[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "matched_results": [],
    "unmatched_results": [
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client cli(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n\n    long status_code = 0;\n\n    if (method == \"GET\") {\n        auto res = cli.Get(URI.c_str());\n        if (res) {\n            status_code = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"POST\") {\n        std::string body = request_data ? request_data->dump() : \"\";\n        auto res = cli.Post(URI.c_str(), headers, body, \"application/json\");\n        if (res) {\n            status_code = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"PUT\") {\n        std::string body = request_data ? request_data->dump() : \"\";\n        auto res = cli.Put(URI.c_str(), headers, body, \"application/json\");\n        if (res) {\n            status_code = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"DELETE\") {\n        auto res = cli.Delete(URI.c_str());\n        if (res) {\n            status_code = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    }\n\n    return status_code;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client cli(location.c_str());\n\n    std::map<std::string, std::string> headers;\n    headers[\"Content-Type\"] = \"application/json\";\n\n    std::string body = request_data ? request_data->dump() : \"\";\n\n    httplib::Response res;\n\n    if (method == \"GET\") {\n        res = cli.Get(URI.c_str());\n    } else if (method == \"POST\") {\n        res = cli.Post(URI.c_str(), body, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = cli.Put(URI.c_str(), body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = cli.Delete(URI.c_str());\n    }\n\n    if (res.status >= 200 && res.status < 300 && response_data) {\n        try {\n            *response_data = json::parse(res.body);\n        } catch (...) {\n            return -1;\n        }\n    }\n\n    return res.status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, const json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client cli(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n    std::string body = request_data ? request_data->dump() : \"\";\n\n    httplib::Result res;\n\n    if (method == \"GET\") {\n        res = cli.Get(URI.c_str(), headers);\n    } else if (method == \"POST\") {\n        res = cli.Post(URI.c_str(), body, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = cli.Put(URI.c_str(), body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = cli.Delete(URI.c_str(), headers);\n    } else {\n        return -1; // Unsupported method\n    }\n\n    if (!res) {\n        return -1; // Connection error\n    }\n\n    long status_code = res->status;\n\n    if (status_code >= 200 && status_code < 300 && response_data) {\n        try {\n            *response_data = json::parse(res->body);\n        } catch (...) {\n            return -2; // JSON parse error\n        }\n    }\n\n    return status_code;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, const json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client client(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n\n    std::string body = request_data ? request_data->dump() : \"\";\n\n    httplib::Result res;\n\n    if (method == \"GET\") {\n        res = client.Get(URI.c_str(), headers);\n    } else if (method == \"POST\") {\n        res = client.Post(URI.c_str(), body, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = client.Put(URI.c_str(), body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = client.Delete(URI.c_str());\n    } else {\n        return 405; // Method Not Allowed\n    }\n\n    if (!res) {\n        return -1; // Connection error\n    }\n\n    long status_code = res->status;\n\n    if (response_data && status_code >= 200 && status_code < 300) {\n        if (res->body.length() > 0) {\n            try {\n                *response_data = json::parse(res->body);\n            } catch (...) {\n                return -2; // JSON parse error\n            }\n        }\n    }\n\n    return status_code;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, const json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client client(location.c_str());\n\n    auto headers = httplib::Headers{\n        {\"Content-Type\", \"application/json\"},\n        {\"Accept\", \"application/json\"}\n    };\n\n    long status = -1;\n\n    if (method == \"GET\") {\n        auto res = client.Get(URI.c_str(), headers);\n        if (res) {\n            status = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"POST\") {\n        std::string body = request_data ? request_data->dump() : \"\";\n        auto res = client.Post(URI.c_str(), headers, body, \"application/json\");\n        if (res) {\n            status = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"PUT\") {\n        std::string body = request_data ? request_data->dump() : \"\";\n        auto res = client.Put(URI.c_str(), headers, body, \"application/json\");\n        if (res) {\n            status = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"DELETE\") {\n        auto res = client.Delete(URI.c_str(), headers);\n        if (res) {\n            status = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    }\n\n    return status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client client(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n\n    std::string body = request_data ? request_data->dump() : \"\";\n\n    httplib::Result res;\n\n    if (method == \"GET\") {\n        res = client.Get(URI.c_str(), headers);\n    } else if (method == \"POST\") {\n        res = client.Post(URI.c_str(), body, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = client.Put(URI.c_str(), body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = client.Delete(URI.c_str(), headers);\n    } else {\n        return -1; // Unsupported method\n    }\n\n    if (!res) {\n        return -1; // Connection error\n    }\n\n    long status_code = res->status;\n\n    if (response_data && (status_code >= 200 && status_code < 300)) {\n        try {\n            *response_data = json::parse(res->body);\n        } catch (...) {\n            return -2; // JSON parsing error\n        }\n    }\n\n    return status_code;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client client(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}, {\"Accept\", \"application/json\"}};\n    std::string body = request_data ? request_data->dump() : \"\";\n\n    httplib::Result res;\n\n    if (method == \"GET\") {\n        res = client.Get(URI.c_str(), headers);\n    } else if (method == \"POST\") {\n        res = client.Post(URI.c_str(), body, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = client.Put(URI.c_str(), body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = client.Delete(URI.c_str(), headers);\n    }\n\n    if (res && res->status >= 200 && res->status < 300 && response_data) {\n        if (res->body.length() > 0) {\n            *response_data = json::parse(res->body);\n        }\n    }\n\n    return res ? static_cast<long>(res->status) : -1;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, const json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client client(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n    std::string body = request_data ? request_data->dump() : \"\";\n\n    httplib::Result res;\n\n    if (method == \"GET\") {\n        res = client.Get(URI.c_str(), headers);\n    } else if (method == \"POST\") {\n        res = client.Post(URI.c_str(), body, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = client.Put(URI.c_str(), body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = client.Delete(URI.c_str(), headers);\n    } else {\n        return -1; // Unsupported method\n    }\n\n    if (!res) {\n        return -1; // Connection error\n    }\n\n    long status_code = res->status;\n\n    if (status_code >= 200 && status_code < 300 && response_data) {\n        if (res->body.find('{') != std::string::npos || res->body.find('[') != std::string::npos) {\n            try {\n                *response_data = json::parse(res->body);\n            } catch (...) {\n                return -2; // JSON parse error\n            }\n        }\n    }\n\n    return status_code;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, const json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client client(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n    std::string body = request_data ? request_data->dump() : \"\";\n\n    httplib::Result res;\n\n    if (method == \"GET\") {\n        res = client.Get(URI.c_str(), headers);\n    } else if (method == \"POST\") {\n        res = client.Post(URI.c_str(), body, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = client.Put(URI.c_str(), body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = client.Delete(URI.c_str(), headers);\n    } else {\n        return -1; // Unsupported method\n    }\n\n    if (!res) {\n        return -1; // Connection error\n    }\n\n    long status_code = res->status;\n\n    if (response_data && status_code >= 200 && status_code < 300) {\n        try {\n            *response_data = json::parse(res->body);\n        } catch (...) {\n            return -2; // JSON parsing error\n        }\n    }\n\n    return status_code;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client client(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n    std::string body = request_data ? request_data->dump() : \"\";\n\n    httplib::Result res;\n\n    if (method == \"GET\") {\n        res = client.Get(URI.c_str(), headers);\n    } else if (method == \"POST\") {\n        res = client.Post(URI.c_str(), body, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = client.Put(URI.c_str(), body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = client.Delete(URI.c_str(), headers);\n    } else {\n        return -1; // Unsupported method\n    }\n\n    if (!res) {\n        return -1; // Connection error\n    }\n\n    long status_code = res->status;\n\n    if (response_data && (status_code >= 200 && status_code < 300)) {\n        try {\n            *response_data = json::parse(res->body);\n        } catch (...) {\n            return -2; // JSON parsing error\n        }\n    }\n\n    return status_code;\n}"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send messages, and receive responses.\n\nFunction Description: The code consists of two functions that together implement a basic TCP client. The first function creates and connects the socket, while the second handles the communication loop with the server.\n\nInput:\n- create_tcp_client:\n  - server_ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n- tcp_client_communication:\n  - sockfd: int - The socket file descriptor returned by create_tcp_client\n\nOutput:\n- create_tcp_client:\n  - Returns: int - The socket file descriptor if successful, -1 if failed\n- tcp_client_communication:\n  - No return value (void), but prints server responses and error messages to console",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(server_ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    while(true){\n        char buf[1024];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message == \"exit\") {\n                break;\n            }\n            send(sockfd, message.c_str(), message.size(), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message == \"exit\") {\n                break;\n            }\n            send(sockfd, message.c_str(), message.size(), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message == \"exit\") break;\n            send(sockfd, message.c_str(), message.size(), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message.empty()) continue;\n            if (send(sockfd, message.c_str(), message.size(), 0) != static_cast<ssize_t>(message.size())) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (write(sockfd, buffer, strlen(buffer)) != strlen(buffer)) {\n                std::cerr << \"Write failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Exiting client...\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr{};\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    \n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            ssize_t valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message == \"exit\") {\n                break;\n            }\n            if (send(sockfd, message.c_str(), message.length(), 0) != static_cast<ssize_t>(message.length())) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message == \"exit\") {\n                break;\n            }\n            send(sockfd, message.c_str(), message.size(), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n\n        int max_sd = sockfd > STDIN_FILENO ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (std::string(buffer) == \"exit\") {\n                break;\n            }\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message == \"exit\") {\n                break;\n            }\n            send(sockfd, message.c_str(), message.size(), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Server: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message == \"exit\") {\n                break;\n            }\n            send(sockfd, message.c_str(), message.size(), 0);\n        }\n    }\n\n    close(sockfd);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send messages, and receive responses.\n\nFunction Description: The code consists of two main functions for creating and managing a TCP client connection. The first function creates and connects a TCP socket to a specified server, while the second function handles the communication loop for sending and receiving messages.\n\nInput:\n- createAndConnectTCPSocket:\n  - ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n\n- tcpClientCommunication:\n  - sockfd: int - The socket file descriptor returned by createAndConnectTCPSocket\n\nOutput:\n- createAndConnectTCPSocket:\n  - Returns: int - The socket file descriptor if successful, -1 if failed\n\n- tcpClientCommunication:\n  - No return value (void), but performs I/O operations until connection is terminated",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int maxFd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        maxFd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(maxFd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int bytesRead = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (bytesRead <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[bytesRead] = '\\0';\n            std::cout << \"Received: \" << buffer;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            std::string message(buffer);\n            if (message == \"exit\") {\n                break;\n            }\n            message += \"\\n\";\n            send(sockfd, message.c_str(), message.size(), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed.\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported.\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection failed.\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int maxFd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        maxFd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(maxFd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error.\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int bytesRead = recv(sockfd, buffer, sizeof(buffer), 0);\n            if (bytesRead <= 0) {\n                if (bytesRead == 0) {\n                    std::cout << \"Server disconnected.\" << std::endl;\n                } else {\n                    std::cerr << \"Receive error.\" << std::endl;\n                }\n                break;\n            }\n            buffer[bytesRead] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n                std::cerr << \"Send failed.\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Closing connection.\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int maxFd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        maxFd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(maxFd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) != static_cast<ssize_t>(strlen(buffer))) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strncmp(buffer, \"exit\", 4) == 0) {\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in serverAddr;\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    \n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int maxFd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        FD_SET(sockfd, &readfds);\n        maxFd = (STDIN_FILENO > sockfd) ? STDIN_FILENO : sockfd;\n\n        int activity = select(maxFd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            }\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in serverAddr;\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Closing connection\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in serverAddr;\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    \n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int maxFd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        maxFd = std::max(sockfd, STDIN_FILENO) + 1;\n\n        int activity = select(maxFd, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::string message;\n            std::getline(std::cin, message);\n            if (message == \"exit\") {\n                break;\n            }\n            send(sockfd, message.c_str(), message.length(), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) != strlen(buffer)) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed.\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int maxFd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        maxFd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(maxFd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Closing connection...\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int maxFd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        FD_SET(sockfd, &readfds);\n        maxFd = (STDIN_FILENO > sockfd) ? STDIN_FILENO : sockfd;\n\n        int activity = select(maxFd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Exiting client...\" << std::endl;\n                break;\n            }\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serverAddr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n\n        int maxFd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n        maxFd++;\n\n        int activity = select(maxFd, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (std::string(buffer) == \"exit\") {\n                break;\n            }\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n    }\n\n    close(sockfd);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server (localhost on port 8888 in this case), and enters a loop where it reads user input from stdin, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed by either side.\n\nInput: None (The server IP and port are hardcoded as 127.0.0.1 and 8888 respectively in the current implementation, but could be parameterized)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)\n\nNote: The function handles socket creation, connection establishment, data transmission, and proper cleanup (socket closing) in case of errors or normal termination.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Connection closed or read error\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n    \n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Connection closed or read error\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    std::string message;\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n        if (message == \"exit\") break;\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a TCP client function in C++ that establishes a connection to a server, sends and receives messages, and maintains the connection until terminated by the user.\n\nFunction Description: The function `create_tcp_client` initializes a TCP client that connects to a specified server IP address. It creates a socket, establishes a connection, and provides interactive communication where the user can send messages to the server and receive responses. The function handles basic error cases and properly closes the connection when done.\n\nInput: \n- `server_ip`: [const char*] - The IP address of the server to connect to in string format (e.g., \"127.0.0.1\")\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any error occurs during socket creation or connection establishment. The function runs indefinitely until manually terminated by the user.\n\nNote: The function uses a default port 6666 for the connection. Error messages are printed to stderr using `perror` for debugging purposes. The communication loop continues until the program is interrupted, allowing continuous message exchange between client and server.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n\n#define DEFAULT_PORT 6666\n\nint create_tcp_client(const char* server_ip) {\n    int connfd = 0;\n    struct sockaddr_in client;\n    \n    client.sin_family = AF_INET;\n    client.sin_port = htons(DEFAULT_PORT);\n    client.sin_addr.s_addr = inet_addr(server_ip);\n    \n    connfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(connfd < 0){\n        perror(\"socket\");\n        return -1;\n    }\n    \n    if(connect(connfd, (struct sockaddr *)&client, sizeof(client)) < 0){\n        perror(\"connect\");\n        close(connfd);\n        return -1;\n    }\n    \n    char buff[1024];\n    bzero(buff, sizeof(buff));\n    recv(connfd, buff, 1024, 0);\n    printf(\"recv : %s \\n\", buff);\n    \n    bzero(buff, sizeof(buff));\n    strcpy(buff, \"this is client \\n\");\n    send(connfd, buff, 1024, 0);\n    \n    while(1){\n        bzero(buff, sizeof(buff));\n        scanf(\"%s\", buff);\n        int p = strlen(buff);\n        buff[p] = '\\0';\n        send(connfd, buff, 1024, 0);\n        printf(\"i have send buff \\n\");\n    }\n    \n    close(connfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":6666\" << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message to send: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            perror(\"Read failed or connection closed\");\n            break;\n        }\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return -1;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":\" << 6666 << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            perror(\"Read failed or connection closed\");\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":\" << 6666 << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            perror(\"Server disconnected or read error\");\n            break;\n        }\n\n        std::cout << \"Received: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":6666\" << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread > 0) {\n            std::cout << \"Server response: \" << buffer << std::endl;\n        } else if (valread == 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        } else {\n            perror(\"Read failed\");\n            break;\n        }\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const int port = 6666;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. You can start sending messages.\\n\";\n\n    while (true) {\n        std::string message;\n        std::cout << \"Client: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return -1;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":\" << 6666 << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message to send: \";\n        std::getline(std::cin, message);\n\n        if (message == \"exit\") break;\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread > 0) {\n            std::cout << \"Received: \" << buffer << std::endl;\n        } else if (valread == 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        } else {\n            perror(\"Read failed\");\n            break;\n        }\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":\" << 6666 << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, 1024);\n        if (valread < 0) {\n            perror(\"Read failed\");\n            break;\n        } else if (valread == 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":\" << 6666 << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            perror(\"Read failed or connection closed\");\n            break;\n        }\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return -1;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":\" << 6666 << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, 1024);\n        if (valread < 0) {\n            perror(\"Read failed\");\n            break;\n        } else if (valread == 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":\" << 6666 << std::endl;\n\n    while (true) {\n        std::string message;\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        char buffer[1024] = {0};\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            perror(\"Server disconnected or read error\");\n            break;\n        }\n        std::cout << \"Received: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return -1;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a C++ class that handles HTTP communication over TCP and UDP protocols, including sending requests and receiving responses from a server.\n\nClass Description: The LinHttpHandler class provides functionality for sending HTTP requests and receiving responses using both TCP (for standard HTTP communication) and UDP (for multicast communication). It includes error handling and resource management through RAII.\n\nAttributes:\n\nSocketCloser: [Nested Class] - A helper class that ensures sockets are properly closed when they go out of scope.\n\nMethods:\n\nsend: [Name](const std::string& msg, const std::string& adr, int port) -> std::string - Sends an HTTP message to the specified address and port using TCP and returns the server's response. Throws system_error on failure.\n\nsendMulticast: [Name](const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) -> std::vector<std::string> - Sends a multicast message using UDP and collects responses within the specified timeout period. Returns a vector of response strings. Throws system_error on failure.\n\nSocketCloser: [Name](int sockFd) -> None - Constructor that takes a socket file descriptor. The destructor automatically closes the socket.",
    "Canonical_solution": "#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <stdexcept>\n#include <system_error>\n#include <vector>\n\nnamespace hueplusplus\n{\nclass LinHttpHandler\n{\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) const\n    {\n        int socketFD = socket(AF_INET, SOCK_STREAM, 0);\n\n        SocketCloser closeMySocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to open socket\"));\n        }\n\n        hostent* server = gethostbyname(adr.c_str());\n        if (server == NULL)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: gethostbyname\"));\n        }\n\n        sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        memcpy(&server_addr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n        if (connect(socketFD, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to connect socket\"));\n        }\n\n        size_t total = msg.length();\n        size_t sent = 0;\n        do\n        {\n            ssize_t bytes = write(socketFD, msg.c_str() + sent, total - sent);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to write message to socket\"));\n            }\n            sent += bytes;\n        } while (sent < total);\n\n        std::string response;\n        char buffer[128] = {};\n        do\n        {\n            ssize_t bytes = read(socketFD, buffer, 127);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to read response from socket\"));\n            }\n            response.append(buffer, bytes);\n        } while (true);\n\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(\n        const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) const\n    {\n        hostent* server;\n        sockaddr_in server_addr;\n\n        memset((char*)&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n\n        server = gethostbyname(adr.c_str());\n        if (!server)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to obtain address of host\"));\n        }\n\n        memcpy((void*)&server_addr.sin_addr, server->h_addr_list[0], server->h_length);\n\n        int socketFD = socket(AF_INET, SOCK_DGRAM, 0);\n        SocketCloser closeMySendSocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to open socket\"));\n        }\n\n        if (sendto(socketFD, msg.c_str(), strlen(msg.c_str()), 0, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to send message\"));\n        }\n\n        std::string response;\n        char buffer[2048] = {};\n\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout)\n        {\n            ssize_t bytesReceived = recv(socketFD, &buffer, 2048, MSG_DONTWAIT);\n            if (bytesReceived < 0 && errno != EAGAIN && errno != EWOULDBLOCK)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to read response from socket\"));\n            }\n            if (bytesReceived > 0)\n            {\n                response.append(buffer, bytesReceived);\n            }\n        }\n\n        std::vector<std::string> returnString;\n        size_t pos = response.find(\"\\r\\n\\r\\n\");\n        size_t prevpos = 0;\n        while (pos != std::string::npos)\n        {\n            returnString.push_back(response.substr(prevpos, pos - prevpos));\n            pos += 4;\n            prevpos = pos;\n            pos = response.find(\"\\r\\n\\r\\n\", pos);\n        }\n        return returnString;\n    }\n\nprivate:\n    class SocketCloser\n    {\n    public:\n        explicit SocketCloser(int sockFd) : s(sockFd) {}\n        ~SocketCloser() { close(s); }\n\n    private:\n        int s;\n    };\n};\n} // namespace hueplusplus",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <system_error>\n#include <chrono>\n#include <thread>\n\nclass LinHttpHandler {\nprivate:\n    class SocketCloser {\n    private:\n        int sockFd;\n    public:\n        explicit SocketCloser(int sockFd) : sockFd(sockFd) {}\n        ~SocketCloser() { if (sockFd >= 0) close(sockFd); }\n    };\n\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket creation failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"invalid address\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connection failed\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"send failed\");\n        }\n\n        char buffer[4096];\n        ssize_t bytesRead = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytesRead < 0) {\n            throw std::system_error(errno, std::system_category(), \"receive failed\");\n        }\n\n        buffer[bytesRead] = '\\0';\n        return std::string(buffer);\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"UDP socket creation failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt failed\");\n        }\n\n        sockaddr_in multicastAddr{};\n        multicastAddr.sin_family = AF_INET;\n        multicastAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &multicastAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"invalid multicast address\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, reinterpret_cast<sockaddr*>(&multicastAddr), sizeof(multicastAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"multicast send failed\");\n        }\n\n        std::vector<std::string> responses;\n        auto start = std::chrono::steady_clock::now();\n        do {\n            fd_set readfds;\n            FD_ZERO(&readfds);\n            FD_SET(sockfd, &readfds);\n\n            timeval tv{};\n            tv.tv_sec = std::chrono::duration_cast<std::chrono::seconds>(timeout).count();\n            tv.tv_usec = (timeout % std::chrono::seconds(1)).count();\n\n            int selectResult = select(sockfd + 1, &readfds, nullptr, nullptr, &tv);\n            if (selectResult < 0) {\n                throw std::system_error(errno, std::system_category(), \"select failed\");\n            } else if (selectResult == 0) {\n                break;\n            }\n\n            char buffer[4096];\n            sockaddr_in senderAddr{};\n            socklen_t senderAddrLen = sizeof(senderAddr);\n            ssize_t bytesRead = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n            if (bytesRead < 0) {\n                throw std::system_error(errno, std::system_category(), \"recvfrom failed\");\n            }\n\n            buffer[bytesRead] = '\\0';\n            responses.emplace_back(buffer);\n\n            auto now = std::chrono::steady_clock::now();\n            if (now - start >= timeout) break;\n\n        } while (true);\n\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <system_error>\n#include <chrono>\n#include <thread>\n\nclass LinHttpHandler {\npublic:\n    class SocketCloser {\n    public:\n        explicit SocketCloser(int sockFd) : sockfd(sockFd) {}\n        ~SocketCloser() { if (sockfd >= 0) close(sockfd); }\n        SocketCloser(const SocketCloser&) = delete;\n        SocketCloser& operator=(const SocketCloser&) = delete;\n        SocketCloser(SocketCloser&& other) noexcept : sockfd(other.sockfd) { other.sockfd = -1; }\n        SocketCloser& operator=(SocketCloser&& other) noexcept {\n            if (this != &other) {\n                sockfd = other.sockfd;\n                other.sockfd = -1;\n            }\n            return *this;\n        }\n    private:\n        int sockfd;\n    };\n\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connect failed\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"send failed\");\n        }\n\n        char buffer[4096];\n        ssize_t bytesRead = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytesRead < 0) {\n            throw std::system_error(errno, std::system_category(), \"recv failed\");\n        }\n\n        return std::string(buffer, bytesRead);\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt reuseaddr failed\");\n        }\n\n        sockaddr_in localAddr{};\n        localAddr.sin_family = AF_INET;\n        localAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n        localAddr.sin_port = htons(port);\n\n        if (bind(sockfd, reinterpret_cast<sockaddr*>(&localAddr), sizeof(localAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"bind failed\");\n        }\n\n        sockaddr_in multicastAddr{};\n        multicastAddr.sin_family = AF_INET;\n        multicastAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &multicastAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, reinterpret_cast<sockaddr*>(&multicastAddr), sizeof(multicastAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        std::vector<std::string> responses;\n        auto start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout) {\n            char buffer[4096];\n            sockaddr_in senderAddr{};\n            socklen_t senderLen = sizeof(senderAddr);\n            ssize_t bytesRead = recvfrom(sockfd, buffer, sizeof(buffer) - 1, MSG_DONTWAIT, reinterpret_cast<sockaddr*>(&senderAddr), &senderLen);\n            if (bytesRead < 0) {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n                    continue;\n                }\n                throw std::system_error(errno, std::system_category(), \"recvfrom failed\");\n            }\n\n            responses.emplace_back(buffer, bytesRead);\n        }\n\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <stdexcept>\n#include <chrono>\n#include <thread>\n\nclass LinHttpHandler {\nprivate:\n    class SocketCloser {\n    public:\n        explicit SocketCloser(int sockFd) : sockfd(sockFd) {}\n        ~SocketCloser() { if (sockfd >= 0) close(sockfd); }\n        void release() { sockfd = -1; }\n    private:\n        int sockfd;\n    };\n\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket\");\n        }\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connect\");\n        }\n\n        if (send(sockfd, msg.c_str(), msg.size(), 0) < 0) {\n            throw std::system_error(errno, std::system_category(), \"send\");\n        }\n\n        char buffer[4096];\n        std::string response;\n        ssize_t bytesRead;\n        while ((bytesRead = recv(sockfd, buffer, sizeof(buffer), 0)) > 0) {\n            response.append(buffer, bytesRead);\n        }\n\n        if (bytesRead < 0) {\n            throw std::system_error(errno, std::system_category(), \"recv\");\n        }\n\n        closer.release();\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port,\n                                           std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket\");\n        }\n        SocketCloser closer(sockfd);\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt(SO_REUSEADDR)\");\n        }\n\n        sockaddr_in localAddr{};\n        localAddr.sin_family = AF_INET;\n        localAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n        localAddr.sin_port = htons(port);\n\n        if (bind(sockfd, reinterpret_cast<sockaddr*>(&localAddr), sizeof(localAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"bind\");\n        }\n\n        sockaddr_in destAddr{};\n        destAddr.sin_family = AF_INET;\n        destAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &destAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton\");\n        }\n\n        if (sendto(sockfd, msg.c_str(), msg.size(), 0, reinterpret_cast<sockaddr*>(&destAddr), sizeof(destAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto\");\n        }\n\n        std::vector<std::string> responses;\n        auto start = std::chrono::steady_clock::now();\n\n        while (std::chrono::steady_clock::now() - start < timeout) {\n            char buffer[4096];\n            sockaddr_in senderAddr{};\n            socklen_t senderLen = sizeof(senderAddr);\n            ssize_t bytesRead = recvfrom(sockfd, buffer, sizeof(buffer), MSG_DONTWAIT,\n                                        reinterpret_cast<sockaddr*>(&senderAddr), &senderLen);\n            if (bytesRead > 0) {\n                responses.emplace_back(buffer, bytesRead);\n            } else if (bytesRead < 0 && errno != EAGAIN && errno != EWOULDBLOCK) {\n                throw std::system_error(errno, std::system_category(), \"recvfrom\");\n            }\n\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n\n        closer.release();\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <memory>\n#include <stdexcept>\n#include <system_error>\n#include <chrono>\n#include <thread>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <cstring>\n\nclass LinHttpHandler {\nprivate:\n    class SocketCloser {\n    public:\n        explicit SocketCloser(int sockFd) : sockfd(sockFd) {}\n        ~SocketCloser() {\n            if (sockfd >= 0) {\n                close(sockfd);\n            }\n        }\n        void release() { sockfd = -1; }\n    private:\n        int sockfd;\n    };\n\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connect failed\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"send failed\");\n        }\n\n        char buffer[4096];\n        ssize_t bytesRead = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytesRead < 0) {\n            throw std::system_error(errno, std::system_category(), \"recv failed\");\n        }\n\n        closer.release(); // Prevent closing since we're done\n        return std::string(buffer, bytesRead);\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port,\n                                           std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        sockaddr_in multicastAddr{};\n        multicastAddr.sin_family = AF_INET;\n        multicastAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &multicastAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt failed\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, reinterpret_cast<sockaddr*>(&multicastAddr), sizeof(multicastAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        std::vector<std::string> responses;\n        auto start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout) {\n            char buffer[4096];\n            sockaddr_in senderAddr{};\n            socklen_t senderAddrLen = sizeof(senderAddr);\n            ssize_t bytesRead = recvfrom(sockfd, buffer, sizeof(buffer) - 1, MSG_DONTWAIT,\n                                         reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n            if (bytesRead < 0) {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n                    continue;\n                }\n                throw std::system_error(errno, std::system_category(), \"recvfrom failed\");\n            }\n\n            responses.emplace_back(buffer, bytesRead);\n        }\n\n        closer.release(); // Prevent closing since we're done\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <system_error>\n#include <chrono>\n#include <thread>\n\nclass LinHttpHandler {\nprivate:\n    class SocketCloser {\n    private:\n        int sockFd;\n    public:\n        explicit SocketCloser(int sockFd) : sockFd(sockFd) {}\n        ~SocketCloser() { if (sockFd >= 0) close(sockFd); }\n    };\n\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connect failed\");\n        }\n\n        if (sendto(sockfd, msg.c_str(), msg.size(), 0, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        char buffer[4096];\n        ssize_t bytesRead = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytesRead < 0) {\n            throw std::system_error(errno, std::system_category(), \"recv failed\");\n        }\n\n        buffer[bytesRead] = '\\0';\n        return std::string(buffer);\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt(SO_REUSEADDR) failed\");\n        }\n\n        sockaddr_in localAddr{};\n        localAddr.sin_family = AF_INET;\n        localAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n        localAddr.sin_port = htons(port);\n\n        if (bind(sockfd, reinterpret_cast<sockaddr*>(&localAddr), sizeof(localAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"bind failed\");\n        }\n\n        ip_mreq mreq{};\n        if (inet_pton(AF_INET, adr.c_str(), &mreq.imr_multiaddr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        mreq.imr_interface.s_addr = htonl(INADDR_ANY);\n        if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt(IP_ADD_MEMBERSHIP) failed\");\n        }\n\n        sockaddr_in destAddr{};\n        destAddr.sin_family = AF_INET;\n        destAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &destAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (sendto(sockfd, msg.c_str(), msg.size(), 0, reinterpret_cast<sockaddr*>(&destAddr), sizeof(destAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        std::vector<std::string> responses;\n        auto start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout) {\n            char buffer[4096];\n            sockaddr_in senderAddr{};\n            socklen_t addrLen = sizeof(senderAddr);\n            ssize_t bytesRead = recvfrom(sockfd, buffer, sizeof(buffer) - 1, MSG_DONTWAIT, reinterpret_cast<sockaddr*>(&senderAddr), &addrLen);\n            if (bytesRead > 0) {\n                buffer[bytesRead] = '\\0';\n                responses.emplace_back(buffer);\n            } else if (bytesRead < 0 && errno != EAGAIN && errno != EWOULDBLOCK) {\n                throw std::system_error(errno, std::system_category(), \"recvfrom failed\");\n            }\n\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <system_error>\n\nclass LinHttpHandler {\npublic:\n    class SocketCloser {\n    public:\n        explicit SocketCloser(int sockFd) : sockfd(sockFd) {}\n        ~SocketCloser() { if (sockfd >= 0) close(sockfd); }\n        void release() { sockfd = -1; }\n    private:\n        int sockfd;\n    };\n\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (::connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connect failed\");\n        }\n\n        if (sendAll(sockfd, msg) < 0) {\n            throw std::system_error(errno, std::system_category(), \"send failed\");\n        }\n\n        return receiveResponse(sockfd);\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt(SO_REUSEADDR) failed\");\n        }\n\n        sockaddr_in localAddr{};\n        localAddr.sin_family = AF_INET;\n        localAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n        localAddr.sin_port = htons(port);\n\n        if (bind(sockfd, reinterpret_cast<sockaddr*>(&localAddr), sizeof(localAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"bind failed\");\n        }\n\n        ip_mreq mreq{};\n        if (inet_pton(AF_INET, adr.c_str(), &mreq.imr_multiaddr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n        mreq.imr_interface.s_addr = htonl(INADDR_ANY);\n\n        if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt(IP_ADD_MEMBERSHIP) failed\");\n        }\n\n        sockaddr_in destAddr{};\n        destAddr.sin_family = AF_INET;\n        destAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &destAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, reinterpret_cast<sockaddr*>(&destAddr), sizeof(destAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        return collectMulticastResponses(sockfd, timeout);\n    }\n\nprivate:\n    ssize_t sendAll(int sockfd, const std::string& msg) {\n        const char* ptr = msg.data();\n        size_t left = msg.size();\n        while (left > 0) {\n            ssize_t sent = ::send(sockfd, ptr, left, 0);\n            if (sent < 0) return -1;\n            ptr += sent;\n            left -= sent;\n        }\n        return msg.size() - left;\n    }\n\n    std::string receiveResponse(int sockfd) {\n        std::string response;\n        char buffer[4096];\n        ssize_t received;\n        while ((received = recv(sockfd, buffer, sizeof(buffer), 0)) > 0) {\n            response.append(buffer, received);\n        }\n        return response;\n    }\n\n    std::vector<std::string> collectMulticastResponses(int sockfd, std::chrono::steady_clock::duration timeout) {\n        std::vector<std::string> responses;\n        char buffer[8192];\n        auto start = std::chrono::steady_clock::now();\n\n        while (true) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - start >= timeout) break;\n\n            timeval tv{};\n            tv.tv_sec = static_cast<decltype(tv.tv_sec)>((timeout - (now - start)).count() / 1000000);\n            tv.tv_usec = static_cast<decltype(tv.tv_usec)>((timeout - (now - start)).count() % 1000000);\n\n            setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n\n            sockaddr_in senderAddr{};\n            socklen_t senderAddrLen = sizeof(senderAddr);\n            ssize_t received = recvfrom(sockfd, buffer, sizeof(buffer), 0,\n                                        reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n            if (received < 0) continue;\n\n            responses.emplace_back(buffer, received);\n        }\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <system_error>\n#include <chrono>\n#include <thread>\n#include <mutex>\n\nclass LinHttpHandler {\npublic:\n    class SocketCloser {\n    public:\n        explicit SocketCloser(int sockFd) : sockfd(sockFd) {}\n        ~SocketCloser() {\n            if (sockfd >= 0) {\n                close(sockfd);\n            }\n        }\n    private:\n        int sockfd;\n    };\n\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connect failed\");\n        }\n\n        if (sendto(sockfd, msg.c_str(), msg.size(), 0, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"send failed\");\n        }\n\n        char buffer[4096];\n        ssize_t bytesRead = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytesRead < 0) {\n            throw std::system_error(errno, std::system_category(), \"recv failed\");\n        }\n\n        buffer[bytesRead] = '\\0';\n        return std::string(buffer);\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        sockaddr_in multicastAddr{};\n        multicastAddr.sin_family = AF_INET;\n        multicastAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &multicastAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt failed\");\n        }\n\n        sockaddr_in localAddr{};\n        localAddr.sin_family = AF_INET;\n        localAddr.sin_port = htons(0);\n        localAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n        if (bind(sockfd, reinterpret_cast<sockaddr*>(&localAddr), sizeof(localAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"bind failed\");\n        }\n\n        if (sendto(sockfd, msg.c_str(), msg.size(), 0, reinterpret_cast<sockaddr*>(&multicastAddr), sizeof(multicastAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        std::vector<std::string> responses;\n        auto start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout) {\n            char buffer[4096];\n            sockaddr_in senderAddr{};\n            socklen_t senderAddrLen = sizeof(senderAddr);\n            ssize_t bytesRead = recvfrom(sockfd, buffer, sizeof(buffer) - 1, MSG_DONTWAIT, reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n            if (bytesRead > 0) {\n                buffer[bytesRead] = '\\0';\n                responses.emplace_back(buffer);\n            } else if (bytesRead == 0) {\n                break;\n            } else {\n                std::this_thread::sleep_for(std::chrono::milliseconds(10));\n            }\n        }\n\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <system_error>\n#include <chrono>\n#include <thread>\n\nclass LinHttpHandler {\nprivate:\n    class SocketCloser {\n    private:\n        int sockFd;\n    public:\n        explicit SocketCloser(int sockFd) : sockFd(sockFd) {}\n        ~SocketCloser() { if (sockFd >= 0) close(sockFd); }\n    };\n\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket creation failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"invalid address\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connection failed\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, nullptr, 0) < 0) {\n            throw std::system_error(errno, std::system_category(), \"send failed\");\n        }\n\n        char buffer[4096];\n        ssize_t bytesRead = recv(sockfd, buffer, sizeof(buffer), 0);\n        if (bytesRead < 0) {\n            throw std::system_error(errno, std::system_category(), \"receive failed\");\n        }\n\n        return std::string(buffer, bytesRead);\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"UDP socket creation failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setting broadcast option failed\");\n        }\n\n        sockaddr_in multicastAddr{};\n        multicastAddr.sin_family = AF_INET;\n        multicastAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &multicastAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"invalid multicast address\");\n        }\n\n        if (sendto(sockfd, msg.data(), msg.size(), 0, reinterpret_cast<sockaddr*>(&multicastAddr), sizeof(multicastAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"multicast send failed\");\n        }\n\n        std::vector<std::string> responses;\n        auto start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout) {\n            char buffer[4096];\n            sockaddr_in senderAddr{};\n            socklen_t addrLen = sizeof(senderAddr);\n            ssize_t bytesRead = recvfrom(sockfd, buffer, sizeof(buffer), MSG_DONTWAIT, reinterpret_cast<sockaddr*>(&senderAddr), &addrLen);\n            if (bytesRead > 0) {\n                responses.emplace_back(buffer, bytesRead);\n            } else if (bytesRead == 0 || (bytesRead < 0 && errno != EAGAIN && errno != EWOULDBLOCK)) {\n                break;\n            }\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <system_error>\n#include <chrono>\n#include <thread>\n\nclass LinHttpHandler {\npublic:\n    class SocketCloser {\n    public:\n        explicit SocketCloser(int sockFd) : sockfd(sockFd) {}\n        ~SocketCloser() {\n            if (sockfd >= 0) {\n                close(sockfd);\n            }\n        }\n    private:\n        int sockfd;\n    };\n\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connect failed\");\n        }\n\n        if (sendto(sockfd, msg.c_str(), msg.size(), 0, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        char buffer[4096];\n        ssize_t bytesRead = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytesRead < 0) {\n            throw std::system_error(errno, std::system_category(), \"recv failed\");\n        }\n\n        return std::string(buffer, bytesRead);\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        sockaddr_in multicastAddr{};\n        multicastAddr.sin_family = AF_INET;\n        multicastAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &multicastAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt failed\");\n        }\n\n        if (sendto(sockfd, msg.c_str(), msg.size(), 0, reinterpret_cast<sockaddr*>(&multicastAddr), sizeof(multicastAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        std::vector<std::string> responses;\n        timeval tv{};\n        tv.tv_sec = static_cast<long>(std::chrono::duration_cast<std::chrono::seconds>(timeout).count());\n        tv.tv_usec = static_cast<long>((timeout % std::chrono::seconds(1)).count());\n\n        if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt failed\");\n        }\n\n        char buffer[4096];\n        sockaddr_in senderAddr{};\n        socklen_t senderAddrLen = sizeof(senderAddr);\n\n        while (true) {\n            ssize_t bytesRead = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0,\n                                         reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n            if (bytesRead < 0) {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    break; // Timeout\n                }\n                throw std::system_error(errno, std::system_category(), \"recvfrom failed\");\n            }\n\n            responses.emplace_back(buffer, bytesRead);\n        }\n\n        return responses;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <system_error>\n#include <chrono>\n#include <thread>\n\nclass LinHttpHandler {\nprivate:\n    class SocketCloser {\n    public:\n        explicit SocketCloser(int sockFd) : sockfd(sockFd) {}\n        ~SocketCloser() {\n            if (sockfd >= 0) {\n                close(sockfd);\n            }\n        }\n        void release() { sockfd = -1; }\n    private:\n        int sockfd;\n    };\n\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (connect(sockfd, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"connect failed\");\n        }\n\n        if (send(sockfd, msg.c_str(), msg.size(), 0) < 0) {\n            throw std::system_error(errno, std::system_category(), \"send failed\");\n        }\n\n        char buffer[4096];\n        std::string response;\n        ssize_t bytesReceived;\n        while ((bytesReceived = recv(sockfd, buffer, sizeof(buffer) - 1, 0)) > 0) {\n            buffer[bytesReceived] = '\\0';\n            response += buffer;\n        }\n\n        if (bytesReceived < 0) {\n            throw std::system_error(errno, std::system_category(), \"recv failed\");\n        }\n\n        closer.release();\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd < 0) {\n            throw std::system_error(errno, std::system_category(), \"socket failed\");\n        }\n        SocketCloser closer(sockfd);\n\n        int enable = 1;\n        if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &enable, sizeof(enable)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"setsockopt failed\");\n        }\n\n        sockaddr_in broadcastAddr{};\n        broadcastAddr.sin_family = AF_INET;\n        broadcastAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &broadcastAddr.sin_addr) <= 0) {\n            throw std::system_error(errno, std::system_category(), \"inet_pton failed\");\n        }\n\n        if (sendto(sockfd, msg.c_str(), msg.size(), 0, reinterpret_cast<sockaddr*>(&broadcastAddr), sizeof(broadcastAddr)) < 0) {\n            throw std::system_error(errno, std::system_category(), \"sendto failed\");\n        }\n\n        std::vector<std::string> responses;\n        fd_set readfds;\n        timeval tv;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        tv.tv_sec = std::chrono::duration_cast<std::chrono::seconds>(timeout).count();\n        tv.tv_usec = (timeout % std::chrono::seconds(1)).count() * 1000;\n\n        int selectResult = select(sockfd + 1, &readfds, nullptr, nullptr, &tv);\n        if (selectResult > 0) {\n            char buffer[4096];\n            sockaddr_in senderAddr;\n            socklen_t senderAddrLen = sizeof(senderAddr);\n            ssize_t bytesReceived = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n            if (bytesReceived >= 0) {\n                buffer[bytesReceived] = '\\0';\n                responses.emplace_back(buffer);\n            }\n        } else if (selectResult < 0) {\n            throw std::system_error(errno, std::system_category(), \"select failed\");\n        }\n\n        closer.release();\n        return responses;\n    }\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends a single character, receives a response, and then closes the connection.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server address and port, sends a predefined character ('A') to the server, reads the server's response, prints the received character, and finally closes the socket. This demonstrates basic TCP client functionality using BSD sockets.\n\nInput: None (The server address and port are hardcoded as 127.0.0.1:9736 in the function)\n\nOutput: \n- Returns 0 on successful execution\n- Prints the received character from the server\n- Exits with error code 1 if connection fails",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint tcp_client_communication()\n{\n    int sockfd = -1;\n    int len = 0;\n    struct sockaddr_in address;\n    int result;\n    char ch = 'A';\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    address.sin_port = htons(9736);\n    len = sizeof(address);\n    \n    result = connect(sockfd, (struct sockaddr*)&address, len);\n\n    if(result == -1)\n    {\n        perror(\"ops:client\\n\");\n        exit(1);\n    }\n    \n    write(sockfd, &ch, 1);\n    read(sockfd, &ch, 1);\n    printf(\"char form server = %c\\n\", ch);\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    send(sock, &send_char, 1, 0);\n    read(sock, &recv_char, 1);\n    std::cout << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    send(sock, &send_char, sizeof(send_char), 0);\n    read(sock, &recv_char, sizeof(recv_char));\n    std::cout << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (send(sock, &send_char, sizeof(send_char), 0) != sizeof(send_char)) {\n        std::cerr << \"Send failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (recv(sock, &recv_char, sizeof(recv_char), 0) > 0) {\n        std::cout << recv_char << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (send(sock, &send_char, sizeof(send_char), 0) != sizeof(send_char)) {\n        std::cerr << \"Send failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (recv(sock, &recv_char, sizeof(recv_char), 0) > 0) {\n        std::cout << recv_char << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    send(sock, &send_char, sizeof(send_char), 0);\n    read(sock, &recv_char, sizeof(recv_char));\n    std::cout << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char received_char;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    char send_char = 'A';\n    send(sock, &send_char, 1, 0);\n\n    if (read(sock, &received_char, 1) > 0) {\n        std::cout << received_char << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    send(sock, &send_char, sizeof(send_char), 0);\n    read(sock, &recv_char, sizeof(recv_char));\n    std::cout << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    send(sock, &send_char, 1, 0);\n    read(sock, &recv_char, 1);\n    std::cout << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        exit(1);\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        exit(1);\n    }\n\n    send(sock, &send_char, sizeof(send_char), 0);\n    read(sock, &recv_char, sizeof(recv_char));\n    std::cout << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char send_char = 'A';\n    char recv_char = '\\0';\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return 1;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        return 1;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        return 1;\n    }\n\n    send(sock, &send_char, 1, 0);\n    read(sock, &recv_char, 1);\n    std::cout << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send data, and receive responses.\n\nFunction Description: The code consists of two main functions for creating and communicating with a TCP client. The first function creates and connects a TCP socket to a specified server, while the second function handles the communication loop for sending and receiving data.\n\nInput:\n- create_tcp_client:\n  - server_ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n- tcp_client_communication:\n  - sockfd: int - The socket file descriptor returned by create_tcp_client\n\nOutput:\n- create_tcp_client:\n  - Returns: int - The socket file descriptor on success, -1 on failure\n- tcp_client_communication:\n  - No return value (void), but performs continuous communication until connection is terminated",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(server_ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int activity;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n\n        activity = select(sockfd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (std::string(buffer) == \"exit\") {\n                break;\n            }\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            std::cout << \"Received: \" << std::string(buffer, valread) << std::endl;\n            memset(buffer, 0, sizeof(buffer));\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (std::string(buffer) == \"exit\") {\n                break;\n            }\n            send(sockfd, buffer, strlen(buffer), 0);\n            memset(buffer, 0, sizeof(buffer));\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) != strlen(buffer)) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Exiting communication\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n\n        int max_sd = sockfd > STDIN_FILENO ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (std::string(buffer) == \"exit\") {\n                break;\n            }\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n\n        if (send(sockfd, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int activity;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n\n        activity = select(sockfd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (std::string(buffer) == \"exit\") {\n                break;\n            }\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) != static_cast<ssize_t>(strlen(buffer))) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Closing connection\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            memset(buffer, 0, sizeof(buffer));\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (std::string(buffer) == \"exit\") {\n                break;\n            }\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer));\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) != static_cast<ssize_t>(strlen(buffer))) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Closing connection\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    fd_set readfds;\n    int max_sd;\n\n    while (true) {\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        FD_SET(STDIN_FILENO, &readfds);\n        max_sd = (sockfd > STDIN_FILENO) ? sockfd : STDIN_FILENO;\n\n        int activity = select(max_sd + 1, &readfds, nullptr, nullptr, nullptr);\n\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            int valread = read(sockfd, buffer, sizeof(buffer) - 1);\n            if (valread <= 0) {\n                std::cout << \"Server disconnected\" << std::endl;\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &readfds)) {\n            std::cin.getline(buffer, sizeof(buffer));\n            if (send(sockfd, buffer, strlen(buffer), 0) != strlen(buffer)) {\n                std::cerr << \"Send failed\" << std::endl;\n                break;\n            }\n            if (strcmp(buffer, \"exit\") == 0) {\n                std::cout << \"Closing connection\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    close(sockfd);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Implement a TCP client socket class in C++ that handles connection establishment, data transmission, and connection management with a remote server, supporting both IPv4 and IPv6 protocols.\n\nClass Description: The ClientSocket class provides TCP client functionality with support for both IPv4 and IPv6 connections. It handles socket creation, connection establishment with timeout support, send buffer configuration, and connection cleanup. The class is designed to work within a multi-threaded context and supports encryption parameters.\n\nAttributes:\n- dest_: std::string - Destination hostname or IP address to connect to\n- threadCtx_: ThreadCtx& - Reference to thread context containing configuration options\n- sa_: struct addrinfo - Address information structure for socket configuration\n- socket_: std::unique_ptr<WdtSocket> - Smart pointer to the underlying socket implementation\n- peerIp_: std::string - IP address of the connected peer\n\nMethods:\n- Constructor: ClientSocket(ThreadCtx& threadCtx, const string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval) -> void - Initializes the client socket with destination, port, and encryption parameters\n- connect: connect() -> ErrorCode - Establishes connection to the remote server with timeout handling, returns connection status\n- getPeerIp: getPeerIp() -> const std::string& - Returns the IP address of the connected peer\n- setSendBufferSize: setSendBufferSize() -> void - Configures the socket's send buffer size based on thread context options\n- closeConnection: closeConnection() -> void [private] - Closes the active socket connection",
    "Canonical_solution": "#include <fcntl.h>\n#include <folly/Conv.h>\n#include <folly/ScopeGuard.h>\n#include <glog/logging.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <wdt/Reporting.h>\n#include <wdt/util/ClientSocket.h>\n\nnamespace facebook {\nnamespace wdt {\n\nusing std::string;\n\nclass ClientSocket {\npublic:\n  ClientSocket(ThreadCtx &threadCtx, const string &dest,\n               const int port,\n               const EncryptionParams &encryptionParams,\n               int64_t ivChangeInterval)\n      : dest_(dest), threadCtx_(threadCtx) {\n    memset(&sa_, 0, sizeof(sa_));\n    socket_ = std::make_unique<WdtSocket>(threadCtx, port, encryptionParams,\n                                          ivChangeInterval, nullptr);\n    if (threadCtx_.getOptions().ipv6) {\n      sa_.ai_family = AF_INET6;\n    }\n    if (threadCtx_.getOptions().ipv4) {\n      sa_.ai_family = AF_INET;\n    }\n    sa_.ai_socktype = SOCK_STREAM;\n  }\n\n  ErrorCode connect() {\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    WDT_CHECK(fd < 0) << \"Previous connection not closed \" << fd << \" \" << port;\n    \n    struct addrinfo *infoList = nullptr;\n    auto guard = folly::makeGuard([&] {\n      if (infoList) {\n        freeaddrinfo(infoList);\n      }\n    });\n    \n    string portStr = folly::to<string>(port);\n    int res = getaddrinfo(dest_.c_str(), portStr.c_str(), &sa_, &infoList);\n    if (res) {\n      WLOG(ERROR) << \"Failed getaddrinfo \" << dest_ << \" , \" << port << \" : \"\n                  << res << \" : \" << gai_strerror(res);\n      return CONN_ERROR;\n    }\n    \n    int count = 0;\n    for (struct addrinfo *info = infoList; info != nullptr;\n         info = info->ai_next) {\n      ++count;\n      std::string host, port_2;\n      WdtSocket::getNameInfo(info->ai_addr, info->ai_addrlen, host, port_2);\n      WVLOG(2) << \"will connect to \" << host << \" \" << port_2;\n      \n      fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);\n      if (fd == -1) {\n        WPLOG(WARNING) << \"Error making socket for port_2 \" << port_2;\n        continue;\n      }\n      \n      socket_->setFd(fd);\n      setSendBufferSize();\n\n      int sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg |= O_NONBLOCK;\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res < 0) {\n        WPLOG(ERROR) << \"Failed to make the socket non-blocking \" << port_2\n                     << \" sock \" << sockArg << \" res \" << res;\n        closeConnection();\n        continue;\n      }\n\n      if (::connect(fd, info->ai_addr, info->ai_addrlen) != 0) {\n        if (errno != EINPROGRESS) {\n          WPLOG(INFO) << \"Error connecting on \" << host << \" \" << port_2;\n          closeConnection();\n          continue;\n        }\n        \n        auto startTime = Clock::now();\n        int connectTimeout = threadCtx_.getOptions().connect_timeout_millis;\n\n        while (true) {\n          if (threadCtx_.getAbortChecker()->shouldAbort()) {\n            WLOG(ERROR) << \"Transfer aborted during connect \" << port_2 << \" \"\n                        << fd;\n            closeConnection();\n            return ABORT;\n          }\n          \n          int timeElapsed = durationMillis(Clock::now() - startTime);\n          if (timeElapsed >= connectTimeout) {\n            WVLOG(1) << \"connect() timed out\" << host << \" \" << port_2;\n            closeConnection();\n            return CONN_ERROR_RETRYABLE;\n          }\n          \n          int pollTimeout =\n              std::min(connectTimeout - timeElapsed,\n                       threadCtx_.getOptions().abort_check_interval_millis);\n          struct pollfd pollFds[] = {{fd, POLLOUT, 0}};\n\n          if ((res = poll(pollFds, 1, pollTimeout)) <= 0) {\n            if (errno == EINTR) {\n              WVLOG(1) << \"poll() call interrupted. retrying... \" << port_2;\n              continue;\n            }\n            if (res == 0) {\n              WVLOG(1) << \"poll() timed out \" << host << \" \" << port_2;\n              continue;\n            }\n            WPLOG(ERROR) << \"poll() failed \" << host << \" \" << port_2 << \" \"\n                         << fd;\n            closeConnection();\n            return CONN_ERROR;\n          }\n          break;\n        }\n\n        int connectResult;\n        socklen_t len = sizeof(connectResult);\n        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &connectResult, &len) < 0) {\n          WPLOG(WARNING) << \"getsockopt() failed\";\n          closeConnection();\n          continue;\n        }\n        if (connectResult != 0) {\n          WLOG(WARNING) << \"connect did not succeed on \" << host << \" \" << port_2\n                        << \" : \" << strerrorStr(connectResult);\n          closeConnection();\n          continue;\n        }\n      }\n\n      sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg &= (~O_NONBLOCK);\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res == -1) {\n        WPLOG(ERROR) << \"Could not make the socket blocking \" << port_2;\n        closeConnection();\n        continue;\n      }\n      \n      WVLOG(1) << \"Successful connect on \" << fd;\n      peerIp_ = host;\n      sa_ = *info;\n      break;\n    }\n    \n    if (socket_->getFd() < 0) {\n      if (count > 1) {\n        WLOG(INFO) << \"Unable to connect to either of the \" << count << \" addrs\";\n      }\n      return CONN_ERROR_RETRYABLE;\n    }\n    \n    socket_->setSocketTimeouts();\n    socket_->setDscp(threadCtx_.getOptions().dscp);\n    return OK;\n  }\n\n  const std::string &getPeerIp() const {\n    return peerIp_;\n  }\n\n  void setSendBufferSize() {\n    int bufSize = threadCtx_.getOptions().send_buffer_size;\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    if (bufSize <= 0) {\n      return;\n    }\n    int status =\n        ::setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bufSize, sizeof(bufSize));\n    if (status != 0) {\n      WPLOG(ERROR) << \"Failed to set send buffer \" << port << \" size \" << bufSize\n                   << \" fd \" << fd;\n      return;\n    }\n    WVLOG(1) << \"Send buffer size set to \" << bufSize << \" port \" << port;\n  }\n\nprivate:\n  std::string dest_;\n  ThreadCtx &threadCtx_;\n  struct addrinfo sa_;\n  std::unique_ptr<WdtSocket> socket_;\n  std::string peerIp_;\n\n  void closeConnection() {\n    socket_->close();\n  }\n};\n\n}  // namespace wdt\n}  // namespace facebook",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include \"ThreadCtx.h\"\n#include \"WdtSocket.h\"\n#include \"EncryptionParams.h\"\n\nclass ClientSocket {\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n\n    void closeConnection() {\n        if (socket_) {\n            socket_->close();\n            socket_.reset();\n        }\n    }\n\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n        : threadCtx_(threadCtx), dest_(dest) {\n        memset(&sa_, 0, sizeof(sa_));\n        sa_.ai_family = AF_UNSPEC;\n        sa_.ai_socktype = SOCK_STREAM;\n        sa_.ai_protocol = IPPROTO_TCP;\n\n        std::string portStr = std::to_string(port);\n        socket_ = std::make_unique<WdtSocket>(encryptionParams, ivChangeInterval);\n    }\n\n    ErrorCode connect() {\n        struct addrinfo* result = nullptr;\n        int status = getaddrinfo(dest_.c_str(), nullptr, &sa_, &result);\n        if (status != 0) {\n            return ErrorCode::ADDRESS_RESOLUTION_FAILED;\n        }\n\n        for (struct addrinfo* rp = result; rp != nullptr; rp = rp->ai_next) {\n            if (rp->ai_family == AF_INET || rp->ai_family == AF_INET6) {\n                char ipstr[INET6_ADDRSTRLEN];\n                void* addr;\n                if (rp->ai_family == AF_INET) {\n                    struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(rp->ai_addr);\n                    addr = &(ipv4->sin_addr);\n                } else {\n                    struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(rp->ai_addr);\n                    addr = &(ipv6->sin6_addr);\n                }\n                inet_ntop(rp->ai_family, addr, ipstr, sizeof(ipstr));\n                peerIp_ = std::string(ipstr);\n\n                int sockfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n                if (sockfd == -1) continue;\n\n                if (!socket_->setFd(sockfd)) {\n                    freeaddrinfo(result);\n                    closeConnection();\n                    return ErrorCode::SOCKET_ASSIGNMENT_FAILED;\n                }\n\n                if (socket_->connect(rp->ai_addr, rp->ai_addrlen, threadCtx_.getConnectTimeoutMs()) == 0) {\n                    freeaddrinfo(result);\n                    setSendBufferSize();\n                    return ErrorCode::OK;\n                }\n\n                socket_->close();\n            }\n        }\n\n        freeaddrinfo(result);\n        closeConnection();\n        return ErrorCode::CONNECTION_FAILED;\n    }\n\n    const std::string& getPeerIp() const {\n        return peerIp_;\n    }\n\n    void setSendBufferSize() {\n        int bufferSize = threadCtx_.getSocketBufferSize();\n        if (bufferSize > 0) {\n            socket_->setSendBufferSize(bufferSize);\n        }\n    }\n};",
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include \"WdtSocket.h\"  // Assuming WdtSocket is defined in this header\n\nusing namespace std;\n\nclass ThreadCtx {\npublic:\n    struct Options {\n        int sendBufferSize = 0;\n        int connectTimeoutMillis = 0;\n    } options;\n};\n\nstruct EncryptionParams {};\n\nclass ErrorCode {};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n        : threadCtx_(threadCtx), dest_(dest) {\n        struct addrinfo hints;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;       // Allow IPv4 or IPv6\n        hints.ai_socktype = SOCK_STREAM;   // TCP\n        hints.ai_protocol = IPPROTO_TCP;\n\n        char portStr[16];\n        snprintf(portStr, sizeof(portStr), \"%d\", port);\n\n        if (getaddrinfo(dest.c_str(), portStr, &hints, &sa_) != 0) {\n            // Handle error\n        }\n\n        socket_ = make_unique<WdtSocket>(sa_->ai_family, sa_->ai_socktype, sa_->ai_protocol);\n    }\n\n    ErrorCode connect() {\n        socket_->setBlocking(false);\n\n        if (socket_->connect(sa_) < 0) {\n            // Handle connection error\n        }\n\n        setSendBufferSize();\n\n        return ErrorCode();  // Success\n    }\n\n    const string& getPeerIp() const {\n        return peerIp_;\n    }\n\n    void setSendBufferSize() {\n        if (threadCtx_.options.sendBufferSize > 0) {\n            socket_->setSendBufferSize(threadCtx_.options.sendBufferSize);\n        }\n    }\n\nprivate:\n    void closeConnection() {\n        socket_->close();\n    }\n\n    string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo* sa_;\n    unique_ptr<WdtSocket> socket_;\n    string peerIp_;\n};",
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include \"WdtSocket.h\"  // Assuming WdtSocket is defined here\n\nclass ThreadCtx {\npublic:\n    struct Options {\n        int sendBufferSize = 0;\n        int connectTimeoutMillis = 0;\n    } options;\n};\n\nstruct EncryptionParams {};\n\nclass ErrorCode {};\n\nclass ClientSocket {\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n\n    void closeConnection() {\n        if (socket_) {\n            socket_->close();\n            socket_.reset();\n        }\n    }\n\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n        : threadCtx_(threadCtx), dest_(dest) {\n        struct addrinfo hints = {};\n        hints.ai_family = AF_UNSPEC;       // Allow IPv4 or IPv6\n        hints.ai_socktype = SOCK_STREAM;   // TCP stream sockets\n        hints.ai_protocol = IPPROTO_TCP;   // TCP protocol\n\n        std::string portStr = std::to_string(port);\n        int status = getaddrinfo(dest.c_str(), portStr.c_str(), &hints, &sa_);\n        if (status != 0) {\n            // Handle error\n        }\n    }\n\n    ErrorCode connect() {\n        socket_.reset(new WdtSocket());\n        if (!socket_->init(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol)) {\n            return ErrorCode(); // Error in socket creation\n        }\n\n        setSendBufferSize();\n\n        int timeoutMs = threadCtx_.options.connectTimeoutMillis;\n        if (!socket_->connect(&sa_, timeoutMs)) {\n            closeConnection();\n            return ErrorCode(); // Connection failed\n        }\n\n        char ipstr[INET6_ADDRSTRLEN];\n        void* addr;\n        if (sa_.ai_family == AF_INET) { // IPv4\n            struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n            addr = &(ipv4->sin_addr);\n        } else { // IPv6\n            struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n            addr = &(ipv6->sin6_addr);\n        }\n        inet_ntop(sa_.ai_family, addr, ipstr, sizeof(ipstr));\n        peerIp_ = ipstr;\n\n        return ErrorCode(); // Success\n    }\n\n    const std::string& getPeerIp() const {\n        return peerIp_;\n    }\n\n    void setSendBufferSize() {\n        if (socket_ && threadCtx_.options.sendBufferSize > 0) {\n            socket_->setSendBufferSize(threadCtx_.options.sendBufferSize);\n        }\n    }\n};"
    ],
    "unmatched_results": [
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include \"WdtSocket.h\"  // Assuming WdtSocket is defined in this header\n\nclass ThreadCtx {\npublic:\n    int sendBufferSize;\n    // Other configuration options...\n};\n\nstruct EncryptionParams {\n    // Encryption-related parameters\n};\n\nenum class ErrorCode {\n    SUCCESS,\n    TIMEOUT,\n    CONNECTION_FAILED,\n    // Other error codes...\n};\n\nclass ClientSocket {\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n\n    void closeConnection() {\n        if (socket_) {\n            socket_->close();\n            socket_.reset();\n        }\n    }\n\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n        : threadCtx_(threadCtx), dest_(dest) {\n        memset(&sa_, 0, sizeof(sa_));\n        sa_.ai_family = AF_UNSPEC;       // Allow IPv4 or IPv6\n        sa_.ai_socktype = SOCK_STREAM;   // TCP\n        sa_.ai_protocol = IPPROTO_TCP;\n\n        // Address info setup for destination and port\n        std::string portStr = std::to_string(port);\n        struct addrinfo* result;\n        int status = getaddrinfo(dest.c_str(), portStr.c_str(), &sa_, &result);\n        if (status != 0) {\n            // Handle error appropriately\n        } else {\n            // Assume WdtSocket constructor takes addrinfo*\n            socket_ = std::make_unique<WdtSocket>(result, encryptionParams, ivChangeInterval);\n            freeaddrinfo(result);\n        }\n    }\n\n    ErrorCode connect() {\n        if (!socket_) {\n            return ErrorCode::CONNECTION_FAILED;\n        }\n\n        // Simulate timeout handling with a simple check\n        bool connected = socket_->connect();  // WdtSocket should handle the actual connection logic\n        if (!connected) {\n            return ErrorCode::CONNECTION_FAILED;\n        }\n\n        // Retrieve peer IP address\n        char ipstr[INET6_ADDRSTRLEN];\n        struct sockaddr* sa = socket_->getPeerAddr();\n        if (sa->sa_family == AF_INET) {\n            struct sockaddr_in* sa4 = reinterpret_cast<struct sockaddr_in*>(sa);\n            inet_ntop(AF_INET, &(sa4->sin_addr), ipstr, INET_ADDRSTRLEN);\n        } else {\n            struct sockaddr_in6* sa6 = reinterpret_cast<struct sockaddr_in6*>(sa);\n            inet_ntop(AF_INET6, &(sa6->sin6_addr), ipstr, INET6_ADDRSTRLEN);\n        }\n        peerIp_ = std::string(ipstr);\n\n        return ErrorCode::SUCCESS;\n    }\n\n    const std::string& getPeerIp() const {\n        return peerIp_;\n    }\n\n    void setSendBufferSize() {\n        if (socket_ && threadCtx_.sendBufferSize > 0) {\n            socket_->setSendBufferSize(threadCtx_.sendBufferSize);\n        }\n    }\n};",
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include \"ThreadCtx.h\"\n#include \"WdtSocket.h\"\n#include \"EncryptionParams.h\"\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp() const;\n    void setSendBufferSize();\n\nprivate:\n    void closeConnection();\n    \n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n};",
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include \"WdtSocket.h\"  // Assuming WdtSocket is defined here\n\nclass ThreadCtx {\npublic:\n    int sendBufferSize;\n    // Other configuration options\n};\n\nstruct EncryptionParams {\n    // Encryption-related parameters\n};\n\nenum class ErrorCode {\n    SUCCESS,\n    TIMEOUT,\n    CONNECTION_FAILED,\n    // Other error codes\n};\n\nclass ClientSocket {\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n\n    void closeConnection() {\n        if (socket_) {\n            socket_->close();\n            socket_.reset();\n        }\n    }\n\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n        : threadCtx_(threadCtx), dest_(dest) {\n        // Initialize address information structure\n        memset(&sa_, 0, sizeof(sa_));\n        sa_.ai_family = AF_UNSPEC;       // Allow IPv4 or IPv6\n        sa_.ai_socktype = SOCK_STREAM;   // TCP stream sockets\n        sa_.ai_protocol = IPPROTO_TCP;   // TCP protocol\n\n        // Additional initialization related to encryption and port\n        // Convert port to string for getaddrinfo\n        char portStr[16];\n        snprintf(portStr, sizeof(portStr), \"%d\", port);\n\n        // Get address info\n        struct addrinfo* result;\n        int status = getaddrinfo(dest.c_str(), portStr, &sa_, &result);\n        if (status != 0) {\n            // Handle error in resolving address\n        } else {\n            // Store resolved address info\n            memcpy(&sa_, result->ai_addr, result->ai_addrlen);\n            freeaddrinfo(result);\n        }\n\n        // Initialize socket with encryption parameters\n        socket_ = std::make_unique<WdtSocket>(encryptionParams, ivChangeInterval);\n    }\n\n    ErrorCode connect() {\n        if (socket_->connect(sa_) < 0) {\n            closeConnection();\n            return ErrorCode::CONNECTION_FAILED;\n        }\n\n        // Set peer IP after successful connection\n        char ipstr[INET6_ADDRSTRLEN];\n        void* addr;\n        if (sa_.ai_family == AF_INET) { // IPv4\n            struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n            addr = &(ipv4->sin_addr);\n        } else { // IPv6\n            struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n            addr = &(ipv6->sin6_addr);\n        }\n        inet_ntop(sa_.ai_family, addr, ipstr, sizeof(ipstr));\n        peerIp_ = ipstr;\n\n        setSendBufferSize();\n        return ErrorCode::SUCCESS;\n    }\n\n    const std::string& getPeerIp() const {\n        return peerIp_;\n    }\n\n    void setSendBufferSize() {\n        socket_->setSendBufferSize(threadCtx_.sendBufferSize);\n    }\n};",
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include \"WdtSocket.h\"  // Assuming WdtSocket is defined elsewhere\n\nclass ThreadCtx {\npublic:\n    int sendBufferSize;\n    // Other configuration options\n};\n\nstruct EncryptionParams {\n    // Encryption-related parameters\n};\n\nenum class ErrorCode {\n    SUCCESS,\n    TIMEOUT,\n    CONNECTION_FAILED,\n    // Other error codes\n};\n\nclass ClientSocket {\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n\n    void closeConnection() {\n        if (socket_) {\n            socket_->close();\n            socket_.reset();\n        }\n    }\n\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n        : threadCtx_(threadCtx), dest_(dest) {\n        // Initialize address info for IPv4/IPv6\n        struct addrinfo hints = {};\n        hints.ai_family = AF_UNSPEC;       // Allow both IPv4 and IPv6\n        hints.ai_socktype = SOCK_STREAM;   // TCP stream sockets\n\n        char portStr[16];\n        snprintf(portStr, sizeof(portStr), \"%d\", port);\n\n        int status = getaddrinfo(dest.c_str(), portStr, &hints, &sa_);\n        if (status != 0) {\n            // Handle error\n        }\n\n        // Create underlying socket implementation\n        socket_ = std::make_unique<WdtSocket>(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    }\n\n    ErrorCode connect() {\n        if (!socket_ || socket_->connect(sa_.ai_addr, sa_.ai_addrlen) < 0) {\n            closeConnection();\n            return ErrorCode::CONNECTION_FAILED;\n        }\n\n        // Set peer IP address\n        char ipstr[INET6_ADDRSTRLEN];\n        void* addr;\n        if (sa_.ai_family == AF_INET) {\n            struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n            addr = &(ipv4->sin_addr);\n        } else {\n            struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n            addr = &(ipv6->sin6_addr);\n        }\n        inet_ntop(sa_.ai_family, addr, ipstr, sizeof(ipstr));\n        peerIp_ = std::string(ipstr);\n\n        setSendBufferSize();\n\n        return ErrorCode::SUCCESS;\n    }\n\n    const std::string& getPeerIp() const {\n        return peerIp_;\n    }\n\n    void setSendBufferSize() {\n        if (socket_) {\n            socket_->setSendBufferSize(threadCtx_.sendBufferSize);\n        }\n    }\n};",
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\nnamespace wdt {\nclass WdtSocket;\nstruct EncryptionParams;\nstruct ThreadCtx;\n}\n\nclass ClientSocket {\npublic:\n    ClientSocket(wdt::ThreadCtx& threadCtx, const std::string& dest, int port, const wdt::EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ~ClientSocket();\n    wdt::ErrorCode connect();\n    const std::string& getPeerIp() const;\n    void setSendBufferSize();\n\nprivate:\n    void closeConnection();\n    std::string dest_;\n    wdt::ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<wdt::WdtSocket> socket_;\n    std::string peerIp_;\n};",
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\nnamespace wdt {\n    class WdtSocket;\n    class ThreadCtx;\n    class EncryptionParams;\n\n    enum ErrorCode {\n        OK,\n        ERROR\n    };\n\n    class ClientSocket {\n    public:\n        ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n        ~ClientSocket();\n\n        ErrorCode connect();\n        const std::string& getPeerIp() const;\n        void setSendBufferSize();\n\n    private:\n        void closeConnection();\n\n        std::string dest_;\n        ThreadCtx& threadCtx_;\n        struct addrinfo sa_;\n        std::unique_ptr<WdtSocket> socket_;\n        std::string peerIp_;\n    };\n}",
      "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\nnamespace wdt {\nclass WdtSocket;\nstruct EncryptionParams;\nstruct ThreadCtx;\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port,\n                 const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ~ClientSocket();\n\n    ErrorCode connect();\n    const std::string& getPeerIp() const;\n    void setSendBufferSize();\n\nprivate:\n    void closeConnection();\n\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n};\n}  // namespace wdt"
    ],
    "match_count": 3,
    "pass@3": 0.7083333333333333,
    "pass@5": 0.9166666666666666
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 8888, respectively, within the function.)\n\nOutput: None (The function prints received messages from the server to the console but does not return any value.)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n        if (input.empty()) continue;\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n        if (message.empty()) continue;\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n        if (message.empty()) continue;\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n        if (message.empty()) continue;\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n        if (input.empty()) continue;\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Connection closed or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n        if (message.empty()) continue;\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n        if (input.empty()) continue;\n\n        if (send(sock, input.c_str(), input.length(), 0) != static_cast<ssize_t>(input.length())) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1023);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n        if (message.empty()) continue;\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected or error occurred\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n        if (message.empty()) continue;\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Connection closed or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 8888;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n        if (message.empty()) continue;\n\n        if (send(sock, message.c_str(), message.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected or error occurred\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a TCP client class that can establish a connection to a server, send and receive data, and handle timeouts for non-blocking operations.\n\nClass Description: The TCPClient class provides functionality for TCP socket communication with a remote server. It supports both blocking and non-blocking operations with timeout capabilities, and handles cross-platform compatibility between Windows and Unix-like systems.\n\nAttributes:\n- address: std::string - The IP address or hostname of the server to connect to\n- port: u16 - The port number of the server to connect to\n- main_socket: SocketHolder (int) - The socket file descriptor for the connection\n- connected: bool - Flag indicating whether the client is currently connected to the server\n\nMethods:\n- Connect() -> bool - Establishes a connection to the server. Returns true if successful.\n- Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Reads data from the server into the buffer. Returns true if all requested bytes were read.\n- Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Writes data from the buffer to the server. Returns true if all bytes were written.\n- Disconnect() -> void - Closes the connection to the server.\n- SetNonBlock(SocketHolder sockFD, bool nonBlocking) -> bool - Sets the blocking mode of the socket. Returns true if successful.\n- ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) -> bool - Attempts to connect with a timeout. Returns true if successful.",
    "Canonical_solution": "#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <cerrno>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <string>\n\n#ifdef _WIN32\n#define WSAEAGAIN WSAEWOULDBLOCK\n#define WSAEMULTIHOP -1\n#define ERRNO(x) WSA##x\n#define GET_ERRNO WSAGetLastError()\n#define poll(x, y, z) WSAPoll(x, y, z);\n#define SHUT_RD SD_RECEIVE\n#define SHUT_WR SD_SEND\n#define SHUT_RDWR SD_BOTH\n#else\n#define ERRNO(x) x\n#define GET_ERRNO errno\n#define closesocket(x) close(x)\n#endif\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n\n    TCPClient(const std::string& address, u16 port) : address(address), port(port) {}\n\n    bool Connect() {\n        if (connected)\n            return true;\n\n        struct addrinfo hints, *addrinfo;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_family = AF_INET;\n\n        if (getaddrinfo(address.data(), NULL, &hints, &addrinfo) != 0) {\n            return false;\n        }\n\n        main_socket = ::socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == static_cast<SocketHolder>(-1)) {\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, true)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        struct sockaddr_in servaddr = {0};\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_addr.s_addr = ((struct sockaddr_in*)(addrinfo->ai_addr))->sin_addr.s_addr;\n        servaddr.sin_port = htons(port);\n        freeaddrinfo(addrinfo);\n\n        if (!ConnectWithTimeout(main_socket, &servaddr, sizeof(servaddr), 10)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t read_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (read_bytes != size) {\n            int new_read = ::recv(main_socket, (char*)((uintptr_t)buffer + read_bytes), \n                (int)(size - read_bytes), 0);\n            if (new_read < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                read_bytes = 0;\n                break;\n            }\n            read_bytes += new_read;\n        }\n        return read_bytes == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t write_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (write_bytes != size) {\n            int new_written = ::send(main_socket, (const char*)((uintptr_t)buffer + write_bytes),\n                                    (int)(size - write_bytes), 0);\n            if (new_written < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                write_bytes = 0;\n                break;\n            }\n            write_bytes += new_written;\n        }\n        return write_bytes == size;\n    }\n\n    void Disconnect() {\n        if (connected) {\n            shutdown(main_socket, SHUT_RDWR);\n            closesocket(main_socket);\n            connected = false;\n        }\n    }\n\nprivate:\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        bool blocking = !nonBlocking;\n#ifdef _WIN32\n        unsigned long nonblocking = (blocking) ? 0 : 1;\n        int ret = ioctlsocket(sockFD, FIONBIO, &nonblocking);\n        if (ret == -1) {\n            return false;\n        }\n#else\n        int flags = ::fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) {\n            return false;\n        }\n\n        flags &= ~O_NONBLOCK;\n        if (!blocking) {\n            flags |= O_NONBLOCK;\n        }\n\n        const int ret = ::fcntl(sockFD, F_SETFL, flags);\n        if (ret == -1) {\n            return false;\n        }\n#endif\n        return true;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len,\n                           int timeout_seconds) {\n        int res = ::connect(sockFD, (struct sockaddr*)server_addr, static_cast<int>(server_addr_len));\n        if (res == -1 && ((GET_ERRNO == ERRNO(EINPROGRESS) || GET_ERRNO == ERRNO(EWOULDBLOCK))) {\n            struct timeval tv;\n            fd_set fdset;\n            FD_ZERO(&fdset);\n            FD_SET(sockFD, &fdset);\n\n            tv.tv_sec = timeout_seconds;\n            tv.tv_usec = 0;\n            int select_res = ::select(static_cast<int>(sockFD + 1), NULL, &fdset, NULL, &tv);\n#ifdef _WIN32\n            if (select_res == 0) {\n                return false;\n            }\n#else\n            bool select_good = false;\n            if (select_res == 1) {\n                int so_error;\n                socklen_t len = sizeof so_error;\n\n                getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n                if (so_error == 0) {\n                    select_good = true;\n                }\n            }\n            if (!select_good) {\n                return false;\n            }\n#endif\n        } else if (res == -1) {\n            return false;\n        }\n        return true;\n    }\n\n    std::string address;\n    u16 port;\n    SocketHolder main_socket = -1;\n    bool connected = false;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <errno.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\ntypedef SOCKET SocketHolder;\n#else\ntypedef int SocketHolder\n#endif\n\nclass TCPClient {\nprivate:\n    std::string address;\n    uint16_t port;\n    SocketHolder main_socket;\n    bool connected;\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        #ifdef _WIN32\n            u_long mode = nonBlocking ? 1 : 0;\n            return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n        #else\n            int flags = fcntl(sockFD, F_GETFL, 0);\n            if (flags == -1) return false;\n            flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n            return fcntl(sockFD, F_SETFL, flags) != -1;\n        #endif\n    }\n\npublic:\n    TCPClient(const std::string& addr, uint16_t p)\n        : address(addr), port(p), main_socket(INVALID_SOCKET), connected(false) {\n        #ifdef _WIN32\n            WSADATA wsaData;\n            WSAStartup(MAKEWORD(2, 2), &wsaData);\n        #endif\n    }\n\n    ~TCPClient() {\n        Disconnect();\n        #ifdef _WIN32\n            WSACleanup();\n        #endif\n    }\n\n    bool Connect() {\n        if (connected) return true;\n\n        struct addrinfo hints, *servinfo, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n\n        char portStr[6];\n        snprintf(portStr, sizeof(portStr), \"%d\", port);\n\n        if (getaddrinfo(address.c_str(), portStr, &hints, &servinfo) != 0) {\n            return false;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            main_socket = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (main_socket == INVALID_SOCKET) continue;\n\n            if (::connect(main_socket, p->ai_addr, p->ai_addrlen) == 0) {\n                connected = true;\n                break;\n            }\n\n            #ifdef _WIN32\n                closesocket(main_socket);\n            #else\n                close(main_socket);\n            #endif\n        }\n\n        freeaddrinfo(servinfo);\n\n        return connected;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        SetNonBlock(sockFD, true);\n        int result = ::connect(sockFD, reinterpret_cast<struct sockaddr*>(server_addr), server_addr_len);\n        if (result == 0) {\n            SetNonBlock(sockFD, false);\n            return true;\n        }\n\n        #ifdef _WIN32\n            if (WSAGetLastError() != WSAEWOULDBLOCK) return false;\n        #else\n            if (errno != EINPROGRESS) return false;\n        #endif\n\n        fd_set writeSet;\n        FD_ZERO(&writeSet);\n        FD_SET(sockFD, &writeSet);\n\n        timeval timeout;\n        timeout.tv_sec = timeout_seconds;\n        timeout.tv_usec = 0;\n\n        int selectResult = select(sockFD + 1, nullptr, &writeSet, nullptr, &timeout);\n        if (selectResult <= 0) return false;\n\n        #ifdef _WIN32\n            int error = 0;\n            socklen_t len = sizeof(error);\n            getsockopt(sockFD, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&error), &len);\n            if (error != 0) return false;\n        #else\n            int error;\n            socklen_t len = sizeof(error);\n            getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &error, &len);\n            if (error != 0) return false;\n        #endif\n\n        SetNonBlock(sockFD, false);\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t totalRead = 0;\n\n        auto start = std::chrono::steady_clock::now();\n        while (totalRead < size) {\n            auto remaining = timeout - std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start);\n            if (remaining.count() <= 0) return false;\n\n            #ifdef _WIN32\n                DWORD flags = 0;\n                WSAOVERLAPPED overlapped;\n                ZeroMemory(&overlapped, sizeof(overlapped));\n                WSABUF wsabuf;\n                wsabuf.buf = buf + totalRead;\n                wsabuf.len = static_cast<u_long>(size - totalRead);\n                DWORD recvBytes = 0;\n\n                int result = WSARecv(main_socket, &wsabuf, 1, &recvBytes, &flags, &overlapped, nullptr);\n                if (result == SOCKET_ERROR) {\n                    if (WSAGetLastError() != WSA_IO_PENDING) return false;\n                    // Wait for completion or timeout\n                    Sleep(1); // Simpler approach; real code would use WaitForMultipleObjects or similar\n                } else {\n                    totalRead += recvBytes;\n                }\n            #else\n                ssize_t bytesRead = recv(main_socket, buf + totalRead, size - totalRead, 0);\n                if (bytesRead > 0) {\n                    totalRead += static_cast<size_t>(bytesRead);\n                } else if (bytesRead == 0) {\n                    return false; // Connection closed\n                } else {\n                    if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                        // Wait a bit and retry\n                        usleep(1000);\n                        continue;\n                    }\n                    return false;\n                }\n            #endif\n        }\n\n        return totalRead == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t totalWritten = 0;\n\n        auto start = std::chrono::steady_clock::now();\n        while (totalWritten < size) {\n            auto remaining = timeout - std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start);\n            if (remaining.count() <= 0) return false;\n\n            #ifdef _WIN32\n                DWORD sent = 0;\n                WSABUF wsabuf;\n                wsabuf.buf = const_cast<char*>(buf + totalWritten);\n                wsabuf.len = static_cast<u_long>(size - totalWritten);\n                DWORD flags = 0;\n\n                if (WSASend(main_socket, &wsabuf, 1, &sent, flags, nullptr, nullptr) == SOCKET_ERROR) {\n                    if (WSAGetLastError() != WSAEWOULDBLOCK) return false;\n                    // Wait for socket to be writable\n                    Sleep(1);\n                } else {\n                    totalWritten += sent;\n                }\n            #else\n                ssize_t bytesSent = send(main_socket, buf + totalWritten, size - totalWritten, MSG_NOSIGNAL);\n                if (bytesSent >= 0) {\n                    totalWritten += static_cast<size_t>(bytesSent);\n                } else {\n                    if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                        usleep(1000);\n                        continue;\n                    }\n                    return false;\n                }\n            #endif\n        }\n\n        return totalWritten == size;\n    }\n\n    void Disconnect() {\n        if (main_socket != INVALID_SOCKET) {\n            #ifdef _WIN32\n                closesocket(main_socket);\n            #else\n                close(main_socket);\n            #endif\n            main_socket = INVALID_SOCKET;\n        }\n        connected = false;\n    }\n};",
      "#include <string>\n#include <cstring>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <iostream>\n\n#if defined(_WIN32) || defined(_WIN64)\n    #include <winsock2.h>\n    #include <ws2tcpip.h>\n    using SocketHolder = SOCKET;\n    #define INVALID_SOCKET (~0)\n    #define SOCKET_ERROR (-1)\n    #define close closesocket\n#else\n    using SocketHolder = int;\n    #define INVALID_SOCKET (-1)\n#endif\n\nclass TCPClient {\npublic:\n    using u16 = uint16_t;\n\n    TCPClient(const std::string& address, u16 port)\n        : address(address), port(port), main_socket(INVALID_SOCKET), connected(false) {}\n\n    ~TCPClient() {\n        Disconnect();\n    }\n\n    bool Connect() {\n        if (connected) return true;\n\n        struct sockaddr_in server_addr;\n        std::memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            return false;\n        }\n\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == INVALID_SOCKET) {\n            return false;\n        }\n\n        SetNonBlock(main_socket, false); // Blocking for normal connect\n\n        connected = ::connect(main_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == 0;\n        return connected;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t total_read = 0;\n\n        auto timeout_time = std::chrono::steady_clock::now() + timeout;\n\n        while (total_read < size) {\n            auto remaining = size - total_read;\n            auto left = timeout_time - std::chrono::steady_clock::now();\n            if (left <= std::chrono::nanoseconds::zero()) {\n                return false; // Timeout\n            }\n\n            fd_set read_fds;\n            FD_ZERO(&read_fds);\n            FD_SET(main_socket, &read_fds);\n\n            timeval tv{};\n            tv.tv_sec = static_cast<long>(std::chrono::duration_cast<std::chrono::seconds>(left).count());\n            tv.tv_usec = static_cast<long>(std::chrono::duration_cast<std::chrono::microseconds>(left % std::chrono::seconds(1)).count());\n\n            int select_result = select(static_cast<int>(main_socket) + 1, &read_fds, nullptr, nullptr, &tv);\n            if (select_result < 0) {\n                return false; // Error\n            } else if (select_result == 0) {\n                continue; // Timeout\n            }\n\n            ssize_t bytes_read = recv(main_socket, buf + total_read, remaining, 0);\n            if (bytes_read <= 0) {\n                return false; // Connection closed or error\n            }\n            total_read += static_cast<size_t>(bytes_read);\n        }\n\n        return total_read == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t total_written = 0;\n\n        auto timeout_time = std::chrono::steady_clock::now() + timeout;\n\n        while (total_written < size) {\n            auto remaining = size - total_written;\n            auto left = timeout_time - std::chrono::steady_clock::now();\n            if (left <= std::chrono::nanoseconds::zero()) {\n                return false; // Timeout\n            }\n\n            fd_set write_fds;\n            FD_ZERO(&write_fds);\n            FD_SET(main_socket, &write_fds);\n\n            timeval tv{};\n            tv.tv_sec = static_cast<long>(std::chrono::duration_cast<std::chrono::seconds>(left).count());\n            tv.tv_usec = static_cast<long>(std::chrono::duration_cast<std::chrono::microseconds>(left % std::chrono::seconds(1)).count());\n\n            int select_result = select(static_cast<int>(main_socket) + 1, nullptr, &write_fds, nullptr, &tv);\n            if (select_result < 0) {\n                return false; // Error\n            } else if (select_result == 0) {\n                continue; // Timeout\n            }\n\n            ssize_t bytes_sent = send(main_socket, buf + total_written, remaining, 0);\n            if (bytes_sent <= 0) {\n                return false; // Connection closed or error\n            }\n            total_written += static_cast<size_t>(bytes_sent);\n        }\n\n        return total_written == size;\n    }\n\n    void Disconnect() {\n        if (main_socket != INVALID_SOCKET) {\n            close(main_socket);\n            main_socket = INVALID_SOCKET;\n        }\n        connected = false;\n    }\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        if (sockFD == INVALID_SOCKET) return false;\n\n#if defined(_WIN32) || defined(_WIN64)\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) != SOCKET_ERROR;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) != -1;\n#endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (sockFD == INVALID_SOCKET) return false;\n\n        SetNonBlock(sockFD, true);\n\n        int conn_result = connect(sockFD, reinterpret_cast<struct sockaddr*>(server_addr), server_addr_len);\n        if (conn_result == 0) {\n            SetNonBlock(sockFD, false);\n            return true;\n        }\n\n#if defined(_WIN32) || defined(_WIN64)\n        if (WSAGetLastError() != WSAEWOULDBLOCK) {\n#else\n        if (errno != EINPROGRESS) {\n#endif\n            return false;\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        timeval tv{};\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        int select_result = select(static_cast<int>(sockFD) + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result <= 0) {\n            return false; // Timeout or error\n        }\n\n        int so_error;\n        socklen_t len = sizeof(so_error);\n        getsockopt(sockFD, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&so_error), &len);\n\n        SetNonBlock(sockFD, false);\n        return so_error == 0;\n    }\n\nprivate:\n    std::string address;\n    u16 port;\n    SocketHolder main_socket;\n    bool connected;\n};",
      "#include <string>\n#include <cstring>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <iostream>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\n#else\ntypedef int SocketHolder;\nconst SocketHolder INVALID_SOCKET = -1;\n#endif\n\nclass TCPClient {\npublic:\n    TCPClient(const std::string& address, uint16_t port)\n        : address(address), port(port), main_socket(INVALID_SOCKET), connected(false) {}\n\n    ~TCPClient() {\n        Disconnect();\n    }\n\n    bool Connect() {\n        struct addrinfo hints, *server_info, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n\n        std::string port_str = std::to_string(port);\n        if (getaddrinfo(address.c_str(), port_str.c_str(), &hints, &server_info) != 0) {\n            return false;\n        }\n\n        for (p = server_info; p != nullptr; p = p->ai_next) {\n            main_socket = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (main_socket == INVALID_SOCKET) continue;\n\n            SetNonBlock(main_socket, true);\n\n            if (ConnectWithTimeout(main_socket, p->ai_addr, p->ai_addrlen, 5)) {\n                connected = true;\n                SetNonBlock(main_socket, false);\n                break;\n            }\n\n            close(main_socket);\n            main_socket = INVALID_SOCKET;\n        }\n\n        freeaddrinfo(server_info);\n        return connected;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected) return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t total_read = 0;\n\n        auto start_time = std::chrono::steady_clock::now();\n        while (total_read < size) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - start_time > timeout) {\n                return false;\n            }\n\n            ssize_t bytes_read = recv(main_socket, buf + total_read, size - total_read, 0);\n            if (bytes_read > 0) {\n                total_read += bytes_read;\n            } else if (bytes_read == 0) {\n                connected = false;\n                return false;\n            } else {\n                if (!(errno == EAGAIN || errno == EWOULDBLOCK)) {\n                    connected = false;\n                    return false;\n                }\n            }\n        }\n\n        return total_read == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected) return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t total_written = 0;\n\n        auto start_time = std::chrono::steady_clock::now();\n        while (total_written < size) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - start_time > timeout) {\n                return false;\n            }\n\n            ssize_t bytes_sent = send(main_socket, buf + total_written, size - total_written, 0);\n            if (bytes_sent > 0) {\n                total_written += bytes_sent;\n            } else {\n                if (!(errno == EAGAIN || errno == EWOULDBLOCK)) {\n                    connected = false;\n                    return false;\n                }\n            }\n        }\n\n        return total_written == size;\n    }\n\n    void Disconnect() {\n        if (main_socket != INVALID_SOCKET) {\n#ifdef _WIN32\n            closesocket(main_socket);\n#else\n            close(main_socket);\n#endif\n            main_socket = INVALID_SOCKET;\n        }\n        connected = false;\n    }\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n#ifdef _WIN32\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) != -1;\n#endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (connect(sockFD, reinterpret_cast<struct sockaddr*>(server_addr), server_addr_len) == 0) {\n            return true;\n        }\n\n#ifndef _WIN32\n        if (errno != EINPROGRESS) {\n            return false;\n        }\n#endif\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        timeval timeout;\n        timeout.tv_sec = timeout_seconds;\n        timeout.tv_usec = 0;\n\n        int select_result = select(sockFD + 1, nullptr, &write_fds, nullptr, &timeout);\n        if (select_result <= 0) {\n            return false;\n        }\n\n        int so_error;\n        socklen_t len = sizeof(so_error);\n        getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n        return so_error == 0;\n    }\n\nprivate:\n    std::string address;\n    uint16_t port;\n    SocketHolder main_socket;\n    bool connected;\n};",
      "#include <string>\n#include <cstring>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <iostream>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\n#else\ntypedef int SocketHolder;\nconst SocketHolder INVALID_SOCKET = -1;\n#endif\n\nclass TCPClient {\npublic:\n    TCPClient(const std::string& address, uint16_t port)\n        : address(address), port(port), main_socket(INVALID_SOCKET), connected(false) {}\n\n    ~TCPClient() {\n        Disconnect();\n    }\n\n    bool Connect() {\n        struct addrinfo hints, *servinfo, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n\n        std::string portStr = std::to_string(port);\n        if (getaddrinfo(address.c_str(), portStr.c_str(), &hints, &servinfo) != 0) {\n            return false;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            main_socket = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (main_socket == INVALID_SOCKET) continue;\n\n            if (ConnectWithTimeout(main_socket, p->ai_addr, p->ai_addrlen, 5)) {\n                freeaddrinfo(servinfo);\n                connected = true;\n                return true;\n            }\n\n            close(main_socket);\n            main_socket = INVALID_SOCKET;\n        }\n\n        freeaddrinfo(servinfo);\n        return false;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t totalRead = 0;\n\n        auto start = std::chrono::steady_clock::now();\n        while (totalRead < size) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - start > timeout) {\n                errno = ETIMEDOUT;\n                return false;\n            }\n\n            ssize_t bytes = recv(main_socket, buf + totalRead, size - totalRead, 0);\n            if (bytes <= 0) {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    continue;\n                }\n                return false;\n            }\n            totalRead += bytes;\n        }\n\n        return totalRead == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t totalWritten = 0;\n\n        auto start = std::chrono::steady_clock::now();\n        while (totalWritten < size) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - start > timeout) {\n                errno = ETIMEDOUT;\n                return false;\n            }\n\n            ssize_t bytes = send(main_socket, buf + totalWritten, size - totalWritten, 0);\n            if (bytes <= 0) {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    continue;\n                }\n                return false;\n            }\n            totalWritten += bytes;\n        }\n\n        return totalWritten == size;\n    }\n\n    void Disconnect() {\n        if (main_socket != INVALID_SOCKET) {\n#ifdef _WIN32\n            closesocket(main_socket);\n#else\n            close(main_socket);\n#endif\n            main_socket = INVALID_SOCKET;\n        }\n        connected = false;\n    }\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        if (sockFD == INVALID_SOCKET) return false;\n\n#ifdef _WIN32\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) != -1;\n#endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (!SetNonBlock(sockFD, true)) return false;\n\n        int connectResult = connect(sockFD, static_cast<struct sockaddr*>(server_addr), server_addr_len);\n\n        fd_set writeSet, errorSet;\n        FD_ZERO(&writeSet);\n        FD_ZERO(&errorSet);\n        FD_SET(sockFD, &writeSet);\n        FD_SET(sockFD, &errorSet);\n\n        timeval timeout;\n        timeout.tv_sec = timeout_seconds;\n        timeout.tv_usec = 0;\n\n        int selectResult = select(sockFD + 1, nullptr, &writeSet, &errorSet, &timeout);\n\n        if (selectResult <= 0) return false;\n\n        if (FD_ISSET(sockFD, &errorSet)) return false;\n\n        return true;\n    }\n\nprivate:\n    std::string address;\n    uint16_t port;\n    SocketHolder main_socket;\n    bool connected;\n};",
      "#include <string>\n#include <cstring>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <iostream>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\n#else\ntypedef int SocketHolder;\nconst SocketHolder INVALID_SOCKET = -1;\n#endif\n\nclass TCPClient {\npublic:\n    TCPClient(const std::string& address, uint16_t port)\n        : address(address), port(port), main_socket(INVALID_SOCKET), connected(false) {}\n\n    ~TCPClient() {\n        Disconnect();\n    }\n\n    bool Connect() {\n        struct addrinfo hints, *server_info, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n\n        std::string port_str = std::to_string(port);\n        if (getaddrinfo(address.c_str(), port_str.c_str(), &hints, &server_info) != 0) {\n            return false;\n        }\n\n        for (p = server_info; p != nullptr; p = p->ai_next) {\n            main_socket = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (main_socket == INVALID_SOCKET) continue;\n\n            SetNonBlock(main_socket, false);\n\n            if (::connect(main_socket, p->ai_addr, p->ai_addrlen) == 0) {\n                connected = true;\n                break;\n            }\n\n            #ifdef _WIN32\n            int err = WSAGetLastError();\n            if (err == WSAECONNREFUSED || err == WSAETIMEDOUT) {\n            #else\n            if (errno == ECONNREFUSED || errno == ETIMEDOUT) {\n            #endif\n                close(main_socket);\n                continue;\n            }\n        }\n\n        freeaddrinfo(server_info);\n\n        return connected;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t total_read = 0;\n\n        while (total_read < size) {\n            fd_set read_fds;\n            FD_ZERO(&read_fds);\n            FD_SET(main_socket, &read_fds);\n\n            int select_result;\n            do {\n                struct timeval tv{};\n                auto timeout_us = std::chrono::duration_cast<std::chrono::microseconds>(timeout);\n                tv.tv_sec = static_cast<long>(timeout_us.count() / 1000000);\n                tv.tv_usec = static_cast<long>(timeout_us.count() % 1000000);\n\n                select_result = ::select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n            } while (select_result == -1 && errno == EINTR);\n\n            if (select_result <= 0) return false;\n\n            ssize_t bytes_read = recv(main_socket, buf + total_read, size - total_read, 0);\n            if (bytes_read <= 0) return false;\n\n            total_read += bytes_read;\n        }\n\n        return total_read == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t total_written = 0;\n\n        while (total_written < size) {\n            fd_set write_fds;\n            FD_ZERO(&write_fds);\n            FD_SET(main_socket, &write_fds);\n\n            int select_result;\n            do {\n                struct timeval tv{};\n                auto timeout_us = std::chrono::duration_cast<std::chrono::microseconds>(timeout);\n                tv.tv_sec = static_cast<long>(timeout_us.count() / 1000000);\n                tv.tv_usec = static_cast<long>(timeout_us.count() % 1000000);\n\n                select_result = ::select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n            } while (select_result == -1 && errno == EINTR);\n\n            if (select_result <= 0) return false;\n\n            ssize_t bytes_written = send(main_socket, buf + total_written, size - total_written, 0);\n            if (bytes_written <= 0) return false;\n\n            total_written += bytes_written;\n        }\n\n        return total_written == size;\n    }\n\n    void Disconnect() {\n        if (main_socket != INVALID_SOCKET) {\n            #ifdef _WIN32\n            closesocket(main_socket);\n            #else\n            close(main_socket);\n            #endif\n            main_socket = INVALID_SOCKET;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        #ifdef _WIN32\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n        #else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        return fcntl(sockFD, F_SETFL, nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK)) != -1;\n        #endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, socklen_t server_addr_len, int timeout_seconds) {\n        SetNonBlock(sockFD, true);\n\n        int connect_result = ::connect(sockFD, static_cast<struct sockaddr*>(server_addr), server_addr_len);\n\n        #ifdef _WIN32\n        if (connect_result == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK) {\n            return false;\n        }\n        #else\n        if (connect_result < 0 && errno != EINPROGRESS) {\n            return false;\n        }\n        #endif\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        struct timeval tv{};\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        int select_result = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result <= 0) {\n            return false;\n        }\n\n        #ifdef _WIN32\n        int opt_val;\n        #else\n        int opt_val = 0;\n        #endif\n        socklen_t opt_len = sizeof(opt_val);\n\n        if (getsockopt(sockFD, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&opt_val), &opt_len) < 0) {\n            return false;\n        }\n\n        return opt_val == 0;\n    }\n\nprivate:\n    std::string address;\n    uint16_t port;\n    SocketHolder main_socket;\n    bool connected;\n};",
      "#include <iostream>\n#include <cstring>\n#include <chrono>\n#include <thread>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\n#else\ntypedef int SocketHolder;\nconst SocketHolder INVALID_SOCKET = -1;\n#endif\n\nclass TCPClient {\nprivate:\n    std::string address;\n    unsigned short port;\n    SocketHolder main_socket;\n    bool connected;\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        if (sockFD == INVALID_SOCKET)\n            return false;\n\n#ifdef _WIN32\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1)\n            return false;\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) != -1;\n#endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (connect(sockFD, reinterpret_cast<struct sockaddr*>(server_addr), server_addr_len) == 0) {\n            return true;\n        }\n\n#ifdef _WIN32\n        if (WSAGetLastError() != WSAEWOULDBLOCK)\n            return false;\n#else\n        if (errno != EINPROGRESS)\n            return false;\n#endif\n\n        fd_set writeSet, errorSet;\n        FD_ZERO(&writeSet);\n        FD_ZERO(&errorSet);\n        FD_SET(sockFD, &writeSet);\n        FD_SET(sockFD, &errorSet);\n\n        timeval timeout;\n        timeout.tv_sec = timeout_seconds;\n        timeout.tv_usec = 0;\n\n        int selectResult = select(static_cast<int>(sockFD + 1), nullptr, &writeSet, &errorSet, &timeout);\n        if (selectResult <= 0)\n            return false;\n\n        if (FD_ISSET(sockFD, &errorSet))\n            return false;\n\n        return true;\n    }\n\npublic:\n    TCPClient(const std::string& addr, unsigned short p)\n        : address(addr), port(p), main_socket(INVALID_SOCKET), connected(false) {\n#ifdef _WIN32\n        WSADATA wsaData;\n        WSAStartup(MAKEWORD(2, 2), &wsaData);\n#endif\n    }\n\n    ~TCPClient() {\n        Disconnect();\n#ifdef _WIN32\n        WSACleanup();\n#endif\n    }\n\n    bool Connect() {\n        if (connected)\n            return true;\n\n        struct sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        inet_pton(AF_INET, address.c_str(), &serverAddr.sin_addr);\n\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == INVALID_SOCKET)\n            return false;\n\n        SetNonBlock(main_socket, false);\n\n        if (::connect(main_socket, reinterpret_cast<struct sockaddr*>(&serverAddr), sizeof(serverAddr)) == 0) {\n            connected = true;\n            return true;\n        }\n\n        if (ConnectWithTimeout(main_socket, &serverAddr, sizeof(serverAddr), 10)) {\n            connected = true;\n            SetNonBlock(main_socket, false); // Reset to blocking after connection\n            return true;\n        }\n\n        Disconnect();\n        return false;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0)\n            return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t totalRead = 0;\n        auto startTime = std::chrono::steady_clock::now();\n\n        while (totalRead < size) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - startTime >= timeout)\n                break;\n\n            ssize_t bytesRead = recv(main_socket, buf + totalRead, size - totalRead, 0);\n            if (bytesRead > 0) {\n                totalRead += bytesRead;\n            }\n            else if (bytesRead == 0) {\n                Disconnect();\n                return false;\n            }\n            else {\n#ifdef _WIN32\n                if (WSAGetLastError() != WSAEWOULDBLOCK)\n#else\n                if (errno != EAGAIN && errno != EWOULDBLOCK)\n#endif\n                    return false;\n                std::this_thread::sleep_for(std::chrono::milliseconds(10));\n            }\n        }\n\n        return totalRead == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0)\n            return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t totalWritten = 0;\n        auto startTime = std::chrono::steady_clock::now();\n\n        while (totalWritten < size) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - startTime >= timeout)\n                break;\n\n            ssize_t bytesSent = send(main_socket, buf + totalWritten, size - totalWritten, 0);\n            if (bytesSent > 0) {\n                totalWritten += bytesSent;\n            }\n            else if (bytesSent < 0) {\n#ifdef _WIN32\n                if (WSAGetLastError() != WSAEWOULDBLOCK)\n#else\n                if (errno != EAGAIN && errno != EWOULDBLOCK)\n#endif\n                    return false;\n                std::this_thread::sleep_for(std::chrono::milliseconds(10));\n            }\n        }\n\n        return totalWritten == size;\n    }\n\n    void Disconnect() {\n        if (main_socket != INVALID_SOCKET) {\n#ifdef _WIN32\n            closesocket(main_socket);\n#else\n            close(main_socket);\n#endif\n            main_socket = INVALID_SOCKET;\n        }\n        connected = false;\n    }\n};",
      "#include <string>\n#include <cstring>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <iostream>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\n#else\ntypedef int SocketHolder;\nconst SocketHolder INVALID_SOCKET = -1;\n#endif\n\nclass TCPClient {\npublic:\n    TCPClient(const std::string& address, uint16_t port)\n        : address(address), port(port), main_socket(INVALID_SOCKET), connected(false) {}\n\n    ~TCPClient() {\n        Disconnect();\n    }\n\n    bool Connect() {\n        struct addrinfo hints, *servinfo, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n\n        std::string portStr = std::to_string(port);\n        if (getaddrinfo(address.c_str(), portStr.c_str(), &hints, &servinfo) != 0) {\n            return false;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            main_socket = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (main_socket == INVALID_SOCKET) continue;\n\n            if (ConnectWithTimeout(main_socket, p->ai_addr, p->ai_addrlen, 5)) {\n                freeaddrinfo(servinfo);\n                connected = true;\n                return true;\n            }\n\n            close(main_socket);\n            main_socket = INVALID_SOCKET;\n        }\n\n        freeaddrinfo(servinfo);\n        return false;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t totalRead = 0;\n        auto start = std::chrono::steady_clock::now();\n\n        while (totalRead < size) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - start > timeout) {\n                errno = ETIMEDOUT;\n                return false;\n            }\n\n            ssize_t bytes = recv(main_socket, buf + totalRead, size - totalRead, 0);\n            if (bytes > 0) {\n                totalRead += bytes;\n            } else if (bytes == 0) {\n                connected = false;\n                return false;\n            } else {\n                if (errno != EAGAIN && errno != EWOULDBLOCK) {\n                    connected = false;\n                    return false;\n                }\n            }\n        }\n\n        return totalRead == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t totalWritten = 0;\n        auto start = std::chrono::steady_clock::now();\n\n        while (totalWritten < size) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - start > timeout) {\n                errno = ETIMEDOUT;\n                return false;\n            }\n\n            ssize_t bytes = send(main_socket, buf + totalWritten, size - totalWritten, 0);\n            if (bytes > 0) {\n                totalWritten += bytes;\n            } else if (bytes < 0) {\n                if (errno != EAGAIN && errno != EWOULDBLOCK) {\n                    connected = false;\n                    return false;\n                }\n            }\n        }\n\n        return totalWritten == size;\n    }\n\n    void Disconnect() {\n        if (main_socket != INVALID_SOCKET) {\n#ifdef _WIN32\n            closesocket(main_socket);\n#else\n            close(main_socket);\n#endif\n            main_socket = INVALID_SOCKET;\n        }\n        connected = false;\n    }\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n#ifdef _WIN32\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) != -1;\n#endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        SetNonBlock(sockFD, true);\n\n        int connResult = connect(sockFD, static_cast<struct sockaddr*>(server_addr), server_addr_len);\n\n        if (connResult == 0) {\n            SetNonBlock(sockFD, false);\n            return true;\n        }\n\n#ifdef _WIN32\n        if (WSAGetLastError() != WSAEWOULDBLOCK) {\n#else\n        if (errno != EINPROGRESS) {\n#endif\n            return false;\n        }\n\n        fd_set writeSet;\n        FD_ZERO(&writeSet);\n        FD_SET(sockFD, &writeSet);\n\n        timeval timeout;\n        timeout.tv_sec = timeout_seconds;\n        timeout.tv_usec = 0;\n\n        int selectResult = select(static_cast<int>(sockFD + 1), nullptr, &writeSet, nullptr, &timeout);\n\n        if (selectResult <= 0) return false;\n\n        int error = 0;\n        socklen_t len = sizeof(error);\n        getsockopt(sockFD, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&error), &len);\n\n        SetNonBlock(sockFD, false);\n        return error == 0;\n    }\n\nprivate:\n    std::string address;\n    uint16_t port;\n    SocketHolder main_socket;\n    bool connected;\n};",
      "#include <string>\n#include <cstring>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <iostream>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\n#else\ntypedef int SocketHolder;\nconst SocketHolder INVALID_SOCKET = -1;\n#endif\n\nclass TCPClient {\npublic:\n    TCPClient(const std::string& address, uint16_t port)\n        : address(address), port(port), main_socket(INVALID_SOCKET), connected(false) {}\n\n    ~TCPClient() {\n        Disconnect();\n    }\n\n    bool Connect() {\n        struct addrinfo hints, *servinfo, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n\n        char portStr[6];\n        snprintf(portStr, sizeof(portStr), \"%u\", port);\n\n        if (getaddrinfo(address.c_str(), portStr, &hints, &servinfo) != 0) {\n            return false;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            main_socket = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (main_socket == INVALID_SOCKET) continue;\n\n            SetNonBlock(main_socket, true);\n\n            if (ConnectWithTimeout(main_socket, p->ai_addr, p->ai_addrlen, 5) == true) {\n                SetNonBlock(main_socket, false);\n                connected = true;\n                freeaddrinfo(servinfo);\n                return true;\n            }\n\n            close(main_socket);\n            main_socket = INVALID_SOCKET;\n        }\n\n        freeaddrinfo(servinfo);\n        return false;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t totalRead = 0;\n\n        auto start = std::chrono::steady_clock::now();\n        while (totalRead < size) {\n            ssize_t bytes_read = recv(main_socket, buf + totalRead, size - totalRead, 0);\n            if (bytes_read > 0) {\n                totalRead += bytes_read;\n            } else if (bytes_read == 0) {\n                connected = false;\n                return false;\n            } else {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    auto now = std::chrono::steady_clock::now();\n                    if (now - start >= timeout) {\n                        return false;\n                    }\n                    usleep(1000); // Small sleep to prevent busy waiting\n                } else {\n                    connected = false;\n                    return false;\n                }\n            }\n        }\n\n        return totalRead == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0) return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t totalWritten = 0;\n\n        auto start = std::chrono::steady_clock::now();\n        while (totalWritten < size) {\n            ssize_t bytes_written = send(main_socket, buf + totalWritten, size - totalWritten, 0);\n            if (bytes_written >= 0) {\n                totalWritten += bytes_written;\n            } else {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    auto now = std::chrono::steady_clock::now();\n                    if (now - start >= timeout) {\n                        return false;\n                    }\n                    usleep(1000); // Small sleep to prevent busy waiting\n                } else {\n                    connected = false;\n                    return false;\n                }\n            }\n        }\n\n        return totalWritten == size;\n    }\n\n    void Disconnect() {\n        if (main_socket != INVALID_SOCKET) {\n#ifdef _WIN32\n            closesocket(main_socket);\n#else\n            close(main_socket);\n#endif\n            main_socket = INVALID_SOCKET;\n        }\n        connected = false;\n    }\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        if (sockFD == INVALID_SOCKET) return false;\n\n#ifdef _WIN32\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) != -1;\n#endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (connect(sockFD, reinterpret_cast<struct sockaddr*>(server_addr), server_addr_len) == 0) {\n            return true;\n        }\n\n        if (errno != EINPROGRESS) {\n            return false;\n        }\n\n        fd_set writeSet;\n        FD_ZERO(&writeSet);\n        FD_SET(sockFD, &writeSet);\n\n        timeval timeout;\n        timeout.tv_sec = timeout_seconds;\n        timeout.tv_usec = 0;\n\n        int selectResult = select(sockFD + 1, nullptr, &writeSet, nullptr, &timeout);\n        if (selectResult <= 0) {\n            return false;\n        }\n\n        int so_error;\n        socklen_t len = sizeof(so_error);\n        getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n        return so_error == 0;\n    }\n\nprivate:\n    std::string address;\n    uint16_t port;\n    SocketHolder main_socket;\n    bool connected;\n};"
    ],
    "unmatched_results": [
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <errno.h>\n#include <thread>\n#include <future>\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n    using u16 = uint16_t;\n\nprivate:\n    std::string address;\n    u16 port;\n    SocketHolder main_socket;\n    bool connected;\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1)\n            return false;\n\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return (fcntl(sockFD, F_SETFL, flags) == 0);\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        SetNonBlock(sockFD, true);\n\n        int result = connect(sockFD, reinterpret_cast<sockaddr*>(server_addr), server_addr_len);\n        if (result == 0) {\n            SetNonBlock(sockFD, false);\n            return true;\n        }\n\n        if (errno != EINPROGRESS)\n            return false;\n\n        fd_set writeSet;\n        FD_ZERO(&writeSet);\n        FD_SET(sockFD, &writeSet);\n\n        timeval timeout;\n        timeout.tv_sec = timeout_seconds;\n        timeout.tv_usec = 0;\n\n        int selectResult = select(sockFD + 1, nullptr, &writeSet, nullptr, &timeout);\n        if (selectResult <= 0)\n            return false;\n\n        int so_error;\n        socklen_t len = sizeof(so_error);\n        getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n        SetNonBlock(sockFD, false);\n        return so_error == 0;\n    }\n\npublic:\n    TCPClient(const std::string& addr, u16 p)\n        : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    ~TCPClient() {\n        Disconnect();\n    }\n\n    bool Connect() {\n        struct addrinfo hints, *servinfo, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n\n        std::string portStr = std::to_string(port);\n        int status = getaddrinfo(address.c_str(), portStr.c_str(), &hints, &servinfo);\n        if (status != 0)\n            return false;\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            main_socket = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (main_socket == -1)\n                continue;\n\n            if (ConnectWithTimeout(main_socket, p->ai_addr, p->ai_addrlen, 5)) {\n                freeaddrinfo(servinfo);\n                connected = true;\n                return true;\n            }\n\n            close(main_socket);\n        }\n\n        freeaddrinfo(servinfo);\n        return false;\n    }\n\n    void Disconnect() {\n        if (main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n        }\n        connected = false;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0)\n            return false;\n\n        char* buf = static_cast<char*>(buffer);\n        size_t totalRead = 0;\n        auto start = std::chrono::steady_clock::now();\n\n        while (totalRead < size) {\n            auto remaining = timeout - std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start);\n            if (remaining.count() <= 0)\n                return false;\n\n            fd_set readSet;\n            FD_ZERO(&readSet);\n            FD_SET(main_socket, &readSet);\n\n            timeval tv;\n            tv.tv_sec = std::chrono::duration_cast<std::chrono::seconds>(remaining).count();\n            tv.tv_usec = (remaining % std::chrono::seconds(1)).count() / 1000;\n\n            int selectResult = select(main_socket + 1, &readSet, nullptr, nullptr, &tv);\n            if (selectResult <= 0)\n                return false;\n\n            ssize_t bytesRead = recv(main_socket, buf + totalRead, size - totalRead, 0);\n            if (bytesRead <= 0)\n                return false;\n\n            totalRead += bytesRead;\n        }\n\n        return true;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || !buffer || size == 0)\n            return false;\n\n        const char* buf = static_cast<const char*>(buffer);\n        size_t totalWritten = 0;\n        auto start = std::chrono::steady_clock::now();\n\n        while (totalWritten < size) {\n            auto remaining = timeout - std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - start);\n            if (remaining.count() <= 0)\n                return false;\n\n            fd_set writeSet;\n            FD_ZERO(&writeSet);\n            FD_SET(main_socket, &writeSet);\n\n            timeval tv;\n            tv.tv_sec = std::chrono::duration_cast<std::chrono::seconds>(remaining).count();\n            tv.tv_usec = (remaining % std::chrono::seconds(1)).count() / 1000;\n\n            int selectResult = select(main_socket + 1, nullptr, &writeSet, nullptr, &tv);\n            if (selectResult <= 0)\n                return false;\n\n            ssize_t bytesSent = send(main_socket, buf + totalWritten, size - totalWritten, 0);\n            if (bytesSent <= 0)\n                return false;\n\n            totalWritten += bytesSent;\n        }\n\n        return true;\n    }\n};",
      "#include <string>\n#include <cstring>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <iostream>\n\n#if defined(_WIN32) || defined(_WIN64)\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef int socklen_t;\ntypedef char* sockbuf_t;\n#else\ntypedef int SOCKET;\ntypedef struct sockaddr_in SOCKADDR_IN;\ntypedef struct sockaddr SOCKADDR;\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define closesocket close\n#define sockbuf_t void*\n#endif\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n    TCPClient(const std::string& address, uint16_t port);\n    ~TCPClient();\n\n    bool Connect();\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout);\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout);\n    void Disconnect();\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking);\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds);\n\nprivate:\n    std::string address_;\n    uint16_t port_;\n    SocketHolder main_socket_;\n    bool connected_;\n};"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests and handling responses, including JSON parsing capabilities.\n\nClass Description: The CurlHttpClient class provides methods for performing HTTP GET requests and downloading web pages, with support for custom headers and request bodies. It includes JSON response handling and memory management for received data.\n\nAttributes:\nMemoryStruct: [struct] - A helper structure for storing received data in memory during curl operations\n  - memory: [char*] - Pointer to the allocated memory buffer\n  - size: [size_t] - Size of the allocated memory buffer\n\nMethods:\nWriteMemoryCallback: [static](void* contents, size_t size, size_t nmemb, void* userp) -> size_t - A static callback function for libcurl to write received data into memory\n  - contents: [void*] - Pointer to the received data\n  - size: [size_t] - Size of each data element\n  - nmemb: [size_t] - Number of data elements\n  - userp: [void*] - Pointer to user-provided memory structure\n  - Returns: The number of bytes actually written\n\ndownloadPage: [](const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) -> long - Downloads a web page and returns the HTTP status code\n  - url: [const std::string&] - The URL to request\n  - res: [std::string&] - Reference to store the response body\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response\n\ngetRequest: [](const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) -> long - Performs a GET request and parses the JSON response\n  - url: [const std::string&] - The URL to request\n  - res: [json&] - Reference to store the parsed JSON response\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <vector>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::ordered_json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n        if (ptr == NULL) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl_handle;\n        MemoryStruct chunk;\n        struct curl_slist* list = NULL;\n        long status_code;\n\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_global_init(CURL_GLOBAL_ALL);\n        curl_handle = curl_easy_init();\n        curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());\n        if (!headers.empty()) {\n            for (auto& h : headers) {\n                list = curl_slist_append(list, h.c_str());\n            }\n            curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, list);\n        }\n        if (body != \"\") {\n            curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"HamletDuFromage\");\n\n        curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);\n        curl_easy_perform(curl_handle);\n        curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &status_code);\n        curl_easy_cleanup(curl_handle);\n        res = std::string(chunk.memory);\n        free(chunk.memory);\n\n        curl_global_cleanup();\n        return status_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string request;\n        long status_code = downloadPage(url, request, headers, body);\n\n        if (json::accept(request))\n            res = json::parse(request);\n        else\n            res = json::object();\n\n        return status_code;\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\nprivate:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (!ptr) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\npublic:\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl = curl_easy_init();\n        if (!curl) return -1;\n\n        struct MemoryStruct chunk;\n        chunk.memory = (char*)malloc(1);\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n\n        if (!headers.empty()) {\n            struct curl_slist* headerList = nullptr;\n            for (const auto& header : headers) {\n                headerList = curl_slist_append(headerList, header.c_str());\n            }\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerList);\n        }\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode resCode = curl_easy_perform(curl);\n        if (resCode != CURLE_OK) {\n            free(chunk.memory);\n            curl_easy_cleanup(curl);\n            return -1;\n        }\n\n        res = std::string(chunk.memory);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        free(chunk.memory);\n        curl_easy_cleanup(curl);\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string responseStr;\n        long httpStatus = downloadPage(url, responseStr, headers, body);\n        if (httpStatus == 200 && !responseStr.empty()) {\n            try {\n                res = json::parse(responseStr);\n            } catch (const json::parse_error&) {\n                return -2;\n            }\n        }\n        return httpStatus;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (ptr == NULL) {\n            return 0;  // out of memory\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl_handle;\n        CURLcode result;\n        long http_code = 0;\n\n        MemoryStruct chunk;\n        chunk.memory = (char*)malloc(1);  // will be grown as needed by the realloc above\n        chunk.size = 0;\n\n        struct curl_slist* header_list = NULL;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n\n        curl_global_init(CURL_GLOBAL_ALL);\n        curl_handle = curl_easy_init();\n\n        if (curl_handle) {\n            curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());\n            curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n            curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);\n            curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"libcurl-agent/1.0\");\n            curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, header_list);\n\n            if (!body.empty()) {\n                curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, body.c_str());\n            }\n\n            result = curl_easy_perform(curl_handle);\n            curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &http_code);\n\n            if (result != CURLE_OK) {\n                http_code = -1;\n            } else {\n                res.assign(chunk.memory, chunk.size);\n            }\n\n            curl_easy_cleanup(curl_handle);\n        }\n\n        if (header_list) {\n            curl_slist_free_all(header_list);\n        }\n\n        if (chunk.memory) {\n            free(chunk.memory);\n        }\n\n        curl_global_cleanup();\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string response_str;\n        long status_code = downloadPage(url, response_str, headers, body);\n\n        if (status_code >= 200 && status_code < 300 && !response_str.empty()) {\n            try {\n                res = json::parse(response_str);\n            } catch (const json::parse_error&) {\n                status_code = -2; // JSON parse error\n            }\n        }\n\n        return status_code;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (!ptr) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers = {}, const std::string& body = \"\") {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            return -1;\n        }\n\n        struct MemoryStruct chunk;\n        chunk.memory = (char*)malloc(1);\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, \"C++ HttpClient/1.0\");\n\n        if (!headers.empty()) {\n            struct curl_slist* header_list = nullptr;\n            for (const auto& header : headers) {\n                header_list = curl_slist_append(header_list, header.c_str());\n            }\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n        }\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode resCode = curl_easy_perform(curl);\n        if (resCode != CURLE_OK) {\n            free(chunk.memory);\n            curl_easy_cleanup(curl);\n            return -1;\n        }\n\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        if (chunk.memory) {\n            res = std::string(chunk.memory, chunk.size);\n        }\n\n        free(chunk.memory);\n        curl_easy_cleanup(curl);\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers = {}, const std::string& body = \"\") {\n        std::string responseStr;\n        long httpStatus = downloadPage(url, responseStr, headers, body);\n        if (httpStatus == 200 && !responseStr.empty()) {\n            try {\n                res = json::parse(responseStr);\n            } catch (const json::parse_error&) {\n                return -2;\n            }\n        }\n        return httpStatus;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (ptr == NULL) {\n            return 0; // out of memory\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers = {}, const std::string& body = \"\") {\n        CURL* curl = curl_easy_init();\n        if (!curl) return -1;\n\n        struct MemoryStruct chunk;\n        chunk.memory = (char*)malloc(1); // initial allocation\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, \"libcurl-agent/1.0\");\n\n        if (!headers.empty()) {\n            struct curl_slist* header_list = nullptr;\n            for (const auto& header : headers) {\n                header_list = curl_slist_append(header_list, header.c_str());\n            }\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n        }\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode resCode = curl_easy_perform(curl);\n        if (resCode != CURLE_OK) {\n            free(chunk.memory);\n            curl_easy_cleanup(curl);\n            return -1;\n        }\n\n        res = chunk.memory ? chunk.memory : \"\";\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        free(chunk.memory);\n        curl_easy_cleanup(curl);\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers = {}, const std::string& body = \"\") {\n        std::string responseStr;\n        long httpCode = downloadPage(url, responseStr, headers, body);\n        if (httpCode == 200 && !responseStr.empty()) {\n            try {\n                res = json::parse(responseStr);\n            } catch (json::parse_error& e) {\n                return -2; // JSON parse error\n            }\n        }\n        return httpCode;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\nprivate:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (!ptr) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\npublic:\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl;\n        CURLcode res_code = CURLE_OK;\n        long http_code = 0;\n        struct MemoryStruct chunk;\n        chunk.memory = (char*)malloc(1);\n        chunk.size = 0;\n\n        curl = curl_easy_init();\n        if (!curl) {\n            return -1;\n        }\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        res_code = curl_easy_perform(curl);\n        if (res_code != CURLE_OK) {\n            http_code = -1;\n        } else {\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n            res.assign(chunk.memory, chunk.size);\n        }\n\n        curl_easy_cleanup(curl);\n        curl_slist_free_all(header_list);\n        free(chunk.memory);\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string response_str;\n        long status_code = downloadPage(url, response_str, headers, body);\n\n        if (status_code >= 200 && status_code < 300) {\n            try {\n                res = json::parse(response_str);\n            } catch (const json::parse_error&) {\n                status_code = -2;\n            }\n        }\n\n        return status_code;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (!ptr) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            return -1;\n        }\n\n        struct MemoryStruct chunk;\n        chunk.memory = (char*)malloc(1);\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n\n        if (!headers.empty()) {\n            struct curl_slist* headerList = nullptr;\n            for (const auto& header : headers) {\n                headerList = curl_slist_append(headerList, header.c_str());\n            }\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerList);\n        }\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode resCode = curl_easy_perform(curl);\n        if (resCode != CURLE_OK) {\n            free(chunk.memory);\n            curl_easy_cleanup(curl);\n            return -1;\n        }\n\n        res = chunk.memory;\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        curl_easy_cleanup(curl);\n        free(chunk.memory);\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string responseStr;\n        long httpStatus = downloadPage(url, responseStr, headers, body);\n\n        if (httpStatus == 200 && !responseStr.empty()) {\n            try {\n                res = json::parse(responseStr);\n            } catch (const json::parse_error&) {\n                return -2;\n            }\n        }\n\n        return httpStatus;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (ptr == nullptr) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl = curl_easy_init();\n        MemoryStruct chunk{nullptr, 0};\n\n        if (!curl) {\n            return -1;\n        }\n\n        struct curl_slist* headerList = nullptr;\n        for (const auto& header : headers) {\n            headerList = curl_slist_append(headerList, header.c_str());\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerList);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode resCode = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        if (resCode != CURLE_OK) {\n            http_code = -1;\n        } else {\n            res = chunk.memory ? chunk.memory : \"\";\n        }\n\n        curl_easy_cleanup(curl);\n        curl_slist_free_all(headerList);\n        if (chunk.memory) free(chunk.memory);\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string responseStr;\n        long statusCode = downloadPage(url, responseStr, headers, body);\n\n        if (statusCode >= 200 && statusCode < 300 && !responseStr.empty()) {\n            try {\n                res = json::parse(responseStr);\n            } catch (const json::parse_error&) {\n                return -2;\n            }\n        }\n\n        return statusCode;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (!ptr) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl = curl_easy_init();\n        if (!curl) return -1;\n\n        struct MemoryStruct chunk;\n        chunk.memory = (char*)malloc(1);\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n\n        if (!headers.empty()) {\n            struct curl_slist* headerList = nullptr;\n            for (const auto& header : headers) {\n                headerList = curl_slist_append(headerList, header.c_str());\n            }\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerList);\n        }\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode resCode = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        if (resCode != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(resCode) << std::endl;\n        } else {\n            res.assign(chunk.memory, chunk.size);\n        }\n\n        curl_easy_cleanup(curl);\n        free(chunk.memory);\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string responseStr;\n        long httpStatus = downloadPage(url, responseStr, headers, body);\n\n        if (httpStatus == 200) {\n            try {\n                res = json::parse(responseStr);\n            } catch (json::parse_error& e) {\n                std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n                return -2;\n            }\n        }\n\n        return httpStatus;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\nprivate:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t totalSize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + totalSize + 1);\n        if (!ptr) {\n            std::cerr << \"Not enough memory (realloc returned NULL)\" << std::endl;\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, totalSize);\n        mem->size += totalSize;\n        mem->memory[mem->size] = '\\0';\n\n        return totalSize;\n    }\n\npublic:\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curlHandle = curl_easy_init();\n        MemoryStruct chunk{nullptr, 0};\n\n        if (!curlHandle) {\n            return -1;\n        }\n\n        struct curl_slist* headerList = nullptr;\n        for (const auto& header : headers) {\n            headerList = curl_slist_append(headerList, header.c_str());\n        }\n\n        curl_easy_setopt(curlHandle, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curlHandle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curlHandle, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curlHandle, CURLOPT_HTTPHEADER, headerList);\n        curl_easy_setopt(curlHandle, CURLOPT_POSTFIELDS, body.c_str());\n        curl_easy_setopt(curlHandle, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode resCode = curl_easy_perform(curlHandle);\n        long httpCode = 0;\n        curl_easy_getinfo(curlHandle, CURLINFO_RESPONSE_CODE, &httpCode);\n\n        if (resCode != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(resCode) << std::endl;\n        } else {\n            res.assign(chunk.memory, chunk.size);\n        }\n\n        if (headerList) {\n            curl_slist_free_all(headerList);\n        }\n\n        if (chunk.memory) {\n            free(chunk.memory);\n        }\n\n        curl_easy_cleanup(curlHandle);\n        return httpCode;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string responseStr;\n        long httpCode = downloadPage(url, responseStr, headers, body);\n\n        if (httpCode >= 200 && httpCode < 300) {\n            try {\n                res = json::parse(responseStr);\n            } catch (const json::parse_error& e) {\n                std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n                return -1;\n            }\n        }\n\n        return httpCode;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);\n        if (ptr == NULL) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl_handle;\n        CURLcode result;\n        long http_code = 0;\n\n        MemoryStruct chunk;\n        chunk.memory = (char*)malloc(1);\n        chunk.size = 0;\n\n        curl_handle = curl_easy_init();\n        if (!curl_handle) {\n            return -1;\n        }\n\n        struct curl_slist* header_list = NULL;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n\n        curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, header_list);\n        curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, body.c_str());\n\n        result = curl_easy_perform(curl_handle);\n        if (result != CURLE_OK) {\n            fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(result));\n        } else {\n            curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &http_code);\n            res.assign(chunk.memory, chunk.size);\n        }\n\n        curl_easy_cleanup(curl_handle);\n        curl_slist_free_all(header_list);\n        free(chunk.memory);\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string response_str;\n        long status_code = downloadPage(url, response_str, headers, body);\n\n        if (status_code == 200 && !response_str.empty()) {\n            try {\n                res = json::parse(response_str);\n            } catch (const json::parse_error& e) {\n                std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n                return -1;\n            }\n        }\n\n        return status_code;\n    }\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Implement a TCP client function that establishes a connection to a server, sends data, and reads the server's response in a continuous loop, handling connection errors and reconnection attempts.\n\nFunction Description: The function `readwrite_routine` implements a TCP client that continuously attempts to connect to a specified server endpoint. Once connected, it sends a fixed message and reads the server's response. If the connection fails or is lost, it automatically attempts to reconnect. The function handles connection states and errors appropriately, including non-blocking connection scenarios.\n\nInput: \n- `arg` (void pointer): A pointer to a `stEndPoint` structure containing:\n  - `ip` (char pointer): The IP address of the server to connect to (can be NULL or special values for default behavior)\n  - `port` (unsigned short int): The port number of the server to connect to\n\nOutput: \n- Returns NULL (void pointer) when the loop exits (though the provided implementation has an infinite loop)\n- No explicit return value, but performs I/O operations through the socket\n\nNote: The function runs in an infinite loop and should typically be executed in a separate thread. It manages its own socket lifecycle, creating and closing sockets as needed during connection attempts and communication.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nstruct stEndPoint\n{\n    char *ip;\n    unsigned short int port;\n};\n\nstatic void SetAddr(const char *pszIP, const unsigned short shPort, struct sockaddr_in &addr)\n{\n    bzero(&addr, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(shPort);\n    int nIP = 0;\n    if(!pszIP || '\\0' == *pszIP   \n            || 0 == strcmp(pszIP,\"0\") || 0 == strcmp(pszIP,\"0.0.0.0\") \n            || 0 == strcmp(pszIP,\"*\") \n      )\n    {\n        nIP = htonl(INADDR_ANY);\n    }\n    else\n    {\n        nIP = inet_addr(pszIP);\n    }\n    addr.sin_addr.s_addr = nIP;\n}\n\nstatic void *readwrite_routine(void *arg)\n{\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    char str[8] = \"sarlmol\";\n    char buf[1024 * 16];\n    int fd = -1;\n    int ret = 0;\n    \n    for(;;)\n    {\n        if(fd < 0)\n        {\n            fd = socket(PF_INET, SOCK_STREAM, 0);\n            struct sockaddr_in addr;\n            SetAddr(endpoint->ip, endpoint->port, addr);\n            ret = connect(fd, (struct sockaddr*)&addr, sizeof(addr));\n            \n            if(errno == EALREADY || errno == EINPROGRESS)\n            {       \n                struct pollfd pf = {0};\n                pf.fd = fd;\n                pf.events = (POLLOUT|POLLERR|POLLHUP);\n                co_poll(co_get_epoll_ct(), &pf, 1, 200);\n                \n                int error = 0;\n                uint32_t socklen = sizeof(error);\n                errno = 0;\n                ret = getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *)&error, &socklen);\n                if(ret == -1)\n                {       \n                    close(fd);\n                    fd = -1;\n                    continue;\n                }       \n                if(error)\n                {       \n                    errno = error;\n                    close(fd);\n                    fd = -1;\n                    continue;\n                }       \n            }\n        }\n        \n        ret = write(fd, str, 8);\n        if(ret > 0)\n        {\n            ret = read(fd, buf, sizeof(buf));\n            if(ret <= 0)\n            {\n                close(fd);\n                fd = -1;\n            }\n        }\n        else\n        {\n            close(fd);\n            fd = -1;\n        }\n    }\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pthread.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    int sockfd;\n    struct sockaddr_in serv_addr;\n    struct hostent *server;\n    char* message = \"Hello from client\";\n    char buffer[1024];\n    \n    while (1) {\n        // Create socket\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"ERROR opening socket\");\n            sleep(5);  // Wait before retrying\n            continue;\n        }\n\n        // Initialize server address\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(endpoint->port);\n\n        // Handle IP address\n        if (endpoint->ip == NULL || strcmp(endpoint->ip, \"INADDR_ANY\") == 0) {\n            serv_addr.sin_addr.s_addr = INADDR_ANY;\n        } else if (inet_aton(endpoint->ip, &serv_addr.sin_addr) <= 0) {\n            server = gethostbyname(endpoint->ip);\n            if (server == NULL) {\n                fprintf(stderr, \"ERROR, no such host\\n\");\n                close(sockfd);\n                sleep(5);  // Wait before retrying\n                continue;\n            }\n            memcpy((char*)&serv_addr.sin_addr.s_addr, (char*)server->h_addr, server->h_length);\n        }\n\n        // Connect to server\n        if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n            perror(\"ERROR connecting\");\n            close(sockfd);\n            sleep(5);  // Wait before retrying\n            continue;\n        }\n\n        // Connection established, send and receive data\n        while (1) {\n            // Send message\n            if (send(sockfd, message, strlen(message), 0) < 0) {\n                perror(\"ERROR writing to socket\");\n                break;  // Break inner loop to reconnect\n            }\n\n            // Receive response\n            memset(buffer, 0, sizeof(buffer));\n            int n = recv(sockfd, buffer, sizeof(buffer)-1, 0);\n            if (n < 0) {\n                perror(\"ERROR reading from socket\");\n                break;  // Break inner loop to reconnect\n            } else if (n == 0) {\n                printf(\"Server closed connection\\n\");\n                break;  // Break inner loop to reconnect\n            }\n\n            printf(\"Server response: %s\\n\", buffer);\n            \n            // Sleep a bit before sending next message\n            sleep(1);\n        }\n\n        // Close socket and try to reconnect\n        close(sockfd);\n        sleep(5);  // Wait before retrying connection\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pthread.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    int sockfd;\n    struct sockaddr_in serv_addr;\n    struct hostent *server;\n    char message[] = \"Hello from client\";\n    char buffer[1024];\n    \n    while (1) {\n        // Create socket\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"ERROR opening socket\");\n            sleep(5);  // Wait before retrying\n            continue;\n        }\n\n        // Initialize server address structure\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(endpoint->port);\n\n        // Get server by name or use default\n        if (endpoint->ip != NULL && inet_aton(endpoint->ip, &serv_addr.sin_addr) <= 0) {\n            server = gethostbyname(endpoint->ip);\n            if (server == NULL) {\n                fprintf(stderr, \"ERROR, no such host\\n\");\n                close(sockfd);\n                sleep(5);\n                continue;\n            }\n            memcpy(&serv_addr.sin_addr, server->h_addr, server->h_length);\n        } else if (endpoint->ip == NULL) {\n            serv_addr.sin_addr.s_addr = INADDR_ANY;  // Default to any interface\n        }\n\n        // Connect to server\n        if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n            perror(\"ERROR connecting\");\n            close(sockfd);\n            sleep(5);  // Wait before retrying\n            continue;\n        }\n\n        printf(\"Connected to server\\n\");\n\n        // Communication loop\n        while (1) {\n            // Send data to server\n            if (send(sockfd, message, strlen(message), 0) < 0) {\n                perror(\"ERROR writing to socket\");\n                break;\n            }\n\n            // Read response from server\n            memset(buffer, 0, sizeof(buffer));\n            int n = recv(sockfd, buffer, sizeof(buffer)-1, 0);\n            if (n < 0) {\n                perror(\"ERROR reading from socket\");\n                break;\n            } else if (n == 0) {\n                printf(\"Server closed connection\\n\");\n                break;\n            }\n\n            printf(\"Server response: %s\\n\", buffer);\n            \n            // Small delay between sends\n            sleep(1);\n        }\n\n        // Close socket and try reconnecting\n        close(sockfd);\n        printf(\"Reconnecting...\\n\");\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <fcntl.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    const char* message = \"Hello from client\";\n    const int message_len = strlen(message);\n    \n    while (1) {\n        int sockfd = -1;\n        struct addrinfo hints, *servinfo, *p;\n        int rv;\n        \n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        \n        char port_str[6];\n        snprintf(port_str, sizeof(port_str), \"%d\", endpoint->port);\n        \n        if ((rv = getaddrinfo(endpoint->ip ? endpoint->ip : \"127.0.0.1\", \n                             port_str, &hints, &servinfo)) != 0) {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(rv));\n            sleep(5);\n            continue;\n        }\n        \n        for (p = servinfo; p != NULL; p = p->ai_next) {\n            if ((sockfd = socket(p->ai_family, p->ai_socktype, \n                                p->ai_protocol)) == -1) {\n                continue;\n            }\n            \n            int flags = fcntl(sockfd, F_GETFL, 0);\n            fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n            \n            connect(sockfd, p->ai_addr, p->ai_addrlen);\n            \n            fd_set write_fds;\n            FD_ZERO(&write_fds);\n            FD_SET(sockfd, &write_fds);\n            \n            struct timeval timeout;\n            timeout.tv_sec = 5;\n            timeout.tv_usec = 0;\n            \n            if (select(sockfd + 1, NULL, &write_fds, NULL, &timeout) <= 0) {\n                close(sockfd);\n                sockfd = -1;\n                continue;\n            }\n            \n            int so_error;\n            socklen_t len = sizeof(so_error);\n            getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len);\n            \n            if (so_error != 0) {\n                close(sockfd);\n                sockfd = -1;\n                continue;\n            }\n            \n            fcntl(sockfd, F_SETFL, flags & ~O_NONBLOCK);\n            break;\n        }\n        \n        freeaddrinfo(servinfo);\n        \n        if (sockfd == -1) {\n            sleep(5);\n            continue;\n        }\n        \n        while (1) {\n            if (send(sockfd, message, message_len, 0) == -1) {\n                perror(\"send\");\n                break;\n            }\n            \n            char buffer[4096];\n            ssize_t numbytes;\n            \n            if ((numbytes = recv(sockfd, buffer, sizeof(buffer) - 1, 0)) <= 0) {\n                if (numbytes == 0) {\n                    printf(\"Server closed connection\\n\");\n                } else {\n                    perror(\"recv\");\n                }\n                break;\n            }\n            \n            buffer[numbytes] = '\\0';\n            printf(\"Received: %s\\n\", buffer);\n            \n            sleep(1);\n        }\n        \n        close(sockfd);\n        sleep(5);\n    }\n    \n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <fcntl.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    const char* message = \"Hello from client\";\n    const int MAX_RETRIES = 5;\n    const int RETRY_DELAY_MS = 3000;\n    \n    while (1) {\n        int sockfd = -1;\n        struct addrinfo hints, *servinfo, *p;\n        int rv;\n        char ipstr[INET6_ADDRSTRLEN];\n        \n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        \n        char portstr[6];\n        snprintf(portstr, sizeof(portstr), \"%d\", endpoint->port);\n        \n        if ((rv = getaddrinfo(endpoint->ip ? endpoint->ip : \"127.0.0.1\", portstr, &hints, &servinfo)) != 0) {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(rv));\n            usleep(RETRY_DELAY_MS * 1000);\n            continue;\n        }\n        \n        for(p = servinfo; p != NULL; p = p->ai_next) {\n            if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {\n                perror(\"client: socket\");\n                continue;\n            }\n            \n            // Set non-blocking\n            int flags = fcntl(sockfd, F_GETFL, 0);\n            fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n            \n            // Try connecting\n            int connect_result = connect(sockfd, p->ai_addr, p->ai_addrlen);\n            \n            if (connect_result == -1) {\n                if (errno == EINPROGRESS) {\n                    // Connection in progress, wait for it to complete\n                    fd_set writefds;\n                    FD_ZERO(&writefds);\n                    FD_SET(sockfd, &writefds);\n                    \n                    struct timeval timeout;\n                    timeout.tv_sec = 5;\n                    timeout.tv_usec = 0;\n                    \n                    if (select(sockfd + 1, NULL, &writefds, NULL, &timeout) <= 0) {\n                        perror(\"client: select timeout or error\");\n                        close(sockfd);\n                        sockfd = -1;\n                        continue;\n                    }\n                    \n                    // Check if the connection was successful\n                    int so_error;\n                    socklen_t len = sizeof(so_error);\n                    getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len);\n                    \n                    if (so_error != 0) {\n                        perror(\"client: delayed connection failure\");\n                        close(sockfd);\n                        sockfd = -1;\n                        continue;\n                    }\n                } else {\n                    perror(\"client: connect\");\n                    close(sockfd);\n                    sockfd = -1;\n                    continue;\n                }\n            }\n            \n            break; // If we get here, we connected\n        }\n        \n        if (p == NULL) {\n            fprintf(stderr, \"client: failed to connect\\n\");\n            freeaddrinfo(servinfo);\n            usleep(RETRY_DELAY_MS * 1000);\n            continue;\n        }\n        \n        freeaddrinfo(servinfo); // All done with this\n        \n        printf(\"client: connecting to %s\\n\", \n               inet_ntop(p->ai_family, \n                         p->ai_addr->sa_data + (p->ai_family == AF_INET6 ? 6 : 4),\n                         ipstr, sizeof ipstr));\n        \n        // Reset flags to blocking\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        fcntl(sockfd, F_SETFL, flags & ~O_NONBLOCK);\n        \n        // Connection established, start communication\n        while (1) {\n            // Send data\n            if (send(sockfd, message, strlen(message), 0) == -1) {\n                perror(\"client: send\");\n                break;\n            }\n            \n            // Receive response\n            char buf[1024];\n            int numbytes;\n            \n            if ((numbytes = recv(sockfd, buf, sizeof(buf)-1, 0)) == -1) {\n                perror(\"client: recv\");\n                break;\n            } else if (numbytes == 0) {\n                printf(\"Server closed connection\\n\");\n                break;\n            }\n            \n            buf[numbytes] = '\\0';\n            printf(\"client: received '%s'\\n\", buf);\n            \n            // Small delay between messages\n            usleep(100000); // 100ms\n        }\n        \n        close(sockfd);\n        printf(\"Reconnecting in %d seconds...\\n\", RETRY_DELAY_MS / 1000);\n        usleep(RETRY_DELAY_MS * 1000);\n    }\n    \n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pthread.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    int sockfd;\n    struct sockaddr_in serv_addr;\n    struct hostent *server;\n    char* message = \"Hello from client\";\n    char buffer[1024];\n    int retry_delay = 1; // seconds\n\n    while (1) {\n        // Create socket\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"ERROR opening socket\");\n            sleep(retry_delay);\n            continue;\n        }\n\n        // Set server address\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(endpoint->port);\n\n        // Handle IP address\n        if (endpoint->ip != NULL) {\n            if (inet_aton(endpoint->ip, &serv_addr.sin_addr) <= 0) {\n                server = gethostbyname(endpoint->ip);\n                if (server == NULL) {\n                    fprintf(stderr, \"ERROR, no such host\\n\");\n                    close(sockfd);\n                    sleep(retry_delay);\n                    continue;\n                }\n                memcpy((char*)&serv_addr.sin_addr, (char*)server->h_addr, server->h_length);\n            }\n        } else {\n            serv_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        // Connect to server\n        if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n            perror(\"ERROR connecting\");\n            close(sockfd);\n            sleep(retry_delay);\n            continue;\n        }\n\n        // Reset retry delay after successful connection\n        retry_delay = 1;\n\n        // Send data\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            perror(\"ERROR writing to socket\");\n            close(sockfd);\n            sleep(retry_delay);\n            continue;\n        }\n\n        // Read response\n        memset(buffer, 0, sizeof(buffer));\n        int n = recv(sockfd, buffer, sizeof(buffer)-1, 0);\n        if (n < 0) {\n            perror(\"ERROR reading from socket\");\n            close(sockfd);\n            sleep(retry_delay);\n            continue;\n        } else if (n == 0) {\n            // Connection closed by server\n            printf(\"Connection closed by server\\n\");\n            close(sockfd);\n            sleep(retry_delay);\n            continue;\n        }\n\n        printf(\"Server response: %s\\n\", buffer);\n\n        // Close socket\n        close(sockfd);\n\n        // Add a small delay before next iteration\n        usleep(100000); // 0.1 seconds\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <netdb.h>\n#include <pthread.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    const char* message = \"Hello from client\";\n    const int message_len = strlen(message);\n    const int buffer_size = 1024;\n    \n    while (1) {\n        int sockfd = -1;\n        struct sockaddr_in server_addr;\n        int connected = 0;\n        \n        // Create socket\n        if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n            perror(\"Socket creation error\");\n            sleep(5);\n            continue;\n        }\n        \n        // Set non-blocking\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n        \n        // Prepare sockaddr_in structure\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n        \n        // Convert IPv4 or IPv6 addresses from text to binary form\n        if (endpoint->ip && inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n            struct hostent* server = gethostbyname(endpoint->ip);\n            if (!server) {\n                fprintf(stderr, \"Hostname resolution failed\\n\");\n                close(sockfd);\n                sleep(5);\n                continue;\n            }\n            memcpy(&server_addr.sin_addr, server->h_addr, server->h_length);\n        } else if (!endpoint->ip) {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n        \n        // Connect to remote server\n        int connect_status = connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n        \n        if (connect_status < 0) {\n            if (errno == EINPROGRESS) {\n                // Wait for connection to establish\n                fd_set writefds;\n                FD_ZERO(&writefds);\n                FD_SET(sockfd, &writefds);\n                \n                struct timeval timeout;\n                timeout.tv_sec = 10;\n                timeout.tv_usec = 0;\n                \n                int select_status = select(sockfd + 1, NULL, &writefds, NULL, &timeout);\n                \n                if (select_status > 0) {\n                    // Check if socket is connected\n                    int so_error;\n                    socklen_t len = sizeof(so_error);\n                    getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len);\n                    \n                    if (so_error == 0) {\n                        connected = 1;\n                    } else {\n                        fprintf(stderr, \"Connection error: %s\\n\", strerror(so_error));\n                    }\n                } else if (select_status == 0) {\n                    fprintf(stderr, \"Connection timeout\\n\");\n                } else {\n                    perror(\"Select error\");\n                }\n            } else {\n                perror(\"Connection failed\");\n            }\n        } else {\n            connected = 1;\n        }\n        \n        if (connected) {\n            printf(\"Connected to server\\n\");\n            \n            // Reset socket to blocking mode\n            fcntl(sockfd, F_SETFL, flags & ~O_NONBLOCK);\n            \n            // Communication loop\n            while (1) {\n                // Send data\n                if (send(sockfd, message, message_len, 0) < 0) {\n                    perror(\"Send failed\");\n                    break;\n                }\n                \n                // Receive response\n                char buffer[buffer_size];\n                int bytes_received = recv(sockfd, buffer, buffer_size - 1, 0);\n                \n                if (bytes_received <= 0) {\n                    if (bytes_received == 0) {\n                        printf(\"Server disconnected\\n\");\n                    } else {\n                        perror(\"Receive error\");\n                    }\n                    break;\n                }\n                \n                buffer[bytes_received] = '\\0';\n                printf(\"Received: %s\\n\", buffer);\n                \n                // Wait before next send\n                sleep(1);\n            }\n        }\n        \n        // Close socket and wait before reconnecting\n        if (sockfd >= 0) {\n            close(sockfd);\n        }\n        \n        sleep(5); // Wait before attempting to reconnect\n    }\n    \n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <netdb.h>\n#include <pthread.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    const char* message = \"Hello, server!\";\n    const int buffer_size = 1024;\n    char buffer[buffer_size];\n    \n    while (1) {\n        int sockfd = -1;\n        struct sockaddr_in serv_addr;\n        struct hostent *server;\n        \n        // Create socket\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"ERROR opening socket\");\n            sleep(5); // Wait before retrying\n            continue;\n        }\n        \n        // Set non-blocking\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n        \n        // Initialize server address\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(endpoint->port);\n        \n        // Handle IP address\n        if (endpoint->ip != NULL) {\n            if (inet_aton(endpoint->ip, &serv_addr.sin_addr) <= 0) {\n                server = gethostbyname(endpoint->ip);\n                if (server == NULL) {\n                    fprintf(stderr, \"ERROR, no such host\\n\");\n                    close(sockfd);\n                    sleep(5);\n                    continue;\n                }\n                memcpy((char*)&serv_addr.sin_addr.s_addr, (char*)server->h_addr, server->h_length);\n            }\n        } else {\n            serv_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n        \n        // Connect to server\n        int connect_result = connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n        \n        if (connect_result < 0) {\n            if (errno == EINPROGRESS) {\n                // Wait for connection to establish\n                fd_set writefds;\n                FD_ZERO(&writefds);\n                FD_SET(sockfd, &writefds);\n                \n                struct timeval timeout;\n                timeout.tv_sec = 5;\n                timeout.tv_usec = 0;\n                \n                int select_result = select(sockfd + 1, NULL, &writefds, NULL, &timeout);\n                \n                if (select_result <= 0 || !FD_ISSET(sockfd, &writefds)) {\n                    fprintf(stderr, \"Non-blocking connect timed out or failed\\n\");\n                    close(sockfd);\n                    sleep(5);\n                    continue;\n                }\n            } else {\n                perror(\"Connection failed\");\n                close(sockfd);\n                sleep(5);\n                continue;\n            }\n        }\n        \n        // Connection successful, restore blocking mode\n        fcntl(sockfd, F_SETFL, flags);\n        \n        // Communication loop\n        while (1) {\n            // Send message\n            ssize_t bytes_sent = send(sockfd, message, strlen(message), 0);\n            if (bytes_sent < 0) {\n                perror(\"Send failed\");\n                break;\n            }\n            \n            // Receive response\n            memset(buffer, 0, buffer_size);\n            ssize_t bytes_received = recv(sockfd, buffer, buffer_size - 1, 0);\n            if (bytes_received <= 0) {\n                if (bytes_received == 0) {\n                    printf(\"Server disconnected\\n\");\n                } else {\n                    perror(\"Receive failed\");\n                }\n                break;\n            }\n            \n            printf(\"Received: %s\\n\", buffer);\n            \n            // Wait before sending next message\n            sleep(1);\n        }\n        \n        // Close socket and try to reconnect\n        close(sockfd);\n        sleep(5);\n    }\n    \n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <netdb.h>\n#include <pthread.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    const char* message = \"Hello from client\";\n    const int buffer_size = 1024;\n\n    while (1) {\n        int sockfd = -1;\n        struct sockaddr_in server_addr;\n        socklen_t addr_len = sizeof(server_addr);\n        int connected = 0;\n\n        // Create socket\n        if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n            perror(\"Socket creation error\");\n            sleep(5);\n            continue;\n        }\n\n        // Set non-blocking\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n\n        // Configure server address\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        // Handle special IP cases\n        if (endpoint->ip == NULL || strcmp(endpoint->ip, \"INADDR_ANY\") == 0) {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        } else if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n            // If IP is not numeric, try DNS lookup\n            struct hostent* host_entry = gethostbyname(endpoint->ip);\n            if (host_entry == NULL) {\n                fprintf(stderr, \"Invalid IP or hostname: %s\\n\", endpoint->ip);\n                close(sockfd);\n                sleep(5);\n                continue;\n            }\n            memcpy(&server_addr.sin_addr, host_entry->h_addr_list[0], host_entry->h_length);\n        }\n\n        // Connect to server\n        int connect_status = connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n        \n        if (connect_status == -1) {\n            if (errno == EINPROGRESS) {\n                // Wait for connection to establish\n                fd_set writefds;\n                FD_ZERO(&writefds);\n                FD_SET(sockfd, &writefds);\n                \n                struct timeval timeout = {5, 0}; // 5 seconds timeout\n                \n                if (select(sockfd + 1, NULL, &writefds, NULL, &timeout) > 0) {\n                    int so_error;\n                    socklen_t len = sizeof(so_error);\n                    getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len);\n                    if (so_error == 0) connected = 1;\n                }\n            }\n        } else {\n            connected = 1;\n        }\n\n        if (!connected) {\n            fprintf(stderr, \"Connection failed\\n\");\n            close(sockfd);\n            sleep(5);\n            continue;\n        }\n\n        // Reset socket to blocking mode\n        fcntl(sockfd, F_SETFL, flags);\n\n        // Connection established, send and receive data\n        while (1) {\n            // Send data\n            if (send(sockfd, message, strlen(message), 0) == -1) {\n                perror(\"Send failed\");\n                break;\n            }\n\n            // Receive response\n            char buffer[buffer_size];\n            ssize_t bytes_received;\n            if ((bytes_received = recv(sockfd, buffer, buffer_size - 1, 0)) > 0) {\n                buffer[bytes_received] = '\\0';\n                printf(\"Received: %s\\n\", buffer);\n            } else if (bytes_received == 0) {\n                printf(\"Server disconnected\\n\");\n                break;\n            } else {\n                perror(\"Receive error\");\n                break;\n            }\n\n            // Small delay before next message\n            sleep(1);\n        }\n\n        // Connection lost, cleanup and retry\n        close(sockfd);\n        sleep(5);\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pthread.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    int sockfd;\n    struct sockaddr_in serv_addr;\n    struct hostent *server;\n    char* message = \"Hello from client\";\n    char buffer[1024];\n    int retry_interval = 5; // seconds\n\n    while (1) {\n        // Create socket\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"ERROR opening socket\");\n            sleep(retry_interval);\n            continue;\n        }\n\n        // Set server address\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(endpoint->port);\n\n        // Handle IP address\n        if (endpoint->ip != NULL) {\n            if (inet_aton(endpoint->ip, &serv_addr.sin_addr) <= 0) {\n                server = gethostbyname(endpoint->ip);\n                if (server == NULL) {\n                    fprintf(stderr, \"ERROR, no such host\\n\");\n                    close(sockfd);\n                    sleep(retry_interval);\n                    continue;\n                }\n                memcpy((char*)&serv_addr.sin_addr.s_addr, (char*)server->h_addr, server->h_length);\n            }\n        } else {\n            serv_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        // Connect to server\n        if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n            perror(\"ERROR connecting\");\n            close(sockfd);\n            sleep(retry_interval);\n            continue;\n        }\n\n        // Connection established, send and receive data\n        while (1) {\n            // Send data\n            if (send(sockfd, message, strlen(message), 0) < 0) {\n                perror(\"ERROR writing to socket\");\n                break;\n            }\n\n            // Receive response\n            memset(buffer, 0, sizeof(buffer));\n            int n = recv(sockfd, buffer, sizeof(buffer)-1, 0);\n            if (n < 0) {\n                perror(\"ERROR reading from socket\");\n                break;\n            } else if (n == 0) {\n                printf(\"Server closed connection\\n\");\n                break;\n            }\n\n            printf(\"Server response: %s\\n\", buffer);\n        }\n\n        // Close socket and try to reconnect\n        close(sockfd);\n        sleep(retry_interval);\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pthread.h>\n\ntypedef struct {\n    char* ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint* endpoint = (stEndPoint*)arg;\n    int sockfd;\n    struct sockaddr_in serv_addr;\n    struct hostent *server;\n    char* message = \"Hello from client\";\n    char buffer[1024];\n    int retry_delay = 5; // seconds\n\n    while (1) {\n        // Create socket\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"ERROR opening socket\");\n            sleep(retry_delay);\n            continue;\n        }\n\n        // Set server address\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(endpoint->port);\n\n        // Handle IP address\n        if (endpoint->ip == NULL || strcmp(endpoint->ip, \"INADDR_ANY\") == 0) {\n            serv_addr.sin_addr.s_addr = INADDR_ANY;\n        } else if (inet_aton(endpoint->ip, &serv_addr.sin_addr)) {\n            // IP address is valid\n        } else {\n            server = gethostbyname(endpoint->ip);\n            if (server == NULL) {\n                fprintf(stderr, \"ERROR, no such host\\n\");\n                close(sockfd);\n                sleep(retry_delay);\n                continue;\n            }\n            memcpy((char*)&serv_addr.sin_addr.s_addr, (char*)server->h_addr, server->h_length);\n        }\n\n        // Connect to server\n        if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n            perror(\"ERROR connecting\");\n            close(sockfd);\n            sleep(retry_delay);\n            continue;\n        }\n\n        // Connection established - send and receive data\n        while (1) {\n            // Send data\n            if (send(sockfd, message, strlen(message), 0) < 0) {\n                perror(\"ERROR writing to socket\");\n                break;\n            }\n\n            // Receive response\n            memset(buffer, 0, sizeof(buffer));\n            int n = recv(sockfd, buffer, sizeof(buffer)-1, 0);\n            if (n < 0) {\n                perror(\"ERROR reading from socket\");\n                break;\n            } else if (n == 0) {\n                printf(\"Server closed connection\\n\");\n                break;\n            }\n\n            printf(\"Server response: %s\\n\", buffer);\n\n            // Small delay before next send\n            sleep(1);\n        }\n\n        // Close socket and try to reconnect\n        close(sockfd);\n        sleep(retry_delay);\n    }\n\n    return NULL;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server (localhost on port 8888 in this case), and enters a loop where it reads user input from stdin, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed by either side.\n\nInput: None (The server IP and port are hardcoded as 127.0.0.1 and 8888 respectively in the function. User input is collected interactively during execution.)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value. All communication results are handled via side effects.)\n\nNote: The function handles its own socket cleanup by closing the connection before exiting.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) <= 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Connection closed or read error\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::string input;\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n\n        if (send(sock, message.c_str(), message.size(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Connection closed or read error\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Connection closed or read error\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n        if (input.empty()) continue;\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input to the server, and prints the server's response. The function should handle basic error cases and properly close the connection when done.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and displays the server's response. The loop continues until an error occurs or the connection is closed by the server. The function handles socket creation, connection, data transmission, and cleanup.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 1234 respectively in the function)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(1234);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n    \n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(1234);\n    \n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.size(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << std::string(buffer, valread) << std::endl;\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n    \n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(1234);\n    \n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 1234;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n        if (input.empty()) continue;\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 1234;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            if (valread == 0) {\n                std::cout << \"Server disconnected\\n\";\n            } else {\n                std::cerr << \"Read failed\\n\";\n            }\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 1234;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            if (valread == 0) {\n                std::cout << \"Server closed connection\\n\";\n            } else {\n                std::cerr << \"Read error\\n\";\n            }\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 1234;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            if (valread == 0) {\n                std::cout << \"Server closed connection\\n\";\n            } else {\n                std::cerr << \"Read error\\n\";\n            }\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 1234;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n        if (input.empty()) continue;\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n\n        std::cout << \"Server response: \" << std::string(buffer, valread) << \"\\n\";\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char *server_ip = \"127.0.0.1\";\n    int port = 1234;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            if (valread == 0) {\n                std::cout << \"Server closed connection\\n\";\n            } else {\n                std::cerr << \"Read error\\n\";\n            }\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 1234;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (send(sock, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer) - 1);\n        if (valread <= 0) {\n            if (valread == 0) {\n                std::cout << \"Server closed connection\\n\";\n            } else {\n                std::cerr << \"Read error\\n\";\n            }\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    const char* server_ip = \"127.0.0.1\";\n    int port = 1234;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\\n\";\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection Failed\\n\";\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n        if (input.empty()) continue;\n\n        if (send(sock, input.c_str(), input.length(), 0) <= 0) {\n            std::cerr << \"Send failed\\n\";\n            break;\n        }\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected or read error\\n\";\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a TCP server in C++ that listens for incoming connections, receives data from clients, and echoes the data back to the clients. The server should handle one client at a time and properly clean up resources when the connection is terminated.\n\nFunction Description: The function `create_tcp_server` establishes a TCP server that binds to a specified IP address and port, listens for incoming connections, and handles client communication. It reads data from the client and sends the same data back (echo). The server runs until the client disconnects or an error occurs.\n\nInput: \n- `ip`: [const char*] - The IP address the server should bind to (e.g., \"127.0.0.1\" for localhost).\n- `port`: [int] - The port number the server should listen on (e.g., 8080).\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any step fails (socket creation, binding, listening, or accepting connections).",
    "Canonical_solution": "#include <stdio.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(bind(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    if(listen(sockfd, SOMAXCONN) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    bzero(&clnt_addr, sizeof(clnt_addr));\n\n    int clnt_sockfd = accept(sockfd, (sockaddr*)&clnt_addr, &clnt_addr_len);\n    if(clnt_sockfd == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sockfd, inet_ntoa(clnt_addr.sin_addr), ntohs(clnt_addr.sin_port));\n    \n    char buf[1024];\n    while (true) {\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(clnt_sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from client fd %d: %s\\n\", clnt_sockfd, buf);\n            write(clnt_sockfd, buf, sizeof(buf));\n        } else if(read_bytes == 0){\n            printf(\"client fd %d disconnected\\n\", clnt_sockfd);\n            close(clnt_sockfd);\n            break;\n        } else if(read_bytes == -1){\n            close(clnt_sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int new_socket = -1;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024] = {0};\n    int valread;\n\n    while ((valread = read(new_socket, buffer, sizeof(buffer))) > 0) {\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int new_socket = -1;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024] = {0};\n    int valread;\n\n    while ((valread = read(new_socket, buffer, sizeof(buffer))) > 0) {\n        write(new_socket, buffer, valread);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int new_socket = -1;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024] = {0};\n    int valread;\n\n    while ((valread = read(new_socket, buffer, sizeof(buffer))) > 0) {\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int new_socket = -1;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024] = {0};\n    int valread;\n\n    while ((valread = read(new_socket, buffer, sizeof(buffer))) > 0) {\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int new_socket = -1;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024] = {0};\n    int valread;\n\n    while ((valread = read(new_socket, buffer, sizeof(buffer))) > 0) {\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int client_fd = -1;\n    struct sockaddr_in server_addr{};\n    struct sockaddr_in client_addr{};\n    socklen_t client_len = sizeof(client_addr);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n        return -1;\n    }\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, SOMAXCONN) == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    if ((client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len)) == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024];\n    ssize_t bytes_read;\n\n    while ((bytes_read = read(client_fd, buffer, sizeof(buffer))) > 0) {\n        write(client_fd, buffer, bytes_read);\n    }\n\n    close(client_fd);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int client_fd = -1;\n    struct sockaddr_in server_addr{};\n    struct sockaddr_in client_addr{};\n    socklen_t client_len = sizeof(client_addr);\n\n    // Create socket\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd == -1) {\n        return -1;\n    }\n\n    // Set up server address structure\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    // Bind the socket\n    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 1) == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    // Accept a connection\n    client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);\n    if (client_fd == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    const int buffer_size = 1024;\n    char buffer[buffer_size];\n    ssize_t bytes_read;\n\n    // Echo loop\n    while ((bytes_read = read(client_fd, buffer, buffer_size - 1)) > 0) {\n        buffer[bytes_read] = '\\0'; // Null-terminate received data\n        write(client_fd, buffer, bytes_read); // Echo back\n    }\n\n    // Cleanup\n    close(client_fd);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int new_socket = -1;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024] = {0};\n    int valread;\n\n    while ((valread = read(new_socket, buffer, sizeof(buffer))) > 0) {\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int client_fd = -1;\n    struct sockaddr_in server_addr{};\n    struct sockaddr_in client_addr{};\n    socklen_t client_len = sizeof(client_addr);\n\n    // Create socket\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd == -1) {\n        return -1;\n    }\n\n    // Set up server address structure\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    // Bind the socket\n    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, SOMAXCONN) == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    // Accept a connection\n    client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);\n    if (client_fd == -1) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024];\n    ssize_t bytes_read;\n\n    // Echo loop\n    while ((bytes_read = read(client_fd, buffer, sizeof(buffer))) > 0) {\n        if (write(client_fd, buffer, bytes_read) != bytes_read) {\n            break; // Write failed\n        }\n    }\n\n    // Clean up\n    close(client_fd);\n    close(server_fd);\n\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd = -1;\n    int new_socket = -1;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        close(server_fd);\n        return -1;\n    }\n\n    char buffer[1024] = {0};\n    int valread;\n\n    while ((valread = read(new_socket, buffer, sizeof(buffer))) > 0) {\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "matched_results": [
      "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <cstring>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n\n#define MAXSOCK 16\n#define BUFFER_SIZE 4096\n\nclass RGBController {};\n\nstruct NetworkClientInfo {\n    int client_socket;\n    std::string ip_address;\n    unsigned short port;\n    std::atomic<bool> active;\n    std::thread listen_thread;\n};\n\nclass NetworkServer {\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    int server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n\npublic:\n    NetworkServer(std::vector<RGBController*>& control) : host(\"0.0.0.0\"), port_num(8080), server_online(false),\n        server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        if (server_online) return;\n\n        // Initialize sockets\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = -1;\n            ConnectionThread[i] = nullptr;\n        }\n\n        struct addrinfo hints, *res, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        char port_str[6];\n        snprintf(port_str, sizeof(port_str), \"%d\", port_num);\n\n        if (getaddrinfo(host.empty() ? nullptr : host.c_str(), port_str, &hints, &res) != 0) {\n            std::cerr << \"Failed to resolve address\" << std::endl;\n            return;\n        }\n\n        int sock_idx = 0;\n        for (p = res; p != nullptr && sock_idx < MAXSOCK; p = p->ai_next) {\n            int sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (sockfd == -1) continue;\n\n            int opt = 1;\n            setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n            if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {\n                close(sockfd);\n                continue;\n            }\n\n            if (listen(sockfd, SOMAXCONN) == -1) {\n                close(sockfd);\n                continue;\n            }\n\n            server_sock[sock_idx++] = sockfd;\n\n            // Set non-blocking\n            fcntl(sockfd, F_SETFL, O_NONBLOCK);\n        }\n\n        freeaddrinfo(res);\n\n        if (sock_idx == 0) {\n            std::cerr << \"Failed to create any listening sockets\" << std::endl;\n            return;\n        }\n\n        socket_count = sock_idx;\n        server_online = true;\n        server_listening = true;\n\n        for (int i = 0; i < socket_count; ++i) {\n            ConnectionThread[i] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, i);\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_listening = false;\n        server_online = false;\n\n        // Close all server sockets\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != -1) {\n                shutdown(server_sock[i], SHUT_RDWR);\n                close(server_sock[i]);\n                server_sock[i] = -1;\n            }\n        }\n\n        // Join and delete connection threads\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        // Clean up clients\n        std::lock_guard<std::mutex> lock(ServerClientsMutex);\n        for (auto client_info : ServerClients) {\n            if (client_info->active.load()) {\n                client_info->active.store(false);\n                shutdown(client_info->client_socket, SHUT_RDWR);\n                close(client_info->client_socket);\n                client_info->listen_thread.join();\n            }\n            delete client_info;\n        }\n        ServerClients.clear();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        int sockfd = server_sock[socket_idx];\n        if (sockfd == -1) return;\n\n        while (server_listening) {\n            int client_fd = accept_select(sockfd);\n            if (client_fd == -1) continue;\n\n            // Get client info\n            struct sockaddr_storage client_addr;\n            socklen_t addr_len = sizeof(client_addr);\n            getpeername(client_fd, (struct sockaddr*)&client_addr, &addr_len);\n\n            char ip_str[INET6_ADDRSTRLEN];\n            void* addr;\n            unsigned short client_port;\n\n            if (client_addr.ss_family == AF_INET) {\n                struct sockaddr_in* s = (struct sockaddr_in*)&client_addr;\n                addr = &(s->sin_addr);\n                client_port = ntohs(s->sin_port);\n            } else {\n                struct sockaddr_in6* s = (struct sockaddr_in6*)&client_addr;\n                addr = &(s->sin6_addr);\n                client_port = ntohs(s->sin6_port);\n            }\n\n            inet_ntop(client_addr.ss_family, addr, ip_str, sizeof(ip_str));\n\n            // Create client info\n            auto* client_info = new NetworkClientInfo();\n            client_info->client_socket = client_fd;\n            client_info->ip_address = std::string(ip_str);\n            client_info->port = client_port;\n            client_info->active.store(true);\n\n            {\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                ServerClients.push_back(client_info);\n            }\n\n            ClientInfoChanged();\n\n            // Start client communication thread\n            client_info->listen_thread = std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(sockfd, &read_fds);\n\n        struct timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int activity = select(sockfd + 1, &read_fds, nullptr, nullptr, &timeout);\n        if (activity <= 0) return -1;\n\n        if (!FD_ISSET(sockfd, &read_fds)) return -1;\n\n        struct sockaddr_in client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        int client_fd = accept(sockfd, (struct sockaddr*)&client_addr, &addr_len);\n\n        if (client_fd == -1) return -1;\n\n        // Set non-blocking\n        fcntl(client_fd, F_SETFL, O_NONBLOCK);\n\n        return client_fd;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation depends on application context\n    }\n\n    void ServerListeningChanged() {\n        // Implementation depends on application context\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[BUFFER_SIZE];\n        \n        while (client_info->active.load()) {\n            ssize_t bytes_received = recv(client_info->client_socket, buffer, BUFFER_SIZE - 1, 0);\n            \n            if (bytes_received <= 0) {\n                // Connection closed or error\n                break;\n            }\n\n            buffer[bytes_received] = '\\0';\n            \n            // Process message (implementation depends on protocol)\n            std::cout << \"Received: \" << std::string(buffer, bytes_received) << std::endl;\n            \n            // Echo back for testing\n            send(client_info->client_socket, buffer, bytes_received, 0);\n        }\n\n        // Cleanup client\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.erase(std::remove(ServerClients.begin(), ServerClients.end(), client_info), ServerClients.end());\n        }\n\n        ClientInfoChanged();\n\n        shutdown(client_info->client_socket, SHUT_RDWR);\n        close(client_info->client_socket);\n        delete client_info;\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <cstring>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n\n#define MAXSOCK 16\n\nclass NetworkClientInfo {\npublic:\n    int client_socket;\n    sockaddr_storage client_addr;\n    socklen_t addr_len;\n    std::atomic<bool> active;\n    std::thread listen_thread;\n\n    NetworkClientInfo(int sock) : client_socket(sock), active(true) {\n        addr_len = sizeof(client_addr);\n        memset(&client_addr, 0, sizeof(client_addr));\n    }\n\n    ~NetworkClientInfo() {\n        if (listen_thread.joinable()) {\n            listen_thread.join();\n        }\n        if (active.load()) {\n            close(client_socket);\n        }\n    }\n};\n\nclass NetworkServer {\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    int server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n\n    void ClientInfoChanged() {}\n    void ServerListeningChanged() {}\n\npublic:\n    NetworkServer(const std::string& host_addr, unsigned short port)\n        : host(host_addr), port_num(port), server_online(false),\n          server_listening(false), socket_count(0) {\n        memset(server_sock, 0, sizeof(server_sock));\n        memset(ConnectionThread, 0, sizeof(ConnectionThread));\n    }\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        if (server_online) return;\n\n        server_online = true;\n        server_listening = false;\n        socket_count = 0;\n\n        struct addrinfo hints, *res, *p;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        std::string port_str = std::to_string(port_num);\n        int status = getaddrinfo(host.empty() ? nullptr : host.c_str(), port_str.c_str(), &hints, &res);\n\n        if (status != 0) {\n            std::cerr << \"getaddrinfo error: \" << gai_strerror(status) << std::endl;\n            return;\n        }\n\n        int sock_opt = 1;\n        for (p = res; p != nullptr && socket_count < MAXSOCK; p = p->ai_next) {\n            int sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (sockfd == -1) continue;\n\n            setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &sock_opt, sizeof(sock_opt));\n\n            if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {\n                close(sockfd);\n                continue;\n            }\n\n            if (listen(sockfd, SOMAXCONN) == -1) {\n                close(sockfd);\n                continue;\n            }\n\n            server_sock[socket_count++] = sockfd;\n\n            ConnectionThread[socket_count - 1] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, socket_count - 1);\n        }\n\n        freeaddrinfo(res);\n\n        if (socket_count > 0) {\n            server_listening = true;\n            ServerListeningChanged();\n        } else {\n            server_online = false;\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_listening = false;\n        ServerListeningChanged();\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != -1) {\n                close(server_sock[i]);\n                server_sock[i] = -1;\n            }\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        std::vector<NetworkClientInfo*> clients_copy;\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            clients_copy = ServerClients;\n            ServerClients.clear();\n        }\n\n        for (auto client : clients_copy) {\n            delete client;\n        }\n\n        server_online = false;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_listening && socket_idx >= 0 && socket_idx < socket_count) {\n            int client_sock = accept_select(server_sock[socket_idx]);\n            if (client_sock == -1) continue;\n\n            NetworkClientInfo* client_info = new NetworkClientInfo(client_sock);\n            {\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                ServerClients.push_back(client_info);\n            }\n            ClientInfoChanged();\n\n            client_info->listen_thread = std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int ret = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n        if (ret <= 0) return -1;\n\n        sockaddr_storage client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        int client_sock = accept(sockfd, reinterpret_cast<sockaddr*>(&client_addr), &addr_len);\n\n        if (client_sock == -1) return -1;\n\n        int flags = fcntl(client_sock, F_GETFL, 0);\n        fcntl(client_sock, F_SETFL, flags | O_NONBLOCK);\n\n        return client_sock;\n    }\n\n    unsigned short GetPort() const {\n        return port_num;\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[4096];\n        while (client_info->active.load() && server_online) {\n            int bytes_received = recv(client_info->client_socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                break;\n            }\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            for (auto client : ServerClients) {\n                if (client != client_info && client->active.load()) {\n                    send(client->client_socket, buffer, bytes_received, 0);\n                }\n            }\n        }\n\n        shutdown(client_info->client_socket, SHUT_RDWR);\n        close(client_info->client_socket);\n        client_info->active.store(false);\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n            if (it != ServerClients.end()) {\n                ServerClients.erase(it);\n            }\n        }\n        delete client_info;\n        ClientInfoChanged();\n    }\n};"
    ],
    "unmatched_results": [
      "#include <string>\n#include <vector>\n#include <mutex>\n#include <thread>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\n#define MAXSOCK 16\n#define BUFFER_SIZE 4096\n\nstruct NetworkClientInfo {\n    SOCKET client_socket;\n    sockaddr_storage client_addr;\n    socklen_t addr_len;\n    std::thread* listen_thread;\n    bool connected;\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<void*>& control);\n    ~NetworkServer();\n    void StartServer();\n    void StopServer();\n    void ConnectionThreadFunction(int socket_idx);\n    int accept_select(int sockfd);\n    unsigned short GetPort();\n    void ClientInfoChanged();\n    void ServerListeningChanged();\n    void ListenThreadFunction(NetworkClientInfo* client_info);\n\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n};",
      "#include <string>\n#include <vector>\n#include <mutex>\n#include <thread>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 16\n#define BUFFER_SIZE 4096\n\nstruct RGBColor {\n    unsigned char r;\n    unsigned char g;\n    unsigned char b;\n};\n\nstruct RGBController {\n    virtual ~RGBController() {}\n    virtual void SetLEDColor(int led_index, RGBColor color) = 0;\n};\n\nstruct NetworkClientInfo {\n    SOCKET client_socket;\n    std::string ip_address;\n    unsigned short port;\n    std::thread* listen_thread;\n    std::atomic<bool> running;\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<RGBController*>& control)\n        : host(\"0.0.0.0\"), port_num(0), server_online(false), server_listening(false),\n          socket_count(0), controllers(control) {\n        ZeroMemory(server_sock, sizeof(server_sock));\n        ZeroMemory(ConnectionThread, sizeof(ConnectionThread));\n    }\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        if (server_online) return;\n\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            return;\n        }\n\n        server_online = true;\n        server_listening = false;\n\n        struct addrinfo* result = nullptr;\n        struct addrinfo hints;\n\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        std::string port_str = std::to_string(port_num);\n\n        if (getaddrinfo(host.c_str(), port_str.c_str(), &hints, &result) != 0) {\n            WSACleanup();\n            return;\n        }\n\n        int sock_idx = 0;\n        for (struct addrinfo* ptr = result; ptr != nullptr && sock_idx < MAXSOCK; ptr = ptr->ai_next) {\n            SOCKET listen_sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n            if (listen_sock == INVALID_SOCKET) continue;\n\n            int opt = 1;\n            setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char*>(&opt), sizeof(opt));\n\n            if (bind(listen_sock, ptr->ai_addr, static_cast<int>(ptr->ai_addrlen)) == SOCKET_ERROR) {\n                closesocket(listen_sock);\n                continue;\n            }\n\n            if (listen(listen_sock, SOMAXCONN) == SOCKET_ERROR) {\n                closesocket(listen_sock);\n                continue;\n            }\n\n            server_sock[sock_idx++] = listen_sock;\n        }\n\n        freeaddrinfo(result);\n\n        if (sock_idx == 0) {\n            WSACleanup();\n            return;\n        }\n\n        socket_count = sock_idx;\n        server_listening = true;\n        ServerListeningChanged();\n\n        for (int i = 0; i < socket_count; ++i) {\n            ConnectionThread[i] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, i);\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n\n            if (server_sock[i] != INVALID_SOCKET) {\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        socket_count = 0;\n\n        std::lock_guard<std::mutex> lock(ServerClientsMutex);\n        for (auto client_info : ServerClients) {\n            client_info->running = false;\n            if (client_info->listen_thread) {\n                client_info->listen_thread->join();\n                delete client_info->listen_thread;\n            }\n            closesocket(client_info->client_socket);\n            delete client_info;\n        }\n        ServerClients.clear();\n        ClientInfoChanged();\n\n        WSACleanup();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        SOCKET listen_sock = server_sock[socket_idx];\n        while (server_online && !ThreadShouldExit()) {\n            SOCKET client_sock = accept_select(listen_sock);\n            if (client_sock == INVALID_SOCKET) continue;\n\n            char ipstr[INET6_ADDRSTRLEN];\n            struct sockaddr_storage client_addr;\n            int addr_len = sizeof(client_addr);\n            getpeername(client_sock, (struct sockaddr*)&client_addr, &addr_len);\n\n            void* addr;\n            if (client_addr.ss_family == AF_INET) {\n                struct sockaddr_in* s = (struct sockaddr_in*)&client_addr;\n                addr = &(s->sin_addr);\n            } else {\n                struct sockaddr_in6* s = (struct sockaddr_in6*)&client_addr;\n                addr = &(s->sin6_addr);\n            }\n\n            inet_ntop(client_addr.ss_family, addr, ipstr, sizeof(ipstr));\n            unsigned short client_port = 0;\n            if (client_addr.ss_family == AF_INET) {\n                client_port = ntohs(((struct sockaddr_in*)&client_addr)->sin_port);\n            } else {\n                client_port = ntohs(((struct sockaddr_in6*)&client_addr)->sin6_port);\n            }\n\n            auto* client_info = new NetworkClientInfo();\n            client_info->client_socket = client_sock;\n            client_info->ip_address = std::string(ipstr);\n            client_info->port = client_port;\n            client_info->listen_thread = nullptr;\n            client_info->running = true;\n\n            client_info->listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n\n            {\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                ServerClients.push_back(client_info);\n            }\n            ClientInfoChanged();\n        }\n    }\n\n    int accept_select(SOCKET sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int ret = select(static_cast<int>(sockfd) + 1, &readfds, nullptr, nullptr, &timeout);\n        if (ret <= 0) return INVALID_SOCKET;\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            sockaddr_in addr;\n            int len = sizeof(addr);\n            return accept(sockfd, (struct sockaddr*)&addr, &len);\n        }\n\n        return INVALID_SOCKET;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void SetPort(unsigned short port) {\n        port_num = port;\n    }\n\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    bool ThreadShouldExit() {\n        return !server_online;\n    }\n\n    void ClientInfoChanged() {\n        // Placeholder for UI update or notification logic\n    }\n\n    void ServerListeningChanged() {\n        // Placeholder for UI update or notification logic\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[BUFFER_SIZE];\n        while (client_info->running && server_online) {\n            int bytes_received = recv(client_info->client_socket, buffer, BUFFER_SIZE - 1, 0);\n            if (bytes_received <= 0) {\n                break;\n            }\n\n            buffer[bytes_received] = '\\0';\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            for (auto controller : controllers) {\n                for (int i = 0; i < controller->GetLEDCount(); ++i) {\n                    RGBColor color;\n                    color.r = rand() % 256;\n                    color.g = rand() % 256;\n                    color.b = rand() % 256;\n                    controller->SetLEDColor(i, color);\n                }\n            }\n        }\n\n        client_info->running = false;\n        closesocket(client_info->client_socket);\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n            if (it != ServerClients.end()) {\n                ServerClients.erase(it);\n            }\n        }\n        ClientInfoChanged();\n\n        if (client_info->listen_thread) {\n            delete client_info->listen_thread;\n            client_info->listen_thread = nullptr;\n        }\n\n        delete client_info;\n    }\n};",
      "#include <vector>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\n#define MAXSOCK 64\n\nstruct RGBColor {\n    unsigned char r;\n    unsigned char g;\n    unsigned char b;\n};\n\nclass RGBController {\npublic:\n    virtual void SetLEDColor(RGBColor color) = 0;\n    virtual ~RGBController() {}\n};\n\nstruct NetworkClientInfo {\n    SOCKET client_socket;\n    std::string ip_address;\n    unsigned short port;\n    std::thread* listen_thread;\n    std::atomic<bool> thread_active;\n    RGBController* controller;\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<RGBController*>& control)\n        : host(\"0.0.0.0\"), port_num(8080), server_online(false), \n          server_listening(false), socket_count(0), controllers(control) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        if (server_online) return;\n\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            return;\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n            ConnectionThread[i] = nullptr;\n        }\n\n        struct addrinfo* result = nullptr;\n        struct addrinfo hints;\n\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        std::string port_str = std::to_string(port_num);\n        \n        if (getaddrinfo(host.c_str(), port_str.c_str(), &hints, &result) != 0) {\n            WSACleanup();\n            return;\n        }\n\n        int sock_idx = 0;\n        for (struct addrinfo* ptr = result; ptr != nullptr && sock_idx < MAXSOCK; ptr = ptr->ai_next) {\n            SOCKET listen_sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n            if (listen_sock == INVALID_SOCKET) continue;\n\n            int opt = 1;\n            setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char*>(&opt), sizeof(opt));\n\n            if (bind(listen_sock, ptr->ai_addr, static_cast<int>(ptr->ai_addrlen)) == SOCKET_ERROR) {\n                closesocket(listen_sock);\n                continue;\n            }\n\n            if (listen(listen_sock, SOMAXCONN) == SOCKET_ERROR) {\n                closesocket(listen_sock);\n                continue;\n            }\n\n            server_sock[sock_idx++] = listen_sock;\n        }\n\n        freeaddrinfo(result);\n\n        if (sock_idx == 0) {\n            WSACleanup();\n            return;\n        }\n\n        socket_count = sock_idx;\n        server_online = true;\n        server_listening = true;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                ConnectionThread[i] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, i);\n            }\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_listening = false;\n        server_online = false;\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                shutdown(server_sock[i], SD_BOTH);\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        std::lock_guard<std::mutex> lock(ServerClientsMutex);\n        for (auto client_info : ServerClients) {\n            if (client_info->listen_thread && client_info->listen_thread->joinable()) {\n                client_info->thread_active = false;\n                shutdown(client_info->client_socket, SD_BOTH);\n                closesocket(client_info->client_socket);\n                client_info->listen_thread->join();\n                delete client_info->listen_thread;\n            }\n            delete client_info;\n        }\n        ServerClients.clear();\n\n        WSACleanup();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            SOCKET client_sock = accept_select(socket_idx);\n            if (client_sock == INVALID_SOCKET) continue;\n\n            char ipstr[INET6_ADDRSTRLEN];\n            sockaddr_storage addr;\n            int addr_len = sizeof(addr);\n            \n            getpeername(client_sock, reinterpret_cast<sockaddr*>(&addr), &addr_len);\n            \n            if (addr.ss_family == AF_INET) {\n                sockaddr_in* s = reinterpret_cast<sockaddr_in*>(&addr);\n                inet_ntop(AF_INET, &s->sin_addr, ipstr, sizeof(ipstr));\n            } else { // AF_INET6\n                sockaddr_in6* s = reinterpret_cast<sockaddr_in6*>(&addr);\n                inet_ntop(AF_INET6, &s->sin6_addr, ipstr, sizeof(ipstr));\n            }\n\n            auto client_info = new NetworkClientInfo();\n            client_info->client_socket = client_sock;\n            client_info->ip_address = std::string(ipstr);\n            client_info->port = (addr.ss_family == AF_INET) ? \n                ntohs(reinterpret_cast<sockaddr_in*>(&addr)->sin_port) :\n                ntohs(reinterpret_cast<sockaddr_in6*>(&addr)->sin6_port);\n            client_info->listen_thread = nullptr;\n            client_info->thread_active = true;\n            client_info->controller = (controllers.size() > 0) ? controllers[0] : nullptr;\n\n            {\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                ServerClients.push_back(client_info);\n            }\n\n            ClientInfoChanged();\n\n            try {\n                client_info->listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            } catch (...) {\n                delete client_info->listen_thread;\n                client_info->listen_thread = nullptr;\n            }\n        }\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        if (!client_info || client_info->client_socket == INVALID_SOCKET) return;\n\n        char buffer[1024];\n        while (client_info->thread_active && server_online) {\n            int bytes_received = recv(client_info->client_socket, buffer, sizeof(buffer), 0);\n            \n            if (bytes_received <= 0) {\n                break;\n            }\n\n            if (client_info->controller) {\n                RGBColor color;\n                color.r = buffer[0];\n                color.g = buffer[1];\n                color.b = buffer[2];\n                client_info->controller->SetLEDColor(color);\n            }\n        }\n\n        shutdown(client_info->client_socket, SD_BOTH);\n        closesocket(client_info->client_socket);\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n            if (it != ServerClients.end()) {\n                ServerClients.erase(it);\n            }\n        }\n\n        ClientInfoChanged();\n\n        if (client_info->listen_thread) {\n            delete client_info->listen_thread;\n        }\n        delete client_info;\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(server_sock[sockfd], &readfds);\n\n        timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int result = select(0, &readfds, nullptr, nullptr, &timeout);\n        \n        if (result > 0 && FD_ISSET(server_sock[sockfd], &readfds)) {\n            sockaddr_in6 client_addr;\n            int addr_len = sizeof(client_addr);\n            return accept(server_sock[sockfd], reinterpret_cast<sockaddr*>(&client_addr), &addr_len);\n        }\n        \n        return INVALID_SOCKET;\n    }\n\n    unsigned short GetPort() const {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Placeholder for client list change notification logic\n    }\n\n    void ServerListeningChanged() {\n        // Placeholder for server listening state change notification logic\n    }\n\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n};",
      "#include <string>\n#include <vector>\n#include <mutex>\n#include <thread>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 16\n#define BUFFER_SIZE 4096\n\nclass NetworkClientInfo {\npublic:\n    SOCKET client_socket;\n    std::atomic<bool> connected;\n    // Additional client information can be added here\n\n    NetworkClientInfo(SOCKET sock) : client_socket(sock), connected(true) {}\n};\n\nclass NetworkServer {\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n\n    void ClientInfoChanged() {\n        // Implementation for client info change callback\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state change callback\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int result = select(0, &readfds, nullptr, nullptr, &timeout);\n        if (result == SOCKET_ERROR) {\n            return -1;\n        }\n        if (result == 0) {\n            return 0; // Timeout\n        }\n        if (FD_ISSET(sockfd, &readfds)) {\n            sockaddr_in6 client_addr;\n            int addr_len = sizeof(client_addr);\n            SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &addr_len);\n            if (client_socket == INVALID_SOCKET) {\n                return -1;\n            }\n            return client_socket;\n        }\n        return 0;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online && server_listening) {\n            int client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket > 0) {\n                NetworkClientInfo* client_info = new NetworkClientInfo(client_socket);\n                \n                {\n                    std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                    ServerClients.push_back(client_info);\n                }\n                ClientInfoChanged();\n\n                // Create thread for client communication\n                std::thread([this, client_info]() {\n                    char buffer[BUFFER_SIZE];\n                    while (server_online && client_info->connected.load()) {\n                        int bytes_received = recv(client_info->client_socket, buffer, BUFFER_SIZE, 0);\n                        if (bytes_received <= 0) {\n                            client_info->connected.store(false);\n                            break;\n                        }\n                        // Process received data here\n                        // ...\n\n                        // Send response if needed\n                        // send(client_info->client_socket, response, response_length, 0);\n                    }\n\n                    // Clean up client connection\n                    closesocket(client_info->client_socket);\n                    {\n                        std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                        auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                        if (it != ServerClients.end()) {\n                            ServerClients.erase(it);\n                        }\n                    }\n                    ClientInfoChanged();\n                    delete client_info;\n                }).detach();\n            }\n            else if (client_socket < 0) {\n                // Error occurred\n                break;\n            }\n        }\n    }\n\npublic:\n    NetworkServer(const std::string& host_addr, unsigned short port)\n        : host(host_addr), port_num(port), server_online(false), server_listening(false), socket_count(0) {\n        ZeroMemory(server_sock, sizeof(server_sock));\n        ZeroMemory(ConnectionThread, sizeof(ConnectionThread));\n    }\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        if (server_online) return;\n\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            return;\n        }\n\n        server_online = true;\n        server_listening = true;\n        ServerListeningChanged();\n\n        addrinfo hints;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        addrinfo* result = nullptr;\n        std::string port_str = std::to_string(port_num);\n        \n        if (getaddrinfo(host.c_str(), port_str.c_str(), &hints, &result) != 0) {\n            WSACleanup();\n            return;\n        }\n\n        int sock_idx = 0;\n        for (addrinfo* ptr = result; ptr != nullptr && sock_idx < MAXSOCK; ptr = ptr->ai_next) {\n            SOCKET listen_socket = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n            if (listen_socket == INVALID_SOCKET) {\n                continue;\n            }\n\n            // Enable dual-stack if supported\n            if (ptr->ai_family == AF_INET6) {\n                DWORD opt = 0;\n                setsockopt(listen_socket, IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&opt, sizeof(opt));\n            }\n\n            // Set socket options\n            DWORD optval = 1;\n            setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(optval));\n\n            if (bind(listen_socket, ptr->ai_addr, (int)ptr->ai_addrlen) == SOCKET_ERROR) {\n                closesocket(listen_socket);\n                continue;\n            }\n\n            if (listen(listen_socket, SOMAXCONN) == SOCKET_ERROR) {\n                closesocket(listen_socket);\n                continue;\n            }\n\n            server_sock[sock_idx++] = listen_socket;\n            ConnectionThread[sock_idx - 1] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, sock_idx - 1);\n        }\n\n        socket_count = sock_idx;\n        freeaddrinfo(result);\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n\n        // Close all client connections\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            for (NetworkClientInfo* client : ServerClients) {\n                client->connected.store(false);\n                shutdown(client->client_socket, SD_BOTH);\n            }\n            ServerClients.clear();\n        }\n\n        // Close server sockets\n        for (int i = 0; i < socket_count; i++) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                shutdown(server_sock[i], SD_BOTH);\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        // Join and clean up connection threads\n        for (int i = 0; i < MAXSOCK; i++) {\n            if (ConnectionThread[i]) {\n                if (ConnectionThread[i]->joinable()) {\n                    ConnectionThread[i]->join();\n                }\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        WSACleanup();\n    }\n\n    unsigned short GetPort() const {\n        return port_num;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\n#define MAXSOCK 16\n#define BUFFER_SIZE 4096\n\nclass RGBController {};\n\nstruct NetworkClientInfo {\n    SOCKET client_socket;\n    std::string ip_address;\n    unsigned short port;\n    std::thread* listen_thread;\n    bool connected;\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<RGBController*>& control);\n    ~NetworkServer();\n    void StartServer();\n    void StopServer();\n    void ConnectionThreadFunction(int socket_idx);\n    int accept_select(int sockfd);\n    unsigned short GetPort();\n    void ClientInfoChanged();\n    void ServerListeningChanged();\n    void ListenThreadFunction(NetworkClientInfo* client_info);\n\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n};\n\nNetworkServer::NetworkServer(std::vector<RGBController*>& control) {\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n\n    host = \"0.0.0.0\";\n    port_num = 8080;\n    server_online = false;\n    server_listening = false;\n    socket_count = 0;\n\n    for (int i = 0; i < MAXSOCK; ++i) {\n        server_sock[i] = INVALID_SOCKET;\n        ConnectionThread[i] = nullptr;\n    }\n}\n\nNetworkServer::~NetworkServer() {\n    StopServer();\n\n    for (auto client : ServerClients) {\n        delete client;\n    }\n    ServerClients.clear();\n\n    WSACleanup();\n}\n\nvoid NetworkServer::StartServer() {\n    if (server_online) return;\n\n    server_online = true;\n    server_listening = false;\n    ServerListeningChanged();\n\n    struct addrinfo hints, *result = nullptr, *ptr = nullptr;\n    ZeroMemory(&hints, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_flags = AI_PASSIVE;\n\n    std::string port_str = std::to_string(port_num);\n\n    if (getaddrinfo(host.c_str(), port_str.c_str(), &hints, &result) != 0) {\n        server_online = false;\n        ServerListeningChanged();\n        return;\n    }\n\n    socket_count = 0;\n    for (ptr = result; ptr != nullptr && socket_count < MAXSOCK; ptr = ptr->ai_next) {\n        SOCKET sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n        if (sock == INVALID_SOCKET) continue;\n\n        int enable = 1;\n        setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<const char*>(&enable), sizeof(enable));\n\n        if (bind(sock, ptr->ai_addr, static_cast<int>(ptr->ai_addrlen)) == SOCKET_ERROR) {\n            closesocket(sock);\n            continue;\n        }\n\n        if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {\n            closesocket(sock);\n            continue;\n        }\n\n        server_sock[socket_count++] = sock;\n    }\n\n    freeaddrinfo(result);\n\n    if (socket_count == 0) {\n        server_online = false;\n        ServerListeningChanged();\n        return;\n    }\n\n    server_listening = true;\n    ServerListeningChanged();\n\n    for (int i = 0; i < socket_count; ++i) {\n        ConnectionThread[i] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, i);\n    }\n}\n\nvoid NetworkServer::StopServer() {\n    if (!server_online) return;\n\n    server_online = false;\n    server_listening = false;\n    ServerListeningChanged();\n\n    for (int i = 0; i < socket_count; ++i) {\n        if (server_sock[i] != INVALID_SOCKET) {\n            shutdown(server_sock[i], SD_BOTH);\n            closesocket(server_sock[i]);\n            server_sock[i] = INVALID_SOCKET;\n        }\n    }\n\n    for (int i = 0; i < socket_count; ++i) {\n        if (ConnectionThread[i]) {\n            ConnectionThread[i]->join();\n            delete ConnectionThread[i];\n            ConnectionThread[i] = nullptr;\n        }\n    }\n\n    // Clean up all client connections\n    ServerClientsMutex.lock();\n    for (auto client : ServerClients) {\n        if (client->connected) {\n            shutdown(client->client_socket, SD_BOTH);\n            closesocket(client->client_socket);\n            client->connected = false;\n            if (client->listen_thread) {\n                client->listen_thread->join();\n                delete client->listen_thread;\n                client->listen_thread = nullptr;\n            }\n        }\n        delete client;\n    }\n    ServerClients.clear();\n    ServerClientsMutex.unlock();\n}\n\nvoid NetworkServer::ConnectionThreadFunction(int socket_idx) {\n    while (server_online && server_listening) {\n        SOCKET client_sock = accept_select(socket_idx);\n        if (client_sock == INVALID_SOCKET) continue;\n\n        char ipstr[INET6_ADDRSTRLEN];\n        sockaddr_storage client_addr;\n        int addr_len = sizeof(client_addr);\n        getpeername(client_sock, reinterpret_cast<sockaddr*>(&client_addr), &addr_len);\n\n        void* addr;\n        if (client_addr.ss_family == AF_INET) {\n            sockaddr_in* s = reinterpret_cast<sockaddr_in*>(&client_addr);\n            addr = &(s->sin_addr);\n            inet_ntop(AF_INET, addr, ipstr, sizeof(ipstr));\n        } else {\n            sockaddr_in6* s = reinterpret_cast<sockaddr_in6*>(&client_addr);\n            addr = &(s->sin6_addr);\n            inet_ntop(AF_INET6, addr, ipstr, sizeof(ipstr));\n        }\n\n        NetworkClientInfo* client_info = new NetworkClientInfo();\n        client_info->client_socket = client_sock;\n        client_info->ip_address = std::string(ipstr);\n        client_info->port = (client_addr.ss_family == AF_INET) ?\n            ntohs(reinterpret_cast<sockaddr_in*>(&client_addr)->sin_port) :\n            ntohs(reinterpret_cast<sockaddr_in6*>(&client_addr)->sin6_port);\n        client_info->listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n        client_info->connected = true;\n\n        ServerClientsMutex.lock();\n        ServerClients.push_back(client_info);\n        ServerClientsMutex.unlock();\n\n        ClientInfoChanged();\n    }\n}\n\nint NetworkServer::accept_select(int sockfd) {\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(server_sock[sockfd], &readfds);\n\n    timeval timeout;\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n\n    int ret = select(static_cast<int>(server_sock[sockfd]) + 1, &readfds, nullptr, nullptr, &timeout);\n    if (ret <= 0) return INVALID_SOCKET;\n\n    sockaddr_in6 client_addr;\n    int addr_len = sizeof(client_addr);\n    SOCKET client_sock = accept(server_sock[sockfd], reinterpret_cast<sockaddr*>(&client_addr), &addr_len);\n\n    if (client_sock == INVALID_SOCKET) return INVALID_SOCKET;\n\n    // Set client socket to non-blocking mode\n    u_long mode = 1;\n    ioctlsocket(client_sock, FIONBIO, &mode);\n\n    return client_sock;\n}\n\nunsigned short NetworkServer::GetPort() {\n    return port_num;\n}\n\nvoid NetworkServer::ClientInfoChanged() {\n    // Implementation would go here\n}\n\nvoid NetworkServer::ServerListeningChanged() {\n    // Implementation would go here\n}\n\nvoid NetworkServer::ListenThreadFunction(NetworkClientInfo* client_info) {\n    char buffer[BUFFER_SIZE];\n    int total_bytes_read = 0;\n\n    while (server_online && client_info->connected) {\n        int bytes_received = recv(client_info->client_socket, buffer + total_bytes_read, BUFFER_SIZE - total_bytes_read, 0);\n\n        if (bytes_received <= 0) {\n            // Connection closed or error\n            break;\n        }\n\n        total_bytes_read += bytes_received;\n\n        // Process complete messages (this is a simplified example)\n        // In a real implementation, you'd need proper message framing\n        while (true) {\n            // Example: process line-based messages\n            char* newline_pos = reinterpret_cast<char*>(memchr(buffer, '\\n', total_bytes_read));\n            if (!newline_pos) break;\n\n            // Null-terminate the message\n            *newline_pos = '\\0';\n            std::string message(buffer);\n\n            // Handle the message (implementation-specific)\n\n            // Remove processed message from buffer\n            int msg_len = newline_pos - buffer + 1;\n            total_bytes_read -= msg_len;\n            memmove(buffer, newline_pos + 1, total_bytes_read);\n        }\n\n        // Limit how much we keep in the buffer\n        if (total_bytes_read >= BUFFER_SIZE - 1) {\n            // Buffer overflow - disconnect client\n            break;\n        }\n    }\n\n    // Clean up client connection\n    client_info->connected = false;\n    closesocket(client_info->client_socket);\n\n    // Notify listeners\n    ClientInfoChanged();\n}",
      "#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\n#define MAXSOCK 64\n#define BUFFER_SIZE 4096\n\nstruct RGBColor {\n    unsigned char r;\n    unsigned char g;\n    unsigned char b;\n};\n\nstruct RGBController {\n    virtual unsigned int GetLEDCount() = 0;\n    virtual RGBColor GetLED(unsigned int led_index) = 0;\n    virtual void SetLED(unsigned int led_index, RGBColor color) = 0;\n    virtual void Update() = 0;\n};\n\nclass NetworkClientInfo {\npublic:\n    SOCKET client_socket;\n    sockaddr_storage client_addr;\n    socklen_t addr_len;\n    std::thread* listen_thread;\n    bool connected;\n\n    NetworkClientInfo(SOCKET sock) : client_socket(sock), addr_len(sizeof(client_addr)), connected(true) {\n        listen_thread = nullptr;\n    }\n\n    ~NetworkClientInfo() {\n        if (connected) {\n            closesocket(client_socket);\n        }\n        if (listen_thread && listen_thread->joinable()) {\n            listen_thread->join();\n            delete listen_thread;\n        }\n    }\n};\n\nclass NetworkServer {\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n\n    void ClientInfoChanged() {}\n    void ServerListeningChanged() {}\n    void ListenThreadFunction(NetworkClientInfo* client_info);\n\npublic:\n    NetworkServer(std::vector<RGBController*>& control) {\n        WSADATA wsaData;\n        WSAStartup(MAKEWORD(2, 2), &wsaData);\n        server_online = false;\n        server_listening = false;\n        socket_count = 0;\n        port_num = 0;\n        host = \"\";\n    }\n\n    ~NetworkServer() {\n        StopServer();\n        WSACleanup();\n    }\n\n    void StartServer() {\n        if (server_online) return;\n\n        server_online = true;\n        server_listening = false;\n        socket_count = 0;\n\n        ZeroMemory(server_sock, sizeof(server_sock));\n        for (int i = 0; i < MAXSOCK; ++i) {\n            ConnectionThread[i] = nullptr;\n        }\n\n        addrinfo hints, *result = nullptr;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        std::string port_str = std::to_string(port_num);\n        if (getaddrinfo(host.empty() ? nullptr : host.c_str(), port_str.c_str(), &hints, &result) != 0) {\n            server_online = false;\n            return;\n        }\n\n        int sock_idx = 0;\n        for (addrinfo* ptr = result; ptr != nullptr && sock_idx < MAXSOCK; ptr = ptr->ai_next) {\n            SOCKET listen_sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n            if (listen_sock == INVALID_SOCKET) continue;\n\n            int enable = 1;\n            setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<char*>(&enable), sizeof(enable));\n\n            if (bind(listen_sock, ptr->ai_addr, static_cast<int>(ptr->ai_addrlen)) == SOCKET_ERROR) {\n                closesocket(listen_sock);\n                continue;\n            }\n\n            if (listen(listen_sock, SOMAXCONN) == SOCKET_ERROR) {\n                closesocket(listen_sock);\n                continue;\n            }\n\n            server_sock[sock_idx++] = listen_sock;\n        }\n\n        freeaddrinfo(result);\n\n        if (sock_idx == 0) {\n            server_online = false;\n            return;\n        }\n\n        socket_count = sock_idx;\n        server_listening = true;\n        ServerListeningChanged();\n\n        for (int i = 0; i < socket_count; ++i) {\n            ConnectionThread[i] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, i);\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_online = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                shutdown(server_sock[i], SD_BOTH);\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            for (NetworkClientInfo* client : ServerClients) {\n                delete client;\n            }\n            ServerClients.clear();\n        }\n\n        ClientInfoChanged();\n\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online && server_listening) {\n            SOCKET client_sock = accept_select(server_sock[socket_idx]);\n            if (client_sock == INVALID_SOCKET) continue;\n\n            NetworkClientInfo* client_info = new NetworkClientInfo(client_sock);\n            {\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                ServerClients.push_back(client_info);\n            }\n            ClientInfoChanged();\n\n            client_info->listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int ret = select(static_cast<int>(sockfd) + 1, &readfds, nullptr, nullptr, &timeout);\n        if (ret <= 0) return INVALID_SOCKET;\n\n        if (!FD_ISSET(sockfd, &readfds)) return INVALID_SOCKET;\n\n        sockaddr_storage client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        SOCKET client_sock = accept(sockfd, reinterpret_cast<sockaddr*>(&client_addr), &addr_len);\n        return client_sock;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n};",
      "#include <string>\n#include <vector>\n#include <mutex>\n#include <thread>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 16\n#define BUFFER_SIZE 4096\n\nstruct RGBColor {\n    unsigned char r;\n    unsigned char g;\n    unsigned char b;\n};\n\nstruct RGBController {\n    virtual void SetLEDColor(RGBColor color) = 0;\n};\n\nstruct NetworkClientInfo {\n    SOCKET client_socket;\n    std::string ip_address;\n    unsigned short port;\n    std::thread* listen_thread;\n    std::atomic<bool> running;\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<RGBController*>& control);\n    ~NetworkServer();\n    void StartServer();\n    void StopServer();\n    \nprivate:\n    void ConnectionThreadFunction(int socket_idx);\n    int accept_select(int sockfd);\n    void ListenThreadFunction(NetworkClientInfo* client_info);\n    \n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    \n    // Callbacks (implied)\n    void ClientInfoChanged();\n    void ServerListeningChanged();\n    unsigned short GetPort();\n};",
      "#include <string>\n#include <vector>\n#include <mutex>\n#include <thread>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 16\n#define BUFFER_SIZE 4096\n\nstruct RGBColor {\n    unsigned char r;\n    unsigned char g;\n    unsigned char b;\n};\n\nstruct RGBController {\n    virtual unsigned int GetLEDCount() = 0;\n    virtual void SetLEDColor(unsigned int led_index, RGBColor color) = 0;\n};\n\nstruct NetworkClientInfo {\n    SOCKET client_socket;\n    std::thread* listen_thread;\n    std::atomic<bool> running;\n    std::string ip_address;\n    unsigned short port;\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<RGBController*>& control);\n    ~NetworkServer();\n    \n    void StartServer();\n    void StopServer();\n    \nprivate:\n    void ConnectionThreadFunction(int socket_idx);\n    int accept_select(int sockfd);\n    \n    void ClientInfoChanged();\n    void ServerListeningChanged();\n    void ListenThreadFunction(NetworkClientInfo* client_info);\n    \n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    \n    std::vector<RGBController*> controllers;\n};"
    ],
    "match_count": 2,
    "pass@3": 0.5333333333333333,
    "pass@5": 0.7777777777777778
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Implement a TCP server in C++ that listens for incoming connections, handles client requests in separate child processes, and responds to clients after processing their data.\n\nFunction Description: The function `tcp_server_communication` creates a TCP server that binds to a specified port, listens for incoming connections, and forks child processes to handle each client connection. Each child process reads a character from the client, increments it after a delay, and sends it back before terminating.\n\nInput: None (The function uses predefined constants: port number 9736 and INADDR_ANY for binding to all available network interfaces)\n\nOutput: None (The function runs indefinitely, servicing client requests and doesn't return any value)\n\nNote: The function includes signal handling to prevent zombie processes from terminated child processes. Each client connection is handled in a separate child process while the parent process continues to accept new connections.",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <signal.h>\n\nvoid tcp_server_communication()\n{\n    int server_sockfd = -1;\n    int client_sockfd = -1;\n    int client_len = 0;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n    \n    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(9736);\n    \n    bind(server_sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(server_sockfd, 5);\n    signal(SIGCHLD, SIG_IGN);\n\n    while(1)\n    {\n        char ch = '\\0';\n        client_len = sizeof(client_addr);\n        client_sockfd = accept(server_sockfd, (struct sockaddr*)&client_addr,\n                               (socklen_t *)&client_len);\n\n        if(fork() == 0)\n        {\n            read(client_sockfd, &ch, 1);\n            sleep(5);\n            ch++;\n            write(client_sockfd, &ch, 1);\n            close(client_sockfd);\n            exit(0);\n        }\n        else\n        {\n            close(client_sockfd);\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "matched_results": [
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n#include <cstdlib>\n#include <cstdio>\n\n#define PORT 9736\n#define INADDR_ANY 0\n\nvoid sigchld_handler(int s) {\n    while (waitpid(-1, NULL, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    pid_t child_pid;\n\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        perror(\"sigaction\");\n        exit(1);\n    }\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    int opt = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        if ((child_pid = fork()) == 0) {\n            close(server_fd);\n            char buffer[1];\n            if (read(new_socket, buffer, 1) > 0) {\n                sleep(1);\n                buffer[0]++;\n                write(new_socket, buffer, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else if (child_pid > 0) {\n            close(new_socket);\n        } else {\n            perror(\"fork\");\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n}"
    ],
    "unmatched_results": [
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\n#define PORT 9736\n#define BACKLOG 10\n#define DELAY_SECONDS 2\n\nvoid handle_client(int client_socket) {\n    char buffer;\n    ssize_t bytes_read = read(client_socket, &buffer, sizeof(buffer));\n    if (bytes_read > 0) {\n        sleep(DELAY_SECONDS);\n        buffer++;\n        write(client_socket, &buffer, sizeof(buffer));\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int signal) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return;\n    }\n\n    int opt = 1;\n    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {\n        std::cerr << \"Setsockopt failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    struct sockaddr_in server_addr{};\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(PORT);\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    if (listen(server_socket, BACKLOG) == -1) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGCHLD, &sa, nullptr) == -1) {\n        std::cerr << \"Sigaction failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    while (true) {\n        struct sockaddr_in client_addr{};\n        socklen_t addr_size = sizeof(client_addr);\n        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &addr_size);\n        if (client_socket == -1) {\n            std::cerr << \"Accept failed\" << std::endl;\n            continue;\n        }\n\n        pid_t pid = fork();\n        if (pid == 0) {\n            close(server_socket);\n            handle_client(client_socket);\n        } else if (pid > 0) {\n            close(client_socket);\n        } else {\n            std::cerr << \"Fork failed\" << std::endl;\n            close(client_socket);\n        }\n    }\n\n    close(server_socket);\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\n#define PORT 9736\n#define BACKLOG 10\n#define DELAY_SECONDS 2\n\nvoid handle_client(int client_socket) {\n    char buffer;\n    ssize_t bytes_read = read(client_socket, &buffer, sizeof(buffer));\n    if (bytes_read > 0) {\n        sleep(DELAY_SECONDS);\n        buffer++;\n        write(client_socket, &buffer, sizeof(buffer));\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int signal) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    int opt = 1;\n    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {\n        std::cerr << \"Setsockopt failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    struct sockaddr_in server_addr{};\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(PORT);\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    if (listen(server_socket, BACKLOG) == -1) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGCHLD, &sa, nullptr) == -1) {\n        std::cerr << \"Sigaction failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    while (true) {\n        struct sockaddr_in client_addr{};\n        socklen_t addr_size = sizeof(client_addr);\n        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &addr_size);\n        if (client_socket == -1) {\n            std::cerr << \"Accept failed\" << std::endl;\n            continue;\n        }\n\n        pid_t pid = fork();\n        if (pid == -1) {\n            std::cerr << \"Fork failed\" << std::endl;\n            close(client_socket);\n        } else if (pid == 0) {\n            close(server_socket);\n            handle_client(client_socket);\n        } else {\n            close(client_socket);\n        }\n    }\n\n    close(server_socket);\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\nvoid handle_client(int client_socket) {\n    char buffer;\n    ssize_t bytes_read = read(client_socket, &buffer, 1);\n    if (bytes_read > 0) {\n        sleep(2); // Simulate processing delay\n        buffer++;\n        write(client_socket, &buffer, 1);\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int signal) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return;\n    }\n\n    int enable = 1;\n    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable));\n\n    struct sockaddr_in server_address{};\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = INADDR_ANY;\n    server_address.sin_port = htons(9736);\n\n    if (bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address)) == -1) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    if (listen(server_socket, 5) == -1) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    signal(SIGCHLD, sigchld_handler);\n\n    while (true) {\n        struct sockaddr_in client_address{};\n        socklen_t client_len = sizeof(client_address);\n        int client_socket = accept(server_socket, (struct sockaddr*)&client_address, &client_len);\n        if (client_socket == -1) {\n            std::cerr << \"Accept failed\" << std::endl;\n            continue;\n        }\n\n        pid_t pid = fork();\n        if (pid == 0) { // Child process\n            close(server_socket);\n            handle_client(client_socket);\n        } else if (pid > 0) { // Parent process\n            close(client_socket);\n        } else {\n            std::cerr << \"Fork failed\" << std::endl;\n            close(client_socket);\n        }\n    }\n\n    close(server_socket);\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\nvoid handle_client(int client_socket) {\n    char buffer;\n    if (read(client_socket, &buffer, 1) > 0) {\n        sleep(2); // Simulate processing delay\n        buffer++;\n        write(client_socket, &buffer, 1);\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int signal) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_fd, client_fd;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t client_len = sizeof(client_addr);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    int opt = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        std::cerr << \"Setsockopt error\" << std::endl;\n        close(server_fd);\n        return;\n    }\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return;\n    }\n\n    if (listen(server_fd, 5) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return;\n    }\n\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sigaction(SIGCHLD, &sa, nullptr);\n\n    while (true) {\n        if ((client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &client_len)) < 0) {\n            std::cerr << \"Accept error\" << std::endl;\n            continue;\n        }\n\n        pid_t pid = fork();\n        if (pid == 0) {\n            close(server_fd);\n            handle_client(client_fd);\n        } else if (pid > 0) {\n            close(client_fd);\n        } else {\n            std::cerr << \"Fork error\" << std::endl;\n            close(client_fd);\n        }\n    }\n\n    close(server_fd);\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\nvoid handle_client(int client_socket) {\n    char buffer;\n    if (read(client_socket, &buffer, sizeof(buffer)) > 0) {\n        sleep(1); // Delay before processing\n        buffer++;\n        write(client_socket, &buffer, sizeof(buffer));\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int signal) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_fd, client_fd;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t client_len = sizeof(client_addr);\n\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    int opt = 1;\n    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return;\n    }\n\n    if (listen(server_fd, 5) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return;\n    }\n\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sigaction(SIGCHLD, &sa, nullptr);\n\n    while (true) {\n        client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &client_len);\n        if (client_fd < 0) continue;\n\n        pid_t pid = fork();\n        if (pid == 0) {\n            close(server_fd);\n            handle_client(client_fd);\n        } else if (pid > 0) {\n            close(client_fd);\n        } else {\n            close(client_fd);\n            std::cerr << \"Fork failed\" << std::endl;\n        }\n    }\n\n    close(server_fd);\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\n#define PORT 9736\n#define INADDR_ANY INADDR_ANY\n\nvoid handle_client(int client_socket) {\n    char buffer[1];\n    if (read(client_socket, buffer, sizeof(buffer)) > 0) {\n        sleep(2); // Delay before processing\n        buffer[0]++;\n        write(client_socket, buffer, sizeof(buffer));\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid tcp_server_communication() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    // Create socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set socket options\n    int opt = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind socket\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Signal handler to prevent zombie processes\n    signal(SIGCHLD, [](int){ while (waitpid(-1, NULL, WNOHANG) > 0); });\n\n    while (true) {\n        // Accept incoming connection\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        // Fork child process to handle client\n        pid_t child_pid = fork();\n        if (child_pid == 0) { // Child process\n            close(server_fd); // Close listening socket in child\n            handle_client(new_socket);\n        } else if (child_pid > 0) { // Parent process\n            close(new_socket); // Close client socket in parent\n        } else {\n            perror(\"fork\");\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\n#define PORT 9736\n#define BACKLOG 10\n#define DELAY_SECONDS 2\n\nvoid handle_client(int client_socket) {\n    char buffer;\n    ssize_t bytes_read = read(client_socket, &buffer, sizeof(buffer));\n    if (bytes_read > 0) {\n        sleep(DELAY_SECONDS);\n        buffer++;\n        write(client_socket, &buffer, sizeof(buffer));\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int signal) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    int opt = 1;\n    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {\n        std::cerr << \"Setsockopt failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(PORT);\n\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    if (listen(server_socket, BACKLOG) == -1) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGCHLD, &sa, nullptr) == -1) {\n        std::cerr << \"Sigaction failed\" << std::endl;\n        close(server_socket);\n        return;\n    }\n\n    while (true) {\n        struct sockaddr_in client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &addr_len);\n        if (client_socket == -1) {\n            std::cerr << \"Accept failed\" << std::endl;\n            continue;\n        }\n\n        pid_t pid = fork();\n        if (pid == -1) {\n            std::cerr << \"Fork failed\" << std::endl;\n            close(client_socket);\n        } else if (pid == 0) {\n            close(server_socket);\n            handle_client(client_socket);\n        } else {\n            close(client_socket);\n        }\n    }\n\n    close(server_socket);\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\nvoid handle_client(int client_socket) {\n    char buffer;\n    if (read(client_socket, &buffer, sizeof(buffer)) > 0) {\n        sleep(1); // Delay before processing\n        buffer++;\n        write(client_socket, &buffer, sizeof(buffer));\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int signal) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    int opt = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGCHLD, &sa, nullptr) == -1) {\n        perror(\"sigaction\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t pid = fork();\n        if (pid == 0) { // Child process\n            close(server_fd);\n            handle_client(new_socket);\n        } else if (pid > 0) { // Parent process\n            close(new_socket);\n        } else {\n            perror(\"fork\");\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\nvoid handle_client(int client_socket) {\n    char buffer;\n    if (read(client_socket, &buffer, sizeof(buffer)) > 0) {\n        sleep(1); // Delay before processing\n        buffer++;\n        write(client_socket, &buffer, sizeof(buffer));\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int signal) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_fd, client_fd;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    int opt = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if (sigaction(SIGCHLD, &sa, nullptr) == -1) {\n        perror(\"sigaction\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    while (true) {\n        if ((client_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t pid = fork();\n        if (pid == 0) { // Child process\n            close(server_fd);\n            handle_client(client_fd);\n        } else if (pid > 0) { // Parent process\n            close(client_fd);\n        } else {\n            perror(\"fork\");\n            close(client_fd);\n        }\n    }\n\n    close(server_fd);\n}"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Implement a TCP server using UNIX domain sockets for inter-process communication that manages and provides access to statistics data. The server should handle multiple client connections concurrently, process different types of requests (get, reset, etc.), and maintain thread safety.\n\nClass Description: The Stats class implements a TCP server using UNIX domain sockets to manage and provide access to statistics data. It handles client connections, processes requests, and maintains thread safety for concurrent access to statistics.\n\nAttributes:\n- stats_socket_path_: std::string - Path to the UNIX domain socket file\n- sockfd_: int - File descriptor for the server socket\n- serv_addr_: sockaddr_un - Server address structure\n- stats_thread_: std::thread - Thread for running the socket server\n- statsThreadRunning_: std::atomic<bool> - Flag to control the server thread's execution\n- stats_mutex_: std::mutex - Mutex for protecting access to statistics data\n- thread_mutex_: std::mutex - Mutex for protecting thread count\n- thread_exited_: std::condition_variable - Condition variable for thread synchronization\n- thread_count_: int - Count of active threads\n- stats_: std::unordered_map<std::string, int> - Container for storing statistics data\n\nMethods:\n- Stats(const std::string& stats_socket_path) -> None - Constructor that initializes the socket server\n- ~Stats() -> None - Destructor that cleans up resources\n- get(const std::string& stats_socket_path) -> Stats& - Static method to get the singleton instance\n- get_for_unittest(const std::string& stats_socket_path) -> std::unique_ptr<Stats> - Static method to get an instance for unit testing\n- init(const std::string& stats_socket_path) -> bool - Static method to initialize the singleton\n- isInit() -> bool - Static method to check if the singleton is initialized\n- getAll() -> std::unordered_map<std::string, int> - Returns all statistics data\n- increment(const std::string& key, int val) -> int - Increments a statistic value\n- set(const std::string& key, int val) -> int - Sets a statistic value\n- reset() -> int - Resets all statistics\n- startSocket() -> bool - Starts the socket server\n- runSocket() -> void - Main server loop that accepts connections\n- processMsg(int sockfd) -> void - Processes a client message\n- isInitInternal() -> bool& - Internal static method for initialization status",
    "Canonical_solution": "#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n#include <json/value.h>\n\nnamespace Oomd {\n\nclass Stats {\npublic:\n  Stats(const std::string& stats_socket_path);\n  ~Stats();\n\n  static Stats& get(const std::string& stats_socket_path);\n  static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n  static bool init(const std::string& stats_socket_path);\n  static bool isInit();\n\n  std::unordered_map<std::string, int> getAll();\n  int increment(const std::string& key, int val);\n  int set(const std::string& key, int val);\n  int reset();\n\nprivate:\n  bool startSocket();\n  void runSocket();\n  void processMsg(int sockfd);\n  static bool& isInitInternal();\n\n  std::string stats_socket_path_;\n  int sockfd_{-1};\n  sockaddr_un serv_addr_{};\n  std::thread stats_thread_;\n  std::atomic<bool> statsThreadRunning_{true};\n  std::mutex stats_mutex_;\n  std::unordered_map<std::string, int> stats_;\n  std::mutex thread_mutex_;\n  std::condition_variable thread_exited_;\n  int thread_count_{0};\n};\n\nStats::Stats(const std::string& stats_socket_path)\n    : stats_socket_path_(stats_socket_path) {\n  if (!this->startSocket()) {\n    throw std::runtime_error(\"Socket thread failed to start\");\n  }\n}\n\nStats::~Stats() {\n  std::array<char, 64> err_buf = {};\n  statsThreadRunning_ = false;\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  if (!thread_exited_.wait_for(lock, std::chrono::seconds(5), [this] {\n        return this->thread_count_ == 0;\n      })) {\n    OCHECK(false);\n  }\n  lock.unlock();\n  if (stats_thread_.joinable()) {\n    stats_thread_.join();\n  }\n  if (::unlink(serv_addr_.sun_path) < 0) {\n    OLOG << \"Closing stats error: unlinking socket path: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  if (::close(sockfd_) < 0) {\n    OLOG << \"Closing stats error: closing stats socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n}\n\nbool Stats::startSocket() {\n  std::array<char, 64> err_buf = {};\n\n  sockfd_ = ::socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sockfd_ < 0) {\n    OLOG << \"Error creating socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size() - 1);\n    return false;\n  }\n  ::memset(&serv_addr_, '\\0', sizeof(serv_addr_));\n  serv_addr_.sun_family = AF_UNIX;\n  ::strcpy(serv_addr_.sun_path, stats_socket_path_.c_str());\n  if (::unlink(serv_addr_.sun_path) < 0 && errno != ENOENT) {\n    OLOG << \"Pre-unlinking of socket path failed. \" << serv_addr_.sun_path\n         << \". Errno: \" << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) < 0) {\n    OLOG << \"Error binding stats collection socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::listen(sockfd_, 5) < 0) {\n    OLOG << \"Error listening at socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  stats_thread_ = std::thread([this] { this->runSocket(); });\n  return true;\n}\n\nvoid Stats::runSocket() {\n  sockaddr_un cli_addr;\n  socklen_t clilen = sizeof(cli_addr);\n  std::array<char, 64> err_buf = {};\n  while (statsThreadRunning_) {\n    int sockfd = ::accept(sockfd_, (struct sockaddr*)&cli_addr, &clilen);\n    if (sockfd < 0) {\n      OLOG << \"Stats server error: accepting connection: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      continue;\n    }\n    std::unique_lock<std::mutex> lock(thread_mutex_);\n    ++thread_count_;\n    std::thread msg_thread_ =\n        std::thread([this, sockfd] { this->processMsg(sockfd); });\n    msg_thread_.detach();\n    lock.unlock();\n    thread_exited_.notify_one();\n  }\n}\n\nvoid Stats::processMsg(int sockfd) {\n  std::array<char, 64> err_buf = {};\n  OOMD_SCOPE_EXIT {\n    if (::close(sockfd) < 0) {\n      OLOG << \"Stats server error: closing file descriptor: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    }\n  };\n  char mode = 'a';\n  char byte_buf;\n  int num_read = 0;\n  for (; num_read < 32; num_read++) {\n    int res = ::read(sockfd, &byte_buf, 1);\n    if (res < 0) {\n      OLOG << \"Stats server error: reading from socket: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      return;\n    } else if (res == 0) {\n      break;\n    }\n    if (byte_buf == '\\n' || byte_buf == '\\0') {\n      break;\n    }\n    if (num_read == 0) {\n      mode = byte_buf;\n    }\n  }\n\n  Json::Value root;\n  root[\"error\"] = 0;\n  Json::Value body(Json::objectValue);\n  switch (mode) {\n    case 'g':\n      for (auto const& pair : getAll()) {\n        body[pair.first] = pair.second;\n      }\n      break;\n    case 'r':\n      Stats::reset();\n      break;\n    case '0':\n      break;\n    default:\n      root[\"error\"] = 1;\n      OLOG << \"Stats server error: received unknown request: \" << mode;\n  }\n  root[\"body\"] = body;\n  std::string ret = root.toStyledString();\n  if (Util::writeFull(sockfd, ret.c_str(), strlen(ret.c_str())) < 0) {\n    OLOG << \"Stats server error: writing to socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  thread_count_--;\n  lock.unlock();\n  thread_exited_.notify_one();\n}\n\n} // namespace Oomd",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <vector>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <memory>\n#include <sstream>\n#include <fstream>\n\nclass Stats {\npublic:\n    explicit Stats(const std::string& stats_socket_path)\n        : stats_socket_path_(stats_socket_path),\n          sockfd_(-1),\n          serv_addr_(),\n          stats_thread_(),\n          statsThreadRunning_(false),\n          stats_mutex_(),\n          thread_mutex_(),\n          thread_exited_(),\n          thread_count_(0),\n          stats_() {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stop();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n            unlink(stats_socket_path_.c_str());\n        }\n    }\n\n    static Stats& get(const std::string& stats_socket_path) {\n        static Stats instance(stats_socket_path);\n        return instance;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        if (!isInitInternal()) {\n            try {\n                Stats& instance = get(stats_socket_path);\n                if (!instance.startSocket()) {\n                    return false;\n                }\n                isInitInternal() = true;\n                return true;\n            } catch (...) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static bool isInit() {\n        return isInitInternal();\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return stats_[key];\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        return 0;\n    }\n\n    bool startSocket() {\n        if (sockfd_ != -1) {\n            return true;\n        }\n\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) {\n            return false;\n        }\n\n        unlink(stats_socket_path_.c_str());\n\n        if (bind(sockfd_, reinterpret_cast<struct sockaddr*>(&serv_addr_), sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            unlink(stats_socket_path_.c_str());\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            struct sockaddr_un cli_addr;\n            socklen_t clilen = sizeof(cli_addr);\n            int newsockfd = accept(sockfd_, reinterpret_cast<struct sockaddr*>(&cli_addr), &clilen);\n\n            if (newsockfd == -1) {\n                continue;\n            }\n\n            {\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                ++thread_count_;\n            }\n\n            std::thread([this, newsockfd]() {\n                processMsg(newsockfd);\n                close(newsockfd);\n\n                {\n                    std::lock_guard<std::mutex> lock(thread_mutex_);\n                    --thread_count_;\n                    if (thread_count_ == 0) {\n                        thread_exited_.notify_one();\n                    }\n                }\n            }).detach();\n        }\n\n        close(sockfd_);\n        sockfd_ = -1;\n        unlink(stats_socket_path_.c_str());\n\n        {\n            std::unique_lock<std::mutex> lock(thread_mutex_);\n            thread_exited_.wait(lock, [this] { return thread_count_ == 0; });\n        }\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[256];\n        bzero(buffer, 256);\n        int n = read(sockfd, buffer, 255);\n        if (n <= 0) {\n            return;\n        }\n\n        std::istringstream iss(buffer);\n        std::string command;\n        iss >> command;\n\n        std::ostringstream oss;\n        if (command == \"GET\") {\n            std::string key;\n            iss >> key;\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                oss << it->second;\n            } else {\n                oss << \"Key not found\";\n            }\n        } else if (command == \"INCREMENT\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] += val;\n            oss << stats_[key];\n        } else if (command == \"SET\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] = val;\n            oss << \"OK\";\n        } else if (command == \"RESET\") {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_.clear();\n            oss << \"OK\";\n        } else if (command == \"ALL\") {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            for (const auto& pair : stats_) {\n                oss << pair.first << \": \" << pair.second << \"\\n\";\n            }\n        } else {\n            oss << \"Unknown command\";\n        }\n\n        std::string response = oss.str();\n        write(sockfd, response.c_str(), response.size());\n    }\n\n    void stop() {\n        statsThreadRunning_ = false;\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static bool& isInitInternal() {\n        static bool initialized = false;\n        return initialized;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <unordered_map>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <memory>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nclass Stats {\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static Stats* instance_;\n    static bool initialized_;\n\n    Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), statsThreadRunning_(false), thread_count_(0) {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stopSocket();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n        }\n        unlink(serv_addr_.sun_path);\n    }\n\n    bool initInternal() {\n        if (isInitInternal()) {\n            return false;\n        }\n        initialized_ = true;\n        return true;\n    }\n\npublic:\n    static Stats& get(const std::string& stats_socket_path) {\n        if (!instance_) {\n            instance_ = new Stats(stats_socket_path);\n            instance_->startSocket();\n        }\n        return *instance_;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        if (instance_ || initialized_) {\n            return false;\n        }\n        instance_ = new Stats(stats_socket_path);\n        return instance_->initInternal();\n    }\n\n    static bool isInit() {\n        return initialized_;\n    }\n\n    bool isInitInternal() {\n        return initialized_;\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return val;\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        int count = stats_.size();\n        stats_.clear();\n        return count;\n    }\n\n    bool startSocket() {\n        if (sockfd_ != -1) {\n            return false;\n        }\n\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) {\n            return false;\n        }\n\n        unlink(serv_addr_.sun_path);\n\n        if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            int client_fd = accept(sockfd_, nullptr, nullptr);\n            if (client_fd == -1) {\n                continue;\n            }\n\n            std::lock_guard<std::mutex> lock(thread_mutex_);\n            ++thread_count_;\n        }\n\n        close(sockfd_);\n        sockfd_ = -1;\n\n        {\n            std::lock_guard<std::mutex> lock(thread_mutex_);\n            if (--thread_count_ == 0) {\n                thread_exited_.notify_all();\n            }\n        }\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[1024];\n        ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer) - 1);\n        if (bytes_read <= 0) {\n            close(sockfd);\n            return;\n        }\n\n        buffer[bytes_read] = '\\0';\n        std::istringstream iss(buffer);\n        std::string command;\n        iss >> command;\n\n        std::ostringstream oss;\n\n        if (command == \"GET\") {\n            std::string key;\n            iss >> key;\n            if (key.empty()) {\n                auto all_stats = getAll();\n                for (const auto& [k, v] : all_stats) {\n                    oss << k << \": \" << v << \"\\n\";\n                }\n            } else {\n                std::lock_guard<std::mutex> lock(stats_mutex_);\n                auto it = stats_.find(key);\n                if (it != stats_.end()) {\n                    oss << it->second;\n                } else {\n                    oss << \"Key not found\";\n                }\n            }\n        } else if (command == \"INCREMENT\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            if (!key.empty()) {\n                int new_val = increment(key, val);\n                oss << \"New value: \" << new_val;\n            } else {\n                oss << \"Invalid parameters\";\n            }\n        } else if (command == \"SET\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            if (!key.empty()) {\n                int new_val = set(key, val);\n                oss << \"Value set to: \" << new_val;\n            } else {\n                oss << \"Invalid parameters\";\n            }\n        } else if (command == \"RESET\") {\n            int count = reset();\n            oss << \"Reset \" << count << \" statistics\";\n        } else {\n            oss << \"Unknown command\";\n        }\n\n        std::string response = oss.str();\n        write(sockfd, response.c_str(), response.size());\n        close(sockfd);\n\n        std::lock_guard<std::mutex> lock(thread_mutex_);\n        if (--thread_count_ == 0 && !statsThreadRunning_) {\n            thread_exited_.notify_all();\n        }\n    }\n\n    void stopSocket() {\n        statsThreadRunning_ = false;\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n};\n\nStats* Stats::instance_ = nullptr;\nbool Stats::initialized_ = false;",
      "#include <iostream>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <unordered_map>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <functional>\n#include <memory>\n#include <sstream>\n#include <vector>\n\nclass Stats {\npublic:\n    explicit Stats(const std::string& stats_socket_path)\n        : stats_socket_path_(stats_socket_path),\n          sockfd_(-1),\n          serv_addr_(),\n          stats_thread_(),\n          statsThreadRunning_(false),\n          stats_mutex_(),\n          thread_mutex_(),\n          thread_exited_(),\n          thread_count_(0),\n          stats_() {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stop();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n            unlink(serv_addr_.sun_path);\n        }\n    }\n\n    static Stats& get(const std::string& stats_socket_path) {\n        static Stats instance(stats_socket_path);\n        return instance;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        if (!isInitInternal()) {\n            try {\n                Stats& instance = get(stats_socket_path);\n                if (instance.startSocket()) {\n                    isInitInternal() = true;\n                    return true;\n                }\n            } catch (...) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    static bool isInit() {\n        return isInitInternal();\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return val;\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        return 0;\n    }\n\n    bool startSocket() {\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) {\n            return false;\n        }\n\n        unlink(serv_addr_.sun_path);\n\n        if (bind(sockfd_, reinterpret_cast<struct sockaddr*>(&serv_addr_), sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            struct sockaddr_un cli_addr;\n            socklen_t clilen = sizeof(cli_addr);\n            int newsockfd = accept(sockfd_, reinterpret_cast<struct sockaddr*>(&cli_addr), &clilen);\n            if (newsockfd >= 0) {\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                ++thread_count_;\n                std::thread([this, newsockfd]() {\n                    processMsg(newsockfd);\n                    close(newsockfd);\n                    std::lock_guard<std::mutex> lock(thread_mutex_);\n                    --thread_count_;\n                    thread_exited_.notify_one();\n                }).detach();\n            }\n        }\n\n        close(sockfd_);\n\n        std::unique_lock<std::mutex> lock(thread_mutex_);\n        thread_exited_.wait(lock, [this] { return thread_count_ == 0; });\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[256];\n        bzero(buffer, 256);\n        int n = read(sockfd, buffer, 255);\n        if (n > 0) {\n            std::string request(buffer);\n            std::istringstream iss(request);\n            std::string command;\n            iss >> command;\n\n            std::ostringstream oss;\n            if (command == \"GET\") {\n                std::string key;\n                iss >> key;\n                std::lock_guard<std::mutex> lock(stats_mutex_);\n                auto it = stats_.find(key);\n                if (it != stats_.end()) {\n                    oss << it->second << \"\\n\";\n                } else {\n                    oss << \"Key not found\\n\";\n                }\n            } else if (command == \"RESET\") {\n                reset();\n                oss << \"Statistics reset\\n\";\n            } else if (command == \"INCREMENT\") {\n                std::string key;\n                int val;\n                iss >> key >> val;\n                int result = increment(key, val);\n                oss << \"Incremented to: \" << result << \"\\n\";\n            } else if (command == \"SET\") {\n                std::string key;\n                int val;\n                iss >> key >> val;\n                int result = set(key, val);\n                oss << \"Set to: \" << result << \"\\n\";\n            } else if (command == \"ALL\") {\n                auto all_stats = getAll();\n                for (const auto& pair : all_stats) {\n                    oss << pair.first << \": \" << pair.second << \"\\n\";\n                }\n            } else {\n                oss << \"Unknown command\\n\";\n            }\n\n            std::string response = oss.str();\n            write(sockfd, response.c_str(), response.size());\n        }\n    }\n\nprivate:\n    void stop() {\n        if (statsThreadRunning_) {\n            statsThreadRunning_ = false;\n            if (stats_thread_.joinable()) {\n                stats_thread_.join();\n            }\n        }\n    }\n\n    static bool& isInitInternal() {\n        static bool initialized = false;\n        return initialized;\n    }\n\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n};",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <memory>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <sstream>\n#include <vector>\n\nclass Stats {\npublic:\n    explicit Stats(const std::string& stats_socket_path)\n        : stats_socket_path_(stats_socket_path), sockfd_(-1), statsThreadRunning_(false), thread_count_(0) {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stopSocket();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n        }\n        unlink(serv_addr_.sun_path);\n    }\n\n    static Stats& get(const std::string& stats_socket_path) {\n        static Stats instance(stats_socket_path);\n        return instance;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        if (!isInitInternal()) {\n            instance_ = get_for_unittest(stats_socket_path);\n            if (!instance_->startSocket()) {\n                instance_.reset();\n                return false;\n            }\n            isInitFlag_ = true;\n            return true;\n        }\n        return false;\n    }\n\n    static bool isInit() {\n        return isInitInternal();\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return stats_[key];\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        return 0;\n    }\n\n    bool startSocket() {\n        if (sockfd_ != -1) return false;\n\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) return false;\n\n        unlink(serv_addr_.sun_path);\n\n        if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            unlink(serv_addr_.sun_path);\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            struct sockaddr_un client_addr;\n            socklen_t client_len = sizeof(client_addr);\n            int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n            if (client_fd == -1) continue;\n\n            std::lock_guard<std::mutex> lock(thread_mutex_);\n            ++thread_count_;\n            std::thread([this, client_fd]() {\n                processMsg(client_fd);\n                close(client_fd);\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                --thread_count_;\n                thread_exited_.notify_one();\n            }).detach();\n        }\n\n        {\n            std::unique_lock<std::mutex> lock(thread_mutex_);\n            thread_exited_.wait(lock, [this]() { return thread_count_ == 0; });\n        }\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[1024];\n        ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer) - 1);\n        if (bytes_read <= 0) return;\n\n        buffer[bytes_read] = '\\0';\n        std::istringstream iss(buffer);\n        std::string request_type;\n        iss >> request_type;\n\n        std::ostringstream oss;\n\n        if (request_type == \"GET\") {\n            std::string key;\n            iss >> key;\n            if (key == \"ALL\") {\n                auto all_stats = getAll();\n                for (const auto& pair : all_stats) {\n                    oss << pair.first << \":\" << pair.second << \"\\n\";\n                }\n            } else {\n                std::lock_guard<std::mutex> lock(stats_mutex_);\n                auto it = stats_.find(key);\n                if (it != stats_.end()) {\n                    oss << it->second;\n                } else {\n                    oss << \"Key not found\";\n                }\n            }\n        } else if (request_type == \"INCREMENT\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            int new_val = increment(key, val);\n            oss << \"Incremented to: \" << new_val;\n        } else if (request_type == \"SET\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            int new_val = set(key, val);\n            oss << \"Set to: \" << new_val;\n        } else if (request_type == \"RESET\") {\n            reset();\n            oss << \"Statistics reset\";\n        } else {\n            oss << \"Unknown command\";\n        }\n\n        std::string response = oss.str();\n        write(sockfd, response.c_str(), response.size());\n    }\n\n    void stopSocket() {\n        statsThreadRunning_ = false;\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n\nprivate:\n    static bool& isInitInternal() {\n        static bool flag = false;\n        return flag;\n    }\n\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static std::unique_ptr<Stats> instance_;\n    static bool isInitFlag_;\n};\n\nstd::unique_ptr<Stats> Stats::instance_;\nbool Stats::isInitFlag_ = false;",
      "#include <iostream>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <unordered_map>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <functional>\n#include <memory>\n#include <sstream>\n#include <vector>\n\nclass Stats {\npublic:\n    explicit Stats(const std::string& stats_socket_path)\n        : stats_socket_path_(stats_socket_path),\n          sockfd_(-1),\n          serv_addr_(),\n          stats_thread_(),\n          statsThreadRunning_(false),\n          stats_mutex_(),\n          thread_mutex_(),\n          thread_exited_(),\n          thread_count_(0),\n          stats_() {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stop();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n            unlink(serv_addr_.sun_path);\n        }\n    }\n\n    static Stats& get(const std::string& stats_socket_path) {\n        static Stats instance(stats_socket_path);\n        return instance;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        if (!isInitInternal()) {\n            try {\n                Stats::get(stats_socket_path);\n                isInitInternal() = true;\n                return true;\n            } catch (...) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    static bool isInit() {\n        return isInitInternal();\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return val;\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        int count = stats_.size();\n        stats_.clear();\n        return count;\n    }\n\n    bool startSocket() {\n        if (sockfd_ != -1) return false;\n\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) return false;\n\n        unlink(serv_addr_.sun_path);\n\n        if (bind(sockfd_, reinterpret_cast<struct sockaddr*>(&serv_addr_), sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            unlink(serv_addr_.sun_path);\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            struct sockaddr_un cli_addr;\n            socklen_t clilen = sizeof(cli_addr);\n            int newsockfd = accept(sockfd_, reinterpret_cast<struct sockaddr*>(&cli_addr), &clilen);\n            if (newsockfd == -1) continue;\n\n            std::lock_guard<std::mutex> lock(thread_mutex_);\n            ++thread_count_;\n            std::thread([this, newsockfd]() {\n                processMsg(newsockfd);\n                close(newsockfd);\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                --thread_count_;\n                thread_exited_.notify_one();\n            }).detach();\n        }\n\n        close(sockfd_);\n        sockfd_ = -1;\n\n        std::unique_lock<std::mutex> lock(thread_mutex_);\n        thread_exited_.wait(lock, [this] { return thread_count_ == 0; });\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[1024];\n        int n = read(sockfd, buffer, sizeof(buffer) - 1);\n        if (n <= 0) return;\n\n        buffer[n] = '\\0';\n        std::istringstream iss(buffer);\n        std::string request;\n        iss >> request;\n\n        std::ostringstream oss;\n        if (request == \"GET\") {\n            std::string key;\n            iss >> key;\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                oss << \"GET \" << it->first << \" \" << it->second << \"\\n\";\n            } else {\n                oss << \"ERROR Key not found\\n\";\n            }\n        } else if (request == \"INCREMENT\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            int new_val = increment(key, val);\n            oss << \"INCREMENTED \" << key << \" \" << new_val << \"\\n\";\n        } else if (request == \"SET\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            int new_val = set(key, val);\n            oss << \"SET \" << key << \" \" << new_val << \"\\n\";\n        } else if (request == \"RESET\") {\n            int count = reset();\n            oss << \"RESET \" << count << \" statistics\\n\";\n        } else if (request == \"ALL\") {\n            auto all_stats = getAll();\n            for (const auto& pair : all_stats) {\n                oss << pair.first << \": \" << pair.second << \"\\n\";\n            }\n        } else {\n            oss << \"ERROR Unknown command\\n\";\n        }\n\n        std::string response = oss.str();\n        write(sockfd, response.c_str(), response.size());\n    }\n\n    void stop() {\n        if (statsThreadRunning_) {\n            statsThreadRunning_ = false;\n            if (stats_thread_.joinable()) {\n                stats_thread_.join();\n            }\n        }\n    }\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static bool& isInitInternal() {\n        static bool initialized = false;\n        return initialized;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <memory>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <sstream>\n#include <vector>\n\nclass Stats {\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static Stats* instance_;\n    static bool initialized_;\n\n    Stats(const std::string& stats_socket_path) \n        : stats_socket_path_(stats_socket_path), \n          sockfd_(-1), \n          statsThreadRunning_(false),\n          thread_count_(0) {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stopSocket();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n        }\n        unlink(stats_socket_path_.c_str());\n    }\n\n    void stopSocket() {\n        if (statsThreadRunning_.load()) {\n            statsThreadRunning_.store(false);\n            if (stats_thread_.joinable()) {\n                stats_thread_.join();\n            }\n        }\n    }\n\n    bool initInternal() {\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) {\n            return false;\n        }\n\n        unlink(serv_addr_.sun_path);\n\n        if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            return false;\n        }\n\n        return true;\n    }\n\n    void runSocket() {\n        statsThreadRunning_.store(true);\n        while (statsThreadRunning_.load()) {\n            int connfd = accept(sockfd_, nullptr, nullptr);\n            if (connfd == -1) {\n                continue;\n            }\n\n            std::lock_guard<std::mutex> lock(thread_mutex_);\n            thread_count_++;\n        }\n\n        std::thread([this, connfd]() {\n            processMsg(connfd);\n            close(connfd);\n\n            std::lock_guard<std::mutex> lock(thread_mutex_);\n            thread_count_--;\n            if (thread_count_ == 0) {\n                thread_exited_.notify_one();\n            }\n        }).detach();\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[1024];\n        ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer) - 1);\n        if (bytes_read <= 0) {\n            return;\n        }\n        buffer[bytes_read] = '\\0';\n\n        std::istringstream iss(buffer);\n        std::string command;\n        iss >> command;\n\n        std::ostringstream oss;\n\n        if (command == \"GET\") {\n            std::string key;\n            iss >> key;\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                oss << it->second << \"\\n\";\n            } else {\n                oss << \"0\\n\";\n            }\n        } else if (command == \"INCREMENT\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] += val;\n            oss << \"OK\\n\";\n        } else if (command == \"SET\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] = val;\n            oss << \"OK\\n\";\n        } else if (command == \"RESET\") {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_.clear();\n            oss << \"OK\\n\";\n        } else if (command == \"GETALL\") {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            for (const auto& pair : stats_) {\n                oss << pair.first << \": \" << pair.second << \"\\n\";\n            }\n        } else {\n            oss << \"UNKNOWN_COMMAND\\n\";\n        }\n\n        std::string response = oss.str();\n        write(sockfd, response.c_str(), response.size());\n    }\n\npublic:\n    static Stats& get(const std::string& stats_socket_path) {\n        if (!instance_) {\n            instance_ = new Stats(stats_socket_path);\n            if (!instance_->initInternal()) {\n                delete instance_;\n                instance_ = nullptr;\n                throw std::runtime_error(\"Failed to initialize Stats\");\n            }\n            instance_->startSocket();\n        }\n        return *instance_;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        auto stats = std::make_unique<Stats>(stats_socket_path);\n        if (!stats->initInternal()) {\n            return nullptr;\n        }\n        stats->startSocket();\n        return stats;\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        if (instance_) {\n            return false;\n        }\n        instance_ = new Stats(stats_socket_path);\n        bool success = instance_->initInternal();\n        if (!success) {\n            delete instance_;\n            instance_ = nullptr;\n        } else {\n            initialized_ = true;\n        }\n        return success;\n    }\n\n    static bool isInit() {\n        return instance_ != nullptr;\n    }\n\n    static bool isInitInternal() {\n        return initialized_;\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return stats_[key];\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        return 0;\n    }\n\n    bool startSocket() {\n        if (statsThreadRunning_.load()) {\n            return false;\n        }\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n};\n\nStats* Stats::instance_ = nullptr;\nbool Stats::initialized_ = false;",
      "#include <iostream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <unordered_map>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <memory>\n#include <functional>\n#include <vector>\n\nclass Stats {\npublic:\n    explicit Stats(const std::string& stats_socket_path)\n        : stats_socket_path_(stats_socket_path),\n          sockfd_(-1),\n          serv_addr_(),\n          stats_thread_(),\n          statsThreadRunning_(false),\n          stats_mutex_(),\n          thread_mutex_(),\n          thread_exited_(),\n          thread_count_(0),\n          stats_() {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stop();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n            unlink(serv_addr_.sun_path);\n        }\n    }\n\n    static Stats& get(const std::string& stats_socket_path) {\n        static Stats instance(stats_socket_path);\n        return instance;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        if (!isInitInternal()) {\n            try {\n                get(stats_socket_path);\n                isInitInternal() = true;\n                return true;\n            } catch (...) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    static bool isInit() {\n        return isInitInternal();\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return val;\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        int count = stats_.size();\n        stats_.clear();\n        return count;\n    }\n\n    bool startSocket() {\n        if (sockfd_ != -1) return false;\n\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) return false;\n\n        unlink(serv_addr_.sun_path);\n\n        if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            unlink(serv_addr_.sun_path);\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            struct sockaddr_un client_addr;\n            socklen_t client_len = sizeof(client_addr);\n            int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n            if (client_fd == -1) continue;\n\n            std::lock_guard<std::mutex> lock(thread_mutex_);\n            ++thread_count_;\n            std::thread([this, client_fd]() {\n                processMsg(client_fd);\n                close(client_fd);\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                --thread_count_;\n                thread_exited_.notify_one();\n            }).detach();\n        }\n\n        {\n            std::unique_lock<std::mutex> lock(thread_mutex_);\n            thread_exited_.wait(lock, [this] { return thread_count_ == 0; });\n        }\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[1024];\n        ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer) - 1);\n        if (bytes_read <= 0) return;\n\n        buffer[bytes_read] = '\\0';\n        std::string request(buffer);\n\n        std::istringstream iss(request);\n        std::string command;\n        if (!(iss >> command)) return;\n\n        std::ostringstream oss;\n        if (command == \"GET\") {\n            std::string key;\n            if (iss >> key) {\n                std::lock_guard<std::mutex> lock(stats_mutex_);\n                auto it = stats_.find(key);\n                oss << (it != stats_.end() ? std::to_string(it->second) : \"NOT_FOUND\");\n            } else {\n                oss << \"ERROR: Missing key\";\n            }\n        } else if (command == \"INCREMENT\") {\n            std::string key;\n            int val;\n            if (iss >> key >> val) {\n                increment(key, val);\n                oss << \"OK\";\n            } else {\n                oss << \"ERROR: Missing key or value\";\n            }\n        } else if (command == \"SET\") {\n            std::string key;\n            int val;\n            if (iss >> key >> val) {\n                set(key, val);\n                oss << \"OK\";\n            } else {\n                oss << \"ERROR: Missing key or value\";\n            }\n        } else if (command == \"RESET\") {\n            reset();\n            oss << \"OK\";\n        } else if (command == \"GETALL\") {\n            auto all_stats = getAll();\n            for (const auto& pair : all_stats) {\n                oss << pair.first << \": \" << pair.second << \"\\n\";\n            }\n        } else {\n            oss << \"ERROR: Unknown command\";\n        }\n\n        std::string response = oss.str();\n        write(sockfd, response.c_str(), response.size());\n    }\n\n    void stop() {\n        if (statsThreadRunning_) {\n            statsThreadRunning_ = false;\n            if (stats_thread_.joinable()) {\n                stats_thread_.join();\n            }\n        }\n    }\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static bool& isInitInternal() {\n        static bool initialized = false;\n        return initialized;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <memory>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nclass Stats {\npublic:\n    explicit Stats(const std::string& stats_socket_path)\n        : stats_socket_path_(stats_socket_path),\n          sockfd_(-1),\n          serv_addr_(),\n          stats_thread_(),\n          statsThreadRunning_(false),\n          stats_mutex_(),\n          thread_mutex_(),\n          thread_exited_(),\n          thread_count_(0),\n          stats_() {\n        if (isInitInternal()) {\n            throw std::runtime_error(\"Stats singleton already initialized\");\n        }\n        isInitInternal() = true;\n    }\n\n    ~Stats() {\n        stopSocket();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n        }\n        unlink(stats_socket_path_.c_str());\n        isInitInternal() = false;\n    }\n\n    static Stats& get(const std::string& stats_socket_path) {\n        static Stats instance(stats_socket_path);\n        return instance;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        try {\n            get(stats_socket_path);\n            return true;\n        } catch (...) {\n            return false;\n        }\n    }\n\n    static bool isInit() {\n        return isInitInternal();\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return val;\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        return 0;\n    }\n\n    bool startSocket() {\n        if (sockfd_ != -1) {\n            return false;\n        }\n\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) {\n            return false;\n        }\n\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n\n        unlink(stats_socket_path_.c_str());\n\n        if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            unlink(stats_socket_path_.c_str());\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            struct sockaddr_un cli_addr;\n            socklen_t clilen = sizeof(cli_addr);\n            int* connfd = new int;\n\n            *connfd = accept(sockfd_, (struct sockaddr*)&cli_addr, &clilen);\n\n            if (*connfd < 0) {\n                delete connfd;\n                continue;\n            }\n\n            {\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                ++thread_count_;\n            }\n\n            std::thread([this, connfd]() {\n                processMsg(*connfd);\n                close(*connfd);\n                delete connfd;\n\n                {\n                    std::lock_guard<std::mutex> lock(thread_mutex_);\n                    --thread_count_;\n                    if (thread_count_ == 0) {\n                        thread_exited_.notify_one();\n                    }\n                }\n            }).detach();\n        }\n\n        close(sockfd_);\n        sockfd_ = -1;\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[4096];\n        int n;\n        std::ostringstream oss;\n\n        while ((n = read(sockfd, buffer, sizeof(buffer))) > 0) {\n            oss.write(buffer, n);\n        }\n\n        std::string request = oss.str();\n        std::istringstream iss(request);\n        std::string command;\n        if (!(iss >> command)) {\n            write(sockfd, \"ERROR\\n\", 6);\n            return;\n        }\n\n        if (command == \"GET\") {\n            std::string key;\n            if (iss >> key) {\n                std::lock_guard<std::mutex> lock(stats_mutex_);\n                auto it = stats_.find(key);\n                std::string response = (it != stats_.end()) ? std::to_string(it->second) + \"\\n\" : \"0\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                std::lock_guard<std::mutex> lock(stats_mutex_);\n                std::ostringstream resp;\n                for (const auto& pair : stats_) {\n                    resp << pair.first << \":\" << pair.second << \"\\n\";\n                }\n                std::string response = resp.str();\n                write(sockfd, response.c_str(), response.size());\n            }\n        } else if (command == \"INCREMENT\") {\n            std::string key;\n            int val;\n            if (iss >> key >> val) {\n                int new_val = increment(key, val);\n                std::string response = std::to_string(new_val) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                write(sockfd, \"ERROR\\n\", 6);\n            }\n        } else if (command == \"SET\") {\n            std::string key;\n            int val;\n            if (iss >> key >> val) {\n                int new_val = set(key, val);\n                std::string response = std::to_string(new_val) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                write(sockfd, \"ERROR\\n\", 6);\n            }\n        } else if (command == \"RESET\") {\n            int result = reset();\n            std::string response = std::to_string(result) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            write(sockfd, \"ERROR\\n\", 6);\n        }\n    }\n\nprivate:\n    void stopSocket() {\n        statsThreadRunning_ = false;\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n\n        std::unique_lock<std::mutex> lock(thread_mutex_);\n        thread_exited_.wait(lock, [this] { return thread_count_ == 0; });\n    }\n\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static bool& isInitInternal() {\n        static bool initialized = false;\n        return initialized;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <memory>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nclass Stats {\npublic:\n    explicit Stats(const std::string& stats_socket_path)\n        : stats_socket_path_(stats_socket_path), sockfd_(-1), statsThreadRunning_(false), thread_count_(0) {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stopSocket();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n        }\n        unlink(stats_socket_path_.c_str());\n    }\n\n    static Stats& get(const std::string& stats_socket_path) {\n        static Stats instance(stats_socket_path);\n        return instance;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        if (!isInit()) {\n            instance_ = std::shared_ptr<Stats>(new Stats(stats_socket_path));\n            if (!instance_->startSocket()) {\n                instance_.reset();\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static bool isInit() {\n        return instance_ != nullptr;\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return val;\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        return 0;\n    }\n\n    bool startSocket() {\n        if (sockfd_ != -1) {\n            return true;\n        }\n\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0);\n        if (sockfd_ == -1) {\n            return false;\n        }\n\n        unlink(serv_addr_.sun_path);\n\n        if (bind(sockfd_, reinterpret_cast<struct sockaddr*>(&serv_addr_), sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            sockfd_ = -1;\n            unlink(serv_addr_.sun_path);\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            struct sockaddr_un client_addr;\n            socklen_t client_len = sizeof(client_addr);\n            int connfd = accept(sockfd_, reinterpret_cast<struct sockaddr*>(&client_addr), &client_len);\n            if (connfd == -1) {\n                continue;\n            }\n\n            {\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                ++thread_count_;\n            }\n\n            std::thread([this, connfd]() {\n                processMsg(connfd);\n                close(connfd);\n\n                {\n                    std::lock_guard<std::mutex> lock(thread_mutex_);\n                    --thread_count_;\n                    if (thread_count_ == 0) {\n                        thread_exited_.notify_one();\n                    }\n                }\n            }).detach();\n        }\n\n        close(sockfd_);\n        sockfd_ = -1;\n\n        std::unique_lock<std::mutex> lock(thread_mutex_);\n        thread_exited_.wait(lock, [this] { return thread_count_ == 0; });\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[1024];\n        ssize_t n = read(sockfd, buffer, sizeof(buffer) - 1);\n        if (n <= 0) {\n            return;\n        }\n        buffer[n] = '\\0';\n\n        std::istringstream iss(buffer);\n        std::string command;\n        if (!(iss >> command)) {\n            return;\n        }\n\n        std::ostringstream oss;\n        if (command == \"GET\") {\n            std::string key;\n            if (iss >> key) {\n                std::lock_guard<std::mutex> lock(stats_mutex_);\n                auto it = stats_.find(key);\n                oss << (it != stats_.end() ? std::to_string(it->second) : \"Key not found\");\n            } else {\n                oss << \"Invalid GET command\";\n            }\n        } else if (command == \"INCREMENT\") {\n            std::string key;\n            int val;\n            if (iss >> key >> val) {\n                oss << increment(key, val);\n            } else {\n                oss << \"Invalid INCREMENT command\";\n            }\n        } else if (command == \"SET\") {\n            std::string key;\n            int val;\n            if (iss >> key >> val) {\n                oss << set(key, val);\n            } else {\n                oss << \"Invalid SET command\";\n            }\n        } else if (command == \"RESET\") {\n            oss << reset();\n        } else if (command == \"GETALL\") {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            for (const auto& pair : stats_) {\n                oss << pair.first << \": \" << pair.second << \"\\n\";\n            }\n        } else {\n            oss << \"Unknown command\";\n        }\n\n        std::string response = oss.str();\n        write(sockfd, response.c_str(), response.size());\n    }\n\n    void stopSocket() {\n        statsThreadRunning_ = false;\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static std::shared_ptr<Stats> instance_;\n};\n\nstd::shared_ptr<Stats> Stats::instance_;",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <vector>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <memory>\n#include <sstream>\n#include <stdexcept>\n\nclass Stats {\npublic:\n    explicit Stats(const std::string& stats_socket_path)\n        : stats_socket_path_(stats_socket_path),\n          sockfd_(-1),\n          serv_addr_(),\n          stats_thread_(),\n          statsThreadRunning_(false),\n          stats_mutex_(),\n          thread_mutex_(),\n          thread_exited_(),\n          thread_count_(0),\n          stats_() {\n        memset(&serv_addr_, 0, sizeof(serv_addr_));\n        serv_addr_.sun_family = AF_UNIX;\n        strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    }\n\n    ~Stats() {\n        stop();\n        if (sockfd_ != -1) {\n            close(sockfd_);\n            unlink(stats_socket_path_.c_str());\n        }\n    }\n\n    static Stats& get(const std::string& stats_socket_path) {\n        static Stats instance(stats_socket_path);\n        return instance;\n    }\n\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path) {\n        return std::make_unique<Stats>(stats_socket_path);\n    }\n\n    static bool init(const std::string& stats_socket_path) {\n        try {\n            get(stats_socket_path);\n            return true;\n        } catch (...) {\n            return false;\n        }\n    }\n\n    static bool isInit() {\n        return isInitInternal();\n    }\n\n    std::unordered_map<std::string, int> getAll() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        return stats_;\n    }\n\n    int increment(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] += val;\n        return stats_[key];\n    }\n\n    int set(const std::string& key, int val) {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        return stats_[key];\n    }\n\n    int reset() {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        int count = stats_.size();\n        stats_.clear();\n        return count;\n    }\n\n    bool startSocket() {\n        sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (sockfd_ == -1) {\n            return false;\n        }\n\n        unlink(stats_socket_path_.c_str());\n\n        if (bind(sockfd_, reinterpret_cast<struct sockaddr*>(&serv_addr_), sizeof(serv_addr_)) == -1) {\n            close(sockfd_);\n            return false;\n        }\n\n        if (listen(sockfd_, 5) == -1) {\n            close(sockfd_);\n            return false;\n        }\n\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n\n    void runSocket() {\n        while (statsThreadRunning_) {\n            struct sockaddr_un cli_addr;\n            socklen_t clilen = sizeof(cli_addr);\n            int* connfd = new int;\n\n            *connfd = accept(sockfd_, reinterpret_cast<struct sockaddr*>(&cli_addr), &clilen);\n            if (*connfd < 0) {\n                delete connfd;\n                continue;\n            }\n\n            {\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                ++thread_count_;\n            }\n\n            std::thread([this, connfd]() {\n                processMsg(*connfd);\n                close(*connfd);\n                delete connfd;\n\n                std::lock_guard<std::mutex> lock(thread_mutex_);\n                --thread_count_;\n                thread_exited_.notify_one();\n            }).detach();\n        }\n\n        close(sockfd_);\n    }\n\n    void processMsg(int sockfd) {\n        char buffer[256];\n        int n = read(sockfd, buffer, sizeof(buffer) - 1);\n        if (n <= 0) {\n            return;\n        }\n        buffer[n] = '\\0';\n\n        std::string request(buffer);\n        std::istringstream iss(request);\n        std::string cmd;\n        iss >> cmd;\n\n        std::ostringstream oss;\n\n        if (cmd == \"GET\") {\n            std::string key;\n            iss >> key;\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                oss << it->second << \"\\n\";\n            } else {\n                oss << \"Key not found\\n\";\n            }\n        } else if (cmd == \"INCREMENT\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            int new_val = increment(key, val);\n            oss << new_val << \"\\n\";\n        } else if (cmd == \"SET\") {\n            std::string key;\n            int val;\n            iss >> key >> val;\n            int new_val = set(key, val);\n            oss << new_val << \"\\n\";\n        } else if (cmd == \"RESET\") {\n            int count = reset();\n            oss << count << \" statistics reset\\n\";\n        } else if (cmd == \"ALL\") {\n            auto all_stats = getAll();\n            for (const auto& pair : all_stats) {\n                oss << pair.first << \": \" << pair.second << \"\\n\";\n            }\n        } else {\n            oss << \"Unknown command\\n\";\n        }\n\n        std::string response = oss.str();\n        write(sockfd, response.c_str(), response.size());\n    }\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static bool& isInitInternal() {\n        static bool initialized = false;\n        return initialized;\n    }\n\n    void stop() {\n        if (statsThreadRunning_) {\n            statsThreadRunning_ = false;\n            if (stats_thread_.joinable()) {\n                stats_thread_.join();\n            }\n        }\n\n        std::unique_lock<std::mutex> lock(thread_mutex_);\n        thread_exited_.wait(lock, [this]() { return thread_count_ == 0; });\n    }\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a UDP receiver class in C++ that listens for incoming UDP packets on a specified port, processes them, and forwards them to a network handling component. The class should handle socket creation, binding, and packet reception in a non-blocking manner using polling.\n\nClass Description: The `UDPRecv` class is responsible for setting up a UDP socket server that listens for incoming messages on a specified port. It uses polling to check for incoming data without blocking, and forwards received messages to a network handling component (`DFNetWork`). The class manages the socket lifecycle and provides methods to initialize, start, and stop the receiver.\n\nAttributes:\n- m_poDFNetWork: [DFNetWork*] - Pointer to the network handling component that processes received messages\n- m_iSockFD: [int] - File descriptor for the UDP socket\n- m_bIsEnd: [bool] - Flag indicating whether the receiver should stop running\n- m_bIsStarted: [bool] - Flag indicating whether the receiver has started\n\nMethods:\n- UDPRecv(DFNetWork* poDFNetWork) -> [void] - Constructor that initializes the receiver with a network handling component\n- ~UDPRecv() -> [void] - Destructor that closes the socket if it's open\n- Stop() -> [void] - Signals the receiver to stop and waits for it to finish\n- Init(int iPort) -> [int] - Initializes the UDP socket and binds it to the specified port (returns 0 on success, -1 on failure)\n- run() -> [void] - Main execution loop that polls for incoming messages and processes them (runs in a separate thread)",
    "Canonical_solution": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include \"dfnetwork.h\"\n\nnamespace phxpaxos {\n\nclass UDPRecv\n{\npublic:\n    UDPRecv(DFNetWork * poDFNetWork);\n    ~UDPRecv();\n\n    void Stop();\n    int Init(const int iPort);\n    void run();\n\nprivate:\n    DFNetWork * m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n};\n\nUDPRecv::UDPRecv(DFNetWork * poDFNetWork) \n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false)\n{\n}\n\nUDPRecv::~UDPRecv()\n{\n    if (m_iSockFD != -1)\n    {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n    }\n}\n\nvoid UDPRecv::Stop()\n{\n    if (m_bIsStarted)\n    {\n        m_bIsEnd = true;\n        join();\n    }\n}\n\nint UDPRecv::Init(const int iPort)\n{\n    if ((m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0)) < 0) \n    {\n        return -1;\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(iPort);\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    int enable = 1;\n    setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int));\n\n    if (bind(m_iSockFD, (struct sockaddr *)&addr, sizeof(addr)) < 0) \n    {\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid UDPRecv::run()\n{\n    m_bIsStarted = true;\n\n    char sBuffer[65536] = {0};\n\n    struct sockaddr_in addr;\n    socklen_t addr_len = sizeof(struct sockaddr_in);\n    memset(&addr, 0, sizeof(addr));\n\n    while(true)\n    {\n        if (m_bIsEnd)\n        {\n            return;\n        }\n\n        struct pollfd fd;\n        int ret;\n\n        fd.fd = m_iSockFD;\n        fd.events = POLLIN;\n        ret = poll(&fd, 1, 500);\n\n        if (ret == 0 || ret == -1)\n        {\n            continue;\n        }\n        \n        int iRecvLen = recvfrom(m_iSockFD, sBuffer, sizeof(sBuffer), 0,\n                (struct sockaddr *)&addr, &addr_len);\n\n        if (iRecvLen > 0)\n        {\n            m_poDFNetWork->OnReceiveMessage(sBuffer, iRecvLen);\n        }\n    }\n}\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 152,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork;\n\nclass UDPRecv {\npublic:\n    UDPRecv(DFNetWork* poDFNetWork);\n    ~UDPRecv();\n    void Stop();\n    int Init(int iPort);\n    void run();\n\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n};\n\nUDPRecv::UDPRecv(DFNetWork* poDFNetWork)\n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\nUDPRecv::~UDPRecv() {\n    if (m_iSockFD != -1) {\n        close(m_iSockFD);\n    }\n}\n\nvoid UDPRecv::Stop() {\n    m_bIsEnd = true;\n    if (m_thread.joinable()) {\n        m_thread.join();\n    }\n}\n\nint UDPRecv::Init(int iPort) {\n    m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n    if (m_iSockFD == -1) {\n        return -1;\n    }\n\n    int flags = fcntl(m_iSockFD, F_GETFL, 0);\n    fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n    sockaddr_in addr;\n    std::memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(iPort);\n    addr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(m_iSockFD, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == -1) {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid UDPRecv::run() {\n    m_bIsStarted = true;\n    pollfd pfd;\n    pfd.fd = m_iSockFD;\n    pfd.events = POLLIN;\n\n    while (!m_bIsEnd) {\n        int ret = poll(&pfd, 1, 100); // 100ms timeout\n        if (ret > 0 && (pfd.revents & POLLIN)) {\n            char buffer[65536];\n            sockaddr_in senderAddr;\n            socklen_t senderAddrLen = sizeof(senderAddr);\n            ssize_t recvLen = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0,\n                                       reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n            if (recvLen > 0) {\n                // Forward to network handler\n                m_poDFNetWork->HandleMessage(buffer, recvLen, &senderAddr);\n            }\n        }\n    }\n\n    m_bIsStarted = false;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork {\npublic:\n    void ProcessMessage(const char* data, int size, const sockaddr_in& addr) {\n        // Handle the received message\n        std::cout << \"Received message from \" << inet_ntoa(addr.sin_addr) << \":\" << ntohs(addr.sin_port) << std::endl;\n    }\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n\n    static const int BUFFER_SIZE = 65536;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork)\n        : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        Stop();\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_thread.joinable()) {\n            m_thread.join();\n        }\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return -1;\n        }\n\n        // Set non-blocking\n        int flags = fcntl(m_iSockFD, F_GETFL, 0);\n        fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n        sockaddr_in addr;\n        std::memset(&addr, 0, sizeof(addr));\n        addr.sin_family = AF_INET;\n        addr.sin_port = htons(iPort);\n        addr.sin_addr.s_addr = INADDR_ANY;\n\n        if (bind(m_iSockFD, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == -1) {\n            std::cerr << \"Failed to bind socket\" << std::endl;\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_bIsEnd = false;\n        m_thread = std::thread(&UDPRecv::run, this);\n        m_bIsStarted = true;\n\n        return 0;\n    }\n\n    void run() {\n        char buffer[BUFFER_SIZE];\n        sockaddr_in senderAddr;\n        socklen_t senderAddrLen = sizeof(senderAddr);\n\n        struct pollfd fds[1];\n        fds[0].fd = m_iSockFD;\n        fds[0].events = POLLIN;\n\n        while (!m_bIsEnd) {\n            int ret = poll(fds, 1, 100); // 100ms timeout\n\n            if (ret > 0 && (fds[0].revents & POLLIN)) {\n                ssize_t recvLen = recvfrom(m_iSockFD, buffer, BUFFER_SIZE, 0,\n                                           reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n\n                if (recvLen > 0) {\n                    m_poDFNetWork->ProcessMessage(buffer, recvLen, senderAddr);\n                }\n            }\n        }\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork {\npublic:\n    void ProcessMessage(const char* data, int size, const sockaddr_in& addr) {\n        // Handle the received message\n    }\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n\n    static const int BUFFER_SIZE = 65536;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork)\n        : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        Stop();\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_thread.joinable()) {\n            m_thread.join();\n        }\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            return -1;\n        }\n\n        int flags = fcntl(m_iSockFD, F_GETFL, 0);\n        fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n        sockaddr_in addr;\n        std::memset(&addr, 0, sizeof(addr));\n        addr.sin_family = AF_INET;\n        addr.sin_port = htons(iPort);\n        addr.sin_addr.s_addr = INADDR_ANY;\n\n        if (bind(m_iSockFD, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        return 0;\n    }\n\n    void run() {\n        if (m_iSockFD == -1 || m_bIsStarted) {\n            return;\n        }\n\n        m_bIsStarted = true;\n        m_bIsEnd = false;\n\n        while (!m_bIsEnd) {\n            struct pollfd fds[1];\n            fds[0].fd = m_iSockFD;\n            fds[0].events = POLLIN;\n\n            int ret = poll(fds, 1, 100); // 100ms timeout\n\n            if (ret > 0 && (fds[0].revents & POLLIN)) {\n                sockaddr_in senderAddr;\n                socklen_t senderAddrLen = sizeof(senderAddr);\n                char buffer[BUFFER_SIZE];\n\n                ssize_t recvLen = recvfrom(m_iSockFD, buffer, BUFFER_SIZE, 0,\n                                           reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrLen);\n\n                if (recvLen > 0) {\n                    m_poDFNetWork->ProcessMessage(buffer, recvLen, senderAddr);\n                }\n            }\n        }\n\n        m_bIsStarted = false;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <thread>\n#include <poll.h>\n\nclass DFNetWork;\n\nclass UDPRecv {\npublic:\n    UDPRecv(DFNetWork* poDFNetWork);\n    ~UDPRecv();\n    void Stop();\n    int Init(int iPort);\n    void run();\n\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n};\n\nUDPRecv::UDPRecv(DFNetWork* poDFNetWork)\n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\nUDPRecv::~UDPRecv() {\n    if (m_iSockFD != -1) {\n        close(m_iSockFD);\n    }\n}\n\nvoid UDPRecv::Stop() {\n    m_bIsEnd = true;\n    if (m_bIsStarted) {\n        // Wait for the thread to finish if needed\n        // This would require storing the thread object or joining elsewhere\n    }\n}\n\nint UDPRecv::Init(int iPort) {\n    m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n    if (m_iSockFD == -1) {\n        return -1;\n    }\n\n    int flags = fcntl(m_iSockFD, F_GETFL, 0);\n    fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n    sockaddr_in serverAddr;\n    std::memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(iPort);\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(m_iSockFD, reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)) == -1) {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n        return -1;\n    }\n\n    m_bIsStarted = true;\n    return 0;\n}\n\nvoid UDPRecv::run() {\n    const size_t bufferSize = 65536;\n    char buffer[bufferSize];\n    sockaddr_in clientAddr;\n    socklen_t addrLen = sizeof(clientAddr);\n\n    struct pollfd fds[1];\n    fds[0].fd = m_iSockFD;\n    fds[0].events = POLLIN;\n\n    while (!m_bIsEnd) {\n        int ret = poll(fds, 1, 100); // 100ms timeout\n\n        if (ret > 0 && (fds[0].revents & POLLIN)) {\n            ssize_t recvLen = recvfrom(m_iSockFD, buffer, bufferSize, 0,\n                                       reinterpret_cast<sockaddr*>(&clientAddr), &addrLen);\n            if (recvLen > 0) {\n                // Forward the received packet to network handler\n                m_poDFNetWork->HandleMessage(buffer, recvLen, &clientAddr);\n            }\n        }\n    }\n\n    m_bIsStarted = false;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork {\npublic:\n    void ProcessMessage(const char* data, int size, const sockaddr_in& addr) {\n        // Handle received message\n    }\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n\n    static const int MAX_BUFFER_SIZE = 65536;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork)\n        : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        Stop();\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_thread.joinable()) {\n            m_thread.join();\n        }\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            return -1;\n        }\n\n        int flags = fcntl(m_iSockFD, F_GETFL, 0);\n        fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n        sockaddr_in addr;\n        std::memset(&addr, 0, sizeof(addr));\n        addr.sin_family = AF_INET;\n        addr.sin_port = htons(iPort);\n        addr.sin_addr.s_addr = INADDR_ANY;\n\n        if (bind(m_iSockFD, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        return 0;\n    }\n\n    void run() {\n        if (m_iSockFD == -1 || m_bIsStarted) {\n            return;\n        }\n\n        m_bIsStarted = true;\n        m_bIsEnd = false;\n\n        struct pollfd fds[1];\n        fds[0].fd = m_iSockFD;\n        fds[0].events = POLLIN;\n\n        while (!m_bIsEnd) {\n            int ret = poll(fds, 1, 100); // 100ms timeout\n\n            if (ret > 0 && (fds[0].revents & POLLIN)) {\n                sockaddr_in senderAddr;\n                socklen_t addrLen = sizeof(senderAddr);\n                char buffer[MAX_BUFFER_SIZE];\n\n                ssize_t recvSize = recvfrom(m_iSockFD, buffer, MAX_BUFFER_SIZE, 0,\n                                            reinterpret_cast<sockaddr*>(&senderAddr), &addrLen);\n\n                if (recvSize > 0) {\n                    m_poDFNetWork->ProcessMessage(buffer, static_cast<int>(recvSize), senderAddr);\n                }\n            }\n        }\n\n        m_bIsStarted = false;\n    }\n};"
    ],
    "unmatched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork {\npublic:\n    void ProcessMessage(const char* data, int size, const std::string& ip, int port) {\n        // Handle the received message\n    }\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n\n    void run() {\n        struct pollfd fds[1];\n        fds[0].fd = m_iSockFD;\n        fds[0].events = POLLIN;\n\n        while (!m_bIsEnd) {\n            int ret = poll(fds, 1, 100); // 100ms timeout\n            if (ret > 0 && (fds[0].revents & POLLIN)) {\n                char buffer[65536];\n                sockaddr_in addr;\n                socklen_t addr_len = sizeof(addr);\n                ssize_t recv_len = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&addr, &addr_len);\n                if (recv_len > 0) {\n                    std::string ip(inet_ntoa(addr.sin_addr));\n                    int port = ntohs(addr.sin_port);\n                    m_poDFNetWork->ProcessMessage(buffer, recv_len, ip, port);\n                }\n            }\n        }\n        m_bIsStarted = false;\n    }\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork)\n        : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        Stop();\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        if (m_bIsStarted) {\n            m_bIsEnd = true;\n            if (m_thread.joinable()) {\n                m_thread.join();\n            }\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            return -1;\n        }\n\n        int flags = fcntl(m_iSockFD, F_GETFL, 0);\n        fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n        sockaddr_in server_addr;\n        std::memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_addr.s_addr = INADDR_ANY;\n        server_addr.sin_port = htons(iPort);\n\n        if (bind(m_iSockFD, (const struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_bIsEnd = false;\n        m_thread = std::thread(&UDPRecv::run, this);\n        m_bIsStarted = true;\n        return 0;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork {\npublic:\n    void ProcessMessage(const char* data, int size, const std::string& ip, int port) {\n        // Handle the received message\n    }\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n\n    void run() {\n        struct pollfd fds[1];\n        fds[0].fd = m_iSockFD;\n        fds[0].events = POLLIN;\n\n        while (!m_bIsEnd) {\n            int ret = ::poll(fds, 1, 100); // 100ms timeout\n            if (ret > 0) {\n                if (fds[0].revents & POLLIN) {\n                    char buffer[65536];\n                    sockaddr_in addr;\n                    socklen_t addr_len = sizeof(addr);\n                    ssize_t recv_len = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (sockaddr*)&addr, &addr_len);\n                    if (recv_len > 0) {\n                        std::string ip(inet_ntoa(addr.sin_addr));\n                        int port = ntohs(addr.sin_port);\n                        m_poDFNetWork->ProcessMessage(buffer, recv_len, ip, port);\n                    }\n                }\n            }\n        }\n\n        m_bIsStarted = false;\n    }\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork)\n        : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        Stop();\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        if (m_bIsStarted) {\n            m_bIsEnd = true;\n            if (m_thread.joinable()) {\n                m_thread.join();\n            }\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            return -1;\n        }\n\n        int flags = fcntl(m_iSockFD, F_GETFL, 0);\n        fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n        sockaddr_in addr;\n        std::memset(&addr, 0, sizeof(addr));\n        addr.sin_family = AF_INET;\n        addr.sin_port = htons(iPort);\n        addr.sin_addr.s_addr = INADDR_ANY;\n\n        if (bind(m_iSockFD, (const sockaddr*)&addr, sizeof(addr)) == -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_bIsEnd = false;\n        m_thread = std::thread(&UDPRecv::run, this);\n        m_bIsStarted = true;\n\n        return 0;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork {\npublic:\n    void ProcessMessage(const char* data, int size, const std::string& ip, int port) {\n        // Handle the received message\n    }\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n\n    void run() {\n        struct pollfd fds[1];\n        fds[0].fd = m_iSockFD;\n        fds[0].events = POLLIN;\n\n        while (!m_bIsEnd) {\n            int ret = ::poll(fds, 1, 100); // 100ms timeout\n            if (ret > 0) {\n                if (fds[0].revents & POLLIN) {\n                    char buffer[65536];\n                    sockaddr_in addr;\n                    socklen_t addr_len = sizeof(addr);\n                    ssize_t recv_len = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (sockaddr*)&addr, &addr_len);\n                    if (recv_len > 0) {\n                        std::string ip(inet_ntoa(addr.sin_addr));\n                        int port = ntohs(addr.sin_port);\n                        m_poDFNetWork->ProcessMessage(buffer, recv_len, ip, port);\n                    }\n                }\n            }\n        }\n\n        m_bIsStarted = false;\n    }\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork)\n        : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        Stop();\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        if (m_bIsStarted) {\n            m_bIsEnd = true;\n            if (m_thread.joinable()) {\n                m_thread.join();\n            }\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            return -1;\n        }\n\n        int flags = fcntl(m_iSockFD, F_GETFL, 0);\n        fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n        sockaddr_in server_addr;\n        std::memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_addr.s_addr = INADDR_ANY;\n        server_addr.sin_port = htons(iPort);\n\n        if (bind(m_iSockFD, (const sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_bIsEnd = false;\n        m_thread = std::thread(&UDPRecv::run, this);\n        m_bIsStarted = true;\n\n        return 0;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork {\npublic:\n    void ProcessMessage(const char* data, int size, const std::string& ip, int port) {\n        // Handle the received message\n    }\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n\n    void run() {\n        struct pollfd fds[1];\n        fds[0].fd = m_iSockFD;\n        fds[0].events = POLLIN;\n\n        while (!m_bIsEnd) {\n            int ret = ::poll(fds, 1, 100); // 100ms timeout\n            if (ret > 0) {\n                if (fds[0].revents & POLLIN) {\n                    char buffer[65536];\n                    sockaddr_in addr;\n                    socklen_t addr_len = sizeof(addr);\n                    ssize_t recv_len = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (sockaddr*)&addr, &addr_len);\n                    if (recv_len > 0) {\n                        std::string ip(inet_ntoa(addr.sin_addr));\n                        int port = ntohs(addr.sin_port);\n                        m_poDFNetWork->ProcessMessage(buffer, recv_len, ip, port);\n                    }\n                }\n            }\n        }\n\n        m_bIsStarted = false;\n    }\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork)\n        : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        Stop();\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        if (m_bIsStarted) {\n            m_bIsEnd = true;\n            if (m_thread.joinable()) {\n                m_thread.join();\n            }\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            return -1;\n        }\n\n        int flags = fcntl(m_iSockFD, F_GETFL, 0);\n        fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n        sockaddr_in addr;\n        std::memset(&addr, 0, sizeof(addr));\n        addr.sin_family = AF_INET;\n        addr.sin_port = htons(iPort);\n        addr.sin_addr.s_addr = INADDR_ANY;\n\n        if (bind(m_iSockFD, (const sockaddr*)&addr, sizeof(addr)) == -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_bIsEnd = false;\n        m_thread = std::thread(&UDPRecv::run, this);\n        m_bIsStarted = true;\n\n        return 0;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <thread>\n\nclass DFNetWork {\npublic:\n    void ProcessMessage(const char* data, int size, const std::string& ip, int port) {\n        // Handle the received message\n    }\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n\n    void run() {\n        struct pollfd fds[1];\n        fds[0].fd = m_iSockFD;\n        fds[0].events = POLLIN;\n\n        while (!m_bIsEnd) {\n            int ret = ::poll(fds, 1, 100); // 100ms timeout\n            if (ret > 0) {\n                if (fds[0].revents & POLLIN) {\n                    char buffer[65536];\n                    sockaddr_in addr;\n                    socklen_t addr_len = sizeof(addr);\n                    ssize_t recv_len = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0,\n                                                (struct sockaddr*)&addr, &addr_len);\n                    if (recv_len > 0) {\n                        std::string ip(inet_ntoa(addr.sin_addr));\n                        int port = ntohs(addr.sin_port);\n                        m_poDFNetWork->ProcessMessage(buffer, recv_len, ip, port);\n                    }\n                }\n            }\n        }\n\n        m_bIsStarted = false;\n    }\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork)\n        : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        Stop();\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n        }\n    }\n\n    void Stop() {\n        if (m_bIsStarted) {\n            m_bIsEnd = true;\n            if (m_thread.joinable()) {\n                m_thread.join();\n            }\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            return -1;\n        }\n\n        int opt = 1;\n        if (setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        // Set non-blocking\n        int flags = fcntl(m_iSockFD, F_GETFL, 0);\n        fcntl(m_iSockFD, F_SETFL, flags | O_NONBLOCK);\n\n        sockaddr_in addr;\n        memset(&addr, 0, sizeof(addr));\n        addr.sin_family = AF_INET;\n        addr.sin_addr.s_addr = INADDR_ANY;\n        addr.sin_port = htons(iPort);\n\n        if (bind(m_iSockFD, (const struct sockaddr*)&addr, sizeof(addr)) == -1) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_bIsEnd = false;\n        m_thread = std::thread(&UDPRecv::run, this);\n        m_bIsStarted = true;\n\n        return 0;\n    }\n};"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a UDP server class using Boost.Asio that asynchronously receives datagrams and sends responses.\n\nClass Description: The udp_server class implements a UDP server that listens for incoming datagrams on a specified port and responds with a daytime string. It uses Boost.Asio for asynchronous network operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received message\n- recv_buffer_: [std::array<char, 1>] - Buffer for receiving incoming datagrams\n\nMethods:\n- udp_server([boost::asio::io_context&] io_context) -> [void] - Constructor that initializes the UDP socket and starts listening\n- start_receive() -> [void] - Begins asynchronous reception of UDP datagrams\n- handle_receive([const boost::system::error_code&] error) -> [void] - Callback for handling received datagrams and sending responses\n- handle_send([std::shared_ptr<std::string>] message) -> [void] - Callback for handling completed send operations",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error));\n  }\n\n  void handle_receive(const boost::system::error_code& error)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/)\n  {\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n            socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message));\n        }\n\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <array>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_),\n            remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = boost::posix_time::to_simple_string(boost::posix_time::second_clock::local_time());\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n\n            socket_.async_send_to(\n                boost::asio::buffer(*shared_message),\n                remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message));\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed after sending\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n            message.pop_back(); // Remove trailing newline\n\n            std::shared_ptr<std::string> shared_msg = std::make_shared<std::string>(std::move(message));\n            socket_.async_send_to(boost::asio::buffer(*shared_msg), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_msg));\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed after sending\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_),\n            remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n\n            socket_.async_send_to(\n                boost::asio::buffer(*shared_message),\n                remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message));\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed after sending\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\nprivate:\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n            socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message));\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\nprivate:\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n\n            socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message));\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed after sending\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_),\n            remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n\n            socket_.async_send_to(\n                boost::asio::buffer(*shared_message),\n                remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message));\n        }\n\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed after sending\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <array>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = boost::posix_time::to_simple_string(boost::posix_time::second_clock::local_time());\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n\n            socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message));\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed after sending\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_),\n            remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n\n            socket_.async_send_to(\n                boost::asio::buffer(*shared_message),\n                remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message));\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed after sending\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\nprivate:\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n            socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                [this, shared_message](const boost::system::error_code&, std::size_t) {\n                    handle_send(shared_message);\n                });\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message) {\n        // No action needed; message is kept alive by the lambda until sent\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nClass Description: The `udp_server` class implements a UDP server that listens on a specified port (13 in this case) for incoming datagrams. When a datagram is received, it responds with the current daytime string. The class uses asynchronous operations for receiving and sending data.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received datagram\n- recv_buffer_: [std::array<char, 1>] - Buffer for storing received data\n\nMethods:\n- Constructor: [udp_server]([boost::asio::io_context& io_context]) -> [void] - Initializes the UDP socket and starts listening for incoming datagrams\n- start_receive: [start_receive]() -> [void] - Begins an asynchronous receive operation on the socket\n- handle_receive: [handle_receive]([const boost::system::error_code& error, std::size_t bytes_transferred]) -> [void] - Handles the completion of a receive operation and initiates a response\n- handle_send: [handle_send]([std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred]) -> [void] - Handles the completion of a send operation\n- make_daytime_string: [make_daytime_string]() -> [std::string] - Generates and returns the current daytime string",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\n\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error,\n          boost::asio::placeholders::bytes_transferred));\n  }\n\n  void handle_receive(const boost::system::error_code& error,\n      std::size_t /*bytes_transferred*/)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message,\n            boost::asio::placeholders::error,\n            boost::asio::placeholders::bytes_transferred));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/,\n      const boost::system::error_code& /*error*/,\n      std::size_t /*bytes_transferred*/)\n  {\n  }\n\n  std::string make_daytime_string()\n  {\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <iostream>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1, _2));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            boost::shared_array<char> buffer(new char[message.size()]);\n            std::memcpy(buffer.get(), message.c_str(), message.size());\n            socket_.async_send_to(\n                boost::asio::buffer(buffer, message.size()), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, _1, _2));\n        }\n    }\n\n    void handle_send(const boost::system::error_code& /*error*/, std::size_t /*bytes_transferred*/) {\n    }\n\n    std::string make_daytime_string() {\n        using namespace std;\n        time_t now = time(0);\n        return ctime(&now);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <iostream>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1, _2));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            std::shared_ptr<std::string> message_ptr = std::make_shared<std::string>(message);\n            socket_.async_send_to(\n                boost::asio::buffer(*message_ptr), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, message_ptr, _1, _2));\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/, const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (error) {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        }\n    }\n\n    std::string make_daytime_string() {\n        using namespace std; // For time_t, time and ctime;\n        time_t now = time(0);\n        return ctime(&now);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <iostream>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1, _2));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            boost::shared_array<char> send_buffer(new char[message.size()]);\n            std::memcpy(send_buffer.get(), message.c_str(), message.size());\n            socket_.async_send_to(\n                boost::asio::buffer(send_buffer, message.size()), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, _1, _2));\n        }\n    }\n\n    void handle_send(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (error) {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        }\n    }\n\n    std::string make_daytime_string() {\n        using namespace std; // For time_t, time and ctime;\n        time_t now = time(0);\n        return ctime(&now);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <iostream>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1, _2));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            boost::shared_array<char> send_buffer(new char[message.size()]);\n            std::memcpy(send_buffer.get(), message.c_str(), message.size());\n            socket_.async_send_to(\n                boost::asio::buffer(send_buffer, message.size()), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, _1, _2));\n        }\n    }\n\n    void handle_send(const boost::system::error_code& /*error*/, std::size_t /*bytes_transferred*/) {\n    }\n\n    std::string make_daytime_string() {\n        using namespace std; // For time_t, time and ctime;\n        time_t now = time(0);\n        return ctime(&now);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <iostream>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1, _2));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            boost::shared_array<char> send_buffer(new char[message.size()]);\n            std::memcpy(send_buffer.get(), message.c_str(), message.size());\n            socket_.async_send_to(\n                boost::asio::buffer(send_buffer, message.size()), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, _1, _2));\n        }\n    }\n\n    void handle_send(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (error) {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        }\n    }\n\n    std::string make_daytime_string() {\n        using namespace std; // For time_t, time and ctime;\n        time_t now = time(0);\n        return ctime(&now);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <iostream>\n#include <memory>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1, _2));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n            socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, shared_message, _1, _2));\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/, const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (error) {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        }\n    }\n\n    std::string make_daytime_string() {\n        using namespace std; // For time_t, time and ctime;\n        time_t now = time(0);\n        return ctime(&now);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\nclass udp_server {\n public:\n  explicit udp_server(boost::asio::io_context& io_context)\n      : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n    start_receive();\n  }\n\n private:\n  void start_receive() {\n    remote_endpoint_ = boost::asio::ip::udp::endpoint();\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n          handle_receive(ec, bytes_recvd);\n        });\n  }\n\n  void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n    if (!error) {\n      std::string message = make_daytime_string();\n      std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(std::move(message));\n      socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                            [shared_message, this](const boost::system::error_code& error, std::size_t) {\n                              handle_send(shared_message, error, 0);\n                            });\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/, const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n    // No action needed after sending\n  }\n\n  std::string make_daytime_string() {\n    using namespace std;  // For time_t, time and ctime;\n    time_t now = time(0);\n    return ctime(&now);\n  }\n\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::ip::udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\nprivate:\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                handle_receive(ec, bytes_recvd);\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(message);\n\n            socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                [this, shared_message](const boost::system::error_code& error, std::size_t bytes_sent) {\n                    handle_send(shared_message, error, bytes_sent);\n                });\n\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/, const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (error) {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        }\n    }\n\n    std::string make_daytime_string() {\n        using namespace std; // For time_t, time and ctime;\n        time_t now = time(0);\n        return ctime(&now);\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_array.hpp>\n#include <ctime>\n#include <iostream>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1, _2));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            boost::shared_array<char> send_buffer(new char[message.size()]);\n            std::memcpy(send_buffer.get(), message.c_str(), message.size());\n            socket_.async_send_to(\n                boost::asio::buffer(send_buffer, message.size()), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, _1, _2));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(const boost::system::error_code& /*error*/, std::size_t /*bytes_transferred*/) {\n    }\n\n    std::string make_daytime_string() {\n        using namespace std; // For time_t, time and ctime;\n        time_t now = time(0);\n        return ctime(&now);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)) {\n        start_receive();\n    }\n\nprivate:\n    void start_receive() {\n        remote_endpoint_ = boost::asio::ip::udp::endpoint();\n        recv_buffer_.fill('\\0');\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                handle_receive(error, bytes_transferred);\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t /*bytes_transferred*/) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            std::shared_ptr<std::string> shared_message = std::make_shared<std::string>(std::move(message));\n            socket_.async_send_to(boost::asio::buffer(*shared_message), remote_endpoint_,\n                [shared_message, this](const boost::system::error_code& error, std::size_t bytes_sent) {\n                    handle_send(shared_message, error, bytes_sent);\n                });\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/, const boost::system::error_code& error, std::size_t /*bytes_sent*/) {\n        if (error) {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        }\n    }\n\n    std::string make_daytime_string() {\n        using namespace std; // For time_t, time and ctime;\n        time_t now = time(nullptr);\n        return ctime(&now);\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests to a specified base URL.\n\nClass Description: The HTTPClient class provides a simple interface for making HTTP GET requests to a given base URL. It handles libcurl initialization, request configuration, execution, and cleanup, while providing a method to append endpoints to the base URL and make requests.\n\nAttributes:\nbaseURL: std::string - The base URL to which endpoints will be appended for HTTP requests\n\nMethods:\nmakeRequest: makeRequest(const std::string& endpoint) -> std::string - Makes an HTTP GET request to the base URL plus the specified endpoint, returning the response as a string\nwrite_to_string: write_to_string(void* ptr, size_t size, size_t count, void* stream) -> size_t - Static callback function for libcurl to write response data into a string",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <sstream>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string URL = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, URL.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_perform(curl);\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, 0, size*count);\n        return size*count;\n    }\n\n    std::string baseURL;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& url) : baseURL(url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& base_url) : baseURL(base_url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& url) : baseURL(url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& url) : baseURL(url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& base_url) : baseURL(base_url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& url) : baseURL(url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& url) : baseURL(url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& base_url) : baseURL(base_url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\npublic:\n    explicit HTTPClient(const std::string& base_url) : baseURL(base_url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\nprivate:\n    std::string baseURL;\n\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, 0, size * count);\n        return size * count;\n    }\n\npublic:\n    HTTPClient(const std::string& url) : baseURL(url) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string full_url = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, full_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that can asynchronously receive and send datagrams.\n\nClass Description: The `server` class represents a UDP server that listens on a specified port, receives incoming datagrams asynchronously, and sends responses back to the sender. It utilizes Boost.Asio for asynchronous I/O operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- sender_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last sender\n- max_length: [enum] - Maximum size of the receive buffer (1024 bytes)\n- data_: [char[max_length]] - Buffer for storing received data\n\nMethods:\n- server: [constructor](boost::asio::io_context& io_context, short port) -> void - Initializes the UDP socket and starts the receive operation\n- do_receive: [method]() -> void - Asynchronously receives data from clients and triggers do_send if data is received\n- do_send: [method](std::size_t length) -> void - Asynchronously sends the received data back to the sender",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n\nusing boost::asio::ip::udp;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, short port)\n    : socket_(io_context, udp::endpoint(udp::v4(), port))\n  {\n    do_receive();\n  }\n\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd)\n        {\n          if (!ec && bytes_recvd > 0)\n          {\n            do_send(bytes_recvd);\n          }\n          else\n          {\n            do_receive();\n          }\n        });\n  }\n\n  void do_send(std::size_t length)\n  {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length), sender_endpoint_,\n        [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/)\n        {\n          do_receive();\n        });\n  }\n\nprivate:\n  udp::socket socket_;\n  udp::endpoint sender_endpoint_;\n  enum { max_length = 1024 };\n  char data_[max_length];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec) {\n                    do_send(length);\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec) {\n                    do_send(length);\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec) {\n                    do_send(length);\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec) {\n                    do_send(length);\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    do_send(bytes_recvd);\n                } else {\n                    do_receive();\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec) {\n                    do_send(length);\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    do_send(bytes_recvd);\n                } else {\n                    do_receive();\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec && length > 0) {\n                    do_send(length);\n                } else {\n                    do_receive();\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    do_send(bytes_recvd);\n                } else {\n                    do_receive();\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n\nclass server {\npublic:\n    enum { max_length = 1024 };\n\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec) {\n                    do_send(length);\n                }\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    char data_[max_length];\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Implement a UDP server using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nFunction Description: The function `udp_server` creates a UDP server that listens on port 13 (daytime protocol port). When it receives any datagram from a client, it responds with the current time in string format. The server runs indefinitely until an exception occurs.\n\nInput: None\n\nOutput: None (The function runs indefinitely and sends responses to clients, but doesn't return any value)",
    "Canonical_solution": "#include <array>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n  using namespace std;\n  time_t now = time(0);\n  return ctime(&now);\n}\n\nvoid udp_server()\n{\n  try\n  {\n    boost::asio::io_context io_context;\n\n    udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n    for (;;)\n    {\n      std::array<char, 1> recv_buf;\n      udp::endpoint remote_endpoint;\n      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);\n\n      std::string message = make_daytime_string();\n\n      boost::system::error_code ignored_error;\n      socket.send_to(boost::asio::buffer(message),\n          remote_endpoint, 0, ignored_error);\n    }\n  }\n  catch (std::exception& e)\n  {\n    std::cerr << e.what() << std::endl;\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/array.hpp>\n#include <ctime>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n\n        for (;;) {\n            boost::array<char, 1> recv_buf;\n            boost::asio::ip::udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size) {\n                throw boost::system::system_error(error);\n            }\n\n            std::time_t now = std::time(0);\n            std::string message = std::ctime(&now);\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n}",
      "#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n}\n\nvoid udp_server()\n{\n    try\n    {\n        boost::asio::io_context io_context;\n\n        udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n        for (;;)\n        {\n            boost::array<char, 1> recv_buf;\n            udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size)\n                throw boost::system::system_error(error);\n\n            std::string message = make_daytime_string();\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << \"Exception in UDP server: \" << e.what() << \"\\n\";\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/array.hpp>\n#include <ctime>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n\n        for (;;) {\n            boost::array<char, 1> recv_buf;\n            boost::asio::ip::udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size) {\n                throw boost::system::system_error(error);\n            }\n\n            std::time_t now = std::time(nullptr);\n            std::string message = std::ctime(&now);\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception in UDP server: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/array.hpp>\n#include <ctime>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n\n        for (;;) {\n            boost::array<char, 1> recv_buf;\n            boost::asio::ip::udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size) {\n                throw boost::system::system_error(error);\n            }\n\n            std::time_t now = std::time(nullptr);\n            std::string time_str = std::ctime(&now);\n            time_str.pop_back(); // Remove trailing newline\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(time_str), remote_endpoint, 0, ignored_error);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception in UDP server: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n}\n\nvoid udp_server()\n{\n    try\n    {\n        boost::asio::io_context io_context;\n\n        udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n        for (;;)\n        {\n            boost::array<char, 1> recv_buf;\n            udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size)\n                throw boost::system::system_error(error);\n\n            std::string message = make_daytime_string();\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/array.hpp>\n#include <ctime>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n}\n\nvoid udp_server()\n{\n    try\n    {\n        boost::asio::io_context io_context;\n\n        udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n        for (;;)\n        {\n            boost::array<char, 1> recv_buf;\n            udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size)\n                throw boost::system::system_error(error);\n\n            std::string message = make_daytime_string();\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n}",
      "#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n}\n\nvoid udp_server()\n{\n    try\n    {\n        boost::asio::io_context io_context;\n\n        udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n        for (;;)\n        {\n            char recv_buffer[1];\n            udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size)\n                throw boost::system::system_error(error);\n\n            std::string message = make_daytime_string();\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << \"Exception in udp_server: \" << e.what() << \"\\n\";\n    }\n}",
      "#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n    using namespace std; // For time_t, time and ctime;\n    time_t now = time(0);\n    return ctime(&now);\n}\n\nvoid udp_server()\n{\n    try\n    {\n        boost::asio::io_context io_context;\n\n        udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n        for (;;)\n        {\n            boost::array<char, 1> recv_buf;\n            udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size)\n                throw boost::system::system_error(error);\n\n            std::string message = make_daytime_string();\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n}",
      "#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n}\n\nvoid udp_server()\n{\n    try\n    {\n        boost::asio::io_context io_context;\n\n        udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n        for (;;)\n        {\n            boost::array<char, 1> recv_buf;\n            udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size)\n                throw boost::system::system_error(error);\n\n            std::string message = make_daytime_string();\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << \"Exception in UDP server: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/array.hpp>\n#include <ctime>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n\n        for (;;) {\n            boost::array<char, 1> recv_buf;\n            boost::asio::ip::udp::endpoint remote_endpoint;\n            boost::system::error_code error;\n\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint, 0, error);\n\n            if (error && error != boost::asio::error::message_size) {\n                throw boost::system::system_error(error);\n            }\n\n            std::time_t now = std::time(0);\n            std::string message = std::ctime(&now);\n\n            boost::system::error_code ignored_error;\n            socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, ignored_error);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception in UDP server: \" << e.what() << std::endl;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a UDP multicast sender class using Boost.Asio that periodically sends messages to a specified multicast address.\n\nClass Description: The `sender` class encapsulates functionality for sending UDP multicast messages at regular intervals. It uses Boost.Asio for asynchronous network operations and timer management.\n\nAttributes:\n- endpoint_: [boost::asio::ip::udp::endpoint] - The multicast endpoint (address + port) to send messages to\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for sending messages\n- timer_: [boost::asio::steady_timer] - Timer used to schedule message sends\n- message_count_: [int] - Counter tracking the number of messages sent\n- message_: [std::string] - The current message content to be sent\n\nMethods:\n- sender([boost::asio::io_context&] io_context, [const boost::asio::ip::address&] multicast_address) -> [void] - Constructor that initializes the sender with IO context and multicast address\n- do_send() -> [void] - Asynchronously sends the current message to the multicast endpoint\n- do_timeout() -> [void] - Sets up a timer to schedule the next message send after a delay",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <string>\n#include <chrono>\n\nclass sender\n{\npublic:\n  sender(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& multicast_address)\n    : endpoint_(multicast_address, multicast_port),\n      socket_(io_context, endpoint_.protocol()),\n      timer_(io_context),\n      message_count_(0)\n  {\n    do_send();\n  }\n\nprivate:\n  void do_send()\n  {\n    std::ostringstream os;\n    os << \"Message \" << message_count_++;\n    message_ = os.str();\n\n    socket_.async_send_to(\n        boost::asio::buffer(message_), endpoint_,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && message_count_ < max_message_count)\n            do_timeout();\n        });\n  }\n\n  void do_timeout()\n  {\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(\n        [this](boost::system::error_code ec)\n        {\n          if (!ec)\n            do_send();\n        });\n  }\n\nprivate:\n  boost::asio::ip::udp::endpoint endpoint_;\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::steady_timer timer_;\n  int message_count_;\n  std::string message_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, udp::v4()),\n          timer_(io_context),\n          message_count_(0),\n          message_(\"Multicast message \" + std::to_string(message_count_)) {}\n\n    void do_send() {\n        socket_.async_send_to(\n            boost::asio::buffer(message_), endpoint_,\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_sent*/) {\n                if (!ec) {\n                    ++message_count_;\n                    message_ = \"Multicast message \" + std::to_string(message_count_);\n                    do_timeout();\n                }\n            });\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait(\n            [this](const boost::system::error_code& ec) {\n                if (!ec) {\n                    do_send();\n                }\n            });\n    }\n\nprivate:\n    using udp = boost::asio::ip::udp;\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, udp::v4()),\n          timer_(io_context),\n          message_count_(0),\n          message_(\"Multicast message \" + std::to_string(message_count_)) {}\n\nprivate:\n    void do_send() {\n        std::shared_ptr<std::string> message_ptr = std::make_shared<std::string>(message_);\n        socket_.async_send_to(boost::asio::buffer(*message_ptr), endpoint_,\n            [this, message_ptr](const boost::system::error_code&, std::size_t) {\n                do_timeout();\n            });\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait([this](const boost::system::error_code&) {\n            ++message_count_;\n            message_ = \"Multicast message \" + std::to_string(message_count_);\n            do_send();\n        });\n    }\n\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, boost::asio::ip::udp::v4()),\n          timer_(io_context),\n          message_count_(0),\n          message_(\"Multicast message \" + std::to_string(message_count_)) {}\n\n    void do_send() {\n        socket_.async_send_to(boost::asio::buffer(message_), endpoint_,\n            [this](const boost::system::error_code&, std::size_t) {\n                do_timeout();\n            });\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait([this](const boost::system::error_code&) {\n            ++message_count_;\n            message_ = \"Multicast message \" + std::to_string(message_count_);\n            do_send();\n        });\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, udp::v4()),\n          timer_(io_context),\n          message_count_(0),\n          message_(\"Multicast message \" + std::to_string(message_count_)) {}\n\nprivate:\n    void do_send() {\n        socket_.async_send_to(boost::asio::buffer(message_), endpoint_,\n            [this](const boost::system::error_code&, std::size_t) {});\n        ++message_count_;\n        message_ = \"Multicast message \" + std::to_string(message_count_);\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait([this](const boost::system::error_code&) { do_send(); });\n    }\n\n    using udp = boost::asio::ip::udp;\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <iostream>\n\nclass sender : public boost::enable_shared_from_this<sender> {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, udp::v4()),\n          timer_(io_context),\n          message_count_(0) {\n        do_timeout();\n    }\n\nprivate:\n    typedef boost::asio::ip::udp udp;\n\n    void do_send() {\n        message_ = \"Message #\" + std::to_string(message_count_++);\n        socket_.async_send_to(\n            boost::asio::buffer(message_), endpoint_,\n            boost::bind(&sender::handle_send, shared_from_this(), _1));\n    }\n\n    void handle_send(const boost::system::error_code&) {\n        // Continue sending next message\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait(\n            boost::bind(&sender::timeout_handler, shared_from_this(), _1));\n    }\n\n    void timeout_handler(const boost::system::error_code&) {\n        if (!timer_.expiry().has_value()) return; // Check if timer was canceled\n        do_send();\n    }\n\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <iostream>\n\nclass sender : public boost::enable_shared_from_this<sender> {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, udp::v4()),\n          timer_(io_context),\n          message_count_(0) {\n        do_timeout();\n    }\n\nprivate:\n    typedef boost::asio::ip::udp udp;\n\n    void do_send() {\n        message_ = \"Message #\" + std::to_string(message_count_++);\n        socket_.async_send_to(\n            boost::asio::buffer(message_), endpoint_,\n            boost::bind(&sender::handle_send, shared_from_this(), _1));\n    }\n\n    void handle_send(const boost::system::error_code&) {\n        // Continue sending next message\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait(\n            boost::bind(&sender::handle_timeout, shared_from_this(), _1));\n    }\n\n    void handle_timeout(const boost::system::error_code&) {\n        if (!socket_.is_open()) return;\n        do_send();\n    }\n\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, udp::v4()),\n          timer_(io_context),\n          message_count_(0),\n          message_(\"Multicast message \" + std::to_string(message_count_)) {}\n\nprivate:\n    void do_send() {\n        socket_.async_send_to(boost::asio::buffer(message_), endpoint_,\n            [this](const boost::system::error_code&, std::size_t) {});\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait([this](const boost::system::error_code&) {\n            ++message_count_;\n            message_ = \"Multicast message \" + std::to_string(message_count_);\n            do_send();\n            do_timeout();\n        });\n    }\n\n    using udp = boost::asio::ip::udp;\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <iostream>\n\nclass sender : public boost::enable_shared_from_this<sender> {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, udp::v4()),\n          timer_(io_context),\n          message_count_(0) {\n        do_timeout();\n    }\n\nprivate:\n    typedef boost::asio::ip::udp udp;\n\n    void do_send() {\n        std::ostringstream os;\n        os << \"Message #\" << ++message_count_;\n        message_ = os.str();\n\n        socket_.async_send_to(\n            boost::asio::buffer(message_), endpoint_,\n            boost::bind(&sender::handle_send, shared_from_this(), _1));\n    }\n\n    void handle_send(const boost::system::error_code&) {\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::posix_time::seconds(1));\n        timer_.async_wait(\n            boost::bind(&sender::handle_timeout, shared_from_this(), _1));\n    }\n\n    void handle_timeout(const boost::system::error_code&) {\n        if (!socket_.is_open()) return;\n        do_send();\n    }\n\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n#include <memory>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, boost::asio::ip::udp::v4()),\n          timer_(io_context),\n          message_count_(0),\n          message_(\"Multicast message \" + std::to_string(message_count_)) {}\n\n    void do_send() {\n        std::shared_ptr<std::string> message_ptr = std::make_shared<std::string>(message_);\n\n        socket_.async_send_to(boost::asio::buffer(*message_ptr), endpoint_,\n            [this, message_ptr](const boost::system::error_code&, std::size_t) {\n                do_timeout();\n            });\n    }\n\nprivate:\n    void do_timeout() {\n        ++message_count_;\n        message_ = \"Multicast message \" + std::to_string(message_count_);\n\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait([this](const boost::system::error_code&) {\n            do_send();\n        });\n    }\n\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 30001),\n          socket_(io_context, udp::v4()),\n          timer_(io_context),\n          message_count_(0),\n          message_(\"Multicast message \" + std::to_string(message_count_)) {}\n\nprivate:\n    void do_send() {\n        socket_.async_send_to(boost::asio::buffer(message_), endpoint_,\n            [this](const boost::system::error_code&, std::size_t) {});\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(std::chrono::seconds(1));\n        timer_.async_wait([this](const boost::system::error_code&) {\n            ++message_count_;\n            message_ = \"Multicast message \" + std::to_string(message_count_);\n            do_send();\n            do_timeout();\n        });\n    }\n\n    using udp = boost::asio::ip::udp;\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Implement a UDP echo server using Boost.Asio that listens on a specified port, receives incoming datagrams, and sends them back to the sender.\n\nFunction Description: The function creates a UDP socket bound to a specified port, then enters an infinite loop where it receives datagrams from clients and echoes them back to the sender. This demonstrates basic UDP communication using Boost.Asio.\n\nInput:\n- io_context: boost::asio::io_context& - Reference to an I/O execution context that manages asynchronous operations\n- port: unsigned short - The port number on which the server should listen for incoming UDP datagrams\n\nOutput: None (The function runs indefinitely in a loop, processing incoming datagrams)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\nenum { max_length = 1024 };\n\nvoid server(boost::asio::io_context& io_context, unsigned short port)\n{\n  udp::socket sock(io_context, udp::endpoint(udp::v4(), port));\n  for (;;)\n  {\n    char data[max_length];\n    udp::endpoint sender_endpoint;\n    size_t length = sock.receive_from(\n        boost::asio::buffer(data, max_length), sender_endpoint);\n    sock.send_to(boost::asio::buffer(data, length), sender_endpoint);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <array>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n\n        size_t len = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n        if (error && error != boost::asio::error::message_size)\n            break;\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), len), remote_endpoint, 0, error);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <array>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n\n        size_t len = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n        if (error && error != boost::asio::error::message_size)\n            break;\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), len), remote_endpoint, 0, error);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <array>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n        if (error && error != boost::asio::error::message_size)\n            break;\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), length), remote_endpoint, 0, error);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        boost::system::error_code error;\n\n        size_t len = socket.receive_from(boost::asio::buffer(recv_buffer), sender_endpoint, 0, error);\n\n        if (error) {\n            std::cerr << \"Error receiving data: \" << error.message() << std::endl;\n            continue;\n        }\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), len), sender_endpoint, 0, error);\n\n        if (error) {\n            std::cerr << \"Error sending data: \" << error.message() << std::endl;\n        }\n    }\n}",
      "#include <boost/asio.hpp>\n#include <array>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        boost::system::error_code error;\n\n        size_t len = socket.receive_from(boost::asio::buffer(recv_buffer), sender_endpoint, 0, error);\n\n        if (error && error != boost::asio::error::message_size) {\n            break;\n        }\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), len), sender_endpoint, 0, error);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        boost::system::error_code error;\n\n        size_t len = socket.receive_from(boost::asio::buffer(recv_buffer), sender_endpoint, 0, error);\n\n        if (error) {\n            std::cerr << \"Error receiving data: \" << error.message() << std::endl;\n            continue;\n        }\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), len), sender_endpoint, 0, error);\n\n        if (error) {\n            std::cerr << \"Error sending data: \" << error.message() << std::endl;\n        }\n    }\n}",
      "#include <boost/asio.hpp>\n#include <array>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n\n        size_t len = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n        if (error && error != boost::asio::error::message_size)\n            break;\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), len), remote_endpoint, 0, error);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <array>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n\n        size_t len = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n        if (error && error != boost::asio::error::message_size)\n            break;\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), len), remote_endpoint, 0, error);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <array>\n\nvoid run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        std::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n        if (error && error != boost::asio::error::message_size) {\n            break;\n        }\n\n        socket.send_to(boost::asio::buffer(recv_buffer.data(), length), remote_endpoint, 0, error);\n    }\n}"
    ],
    "unmatched_results": [
      "void run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        boost::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n\n        std::size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n        if (error == boost::asio::error::message_size) {\n            continue;\n        }\n\n        if (!error || error == boost::asio::error::message_size) {\n            socket.send_to(boost::asio::buffer(recv_buffer.data(), length), remote_endpoint, 0, error);\n        }\n    }\n}"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a UDP client communication function using Boost.Asio to send a message to a specified host and port, and receive a response.\n\nFunction Description: The function establishes a UDP client connection, sends a message to a specified server, and waits to receive a response. It uses Boost.Asio for asynchronous UDP operations.\n\nInput:\n- host: [std::string] - The hostname or IP address of the UDP server to connect to\n- port: [std::string] - The port number of the UDP server\n- message: [std::string] - The message to be sent to the server\n\nOutput: None (The function receives a reply from the server but doesn't return it. In a real implementation, you might want to return the reply or process it further.)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client_communication(const std::string& host, const std::string& port, const std::string& message)\n{\n    boost::asio::io_context io_context;\n    udp::socket s(io_context, udp::endpoint(udp::v4(), 0));\n    udp::resolver resolver(io_context);\n    udp::resolver::results_type endpoints = resolver.resolve(udp::v4(), host, port);\n\n    size_t request_length = message.length();\n    s.send_to(boost::asio::buffer(message, request_length), *endpoints.begin());\n\n    char reply[max_length];\n    udp::endpoint sender_endpoint;\n    size_t reply_length = s.receive_from(boost::asio::buffer(reply, max_length), sender_endpoint);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    // Optionally process the reply here\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}",
      "#include <boost/asio.hpp>\n#include <string>\n\nvoid communicate_udp(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, port).begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    socket.send_to(boost::asio::buffer(message), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    socket.receive_from(boost::asio::buffer(reply, 1024), sender_endpoint);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that handles incoming UDP packets, processes them, and sends replies back to clients. The server should run asynchronously in a separate thread and provide a callback mechanism for handling incoming requests.\n\nClass Description: UDPServer::Impl is an implementation class for a UDP server that listens for incoming packets, validates them, and forwards valid packets to a callback function. It also provides functionality to send replies back to clients.\n\nAttributes:\n- worker_thread: std::thread - Thread that runs the IO context for asynchronous operations\n- io_context: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket: boost::asio::ip::udp::socket - UDP socket for communication\n- request_buffer: std::array<u8, MAX_PACKET_SIZE> - Buffer for storing incoming UDP packets\n- remote_endpoint: boost::asio::ip::udp::endpoint - Stores the endpoint of the last received packet\n- new_request_callback: std::function<void(std::unique_ptr<Packet>)> - Callback function for handling new valid packets\n\nMethods:\n- Impl(std::function<void(std::unique_ptr<Packet>)>) -> None - Constructor that initializes the UDP socket and starts the receive loop\n- ~Impl() -> None - Destructor that stops the IO context and joins the worker thread\n- StartReceive() -> None - Starts an asynchronous receive operation on the UDP socket\n- HandleReceive(const boost::system::error_code&, std::size_t) -> None - Handles received data, validates packets, and triggers the callback for valid packets\n- SendReply(boost::asio::ip::udp::endpoint, Packet&) -> None - Sends a reply packet back to the specified endpoint",
    "Canonical_solution": "#include <thread>\n#include <boost/asio.hpp>\n#include <functional>\n#include <memory>\n#include <array>\n#include \"common/common_types.h\"\n#include \"common/logging/log.h\"\n#include \"core/rpc/packet.h\"\n\nnamespace Core::RPC {\n\nclass UDPServer::Impl {\npublic:\n    explicit Impl(std::function<void(std::unique_ptr<Packet>)> new_request_callback)\n        : socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 45987)),\n          new_request_callback(std::move(new_request_callback)) {\n\n        StartReceive();\n        worker_thread = std::thread([this] { io_context.run(); });\n    }\n\n    ~Impl() {\n        io_context.stop();\n        worker_thread.join();\n    }\n\nprivate:\n    void StartReceive() {\n        socket.async_receive_from(boost::asio::buffer(request_buffer), remote_endpoint,\n                                  [this](const boost::system::error_code& error, std::size_t size) {\n                                      HandleReceive(error, size);\n                                  });\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t size) {\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to receive data on UDP socket: {}\", error.message());\n        } else if (size >= MIN_PACKET_SIZE && size <= MAX_PACKET_SIZE) {\n            PacketHeader header;\n            std::memcpy(&header, request_buffer.data(), sizeof(header));\n            if ((size - MIN_PACKET_SIZE) == header.packet_size) {\n                u8* data = request_buffer.data() + MIN_PACKET_SIZE;\n                std::function<void(Packet&)> send_reply_callback =\n                    std::bind(&Impl::SendReply, this, remote_endpoint, std::placeholders::_1);\n                std::unique_ptr<Packet> new_packet =\n                    std::make_unique<Packet>(header, data, send_reply_callback);\n\n                new_request_callback(std::move(new_packet));\n            }\n        } else {\n            LOG_WARNING(RPC_Server, \"Received message with wrong size: {}\", size);\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply_packet) {\n        std::vector<u8> reply_buffer(MIN_PACKET_SIZE + reply_packet.GetPacketDataSize());\n        auto reply_header = reply_packet.GetHeader();\n\n        std::memcpy(reply_buffer.data(), &reply_header, sizeof(reply_header));\n        std::memcpy(reply_buffer.data() + (4 * sizeof(u32)), reply_packet.GetPacketData().data(),\n                    reply_packet.GetPacketDataSize());\n\n        boost::system::error_code error;\n        socket.send_to(boost::asio::buffer(reply_buffer), endpoint, 0, error);\n\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to send reply: {}\", error.message());\n        } else {\n            LOG_INFO(RPC_Server, \"Sent reply version({}) id=({}) type=({}) size=({})\",\n                     reply_packet.GetVersion(), reply_packet.GetId(), reply_packet.GetPacketType(),\n                     reply_packet.GetPacketDataSize());\n        }\n    }\n\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace Core::RPC",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1400;\n\nclass Packet {\n    // Assume Packet class definition with data and validation logic\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : io_context(), socket(io_context), new_request_callback(std::move(callback)), worker_thread([this]() { io_context.run(); }) {\n            socket.open(boost::asio::ip::udp::v4());\n            socket.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 12345));\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            remote_endpoint = boost::asio::ip::udp::endpoint();\n            socket.async_receive_from(boost::asio::buffer(request_buffer), remote_endpoint,\n                [this](const boost::system::error_code& ec, std::size_t bytes_recvd) {\n                    HandleReceive(ec, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                auto packet = std::make_unique<Packet>();\n                // Validate packet logic here\n                bool valid = true; // Placeholder for actual validation\n                if (valid) {\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            socket.send_to(boost::asio::buffer(/* packet data */), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1400;\n\nclass Packet {\n    // Assume Packet class is defined elsewhere with appropriate methods\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : io_context(), socket(io_context), new_request_callback(std::move(callback)) {\n            boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::udp::v4(), 12345); // Example port\n            socket.open(endpoint.protocol());\n            socket.bind(endpoint);\n            worker_thread = std::thread([this]() { io_context.run(); });\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            remote_endpoint = boost::asio::ip::udp::endpoint();\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer),\n                remote_endpoint,\n                [this](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                    HandleReceive(error, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& error, std::size_t bytes_recvd) {\n            if (!error && bytes_recvd > 0) {\n                auto packet = std::make_unique<Packet>();\n                // Assume validation logic here; for example, simple check:\n                if (bytes_recvd <= MAX_PACKET_SIZE) {\n                    // Populate packet with data from request_buffer\n                    if (new_request_callback) {\n                        new_request_callback(std::move(packet));\n                    }\n                }\n                StartReceive();\n            }\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            socket.send_to(boost::asio::buffer(/* packet data */, /* size */), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1400;\n\nclass Packet {\n    // Assume Packet class definition with data and validation logic\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : io_context(), socket(io_context), new_request_callback(std::move(callback)), worker_thread([this]() { io_context.run(); }) {\n            socket.open(boost::asio::ip::udp::v4());\n            socket.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 12345));\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            remote_endpoint = boost::asio::ip::udp::endpoint();\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer),\n                remote_endpoint,\n                [this](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                    HandleReceive(error, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& error, std::size_t bytes_recvd) {\n            if (!error && bytes_recvd > 0) {\n                // Validate packet logic here\n                auto packet = std::make_unique<Packet>();\n                // ... populate packet from request_buffer ...\n\n                // Trigger callback for valid packet\n                if (new_request_callback) {\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            socket.send_to(boost::asio::buffer(/* packet data */), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = uint8_t;\n\nclass Packet {\n    // Assume Packet class is defined elsewhere with appropriate methods\n};\n\nclass UDPServer {\nprivate:\n    class Impl {\n    public:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, 65536> request_buffer; // MAX_PACKET_SIZE assumed to be 65536\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : new_request_callback(std::move(callback)),\n              socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n            worker_thread = std::thread([this]() { io_context.run(); });\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer), remote_endpoint,\n                [this](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                    HandleReceive(error, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& error, std::size_t bytes_recvd) {\n            if (!error && bytes_recvd > 0) {\n                // Validate packet and construct Packet object\n                auto packet = std::make_unique<Packet>(); // Placeholder for actual parsing logic\n                if (packet) { // Assuming validation is done via constructor or conversion\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            // Convert Packet to buffer or serialize it\n            // For demonstration, assuming a method data() and size() exist in Packet\n            socket.async_send_to(\n                boost::asio::buffer(packet.data(), packet.size()), endpoint,\n                [](const boost::system::error_code&, std::size_t) {});\n        }\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1400;\n\nclass Packet {\n    // Assume Packet class definition with data, size, etc.\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : io_context(), socket(io_context), new_request_callback(std::move(callback)) {\n            boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::udp::v4(), 12345);\n            socket.open(endpoint.protocol());\n            socket.bind(endpoint);\n            worker_thread = std::thread([this]() { io_context.run(); });\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            remote_endpoint = boost::asio::ip::udp::endpoint();\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer),\n                remote_endpoint,\n                [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                    HandleReceive(error, bytes_transferred);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n            if (!ec && bytes_transferred > 0) {\n                auto packet = std::make_unique<Packet>();\n                // Assume proper copying into packet and validation logic\n                if (new_request_callback) {\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            // Assume packet has a data() and size() method\n            socket.send_to(boost::asio::buffer(packet.data(), packet.size()), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1400;\n\nclass Packet {\n    // Assume Packet class definition with data, size, etc.\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : io_context(), socket(io_context), new_request_callback(std::move(callback)) {\n            worker_thread = std::thread([this]() { io_context.run(); });\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            remote_endpoint = boost::asio::ip::udp::endpoint();\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer),\n                remote_endpoint,\n                [this](const boost::system::error_code& ec, std::size_t bytes_recvd) {\n                    HandleReceive(ec, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                auto packet = std::make_unique<Packet>();\n                // Assume proper copying into packet and validation logic\n                if (new_request_callback) {\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            socket.send_to(boost::asio::buffer(packet.data, packet.size), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1400;\n\nclass Packet {\n    // Assume Packet class definition with data and validation logic\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : io_context(), socket(io_context), new_request_callback(std::move(callback)), worker_thread([this]() { io_context.run(); }) {\n            socket.open(boost::asio::ip::udp::v4());\n            socket.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 12345));\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            remote_endpoint = boost::asio::ip::udp::endpoint();\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer),\n                remote_endpoint,\n                [this](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                    HandleReceive(error, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& error, std::size_t bytes_recvd) {\n            if (!error && bytes_recvd > 0) {\n                auto packet = std::make_unique<Packet>();\n                // Validate packet logic here\n                bool valid = true; // Placeholder for actual validation logic\n                if (valid) {\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            socket.send_to(boost::asio::buffer(/* packet data */), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1400;\n\nclass Packet {\n    // Assume Packet class definition with data and validation logic\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : io_context(), socket(io_context), new_request_callback(std::move(callback)), worker_thread([this]() { io_context.run(); }) {\n            socket.open(boost::asio::ip::udp::v4());\n            socket.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 12345));\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            remote_endpoint = boost::asio::ip::udp::endpoint();\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer),\n                remote_endpoint,\n                [this](const boost::system::error_code& ec, std::size_t bytes_recvd) {\n                    HandleReceive(ec, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                auto packet = std::make_unique<Packet>();\n                // Validate packet logic here\n                bool valid = true; // Replace with actual validation\n                if (valid) {\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            socket.send_to(boost::asio::buffer(/* packet data */), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1500;\n\nclass Packet {\n    // Assume Packet class definition with data and validation logic\n};\n\nclass UDPServer {\nprivate:\n    class Impl {\n    public:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)),\n              new_request_callback(std::move(callback)), worker_thread([this]() { io_context.run(); }) {\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer), remote_endpoint,\n                [this](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                    HandleReceive(error, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& error, std::size_t bytes_recvd) {\n            if (!error && bytes_recvd > 0) {\n                auto packet = std::make_unique<Packet>(); // Assume proper initialization from buffer\n                if (packet && new_request_callback) {\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            socket.send_to(boost::asio::buffer(/* packet data */), endpoint);\n        }\n    };\n};",
      "#include <boost/asio.hpp>\n#include <thread>\n#include <array>\n#include <functional>\n#include <memory>\n\nusing u8 = unsigned char;\nconstexpr size_t MAX_PACKET_SIZE = 1400;\n\nclass Packet {\n    // Assume Packet class definition with data and validation logic\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        explicit Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : io_context(), socket(io_context), new_request_callback(std::move(callback)),\n              worker_thread([this]() { io_context.run(); }) {\n            socket.open(boost::asio::ip::udp::v4());\n            socket.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 12345));\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            request_buffer.fill(0);\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer),\n                remote_endpoint,\n                [this](const boost::system::error_code& ec, std::size_t bytes_recvd) {\n                    HandleReceive(ec, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const boost::system::error_code& ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                auto packet = std::make_unique<Packet>();\n                // Assume some validation logic here\n                bool valid = true; // Replace with actual validation of packet data\n                if (valid) {\n                    new_request_callback(std::move(packet));\n                }\n            }\n            StartReceive();\n        }\n\n        void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n            socket.send_to(boost::asio::buffer(/* packet data */), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a UDP multicast receiver class using Boost.Asio that listens for incoming datagrams on a specified multicast address and port, and prints received messages to the console.\n\nClass Description: The `receiver` class encapsulates functionality for receiving UDP multicast messages. It initializes a UDP socket, joins a multicast group, and asynchronously receives datagrams, printing their contents to standard output.\n\nAttributes:\n- socket_: boost::asio::ip::udp::socket - The UDP socket used for communication\n- sender_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint of the sender of the last received message\n- data_: std::array<char, 1024> - Buffer for storing received data\n\nMethods:\n- receiver(boost::asio::io_context&, const boost::asio::ip::address&, const boost::asio::ip::address&) -> None - Constructor that initializes the socket, binds it to the listening address and port, joins the multicast group, and starts receiving\n- do_receive() -> None - Private method that asynchronously receives data and prints it to console, then continues listening for more data",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nconstexpr short multicast_port = 30001;\n\nclass receiver\n{\npublic:\n  receiver(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& listen_address,\n      const boost::asio::ip::address& multicast_address)\n    : socket_(io_context)\n  {\n    // Create the socket so that multiple may be bound to the same address.\n    boost::asio::ip::udp::endpoint listen_endpoint(\n        listen_address, multicast_port);\n    socket_.open(listen_endpoint.protocol());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(listen_endpoint);\n\n    // Join the multicast group.\n    socket_.set_option(\n        boost::asio::ip::multicast::join_group(multicast_address));\n\n    do_receive();\n  }\n\nprivate:\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::cout.write(data_.data(), length);\n            std::cout << std::endl;\n\n            do_receive();\n          }\n        });\n  }\n\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::ip::udp::endpoint sender_endpoint_;\n  std::array<char, 1024> data_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& multicast_address, const boost::asio::ip::address& listen_address)\n        : socket_(io, udp::endpoint(listen_address, multicast_address.to_v4().port())),\n          sender_endpoint_(),\n          data_()\n    {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.join_multicast_group(multicast_address.to_v4());\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                }\n                do_receive();\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& multicast_address, const boost::asio::ip::address& listen_address)\n        : socket_(io, udp::endpoint(listen_address, multicast_address.to_v4().port())),\n          sender_endpoint_(),\n          data_()\n    {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.bind(udp::endpoint(listen_address, multicast_address.to_v4().port()));\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address.to_v4()));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                }\n                do_receive();\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& multicast_address, const boost::asio::ip::address& listen_address)\n        : socket_(io, udp::endpoint(listen_address, multicast_address.to_v4().to_ulong() >> 16)) {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.bind(udp::endpoint(listen_address, multicast_address.to_v4().to_ulong() >> 16));\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec) {\n                    std::cout << \"Received: \" << std::string(data_.data(), length) << std::endl;\n                }\n                do_receive();\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& multicast_address, const boost::asio::ip::address& listen_address)\n        : socket_(io, udp::endpoint(listen_address, multicast_address.to_v4().port())),\n          sender_endpoint_(),\n          data_()\n    {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.join_group(multicast_address.to_v4());\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                }\n                do_receive();\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address)\n        : socket_(io, boost::asio::ip::udp::endpoint(listen_address, 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        socket_.bind(boost::asio::ip::udp::endpoint(listen_address, 0));\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                    do_receive();\n                }\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& multicast_address, const boost::asio::ip::address& listen_address)\n        : socket_(io, udp::endpoint(listen_address, multicast_address.to_v4().port())),\n          sender_endpoint_(),\n          data_()\n    {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.bind(udp::endpoint(listen_address, multicast_address.to_v4().port()));\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address.to_v4()));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                    do_receive();\n                }\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& multicast_address, const boost::asio::ip::address& listen_address)\n        : socket_(io, udp::endpoint(listen_address, multicast_address.to_v4().port())),\n          sender_endpoint_(),\n          data_()\n    {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.bind(udp::endpoint(listen_address, multicast_address.to_v4().port()));\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address.to_v4()));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                }\n                do_receive();\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& multicast_address, const boost::asio::ip::address& listen_address)\n        : socket_(io, udp::endpoint(listen_address, multicast_address.to_v4().port())),\n          sender_endpoint_(),\n          data_()\n    {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.bind(udp::endpoint(listen_address, multicast_address.to_v4().port()));\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address.to_v4()));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                    do_receive();\n                }\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address)\n        : socket_(io, udp::endpoint(listen_address, 0)) {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.bind(udp::endpoint(listen_address, 0));\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                }\n                do_receive();\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    using udp = boost::asio::ip::udp;\n\n    receiver(boost::asio::io_context& io, const boost::asio::ip::address& multicast_address, const boost::asio::ip::address& listen_address)\n        : socket_(io, udp::endpoint(listen_address, multicast_address.to_v4().port())),\n          sender_endpoint_(),\n          data_()\n    {\n        socket_.set_option(udp::socket::reuse_address(true));\n        socket_.bind(udp::endpoint(listen_address, multicast_address.to_v4().port()));\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address.to_v4()));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_.data(), bytes_recvd) << std::endl;\n                    do_receive();\n                }\n            });\n    }\n\n    udp::socket socket_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a UDP client function using Boost.Asio that sends a request to a UDP server and receives a response.\n\nFunction Description: The function establishes a UDP connection to a specified host, sends a minimal request packet, waits for a response, and prints the received data to standard output. It uses Boost.Asio for asynchronous UDP operations.\n\nInput: \n- host: std::string - The hostname or IP address of the UDP server to connect to\n\nOutput: \n- None (void function), but prints the received data to standard output\n\nNote: The function uses a fixed service name \"daytime\" (port 13) for demonstration purposes. In a real application, this would typically be configurable. The function handles both IPv4 and UDP protocol operations.",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client(const std::string& host)\n{\n    boost::asio::io_context io_context;\n\n    udp::resolver resolver(io_context);\n    udp::endpoint receiver_endpoint =\n      *resolver.resolve(udp::v4(), host, \"daytime\").begin();\n\n    udp::socket socket(io_context);\n    socket.open(udp::v4());\n\n    std::array<char, 1> send_buf  = {{ 0 }};\n    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n\n    std::array<char, 128> recv_buf;\n    udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(\n        boost::asio::buffer(recv_buf), sender_endpoint);\n\n    std::cout.write(recv_buf.data(), len);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n\n        boost::asio::ip::udp::resolver resolver(io_context);\n        boost::asio::ip::udp::resolver::results_type endpoints =\n            resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\");\n\n        boost::asio::ip::udp::socket socket(io_context);\n        socket.open(boost::asio::ip::udp::v4());\n\n        // Send an empty request packet\n        socket.send_to(boost::asio::null_buffers(), *endpoints.begin());\n\n        char recv_buf[1024];\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        size_t len = socket.receive_from(boost::asio::buffer(recv_buf), sender_endpoint);\n\n        std::cout.write(recv_buf, len);\n        std::cout << std::endl;\n    }\n    catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::resolver::results_type endpoints =\n        resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\");\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    // Send an empty request packet\n    socket.send_to(boost::asio::null_buffers(), *endpoints.begin());\n\n    char reply[128];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    std::cout.write(reply, len);\n    std::cout << std::endl;\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n\n        boost::asio::ip::udp::resolver resolver(io_context);\n        boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\").begin();\n\n        boost::asio::ip::udp::socket socket(io_context);\n        socket.open(boost::asio::ip::udp::v4());\n\n        // Send a minimal request packet (empty for daytime service)\n        socket.send_to(boost::asio::buffer(\"\"), endpoint);\n\n        char reply[128];\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n        std::cout.write(reply, len);\n        std::cout << std::endl;\n    }\n    catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\").begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    // Send an empty request packet\n    socket.send_to(boost::asio::buffer(\"\"), endpoint);\n\n    char reply[1024];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    std::cout.write(reply, len);\n    std::cout << std::endl;\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::resolver::results_type endpoints = resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\");\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    // Send an empty request packet\n    socket.send_to(boost::asio::null_buffers(), *endpoints.begin());\n\n    char reply[128];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    std::cout.write(reply, len);\n    std::cout << std::endl;\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::endpoint receiver_endpoint = *resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\").begin();\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    // Send minimal request packet\n    socket.send_to(boost::asio::buffer(\"\"), receiver_endpoint);\n\n    char reply[128];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    std::cout << std::string(reply, reply + len);\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::resolver::results_type endpoints =\n        resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\");\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    // Send an empty request\n    socket.send_to(boost::asio::null_buffers(), *endpoints.begin());\n\n    char reply[128];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    std::cout.write(reply, len);\n    std::cout << std::endl;\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::resolver::results_type endpoints = resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\");\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    // Send empty request packet\n    socket.send_to(boost::asio::null_buffers(), *endpoints.begin());\n\n    char reply[128];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    std::cout.write(reply, len);\n    std::cout << std::endl;\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::resolver::results_type endpoints =\n        resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\");\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    // Send an empty request packet\n    socket.send_to(boost::asio::null_buffers(), *endpoints.begin());\n\n    char reply[128];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    std::cout.write(reply, len);\n    std::cout << std::endl;\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::resolver resolver(io_context);\n    boost::asio::ip::udp::resolver::results_type endpoints = resolver.resolve(boost::asio::ip::udp::v4(), host, \"daytime\");\n\n    boost::asio::ip::udp::socket socket(io_context);\n    socket.open(boost::asio::ip::udp::v4());\n\n    // Send an empty request packet\n    socket.send_to(boost::asio::null_buffers(), *endpoints.begin());\n\n    char reply[128];\n    boost::asio::ip::udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(boost::asio::buffer(reply), sender_endpoint);\n\n    std::cout.write(reply, len);\n    std::cout << std::endl;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a UDP-based client-server communication system using Boost.Asio in C++ that demonstrates asynchronous sending and receiving of datagrams.\n\nClass Description: The `udp_communicator` class provides asynchronous UDP communication capabilities for both sending and receiving datagrams. It manages socket operations, IO context, and buffers for network communication.\n\nAttributes:\n- io_context_: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket_: boost::asio::ip::udp::socket - Represents the UDP socket for communication\n- receiver_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint information for receiving data\n- sender_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint information of the sender\n- receive_buffer_: std::array<char, 1024> - Buffer for storing received data\n- send_buffer_: std::string - Buffer for storing data to be sent\n\nMethods:\n- constructor(io_context, port) -> void - Initializes the UDP socket and binds it to the specified port\n- start_receive() -> void - Begins asynchronous reception of UDP datagrams\n- handle_receive(error_code, bytes_transferred) -> void - Callback for handling received data\n- send_to(message, endpoint) -> void - Asynchronously sends a message to the specified endpoint\n- handle_send(error_code, bytes_transferred) -> void - Callback for handling send completion\n- get_socket() -> boost::asio::ip::udp::socket& - Returns a reference to the UDP socket\n- get_io_context() -> boost::asio::io_context& - Returns a reference to the IO context",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <istream>\n#include <ostream>\n#include \"icmp_header.hpp\"\n#include \"ipv4_header.hpp\"\n\nusing boost::asio::ip::icmp;\nusing boost::asio::steady_timer;\nnamespace chrono = boost::asio::chrono;\n\nclass pinger\n{\npublic:\n  pinger(boost::asio::io_context& io_context, const char* destination)\n    : resolver_(io_context), socket_(io_context, icmp::v4()),\n      timer_(io_context), sequence_number_(0), num_replies_(0)\n  {\n    destination_ = *resolver_.resolve(icmp::v4(), destination, \"\").begin();\n\n    start_send();\n    start_receive();\n  }\n\nprivate:\n  void start_send()\n  {\n    std::string body(\"\\\"Hello!\\\" from Asio ping.\");\n\n    icmp_header echo_request;\n    echo_request.type(icmp_header::echo_request);\n    echo_request.code(0);\n    echo_request.identifier(get_identifier());\n    echo_request.sequence_number(++sequence_number_);\n    compute_checksum(echo_request, body.begin(), body.end());\n\n    boost::asio::streambuf request_buffer;\n    std::ostream os(&request_buffer);\n    os << echo_request << body;\n\n    time_sent_ = steady_timer::clock_type::now();\n    socket_.send_to(request_buffer.data(), destination_);\n\n    num_replies_ = 0;\n    timer_.expires_at(time_sent_ + chrono::seconds(5));\n    timer_.async_wait(std::bind(&pinger::handle_timeout, this));\n  }\n\n  void handle_timeout()\n  {\n    if (num_replies_ == 0)\n      std::cout << \"Request timed out\" << std::endl;\n\n    timer_.expires_at(time_sent_ + chrono::seconds(1));\n    timer_.async_wait(std::bind(&pinger::start_send, this));\n  }\n\n  void start_receive()\n  {\n    reply_buffer_.consume(reply_buffer_.size());\n\n    socket_.async_receive(reply_buffer_.prepare(65536),\n        std::bind(&pinger::handle_receive, this, std::placeholders::_2));\n  }\n\n  void handle_receive(std::size_t length)\n  {\n    reply_buffer_.commit(length);\n\n    std::istream is(&reply_buffer_);\n    ipv4_header ipv4_hdr;\n    icmp_header icmp_hdr;\n    is >> ipv4_hdr >> icmp_hdr;\n\n    if (is && icmp_hdr.type() == icmp_header::echo_reply\n          && icmp_hdr.identifier() == get_identifier()\n          && icmp_hdr.sequence_number() == sequence_number_)\n    {\n      if (num_replies_++ == 0)\n        timer_.cancel();\n\n      chrono::steady_clock::time_point now = chrono::steady_clock::now();\n      chrono::steady_clock::duration elapsed = now - time_sent_;\n      std::cout << length - ipv4_hdr.header_length()\n        << \" bytes from \" << ipv4_hdr.source_address()\n        << \": icmp_seq=\" << icmp_hdr.sequence_number()\n        << \", ttl=\" << ipv4_hdr.time_to_live()\n        << \", time=\"\n        << chrono::duration_cast<chrono::milliseconds>(elapsed).count()\n        << std::endl;\n    }\n\n    start_receive();\n  }\n\n  static unsigned short get_identifier()\n  {\n#if defined(BOOST_ASIO_WINDOWS)\n    return static_cast<unsigned short>(::GetCurrentProcessId());\n#else\n    return static_cast<unsigned short>(::getpid());\n#endif\n  }\n\n  icmp::resolver resolver_;\n  icmp::endpoint destination_;\n  icmp::socket socket_;\n  steady_timer timer_;\n  unsigned short sequence_number_;\n  chrono::steady_clock::time_point time_sent_;\n  boost::asio::streambuf reply_buffer_;\n  std::size_t num_replies_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_receive(ec, bytes_transferred);\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& error_code, std::size_t bytes_transferred) {\n        if (!error_code && bytes_transferred > 0) {\n            sender_endpoint_ = receiver_endpoint_;\n            receive_buffer_[bytes_transferred] = '\\0';\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_send(ec, bytes_transferred);\n            });\n    }\n\n    void handle_send(const boost::system::error_code& error_code, std::size_t bytes_transferred) {\n        if (error_code) {\n            // Handle error\n        }\n    }\n\n    boost::asio::ip::udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint receiver_endpoint_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_),\n            receiver_endpoint_,\n            [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                handle_receive(error, bytes_transferred);\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error) {\n            // Process received data here\n            start_receive();\n        }\n    }\n\n    void send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_),\n            endpoint,\n            [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                handle_send(error, bytes_transferred);\n            });\n    }\n\n    void handle_send(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        // Handle send completion\n    }\n\n    boost::asio::ip::udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint receiver_endpoint_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    using boost::asio::ip::udp;\n\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, udp::endpoint(udp::v4(), port)),\n          receiver_endpoint_(),\n          sender_endpoint_(),\n          receive_buffer_(),\n          send_buffer_() {}\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_receive(ec, bytes_transferred);\n            });\n    }\n\n    void handle_receive(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            // Process received data here\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_send(ec, bytes_transferred);\n            });\n    }\n\n    void handle_send(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec) {\n            // Send completed successfully\n        }\n    }\n\n    udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    udp::socket socket_;\n    udp::endpoint receiver_endpoint_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    using boost::asio::ip::udp;\n\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, udp::endpoint(udp::v4(), port)),\n          receiver_endpoint_(),\n          sender_endpoint_(),\n          receive_buffer_(),\n          send_buffer_() {}\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_receive(ec, bytes_transferred);\n            });\n    }\n\n    void handle_receive(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            // Process received data here\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_send(ec, bytes_transferred);\n            });\n    }\n\n    void handle_send(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec) {\n            // Send successful\n        }\n    }\n\n    udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    udp::socket socket_;\n    udp::endpoint receiver_endpoint_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nusing boost::asio::ip::udp;\nusing boost::system::error_code;\n\nclass udp_communicator {\npublic:\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, udp::endpoint(udp::v4(), port)),\n          receiver_endpoint_(),\n          sender_endpoint_(),\n          receive_buffer_(),\n          send_buffer_() {}\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](error_code ec, std::size_t bytes_transferred) {\n                handle_receive(ec, bytes_transferred);\n            });\n    }\n\n    void handle_receive(error_code ec, std::size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            std::string received_data(receive_buffer_.data(), bytes_transferred);\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](error_code ec, std::size_t bytes_transferred) {\n                handle_send(ec, bytes_transferred);\n            });\n    }\n\n    void handle_send(error_code ec, std::size_t bytes_transferred) {\n        if (ec) {\n        }\n    }\n\n    udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    udp::socket socket_;\n    udp::endpoint receiver_endpoint_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                handle_receive(error, bytes_transferred);\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error) {\n            // Process received data here\n            std::string received_data(receive_buffer_.data(), bytes_transferred);\n            // Echo back the received data\n            send_to(received_data, receiver_endpoint_);\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                handle_send(error, bytes_transferred);\n            });\n    }\n\n    void handle_send(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        // Handle send completion if needed\n    }\n\n    boost::asio::ip::udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint receiver_endpoint_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    using boost::asio::ip::udp;\n\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, udp::endpoint(udp::v4(), port)),\n          receiver_endpoint_(),\n          sender_endpoint_(),\n          receive_buffer_(),\n          send_buffer_() {}\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_receive(ec, bytes_transferred);\n            });\n    }\n\n    void handle_receive(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            // Process received data here\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_send(ec, bytes_transferred);\n            });\n    }\n\n    void handle_send(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec) {\n            // Send successful\n        }\n    }\n\n    udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    udp::socket socket_;\n    udp::endpoint receiver_endpoint_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nusing boost::asio::ip::udp;\nusing boost::system::error_code;\n\nclass udp_communicator {\npublic:\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, udp::endpoint(udp::v4(), port)),\n          receiver_endpoint_(),\n          sender_endpoint_(),\n          receive_buffer_(),\n          send_buffer_() {}\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](error_code ec, std::size_t bytes_transferred) {\n                handle_receive(ec, bytes_transferred);\n            });\n    }\n\n    void handle_receive(error_code ec, std::size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            // Process received data here\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](error_code ec, std::size_t bytes_transferred) {\n                handle_send(ec, bytes_transferred);\n            });\n    }\n\n    void handle_send(error_code ec, std::size_t bytes_transferred) {\n        if (!ec) {\n            // Send completed successfully\n        }\n    }\n\n    udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    udp::socket socket_;\n    udp::endpoint receiver_endpoint_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_receive(ec, bytes_transferred);\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& error_code, std::size_t bytes_transferred) {\n        if (!error_code && bytes_transferred > 0) {\n            sender_endpoint_ = receiver_endpoint_;\n            receive_buffer_[bytes_transferred] = '\\0';\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_send(ec, bytes_transferred);\n            });\n    }\n\n    void handle_send(const boost::system::error_code& error_code, std::size_t bytes_transferred) {\n        if (error_code) {\n            // Handle error\n        }\n    }\n\n    boost::asio::ip::udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint receiver_endpoint_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    using boost::asio::ip::udp;\n\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          socket_(io_context, udp::endpoint(udp::v4(), port)),\n          receiver_endpoint_(),\n          sender_endpoint_(),\n          receive_buffer_(),\n          send_buffer_() {}\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_receive(ec, bytes_transferred);\n            });\n    }\n\n    void handle_receive(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            // Process received data here\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                handle_send(ec, bytes_transferred);\n            });\n    }\n\n    void handle_send(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec) {\n            // Send successful\n        }\n    }\n\n    udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    udp::socket socket_;\n    udp::endpoint receiver_endpoint_;\n    udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Implement a server class that handles both TCP and UDP communications using Boost.Asio, managing client subscriptions and broadcasting data frames to subscribed clients.\n\nClass Description: The `server` class manages network communications using both TCP and UDP protocols. It accepts TCP connections for control messages, maintains a set of subscribed UDP endpoints, and periodically broadcasts data frames to all subscribed clients via UDP.\n\nAttributes:\n- acceptor_: [tcp::acceptor] - Handles incoming TCP connections\n- timer_: [boost::asio::steady_timer] - Manages periodic operations\n- udp_socket_: [udp::socket] - Handles UDP communications\n- next_frame_number_: [unsigned long] - Tracks the sequence number for frames\n- subscribers_: [std::set<udp::endpoint>] - Stores subscribed client endpoints\n\nMethods:\n- server([boost::asio::io_context&] io_context, [unsigned short] port) -> [void] - Constructor that initializes the server with IO context and port\n- handle_accept([const boost::system::error_code&] ec, [tcp_socket_ptr] socket) -> [void] - Handles new TCP connection acceptances\n- handle_control_request([const boost::system::error_code&] ec, [tcp_socket_ptr] socket, [control_request_ptr] request) -> [void] - Processes control requests from clients\n- handle_control_request_timer([tcp_socket_ptr] socket, [control_request_ptr] request, [timer_ptr] delay_timer) -> [void] - Handles delayed processing of control requests\n- handle_timer() -> [void] - Periodically broadcasts data frames to subscribed clients",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <set>\n#include <memory>\n#include \"protocol.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef std::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef std::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef std::shared_ptr<control_request> control_request_ptr;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, unsigned short port)\n    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n      timer_(io_context),\n      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n      next_frame_number_(1)\n  {\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\n  void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n  {\n    if (!ec)\n    {\n      control_request_ptr request(new control_request);\n      boost::asio::async_read(*socket, request->to_buffers(),\n          std::bind(&server::handle_control_request, this,\n            boost::asio::placeholders::error, socket, request));\n    }\n\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n  }\n\n  void handle_control_request(const boost::system::error_code& ec,\n      tcp_socket_ptr socket, control_request_ptr request)\n  {\n    if (!ec)\n    {\n      timer_ptr delay_timer(\n          new boost::asio::steady_timer(acceptor_.get_executor()));\n      delay_timer->expires_after(boost::asio::chrono::seconds(2));\n      delay_timer->async_wait(\n          std::bind(&server::handle_control_request_timer, this,\n            socket, request, delay_timer));\n    }\n  }\n\n  void handle_control_request_timer(tcp_socket_ptr socket,\n      control_request_ptr request, timer_ptr /*delay_timer*/)\n  {\n    boost::system::error_code ec;\n    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);\n    if (!ec)\n    {\n      if (unsigned short old_port = request->old_port())\n      {\n        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);\n        subscribers_.erase(old_endpoint);\n      }\n\n      if (unsigned short new_port = request->new_port())\n      {\n        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);\n        subscribers_.insert(new_endpoint);\n      }\n    }\n\n    boost::asio::async_read(*socket, request->to_buffers(),\n        std::bind(&server::handle_control_request, this,\n          boost::asio::placeholders::error, socket, request));\n  }\n\n  void handle_timer()\n  {\n    double x = next_frame_number_ * 0.2;\n    double y = std::sin(x);\n    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));\n    std::string payload;\n    for (int i = 0; i < frame::payload_size; ++i)\n      payload += (i == char_index ? '*' : '.');\n\n    frame f(next_frame_number_++, payload);\n\n    std::set<udp::endpoint>::iterator j;\n    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)\n    {\n      boost::system::error_code ec;\n      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);\n    }\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\nprivate:\n  tcp::acceptor acceptor_;\n  boost::asio::steady_timer timer_;\n  udp::socket udp_socket_;\n  unsigned long next_frame_number_;\n  std::set<udp::endpoint> subscribers_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing boost::asio::ip::address;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    using tcp_socket_ptr = boost::shared_ptr<tcp::socket>;\n    using control_request_ptr = boost::shared_ptr<std::vector<char>>;\n    using timer_ptr = boost::shared_ptr<boost::asio::steady_timer>;\n\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          timer_(io_context),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr socket(new tcp::socket(acceptor_.get_executor().context()));\n        acceptor_.async_accept(*socket, boost::bind(&server::handle_accept, this,\n            boost::asio::placeholders::error, socket));\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            control_request_ptr request(new std::vector<char>(1024));\n            socket->async_read_some(boost::asio::buffer(*request),\n                boost::bind(&server::handle_control_request, this, _1, socket, request));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n        if (ec) return;\n\n        std::string req(request->begin(), request->end());\n        if (req.find(\"SUBSCRIBE\") != std::string::npos) {\n            auto ep = socket->remote_endpoint();\n            udp::endpoint udp_ep(ep.address(), ep.port());\n            subscribers_.insert(udp_ep);\n        } else if (req.find(\"UNSUBSCRIBE\") != std::string::npos) {\n            auto ep = socket->remote_endpoint();\n            udp::endpoint udp_ep(ep.address(), ep.port());\n            subscribers_.erase(udp_ep);\n        }\n\n        timer_ptr delay_timer(new boost::asio::steady_timer(timer_.get_executor().context()));\n        delay_timer->expires_from_now(std::chrono::seconds(1));\n        delay_timer->async_wait(boost::bind(&server::handle_control_request_timer, this, socket, request, delay_timer));\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer) {\n        socket->shutdown(tcp::socket::shutdown_both);\n        socket->close();\n    }\n\n    void start_timer() {\n        timer_.expires_from_now(std::chrono::milliseconds(100));\n        timer_.async_wait(boost::bind(&server::handle_timer, this, _1));\n    }\n\n    void handle_timer() {\n        std::vector<char> frame_data(1024);\n        std::sprintf(frame_data.data(), \"FRAME:%lu\", next_frame_number_++);\n        \n        for (const auto& subscriber : subscribers_) {\n            udp_socket_.send_to(boost::asio::buffer(frame_data), subscriber);\n        }\n\n        start_timer();\n    }\n\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing boost::asio::ip::address;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    using tcp_socket_ptr = boost::shared_ptr<tcp::socket>;\n    using control_request_ptr = boost::shared_ptr<std::vector<char>>;\n    using timer_ptr = boost::shared_ptr<boost::asio::steady_timer>;\n\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr socket(new tcp::socket(io_context_));\n        acceptor_.async_accept(*socket,\n            boost::bind(&server::handle_accept, this,\n                _1, socket));\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            control_request_ptr request(new std::vector<char>(1024));\n            socket->async_read_some(boost::asio::buffer(*request),\n                boost::bind(&server::handle_control_request, this,\n                    _1, socket, request));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n        if (ec) return;\n\n        std::string req_data(request->begin(), request->end());\n        if (req_data.find(\"SUBSCRIBE\") != std::string::npos) {\n            auto ep = socket->remote_endpoint();\n            udp::resolver resolver(io_context_);\n            udp::endpoint subscriber_ep = *resolver.resolve(udp::v4(), ep.address().to_string(), std::to_string(ep.port())).begin();\n\n            subscribers_.insert(subscriber_ep);\n            boost::asio::write(*socket, boost::asio::buffer(\"SUBSCRIBED\\n\"));\n        } else if (req_data.find(\"UNSUBSCRIBE\") != std::string::npos) {\n            auto ep = socket->remote_endpoint();\n            udp::resolver resolver(io_context_);\n            udp::endpoint subscriber_ep = *resolver.resolve(udp::v4(), ep.address().to_string(), std::to_string(ep.port())).begin();\n\n            subscribers_.erase(subscriber_ep);\n            boost::asio::write(*socket, boost::asio::buffer(\"UNSUBSCRIBED\\n\"));\n        } else {\n            boost::asio::write(*socket, boost::asio::buffer(\"UNKNOWN_COMMAND\\n\"));\n        }\n\n        control_request_ptr new_request(new std::vector<char>(1024));\n        socket->async_read_some(boost::asio::buffer(*new_request),\n            boost::bind(&server::handle_control_request, this,\n                _1, socket, new_request));\n    }\n\n    void start_timer() {\n        timer_.reset(new boost::asio::steady_timer(io_context_));\n        timer_->expires_from_now(std::chrono::milliseconds(100));\n        timer_->async_wait(boost::bind(&server::handle_timer, this, _1));\n    }\n\n    void handle_timer() {\n        std::string frame_data = \"FRAME:\" + std::to_string(next_frame_number_++);\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.async_send_to(\n                boost::asio::buffer(frame_data),\n                endpoint,\n                [this](const boost::system::error_code&, std::size_t) {}\n            );\n        }\n        start_timer();\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::acceptor acceptor_;\n    udp::socket udp_socket_;\n    boost::shared_ptr<boost::asio::steady_timer> timer_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef boost::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<std::vector<boost::uint8_t>> buffer_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    explicit server(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            // Start reading control request from the new connection\n            buffer_ptr request_buffer(new std::vector<boost::uint8_t>(1024));\n            socket->async_read_some(boost::asio::buffer(*request_buffer),\n                boost::bind(&server::handle_control_request, shared_from_this(),\n                    _1, socket, request_buffer));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec,\n                                tcp_socket_ptr socket,\n                                buffer_ptr request) {\n        if (!ec) {\n            // Process control request (simplified logic for subscription)\n            std::string request_str(request->begin(), request->end());\n            if (request_str.find(\"SUBSCRIBE\") != std::string::npos) {\n                udp::endpoint client_endpoint = socket->remote_endpoint().address().to_v4().to_ulong(), 0);\n                client_endpoint.port(socket->remote_endpoint().port() + 1); // Assume UDP port is +1\n                subscribers_.insert(client_endpoint);\n            } else if (request_str.find(\"UNSUBSCRIBE\") != std::string::npos) {\n                udp::endpoint client_endpoint = socket->remote_endpoint().address().to_v4().to_ulong(), 0);\n                client_endpoint.port(socket->remote_endpoint().port() + 1);\n                subscribers_.erase(client_endpoint);\n            }\n\n            // Delayed handling of request with a timer\n            timer_ptr delay_timer(new boost::asio::steady_timer(io_context_));\n            delay_timer->expires_from_now(std::chrono::seconds(1));\n            delay_timer->async_wait(boost::bind(&server::handle_control_request_timer,\n                shared_from_this(), socket, request, delay_timer));\n        }\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket,\n                                     buffer_ptr request,\n                                     timer_ptr delay_timer) {\n        // Optional: Send acknowledgment or response back to client\n        std::string response = \"Request processed\";\n        boost::system::error_code ignored;\n        socket->write_some(boost::asio::buffer(response), ignored);\n    }\n\n    void handle_timer() {\n        // Prepare data frame\n        std::vector<boost::uint8_t> frame_data(sizeof(unsigned long));\n        std::memcpy(frame_data.data(), &next_frame_number_, sizeof(next_frame_number_));\n        next_frame_number_++;\n\n        // Broadcast to all subscribers\n        for (const auto& subscriber : subscribers_) {\n            udp_socket_.async_send_to(boost::asio::buffer(frame_data), subscriber,\n                [this](const boost::system::error_code&, std::size_t) {});\n        }\n\n        // Restart the timer\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr new_socket(new tcp::socket(io_context_));\n        acceptor_.async_accept(*new_socket,\n            boost::bind(&server::handle_accept, shared_from_this(), _1, new_socket));\n    }\n\n    void start_timer() {\n        timer_.reset(new boost::asio::steady_timer(io_context_));\n        timer_->expires_from_now(std::chrono::milliseconds(100)); // Every 100ms\n        timer_->async_wait(boost::bind(&server::handle_timer, shared_from_this()));\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::acceptor acceptor_;\n    udp::socket udp_socket_;\n    boost::asio::steady_timer timer_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing boost::asio::ip::address;\n\nclass server {\npublic:\n    using tcp_socket_ptr = boost::shared_ptr<tcp::socket>;\n    using control_request_ptr = boost::shared_ptr<std::vector<uint8_t>>;\n    using timer_ptr = boost::shared_ptr<boost::asio::steady_timer>;\n\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr socket(new tcp::socket(io_context_));\n        acceptor_.async_accept(*socket,\n            boost::bind(&server::handle_accept, this,\n                _1, socket));\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            control_request_ptr request(new std::vector<uint8_t>(1024));\n            socket->async_read_some(boost::asio::buffer(*request),\n                boost::bind(&server::handle_control_request, this,\n                    _1, socket, request));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n        if (ec) return;\n\n        std::string req_data(request->begin(), request->end());\n        std::istringstream iss(req_data);\n        std::string command;\n        std::getline(iss, command, ' ');\n\n        if (command == \"SUBSCRIBE\") {\n            std::string ip_str;\n            unsigned short udp_port;\n            std::getline(iss, ip_str, ' ');\n            iss >> udp_port;\n\n            udp::resolver resolver(io_context_);\n            udp::endpoint endpoint = *resolver.resolve(udp::v4(), ip_str, std::to_string(udp_port));\n\n            subscribers_.insert(endpoint);\n        } else if (command == \"UNSUBSCRIBE\") {\n            std::string ip_str;\n            unsigned short udp_port;\n            std::getline(iss, ip_str, ' ');\n            iss >> udp_port;\n\n            udp::resolver resolver(io_context_);\n            udp::endpoint endpoint = *resolver.resolve(udp::v4(), ip_str, std::to_string(udp_port));\n\n            subscribers_.erase(endpoint);\n        }\n\n        timer_ptr delay_timer(new boost::asio::steady_timer(io_context_));\n        delay_timer->expires_from_now(boost::posix_time::seconds(1));\n        delay_timer->async_wait(boost::bind(&server::handle_control_request_timer, this, socket, request, delay_timer));\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer) {\n        socket->async_read_some(boost::asio::buffer(*request),\n            boost::bind(&server::handle_control_request, this,\n                _1, socket, request));\n    }\n\n    void start_timer() {\n        timer_.reset(new boost::asio::steady_timer(io_context_));\n        timer_->expires_from_now(boost::posix_time::millisec(100));\n        timer_->async_wait(boost::bind(&server::handle_timer, this, _1));\n    }\n\n    void handle_timer() {\n        std::vector<uint8_t> frame_data(sizeof(unsigned long));\n        std::memcpy(frame_data.data(), &next_frame_number_, sizeof(next_frame_number_));\n        next_frame_number_++;\n\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.async_send_to(boost::asio::buffer(frame_data), endpoint,\n                [](const boost::system::error_code&, std::size_t) {});\n        }\n\n        start_timer();\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::acceptor acceptor_;\n    udp::socket udp_socket_;\n    boost::shared_ptr<boost::asio::steady_timer> timer_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    using tcp_socket_ptr = boost::shared_ptr<tcp::socket>;\n    using control_request_ptr = boost::shared_ptr<std::vector<uint8_t>>;\n    using timer_ptr = boost::shared_ptr<boost::asio::steady_timer>;\n\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          timer_(io_context),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr socket(new tcp::socket(acceptor_.get_executor().context()));\n        acceptor_.async_accept(*socket, boost::bind(&server::handle_accept, this,\n            boost::asio::placeholders::error, socket));\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            control_request_ptr request(new std::vector<uint8_t>(1024));\n            socket->async_read_some(boost::asio::buffer(*request),\n                boost::bind(&server::handle_control_request, this,\n                    boost::asio::placeholders::error, socket, request));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec,\n        tcp_socket_ptr socket, control_request_ptr request) {\n        if (!ec) {\n            // Process control message\n            char op = (*request)[0];\n            if (op == 0x01) { // Subscribe\n                udp::endpoint subscriber_endpoint;\n                std::memcpy(&subscriber_endpoint, &(*request)[1], sizeof(udp::endpoint));\n                subscribers_.insert(subscriber_endpoint);\n            } else if (op == 0x02) { // Unsubscribe\n                udp::endpoint subscriber_endpoint;\n                std::memcpy(&subscriber_endpoint, &(*request)[1], sizeof(udp::endpoint));\n                subscribers_.erase(subscriber_endpoint);\n            }\n\n            // Delayed response\n            timer_ptr delay_timer(new boost::asio::steady_timer(timer_.get_executor().context()));\n            delay_timer->expires_from_now(std::chrono::milliseconds(100));\n            delay_timer->async_wait(boost::bind(&server::handle_control_request_timer, this,\n                socket, request, delay_timer));\n        }\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket,\n        control_request_ptr request, timer_ptr delay_timer) {\n        std::vector<uint8_t> response = {0x0A}; // Acknowledge\n        boost::system::error_code ignored_ec;\n        socket->write_some(boost::asio::buffer(response), ignored_ec);\n    }\n\n    void start_timer() {\n        timer_.expires_from_now(std::chrono::milliseconds(1000 / 30)); // 30 FPS\n        timer_.async_wait(boost::bind(&server::handle_timer, this,\n            boost::asio::placeholders::error));\n    }\n\n    void handle_timer() {\n        std::vector<uint8_t> frame_data = generate_frame_data();\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.send_to(boost::asio::buffer(frame_data), endpoint);\n        }\n        start_timer();\n    }\n\n    std::vector<uint8_t> generate_frame_data() {\n        std::vector<uint8_t> data(1400); // Simulated frame data\n        std::memcpy(data.data(), &next_frame_number_, sizeof(next_frame_number_));\n        ++next_frame_number_;\n        return data;\n    }\n\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\n\nclass server {\npublic:\n    using tcp_socket_ptr = boost::shared_ptr<tcp::socket>;\n    using control_request_ptr = boost::shared_ptr<std::vector<char>>;\n    using timer_ptr = boost::shared_ptr<boost::asio::steady_timer>;\n\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          timer_(io_context),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr socket(new tcp::socket(acceptor_.get_executor().context()));\n        acceptor_.async_accept(*socket, boost::bind(&server::handle_accept, this, _1, socket));\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            control_request_ptr request(new std::vector<char>(1024));\n            socket->async_read_some(boost::asio::buffer(*request),\n                boost::bind(&server::handle_control_request, this, _1, socket, request));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n        if (!ec) {\n            std::string req_data(request->begin(), request->end());\n            if (req_data.find(\"subscribe\") != std::string::npos) {\n                udp::endpoint client_endpoint = socket->remote_endpoint();\n                auto [it, inserted] = subscribers_.insert(client_endpoint);\n                if (inserted) {\n                    std::string response = \"Subscribed successfully\";\n                    boost::asio::write(*socket, boost::asio::buffer(response));\n                } else {\n                    std::string response = \"Already subscribed\";\n                    boost::asio::write(*socket, boost::asio::buffer(response));\n                }\n            } else if (req_data.find(\"unsubscribe\") != std::string::npos) {\n                udp::endpoint client_endpoint = socket->remote_endpoint();\n                subscribers_.erase(client_endpoint);\n                std::string response = \"Unsubscribed\";\n                boost::asio::write(*socket, boost::asio::buffer(response));\n            } else {\n                std::string response = \"Unknown command\";\n                boost::asio::write(*socket, boost::asio::buffer(response));\n            }\n\n            timer_ptr delay_timer(new boost::asio::steady_timer(socket->get_executor().context()));\n            delay_timer->expires_from_now(std::chrono::seconds(1));\n            delay_timer->async_wait(boost::bind(&server::handle_control_request_timer, this, socket, request, delay_timer));\n        }\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer) {\n        socket->async_read_some(boost::asio::buffer(*request),\n            boost::bind(&server::handle_control_request, this, _1, socket, request));\n    }\n\n    void start_timer() {\n        timer_.expires_from_now(std::chrono::milliseconds(100));\n        timer_.async_wait(boost::bind(&server::handle_timer, this, _1));\n    }\n\n    void handle_timer() {\n        std::string frame_data = \"Frame #\" + std::to_string(next_frame_number_++);\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.send_to(boost::asio::buffer(frame_data), endpoint);\n        }\n        start_timer();\n    }\n\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef boost::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<std::vector<boost::uint8_t>> buffer_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    explicit server(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            boost::shared_ptr<std::vector<boost::uint8_t>> request_buffer(new std::vector<boost::uint8_t>(1024));\n            socket->async_read_some(boost::asio::buffer(*request_buffer),\n                boost::bind(&server::handle_control_request, shared_from_this(),\n                    _1, socket, request_buffer));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec,\n        tcp_socket_ptr socket, buffer_ptr request) {\n        if (!ec) {\n            std::string req_str(request->begin(), request->end());\n            std::istringstream iss(req_str);\n            std::string command;\n            std::getline(iss, command, ' ');\n\n            if (command == \"SUBSCRIBE\") {\n                udp_endpoint_ptr endpoint(new udp::endpoint());\n                std::string ip;\n                unsigned short port;\n                iss >> ip >> port;\n                endpoint->address(boost::asio::ip::address::from_string(ip));\n                endpoint->port(port);\n\n                {\n                    boost::unique_lock<boost::mutex> lock(subscribers_mutex_);\n                    subscribers_.insert(*endpoint);\n                }\n\n                std::string response = \"SUBACK\\n\";\n                boost::asio::write(*socket, boost::asio::buffer(response));\n            } else if (command == \"UNSUBSCRIBE\") {\n                udp_endpoint_ptr endpoint(new udp::endpoint());\n                std::string ip;\n                unsigned short port;\n                iss >> ip >> port;\n                endpoint->address(boost::asio::ip::address::from_string(ip));\n                endpoint->port(port);\n\n                {\n                    boost::unique_lock<boost::mutex> lock(subscribers_mutex_);\n                    subscribers_.erase(*endpoint);\n                }\n\n                std::string response = \"UNSUBACK\\n\";\n                boost::asio::write(*socket, boost::asio::buffer(response));\n            }\n        }\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket, buffer_ptr request, timer_ptr delay_timer) {\n        delay_timer->wait();\n        handle_control_request(boost::system::error_code(), socket, request);\n    }\n\n    void handle_timer() {\n        buffer_ptr frame(new std::vector<boost::uint8_t>(1024));\n        std::ostringstream oss;\n        oss << \"FRAME \" << next_frame_number_++ << \" \";\n        std::fill(frame->begin(), frame->end(), 0);\n        std::copy(oss.str().begin(), oss.str().end(), frame->begin());\n\n        boost::unique_lock<boost::mutex> lock(subscribers_mutex_);\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.async_send_to(boost::asio::buffer(*frame), endpoint,\n                [](const boost::system::error_code&, std::size_t) {});\n        }\n\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr new_socket(new tcp::socket(io_context_));\n        acceptor_.async_accept(*new_socket,\n            boost::bind(&server::handle_accept, shared_from_this(),\n                _1, new_socket));\n    }\n\n    void start_timer() {\n        timer_.reset(new boost::asio::steady_timer(io_context_));\n        timer_->expires_from_now(std::chrono::milliseconds(100));\n        timer_->async_wait(boost::bind(&server::handle_timer, shared_from_this(), _1));\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::acceptor acceptor_;\n    udp::socket udp_socket_;\n    boost::shared_ptr<boost::asio::steady_timer> timer_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n    boost::mutex subscribers_mutex_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef boost::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<std::vector<boost::uint8_t>> buffer_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    explicit server(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            // Start reading control request from the new connection\n            buffer_ptr request_buffer(new std::vector<boost::uint8_t>(1024));\n            socket->async_read_some(boost::asio::buffer(*request_buffer),\n                boost::bind(&server::handle_control_request, shared_from_this(),\n                    _1, socket, request_buffer));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec,\n                                tcp_socket_ptr socket,\n                                buffer_ptr request) {\n        if (!ec) {\n            // Process control request (simplified for example)\n            std::string request_str(request->begin(), request->end());\n            if (request_str.find(\"SUBSCRIBE\") != std::string::npos) {\n                // Schedule delayed processing to simulate async operation\n                timer_ptr delay_timer(new boost::asio::steady_timer(io_context_));\n                delay_timer->expires_from_now(std::chrono::seconds(1));\n                delay_timer->async_wait(boost::bind(&server::handle_control_request_timer,\n                    shared_from_this(), socket, request, delay_timer));\n            }\n        }\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket,\n                                     buffer_ptr request,\n                                     timer_ptr delay_timer) {\n        // Simulate response after delay\n        std::string response = \"ACK\";\n        boost::system::error_code ignored_ec;\n        socket->write_some(boost::asio::buffer(response), ignored_ec);\n    }\n\n    void handle_timer() {\n        // Broadcast frame to all subscribers\n        buffer_ptr frame_data(new std::vector<boost::uint8_t>(1024, 0));\n        // Fill frame data with something meaningful\n        frame_data->at(0) = static_cast<boost::uint8_t>((next_frame_number_ >> 24) & 0xFF);\n        frame_data->at(1) = static_cast<boost::uint8_t>((next_frame_number_ >> 16) & 0xFF);\n        frame_data->at(2) = static_cast<boost::uint8_t>((next_frame_number_ >> 8) & 0xFF);\n        frame_data->at(3) = static_cast<boost::uint8_t>(next_frame_number_ & 0xFF);\n\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.async_send_to(boost::asio::buffer(*frame_data), *endpoint,\n                [](const boost::system::error_code&, std::size_t) {});\n        }\n\n        ++next_frame_number_;\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr socket(new tcp::socket(io_context_));\n        acceptor_.async_accept(*socket,\n            boost::bind(&server::handle_accept, shared_from_this(), _1, socket));\n    }\n\n    void start_timer() {\n        timer_.reset(new boost::asio::steady_timer(io_context_));\n        timer_->expires_from_now(std::chrono::milliseconds(100));\n        timer_->async_wait(boost::bind(&server::handle_timer, shared_from_this()));\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::acceptor acceptor_;\n    udp::socket udp_socket_;\n    boost::shared_ptr<boost::asio::steady_timer> timer_;\n    unsigned long next_frame_number_;\n    std::set<udp_endpoint_ptr> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing boost::asio::ip::address;\n\nclass server {\npublic:\n    using tcp_socket_ptr = boost::shared_ptr<tcp::socket>;\n    using udp_endpoint_ptr = boost::shared_ptr<udp::endpoint>;\n    using control_request_ptr = boost::shared_ptr<std::vector<uint8_t>>;\n    using timer_ptr = boost::shared_ptr<boost::asio::steady_timer>;\n\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          timer_(io_context),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr socket(new tcp::socket(acceptor_.get_executor().context()));\n        acceptor_.async_accept(*socket, boost::bind(&server::handle_accept, this,\n            boost::asio::placeholders::error, socket));\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            control_request_ptr request(new std::vector<uint8_t>(1024));\n            socket->async_read_some(boost::asio::buffer(*request),\n                boost::bind(&server::handle_control_request, this,\n                    boost::asio::placeholders::error, socket, request));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec,\n                               tcp_socket_ptr socket, control_request_ptr request) {\n        if (!ec) {\n            std::string req_data(request->begin(), request->end());\n            if (req_data.find(\"SUBSCRIBE\") != std::string::npos) {\n                udp::endpoint client_endpoint = socket->remote_endpoint().address().to_v4(),\n                              udp::endpoint(udp::v4(), 5001); // Assuming fixed UDP port for clients\n                subscribers_.insert(client_endpoint);\n                std::string response = \"SUBSCRIBED\";\n                boost::asio::write(*socket, boost::asio::buffer(response));\n            } else if (req_data.find(\"UNSUBSCRIBE\") != std::string::npos) {\n                udp::endpoint client_endpoint = socket->remote_endpoint().address().to_v4(),\n                              udp::endpoint(udp::v4(), 5001);\n                subscribers_.erase(client_endpoint);\n                std::string response = \"UNSUBSCRIBED\";\n                boost::asio::write(*socket, boost::asio::buffer(response));\n            }\n        }\n    }\n\n    void start_timer() {\n        timer_.expires_from_now(std::chrono::milliseconds(100));\n        timer_.async_wait(boost::bind(&server::handle_timer, this,\n            boost::asio::placeholders::error));\n    }\n\n    void handle_timer() {\n        std::vector<uint8_t> frame_data(sizeof(unsigned long), 0);\n        *reinterpret_cast<unsigned long*>(frame_data.data()) = next_frame_number_++;\n\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.send_to(boost::asio::buffer(frame_data), endpoint);\n        }\n\n        start_timer();\n    }\n\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef boost::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<std::vector<boost::uint8_t>> buffer_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    explicit server(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), port)),\n          next_frame_number_(0) {\n        start_accept();\n        start_timer();\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            // Start reading control request from the new connection\n            buffer_ptr request_buffer(new std::vector<boost::uint8_t>(1024));\n            socket->async_read_some(boost::asio::buffer(*request_buffer),\n                boost::bind(&server::handle_control_request, shared_from_this(),\n                    _1, socket, request_buffer));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec,\n                                tcp_socket_ptr socket,\n                                buffer_ptr request) {\n        if (!ec) {\n            // Process control request (simplified logic for subscription)\n            std::string req_data(request->begin(), request->end());\n            if (req_data.find(\"SUBSCRIBE\") != std::string::npos) {\n                udp_endpoint_ptr endpoint(new udp::endpoint);\n                // Assume client sends its UDP endpoint information in request\n                // Parse and store in endpoint variable\n\n                boost::system::error_code ignored_ec;\n                socket->remote_endpoint(ignored_ec);\n                if (ignored_ec) return;\n\n                *endpoint = udp::endpoint(socket->remote_endpoint().address(), 5000); // example port\n                subscribers_.insert(*endpoint);\n            } else if (req_data.find(\"UNSUBSCRIBE\") != std::string::npos) {\n                udp_endpoint_ptr endpoint(new udp::endpoint);\n                // Similar parsing as above\n                subscribers_.erase(*endpoint);\n            }\n\n            // Set up a timer to handle delayed processing or timeout\n            timer_ptr delay_timer(new boost::asio::steady_timer(io_context_));\n            delay_timer->expires_from_now(boost::posix_time::seconds(1));\n            delay_timer->async_wait(boost::bind(&server::handle_control_request_timer,\n                                               shared_from_this(), socket, request, delay_timer));\n        }\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket,\n                                     buffer_ptr request,\n                                     timer_ptr delay_timer) {\n        // Handle any post-processing after delay\n        // Could send acknowledgment or close connection\n        boost::system::error_code ignored_ec;\n        socket->shutdown(tcp::socket::shutdown_both, ignored_ec);\n    }\n\n    void handle_timer() {\n        // Prepare data frame\n        std::vector<boost::uint8_t> frame_data;\n        // Fill with actual data including next_frame_number_\n        frame_data.push_back(next_frame_number_ >> 24);\n        frame_data.push_back((frame_number >> 16) & 0xFF);\n        frame_data.push_back((frame_number >> 8) & 0xFF);\n        frame_data.push_back(frame_number_++ & 0xFF);\n\n        // Broadcast to all subscribers\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.async_send_to(boost::asio::buffer(frame_data), endpoint,\n                [this](const boost::system::error_code&, std::size_t) {});\n        }\n\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp_socket_ptr new_socket(new tcp::socket(io_context_));\n        acceptor_.async_accept(*new_socket,\n            boost::bind(&server::handle_accept, shared_from_this(), _1, new_socket));\n    }\n\n    void start_timer() {\n        timer_.reset(new boost::asio::steady_timer(io_context_));\n        timer_->expires_from_now(boost::posix_time::millisec(100)); // 10 Hz\n        timer_->async_wait(boost::bind(&server::handle_timer, shared_from_this(), _1));\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::acceptor acceptor_;\n    udp::socket udp_socket_;\n    boost::shared_ptr<boost::asio::steady_timer> timer_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Implement a class for handling HTTP file downloads using libcurl in C++. The class should support URL downloading with retries, temporary file handling, and proper resource management.\n\nClass Description: The DownloadTask class provides functionality to download files from HTTP URLs using libcurl. It handles initialization/cleanup of libcurl, manages download retries, writes data to temporary files, and performs final file operations upon successful download.\n\nAttributes:\n- m_url: [std::string] - Primary URL for file download\n- m_urlBackup: [std::string] - Backup URL if primary fails\n- m_output: [std::string] - Final output file path\n- m_outputTmp: [std::string] - Temporary file path during download\n- m_default: [std::string] - Default file path if download fails\n- m_mtime: [time_t] - Modification time to set on downloaded file\n- m_retries: [unsigned int] - Number of download attempts made\n- m_name: [std::string] - Name identifier for the download task\n- m_userAgent: [std::string] - User agent string for HTTP requests\n- m_error: [std::string] - Last error message encountered\n\nMethods:\n- initialize(): [static void]() -> void - Initializes libcurl global state\n- uninitialize(): [static void]() -> void - Cleans up libcurl global state\n- DownloadTask(): [constructor](const std::string&, const std::string&, const std::string&, time_t, const std::string&) -> DownloadTask - Constructs a download task with URL, output path, default file, modification time, and optional name\n- run(): [bool]() -> bool - Executes the download task and returns success status\n- getRetries(): [unsigned int]() -> unsigned int - Returns number of retry attempts\n- writeData(): [size_t](void*, size_t, size_t) -> size_t - Callback for writing received data\n- downloadFile(): [bool](const std::string&) -> bool - Internal method to perform the actual file download",
    "Canonical_solution": "#include <curl/curl.h>\n#include <vector>\n#include <string>\n#include <utility>\n\nclass DownloadTask\n{\npublic:\n    DownloadTask(const std::string &url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\");\n    \n    static void initialize();\n    static void uninitialize();\n    \n    bool run();\n    unsigned int getRetries() const;\n    size_t writeData(void *buffer, size_t size, size_t nmemb);\n    \nprivate:\n    bool downloadFile(const std::string& url);\n    \n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n};\n\nsize_t writeTaskHttpData(void *buffer, size_t size, size_t nmemb, void *user_p)\n{\n    DownloadTask *task = reinterpret_cast<DownloadTask *>(user_p);\n    if (NULL != task)\n    {\n        return task->writeData(buffer, size, nmemb);\n    }\n    \n    return 0;\n}\n\nvoid DownloadTask::initialize()\n{\n    curl_global_init(CURL_GLOBAL_ALL);\n}\n\nvoid DownloadTask::uninitialize()\n{\n    curl_global_cleanup();\n}\n\nbool DownloadTask::downloadFile(const std::string& url)\n{\n    ++m_retries;\n    \n    m_outputTmp = m_output + \".tmp\";\n    deleteFile(m_outputTmp);\n\n    CURLcode res = CURLE_OK;\n    CURL *curl = NULL;\n    \n    std::string userAgent = m_userAgent.empty() ? \"WeChat/7.0.15.33 CFNetwork/978.0.7 Darwin/18.6.0\" : m_userAgent;\n    \n    curl = curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_USERAGENT, userAgent.c_str());\n    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);\n    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 60);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &::writeTaskHttpData);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, true);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0);\n\n    long httpStatus = 0;\n    res = curl_easy_perform(curl);\n    if (res != CURLE_OK)\n    {\n        m_error = \"Failed \" + m_name + \"\\r\\n\";\n        m_error += curl_easy_strerror(res);\n    }\n    else\n    {\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n    }\n    curl_easy_cleanup(curl);\n    \n    if (res == CURLE_OK && httpStatus == 200)\n    {\n        ::moveFile(m_outputTmp, m_output);\n        if (m_mtime > 0)\n        {\n            updateFileTime(m_output, m_mtime);\n        }\n        return true;\n    }\n\n    if (m_error.empty())\n    {\n        m_error = \"HTTP Status:\" + std::to_string(httpStatus);\n    }\n    return false;\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name) {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    bool run() {\n        m_retries = 0;\n        FILE* tmpFile = fopen(m_outputTmp.c_str(), \"wb\");\n        if (!tmpFile) {\n            m_error = \"Failed to create temporary file: \" + m_outputTmp;\n            return false;\n        }\n        fclose(tmpFile);\n\n        bool success = downloadFile(m_url);\n        if (!success && !m_urlBackup.empty()) {\n            success = downloadFile(m_urlBackup);\n        }\n\n        if (!success) {\n            if (!m_default.empty()) {\n                // Use default file\n            }\n            return false;\n        }\n\n        if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n            m_error = \"Failed to rename temporary file to final output path\";\n            return false;\n        }\n\n        if (m_mtime != (time_t)-1) {\n            struct utimbuf newTime;\n            newTime.actime = m_mtime;\n            newTime.modtime = m_mtime;\n            utime(m_output.c_str(), &newTime);\n        }\n\n        return true;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    static size_t writeData(void* ptr, size_t size, size_t nmemb, void* userdata) {\n        std::ofstream* file = static_cast<std::ofstream*>(userdata);\n        if (!file) return 0;\n\n        size_t realsize = size * nmemb;\n        file->write(static_cast<char*>(ptr), realsize);\n        return realsize;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent = \"DownloadTask/1.0\";\n    std::string m_error;\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        std::ofstream outFile(m_outputTmp, std::ios::binary | std::ios::trunc);\n        if (!outFile) {\n            m_error = \"Failed to open temporary file for writing\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &outFile);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        outFile.close();\n        curl_easy_cleanup(curl);\n\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            m_retries++;\n            return false;\n        }\n\n        return true;\n    }\n};",
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static size_t writeCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        return static_cast<DownloadTask*>(userp)->writeData(contents, size, nmemb);\n    }\n\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_outputTmp(output + \".tmp\"), m_default(defaultFile), m_mtime(mtime),\n          m_retries(0), m_name(name), m_userAgent(\"DownloadTask/1.0\") {}\n\n    bool run() {\n        m_retries = 0;\n        if (downloadFile(m_url)) {\n            return true;\n        }\n\n        if (!m_urlBackup.empty() && downloadFile(m_urlBackup)) {\n            return true;\n        }\n\n        m_error = \"All download attempts failed\";\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        std::ofstream* file = reinterpret_cast<std::ofstream*>(contents);\n        size_t realsize = size * nmemb;\n        file->write(static_cast<char*>(contents), realsize);\n        return realsize;\n    }\n\nprivate:\n    bool downloadFile(const std::string& url) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        std::ofstream file(m_outputTmp, std::ios::binary);\n        if (!file.is_open()) {\n            m_error = \"Failed to open temporary file: \" + m_outputTmp;\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &file);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30);\n        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1L);\n        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 30);\n\n        CURLcode res = curl_easy_perform(curl);\n        file.close();\n\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            std::remove(m_outputTmp.c_str());\n            m_retries++;\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_cleanup(curl);\n\n        if (std::rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n            m_error = \"Failed to rename temporary file to final output\";\n            std::remove(m_outputTmp.c_str());\n            return false;\n        }\n\n        if (m_mtime != static_cast<time_t>(-1)) {\n            struct utimbuf newTime;\n            newTime.actime = m_mtime;\n            newTime.modtime = m_mtime;\n            utime(m_output.c_str(), &newTime);\n        }\n\n        return true;\n    }\n};",
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_urlBackup(\"\"), m_output(output), m_outputTmp(output + \".tmp\"), m_default(defaultFile), m_mtime(mtime),\n          m_retries(0), m_name(name), m_userAgent(\"DownloadTask/1.0\"), m_error(\"\") {}\n\n    bool run() {\n        m_retries = 0;\n        FILE* tmpFile = fopen(m_outputTmp.c_str(), \"wb\");\n        if (!tmpFile) {\n            m_error = \"Failed to create temporary file: \" + m_outputTmp;\n            return false;\n        }\n\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            fclose(tmpFile);\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        bool success = false;\n        do {\n            curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeDataCallback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, tmpFile);\n            curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res == CURLE_OK) {\n                long http_code = 0;\n                curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n                if (http_code >= 200 && http_code < 300) {\n                    success = true;\n                    break;\n                } else {\n                    m_error = \"HTTP error code: \" + std::to_string(http_code);\n                }\n            } else {\n                m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            }\n\n            if (!success && !m_urlBackup.empty()) {\n                std::swap(m_url, m_urlBackup);\n                rewind(tmpFile);\n                m_retries++;\n            }\n        } while (!success && m_retries <= 3 && !m_urlBackup.empty());\n\n        curl_easy_cleanup(curl);\n        fclose(tmpFile);\n\n        if (success) {\n            if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n                m_error = \"Failed to rename temporary file to final output\";\n                success = false;\n            } else if (m_mtime != static_cast<time_t>(-1)) {\n                struct utimbuf new_times;\n                new_times.actime = m_mtime;\n                new_times.modtime = m_mtime;\n                utime(m_output.c_str(), &new_times);\n            }\n        } else {\n            if (!m_default.empty()) {\n                rename(m_default.c_str(), m_output.c_str());\n            }\n        }\n\n        return success;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t totalSize = size * nmemb;\n        // This is just a placeholder for the actual write logic handled in writeDataCallback\n        return totalSize;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static size_t writeDataCallback(void* contents, size_t size, size_t nmemb, FILE* stream) {\n        return fwrite(contents, size, nmemb, stream);\n    }\n\n    bool downloadFile(const std::string& url) {\n        // This method would contain additional implementation details\n        // if needed for internal downloading logic beyond what's in run()\n        return true;\n    }\n};",
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name) {\n        m_outputTmp = m_output + \".tmp\";\n        m_userAgent = \"DownloadTask/1.0\";\n    }\n\n    bool run() {\n        if (downloadFile(m_url)) {\n            return true;\n        }\n\n        if (!m_urlBackup.empty() && downloadFile(m_urlBackup)) {\n            return true;\n        }\n\n        if (!m_default.empty()) {\n            std::ifstream src(m_default, std::ios::binary);\n            std::ofstream dst(m_output, std::ios::binary);\n            dst << src.rdbuf();\n            return true;\n        }\n\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        std::ofstream* file = reinterpret_cast<std::ofstream*>(m_writeStream);\n        if (!file || !file->is_open()) {\n            return 0;\n        }\n\n        size_t totalSize = size * nmemb;\n        file->write(static_cast<char*>(contents), totalSize);\n        return totalSize;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n    void* m_writeStream;\n\n    bool downloadFile(const std::string& url) {\n        for (unsigned int attempt = 0; attempt <= 3; ++attempt) {\n            m_retries++;\n\n            CURL* curl = curl_easy_init();\n            if (!curl) {\n                m_error = \"Failed to initialize CURL\";\n                continue;\n            }\n\n            std::ofstream file(m_outputTmp, std::ios::binary | std::ios::trunc);\n            if (!file.is_open()) {\n                m_error = \"Failed to open temporary file\";\n                curl_easy_cleanup(curl);\n                continue;\n            }\n\n            m_writeStream = &file;\n\n            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n            curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            file.close();\n\n            if (res == CURLE_OK) {\n                curl_off_t contentLength;\n                curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD_T, &contentLength);\n                curl_easy_cleanup(curl);\n\n                if (contentLength > 0) {\n                    std::rename(m_outputTmp.c_str(), m_output.c_str());\n\n                    struct utimbuf times;\n                    times.actime = time(nullptr);\n                    times.modtime = m_mtime;\n                    utime(m_output.c_str(), &times);\n\n                    return true;\n                }\n            } else {\n                m_error = curl_easy_strerror(res);\n            }\n\n            curl_easy_cleanup(curl);\n        }\n\n        return false;\n    }\n\n    static size_t writeCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        return static_cast<DownloadTask*>(userp)->writeData(contents, size, nmemb);\n    }\n};",
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_outputTmp(output + \".tmp\"), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"DownloadTask/1.0\") {}\n\n    bool run() {\n        if (downloadFile(m_url)) {\n            return true;\n        } else if (!m_urlBackup.empty() && downloadFile(m_urlBackup)) {\n            return true;\n        }\n        if (!m_default.empty()) {\n            std::ifstream src(m_default, std::ios::binary);\n            std::ofstream dst(m_output, std::ios::binary);\n            dst << src.rdbuf();\n            return true;\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        std::ofstream* file = reinterpret_cast<std::ofstream*>(contents);\n        file->write(static_cast<char*>(contents), size * nmemb);\n        return size * nmemb;\n    }\n\nprivate:\n    bool downloadFile(const std::string& url) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        std::ofstream file(m_outputTmp, std::ios::binary);\n        if (!file) {\n            m_error = \"Failed to create temporary file\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeDataCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &file);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n\n        CURLcode res = curl_easy_perform(curl);\n        file.close();\n\n        if (res != CURLE_OK) {\n            m_error = curl_easy_strerror(res);\n            std::remove(m_outputTmp.c_str());\n            m_retries++;\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_off_t dl_size;\n        curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD_T, &dl_size);\n        curl_easy_cleanup(curl);\n\n        if (dl_size == 0) {\n            m_error = \"Downloaded file is empty\";\n            std::remove(m_outputTmp.c_str());\n            m_retries++;\n            return false;\n        }\n\n        std::rename(m_outputTmp.c_str(), m_output.c_str());\n        if (m_mtime != static_cast<time_t>(-1)) {\n            struct utimbuf new_times;\n            new_times.actime = new_times.modtime = m_mtime;\n            utime(m_output.c_str(), &new_times);\n        }\n\n        return true;\n    }\n\n    static size_t writeDataCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        return static_cast<DownloadTask*>(userp)->writeData(contents, size, nmemb);\n    }\n};",
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name) {\n        m_outputTmp = m_output + \".tmp\";\n        m_userAgent = \"DownloadTask/1.0\";\n    }\n\n    bool run() {\n        if (downloadFile(m_url)) {\n            return true;\n        }\n        if (!m_urlBackup.empty() && downloadFile(m_urlBackup)) {\n            return true;\n        }\n        if (!m_default.empty()) {\n            std::ifstream src(m_default, std::ios::binary);\n            std::ofstream dst(m_output, std::ios::binary);\n            dst << src.rdbuf();\n            return true;\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        std::ofstream* file = reinterpret_cast<std::ofstream*>(m_writeHandle);\n        if (file && file->is_open()) {\n            file->write(static_cast<char*>(contents), size * nmemb);\n            return size * nmemb;\n        }\n        return 0;\n    private:\n        void* m_writeHandle;\n    }\n\nprivate:\n    bool downloadFile(const std::string& url) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        std::ofstream file(m_outputTmp, std::ios::binary);\n        if (!file.is_open()) {\n            m_error = \"Failed to open temporary file\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        m_writeHandle = &file;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        file.close();\n        curl_easy_cleanup(curl);\n\n        if (res != CURLE_OK) {\n            m_error = curl_easy_strerror(res);\n            std::remove(m_outputTmp.c_str());\n            ++m_retries;\n            return false;\n        }\n\n        if (std::rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n            m_error = \"Failed to rename temporary file\";\n            std::remove(m_outputTmp.c_str());\n            return false;\n        }\n\n        if (m_mtime != static_cast<time_t>(-1)) {\n            struct utimbuf newTime;\n            newTime.actime = m_mtime;\n            newTime.modtime = m_mtime;\n            utime(m_output.c_str(), &newTime);\n        }\n\n        return true;\n    }\n\n    static size_t writeCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        return static_cast<DownloadTask*>(userp)->writeData(contents, size, nmemb);\n    }\n\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n};",
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static size_t writeData(void* ptr, size_t size, size_t nmemb, void* userdata);\n\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_outputTmp(output + \".tmp\"), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"DownloadTask/1.0\") {}\n\n    bool run();\n    unsigned int getRetries() const { return m_retries; }\n    bool downloadFile(const std::string& url);\n}; \n\nbool DownloadTask::run() {\n    // Try primary URL\n    if (downloadFile(m_url)) {\n        return true;\n    }\n\n    // If backup URL exists, try that\n    if (!m_urlBackup.empty() && downloadFile(m_urlBackup)) {\n        return true;\n    }\n\n    // If we're here, both downloads failed - restore default if available\n    if (!m_default.empty()) {\n        std::ifstream src(m_default, std::ios::binary);\n        std::ofstream dst(m_output, std::ios::binary);\n        dst << src.rdbuf();\n        return true;\n    }\n\n    return false;\n}\n\nbool DownloadTask::downloadFile(const std::string& url) {\n    const int MAX_RETRIES = 3;\n    \n    for (int attempt = 0; attempt <= MAX_RETRIES; ++attempt++) {\n        m_retries++;\n\n        // Remove any existing temporary file\n        std::remove(m_outputTmp.c_str());\n\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            continue;\n        }\n\n        FILE* fp = fopen(m_outputTmp.c_str(), \"wb\");\n        if (!fp) {\n            curl_easy_cleanup(curl);\n            m_error = \"Failed to create temporary file\";\n            continue;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30);\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 10);\n\n        CURLcode res = curl_easy_perform(curl);\n        fclose(fp);\n        curl_easy_cleanup(curl);\n\n        if (res == CURLE_OK) {\n            // Rename temp file to final destination\n            std::rename(m_outputTmp.c_str(), m_output.c_str());\n            \n            // Set modification time if specified\n            if (m_mtime != 0) {\n                struct utimbuf new_times;\n                new_times.actime = m_mtime;\n                new_times.modtime = m_mtime;\n                utime(m_output.c_str(), &new_times);\n            }\n            \n            return true;\n        }\n\n        m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n        \n        // Don't wait on last attempt\n        if (attempt < MAX_RETRIES) {\n            // Wait 5 seconds before retrying\n            struct timespec ts = {5, 0};\n            nanosleep(&ts, NULL);\n        }\n    }\n\n    return false;\n}\n\nsize_t DownloadTask::writeData(void* ptr, size_t size, size_t nmemb, void* userdata) {\n    fwrite(ptr, size, nmemb, (FILE*)userdata);\n    return size * nmemb;\n}",
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_urlBackup(\"\"), m_output(output), m_outputTmp(output + \".tmp\"), m_default(defaultFile), m_mtime(mtime),\n          m_retries(0), m_name(name), m_userAgent(\"DownloadTask/1.0\"), m_error(\"\") {}\n\n    bool run() {\n        m_retries = 0;\n        if (downloadFile(m_url)) {\n            finalizeDownload();\n            return true;\n        }\n\n        if (!m_urlBackup.empty() && downloadFile(m_urlBackup)) {\n            finalizeDownload();\n            return true;\n        }\n\n        m_error = \"All download attempts failed\";\n        if (!m_default.empty()) {\n            useDefaultFile();\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    static size_t writeData(void* ptr, size_t size, size_t nmemb, void* userdata) {\n        std::ofstream* file = static_cast<std::ofstream*>(userdata);\n        if (!file || !file->is_open()) return 0;\n\n        size_t totalSize = size * nmemb;\n        file->write(static_cast<char*>(ptr), totalSize);\n        return totalSize;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        std::ofstream file(m_outputTmp, std::ios::binary);\n        if (!file.is_open()) {\n            m_error = \"Failed to create temporary file\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &file);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        file.close();\n\n        if (res != CURLE_OK) {\n            m_error = curl_easy_strerror(res);\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_cleanup(curl);\n        return true;\n    }\n\n    void finalizeDownload() {\n        if (std::rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n            m_error = \"Failed to rename temporary file\";\n        }\n\n        struct utimbuf ubuf;\n        ubuf.actime = time(nullptr);\n        ubuf.modtime = m_mtime;\n        utime(m_output.c_str(), &ubuf);\n    }\n\n    void useDefaultFile() {\n        FILE* src = fopen(m_default.c_str(), \"rb\");\n        FILE* dst = fopen(m_output.c_str(), \"wb\");\n\n        if (!src || !dst) {\n            m_error = \"Failed to use default file\";\n            if (src) fclose(src);\n            if (dst) fclose(dst);\n            return;\n        }\n\n        char buffer[4096];\n        size_t bytesRead;\n        while ((bytesRead = fread(buffer, 1, sizeof(buffer), src)) > 0) {\n            fwrite(buffer, 1, bytesRead, dst);\n        }\n\n        fclose(src);\n        fclose(dst);\n\n        struct stat st;\n        if (stat(m_default.c_str(), &st) == 0) {\n            struct utimbuf ubuf;\n            ubuf.actime = time(nullptr);\n            ubuf.modtime = st.st_mtime;\n            utime(m_output.c_str(), &ubuf);\n        }\n    }\n};",
      "#include <curl/curl.h>\n#include <string>\n#include <fstream>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <ctime>\n\nclass DownloadTask {\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name) {\n        m_outputTmp = m_output + \".tmp\";\n        m_userAgent = \"DownloadTask/1.0\";\n    }\n\n    bool run() {\n        const std::string* currentUrl = &m_url;\n        while (true) {\n            if (downloadFile(*currentUrl)) {\n                if (m_mtime != static_cast<time_t>(-1)) {\n                    struct utimbuf times;\n                    times.actime = time(nullptr);\n                    times.modtime = m_mtime;\n                    utime(m_outputTmp.c_str(), &times);\n                }\n                rename(m_outputTmp.c_str(), m_output.c_str());\n                return true;\n            }\n\n            if (!m_urlBackup.empty() && currentUrl == &m_url) {\n                currentUrl = &m_urlBackup;\n                ++m_retries;\n                continue;\n            } else if (m_retries < 3) {\n                ++m_retries;\n                continue;\n            }\n\n            if (!m_default.empty()) {\n                unlink(m_outputTmp.c_str());\n                // Copy default file\n                std::ifstream src(m_default, std::ios::binary);\n                std::ofstream dst(m_output, std::ios::binary);\n                dst << src.rdbuf();\n                return true;\n            }\n\n            return false;\n        }\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    static size_t writeData(void* ptr, size_t size, size_t nmemb, void* userdata) {\n        std::ofstream* stream = static_cast<std::ofstream*>(userdata);\n        size_t realsize = size * nmemb;\n        stream->write(static_cast<char*>(ptr), realsize);\n        return realsize;\n    }\n\nprivate:\n    bool downloadFile(const std::string& url) {\n        CURL* curl = curl_easy_init();\n        if (!curl) return false;\n\n        std::ofstream outFile(m_outputTmp, std::ios::binary);\n        if (!outFile) {\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &outFile);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n\n        CURLcode res = curl_easy_perform(curl);\n        outFile.close();\n        curl_easy_cleanup(curl);\n\n        if (res != CURLE_OK) {\n            unlink(m_outputTmp.c_str());\n            m_error = \"curl_easy_perform() failed: \" + std::string(curl_easy_strerror(res));\n            return false;\n        }\n\n        return true;\n    }\n\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n};",
      "#include <curl/curl.h>\n#include <fstream>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\npublic:\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_outputTmp(output + \".tmp\"), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"DownloadTask/1.0\") {}\n\n    bool run() {\n        const int MAX_ATTEMPTS = 3;\n        for (int attempt = 0; attempt < MAX_ATTEMPTS; ++attempt) {\n            if (downloadFile(m_url) || (m_urlBackup.empty() ? false : downloadFile(m_urlBackup))) {\n                return true;\n            }\n            m_retries++;\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        std::ofstream* file = reinterpret_cast<std::ofstream*>(contents);\n        size_t realsize = size * nmemb;\n        file->write(static_cast<char*>(contents), realsize);\n        return realsize;\n    }\n\nprivate:\n    bool downloadFile(const std::string& url) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        std::ofstream file(m_outputTmp, std::ios::binary);\n        if (!file.is_open()) {\n            m_error = \"Failed to create temporary file\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeDataCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &file);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n\n        CURLcode res = curl_easy_perform(curl);\n        file.close();\n        curl_easy_cleanup(curl);\n\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            std::remove(m_outputTmp.c_str());\n            return false;\n        }\n\n        if (std::rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n            m_error = \"Failed to rename temporary file\";\n            return false;\n        }\n\n        if (m_mtime != (time_t)-1) {\n            struct utimbuf new_times;\n            new_times.actime = m_mtime;\n            new_times.modtime = m_mtime;\n            utime(m_output.c_str(), &new_times);\n        }\n\n        return true;\n    }\n\n    static size_t writeDataCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        return static_cast<DownloadTask*>(userp)->writeData(contents, size, nmemb);\n    }\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, process incoming messages, and echo messages back to clients. The server should also support stopping the listening process upon receiving a specific command.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, managing connection handling, message processing, and server lifecycle operations.\n\nAttributes:\n- service_: [asio::io_service&] - Reference to the ASIO I/O service used for network operations\n- port_: [int] - The port number on which the server listens for connections\n- ws_server_: [ws_echo_server] - The WebSocket++ server instance\n\nMethods:\n- Constructor: [WebSocketServer]([asio::io_service& service, int port]) -> [void] - Initializes the WebSocket++ server, sets up logging, message handling, and starts listening on the specified port\n- on_message: [on_message]([websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg]) -> [void] - Callback function that processes incoming messages, echoes them back to clients, and handles the stop-listening command\n- run: [run]() -> [void] - Starts the server's event loop to handle connections and messages",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) \n        : service_(service), port_(port) {\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        if (msg->get_payload() == \"stop-listening\") {\n            ws_server_.stop_listening();\n            return;\n        }\n\n        try {\n            ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port), ws_server_() {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTEN\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload, msg->get_opcode());\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port) {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTENING\") {\n            ws_server_.stop_listening();\n            return;\n        }\n        ws_server_.send(hdl, payload);\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port), ws_server_() {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void run() {\n        service_.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTEN\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload, msg->get_opcode());\n        }\n    }\n\nprivate:\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port) {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTENING\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening for new connections.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload, msg->get_opcode());\n        }\n    }\n\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port) {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTEN\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload);\n        }\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port), ws_server_() {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTEN\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload, msg->get_opcode());\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port) {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n\n        if (payload == \"STOP_LISTEN\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n            return;\n        }\n\n        ws_server_.send(hdl, payload, msg->get_opcode());\n    }\n\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port), ws_server_() {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        ws_server_.set_access_channels(websocketpp::log::alevel::none);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::all);\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTENING\") {\n            ws_server_.stop_listening();\n            return;\n        }\n        ws_server_.send(hdl, payload);\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port), ws_server_() {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTEN\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload, msg->get_opcode());\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port) {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        ws_server_.set_message_handler([this](websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void run() {\n        service_.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_LISTENING\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening for new connections.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload, msg->get_opcode());\n        }\n    }\n\nprivate:\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication\n- m_connections: [con_list (std::set<connection_hdl>)] - A set of active client connections\n\nMethods:\n- broadcast_server() - [Constructor] -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events\n- on_open(connection_hdl hdl) -> [void] - Handles new client connections by adding them to the connection set\n- on_close(connection_hdl hdl) -> [void] - Handles client disconnections by removing them from the connection set\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by broadcasting them to all connected clients\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n\n        m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void on_open(websocketpp::connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> con_list;\n\n    server_t m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n        m_server.set_close_handler([this](connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n        m_server.set_message_handler([this](connection_hdl hdl, server_t::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server_t::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it, msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server();\n\n    void on_open(websocketpp::connection_hdl hdl);\n    void on_close(websocketpp::connection_hdl hdl);\n    void on_message(websocketpp::connection_hdl hdl, server_t::message_ptr msg);\n\n    void run(uint16_t port);\n\nprivate:\n    typedef std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> con_list;\n\n    server_t m_server;\n    con_list m_connections;\n};\n\nbroadcast_server::broadcast_server() {\n    m_server.init_asio();\n\n    m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_open(hdl);\n    });\n\n    m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_close(hdl);\n    });\n\n    m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n        this->on_message(hdl, msg);\n    });\n}\n\nvoid broadcast_server::on_open(websocketpp::connection_hdl hdl) {\n    m_connections.insert(hdl);\n}\n\nvoid broadcast_server::on_close(websocketpp::connection_hdl hdl) {\n    m_connections.erase(hdl);\n}\n\nvoid broadcast_server::on_message(websocketpp::connection_hdl, server_t::message_ptr msg) {\n    for (auto it : m_connections) {\n        m_server.send(it, msg);\n    }\n}\n\nvoid broadcast_server::run(uint16_t port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server();\n\n    void on_open(websocketpp::connection_hdl hdl);\n    void on_close(websocketpp::connection_hdl hdl);\n    void on_message(websocketpp::connection_hdl hdl, server_t::message_ptr msg);\n    void run(uint16_t port);\n\nprivate:\n    typedef std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> con_list;\n\n    server_t m_server;\n    con_list m_connections;\n};\n\nbroadcast_server::broadcast_server() {\n    m_server.init_asio();\n\n    m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_open(hdl);\n    });\n    m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_close(hdl);\n    });\n    m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n        this->on_message(hdl, msg);\n    });\n}\n\nvoid broadcast_server::on_open(websocketpp::connection_hdl hdl) {\n    m_connections.insert(hdl);\n}\n\nvoid broadcast_server::on_close(websocketpp::connection_hdl hdl) {\n    m_connections.erase(hdl);\n}\n\nvoid broadcast_server::on_message(websocketpp::connection_hdl, server_t::message_ptr msg) {\n    for (auto it : m_connections) {\n        m_server.send(it, msg);\n    }\n}\n\nvoid broadcast_server::run(uint16_t port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server();\n\n    void on_open(websocketpp::connection_hdl hdl);\n    void on_close(websocketpp::connection_hdl hdl);\n    void on_message(websocketpp::connection_hdl hdl, server_t::message_ptr msg);\n\n    void run(uint16_t port);\n\nprivate:\n    typedef std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> con_list;\n\n    server_t m_server;\n    con_list m_connections;\n};\n\nbroadcast_server::broadcast_server() {\n    m_server.init_asio();\n\n    m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_open(hdl);\n    });\n\n    m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_close(hdl);\n    });\n\n    m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n        this->on_message(hdl, msg);\n    });\n}\n\nvoid broadcast_server::on_open(websocketpp::connection_hdl hdl) {\n    m_connections.insert(hdl);\n}\n\nvoid broadcast_server::on_close(websocketpp::connection_hdl hdl) {\n    m_connections.erase(hdl);\n}\n\nvoid broadcast_server::on_message(websocketpp::connection_hdl, server_t::message_ptr msg) {\n    for (auto it : m_connections) {\n        m_server.send(it, msg);\n    }\n}\n\nvoid broadcast_server::run(uint16_t port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server();\n\n    void on_open(websocketpp::connection_hdl hdl);\n    void on_close(websocketpp::connection_hdl hdl);\n    void on_message(websocketpp::connection_hdl hdl, server_t::message_ptr msg);\n\n    void run(uint16_t port);\n\nprivate:\n    typedef std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> con_list;\n\n    server_t m_server;\n    con_list m_connections;\n};\n\nbroadcast_server::broadcast_server() {\n    m_server.init_asio();\n\n    m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_open(hdl);\n    });\n\n    m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_close(hdl);\n    });\n\n    m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n        this->on_message(hdl, msg);\n    });\n}\n\nvoid broadcast_server::on_open(websocketpp::connection_hdl hdl) {\n    m_connections.insert(hdl);\n}\n\nvoid broadcast_server::on_close(websocketpp::connection_hdl hdl) {\n    m_connections.erase(hdl);\n}\n\nvoid broadcast_server::on_message(websocketpp::connection_hdl, server_t::message_ptr msg) {\n    for (auto it : m_connections) {\n        m_server.send(it, msg);\n    }\n}\n\nvoid broadcast_server::run(uint16_t port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n\n        m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void on_open(websocketpp::connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(websocketpp::connection_hdl, server_t::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it, msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> con_list;\n\n    server_t m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\nprivate:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    server_t m_server;\n    con_list m_connections;\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server_t::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(websocketpp::lib::bind(&broadcast_server::on_open, this, ::_1));\n        m_server.set_close_handler(websocketpp::lib::bind(&broadcast_server::on_close, this, ::_1));\n        m_server.set_message_handler(websocketpp::lib::bind(&broadcast_server::on_message, this, ::_1, ::_2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server();\n\n    void on_open(websocketpp::connection_hdl hdl);\n    void on_close(websocketpp::connection_hdl hdl);\n    void on_message(websocketpp::connection_hdl hdl, server_t::message_ptr msg);\n\n    void run(uint16_t port);\n\nprivate:\n    typedef std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> con_list;\n\n    server_t m_server;\n    con_list m_connections;\n};\n\nbroadcast_server::broadcast_server() {\n    m_server.init_asio();\n\n    m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_open(hdl);\n    });\n\n    m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_close(hdl);\n    });\n\n    m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n        this->on_message(hdl, msg);\n    });\n}\n\nvoid broadcast_server::on_open(websocketpp::connection_hdl hdl) {\n    m_connections.insert(hdl);\n}\n\nvoid broadcast_server::on_close(websocketpp::connection_hdl hdl) {\n    m_connections.erase(hdl);\n}\n\nvoid broadcast_server::on_message(websocketpp::connection_hdl, server_t::message_ptr msg) {\n    for (auto it : m_connections) {\n        m_server.send(it, msg);\n    }\n}\n\nvoid broadcast_server::run(uint16_t port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server();\n\n    void on_open(websocketpp::connection_hdl hdl);\n    void on_close(websocketpp::connection_hdl hdl);\n    void on_message(websocketpp::connection_hdl hdl, server_t::message_ptr msg);\n    void run(uint16_t port);\n\nprivate:\n    server_t m_server;\n    std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> m_connections;\n};\n\nbroadcast_server::broadcast_server() {\n    m_server.init_asio();\n\n    m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_open(hdl);\n    });\n\n    m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n        this->on_close(hdl);\n    });\n\n    m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_t::message_ptr msg) {\n        this->on_message(hdl, msg);\n    });\n}\n\nvoid broadcast_server::on_open(websocketpp::connection_hdl hdl) {\n    m_connections.insert(hdl);\n}\n\nvoid broadcast_server::on_close(websocketpp::connection_hdl hdl) {\n    m_connections.erase(hdl);\n}\n\nvoid broadcast_server::on_message(websocketpp::connection_hdl, server_t::message_ptr msg) {\n    for (auto it : m_connections) {\n        m_server.send(it, msg);\n    }\n}\n\nvoid broadcast_server::run(uint16_t port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections, process incoming messages, and support configurable threading for concurrent operations.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server implementation, providing methods to initialize, configure, and run the server with customizable port and threading settings.\n\nAttributes:\n- testee_server_: [server] - The WebSocket++ server instance that manages connections and message handling\n- port_: [short] - The port number on which the server listens for incoming connections\n- num_threads_: [size_t] - The number of threads to use for handling connections (1 for single-threaded mode)\n\nMethods:\n- WebSocketServer([short port = 9002], [size_t num_threads = 1]) -> [void] - Constructor that initializes the server with specified port and thread count (defaults to port 9002 and single-threaded)\n- run() -> [void] - Starts the WebSocket server, sets up message handlers, begins listening on the specified port, and manages the server's event loop(s)\n- on_message([websocketpp::connection_hdl hdl], [message_ptr msg]) -> [void] - Message handler that echoes received messages back to the client (private method)\n- on_socket_init([websocketpp::connection_hdl hdl], [boost::asio::ip::tcp::socket & s]) -> [void] - Socket initialization handler that enables TCP_NODELAY for reduced latency (private method)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/extensions/permessage_deflate/enabled.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <websocketpp/common/thread.hpp>\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::message_ptr message_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) \n        : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        try {\n            testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n            testee_server_.clear_error_channels(websocketpp::log::alevel::all);\n\n            testee_server_.init_asio();\n            testee_server_.set_reuse_addr(true);\n\n            testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n            testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, ::_1, ::_2));\n\n            testee_server_.set_listen_backlog(8192);\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n\n            if (num_threads_ == 1) {\n                testee_server_.run();\n            } else {\n                std::vector<websocketpp::lib::shared_ptr<websocketpp::lib::thread>> ts;\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts.push_back(websocketpp::lib::make_shared<websocketpp::lib::thread>(&server::run, &testee_server_));\n                }\n\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts[i]->join();\n                }\n            }\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket & s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n\n        testee_server_.set_socket_init_handler([this](websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n            this->on_socket_init(hdl, s);\n        });\n\n        testee_server_.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                thread_pool.create_thread([this]() { this->testee_server_.run(); });\n            }\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n\n        testee_server_.set_message_handler([this](\n            websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        testee_server_.set_socket_init_handler([this](\n            websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n            this->on_socket_init(hdl, s);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 1; i < num_threads_; ++i) {\n                thread_pool.create_thread([&]() { testee_server_.run(); });\n            }\n            testee_server_.run();\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket &s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n\n        testee_server_.set_message_handler([this](\n            websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        testee_server_.set_socket_init_handler([this](\n            websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n            this->on_socket_init(hdl, s);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                thread_pool.create_thread([&]() { testee_server_.run(); });\n            }\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n\n        testee_server_.set_message_handler([this](\n            websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        testee_server_.set_socket_init_handler([this](\n            websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n            this->on_socket_init(hdl, s);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                thread_pool.create_thread([&]() { testee_server_.run(); });\n            }\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket& s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n\n        testee_server_.set_message_handler([this](\n            websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        testee_server_.set_socket_init_handler([this](\n            websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n            this->on_socket_init(hdl, s);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                thread_pool.create_thread([&]() { testee_server_.run(); });\n            }\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket& s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n\n        testee_server_.set_socket_init_handler([this](websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n            this->on_socket_init(hdl, s);\n        });\n\n        testee_server_.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                thread_pool.create_thread([this]() {\n                    this->testee_server_.run();\n                });\n            }\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        boost::system::error_code ec;\n        s.set_option(option, ec);\n        if (ec) {\n            std::cerr << \"Error setting TCP_NODELAY: \" << ec.message() << std::endl;\n        }\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n        testee_server_.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        testee_server_.set_socket_init_handler([this](websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n            this->on_socket_init(hdl, s);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                thread_pool.create_thread([this]() { this->testee_server_.run(); });\n            }\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl /*hdl*/, boost::asio::ip::tcp::socket& s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n\n        testee_server_.set_message_handler([this](\n            websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        testee_server_.set_socket_init_handler([this](\n            websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n            this->on_socket_init(hdl, s);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                thread_pool.create_thread([&]() { testee_server_.run(); });\n            }\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket &s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n        testee_server_.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        testee_server_.set_socket_init_handler([this](websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n            this->on_socket_init(hdl, s);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                thread_pool.create_thread([this]() { this->testee_server_.run(); });\n            }\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket& s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1)\n        : port_(port), num_threads_(num_threads) {\n        testee_server_.init_asio();\n\n        testee_server_.set_socket_init_handler([this](websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n            this->on_socket_init(hdl, s);\n        });\n\n        testee_server_.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void run() {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            boost::thread_group thread_pool;\n            for (size_t i = 1; i < num_threads_; ++i) {\n                thread_pool.create_thread([&]() { testee_server_.run(); });\n            }\n            testee_server_.run();\n            thread_pool.join_all();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage sessions, and process incoming messages.\n\nClass Description: The `print_server` class implements a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: int - Tracks the next available session ID to assign to new connections.\n- m_server: server - The WebSocket++ server instance configured with custom connection data.\n\nMethods:\n- print_server() - Constructor - Initializes the server with ASIO, sets up handlers for connection open, close, and message events.\n- on_open(connection_hdl hdl) -> void - Handler for new connections. Assigns a session ID to the new connection.\n- on_close(connection_hdl hdl) -> void - Handler for connection closures. Logs the connection's name and session ID.\n- on_message(connection_hdl hdl, server::message_ptr msg) -> void - Handler for incoming messages. Sets the connection name if not set, otherwise logs the message along with the connection's name and session ID.\n- run(uint16_t port) -> void - Starts the server listening on the specified port, begins accepting connections, and runs the event loop.",
    "Canonical_solution": "#include <iostream>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nstruct custom_config : public websocketpp::config::asio {\n    typedef websocketpp::config::asio core;\n    typedef core::concurrency_type concurrency_type;\n    typedef core::request_type request_type;\n    typedef core::response_type response_type;\n    typedef core::message_type message_type;\n    typedef core::con_msg_manager_type con_msg_manager_type;\n    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;\n    typedef core::alog_type alog_type;\n    typedef core::elog_type elog_type;\n    typedef core::rng_type rng_type;\n    typedef core::transport_type transport_type;\n    typedef core::endpoint_base endpoint_base;\n    typedef connection_data connection_base;\n};\n\ntypedef websocketpp::server<custom_config> server;\ntypedef server::connection_ptr connection_ptr;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->sessionid = m_next_sessionid++;\n    }\n    \n    void on_close(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Closing connection \" << con->name \n                  << \" with sessionid \" << con->sessionid << std::endl;\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        \n        if (con->name.empty()) {\n            con->name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \" \n                      << con->sessionid << \" to \" << con->name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << con->name \n                      << \" with sessionid \" << con->sessionid << std::endl;\n        }\n    }\n    \n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\n// Define a custom connection data structure to hold session information\nstruct session_data {\n    int session_id;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        // Initialize Asio\n        m_server.init_asio();\n\n        // Register handler callbacks\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        // Assign session data with next available session ID\n        session_data sdata;\n        sdata.session_id = m_next_sessionid++;\n        sdata.name = \"unnamed\";\n\n        m_server.set_connection_data(hdl, sdata);\n\n        std::cout << \"Connection opened with session ID: \" << sdata.session_id << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data sdata = m_server.get_connection_data<session_data>(hdl);\n        std::cout << \"Connection closed - Session ID: \" << sdata.session_id \n                  << \", Name: \" << sdata.name << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data& sdata = m_server.get_mutable_connection_data<session_data>(hdl);\n\n        // If the name is still \"unnamed\", set it to the message payload\n        if (sdata.name == \"unnamed\") {\n            sdata.name = msg->get_payload();\n            std::cout << \"Assigned name: \" << sdata.name \n                      << \" to session ID: \" << sdata.session_id << std::endl;\n        } else {\n            // Otherwise, log the message along with session info\n            std::cout << \"Received message from Session ID: \" << sdata.session_id\n                      << \", Name: \" << sdata.name << \" - Message: \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start accepting connections\n        m_server.start_accept();\n\n        // Run the ASIO event loop\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    int m_next_sessionid;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    struct session_data {\n        int sessionid;\n        std::string name;\n    };\n\n    void on_open(connection_hdl hdl) {\n        std::shared_ptr<session_data> data = std::make_shared<session_data>();\n        data->sessionid = m_next_sessionid++;\n        data->name = \"Unnamed\";\n        m_server.set_connection_data(hdl, data);\n\n        std::cout << \"New connection: SessionID=\" << data->sessionid << \", Name=\" << data->name << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::shared_ptr<session_data> data = m_server.get_connection_data(hdl);\n        if (data) {\n            std::cout << \"Connection closed: SessionID=\" << data->sessionid << \", Name=\" << data->name << std::endl;\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::shared_ptr<session_data> data = m_server.get_connection_data(hdl);\n        if (data) {\n            std::string payload = msg->get_payload();\n            if (data->name == \"Unnamed\") {\n                data->name = payload.substr(0, 32); // Limit name length\n                std::cout << \"SessionID \" << data->sessionid << \" set name to: \" << data->name << std::endl;\n            } else {\n                std::cout << \"Message from SessionID=\" << data->sessionid << \" (\" << data->name << \"): \" << payload << std::endl;\n            }\n        }\n    }\n\n    int m_next_sessionid;\n    server m_server;\n};\n\nint main(int argc, char* argv[]) {\n    uint16_t port = 9002;\n\n    if (argc == 2) {\n        port = static_cast<uint16_t>(atoi(argv[1]));\n    }\n\n    try {\n        print_server s;\n        s.run(port);\n    } catch (const std::exception& e) {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\n// Define a custom connection data structure to hold session ID and name\nstruct session_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        // Initialize Asio\n        m_server.init_asio();\n\n        // Set up handler callbacks\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start the server accepting connections\n        m_server.start_accept();\n\n        // Run the ASIO io_context\n        m_server.run();\n    }\n\n    void on_open(connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n\n        // Assign session data\n        session_data* s_data = new session_data();\n        s_data->sessionid = m_next_sessionid++;\n        s_data->name = \"Unnamed\";\n\n        con->set_user_data(s_data);\n    }\n\n    void on_close(connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        session_data* s_data = static_cast<session_data*>(con->get_user_data());\n\n        std::cout << \"Connection closed: SessionID=\" << s_data->sessionid\n                  << \", Name=\" << s_data->name << std::endl;\n\n        delete s_data;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        session_data* s_data = static_cast<session_data*>(con->get_user_data());\n\n        std::string payload = msg->get_payload();\n\n        if (s_data->name == \"Unnamed\") {\n            s_data->name = payload;\n            std::cout << \"SessionID=\" << s_data->sessionid\n                      << \" set name to: \" << s_data->name << std::endl;\n        } else {\n            std::cout << \"Received message from SessionID=\" << s_data->sessionid\n                      << \" (\" << s_data->name << \"): \" << payload << std::endl;\n        }\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};\n\nint main(int argc, char* argv[]) {\n    uint16_t port = 9002;\n\n    print_server s;\n    std::cout << \"Starting WebSocket server on port \" << port << std::endl;\n    s.run(port);\n\n    return 0;\n}",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\n// Define a custom connection data structure to store session information\nstruct session_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        // Initialize Asio\n        m_server.init_asio();\n\n        // Register handler callbacks\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        // Assign a new session ID to the connection\n        session_data* s_data = new session_data();\n        s_data->sessionid = m_next_sessionid++;\n        s_data->name = \"unnamed\";\n        m_server.set_connection_data(hdl, s_data);\n\n        std::cout << \"New connection: sessionID=\" << s_data->sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        // Retrieve session data and log it\n        session_data* s_data = static_cast<session_data*>(m_server.get_connection_data(hdl));\n        std::cout << \"Connection closed: sessionID=\" << s_data->sessionid \n                  << \", name=\" << s_data->name << std::endl;\n\n        delete s_data;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        // Get session data\n        session_data* s_data = static_cast<session_data*>(m_server.get_connection_data(hdl));\n\n        std::string payload = msg->get_payload();\n\n        if (s_data->name == \"unnamed\") {\n            // Set the name for the connection\n            s_data->name = payload;\n            std::cout << \"Assigned name: \" << s_data->name \n                      << \" for sessionID=\" << s_data->sessionid << std::endl;\n        } else {\n            // Log message with session info\n            std::cout << \"Message from sessionID=\" << s_data->sessionid \n                      << \", name=\" << s_data->name << \": \" << payload << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start accepting connections\n        m_server.start_accept();\n\n        // Run the server loop\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\n// pull out the type of messages sent by our config\ntypedef server::message_ptr message_ptr;\n\nstruct session_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        // Set logging settings\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        // Initialize ASIO\n        m_server.init_asio();\n\n        // Register handler callbacks\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        // Create new session data for this connection\n        session_data sdata;\n        sdata.sessionid = m_next_sessionid++;\n        sdata.name = \"Unnamed\";\n\n        m_server.set_connection_data(hdl, sdata);\n\n        std::cout << \"New connection: SessionID \" << sdata.sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data sdata = m_server.get_connection_data<handle>(hdl);\n\n        std::cout << \"Connection closed: SessionID \" << sdata.sessionid \n                  << \", Name: \" << sdata.name << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        session_data &sdata = m_server.get_connection_data<handle>(hdl);\n\n        if (sdata.name == \"Unnamed\") {\n            sdata.name = msg->get_payload();\n            std::cout << \"SessionID \" << sdata.sessionid \n                      << \" set name to \" << sdata.name << std::endl;\n        } else {\n            std::cout << \"Message from SessionID \" << sdata.sessionid \n                      << \" (\" << sdata.name << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start accepting connections\n        m_server.start_accept();\n\n        // Run the ASIO event loop\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl, session_data, std::owner_less<connection_hdl>> con_map;\n\n    server m_server;\n    int m_next_sessionid;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\n// Define a custom connection data structure to store session ID and name\nstruct session_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        // Initialize Asio\n        m_server.init_asio();\n\n        // Register handler callbacks\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        // Assign session data\n        session_data sdata;\n        sdata.sessionid = m_next_sessionid++;\n        sdata.name = \"unnamed\";\n\n        m_server.set_user_data(hdl, sdata);\n\n        std::cout << \"Connection opened with session ID: \" << sdata.sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data sdata = websocketpp::lib::any_cast<session_data>(m_server.get_user_data(hdl));\n        std::cout << \"Connection closed for session ID: \" << sdata.sessionid\n                  << \" (\" << sdata.name << \")\" << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data &sdata = websocketpp::lib::any_cast<session_data&>(m_server.get_user_data(hdl));\n\n        std::string payload = msg->get_payload();\n        if (sdata.name == \"unnamed\") {\n            sdata.name = payload;\n            std::cout << \"Session ID \" << sdata.sessionid\n                      << \" set name to: \" << sdata.name << std::endl;\n        } else {\n            std::cout << \"Session ID \" << sdata.sessionid\n                      << \" (\" << sdata.name << \") sent message: \" << payload << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start the server accepting connections\n        m_server.start_accept();\n\n        // Run the ASIO io_service event loop\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct session_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        auto data = std::make_shared<session_data>();\n        data->sessionid = m_next_sessionid++;\n        data->name = \"Unnamed\";\n\n        m_server.set_connection_data(hdl, data);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto data = std::static_pointer_cast<session_data>(m_server.get_connection_data(hdl));\n        std::cout << \"Connection closed: \" << data->name << \" (Session ID: \" << data->sessionid << \")\" << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        auto data = std::static_pointer_cast<session_data>(m_server.get_connection_data(hdl));\n\n        if (data->name == \"Unnamed\") {\n            data->name = msg->get_payload();\n            std::cout << \"Connection named: \" << data->name << \" (Session ID: \" << data->sessionid << \")\" << std::endl;\n        } else {\n            std::cout << \"Message from \" << data->name << \" (Session ID: \" << data->sessionid << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct session_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        auto data = std::make_shared<session_data>();\n        data->sessionid = m_next_sessionid++;\n        data->name = \"Unnamed\";\n\n        m_server.set_connection_data(hdl, data);\n        std::cout << \"Connection opened with session ID: \" << data->sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto data = std::static_pointer_cast<session_data>(m_server.get_connection_data(hdl));\n        std::cout << \"Connection closed - Session ID: \" << data->sessionid\n                  << \", Name: \" << data->name << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        auto data = std::static_pointer_cast<session_data>(m_server.get_connection_data(hdl));\n\n        std::string payload = msg->get_payload();\n        if (data->name == \"Unnamed\") {\n            data->name = payload;\n            std::cout << \"Set name for session ID: \" << data->sessionid\n                      << \" to: \" << data->name << std::endl;\n        } else {\n            std::cout << \"Message from \" << data->name << \" (Session \" << data->sessionid << \"): \"\n                      << payload << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    int m_next_sessionid;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct session_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        session_data_ptr data = std::make_shared<session_data>();\n        data->sessionid = m_next_sessionid++;\n        data->name = \"Unnamed\";\n        m_server.set_connection_data(hdl, data);\n        std::cout << \"Connection opened with session ID: \" << data->sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data_ptr data = m_server.get_connection_data<session_data>(hdl);\n        std::cout << \"Connection closed - Session ID: \" << data->sessionid\n                  << \", Name: \" << data->name << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data_ptr data = m_server.get_connection_data<session_data>(hdl);\n\n        std::string payload = msg->get_payload();\n        if (data->name == \"Unnamed\") {\n            data->name = payload;\n            std::cout << \"Set name for session ID: \" << data->sessionid\n                      << \" to: \" << data->name << std::endl;\n        } else {\n            std::cout << \"Received message from Session ID: \" << data->sessionid\n                      << \", Name: \" << data->name << \" - Message: \" << payload << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::shared_ptr<session_data> session_data_ptr;\n    server m_server;\n    int m_next_sessionid;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct session_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        session_data* data = new session_data();\n        data->sessionid = m_next_sessionid++;\n        data->name = \"Unnamed\";\n        con->set_user_data(data);\n\n        std::cout << \"Connection opened with session ID: \" << data->sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        session_data* data = static_cast<session_data*>(con->get_user_data());\n        std::cout << \"Connection closed - Session ID: \" << data->sessionid\n                  << \", Name: \" << data->name << std::endl;\n        delete data;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        session_data* data = static_cast<session_data*>(con->get_user_data());\n\n        std::string payload = msg->get_payload();\n        if (data->name == \"Unnamed\") {\n            data->name = payload;\n            con->send(hdl, \"Name set to: \" + data->name, msg->get_opcode());\n        } else {\n            std::cout << \"Session \" << data->sessionid << \" (\" << data->name\n                      << \") sent message: \" << payload << std::endl;\n            con->send(hdl, \"Received: \" + payload, msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.sessionid = m_next_sessionid++;\n        data.name = \"unnamed\";\n\n        m_connections[hdl] = data;\n\n        std::cout << \"New connection: SessionID=\" << data.sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Connection closed: SessionID=\" << it->second.sessionid << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n\n            std::string payload = msg->get_payload();\n            if (payload.substr(0,5) == \"name:\") {\n                data.name = payload.substr(5);\n                std::cout << \"SessionID=\" << data.sessionid << \" set name to \" << data.name << std::endl;\n            } else {\n                std::cout << \"SessionID=\" << data.sessionid << \" (\" << data.name << \") sent message: \" << payload << std::endl;\n            }\n        } catch (const std::out_of_range& e) {\n            std::cerr << \"Error retrieving connection data: \" << e.what() << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection data not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_type;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n\n        m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_type::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<websocketpp::connection_hdl, connection_data, std::owner_less<websocketpp::connection_hdl>> con_map;\n\n    void on_open(websocketpp::connection_hdl hdl) {\n        connection_data data;\n        data.sessionid = m_next_sessionid++;\n        data.name = \"anonymous\";\n\n        m_connections.insert(std::make_pair(hdl, data));\n\n        connection_data& cd = get_data_from_hdl(hdl);\n        std::cout << \"New connection: SessionID=\" << cd.sessionid << \", Name=\" << cd.name << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        con_map::iterator it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Closing connection: SessionID=\" << it->second.sessionid << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server_type::message_ptr msg) {\n        connection_data& cd = get_data_from_hdl(hdl);\n\n        std::string payload = msg->get_payload();\n        if (payload.substr(0,5) == \"name:\") {\n            cd.name = payload.substr(5);\n            std::cout << \"SessionID=\" << cd.sessionid << \" set name to \" << cd.name << std::endl;\n        } else {\n            std::cout << \"Received message from SessionID=\" << cd.sessionid << \" (\" << cd.name << \"): \" << payload << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(websocketpp::connection_hdl hdl) {\n        con_map::iterator it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::runtime_error(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    int m_next_sessionid;\n    server_type m_server;\n    con_map m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_type;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n\n        m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_type::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(websocketpp::connection_hdl hdl) {\n        connection_data data;\n        data.sessionid = m_next_sessionid++;\n        data.name = \"unnamed\";\n\n        m_connections.insert({hdl, data});\n\n        std::cout << \"New connection with session ID: \" << data.sessionid << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Connection closed for session ID: \" << it->second.sessionid << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server_type::message_ptr msg) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n            std::string payload = msg->get_payload();\n\n            if (payload.substr(0, 5) == \"name:\") {\n                data.name = payload.substr(5);\n                std::cout << \"Session \" << data.sessionid << \" set name to: \" << data.name << std::endl;\n            } else {\n                std::cout << \"Received message from session \" << data.sessionid << \" (\" << data.name << \"): \" << payload << std::endl;\n            }\n        } catch (const std::out_of_range& e) {\n            std::cerr << \"Error retrieving connection data: \" << e.what() << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(websocketpp::connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection data not found\");\n        }\n        return it->second;\n    }\n\n    int m_next_sessionid;\n    server_type m_server;\n    std::map<websocketpp::connection_hdl, connection_data, std::owner_less<websocketpp::connection_hdl>> m_connections;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.sessionid = m_next_sessionid++;\n        data.name = \"Unnamed\";\n\n        m_connections[hdl] = data;\n\n        std::cout << \"New connection with session ID: \" << data.sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Connection closed for session ID: \" << it->second.sessionid << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n            std::string payload = msg->get_payload();\n\n            if (payload.substr(0, 5) == \"name:\") {\n                data.name = payload.substr(5);\n                std::cout << \"Session ID \" << data.sessionid << \" set name to: \" << data.name << std::endl;\n            } else {\n                std::cout << \"Received message from \" << data.name << \" (Session \" << data.sessionid << \"): \" << payload << std::endl;\n            }\n        } catch (const std::out_of_range& e) {\n            std::cerr << \"Error retrieving connection data: \" << e.what() << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection data not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\n// pull out the type of messages sent by our config\ntypedef server::message_ptr message_ptr;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        // Initialize Asio\n        m_server.init_asio();\n\n        // Register handler callbacks\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.sessionid = m_next_sessionid++;\n        data.name = \"unknown\";\n\n        m_connections.insert(std::make_pair(hdl, data));\n\n        connection_data& cd = get_data_from_hdl(hdl);\n        std::cout << \"new connection: sid=\" << cd.sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data cd = m_connections[hdl];\n        std::cout << \"closing connection: sid=\" << cd.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        connection_data& cd = get_data_from_hdl(hdl);\n\n        std::string payload = msg->get_payload();\n        if (payload.substr(0,5) == \"name:\") {\n            cd.name = payload.substr(5);\n            std::cout << \"sid=\" << cd.sessionid << \" named as \" << cd.name << std::endl;\n        } else {\n            std::cout << \"msg from \" << cd.name << \" (sid=\" << cd.sessionid << \"): \" << payload << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::runtime_error(\"Invalid connection handle\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        // listen on specified port\n        m_server.listen(port);\n\n        // Start the server accept loop\n        m_server.start_accept();\n\n        // Start the ASIO io_service run loop\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.sessionid = m_next_sessionid++;\n        data.name = \"Unnamed\";\n\n        m_connections[hdl] = data;\n\n        std::cout << \"New connection, session ID: \" << data.sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Connection closed, session ID: \" << it->second.sessionid << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n            std::string payload = msg->get_payload();\n\n            if (payload.substr(0,5) == \"name:\") {\n                data.name = payload.substr(5);\n                std::cout << \"Session \" << data.sessionid << \" set name to: \" << data.name << std::endl;\n            } else {\n                std::cout << \"Session \" << data.sessionid << \" (\" << data.name << \") sent: \" << payload << std::endl;\n            }\n        } catch (const std::out_of_range& e) {\n            std::cerr << \"Error: Connection data not found for message\" << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection data not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_type;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n\n        m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server_type::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<websocketpp::connection_hdl, connection_data, std::owner_less<websocketpp::connection_hdl>> con_map;\n\n    void on_open(websocketpp::connection_hdl hdl) {\n        connection_data data;\n        data.sessionid = m_next_sessionid++;\n        data.name = \"unnamed\";\n\n        m_connections.insert(std::make_pair(hdl, data));\n\n        std::cout << \"New connection: Session ID \" << data.sessionid << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        con_map::iterator it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Closing connection: Session ID \" << it->second.sessionid << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server_type::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n        std::string payload = msg->get_payload();\n\n        if (payload.substr(0,5) == \"name:\") {\n            data.name = payload.substr(5);\n            std::cout << \"Session ID \" << data.sessionid << \" set name to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Received message from Session ID \" << data.sessionid << \" (\" << data.name << \"): \" << payload << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(websocketpp::connection_hdl hdl) {\n        con_map::iterator it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::runtime_error(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    int m_next_sessionid;\n    server_type m_server;\n    con_map m_connections;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.sessionid = m_next_sessionid++;\n        data.name = \"unnamed\";\n\n        m_connections[hdl] = data;\n\n        std::cout << \"New connection with session ID: \" << data.sessionid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Closing connection with session ID: \" << it->second.sessionid << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n            std::string payload = msg->get_payload();\n\n            if (payload.substr(0,5) == \"name:\") {\n                data.name = payload.substr(5);\n                std::cout << \"Session \" << data.sessionid << \" set name to: \" << data.name << std::endl;\n            } else {\n                std::cout << \"Received message from session \" << data.sessionid \n                          << \" (\" << data.name << \"): \" << payload << std::endl;\n            }\n        } catch (const std::out_of_range& e) {\n            std::cerr << \"Connection data not found for handle\" << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection data not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\n// pull out the type of messages sent by our config\ntypedef server::message_ptr message_ptr;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server();\n\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, message_ptr msg);\n    connection_data& get_data_from_hdl(connection_hdl hdl);\n\n    void run(uint16_t port);\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n};\n\nprint_server::print_server() : m_next_sessionid(0) {\n    // Set logging settings\n    m_server.set_access_channels(websocketpp::log::alevel::all);\n    m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n    // Initialize Asio\n    m_server.init_asio();\n\n    // Register handler callbacks\n    m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n    m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n    m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n}\n\nvoid print_server::on_open(connection_hdl hdl) {\n    connection_data data;\n    data.sessionid = m_next_sessionid++;\n    data.name = \"unnamed\";\n\n    m_connections[hdl] = data;\n\n    std::cout << \"new connection: \" << data.sessionid << std::endl;\n}\n\nvoid print_server::on_close(connection_hdl hdl) {\n    auto it = m_connections.find(hdl);\n    if (it != m_connections.end()) {\n        std::cout << \"closing connection: \" << it->second.sessionid << std::endl;\n        m_connections.erase(it);\n    }\n}\n\nvoid print_server::on_message(connection_hdl hdl, message_ptr msg) {\n    connection_data &data = get_data_from_hdl(hdl);\n\n    std::string payload = msg->get_payload();\n    \n    if (payload.substr(0,5) == \"name:\") {\n        data.name = payload.substr(5);\n        std::cout << \"session \" << data.sessionid << \" named to: \" << data.name << std::endl;\n    } else {\n        std::cout << \"msg from \" << data.sessionid << \" (\" << data.name << \"): \" << payload << std::endl;\n    }\n}\n\nconnection_data& print_server::get_data_from_hdl(connection_hdl hdl) {\n    auto it = m_connections.find(hdl);\n    if (it == m_connections.end()) {\n        throw std::invalid_argument(\"Handle not found\");\n    }\n    return it->second;\n}\n\nvoid print_server::run(uint16_t port) {\n    // Listen on port\n    m_server.listen(port);\n\n    // Start the server accept loop\n    m_server.start_accept();\n\n    // Start the ASIO io_service run loop\n    m_server.run();\n}",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <map>\n#include <string>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\n// pull out the type of messages sent by our config\ntypedef server::message_ptr message_ptr;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server();\n\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, message_ptr msg);\n    connection_data& get_data_from_hdl(connection_hdl hdl);\n\n    void run(uint16_t port);\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n};\n\nprint_server::print_server() : m_next_sessionid(0) {\n    // Set logging settings\n    m_server.set_access_channels(websocketpp::log::alevel::all);\n    m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n    // Initialize Asio\n    m_server.init_asio();\n\n    // Register handler callbacks\n    m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n    m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n    m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n}\n\nvoid print_server::on_open(connection_hdl hdl) {\n    connection_data data;\n    data.sessionid = m_next_sessionid++;\n    data.name = \"unnamed\";\n\n    m_connections[hdl] = data;\n\n    std::cout << \"new connection: \" << data.sessionid << std::endl;\n}\n\nvoid print_server::on_close(connection_hdl hdl) {\n    auto it = m_connections.find(hdl);\n    if (it != m_connections.end()) {\n        std::cout << \"closing connection: \" << it->second.sessionid << std::endl;\n        m_connections.erase(it);\n    }\n}\n\nvoid print_server::on_message(connection_hdl hdl, message_ptr msg) {\n    connection_data &data = get_data_from_hdl(hdl);\n\n    std::string payload = msg->get_payload();\n    \n    if (payload.substr(0,5) == \"name:\") {\n        data.name = payload.substr(5);\n        std::cout << \"session \" << data.sessionid << \" named to \" << data.name << std::endl;\n    } else {\n        std::cout << \"session \" << data.sessionid << \" (\" << data.name << \") said: \" << payload << std::endl;\n    }\n}\n\nconnection_data& print_server::get_data_from_hdl(connection_hdl hdl) {\n    auto it = m_connections.find(hdl);\n    if (it == m_connections.end()) {\n        throw std::runtime_error(\"Invalid connection handle\");\n    }\n    return it->second;\n}\n\nvoid print_server::run(uint16_t port) {\n    // Listen on port\n    m_server.listen(port);\n\n    // Start the server accept loop\n    m_server.start_accept();\n\n    // Start the ASIO io_service run loop\n    m_server.run();\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication.\n- m_connections: [con_list] - A set of active connection handles to keep track of connected clients.\n\nMethods:\n- broadcast_server(): [Constructor]() -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events (open, close, message).\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handler for new client connections; adds the connection handle to the active connections set.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handler for client disconnections; removes the connection handle from the active connections set.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Handler for incoming messages; broadcasts the received message to all connected clients.\n- run: [void]([uint16_t port]) -> [void] - Starts the server, begins listening on the specified port, and enters the event loop to handle connections and messages.",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n                \n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n    \n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        con_list::iterator it;\n        for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_type;\n\nclass broadcast_server {\npublic:\n    typedef server_type::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n\n        m_server.set_close_handler([this](connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](connection_hdl hdl, server_type::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server_type::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server_type m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        con_list::iterator it;\n        for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        con_list::iterator it;\n        for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        con_list::iterator it;\n        for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl, server::message_ptr msg) {\n        con_list::iterator it;\n        for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_type;\n\nclass broadcast_server {\npublic:\n    typedef server_type::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n\n        m_server.set_close_handler([this](connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](connection_hdl hdl, server_type::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server_type::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server_type m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        con_list::iterator it;\n        for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        con_list::iterator it;\n        for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    typedef std::set<connection_hdl, std::owner_less<connection_hdl>> con_list;\n\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        con_list::iterator it;\n        for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections and echo back received messages.\n\nClass Description: The utility_server class encapsulates a WebSocket server that listens for incoming connections, receives messages from clients, and echoes them back. It uses WebSocket++ with ASIO for network handling.\n\nAttributes:\n- m_endpoint: [server] - The WebSocket++ server instance that manages connections and message handling.\n\nMethods:\n- utility_server() - [Constructor] -> [void] - Initializes the server with logging settings, ASIO, and sets up the message handler.\n- echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by echoing them back to the client.\n- run() -> [void] - Starts the server, begins listening on port 9002, and runs the ASIO event loop.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <functional>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n         // Set logging settings\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all ^ websocketpp::log::alevel::frame_payload);\n\n        // Initialize Asio\n        m_endpoint.init_asio();\n\n        // Set the default message handler to the echo handler\n        m_endpoint.set_message_handler(std::bind(\n            &utility_server::echo_handler, this,\n            std::placeholders::_1, std::placeholders::_2\n        ));\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        // write a new message\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        // Listen on port 9002\n        m_endpoint.listen(9002);\n\n        // Queues a connection accept operation\n        m_endpoint.start_accept();\n\n        // Start the Asio io_service run loop\n        m_endpoint.run();\n    }\nprivate:\n    server m_endpoint;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->echo_handler(hdl, msg);\n        });\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->echo_handler(hdl, msg);\n        });\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler(\n            [this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n                this->echo_handler(hdl, msg);\n            }\n        );\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->echo_handler(hdl, msg);\n        });\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->echo_handler(hdl, msg);\n        });\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->echo_handler(hdl, msg);\n        });\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->echo_handler(hdl, msg);\n        });\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->echo_handler(hdl, msg);\n        });\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);\n\n        m_endpoint.init_asio();\n\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->echo_handler(hdl, msg);\n        });\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ using the WebSocket++ library to handle client connections, process incoming messages, and manage server events.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, providing methods to initialize, configure, and run the server. It handles WebSocket connections, processes messages, and manages various server events like HTTP requests, connection failures, and closures.\n\nAttributes:\n- m_server: [websocketpp::server<websocketpp::config::debug_asio>] - The main WebSocket++ server instance that manages connections and events.\n\nMethods:\n- WebSocketServer() -> [Constructor] - Initializes the server with default settings, configures logging, sets up ASIO, and registers event handlers.\n- run(int port) -> [void] - Starts the server on the specified port, begins accepting connections, and runs the event loop.\n- validate(websocketpp::connection_hdl hdl) -> [bool] - Validates incoming connections (always returns true in this implementation).\n- on_http(websocketpp::connection_hdl hdl) -> [void] - Handles HTTP requests received by the server.\n- on_fail(websocketpp::connection_hdl hdl) -> [void] - Handles connection failure events.\n- on_close(websocketpp::connection_hdl hdl) -> [void] - Handles connection closure events.\n- on_message(websocketpp::connection_hdl hdl, message_ptr msg) -> [void] - Processes incoming WebSocket messages and echoes them back to the client.",
    "Canonical_solution": "#include <websocketpp/config/debug_asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/logger/syslog.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass WebSocketServer {\npublic:\n    typedef websocketpp::server<websocketpp::config::debug_asio> server;\n    typedef server::message_ptr message_ptr;\n\n    WebSocketServer() {\n        // Set logging settings\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        // Initialize ASIO\n        m_server.init_asio();\n        m_server.set_reuse_addr(true);\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, ::_1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, ::_1));\n        m_server.set_validate_handler(bind(&WebSocketServer::validate, this, ::_1));\n    }\n\n    void run(int port) {\n        try {\n            // Listen on specified port\n            m_server.listen(port);\n\n            // Start the server accept loop\n            m_server.start_accept();\n\n            // Start the ASIO io_service run loop\n            m_server.run();\n        } catch (websocketpp::exception const & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::string res = con->get_request_body();\n        std::stringstream ss;\n        ss << \"got HTTP request with \" << res.size() << \" bytes of body data.\";\n        con->set_body(ss.str());\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Fail handler: \" << con->get_ec() << \" \" << con->get_ec().message() << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Close handler\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \" \n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_hdl(std::bind(&WebSocketServer::validate, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"HTTP body response\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_hdl(std::bind(&WebSocketServer::validate, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"HTTP endpoint\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_hdl(std::bind(&WebSocketServer::validate, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"HTTP body\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->send(msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_handler(websocketpp::lib::bind(&WebSocketServer::validate, this, websocketpp::lib::placeholders::_1));\n        m_server.set_http_handler(websocketpp::lib::bind(&WebSocketServer::on_http, this, websocketpp::lib::placeholders::_1));\n        m_server.set_fail_handler(websocketpp::lib::bind(&WebSocketServer::on_fail, this, websocketpp::lib::placeholders::_1));\n        m_server.set_close_handler(websocketpp::lib::bind(&WebSocketServer::on_close, this, websocketpp::lib::placeholders::_1));\n        m_server.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message, this, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"HTTP request from \" << con->get_remote_endpoint() << std::endl;\n        con->set_body(\"Hello World!\");\n        con->response_ready();\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_hdl(std::bind(&WebSocketServer::validate, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"HTTP endpoint response\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_hdl(std::bind(&WebSocketServer::validate, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"HTTP endpoint\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_hdl(std::bind(&WebSocketServer::validate, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"HTTP body response\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        // Handle failure\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        // Handle connection close\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->send(msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_hdl(std::bind(&WebSocketServer::validate, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"HTTP body\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_handler([this](websocketpp::connection_hdl hdl) {\n            return this->validate(hdl);\n        });\n\n        m_server.set_http_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_http(hdl);\n        });\n\n        m_server.set_fail_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_fail(hdl);\n        });\n\n        m_server.set_close_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received.\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed.\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed.\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::cout << \"Message received: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/debug_asio.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::debug_asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_validate_hdl(std::bind(&WebSocketServer::validate, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"HTTP endpoint\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Connection failed: \" << con->get_state() << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->send(msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that supports secure TLS connections and handles both WebSocket and HTTP requests.\n\nClass Description: The WebSocketServer class encapsulates a secure WebSocket server implementation using WebSocket++ with ASIO and TLS support. It handles incoming connections, processes messages, and manages secure communication settings.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that manages connections and communication\n- tls_mode: [enum] - Enumeration defining TLS security modes (MOZILLA_INTERMEDIATE, MOZILLA_MODERN)\n\nMethods:\n- WebSocketServer() -> [constructor] - Initializes the server, sets up ASIO, and registers handler functions\n- run([int port]) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_message([websocketpp::connection_hdl hdl, message_ptr msg]) -> [void] - Handles incoming WebSocket messages by echoing them back to the client\n- on_http([websocketpp::connection_hdl hdl]) -> [void] - Handles HTTP requests by returning a simple \"Hello World!\" response\n- get_password() -> [std::string] - Returns the password used for TLS certificate encryption\n- on_tls_init([tls_mode mode, websocketpp::connection_hdl hdl]) -> [context_ptr] - Initializes and configures TLS/SSL context with appropriate security settings based on the specified mode",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/lib/asio.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\ntypedef websocketpp::config::asio::message_type::ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        // Initialize ASIO\n        m_server.init_asio();\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, MOZILLA_INTERMEDIATE, ::_1));\n    }\n\n    void run(int port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start the server accept loop\n        m_server.start_accept();\n\n        // Start the ASIO io_service run loop\n        m_server.run();\n    }\n\nprivate:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE = 1,\n        MOZILLA_MODERN = 2\n    };\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        namespace asio = websocketpp::lib::asio;\n\n        context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_MODERN) {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::no_tlsv1 |\n                                 asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::single_dh_use);\n            }\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dh.pem\");\n            \n            std::string ciphers = (mode == MOZILLA_MODERN) ? \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\" : \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\";\n            \n            if (SSL_CTX_set_cipher_list(ctx->native_handle(), ciphers.c_str()) != 1) {\n                std::cout << \"Error setting cipher list\" << std::endl;\n            }\n        } catch (std::exception& e) {\n            std::cout << \"Exception: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network_utils.hpp>\n\n#include <boost/asio/ssl.hpp>\n\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    typedef server::message_ptr message_ptr;\n    typedef boost::shared_ptr<boost::asio::ssl::context> context_ptr;\n\n    WebSocketServer() : m_server(), tls_mode(MOZILLA_INTERMEDIATE) {\n        m_server.init_asio();\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        m_server.set_http_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_http(hdl);\n        });\n\n        m_server.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return this->on_tls_init(tls_mode, hdl);\n        });\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl, message_ptr msg) {\n        // Echo message back to the client\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->set_password_callback([this](std::size_t, boost::asio::ssl::context::password_purpose) -> std::string {\n                return this->get_password();\n            });\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n        } catch (std::exception& e) {\n            std::cerr << \"TLS init failed: \" << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n    tls_mode tls_mode;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network_utils.hpp>\n\n#include <boost/beast/websocket/impl/host.ipp>\n#include <boost/asio/ssl.hpp>\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <functional>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    typedef server::message_ptr message_ptr;\n    typedef boost::asio::ssl::context context_type;\n    typedef std::shared_ptr<context_type> context_ptr;\n\n    WebSocketServer() : m_server(), tls_mode(MOZILLA_INTERMEDIATE) {\n        m_server.init_asio();\n\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n\n        m_server.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, tls_mode, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl) {\n        context_ptr ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->check_password_callback(std::bind(&WebSocketServer::get_password, this));\n\n            std::string dh_params = \"dh2048.pem\";\n            SSL_CTX_set_options(ctx->native_handle(), SSL_OP_SINGLE_DH_USE);\n            FILE* paramfile = fopen(dh_params.c_str(), \"r\");\n            if (paramfile) {\n                DH* dh = PEM_read_DHparams(paramfile, NULL, NULL, NULL);\n                fclose(paramfile);\n                if (dh) {\n                    SSL_CTX_set_tmp_dh(ctx->native_handle(), dh);\n                    DH_free(dh);\n                }\n            }\n\n            std::vector<std::string> ciphers;\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ciphers = {\n                    \"ECDHE-RSA-AES128-GCM-SHA256\",\n                    \"ECDHE-ECDSA-AES128-GCM-SHA256\",\n                    \"ECDHE-RSA-AES256-GCM-SHA384\",\n                    \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n                    \"DHE-RSA-AES128-GCM-SHA256\",\n                    \"ECDHE-RSA-AES128-SHA256\",\n                    \"ECDHE-ECDSA-AES128-SHA256\",\n                    \"ECDHE-RSA-AES256-SHA384\",\n                    \"ECDHE-ECDSA-AES256-SHA384\",\n                    \"ECDHE-RSA-DES-CBC3-SHA\",\n                    \"ECDH-RSA-AES128-GCM-SHA256\",\n                    \"ECDH-ECDSA-AES128-GCM-SHA256\",\n                    \"ECDH-RSA-AES256-GCM-SHA384\",\n                    \"ECDH-ECDSA-AES256-GCM-SHA384\",\n                    \"AES128-GCM-SHA256\",\n                    \"AES256-GCM-SHA384\"\n                };\n            } else {\n                ciphers = {\n                    \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n                    \"ECDHE-RSA-AES256-GCM-SHA384\",\n                    \"ECDHE-ECDSA-CHACHA20-POLY1305\",\n                    \"ECDHE-RSA-CHACHA20-POLY1305\",\n                    \"ECDHE-ECDSA-AES128-GCM-SHA256\",\n                    \"ECDHE-RSA-AES128-GCM-SHA256\"\n                };\n            }\n\n            std::string ciphertxt;\n            for (auto it = ciphers.begin(); it != ciphers.end(); ++it) {\n                if (it != ciphers.begin()) ciphertxt += \":\";\n                ciphertxt += *it;\n            }\n\n            if (SSL_CTX_set_cipher_list(ctx->native_handle(), ciphertxt.c_str()) != 1) {\n                throw std::runtime_error(\"Failed to set cipher list\");\n            }\n\n        } catch (std::exception& e) {\n            std::cout << \"TLS init failed: \" << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n    tls_mode tls_mode;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network_utils.hpp>\n\n#include <boost/asio/ssl.hpp>\n\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    typedef server::message_ptr message_ptr;\n    typedef boost::shared_ptr<boost::asio::ssl::context> context_ptr;\n\n    WebSocketServer() {\n        m_server.init_asio();\n\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, _1));\n\n        m_server.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, MOZILLA_INTERMEDIATE, _1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dh4096.pem\");\n\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            }\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network_utils.hpp>\n\n#include <boost/asio/ssl.hpp>\n\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    typedef server::message_ptr message_ptr;\n    typedef boost::asio::ssl::context context_type;\n\n    WebSocketServer() {\n        m_server.init_asio();\n\n        m_server.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(websocketpp::lib::bind(&WebSocketServer::on_http, this, ::_1));\n\n        m_server.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, MOZILLA_INTERMEDIATE, ::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    context_type::pointer on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        context_type::pointer ctx = websocketpp::lib::make_shared<context_type>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback(websocketpp::lib::bind(&WebSocketServer::get_password, this));\n\n            std::vector<unsigned char> dh_params;\n            if (!SSL_CTX_get_dh_params(ctx->native_handle(), dh_params.data(), dh_params.size())) {\n                DH* dh = DH_new();\n                FILE* paramfile = fopen(\"dhparams.pem\", \"r\");\n                PEM_read_DHparams(paramfile, &dh, NULL, NULL);\n                fclose(paramfile);\n\n                SSL_CTX_set_tmp_dh(ctx->native_handle(), dh);\n                DH_free(dh);\n            }\n\n            if (mode == MOZILLA_INTERMEDIATE) {\n                SSL_CTX_set_cipher_list(ctx->native_handle(), \"HIGH:!aNULL:!MD5\");\n            } else {\n                SSL_CTX_set_cipher_list(ctx->native_handle(), \"ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384\");\n            }\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network_utils.hpp>\n\n#include <boost/asio/ssl.hpp>\n\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    typedef server::message_ptr message_ptr;\n    typedef boost::shared_ptr<boost::asio::ssl::context> context_ptr;\n\n    WebSocketServer() : m_server(), tls_mode(MOZILLA_INTERMEDIATE) {\n        m_server.init_asio();\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        m_server.set_http_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_http(hdl);\n        });\n\n        m_server.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return this->on_tls_init(tls_mode, hdl);\n        });\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else if (mode == MOZILLA_MODERN) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback([this](std::size_t max_length, boost::asio::ssl::context::password_purpose purpose) {\n                return this->get_password();\n            });\n\n            std::vector<std::string> ciphers;\n\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ciphers.push_back(\"ECDHE-RSA-AES128-GCM-SHA256\");\n                ciphers.push_back(\"ECDHE-ECDSA-AES128-GCM-SHA256\");\n                ciphers.push_back(\"ECDHE-RSA-AES256-GCM-SHA384\");\n                ciphers.push_back(\"ECDHE-ECDSA-AES256-GCM-SHA384\");\n                ciphers.push_back(\"DHE-RSA-AES128-GCM-SHA256\");\n                ciphers.push_back(\"ECDHE-RSA-AES128-SHA256\");\n                ciphers.push_back(\"ECDHE-ECDSA-AES128-SHA256\");\n                ciphers.push_back(\"ECDHE-RSA-AES256-SHA384\");\n                ciphers.push_back(\"ECDHE-ECDSA-AES256-SHA384\");\n                ciphers.push_back(\"ECDHE-RSA-AES128-SHA\");\n                ciphers.push_back(\"ECDHE-ECDSA-AES128-SHA\");\n                ciphers.push_back(\"ECDHE-RSA-AES256-SHA\");\n                ciphers.push_back(\"ECDHE-ECDSA-AES256-SHA\");\n                ciphers.push_back(\"DHE-RSA-AES128-SHA256\");\n                ciphers.push_back(\"DHE-RSA-AES128-SHA\");\n                ciphers.push_back(\"DHE-RSA-AES256-SHA256\");\n                ciphers.push_back(\"DHE-RSA-AES256-SHA\");\n            } else if (mode == MOZILLA_MODERN) {\n                ciphers.push_back(\"ECDHE-ECDSA-AES256-GCM-SHA384\");\n                ciphers.push_back(\"ECDHE-DSS-AES256-GCM-SHA384\");\n                ciphers.push_back(\"ECDHE-RSA-AES256-GCM-SHA384\");\n                ciphers.push_back(\"ECDHE-ECDSA-CHACHA20-POLY1305\");\n                ciphers.push_back(\"ECDHE-RSA-CHACHA20-POLY1305\");\n                ciphers.push_back(\"ECDHE-ECDSA-AES128-GCM-SHA256\");\n                ciphers.push_back(\"ECDHE-RSA-AES128-GCM-SHA256\");\n            }\n\n            SSL_CTX_set_cipher_list(ctx->native_handle(), join_ciphers(ciphers).c_str());\n\n            std::string dh_params = read_file(\"dh2048.pem\");\n            const char * dh_buf = dh_params.c_str();\n            BIO * bio = BIO_new_mem_buf((void*)dh_buf, -1);\n            DH * dh = PEM_read_bio_DHparams(bio, NULL, 0, 0);\n            BIO_free(bio);\n\n            if (SSL_CTX_set_tmp_dh(ctx->native_handle(), dh) != 1) {\n                throw std::runtime_error(\"Error setting temporary DH parameters\");\n            }\n\n            DH_free(dh);\n        } catch (std::exception& e) {\n            std::cout << \"Exception: \" << e.what() << \"\\n\";\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n    tls_mode tls_mode;\n\n    std::string join_ciphers(const std::vector<std::string>& ciphers) const {\n        std::string result;\n        for (size_t i = 0; i < ciphers.size(); ++i) {\n            result += ciphers[i];\n            if (i != ciphers.size() - 1) {\n                result += \":\";\n            }\n        }\n        return result;\n    }\n\n    std::string read_file(const std::string& filename) const {\n        std::ifstream file(filename.c_str(), std::ios::in | std::ios::binary | std::ios::ate);\n        if (!file.is_open()) {\n            return \"\";\n        }\n\n        std::streampos size = file.tellg();\n        std::string buffer;\n        buffer.resize(size);\n\n        file.seekg(0, std::ios::beg);\n        file.read(&buffer[0], size);\n        file.close();\n\n        return buffer;\n    }\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network_utils.hpp>\n\n#include <boost/beast/websocket/impl/host.ipp>\n\n#include <iostream>\n#include <string>\n#include <vector>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    typedef server::message_ptr message_ptr;\n    typedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;\n\n    WebSocketServer() {\n        m_server.init_asio();\n\n        m_server.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(websocketpp::lib::bind(&WebSocketServer::on_http, this, ::_1));\n\n        m_server.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, MOZILLA_INTERMEDIATE, ::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"Message received: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else if (mode == MOZILLA_MODERN) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->password_callback(websocketpp::lib::bind(&WebSocketServer::get_password, this));\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        m_server.set_http_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_http(hdl);\n        });\n        m_server.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return this->on_tls_init(MOZILLA_INTERMEDIATE, hdl);\n        });\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    boost::shared_ptr<boost::asio::ssl::context> on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        boost::shared_ptr<boost::asio::ssl::context> ctx = boost::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else if (mode == MOZILLA_MODERN) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->check_password(get_password().c_str());\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n        m_server.set_http_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_http(hdl);\n        });\n        m_server.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return this->on_tls_init(MOZILLA_INTERMEDIATE, hdl);\n        });\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    boost::shared_ptr<boost::asio::ssl::context> on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        namespace asio = boost::asio;\n        asio::ssl::context::method ssl_method = asio::ssl::context::sslv23;\n        \n        switch(mode) {\n            case MOZILLA_INTERMEDIATE:\n                ssl_method = asio::ssl::context::tlsv12;\n                break;\n            case MOZILLA_MODERN:\n                ssl_method = asio::ssl::context::tlsv13;\n                break;\n        }\n        \n        boost::shared_ptr<asio::ssl::context> ctx = boost::make_shared<asio::ssl::context>(ssl_method);\n\n        try {\n            ctx->set_options(asio::ssl::context::default_workarounds |\n                             asio::ssl::context::no_sslv2 |\n                             asio::ssl::context::no_sslv3 |\n                             asio::ssl::context::single_dh_use);\n            \n            ctx->set_password_callback([this](std::size_t max_length, boost::asio::ssl::context::password_purpose purpose) {\n                return this->get_password();\n            });\n            \n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n            \n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_cipher_list(\"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK\");\n            } else if (mode == MOZILLA_MODERN) {\n                ctx->set_cipher_list(\"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\");\n                ctx->set_protocol_options(asio::ssl::context::op_no_sslv3 | asio::ssl::context::op_no_tlsrv1 | asio::ssl::context::op_no_tlsrv1_1);\n            }\n        } catch (std::exception& e) {\n            std::cout << \"Error in TLS init: \" << e.what() << std::endl;\n        }\n        \n        return ctx;\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network_utils.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    WebSocketServer() : m_server(), tls_mode(MOZILLA_INTERMEDIATE) {\n        m_server.init_asio();\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        m_server.set_http_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_http(hdl);\n        });\n\n        m_server.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return this->on_tls_init(tls_mode, hdl);\n        });\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    boost::shared_ptr<boost::asio::ssl::context> on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        boost::shared_ptr<boost::asio::ssl::context> ctx = boost::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else if (mode == MOZILLA_MODERN) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback([this](std::size_t max_length, boost::asio::ssl::context::password_purpose purpose) {\n                return get_password();\n            });\n\n            std::string dhFile = \"dh2048.pem\";\n            FILE* dhFilePtr = fopen(dhFile.c_str(), \"r\");\n            if (dhFilePtr) {\n                DH* dh = PEM_read_DHparams(dhFilePtr, NULL, 0, 0);\n                fclose(dhFilePtr);\n                if (dh != 0) {\n                    SSL_CTX_set_tmp_dh(ctx->native_handle(), dh);\n                    DH_free(dh);\n                }\n            }\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n    tls_mode tls_mode;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/network.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\n    WebSocketServer() : m_server(), tls_mode(MOZILLA_INTERMEDIATE) {\n        m_server.init_asio();\n\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n\n        m_server.set_http_handler([this](websocketpp::connection_hdl hdl) {\n            this->on_http(hdl);\n        });\n\n        m_server.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return this->on_tls_init(tls_mode, hdl);\n        });\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    boost::shared_ptr<boost::asio::ssl::context> on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        boost::shared_ptr<boost::asio::ssl::context> ctx = boost::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_INTERMEDIATE) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv2 |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::single_dh_use);\n            } else if (mode == MOZILLA_MODERN) {\n                ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                                 boost::asio::ssl::context::no_sslv3 |\n                                 boost::asio::ssl::context::no_tlsv1 |\n                                 boost::asio::ssl::context::no_tlsv1_1 |\n                                 boost::asio::ssl::context::single_dh_use);\n            }\n\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback([this](std::size_t max_length, boost::asio::ssl::context::password_purpose purpose) {\n                return get_password();\n            });\n\n            std::string dhFile = \"dh2048.pem\";\n            FILE* dhFileF = fopen(dhFile.c_str(), \"r\");\n\n            if (dhFileF) {\n                DH* dh = PEM_read_DHparams(dhFileF, NULL, 0, 0);\n                fclose(dhFileF);\n\n                if (dh != 0) {\n                    SSL_CTX_set_tmp_dh(ctx->native_handle(), dh);\n                    DH_free(dh);\n                }\n            }\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    server m_server;\n    tls_mode tls_mode;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Implement a WebSocket broadcast server in C++ using the WebSocket++ library that can handle multiple client connections, manage subscriptions, and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and can broadcast messages to all connected clients. It handles connection events (open/close) and message events using a thread-safe action queue system.\n\nAttributes:\n- m_server: [server] - WebSocket++ server instance configured with ASIO\n- m_connections: [con_list] - Set of active WebSocket connection handles\n- m_actions: [std::queue<action>] - Queue of pending actions to process\n- m_action_lock: [mutex] - Mutex for protecting access to the action queue\n- m_connection_lock: [mutex] - Mutex for protecting access to the connections set\n- m_action_cond: [condition_variable] - Condition variable for action queue notification\n\nMethods:\n- broadcast_server() -> [constructor] - Initializes the WebSocket server and sets up event handlers\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_open(connection_hdl hdl) -> [void] - Handler for new WebSocket connections (adds SUBSCRIBE action)\n- on_close(connection_hdl hdl) -> [void] - Handler for closed WebSocket connections (adds UNSUBSCRIBE action)\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handler for incoming messages (adds MESSAGE action)\n- process_messages() -> [void] - Processes actions from the queue (manages subscriptions and broadcasts messages)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/thread.hpp>\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\nusing websocketpp::lib::thread;\nusing websocketpp::lib::mutex;\nusing websocketpp::lib::lock_guard;\nusing websocketpp::lib::unique_lock;\nusing websocketpp::lib::condition_variable;\n\nenum action_type {\n    SUBSCRIBE,\n    UNSUBSCRIBE,\n    MESSAGE\n};\n\nstruct action {\n    action(action_type t, connection_hdl h) : type(t), hdl(h) {}\n    action(action_type t, connection_hdl h, server::message_ptr m)\n      : type(t), hdl(h), msg(m) {}\n\n    action_type type;\n    websocketpp::connection_hdl hdl;\n    server::message_ptr msg;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        try {\n            m_server.run();\n        } catch (const std::exception & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\n    void on_open(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(SUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(UNSUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(MESSAGE,hdl,msg));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while(1) {\n            unique_lock<mutex> lock(m_action_lock);\n            while(m_actions.empty()) {\n                m_action_cond.wait(lock);\n            }\n\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.type == SUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.type == UNSUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.type == MESSAGE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                con_list::iterator it;\n                for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n                    m_server.send(*it,a.msg);\n                }\n            }\n        }\n    }\n\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl> > con_list;\n    server m_server;\n    con_list m_connections;\n    std::queue<action> m_actions;\n    mutex m_action_lock;\n    mutex m_connection_lock;\n    condition_variable m_action_cond;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server() : m_server(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.init_asio();\n\n        m_server.set_open_handler([this](connection_hdl hdl) {\n            this->on_open(hdl);\n        });\n\n        m_server.set_close_handler([this](connection_hdl hdl) {\n            this->on_close(hdl);\n        });\n\n        m_server.set_message_handler([this](connection_hdl hdl, server_t::message_ptr msg) {\n            this->on_message(hdl, msg);\n        });\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n\n        std::thread processing_thread(&broadcast_server::process_messages, this);\n        m_server.run();\n        processing_thread.join();\n    }\n\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push(action{SUBSCRIBE, hdl, nullptr});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push(action{UNSUBSCRIBE, hdl, nullptr});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server_t::message_ptr msg) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push(action{MESSAGE, hdl, msg});\n        m_action_cond.notify_one();\n    }\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n\n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    struct con_list {\n        std::set<connection_hdl> connections;\n    };\n\n    server_t m_server;\n    con_list m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this]() { return !m_actions.empty(); });\n\n            while (!m_actions.empty()) {\n                action a = m_actions.front();\n                m_actions.pop();\n                lock.unlock();\n\n                switch (a.type) {\n                    case SUBSCRIBE:\n                        {\n                            std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                            m_connections.connections.insert(a.hdl);\n                        }\n                        break;\n                    case UNSUBSCRIBE:\n                        {\n                            std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                            m_connections.connections.erase(a.hdl);\n                        }\n                        break;\n                    case MESSAGE:\n                        {\n                            std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                            for (auto it : m_connections.connections) {\n                                m_server.send(it, a.msg);\n                            }\n                        }\n                        break;\n                }\n\n                lock.lock();\n            }\n            lock.unlock();\n        }\n    }\n};"
    ],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(server_t* s, websocketpp::connection_hdl hdl);\n    void on_close(server_t* s, websocketpp::connection_hdl hdl);\n    void on_message(server_t* s, websocketpp::connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    \n    struct action {\n        action_type type;\n        websocketpp::connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n    \n    server_t m_server;\n    std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    \n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_t;\n\nclass broadcast_server {\npublic:\n    typedef server_t::connection_ptr connection_ptr;\n    typedef websocketpp::connection_hdl connection_hdl;\n\n    broadcast_server();\n    void run(uint16_t port);\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server_t::message_ptr msg);\n    void process_actions();\n\nprivate:\n    enum action_type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    struct action {\n        action_type type;\n        connection_hdl hdl;\n        server_t::message_ptr msg;\n    };\n\n    server_t m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a C++ class that provides HTTP request functionality using libcurl, supporting both file and network resource retrieval.\n\nClass Description: HttpWebRequest is a class that encapsulates HTTP request functionality, allowing users to make GET requests to either network resources (via HTTP) or local files (via file:// protocol). It handles request configuration, execution, and response processing.\n\nAttributes:\n- uri_: std::string - The target URI for the HTTP request\n- method_: std::string - The HTTP method to use (defaults to GET)\n- header_: std::map<std::string, std::string> - HTTP headers to include in the request\n- is_: std::iostream - Internal stream used for request processing\n\nMethods:\n- HttpWebRequest(std::string &uri) -> void - Constructor that initializes the request with a target URI\n- callback(void *buffer, size_t size, size_t nmemb, void *data) -> static size_t - Static callback function for libcurl to write response data\n- GetFileResponse(const char *uri) -> HttpWebResponse* - Handles file:// protocol requests and returns the file content as a response\n- GetNetResponse(const char *uri) -> HttpWebResponse* - Performs HTTP network requests using libcurl and returns the response\n- GetResponse() -> HttpWebResponse* - Main method that determines request type (file or network) and returns the appropriate response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <fstream>\n\nnamespace System {\nnamespace Net {\n\nclass HttpWebRequest {\npublic:\n    HttpWebRequest(std::string &uri)\n        : is_(std::ios_base::in | std::ios_base::out | std::ios_base::binary) {\n        uri_ = uri;\n        method_ = HttpWebRequest::Method::GET;\n    }\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        HttpWebResponse *resp = (HttpWebResponse *) data;\n        std::stringstream &ss = resp->GetResponseStream();\n        ss.write((char *) buffer, size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse *GetFileResponse(const char *uri) {\n        assert(strlen(uri) > 6);\n        HttpWebResponse *resp = new HttpWebResponse();\n        const char *filename = uri + 6;\n\n        std::ifstream file;\n        file.open(filename);\n        if (file.is_open()) {\n            resp->os_ << file.rdbuf();\n            file.close();\n        }\n\n        return resp;\n    }\n\n    HttpWebResponse *GetNetResponse(const char *uri) {\n        HttpWebResponse *resp = new HttpWebResponse();\n\n        CURL *curl = curl_easy_init();\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n\n        curl_slist *http_headers = NULL;\n        for (std::map<std::string, std::string>::iterator it = header_.begin();\n             it != header_.end(); it++) {\n            http_headers = curl_slist_append(http_headers,\n                                             (it->first + \":\" + it->second).c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, http_headers);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) resp);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 2);\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 2);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\n        curl_easy_perform(curl);\n\n        long retcode = 0;\n        CURLcode code = curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &retcode);\n        if (code == CURLE_OK && retcode == 200) {\n            resp->status_.SetCode(200);\n\n            char *ctype = NULL;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &ctype);\n            std::string type(ctype);\n            resp->header_.Put(HttpHeader::ContentType, type);\n\n            double length = 0;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &length);\n            std::ostringstream os;\n            os << (long) length;\n            resp->header_.Put(HttpHeader::ContentLength, os.str());\n        }\n\n        curl_slist_free_all(http_headers);\n        curl_easy_cleanup(curl);\n\n        return resp;\n    }\n\n    HttpWebResponse *GetResponse() {\n        const char *uri = uri_.c_str();\n        if (strncmp(uri, \"file://\", 7) == 0) {\n            return GetFileResponse(uri);\n        }\n        return GetNetResponse(uri);\n    }\n\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n};\n\n}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int statusCode;\n    std::map<std::string, std::string> headers;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> headers_;\n    std::iostream is_;\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(nullptr) {}\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        std::ostream *stream = (std::ostream *)data;\n        size_t realsize = size * nmemb;\n        stream->write((char*)buffer, realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse *response = new HttpWebResponse();\n        std::string path = std::string(uri).substr(7); // Remove file://\n        std::ifstream file(path, std::ios::in | std::ios::binary);\n        if (file) {\n            std::ostringstream contentStream;\n            contentStream << file.rdbuf();\n            response->content = contentStream.str();\n            response->statusCode = 200;\n        } else {\n            response->statusCode = 404;\n        }\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse *response = new HttpWebResponse();\n        CURL *curl = curl_easy_init();\n        if (!curl) {\n            return response;\n        }\n\n        struct curl_slist *headerList = NULL;\n        for (auto const &header : headers_) {\n            std::string headerStr = header.first + \": \" + header.second;\n            headerList = curl_slist_append(headerList, headerStr.c_str());\n        }\n\n        std::ostringstream *oss = new std::ostringstream();\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, method_.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, oss);\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerList);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res == CURLE_OK) {\n            response->content = oss->str();\n            long httpCode = 0;\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);\n            response->statusCode = static_cast<int>(httpCode);\n        } else {\n            response->statusCode = 500;\n        }\n\n        curl_slist_free_all(headerList);\n        curl_easy_cleanup(curl);\n        delete oss;\n        return response;\n    }\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    long statusCode;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        std::ostream *o = static_cast<std::ostream *>(data);\n        const char *cbuf = static_cast<const char *>(buffer);\n        o->write(cbuf, size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string path(uri + 7); // Skip \"file://\"\n        std::ifstream file(path, std::ios::in | std::ios::binary);\n        if (file) {\n            response->statusCode = 200;\n            std::ostringstream oss;\n            oss << file.rdbuf();\n            response->content = oss.str();\n        } else {\n            response->statusCode = 404;\n        }\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl = curl_easy_init();\n        HttpWebResponse* response = new HttpWebResponse();\n\n        if (!curl) {\n            response->statusCode = -1;\n            return response;\n        }\n\n        struct curl_slist *headers = NULL;\n        for (auto &h : header_) {\n            headers = curl_slist_append(headers, (h.first + \": \" + h.second).c_str());\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response->content);\n        curl_easy_setopt(curl, CURLOPT_HEADERDATA, &response->content);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        if (!method_.empty()) {\n            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, method_.c_str());\n        }\n\n        if (!header_.empty() && headers) {\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n        }\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            response->statusCode = -1;\n        } else {\n            long http_code = 0;\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n            response->statusCode = http_code;\n        }\n\n        curl_easy_cleanup(curl);\n        if (headers) {\n            curl_slist_free_all(headers);\n        }\n\n        return response;\n    }\n\npublic:\n    explicit HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(nullptr) {}\n\n    void SetMethod(const std::string &method) {\n        method_ = method;\n    }\n\n    void AddHeader(const std::string &key, const std::string &value) {\n        header_[key] = value;\n    }\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int statusCode;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(nullptr) {}\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        std::string* content = (std::string*)data;\n        content->append((char*)buffer, realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string filePath = uri + 7; // Skip \"file://\"\n        FILE* file = fopen(filePath.c_str(), \"rb\");\n        if (!file) {\n            response->statusCode = 404;\n            return response;\n        }\n\n        fseek(file, 0, SEEK_END);\n        long length = ftell(file);\n        fseek(file, 0, SEEK_SET);\n\n        char* buffer = new char[length];\n        size_t bytesRead = fread(buffer, 1, length, file);\n        response->content.assign(buffer, bytesRead);\n        response->statusCode = 200;\n\n        delete[] buffer;\n        fclose(file);\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL* curl = curl_easy_init();\n        HttpWebResponse* response = new HttpWebResponse();\n\n        if (!curl) {\n            response->statusCode = 500;\n            return response;\n        }\n\n        struct curl_slist* headers = nullptr;\n        for (auto& pair : header_) {\n            std::string headerStr = pair.first + \": \" + pair.second;\n            headers = curl_slist_append(headers, headerStr.c_str());\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response->content);\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            response->statusCode = 500;\n        } else {\n            response->statusCode = 200;\n        }\n\n        if (headers) curl_slist_free_all(headers);\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    long statusCode;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        std::ostream *o = static_cast<std::ostream *>(data);\n        size_t realsize = size * nmemb;\n        o->write(static_cast<char *>(buffer), realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string filePath = std::string(uri).substr(7); // Remove \"file://\"\n        std::ifstream file(filePath, std::ios::binary);\n        if (file) {\n            std::ostringstream buffer;\n            buffer << file.rdbuf();\n            response->content = buffer.str();\n            response->statusCode = 200;\n        } else {\n            response->content = \"File not found\";\n            response->statusCode = 404;\n        }\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL *curl = curl_easy_init();\n        if (curl) {\n            std::ostringstream oss;\n            curl_easy_setopt(curl, CURLOPT_URL, uri);\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &oss);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            if (!method_.empty()) {\n                curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, method_.c_str());\n            }\n\n            if (!header_.empty()) {\n                struct curl_slist *headers = NULL;\n                for (auto const &h : header_) {\n                    headers = curl_slist_append(headers, (h.first + \": \" + h.second).c_str());\n                }\n                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n            }\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res == CURLE_OK) {\n                response->content = oss.str();\n                long http_code = 0;\n                curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n                response->statusCode = http_code;\n            } else {\n                response->content = \"Network error: \" + std::string(curl_easy_strerror(res));\n                response->statusCode = 500;\n            }\n\n            curl_easy_cleanup(curl);\n        } else {\n            response->content = \"Failed to initialize CURL\";\n            response->statusCode = 500;\n        }\n        return response;\n    }\n\npublic:\n    explicit HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(nullptr) {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n\n    void setMethod(const std::string& method) {\n        method_ = method;\n    }\n\n    void addHeader(const std::string& key, const std::string& value) {\n        header_[key] = value;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int statusCode;\n\n    HttpWebResponse(std::string content, int statusCode) : content(content), statusCode(statusCode) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        ((std::stringstream*)data)->write((char*)buffer, size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        std::ifstream file(uri + 7); // Skip \"file://\"\n        if (!file.good()) {\n            return new HttpWebResponse(\"\", 404);\n        }\n        std::stringstream buffer;\n        buffer << file.rdbuf();\n        return new HttpWebResponse(buffer.str(), 200);\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl = curl_easy_init();\n        std::stringstream responseBuffer;\n        if (!curl) {\n            return new HttpWebResponse(\"\", 500);\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &responseBuffer);\n\n        if (method_ == \"POST\") {\n            curl_easy_setopt(curl, CURLOPT_POST, 1L);\n        } else if (method_ == \"PUT\") {\n            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, \"PUT\");\n        } else if (method_ == \"DELETE\") {\n            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, \"DELETE\");\n        }\n\n        for (auto const& header : header_) {\n            std::string headerStr = header.first + \": \" + header.second;\n            struct curl_slist *headers = nullptr;\n            headers = curl_slist_append(headers, headerStr.c_str());\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n        }\n\n        CURLcode res = curl_easy_perform(curl);\n        long httpCode = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);\n        curl_easy_cleanup(curl);\n\n        if (res != CURLE_OK) {\n            return new HttpWebResponse(\"\", static_cast<int>(httpCode));\n        }\n\n        return new HttpWebResponse(responseBuffer.str(), static_cast<int>(httpCode));\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(new std::stringbuf()) {}\n\n    void SetMethod(const std::string &method) {\n        method_ = method;\n    }\n\n    void AddHeader(const std::string &key, const std::string &value) {\n        header_[key] = value;\n    }\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int statusCode;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        std::ostream *stream = (std::ostream*)data;\n        std::size_t realsize = size * nmemb;\n        stream->write((char*)buffer, realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string filePath = std::string(uri).substr(7); // Remove \"file://\"\n        std::ifstream file(filePath, std::ios::in | std::ios::binary);\n        if (file) {\n            response->statusCode = 200;\n            response->content.assign((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        } else {\n            response->statusCode = 404;\n            response->content = \"File not found\";\n        }\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl = curl_easy_init();\n        HttpWebResponse* response = new HttpWebResponse();\n\n        if (!curl) {\n            response->statusCode = -1;\n            response->content = \"Failed to initialize CURL\";\n            return response;\n        }\n\n        std::ostringstream oss;\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &oss);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res == CURLE_OK) {\n            response->content = oss.str();\n            response->statusCode = 200;\n        } else {\n            response->content = curl_easy_strerror(res);\n            response->statusCode = -1;\n        }\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(nullptr) {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int statusCode;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        std::ostream *o = static_cast<std::ostream*>(data);\n        std::size_t realsize = size * nmemb;\n        o->write(static_cast<char*>(buffer), realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string path(uri + 7); // Skip \"file://\"\n\n        std::ifstream file(path, std::ios::in | std::ios::binary);\n        if (file) {\n            response->statusCode = 200;\n            file.seekg(0, std::ios::end);\n            response->content.resize(file.tellg());\n            file.seekg(0, std::ios::beg);\n            file.read(&response->content[0], response->content.size());\n            file.close();\n        } else {\n            response->statusCode = 404;\n        }\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl = curl_easy_init();\n        HttpWebResponse* response = new HttpWebResponse();\n\n        if (curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, uri);\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &HttpWebRequest::callback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &is_);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            if (!method_.empty()) {\n                if (method_ == \"GET\") {\n                    curl_easy_setopt(curl, CURLOPT_HTTPGET, 1L);\n                }\n            }\n\n            struct curl_slist *headers = NULL;\n            for (auto const &h : header_) {\n                headers = curl_slist_append(headers, (h.first + \": \" + h.second).c_str());\n            }\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                response->statusCode = -1;\n            } else {\n                response->statusCode = 200;\n                response->content = dynamic_cast<std::ostringstream*>(&is_)->str();\n            }\n\n            curl_easy_cleanup(curl);\n            curl_slist_free_all(headers);\n        }\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(new std::ostringstream()) {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n\n    void SetMethod(const std::string& method) {\n        method_ = method;\n    }\n\n    void AddHeader(const std::string& key, const std::string& value) {\n        header_[key] = value;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int statusCode;\n    std::string statusText;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        std::ostream *o = static_cast<std::ostream*>(data);\n        char *c = static_cast<char*>(buffer);\n        o->write(c, size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string path(uri + 7); // Skip \"file://\"\n        std::ifstream file(path, std::ios::in | std::ios::binary);\n        if (file) {\n            response->statusCode = 200;\n            response->statusText = \"OK\";\n            std::ostringstream ss;\n            ss << file.rdbuf();\n            response->content = ss.str();\n        } else {\n            response->statusCode = 404;\n            response->statusText = \"Not Found\";\n        }\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL *curl = curl_easy_init();\n        if (!curl) return response;\n\n        std::ostringstream oss;\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &oss);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res == CURLE_OK) {\n            long http_code = 0;\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n            response->statusCode = static_cast<int>(http_code);\n            response->statusText = \"OK\";\n            response->content = oss.str();\n        } else {\n            response->statusCode = 500;\n            response->statusText = curl_easy_strerror(res);\n        }\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(nullptr) {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int statusCode;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        std::ostream *stream = (std::ostream*)data;\n        size_t realsize = size * nmemb;\n        stream->write((char*)buffer, realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string path = std::string(uri).substr(7); // Remove \"file://\"\n\n        std::ifstream file(path, std::ios::in | std::ios::binary);\n        if (!file) {\n            response->statusCode = 404;\n            return response;\n        }\n\n        std::ostringstream contentStream;\n        contentStream << file.rdbuf();\n        response->content = contentStream.str();\n        response->statusCode = 200;\n\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl;\n        CURLcode res;\n        std::ostringstream responseStream;\n        HttpWebResponse* response = new HttpWebResponse();\n\n        curl = curl_easy_init();\n        if (!curl) {\n            response->statusCode = 500;\n            return response;\n        }\n\n        struct curl_slist *headers = NULL;\n        for (auto const &h : header_) {\n            headers = curl_slist_append(headers, (h.first + \": \" + h.second).c_str());\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &responseStream);\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            response->statusCode = 500;\n        } else {\n            response->content = responseStream.str();\n            response->statusCode = 200;\n        }\n\n        curl_easy_cleanup(curl);\n        curl_slist_free_all(headers);\n\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : is_(nullptr), method_(\"GET\") {\n        uri_ = uri;\n    }\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int statusCode;\n\n    HttpWebResponse() : statusCode(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        std::ostream *stream = (std::ostream*)data;\n        std::size_t realsize = size * nmemb;\n        stream->write((char*)buffer, realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string path(uri + 7); // Skip \"file://\"\n\n        std::ifstream file(path, std::ios::in | std::ios::binary);\n        if (!file) {\n            response->statusCode = 404;\n            return response;\n        }\n\n        std::ostringstream contentStream;\n        contentStream << file.rdbuf();\n        response->content = contentStream.str();\n        response->statusCode = 200;\n\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl = curl_easy_init();\n        HttpWebResponse* response = new HttpWebResponse();\n\n        if (!curl) {\n            response->statusCode = 500;\n            return response;\n        }\n\n        std::ostringstream resultStream;\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &resultStream);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        if (!method_.empty()) {\n            curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, method_.c_str());\n        }\n\n        if (!header_.empty()) {\n            struct curl_slist *headers = NULL;\n            for (auto it = header_.begin(); it != header_.end(); ++it) {\n                std::string headerLine = it->first + \": \" + it->second;\n                headers = curl_slist_append(headers, headerLine.c_str());\n            }\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n        }\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res == CURLE_OK) {\n            long http_code = 0;\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n            response->statusCode = static_cast<int>(http_code);\n            response->content = resultStream.str();\n        } else {\n            response->statusCode = 500;\n        }\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    explicit HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\"), is_(nullptr) {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n\n    void setMethod(const std::string& method) {\n        method_ = method;\n    }\n\n    void addHeader(const std::string& key, const std::string& value) {\n        header_[key] = value;\n    }\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ that supports both plain and TLS (SSL) connections using the WebSocket++ library. The server should handle incoming messages, echo them back to clients, and manage secure connections with proper TLS initialization.\n\nClass Description: The WebSocketServer class encapsulates functionality for creating and managing both plain and TLS WebSocket servers. It initializes server endpoints, sets up message handlers, manages TLS contexts, and runs the server's event loop.\n\nAttributes:\n- ios_: boost::asio::io_service - ASIO I/O service for handling network operations\n- endpoint_plain_: server_plain - WebSocket++ server instance for plain (non-secure) connections\n- endpoint_tls_: server_tls - WebSocket++ server instance for TLS (secure) connections\n\nMethods:\n- init() -> void - Initializes both plain and TLS server endpoints, sets message handlers, TLS initialization handler, and starts listening on ports 80 (plain) and 443 (TLS)\n- run() -> void - Starts the server's event loop to handle connections and messages\n- on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) -> void - Template method that handles incoming messages from clients and echoes them back\n- get_password() -> std::string - Returns the password used for TLS private key encryption\n- on_tls_init(websocketpp::connection_hdl hdl) -> context_ptr - Initializes and configures the TLS context for secure connections",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(), endpoint_tls_() {}\n\n    void init() {\n        endpoint_plain_.init_asio(&ios_);\n        endpoint_plain_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, ::_1, ::_2));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.init_asio(&ios_);\n        endpoint_tls_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, ::_1, ::_2));\n        endpoint_tls_.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, ::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\nprivate:\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl,\n        typename EndpointType::message_ptr msg)\n    {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                << \" and message: \" << msg->get_payload()\n                << std::endl;\n\n        try {\n            s->send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                    << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        std::cout << \"on_tls_init called with hdl: \" << hdl.lock().get() << std::endl;\n        context_ptr ctx(new boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                            boost::asio::ssl::context::no_sslv2 |\n                            boost::asio::ssl::context::no_sslv3 |\n                            boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [],
    "unmatched_results": [
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server_tls.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\ntypedef server_plain::message_ptr message_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler([this](websocketpp::connection_hdl hdl, server_plain::message_ptr msg) {\n            on_message(&endpoint_plain_, hdl, msg);\n        });\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.set_message_handler([this](websocketpp::connection_hdl hdl, server_tls::message_ptr msg) {\n            on_message(&endpoint_tls_, hdl, msg);\n        });\n        endpoint_tls_.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return on_tls_init(hdl);\n        });\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread_group threads;\n        for (int i = 0; i < 4; ++i) {\n            threads.create_thread([this]() { ios_.run(); });\n        }\n        threads.join_all();\n    }\n\n    template<typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        s->send(hdl, payload, msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"password\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl) {\n        context_ptr ctx = context_ptr(new boost::asio::ssl::context(boost::asio::ssl::context::sslv23));\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem, get_password());\n            ctx->use_tmp_dh_file(\"dhparams.pem\");\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server_tls.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\ntypedef server_plain::message_ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_tls_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n\n        endpoint_plain_.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, websocketpp::lib::placeholders::_1));\n\n        endpoint_plain_.listen(80);\n        endpoint_tls_.listen(443);\n\n        endpoint_plain_.start_accept();\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread t1(websocketpp::lib::bind(&boost::asio::io_service::run, &ios_));\n        boost::thread t2(websocketpp::lib::bind(&boost::asio::io_service::run, &ios_));\n        t1.join();\n        t2.join();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"server\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->password_callback(websocketpp::lib::bind(&WebSocketServer::get_password, this));\n        } catch (std::exception& e) {\n            std::cerr << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\ntypedef server_tls::connection_ptr connection_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler([this](websocketpp::connection_hdl hdl, server_plain::message_ptr msg) {\n            on_message(&endpoint_plain_, hdl, msg);\n        });\n\n        endpoint_tls_.set_message_handler([this](websocketpp::connection_hdl hdl, server_tls::message_ptr msg) {\n            on_message(&endpoint_tls_, hdl, msg);\n        });\n\n        endpoint_tls_.set_tls_init_handler([this](websocketpp::connection_hdl hdl) -> context_ptr {\n            return on_tls_init(hdl);\n        });\n\n        try {\n            endpoint_plain_.listen(80);\n            endpoint_tls_.listen(443);\n        } catch (const std::exception& e) {\n            std::cerr << \"Listen error: \" << e.what() << std::endl;\n        }\n    }\n\n    void run() {\n        boost::thread_group threads;\n        for(int i = 0; i < 2; ++i) {\n            threads.create_thread([&]() { ios_.run(); });\n        }\n        threads.join_all();\n    }\n\n    template<typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"password\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback([this](std::size_t, boost::asio::ssl::context::password_purpose) -> std::string {\n                return get_password();\n            });\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS init error: \" << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_tls;\ntypedef websocketpp::server<websocketpp::config::asio_client> server_plain;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<decltype(endpoint_plain_)>, this, &endpoint_plain_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_tls_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<decltype(endpoint_tls_)>, this, &endpoint_tls_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n\n        endpoint_tls_.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, websocketpp::lib::placeholders::_1));\n\n        try {\n            endpoint_plain_.listen(80);\n            endpoint_tls_.listen(443);\n        } catch (const websocketpp::exception& e) {\n            std::cout << \"Listen error: \" << e.what() << std::endl;\n        }\n    }\n\n    void run() {\n        boost::thread t1(websocketpp::lib::bind(&server_plain::run, &endpoint_plain_));\n        boost::thread t2(websocketpp::lib::bind(&server_tls::run, &endpoint_tls_));\n        t1.join();\n        t2.join();\n    }\n\nprivate:\n    template<typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    server_tls::context_ptr on_tls_init(websocketpp::connection_hdl) {\n        server_tls::context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->password(websocketpp::lib::bind(&WebSocketServer::get_password, this));\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server_tls.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\ntypedef server_plain::message_ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_tls_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n\n        endpoint_tls_.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, websocketpp::lib::placeholders::_1));\n\n        endpoint_plain_.listen(80);\n        endpoint_tls_.listen(443);\n\n        endpoint_plain_.start_accept();\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread_group threads;\n        for (int i = 0; i < 4; ++i) {\n            threads.create_thread(boost::bind(&boost::asio::io_service::run, &ios_));\n        }\n        threads.join_all();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"password\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->password_callback(boost::bind(&WebSocketServer::get_password, this));\n        } catch (std::exception& e) {\n            std::cerr << \"Error in TLS init: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_tls_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n\n        endpoint_tls_.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, websocketpp::lib::placeholders::_1));\n\n        try {\n            endpoint_plain_.listen(80);\n            endpoint_tls_.listen(443);\n        } catch (const websocketpp::exception& e) {\n            std::cout << \"Listen error: \" << e.what() << std::endl;\n        }\n\n        endpoint_plain_.start_accept();\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread_group threads;\n        for (int i = 0; i < 4; ++i) {\n            threads.create_thread(boost::bind(&boost::asio::io_service::run, &ios_));\n        }\n        threads.join_all();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    websocketpp::lib::shared_ptr<boost::asio::ssl::context> on_tls_init(websocketpp::connection_hdl) {\n        websocketpp::lib::shared_ptr<boost::asio::ssl::context> ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback(websocketpp::lib::bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n        } catch (const std::exception& e) {\n            std::cout << \"TLS init error: \" << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_tls;\ntypedef websocketpp::server<websocketpp::config::asio_client> server_plain;\n\nclass WebSocketServer {\npublic:\n    using context_ptr = websocketpp::lib::shared_ptr<boost::asio::ssl::context>;\n\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<decltype(endpoint_plain_)>, this, &endpoint_plain_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<decltype(endpoint_tls_)>, this, &endpoint_tls_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_tls_.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, websocketpp::lib::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread_group threads;\n        for (int i = 0; i < 4; ++i) {\n            threads.create_thread([&]() { ios_.run(); });\n        }\n        threads.join_all();\n    }\n\n    template<typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"password\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->password_callback([this](std::size_t max_length, boost::asio::ssl::context::password_purpose purpose) {\n                return get_password();\n            });\n            ctx->use_tmp_dh_file(\"dhparams.pem\");\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server_tls.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\ntypedef server_plain::message_ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_tls_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n\n        endpoint_plain_.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, websocketpp::lib::placeholders::_1));\n\n        endpoint_plain_.listen(80);\n        endpoint_tls_.listen(443);\n\n        endpoint_plain_.start_accept();\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread_group threads;\n        for (int i = 0; i < 4; ++i) {\n            threads.create_thread(boost::bind(&boost::asio::io_service::run, &ios_));\n        }\n        threads.join_all();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"password\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback(websocketpp::lib::bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->load_verify_file(\"ca.pem\");\n        } catch (std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_tls.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\ntypedef server_plain::message_ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_tls_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n\n        endpoint_plain_.set_tls_init_handler(websocketpp::lib::bind([](websocketpp::connection_hdl) { return context_ptr(); }));\n        endpoint_tls_.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, _1));\n\n        endpoint_plain_.listen(80);\n        endpoint_tls_.listen(443);\n\n        endpoint_plain_.start_accept();\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread t1(websocketpp::lib::bind(&boost::asio::io_service::run, &ios_));\n        boost::thread t2(websocketpp::lib::bind(&boost::asio::io_service::run, &ios_));\n        t1.join();\n        t2.join();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem, get_password());\n            ctx->use_tmp_dh_file(\"dhparams.pem\");\n        } catch (std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server_tls.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls_ecdh_reuse> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler([this](websocketpp::connection_hdl hdl, server_plain::message_ptr msg) {\n            on_message(&endpoint_plain_, hdl, msg);\n        });\n\n        endpoint_tls_.set_message_handler([this](websocketpp::connection_hdl hdl, server_tls::message_ptr msg) {\n            on_message(&endpoint_tls_, hdl, msg);\n        });\n\n        endpoint_tls_.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return on_tls_init(hdl);\n        });\n\n        try {\n            endpoint_plain_.listen(80);\n            endpoint_tls_.listen(443);\n        } catch (const websocketpp::exception& e) {\n            std::cout << \"Listen error: \" << e.what() << std::endl;\n        }\n\n        endpoint_plain_.start_accept();\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread_group threads;\n        for(int i = 0; i < 4; ++i) {\n            threads.create_thread([&]() { ios_.run(); });\n        }\n        threads.join_all();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"test\";\n    }\n\n    server_tls::context_ptr on_tls_init(websocketpp::connection_hdl) {\n        server_tls::context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback([this](std::size_t, boost::asio::ssl::context_base::password_purpose) -> std::string {\n                return get_password();\n            });\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Implement a function that demonstrates inter-process communication between a parent and child process using pipes in C++. The function should create a pipe, fork a child process, and have the parent process write data to the pipe while the child process reads and displays the data.\n\nFunction Description: The function `pipe_communication` sets up a pipe for communication between a parent and child process. The parent process writes a string to the pipe, and the child process reads and prints the data. The function handles pipe creation, process forking, and proper cleanup of file descriptors.\n\nInput: None\n\nOutput: None (The function prints messages to stdout indicating the progress and results of the pipe communication:\n- \"pipe create error\" if pipe creation fails\n- \"Read data from the pipe is [data]\" from the child process\n- \"Write data [data]\" and \"Parent write over\" from the parent process\n- \"parent close fd[1] over\" when parent completes cleanup)",
    "Canonical_solution": "#include <unistd.h>\n#include <stdio.h>\n#include <cstring>\n#include <cstdlib>\n\nvoid pipe_communication() {\n    int pipe_fd[2];\n    pid_t pid;\n\n    char r_buf[4];\n    char w_buf[100];\n    memset(r_buf,0,sizeof(r_buf));\n    memset(w_buf,0,sizeof(w_buf));\n    int r_num;\n\n    if(pipe(pipe_fd)<0) {\n        printf(\"pipe create error\\n\");\n        return;\n    }\n\n    if((pid=fork())==0) {\n        printf(\"\\n\");\n        close(pipe_fd[1]);\n        sleep(5);\n        while((r_num=read(pipe_fd[0],r_buf,4))!=0)\n            printf(\"Read data from the pipe is %s\\n\", r_buf);\n\n        close(pipe_fd[0]);\n        exit(0);\n    }\n    else if(pid>0) {\n        close(pipe_fd[0]);\n        const char* content = \"1111222233334444\";\n        strncpy(w_buf, content, strlen(content));\n        if(write(pipe_fd[1],w_buf, strlen(content))!=-1) {\n            printf(\"Write data %s\\n\", w_buf);\n            printf(\"Parent write over\\n\");\n        }\n        close(pipe_fd[1]);\n        printf(\"parent close fd[1] over\\n\");\n        wait(&pid);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 155,
    "matched_results": [
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent\";\n    char buffer[128];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n    if (pid < 0) {\n        std::cerr << \"fork error\" << std::endl;\n        return;\n    }\n\n    if (pid > 0) { // Parent process\n        close(fd[0]); // Close reading end of the pipe\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message)+1);\n        close(fd[1]); // Close writing end after writing\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    } else { // Child process\n        close(fd[1]); // Close writing end of the pipe\n        read(fd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        close(fd[0]);\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent process!\";\n    char buffer[1024];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n\n    if (pid < 0) {\n        std::cerr << \"fork failed\" << std::endl;\n        return;\n    }\n\n    if (pid > 0) { // Parent process\n        close(fd[0]); // Close read end of the pipe\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message)+1);\n        close(fd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    } else { // Child process\n        close(fd[1]); // Close write end of the pipe\n        read(fd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        close(fd[0]);\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent process!\";\n    char buffer[1024];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n    if (pid < 0) {\n        std::cerr << \"fork failed\" << std::endl;\n        return;\n    }\n\n    if (pid == 0) { // Child process\n        close(fd[1]); // Close write end of the pipe\n        ssize_t bytesRead = read(fd[0], buffer, sizeof(buffer) - 1);\n        if (bytesRead > 0) {\n            buffer[bytesRead] = '\\0';\n            std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        }\n        close(fd[0]);\n    } else { // Parent process\n        close(fd[0]); // Close read end of the pipe\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message));\n        close(fd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr); // Wait for child to finish\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent\";\n    char buffer[128];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n\n    if (pid < 0) {\n        std::cerr << \"fork error\" << std::endl;\n        return;\n    }\n\n    if (pid > 0) { // Parent process\n        close(fd[0]); // Close reading end of the pipe\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message)+1);\n        close(fd[1]); // Close writing end of the pipe\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr); // Wait for child to finish\n    } else { // Child process\n        close(fd[1]); // Close writing end of the pipe\n        read(fd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        close(fd[0]); // Close reading end of the pipe\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent\";\n    char buffer[128];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n    if (pid < 0) {\n        std::cerr << \"fork error\" << std::endl;\n        return;\n    }\n\n    if (pid > 0) { // Parent process\n        close(fd[0]); // Close read end\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message)+1);\n        close(fd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    } else { // Child process\n        close(fd[1]); // Close write end\n        read(fd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        close(fd[0]);\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent\";\n    char buffer[128];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n\n    if (pid < 0) {\n        std::cerr << \"fork failed\" << std::endl;\n        return;\n    }\n\n    if (pid > 0) { // Parent process\n        close(fd[0]); // Close reading end of the pipe\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message)+1);\n        close(fd[1]); // Close writing end after writing\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr); // Wait for child to finish\n    } else { // Child process\n        close(fd[1]); // Close writing end of the pipe\n        read(fd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        close(fd[0]); // Close reading end after reading\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent\";\n    char buffer[128];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n    if (pid < 0) {\n        std::cerr << \"fork error\" << std::endl;\n        return;\n    }\n\n    if (pid > 0) { // Parent process\n        close(fd[0]); // Close reading end\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message)+1);\n        close(fd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    } else { // Child process\n        close(fd[1]); // Close writing end\n        read(fd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        close(fd[0]);\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent process!\";\n    char buffer[1024];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n\n    if (pid < 0) {\n        std::cerr << \"fork failed\" << std::endl;\n        return;\n    }\n\n    if (pid > 0) { // Parent process\n        close(fd[0]); // Close reading end of the pipe\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message)+1);\n        close(fd[1]); // Close writing end of the pipe\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr); // Wait for child to finish\n    } else { // Child process\n        close(fd[1]); // Close writing end of the pipe\n        read(fd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        close(fd[0]); // Close reading end of the pipe\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent\";\n    char buffer[128];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n    if (pid < 0) {\n        std::cerr << \"fork failed\" << std::endl;\n        return;\n    }\n\n    if (pid == 0) { // Child process\n        close(fd[1]); // Close write end\n        ssize_t bytesRead = read(fd[0], buffer, sizeof(buffer) - 1);\n        if (bytesRead > 0) {\n            buffer[bytesRead] = '\\0';\n            std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        }\n        close(fd[0]);\n    } else { // Parent process\n        close(fd[0]); // Close read end\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message));\n        close(fd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr); // Wait for child to finish\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n\nvoid pipe_communication() {\n    int fd[2];\n    pid_t pid;\n    const char* message = \"Hello from parent\";\n    char buffer[128];\n\n    if (pipe(fd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid = fork();\n    if (pid < 0) {\n        std::cerr << \"fork error\" << std::endl;\n        return;\n    }\n\n    if (pid > 0) { // Parent process\n        close(fd[0]); // Close reading end of the pipe\n        std::cout << \"Write data \" << message << std::endl;\n        write(fd[1], message, strlen(message)+1);\n        close(fd[1]); // Close writing end after writing\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr); // Wait for child to finish\n    } else { // Child process\n        close(fd[1]); // Close writing end of the pipe\n        read(fd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        close(fd[0]); // Close reading end after reading\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Implement a multi-threaded HTTP download manager using libcurl in C++ that can handle multiple download tasks concurrently, avoid duplicate downloads, and manage resources efficiently.\n\nClass Description: The DownloadPool class manages a pool of worker threads that process download tasks. Each task downloads a file from a given URL and saves it to a specified output path. The class ensures thread safety and prevents duplicate downloads.\n\nAttributes:\n- m_threads: std::vector<std::thread> - Collection of worker threads\n- m_queue: std::queue<Task> - Queue of pending download tasks\n- m_urls: std::unordered_set<std::string> - Set of unique task identifiers to prevent duplicates\n- m_mtx: std::mutex - Mutex for thread synchronization\n- m_noMoreTask: bool - Flag indicating no more tasks will be added\n\nMethods:\n- DownloadPool() -> void - Constructor initializes libcurl and creates worker threads\n- ~DownloadPool() -> void - Destructor cleans up libcurl resources\n- addTask(const std::string& url, const std::string& output) -> void - Adds a new download task if not already present\n- setNoMoreTask() -> void - Signals that no more tasks will be added\n- finishAndWaitForExit() -> void - Waits for all threads to complete current tasks\n- run() -> void - Worker thread function that processes tasks from the queue\n\nTask Class Description: The Task class represents an individual download task with URL and output file path.\n\nAttributes:\n- m_url: std::string - URL to download from\n- m_output: std::string - Local file path to save to\n\nMethods:\n- run() -> void - Executes the download task using libcurl\n- writeData(void* buffer, size_t size, size_t nmemb) -> size_t - Callback function for writing received data to file",
    "Canonical_solution": "#include <curl/curl.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <queue>\n#include <unordered_set>\n\nclass Task\n{\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n    \n    void run()\n    {\n        std::ofstream output(m_output, std::fstream::in | std::fstream::out | std::fstream::trunc);\n        output.close();\n        \n        CURL *curl_handler = curl_easy_init();\n        curl_easy_setopt(curl_handler, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl_handler, CURLOPT_TIMEOUT, 60);\n        curl_easy_setopt(curl_handler, CURLOPT_WRITEFUNCTION, &Task::writeData);\n        curl_easy_setopt(curl_handler, CURLOPT_WRITEDATA, this);\n\n        curl_easy_perform(curl_handler);\n        \n        curl_easy_cleanup(curl_handler);\n    }\n\n    size_t writeData(void *buffer, size_t size, size_t nmemb)\n    {\n        std::ofstream file;\n        file.open(m_output, std::fstream::in | std::fstream::out | std::fstream::app | std::fstream::binary);\n        size_t bytesToWrite = size * nmemb;\n        file.write(reinterpret_cast<const char *>(buffer), bytesToWrite);\n        file.close();\n        \n        return bytesToWrite;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool\n{\npublic:\n    DownloadPool()\n    {\n        m_noMoreTask = false;\n        curl_global_init(CURL_GLOBAL_ALL);\n        \n        for (int idx = 0; idx < 4; idx++)\n        {\n            m_threads.push_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool()\n    {\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string &url, const std::string& output)\n    {\n        std::string uid = url + output;\n        bool existed = false;\n        Task task(url, output);\n        m_mtx.lock();\n        if (!(existed = (m_urls.find(uid) != m_urls.cend())))\n        {\n            m_urls.insert(uid);\n            m_queue.push(task);\n        }\n        m_mtx.unlock();\n    }\n\n    void setNoMoreTask()\n    {\n        m_mtx.lock();\n        m_noMoreTask = true;\n        m_mtx.unlock();\n    }\n\n    void finishAndWaitForExit()\n    {\n        setNoMoreTask();\n        for (auto& thread : m_threads)\n        {\n            thread.join();\n        }\n    }\n\nprivate:\n    void run()\n    {\n        while(true)\n        {\n            bool found = false;\n            Task task;\n            \n            m_mtx.lock();\n            if (!m_queue.empty())\n            {\n                task = m_queue.front();\n                m_queue.pop();\n                found = true;\n            }\n            bool noMoreTask = m_noMoreTask;\n            m_mtx.unlock();\n            \n            if (found)\n            {\n                task.run();\n                continue;\n            }\n            if (noMoreTask)\n            {\n                break;\n            }\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    bool m_noMoreTask;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* fp = fopen(m_output.c_str(), \"wb\");\n        if (!fp) {\n            fclose(fp);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, FILE* stream) {\n        return fwrite(buffer, size, nmemb, stream);\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool(int numThreads) : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back([this] { this->run(); });\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::unique_lock<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_queue.emplace(url, output);\n            m_urls.insert(url);\n            lock.unlock();\n            cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        cv.notify_all();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\nprivate:\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            cv.wait(lock, [this] { return !m_queue.empty() || m_noMoreTask; });\n\n            if (m_queue.empty() && m_noMoreTask) {\n                break;\n            }\n\n            if (!m_queue.empty()) {\n                Task task = std::move(m_queue.front());\n                m_queue.pop();\n                lock.unlock();\n                task.run();\n            }\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    std::string m_url;\n    std::string m_output;\n\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    size_t writeData(void* buffer, size_t size, size_t nmemb, FILE* stream) {\n        size_t written = fwrite(buffer, size, nmemb, stream);\n        return written;\n    }\n\n    void run() {\n        FILE* fp = fopen(m_output.c_str(), \"wb\");\n        if (!fp) {\n            std::cerr << \"Failed to open file: \" << m_output << std::endl;\n            return;\n        }\n\n        CURL* curl = curl_easy_init();\n        if (curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &Task::writeData);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res != CURLE_OK) {\n                std::cerr << \"CURL error: \" << curl_easy_strerror(res) << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n        fclose(fp);\n    }\n};\n\nclass DownloadPool {\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask = false;\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            m_cv.wait(lock, [this]() { return !m_queue.empty() || m_noMoreTask; });\n\n            if (m_queue.empty() && m_noMoreTask)\n                break;\n\n            if (!m_queue.empty()) {\n                Task task = m_queue.front();\n                m_queue.pop();\n                lock.unlock();\n                task.run();\n            }\n        }\n    }\n\npublic:\n    DownloadPool(size_t numThreads) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (size_t i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back([this] { this->run(); });\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_urls.insert(url);\n            m_queue.emplace(url, output);\n            m_cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* fp = fopen(m_output.c_str(), \"wb\");\n        if (!fp) {\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, FILE* stream) {\n        fwrite(buffer, size, nmemb, stream);\n        return size * nmemb;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool(int numThreads) : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back(&DownloadPool::run, this);\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::unique_lock<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_queue.push(Task(url, output));\n            m_urls.insert(url);\n            lock.unlock();\n            cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::unique_lock<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        lock.unlock();\n        cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\nprivate:\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            cv.wait(lock, [this] { return !m_queue.empty() || m_noMoreTask; });\n\n            if (m_queue.empty() && m_noMoreTask) {\n                break;\n            }\n\n            if (!m_queue.empty()) {\n                Task task = m_queue.front();\n                m_queue.pop();\n                lock.unlock();\n                task.run();\n            }\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* fp = fopen(m_output.c_str(), \"wb\");\n        if (!fp) {\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, FILE* stream) {\n        fwrite(buffer, size, nmemb, stream);\n        return size * nmemb;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool(int numThreads) : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back(&DownloadPool::run, this);\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_queue.emplace(url, output);\n            m_urls.insert(url);\n            m_cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\nprivate:\n    void run() {\n        while (true) {\n            Task task(\"\", \"\");\n            {\n                std::unique_lock<std::mutex> lock(m_mtx);\n                m_cv.wait(lock, [this]() { return !m_queue.empty() || m_noMoreTask; });\n                if (m_queue.empty() && m_noMoreTask) break;\n                if (m_queue.empty()) continue;\n                task = std::move(m_queue.front());\n                m_queue.pop();\n            }\n            task.run();\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        std::ofstream file(m_output, std::ios::binary);\n        if (!file) {\n            std::cerr << \"Failed to open file: \" << m_output << std::endl;\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &file);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        file.close();\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        std::ofstream* file = static_cast<std::ofstream*>(userp);\n        size_t totalSize = size * nmemb;\n        file->write(static_cast<char*>(buffer), totalSize);\n        return totalSize;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool(int numThreads) : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back(&DownloadPool::run, this);\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_queue.emplace(url, output);\n            m_urls.insert(url);\n            m_cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\nprivate:\n    void run() {\n        while (true) {\n            Task task(\"\", \"\");\n            {\n                std::unique_lock<std::mutex> lock(m_mtx);\n                m_cv.wait(lock, [this]() { return !m_queue.empty() || m_noMoreTask; });\n                if (m_queue.empty() && m_noMoreTask) break;\n                if (!m_queue.empty()) {\n                    task = std::move(m_queue.front());\n                    m_queue.pop();\n                }\n            }\n            task.run();\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    std::string m_url;\n    std::string m_output;\n\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    size_t writeData(void* buffer, size_t size, size_t nmemb, FILE* stream) {\n        size_t written = fwrite(buffer, size, nmemb, stream);\n        return written;\n    }\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* fp = fopen(m_output.c_str(), \"wb\");\n        if (!fp) {\n            fclose(fp);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &Task::writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n    }\n};\n\nclass DownloadPool {\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask = false;\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            m_cv.wait(lock, [this]() { return !m_queue.empty() || m_noMoreTask; });\n\n            if (m_queue.empty() && m_noMoreTask)\n                break;\n\n            if (m_queue.empty())\n                continue;\n\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\npublic:\n    DownloadPool(int numThreads) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back([this]() { this->run(); });\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_urls.insert(url);\n            m_queue.emplace(url, output);\n            m_cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    std::string m_url;\n    std::string m_output;\n\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        std::ofstream file(m_output, std::ios::binary);\n        if (!file.is_open()) {\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        file.close();\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        std::ofstream* file = static_cast<std::ofstream*>(userp);\n        size_t totalSize = size * nmemb;\n        file->write(static_cast<char*>(buffer), totalSize);\n        return totalSize;\n    }\n};\n\nclass DownloadPool {\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask = false;\n\npublic:\n    DownloadPool(size_t numThreads) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (size_t i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back(&DownloadPool::run, this);\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_queue.emplace(url, output);\n            m_urls.insert(url);\n            m_cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            m_cv.wait(lock, [this] { return !m_queue.empty() || m_noMoreTask; });\n\n            if (m_queue.empty() && m_noMoreTask) break;\n\n            Task task = std::move(m_queue.front());\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    std::string m_url;\n    std::string m_output;\n\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        std::ofstream* file = static_cast<std::ofstream*>(userp);\n        file->write(static_cast<char*>(buffer), size * nmemb);\n        return size * nmemb;\n    }\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        std::ofstream file(m_output, std::ios::binary);\n        if (!file) {\n            std::cerr << \"Failed to open file: \" << m_output << std::endl;\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &file);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        file.close();\n        curl_easy_cleanup(curl);\n    }\n};\n\nclass DownloadPool {\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask = false;\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            m_cv.wait(lock, [this]() { return !m_queue.empty() || m_noMoreTask; });\n\n            if (m_queue.empty() && m_noMoreTask) break;\n\n            Task task = std::move(m_queue.front());\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\npublic:\n    DownloadPool(int numThreads = std::thread::hardware_concurrency()) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back([this]() { this->run(); });\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_queue.emplace(url, output);\n            m_urls.insert(url);\n            m_cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (std::thread& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* fp = fopen(m_output.c_str(), \"wb\");\n        if (!fp) {\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, FILE* stream) {\n        size_t written = fwrite(buffer, size, nmemb, stream);\n        return written;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool(int numThreads) : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back(&DownloadPool::run, this);\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_queue.emplace(url, output);\n            m_urls.insert(url);\n            m_cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\nprivate:\n    void run() {\n        while (true) {\n            Task task(\"\", \"\");\n            {\n                std::unique_lock<std::mutex> lock(m_mtx);\n                m_cv.wait(lock, [this]() { return !m_queue.empty() || m_noMoreTask; });\n                if (m_queue.empty() && m_noMoreTask) break;\n                if (!m_queue.empty()) {\n                    task = std::move(m_queue.front());\n                    m_queue.pop();\n                }\n            }\n            task.run();\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <thread>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n#include <fstream>\n\nclass Task {\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* fp = fopen(m_output.c_str(), \"wb\");\n        if (!fp) {\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, FILE* stream) {\n        size_t realsize = size * nmemb;\n        fwrite(buffer, 1, realsize, stream);\n        return realsize;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool(int numThreads) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        m_noMoreTask = false;\n        for (int i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back(&DownloadPool::run, this);\n        }\n    }\n\n    ~DownloadPool() {\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_queue.push(Task(url, output));\n            m_urls.insert(url);\n            m_cv.notify_one();\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\nprivate:\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            m_cv.wait(lock, [this] { return !m_queue.empty() || m_noMoreTask; });\n\n            if (m_queue.empty() && m_noMoreTask) {\n                break;\n            }\n\n            if (!m_queue.empty()) {\n                Task task = m_queue.front();\n                m_queue.pop();\n                lock.unlock();\n                task.run();\n            }\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a TCP client class using Boost.Asio that handles asynchronous communication with a chat server, including reading from standard input and writing to standard output.\n\nClass Description: The posix_chat_client class implements an asynchronous TCP client for a chat application. It manages socket connections, handles message reading/writing, and processes user input/output asynchronously using Boost.Asio.\n\nAttributes:\n- socket_: [tcp::socket] - The TCP socket for communication with the server\n- input_: [posix::stream_descriptor] - Handles asynchronous reading from standard input\n- output_: [posix::stream_descriptor] - Handles asynchronous writing to standard output\n- read_msg_: [chat_message] - Stores the message being read from the server\n- write_msg_: [chat_message] - Stores the message to be written to the server\n- input_buffer_: [boost::asio::streambuf] - Buffer for storing input data\n\nMethods:\n- Constructor: [posix_chat_client]([boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints]) -> [void] - Initializes the client with IO context and server endpoints\n- do_connect: [do_connect]([const tcp::resolver::results_type& endpoints]) -> [void] - Asynchronously connects to the server endpoints\n- do_read_header: [do_read_header]() -> [void] - Asynchronously reads the message header from the server\n- do_read_body: [do_read_body]() -> [void] - Asynchronously reads the message body from the server after header is processed\n- do_write_output: [do_write_output]() -> [void] - Asynchronously writes received messages to standard output\n- do_read_input: [do_read_input]() -> [void] - Asynchronously reads input from standard input\n- do_write_message: [do_write_message]() -> [void] - Asynchronously writes the composed message to the server\n- close: [close]() -> [void] - Closes all connections and cleans up resources",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\n#include \"chat_message.hpp\"\nusing boost::asio::ip::tcp;\nnamespace posix = boost::asio::posix;\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO)),\n      input_buffer_(chat_message::max_body_length)\n  {\n    do_connect(endpoints);\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    static char eol[] = { '\\n' };\n    std::array<boost::asio::const_buffer, 2> buffers = {{\n      boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n      boost::asio::buffer(eol) }};\n    boost::asio::async_write(output_, buffers,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            write_msg_.body_length(length - 1);\n            input_buffer_.sgetn(write_msg_.body(), length - 1);\n            input_buffer_.consume(1);\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else if (ec == boost::asio::error::not_found)\n          {\n            write_msg_.body_length(input_buffer_.size());\n            input_buffer_.sgetn(write_msg_.body(), input_buffer_.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  posix::stream_descriptor input_;\n  posix::stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/enable_shared_ptr.hpp>\n#include <boost/foreach.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/array.hpp>\n#include <boost/asio/posix/stream_descriptor.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\n\nclass chat_message\n{\npublic:\n  enum { header_length = 4 };\n  enum { max_body_length = 1024 };\n\n  chat_message()\n    : body_length_(0)\n  {\n  }\n\n  const char* data() const\n  {\n    return data_;\n  }\n\n  char* data()\n  {\n    return data_;\n  }\n\n  std::size_t length() const\n  {\n    return header_length + body_length_;\n  }\n\n  const char* body() const\n  {\n    return data_ + header_length;\n  }\n\n  char* body()\n  {\n    return data_ + header_length;\n  }\n\n  std::size_t body_length() const\n  {\n    return body_length_;\n  }\n\n  void body_length(std::size_t new_length)\n  {\n    body_length_ = new_length;\n  }\n\n  bool decode_header()\n  {\n    std::size_t header_len = header_length;\n    body_length_ = ntohl(*reinterpret_cast<const uint32_t*>(data_));\n    if (body_length_ > max_body_length)\n    {\n      body_length_ = 0;\n      return false;\n    }\n    return true;\n  }\n\nprivate:\n  std::size_t body_length_;\n  char data_[header_length + max_body_length];\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client>\n{\npublic:\n  typedef posix_chat_client this_type;\n\n  posix_chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO))\n  {\n    do_connect(endpoints);\n  }\n\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](const boost::system::error_code& ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](const boost::system::error_code& ec, std::size_t)\n        {\n          if (!ec)\n          {\n            if (read_msg_.decode_header())\n            {\n              do_read_body();\n            }\n            else\n            {\n              close();\n            }\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](const boost::system::error_code& ec, std::size_t)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    boost::asio::async_write(output_,\n        boost::asio::buffer(read_msg_.data(), read_msg_.length()),\n        [this](const boost::system::error_code& ec, std::size_t)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    input_buffer_.consume(input_buffer_.size());\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](const boost::system::error_code& ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            line += \"\\n\";\n            write_msg_.body_length(line.size());\n            std::memcpy(write_msg_.body(), line.c_str(), line.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](const boost::system::error_code& ec, std::size_t)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    try\n    {\n      socket_.close();\n      input_.close();\n      output_.close();\n    }\n    catch (...) {}\n  }\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/enable_shared_ptr.hpp>\n#include <boost/foreach.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\nnamespace posix = boost::asio::posix;\n\nclass chat_message\n{\npublic:\n  enum { header_length = 4 };\n  enum { max_body_length = 1024 };\n\n  chat_message()\n    : body_length_(0)\n  {\n  }\n\n  const char* data() const\n  {\n    return data_;\n  }\n\n  char* data()\n  {\n    return data_;\n  }\n\n  std::size_t length() const\n  {\n    return header_length + body_length_;\n  }\n\n  const char* body() const\n  {\n    return data_ + header_length;\n  }\n\n  char* body()\n  {\n    return data_ + header_length;\n  }\n\n  std::size_t body_length() const\n  {\n    return body_length_;\n  }\n\n  void body_length(std::size_t new_length)\n  {\n    body_length_ = new_length;\n  }\n\n  bool decode_header()\n  {\n    using namespace std; // For strncat and atoi.\n    char header[header_length + 1] = \"\";\n    strncat(header, data_, header_length);\n    body_length_ = atoi(header);\n    if (body_length_ > max_body_length)\n    {\n      body_length_ = 0;\n      return false;\n    }\n    return true;\n  }\n\n  void encode_header()\n  {\n    using namespace std; // For sprintf and memcpy.\n    char header[header_length + 1];\n    sprintf(header, \"%4d\", static_cast<int>(body_length_));\n    memcpy(data_, header, header_length);\n  }\n\nprivate:\n  std::size_t body_length_;\n  char data_[header_length + max_body_length];\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client>\n{\npublic:\n  typedef boost::shared_ptr<posix_chat_client> pointer;\n\n  posix_chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO)),\n      input_buffer_()\n  {\n    do_connect(endpoints);\n  }\n\n  static pointer create(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n  {\n    return pointer(new posix_chat_client(io_context, endpoints));\n  }\n\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](const boost::system::error_code& ec, const tcp::endpoint&)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            if (read_msg_.decode_header())\n            {\n              do_read_body();\n            }\n            else\n            {\n              socket_.close();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    boost::asio::async_write(output_,\n        boost::asio::buffer(read_msg_.data(), read_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    input_buffer_.consume(input_buffer_.size());\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            write_msg_.body_length(line.size());\n            memcpy(write_msg_.body(), line.c_str(), line.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  posix::stream_descriptor input_;\n  posix::stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/enable_shared_ptr.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::posix::stream_descriptor;\n\nclass chat_message\n{\npublic:\n  enum { header_length = 4 };\n  enum { max_body_length = 512 };\n\n  chat_message()\n    : body_length_(0)\n  {\n  }\n\n  const char* data() const\n  {\n    return data_.data();\n  }\n\n  char* data()\n  {\n    return data_.data();\n  }\n\n  std::size_t length() const\n  {\n    return header_length + body_length_;\n  }\n\n  const char* body() const\n  {\n    return data_.data() + header_length;\n  }\n\n  char* body()\n  {\n    return data_.data() + header_length;\n  }\n\n  std::size_t body_length() const\n  {\n    return body_length_;\n  }\n\n  void body_length(std::size_t new_length)\n  {\n    body_length_ = new_length;\n  }\n\n  bool decode_header()\n  {\n    char header[header_length + 1] = \"\";\n    std::strncat(header, data_.data(), header_length);\n    body_length_ = std::atoi(header);\n    if (body_length_ > max_body_length)\n    {\n      body_length_ = 0;\n      return false;\n    }\n    return true;\n  }\n\n  void encode_header()\n  {\n    char header[header_length + 1] = \"\";\n    std::sprintf(header, \"%4d\", static_cast<int>(body_length_));\n    std::memcpy(data_.data(), header, header_length);\n  }\n\nprivate:\n  boost::array<char, header_length + max_body_length> data_;\n  std::size_t body_length_;\n};\n\nclass posix_chat_client\n  : public boost::enable_shared_from_this<posix_chat_client>\n{\npublic:\n  typedef boost::shared_ptr<posix_chat_client> pointer;\n\n  static pointer create(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n  {\n    return pointer(new posix_chat_client(io_context, endpoints));\n  }\n\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO))\n  {\n    do_connect(endpoints);\n  }\n\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            write_output_buffer_ = boost::asio::buffer(read_msg_.data(), read_msg_.length());\n            do_write_output();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    boost::asio::async_write(output_, write_output_buffer_,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            line += \"\\n\";\n\n            if (line.size() <= chat_message::max_body_length)\n            {\n              write_msg_.body_length(line.size());\n              std::memcpy(write_msg_.body(), line.c_str(), line.size());\n              write_msg_.encode_header();\n              do_write_message();\n            }\n\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            // Continue reading input\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    try\n    {\n      socket_.close();\n      input_.close();\n      output_.close();\n    }\n    catch (std::exception&) {}\n  }\n\nprivate:\n  tcp::socket socket_;\n  stream_descriptor input_;\n  stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n  boost::asio::const_buffer write_output_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/array.hpp>\n#include \"chat_message.hpp\"\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO))\n  {\n    do_connect(endpoints);\n  }\n\nprivate:\n  void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, boost::asio::ip::tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    boost::asio::async_write(output_,\n        boost::asio::buffer(read_msg_.data(), read_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            write_msg_ = chat_message(line);\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\n  boost::asio::ip::tcp::socket socket_;\n  boost::asio::posix::stream_descriptor input_;\n  boost::asio::posix::stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/enable_shared_ptr.hpp>\n#include <boost/foreach.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::posix::stream_descriptor;\n\nclass chat_message\n{\npublic:\n  enum { header_length = 4 };\n  enum { max_body_length = 1024 };\n\n  chat_message()\n    : body_length_(0)\n  {\n  }\n\n  const char* data() const\n  {\n    return data_.data();\n  }\n\n  char* data()\n  {\n    return data_.data();\n  }\n\n  std::size_t length() const\n  {\n    return header_length + body_length_;\n  }\n\n  const char* body() const\n  {\n    return data_.data() + header_length;\n  }\n\n  char* body()\n  {\n    return data_.data() + header_length;\n  }\n\n  std::size_t body_length() const\n  {\n    return body_length_;\n  }\n\n  void body_length(std::size_t new_length)\n  {\n    body_length_ = new_length;\n  }\n\n  bool decode_header()\n  {\n    char header[header_length + 1] = \"\";\n    std::strncpy(header, data_.data(), header_length);\n    body_length_ = std::atoi(header);\n    if (body_length_ > max_body_length)\n    {\n      body_length_ = 0;\n      return false;\n    }\n    return true;\n  }\n\n  void encode_header()\n  {\n    char header[header_length + 1] = \"\";\n    std::sprintf(header, \"%4d\", static_cast<int>(body_length_));\n    std::memcpy(data_.data(), header, header_length);\n  }\n\nprivate:\n  boost::array<char, header_length + max_body_length> data_;\n  std::size_t body_length_;\n};\n\nclass posix_chat_client\n  : public boost::enable_shared_from_this<posix_chat_client>\n{\npublic:\n  typedef boost::shared_ptr<posix_chat_client> pointer;\n\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO))\n  {\n    do_connect(endpoints);\n  }\n\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](const boost::system::error_code& ec, const tcp::endpoint&)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](const boost::system::error_code& ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            if (read_msg_.decode_header())\n            {\n              do_read_body();\n            }\n            else\n            {\n              socket_.close();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](const boost::system::error_code& ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    boost::asio::async_write(output_,\n        boost::asio::buffer(read_msg_.data(), read_msg_.length()),\n        [this](const boost::system::error_code& ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    input_buffer_.consume(input_buffer_.size());\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](const boost::system::error_code& ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            line += \"\\n\";\n            write_msg_.body_length(line.size());\n            std::memcpy(write_msg_.body(), line.c_str(), line.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](const boost::system::error_code& ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  stream_descriptor input_;\n  stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/enable_shared_ptr.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::posix::stream_descriptor;\n\nclass chat_message\n{\npublic:\n  enum { header_length = 4 };\n  enum { max_body_length = 512 };\n\n  chat_message()\n    : body_length_(0)\n  {\n  }\n\n  const char* data() const\n  {\n    return data_.data();\n  }\n\n  char* data()\n  {\n    return data_.data();\n  }\n\n  std::size_t length() const\n  {\n    return header_length + body_length_;\n  }\n\n  const char* body() const\n  {\n    return data_.data() + header_length;\n  }\n\n  char* body()\n  {\n    return data_.data() + header_length;\n  }\n\n  std::size_t body_length() const\n  {\n    return body_length_;\n  }\n\n  void body_length(std::size_t new_length)\n  {\n    body_length_ = new_length;\n  }\n\n  bool decode_header()\n  {\n    char header[header_length + 1] = \"\";\n    std::strncat(header, data_.data(), header_length);\n    body_length_ = std::atoi(header);\n    if (body_length_ > max_body_length)\n    {\n      body_length_ = 0;\n      return false;\n    }\n    return true;\n  }\n\n  void encode_header()\n  {\n    char header[header_length + 1] = \"\";\n    std::sprintf(header, \"%4d\", static_cast<int>(body_length_));\n    std::memcpy(data_.data(), header, header_length);\n  }\n\nprivate:\n  boost::array<char, header_length + max_body_length> data_;\n  std::size_t body_length_;\n};\n\nclass posix_chat_client\n  : public boost::enable_shared_from_this<posix_chat_client>\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO))\n  {\n    do_connect(endpoints);\n  }\n\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            if (read_msg_.decode_header())\n            {\n              do_read_body();\n            }\n            else\n            {\n              socket_.close();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    boost::asio::async_write(output_,\n        boost::asio::buffer(read_msg_.data(), read_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            line += \"\\n\";\n            write_msg_.body_length(line.size());\n            std::memcpy(write_msg_.body(), line.c_str(), line.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::system::error_code ignored_ec;\n    socket_.close(ignored_ec);\n    input_.close(ignored_ec);\n    output_.close(ignored_ec);\n  }\n\nprivate:\n  tcp::socket socket_;\n  stream_descriptor input_;\n  stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/enable_shared_ptr.hpp>\n#include <boost/foreach.hpp>\n#include <boost/shared_ptr.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::posix::stream_descriptor;\n\nclass chat_message {\npublic:\n    enum { header_length = 4 };\n    enum { max_body_length = 512 };\n\n    chat_message()\n        : body_length_(0)\n    {\n    }\n\n    const char* data() const\n    {\n        return data_;\n    }\n\n    char* data()\n    {\n        return data_;\n    }\n\n    std::size_t length() const\n    {\n        return header_length + body_length_;\n    }\n\n    const char* body() const\n    {\n        return data_ + header_length;\n    }\n\n    char* body()\n    {\n        return data_ + header_length;\n    }\n\n    std::size_t body_length() const\n    {\n        return body_length_;\n    }\n\n    void body_length(std::size_t new_length)\n    {\n        body_length_ = new_length;\n    }\n\n    bool decode_header()\n    {\n        using namespace std; // For strncat and atoi.\n        char header[header_length + 1] = \"\";\n        strncat(header, data_, header_length);\n        body_length_ = atoi(header);\n        if (body_length_ > max_body_length) {\n            body_length_ = 0;\n            return false;\n        }\n        return true;\n    }\n\n    void encode_header()\n    {\n        using namespace std; // For sprintf and memcpy.\n        char header[header_length + 1];\n        sprintf(header, \"%4d\", static_cast<int>(body_length_));\n        memcpy(data_, header, header_length);\n    }\n\nprivate:\n    std::size_t body_length_;\n    char data_[header_length + max_body_length];\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    typedef boost::shared_ptr<posix_chat_client> pointer;\n\n    posix_chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : socket_(io_context)\n        , input_(io_context, ::dup(STDIN_FILENO))\n        , output_(io_context, ::dup(STDOUT_FILENO))\n    {\n        do_connect(endpoints);\n    }\n\n    static pointer create(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n    {\n        return pointer(new posix_chat_client(io_context, endpoints));\n    }\n\n    void close()\n    {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints)\n    {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, tcp::endpoint) {\n                if (!ec) {\n                    do_read_header();\n                    do_read_input();\n                }\n            });\n    }\n\n    void do_read_header()\n    {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    if (read_msg_.decode_header()) {\n                        do_read_body();\n                    } else {\n                        socket_.close();\n                    }\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body()\n    {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write_output()\n    {\n        const std::string msg_str(read_msg_.body(), read_msg_.body() + read_msg_.body_length());\n        boost::asio::async_write(output_,\n            boost::asio::buffer(msg_str + \"\\n\"),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_input()\n    {\n        boost::asio::async_read_until(input_, input_buffer_, '\\n',\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec) {\n                    std::istream is(&input_buffer_);\n                    std::string line;\n                    std::getline(is, line);\n                    write_msg_.body_length(line.size());\n                    memcpy(write_msg_.body(), line.c_str(), line.size());\n                    write_msg_.encode_header();\n                    do_write_message();\n                } else {\n                    input_.close();\n                }\n            });\n    }\n\n    void do_write_message()\n    {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    do_read_input();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    tcp::socket socket_;\n    stream_descriptor input_;\n    stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/array.hpp>\n#include <boost/shared_array.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::posix::stream_descriptor;\n\nclass chat_message\n{\npublic:\n  enum { header_length = 4 };\n  enum { max_body_length = 1024 };\n\n  chat_message()\n    : body_length_(0)\n  {\n  }\n\n  const char* data() const\n  {\n    return data_;\n  }\n\n  char* data()\n  {\n    return data_;\n  }\n\n  std::size_t length() const\n  {\n    return header_length + body_length_;\n  }\n\n  const char* body() const\n  {\n    return data_ + header_length;\n  }\n\n  char* body()\n  {\n    return data_ + header_length;\n  }\n\n  std::size_t body_length() const\n  {\n    return body_length_;\n  }\n\n  void body_length(std::size_t new_length)\n  {\n    body_length_ = new_length;\n  }\n\n  bool decode_header()\n  {\n    char header[header_length + 1] = \"\";\n    std::strncpy(header, data_, header_length);\n    body_length_ = std::atoi(header);\n    if (body_length_ > max_body_length)\n    {\n      body_length_ = 0;\n      return false;\n    }\n    return true;\n  }\n\n  void encode_header()\n  {\n    char header[header_length + 1] = \"\";\n    std::sprintf(header, \"%4d\", static_cast<int>(body_length_));\n    std::memcpy(data_, header, header_length);\n  }\n\nprivate:\n  char data_[header_length + max_body_length];\n  std::size_t body_length_;\n};\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO))\n  {\n    do_connect(endpoints);\n  }\n\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](const boost::system::error_code& ec, const tcp::endpoint&)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](const boost::system::error_code& ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            if (read_msg_.decode_header())\n            {\n              do_read_body();\n            }\n            else\n            {\n              socket_.close();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](const boost::system::error_code& ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    boost::asio::async_write(output_,\n        boost::asio::buffer(read_msg_.data(), read_msg_.length()),\n        [this](const boost::system::error_code& ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    input_buffer_.consume(input_buffer_.size());\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](const boost::system::error_code& ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            line += \"\\n\";\n            write_msg_.body_length(line.size());\n            std::memcpy(write_msg_.body(), line.c_str(), line.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](const boost::system::error_code& ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  stream_descriptor input_;\n  stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/array.hpp>\n#include <boost/shared_array.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::posix::stream_descriptor;\n\nclass chat_message {\npublic:\n  enum { header_length = 4 };\n  enum { max_body_length = 1024 };\n\n  chat_message()\n    : body_length_(0) {\n  }\n\n  const char* data() const {\n    return data_.data();\n  }\n\n  char* data() {\n    return data_.data();\n  }\n\n  std::size_t length() const {\n    return header_length + body_length_;\n  }\n\n  const char* body() const {\n    return data_.data() + header_length;\n  }\n\n  char* body() {\n    return data_.data() + header_length;\n  }\n\n  std::size_t body_length() const {\n    return body_length_;\n  }\n\n  void body_length(std::size_t new_length) {\n    body_length_ = new_length;\n    if (body_length_ > max_body_length)\n      body_length_ = max_body_length;\n  }\n\n  bool decode_header() {\n    using namespace std; // For strncat and atoi.\n    char header[header_length + 1] = \"\";\n    strncat(header, data_.data(), header_length);\n    body_length_ = atoi(header);\n    if (body_length_ > max_body_length)\n      return false;\n    return true;\n  }\n\n  void encode_header() {\n    using namespace std; // For sprintf and memcpy.\n    char header[header_length + 1];\n    sprintf(header, \"%4d\", static_cast<int>(body_length_));\n    memcpy(data_.data(), header, header_length);\n  }\n\nprivate:\n  boost::array<char, header_length + max_body_length> data_;\n  std::size_t body_length_;\n};\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context,\n                    const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO)) {\n    do_connect(endpoints);\n  }\n\n  void do_connect(const tcp::resolver::results_type& endpoints) {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint) {\n          if (!ec) {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header() {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/) {\n          if (!ec) {\n            if (read_msg_.decode_header()) {\n              do_read_body();\n            } else {\n              close();\n            }\n          } else {\n            close();\n          }\n        });\n  }\n\n  void do_read_body() {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/) {\n          if (!ec) {\n            do_write_output();\n          } else {\n            close();\n          }\n        });\n  }\n\n  void do_write_output() {\n    boost::asio::async_write(output_,\n        boost::asio::buffer(read_msg_.data(), read_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/) {\n          if (!ec) {\n            do_read_header();\n          } else {\n            close();\n          }\n        });\n  }\n\n  void do_read_input() {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length) {\n          if (!ec) {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            line += \"\\n\";\n            write_msg_ = chat_message();\n            write_msg_.body_length(line.size());\n            memcpy(write_msg_.body(), line.c_str(), line.size());\n            write_msg_.encode_header();\n            do_write_message();\n          } else {\n            close();\n          }\n        });\n  }\n\n  void do_write_message() {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/) {\n          if (!ec) {\n            do_read_input();\n          } else {\n            close();\n          }\n        });\n  }\n\n  void close() {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  stream_descriptor input_;\n  stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/enable_shared_ptr.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::posix::stream_descriptor;\n\nclass chat_message\n{\npublic:\n  enum { header_length = 4 };\n  enum { max_body_length = 512 };\n\n  chat_message()\n    : body_length_(0)\n  {\n  }\n\n  const char* data() const\n  {\n    return data_;\n  }\n\n  char* data()\n  {\n    return data_;\n  }\n\n  std::size_t length() const\n  {\n    return header_length + body_length_;\n  }\n\n  const char* body() const\n  {\n    return data_ + header_length;\n  }\n\n  char* body()\n  {\n    return data_ + header_length;\n  }\n\n  std::size_t body_length() const\n  {\n    return body_length_;\n  }\n\n  void body_length(std::size_t new_length)\n  {\n    body_length_ = new_length;\n  }\n\n  bool decode_header()\n  {\n    using namespace std; // For strncat and atoi.\n    char header[header_length + 1] = \"\";\n    strncat(header, data_, header_length);\n    body_length_ = atoi(header);\n    if (body_length_ > max_body_length)\n    {\n      body_length_ = 0;\n      return false;\n    }\n    return true;\n  }\n\n  void encode_header()\n  {\n    using namespace std; // For sprintf and memcpy.\n    char header[header_length + 1];\n    sprintf(header, \"%4d\", static_cast<int>(body_length_));\n    memcpy(data_, header, header_length);\n  }\n\nprivate:\n  std::size_t body_length_;\n  char data_[header_length + max_body_length];\n};\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO))\n  {\n    do_connect(endpoints);\n  }\n\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            if (read_msg_.decode_header())\n            {\n              do_read_body();\n            }\n            else\n            {\n              socket_.close();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    boost::asio::async_write(output_,\n        boost::asio::buffer(read_msg_.data(), read_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::istream is(&input_buffer_);\n            std::string line;\n            std::getline(is, line);\n            line += \"\\n\";\n\n            write_msg_.body_length(line.size());\n            memcpy(write_msg_.body(), line.c_str(), line.size());\n            write_msg_.encode_header();\n\n            boost::asio::async_write(socket_,\n                boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n                [this](boost::system::error_code ec, std::size_t /*length*/)\n                {\n                  if (!ec)\n                  {\n                    do_read_input();\n                  }\n                  else\n                  {\n                    socket_.close();\n                  }\n                });\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::system::error_code ignored_ec;\n    socket_.close(ignored_ec);\n    input_.close(ignored_ec);\n    output_.close(ignored_ec);\n  }\n\nprivate:\n  tcp::socket socket_;\n  stream_descriptor input_;\n  stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nnamespace beast = boost::beast;\nnamespace ws = beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        using tcp = net::ip::tcp;\n        using Work = std::function<void()>;\n\n        enum class SocketStatus { Disconnected, Connecting, Connected };\n\n        Impl(net::io_context& ioc, ssl::context& ctx, Device& device_settings, Logging& log)\n            : ioc_(ioc), ctx_(ctx), device_settings_(device_settings), log_(log.shared_from_this()),\n              resolver_(ioc), buffer_(8192), host_(\"\"), socket_status_(SocketStatus::Disconnected) {}\n\n        void run() {\n            host_ = device_settings_.host + \":\" + std::to_string(device_settings_.port);\n            resolver_.async_resolve(tcp::v4(), device_settings_.host, std::to_string(device_settings_.port),\n                [this](beast::error_code ec, tcp::resolver::results_type results) {\n                    onResolve(ec, results);\n                });\n        }\n\n        void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n            if (ec) {\n                onError(ec, \"resolve\");\n                return;\n            }\n\n            socket_status_ = SocketStatus::Connecting;\n            if (device_settings_.use_ssl) {\n                ws_.emplace(ioc_, ctx_);\n                ws_->next_layer().async_connect(results.begin()->endpoint(),\n                    [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                        onConnect(ec, ep);\n                    });\n            } else {\n                ws_tcp_.emplace(ioc_);\n                ws_tcp_->next_layer().async_connect(results.begin()->endpoint(),\n                    [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                        onConnect(ec, ep);\n                    });\n            }\n        }\n\n        void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n            if (ec) {\n                onError(ec, \"connect\");\n                return;\n            }\n\n            if (device_settings_.use_ssl) {\n                ws_->next_layer().async_handshake(ssl::stream_base::client,\n                    [this](beast::error_code ec) {\n                        onSSLhandshake(ec);\n                    });\n            } else {\n                ws_tcp_->async_handshake(host_, \"/\",\n                    [this](beast::error_code ec) {\n                        onWinsockHandshake(ec);\n                    });\n            }\n        }\n\n        void onSSLhandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"ssl handshake\");\n                return;\n            }\n\n            ws_->async_handshake(host_, \"/\",\n                [this](beast::error_code ec) {\n                    onWinsockHandshake(ec);\n                });\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"websocket handshake\");\n                return;\n            }\n\n            socket_status_ = SocketStatus::Connected;\n            read();\n        }\n\n        void send(std::string type, std::string payload) {\n            std::string message = \"{\\\"type\\\":\\\"\" + type + \"\\\",\\\"payload\\\":\" + payload + \"}\";\n            enqueueWork([this, message]() {\n                if (device_settings_.use_ssl) {\n                    ws_->async_write(net::buffer(message),\n                        [this](beast::error_code ec, std::size_t bytes_transferred) {\n                            onWrite(ec, bytes_transferred);\n                        });\n                } else {\n                    ws_tcp_->async_write(net::buffer(message),\n                        [this](beast::error_code ec, std::size_t bytes_transferred) {\n                            onWrite(ec, bytes_transferred);\n                        });\n                }\n            });\n        }\n\n        void onWrite(beast::error_code ec, std::size_t) {\n            if (ec) {\n                onError(ec, \"write\");\n                return;\n            }\n        }\n\n        void read() {\n            if (device_settings_.use_ssl) {\n                ws_->async_read(buffer_,\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onRead(ec, bytes_transferred);\n                    });\n            } else {\n                ws_tcp_->async_read(buffer_,\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onRead(ec, bytes_transferred);\n                    });\n            }\n        }\n\n        void onRead(beast::error_code ec, std::size_t) {\n            if (ec) {\n                onError(ec, \"read\");\n                return;\n            }\n\n            std::string message = beast::buffers_to_string(buffer_.data());\n            buffer_.consume(buffer_.size());\n\n            enqueueWork([this, message]() {\n                // Process received message\n            });\n\n            read();\n        }\n\n        void onError(beast::error_code& ec, std::string stage) {\n            if (log_) {\n                log_->error(\"WebSocket error during {}: {}\", stage, ec.message());\n            }\n\n            close();\n        }\n\n        void enqueueWork(Work& work) {\n            ioc_.post(work);\n        }\n\n        void close() {\n            socket_status_ = SocketStatus::Disconnected;\n\n            if (device_settings_.use_ssl && ws_) {\n                ws_->async_close(ws::close_reason(),\n                    [this](beast::error_code ec) {\n                        if (ec) {\n                            // Handle close error\n                        }\n                        ws_.reset();\n                    });\n            } else if (!device_settings_.use_ssl && ws_tcp_) {\n                ws_tcp_->async_close(ws::close_reason(),\n                    [this](beast::error_code ec) {\n                        if (ec) {\n                            // Handle close error\n                        }\n                        ws_tcp_.reset();\n                    });\n            }\n        }\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device& device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<ws::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<ws::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        SocketStatus socket_status_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace WebOsClient {\n\nclass Impl {\npublic:\n    using tcp = boost::asio::ip::tcp;\n    namespace beast = boost::beast;\n    namespace websocket = beast::websocket;\n    namespace ssl = boost::asio::ssl;\n    namespace net = boost::asio;\n\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& device_settings, Logging& log)\n        : ioc_(ioc),\n          ctx_(ctx),\n          device_settings_(device_settings),\n          log_(log.shared_from_this()),\n          resolver_(ioc),\n          buffer_(8192),\n          host_(device_settings.host + \":\" + std::to_string(device_settings.port)),\n          socket_status_(0) {}\n\n    void run() {\n        resolver_.async_resolve(host_, std::to_string(device_settings_.port),\n            [this](beast::error_code ec, tcp::resolver::results_type results) {\n                onResolve(ec, results);\n            });\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) {\n            onError(ec, \"resolve\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            ws_ = websocket::stream<beast::ssl_stream<beast::tcp_stream>>(ioc_, ctx_);\n            ws_->next_layer().next_layer().set_verify_mode(ssl::verify_peer);\n            ws_->next_layer().next_layer().set_verify_callback(\n                [this](bool preverified, ssl::verify_context& ctx) {\n                    return verifyCertificate(preverified, ctx);\n                });\n\n            auto& socket = ws_->next_layer().next_layer();\n            beast::get_lowest_layer(*ws_) .async_connect(results,\n                [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        } else {\n            ws_tcp_ = websocket::stream<beast::tcp_stream>(ioc_);\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n        if (ec) {\n            onError(ec, \"connect\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            ws_->next_layer().handshake(ssl::stream_base::client,\n                [this](beast::error_code ec) { onSSLhandshake(ec); });\n        } else {\n            ws_tcp_->handshake(host_, \"/\",\n                [this](beast::error_code ec) { onWinsockHandshake(ec); });\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"SSL handshake\");\n            return;\n        }\n\n        ws_->handshake(host_, \"/\",\n            [this](beast::error_code ec) { onWinsockHandshake(ec); });\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"WebSocket handshake\");\n            return;\n        }\n\n        socket_status_ = 2; // connected\n        read();\n    }\n\n    void send(std::string message_type, std::string payload) {\n        if (socket_status_ != 2) return;\n\n        std::string message = message_type + \":\" + payload;\n        if (device_settings_.use_ssl) {\n            ws_->text(true);\n            ws_->async_write(net::buffer(message),\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onWrite(ec, bytes_transferred);\n                });\n        } else {\n            ws_tcp_->text(true);\n            ws_tcp_->async_write(net::buffer(message),\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onWrite(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"write\");\n            return;\n        }\n    }\n\n    void read() {\n        if (socket_status_ != 2) return;\n\n        if (device_settings_.use_ssl) {\n            ws_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        } else {\n            ws_tcp_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onRead(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"read\");\n            return;\n        }\n\n        std::string data = beast::buffers_to_string(buffer_.data());\n        buffer_.consume(buffer_.size());\n\n        handleMessage(data);\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string operation) {\n        if (ec == beast::errc::operation_canceled || ec == net::error::operation_aborted) {\n            return;\n        }\n\n        log_->error(\"WebOS client error during {}: {}\", operation, ec.message());\n        close();\n    }\n\n    void enqueueWork(Work& work) {\n        ioc_.post([this, &work]() {\n            // Process or queue the work\n        });\n    }\n\n    void close() {\n        socket_status_ = 0; // disconnected\n\n        if (device_settings_.use_ssl && ws_) {\n            ws_->close(websocket::close_code::normal);\n        } else if (ws_tcp_) {\n            ws_tcp_->close(websocket::close_code::normal);\n        }\n    }\n\nprivate:\n    bool verifyCertificate(bool preverified, ssl::verify_context& ctx) {\n        // Custom certificate verification logic\n        return preverified;\n    }\n\n    void handleMessage(const std::string& message) {\n        // Handle incoming messages\n    }\n\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device& device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n}; // class Impl\n} // namespace WebOsClient",
      "#include <boost/asio.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = beast::websocket;\n\nclass Logging {\npublic:\n    void log(const std::string& msg) {}\n};\n\nstruct Device {\n    std::string host;\n    bool use_ssl;\n};\n\nclass WebOsClient {\nprivate:\n    class Impl {\n    public:\n        Impl(net::io_context& ioc, ssl::context& ctx, Device& device, Logging& log)\n            : ioc_(ioc), ctx_(ctx), device_settings_(device), log_(std::make_shared<Logging>(log)),\n              resolver_(ioc_), ws_(websocket::stream<beast::ssl_stream<beast::tcp_stream>>(ioc_, ctx_)),\n              ws_tcp_(websocket::stream<beast::tcp_stream>(ioc_)), buffer_(),\n              host_(device.host), socket_status_(0) {}\n\n        void run() {\n            resolver_.async_resolve(host_, \"80\",\n                [this](beast::error_code ec, tcp::resolver::results_type results) {\n                    onResolve(ec, results);\n                });\n        }\n\n        void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n            if (ec) {\n                onError(ec, \"resolve\");\n                return;\n            }\n\n            if (device_settings_.use_ssl) {\n                ws_->next_layer().connect(results,\n                    [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                        onConnect(ec, ep);\n                    });\n            } else {\n                ws_tcp_->next_layer().connect(results,\n                    [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                        onConnect(ec, ep);\n                    });\n            }\n        }\n\n        void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n            if (ec) {\n                onError(ec, \"connect\");\n                return;\n            }\n\n            if (device_settings_.use_ssl) {\n                ws_->async_handshake(host_, \"/\",\n                    [this](beast::error_code ec) {\n                        onSSLhandshake(ec);\n                    });\n            } else {\n                ws_tcp_->async_handshake(host_, \"/\",\n                    [this](beast::error_code ec) {\n                        onWinsockHandshake(ec);\n                    });\n            }\n        }\n\n        void onSSLhandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"SSL handshake\");\n                return;\n            }\n\n            onWinsockHandshake(ec);\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"WebSocket handshake\");\n                return;\n            }\n\n            socket_status_ = 1; // connected\n            read();\n        }\n\n        void send(std::string topic, std::string payload) {\n            std::string message = \"{\\\"topic\\\":\\\"\" + topic + \"\\\",\\\"payload\\\":\" + payload + \"}\";\n            if (device_settings_.use_ssl) {\n                ws_->async_write(net::buffer(message),\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            } else {\n                ws_tcp_->async_write(net::buffer(message),\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            }\n        }\n\n        void onWrite(beast::error_code ec, std::size_t) {\n            if (ec) {\n                onError(ec, \"write\");\n                return;\n            }\n        }\n\n        void read() {\n            if (device_settings_.use_ssl) {\n                ws_->async_read(buffer_,\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onRead(ec, bytes_transferred);\n                    });\n            } else {\n                ws_tcp_->async_read(buffer_,\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onRead(ec, bytes_transferred);\n                    });\n            }\n        }\n\n        void onRead(beast::error_code ec, std::size_t) {\n            if (ec) {\n                onError(ec, \"read\");\n                return;\n            }\n\n            std::string data = beast::buffers_to_string(buffer_.data());\n            buffer_.consume(buffer_.size());\n\n            log_->log(\"Received: \" + data);\n\n            read();\n        }\n\n        void onError(beast::error_code& ec, std::string stage) {\n            log_->log(\"Error during \" + stage + \": \" + ec.message());\n            close();\n        }\n\n        void enqueueWork(Work& work) {\n            // Implementation depends on Work definition\n        }\n\n        void close() {\n            if (socket_status_ == 1) { // connected\n                if (device_settings_.use_ssl) {\n                    ws_->async_close(websocket::close_code::normal,\n                        [this](beast::error_code ec) {\n                            // Handle close completion\n                        });\n                } else {\n                    ws_tcp_->async_close(websocket::close_code::normal,\n                        [this](beast::error_code ec) {\n                            // Handle close completion\n                        });\n                }\n                socket_status_ = 0; // disconnected\n            }\n        }\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device& device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace net = boost::asio;\nnamespace ssl = net::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = beast::websocket;\n\nstruct Device {\n    std::string host;\n    bool use_ssl;\n};\n\nclass Logging {\npublic:\n    void log(const std::string& message) {}\n};\n\nclass WebOsClient {\nprivate:\n    class Impl {\n    public:\n        using tcp = net::ip::tcp;\n        using Work = std::pair<std::string, std::string>;\n\n        Impl(net::io_context& ioc, ssl::context& ctx, Device& device, Logging& log)\n            : ioc_(ioc), ctx_(ctx), device_settings_(device), log_(std::make_shared<Logging>(log)),\n              resolver_(ioc), buffer_(8192), socket_status_(0) {\n            host_ = device_settings_.host;\n        }\n\n        void run() {\n            resolver_.async_resolve(tcp::resolver::query(host_, \"80\"),\n                [this](const beast::error_code& ec, tcp::resolver::results_type results) {\n                    onResolve(ec, results);\n                });\n        }\n\n        void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n            if (ec) {\n                onError(ec, \"resolve\");\n                return;\n            }\n\n            if (device_settings_.use_ssl) {\n                ws_ = websocket::stream<beast::ssl_stream<beast::tcp_stream>>(ioc_, ctx_);\n                ws_->next_layer().next_layer().async_connect(\n                    results.begin()->endpoint(),\n                    [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                        onConnect(ec, ep);\n                    });\n            } else {\n                ws_tcp_ = websocket::stream<beast::tcp_stream>(ioc_);\n                ws_tcp_->next_layer().async_connect(\n                    results.begin()->endpoint(),\n                    [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                        onConnect(ec, ep);\n                    });\n            }\n        }\n\n        void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n            if (ec) {\n                onError(ec, \"connect\");\n                return;\n            }\n\n            if (device_settings_.use_ssl) {\n                ws_->next_layer().async_handshake(ssl::stream_base::client,\n                    [this](beast::error_code ec) { onSSLhandshake(ec); });\n            } else {\n                ws_tcp_->async_handshake(host_, \"/\",\n                    [this](beast::error_code ec) { onWinsockHandshake(ec); });\n            }\n        }\n\n        void onSSLhandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"SSL handshake\");\n                return;\n            }\n\n            ws_->async_handshake(host_, \"/\",\n                [this](beast::error_code ec) { onWinsockHandshake(ec); });\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"WebSocket handshake\");\n                return;\n            }\n\n            socket_status_ = 1; // connected\n            read();\n        }\n\n        void send(std::string topic, std::string payload) {\n            Work work = std::make_pair(topic, payload);\n            enqueueWork(work);\n        }\n\n        void enqueueWork(Work& work) {\n            std::string message = \"{\\\"topic\\\":\\\"\" + work.first + \"\\\",\\\"payload\\\":\" + work.second + \"}\";\n            if (device_settings_.use_ssl && ws_) {\n                ws_->async_write(net::buffer(message),\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            } else if (!device_settings_.use_ssl && ws_tcp_) {\n                ws_tcp_->async_write(net::buffer(message),\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            }\n        }\n\n        void onWrite(beast::error_code ec, std::size_t) {\n            if (ec) {\n                onError(ec, \"write\");\n                return;\n            }\n        }\n\n        void read() {\n            if (device_settings_.use_ssl && ws_) {\n                ws_->async_read(buffer_,\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onRead(ec, bytes_transferred);\n                    });\n            } else if (!device_settings_.use_ssl && ws_tcp_) {\n                ws_tcp_->async_read(buffer_,\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onRead(ec, bytes_transferred);\n                    });\n            }\n        }\n\n        void onRead(beast::error_code ec, std::size_t) {\n            if (ec) {\n                onError(ec, \"read\");\n                return;\n            }\n\n            std::string message = beast::buffers_to_string(buffer_.data());\n            buffer_.consume(buffer_.size());\n\n            read(); // Continue reading\n        }\n\n        void onError(beast::error_code& ec, std::string stage) {\n            socket_status_ = 0; // disconnected\n            close();\n        }\n\n        void close() {\n            if (device_settings_.use_ssl && ws_) {\n                ws_->async_close(websocket::close_reason(),\n                    [](beast::error_code) {});\n            } else if (!device_settings_.use_ssl && ws_tcp_) {\n                ws_tcp_->async_close(websocket::close_reason(),\n                    [](beast::error_code) {});\n            }\n        }\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device& device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n    };\n\n    std::unique_ptr<Impl> pImpl_;\n};"
    ],
    "unmatched_results": [
      "#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace beast = boost::beast;\nnamespace web = boost::beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = net::ssl;\n\nstruct Device {\n    std::string host;\n    bool use_ssl;\n};\n\nclass Logging {\npublic:\n    void log(const std::string& msg) {}\n};\n\nclass WebOsClient {\nprivate:\n    class Impl {\n    public:\n        enum class SocketStatus { disconnected, connecting, connected };\n\n        Impl(net::io_context& ioc, ssl::context& ctx, Device& device, Logging& log)\n            : ioc_(ioc), ctx_(ctx), device_settings_(device), log_(std::make_shared<Logging>(log)),\n              resolver_(net::make_strand(ioc)), host_(device.host),\n              socket_status_(SocketStatus::disconnected) {}\n\n        void run() {\n            resolver_.async_resolve(host_, \"80\",\n                [self = shared_from_this()](beast::error_code ec, tcp::resolver::results_type results) {\n                    self->onResolve(ec, results);\n                });\n        }\n\n        void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n            if (ec) {\n                onError(ec, \"resolve\");\n                return;\n            }\n\n            if (!results.empty()) {\n                auto ep = *results.begin();\n                if (device_settings_.use_ssl) {\n                    ws_ = web::stream<beast::ssl_stream<beast::tcp_stream>>(ioc_, ctx_);\n                    ws_->next_layer().expires_after(std::chrono::seconds(30));\n                    ws_->next_layer().async_connect(ep,\n                        [self = shared_from_this()](beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n                            self->onConnect(ec, {});\n                        });\n                } else {\n                    ws_tcp_ = web::stream<beast::tcp_stream>(ioc_);\n                    ws_tcp_->next_layer().expires_after(std::chrono::seconds(30));\n                    ws_tcp_->next_layer().async_connect(ep,\n                        [self = shared_from_this()](beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n                            self->onConnect(ec, {});\n                        });\n                }\n            }\n        }\n\n        void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n            if (ec) {\n                onError(ec, \"connect\");\n                return;\n            }\n\n            if (device_settings_.use_ssl && ws_) {\n                ws_->next_layer().async_handshake(ssl::stream_base::client,\n                    [self = shared_from_this()](beast::error_code ec) {\n                        self->onSSLhandshake(ec);\n                    });\n            } else if (ws_tcp_) {\n                ws_tcp_->async_handshake(host_, \"/\",\n                    [self = shared_from_this()](beast::error_code ec) {\n                        self->onWinsockHandshake(ec);\n                    });\n            }\n        }\n\n        void onSSLhandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"SSL handshake\");\n                return;\n            }\n\n            ws_->async_handshake(host_, \"/\",\n                [self = shared_from_this()](beast::error_code ec) {\n                    self->onWinsockHandshake(ec);\n                });\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"WebSocket handshake\");\n                return;\n            }\n\n            socket_status_ = SocketStatus::connected;\n            read();\n        }\n\n        void send(std::string id, std::string message) {\n            std::string payload = \"{\\\"id\\\":\\\"\" + id + \"\\\",\\\"payload\\\":\" + message + \"}\";\n            if (socket_status_ == SocketStatus::connected) {\n                if (device_settings_.use_ssl && ws_) {\n                    ws_->async_write(net::buffer(payload),\n                        [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {\n                            self->onWrite(ec, bytes_transferred);\n                        });\n                } else if (ws_tcp_) {\n                    ws_tcp_->async_write(net::buffer(payload),\n                        [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {\n                            self->onWrite(ec, bytes_transferred);\n                        });\n                }\n            }\n        }\n\n        void onWrite(beast::error_code ec, std::size_t) {\n            if (ec) {\n                onError(ec, \"write\");\n                return;\n            }\n        }\n\n        void read() {\n            if (socket_status_ == SocketStatus::connected) {\n                if (device_settings_.use_ssl && ws_) {\n                    ws_->async_read(buffer_,\n                        [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {\n                            self->onRead(ec, bytes_transferred);\n                        });\n                } else if (ws_tcp_) {\n                    ws_tcp_->async_read(buffer_,\n                        [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {\n                            self->onRead(ec, bytes_transferred);\n                        });\n                }\n            }\n        }\n\n        void onRead(beast::error_code ec, std::size_t) {\n            if (ec) {\n                onError(ec, \"read\");\n                return;\n            }\n\n            std::string data = beast::buffers_to_string(buffer_.data());\n            buffer_.consume(buffer_.size());\n\n            read(); // Continue reading\n        }\n\n        void onError(beast::error_code& ec, std::string stage) {\n            log_->log(\"Error during \" + stage + \": \" + ec.message());\n            close();\n        }\n\n        void enqueueWork(Impl& work) {\n            // Implementation depends on Work type definition\n        }\n\n        void close() {\n            socket_status_ = SocketStatus::disconnected;\n\n            if (ws_) {\n                ws_->close(web::close_code::normal);\n                ws_.reset();\n            }\n\n            if (ws_tcp_) {\n                ws_tcp_->close(web::close_code::normal);\n                ws_tcp_.reset();\n            }\n        }\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device& device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<web::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<web::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        SocketStatus socket_status_;\n    };\n};",
      "#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace WebOsClient {\n\nclass Impl {\npublic:\n    using tcp = boost::asio::ip::tcp;\n    namespace ssl = boost::asio::ssl;\n    namespace beast = boost::beast;\n    namespace websocket = beast::websocket;\n    namespace net = boost::asio;\n\n    struct Work {\n        std::string type;\n        std::string data;\n    };\n\n    Impl(net::io_context& ioc, ssl::context& ctx, Device& device_settings, Logging& log)\n        : ioc_(ioc),\n          ctx_(ctx),\n          device_settings_(device_settings),\n          log_(log.shared_from_this()),\n          resolver_(ioc),\n          buffer_(8192),\n          host_(device_settings.host + \":\" + std::to_string(device_settings.port)),\n          socket_status_(0) {}\n\n    void run() {\n        resolver_.async_resolve(host_, \"ws\",\n            [this](beast::error_code ec, tcp::resolver::results_type results) {\n                onResolve(ec, results);\n            });\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) {\n            onError(ec, \"resolve\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            ws_ = websocket::stream<beast::ssl_stream<beast::tcp_stream>>(ioc_, ctx_);\n            auto& stream = *ws_;\n            stream.next_layer().next_layer().set_verify_mode(ssl::verify_peer);\n            stream.next_layer().next_layer().set_verify_callback(\n                [this](bool preverified, ssl::verify_context& ctx) {\n                    return verifyCertificate(preverified, ctx);\n                });\n\n            stream.next_layer().async_connect(results,\n                [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        } else {\n            ws_tcp_ = websocket::stream<beast::tcp_stream>(ioc_);\n            auto& stream = *ws_tcp_;\n            stream.next_layer().async_connect(results,\n                [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n        if (ec) {\n            onError(ec, \"connect\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            auto& stream = *ws_;\n            stream.next_layer().async_handshake(ssl::stream_base::client,\n                [this](beast::error_code ec) {\n                    onSSLhandshake(ec);\n                });\n        } else {\n            auto& stream = *ws_tcp_;\n            stream.async_handshake(host_, \"/\",\n                [this](beast::error_code ec) {\n                    onWinsockHandshake(ec);\n                });\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"SSL handshake\");\n            return;\n        }\n\n        auto& stream = *ws_;\n        stream.async_handshake(host_, \"/\",\n            [this](beast::error_code ec) {\n                onWinsockHandshake(ec);\n            });\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"WebSocket handshake\");\n            return;\n        }\n\n        socket_status_ = 2; // connected\n        read();\n    }\n\n    void send(std::string type, std::string data) {\n        Work work{std::move(type), std::move(data)};\n        enqueueWork(work);\n    }\n\n    void enqueueWork(Work& work) {\n        bool writing = !write_queue_.empty();\n        write_queue_.push(std::move(work));\n\n        if (!writing) {\n            doWrite();\n        }\n    }\n\n    void doWrite() {\n        if (device_settings_.use_ssl) {\n            auto& stream = *ws_;\n            stream.write_some(false, net::buffer(write_queue_.front().data),\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onWrite(ec, bytes_transferred);\n                });\n        } else {\n            auto& stream = *ws_tcp_;\n            stream.write_some(false, net::buffer(write_queue_.front().data),\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onWrite(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"write\");\n            return;\n        }\n\n        write_queue_.pop();\n        if (!write_queue_.empty()) {\n            doWrite();\n        }\n    }\n\n    void read() {\n        if (device_settings_.use_ssl) {\n            ws_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        } else {\n            ws_tcp_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onRead(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"read\");\n            return;\n        }\n\n        auto const& buffer = buffer_.data();\n        std::string message(boost::asio::buffers_begin(buffer),\n                            boost::asio::buffers_end(buffer));\n        buffer_.consume(buffer.size());\n\n        log_->onMessageReceived(message);\n\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string operation) {\n        if (ec == beast::errc::operation_aborted ||\n            ec == beast::websocket::error::closed ||\n            ec == beast::websocket::error::abort) {\n            return;\n        }\n\n        log_->onError(\"WebSocket \" + operation + \" error: \" + ec.message());\n        close();\n    }\n\n    void close() {\n        socket_status_ = 0; // disconnected\n\n        if (device_settings_.use_ssl && ws_) {\n            ws_->next_layer().close();\n        } else if (ws_tcp_) {\n            ws_tcp_->next_layer().close();\n        }\n    }\n\nprivate:\n    bool verifyCertificate(bool preverified, ssl::verify_context&) {\n        return preverified;\n    }\n\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device& device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n    std::queue<Work> write_queue_;\n};",
      "#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace WebOsClient {\n\nclass Impl {\npublic:\n    using tcp = boost::asio::ip::tcp;\n    namespace ssl = boost::asio::ssl;\n    namespace beast = boost::beast;\n    namespace websocket = beast::websocket;\n\n    struct Work {\n        std::string type;\n        std::string data;\n    };\n\n    Impl(boost::asio::io_context& ioc, ssl::context& ctx, Device& device_settings, Logging& log)\n        : ioc_(ioc)\n        , ctx_(ctx)\n        , device_settings_(device_settings)\n        , log_(log.shared_from_this())\n        , resolver_(ioc)\n        , buffer_(8192)\n        , host_(device_settings.host + \":\" + std::to_string(device_settings.port))\n        , socket_status_(0) {}\n\n    void run() {\n        resolver_.async_resolve(device_settings_.host, std::to_string(device_settings_.port),\n            [this](beast::error_code ec, tcp::resolver::results_type results) {\n                onResolve(ec, results);\n            });\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) {\n            onError(ec, \"resolve\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            ws_ = websocket::stream<beast::ssl_stream<beast::tcp_stream>>(ioc_, ctx_);\n            beast::get_lowest_layer(*ws_).async_connect(results.begin()->endpoint(),\n                [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        } else {\n            ws_tcp_ = websocket::stream<beast::tcp_stream>(ioc_);\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results.begin()->endpoint(),\n                [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n        if (ec) {\n            onError(ec, \"connect\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                [this](beast::error_code ec) {\n                    onSSLhandshake(ec);\n                });\n        } else {\n            ws_tcp_->async_handshake(host_, \"/\",\n                [this](beast::error_code ec) {\n                    onWinsockHandshake(ec);\n                });\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"SSL handshake\");\n            return;\n        }\n\n        ws_->async_handshake(host_, \"/\",\n            [this](beast::error_code ec) {\n                onWinsockHandshake(ec);\n            });\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"WebSocket handshake\");\n            return;\n        }\n\n        socket_status_ = 1; // connected\n        read();\n    }\n\n    void send(std::string type, std::string data) {\n        Work work{std::move(type), std::move(data)};\n        enqueueWork(work);\n    }\n\n    void enqueueWork(Work& work) {\n        auto self = shared_from_this();\n        ioc_.post([this, self, work]() mutable {\n            bool writing = !write_queue_.empty();\n            write_queue_.push(std::move(work));\n            if (!writing) {\n                doWrite();\n            }\n        });\n    }\n\n    void doWrite() {\n        if (write_queue_.empty()) {\n            return;\n        }\n\n        const auto& work = write_queue_.front();\n        std::string message = work.type + \":\" + work.data;\n\n        if (device_settings_.use_ssl) {\n            ws_->async_write(net::buffer(message),\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onWrite(ec, bytes_transferred);\n                });\n        } else {\n            ws_tcp_->async_write(net::buffer(message),\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onWrite(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"write\");\n            return;\n        }\n\n        write_queue_.pop();\n        if (!write_queue_.empty()) {\n            doWrite();\n        }\n    }\n\n    void read() {\n        if (device_settings_.use_ssl) {\n            ws_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        } else {\n            ws_tcp_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onRead(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"read\");\n            return;\n        }\n\n        std::string message = beast::buffers_to_string(buffer_.data());\n        buffer_.consume(buffer_.size());\n\n        log_->info(\"Received: {}\", message);\n\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string operation) {\n        log_->error(\"{} failed: {}\", operation, ec.message());\n\n        if (socket_status_ == 1) { // was connected\n            close();\n        }\n\n        socket_status_ = 0; // disconnected\n    }\n\n    void close() {\n        if (device_settings_.use_ssl && ws_) {\n            ws_->close(websocket::close_reason());\n            ws_.reset();\n        } else if (ws_tcp_) {\n            ws_tcp_->close(websocket::close_reason());\n            ws_tcp_.reset();\n        }\n    }\n\nprivate:\n    boost::asio::io_context& ioc_;\n    ssl::context& ctx_;\n    Device& device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n    std::queue<Work> write_queue_;\n};\n\n} // namespace WebOsClient",
      "#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace WebOsClient {\n\nclass Impl {\npublic:\n    using tcp = boost::asio::ip::tcp;\n    namespace ssl = boost::asio::ssl;\n    namespace beast = boost::beast;\n    namespace websocket = beast::websocket;\n    using Work = std::pair<std::string, std::string>;\n\n    Impl(boost::asio::net::io_context& ioc, ssl::context& ctx, Device& device_settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(device_settings), log_(log.shared_from_this()),\n          resolver_(ioc), buffer_(8192), host_(device_settings.host + \":\" + std::to_string(device_settings.port)),\n          socket_status_(0) {}\n\n    void run() {\n        resolver_.async_resolve(tcp::v4(), device_settings_.host, std::to_string(device_settings_.port),\n            [this](beast::error_code ec, tcp::resolver::results_type results) {\n                onResolve(ec, results);\n            });\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) {\n            onError(ec, \"resolve\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            ws_ = websocket::stream<beast::ssl_stream<beast::tcp_stream>>(ioc_, ctx_);\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        } else {\n            ws_tcp_ = websocket::stream<beast::tcp_stream>(ioc_);\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n        if (ec) {\n            onError(ec, \"connect\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                [this](beast::error_code ec) {\n                    onSSLhandshake(ec);\n                });\n        } else {\n            ws_tcp_->async_handshake(host_, \"/\",\n                [this](beast::error_code ec) {\n                    onWinsockHandshake(ec);\n                });\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"SSL handshake\");\n            return;\n        }\n\n        ws_->async_handshake(host_, \"/\",\n            [this](beast::error_code ec) {\n                onWinsockHandshake(ec);\n            });\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"WebSocket handshake\");\n            return;\n        }\n\n        socket_status_ = 1; // connected\n        read();\n    }\n\n    void send(std::string type, std::string payload) {\n        Work work(std::move(type), std::move(payload));\n        enqueueWork(work);\n    }\n\n    void enqueueWork(Work& work) {\n        auto self = shared_from_this();\n        ioc_.post([this, self, work]() mutable {\n            if (!ws_ && !ws_tcp_) return;\n\n            std::string message = \"{\\\"type\\\":\\\"\" + work.first + \"\\\",\\\"payload\\\":\" + work.second + \"}\";\n\n            if (device_settings_.use_ssl) {\n                ws_->async_write(net::buffer(message),\n                    [this, self](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            } else {\n                ws_tcp_->async_write(net::buffer(message),\n                    [this, self](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            }\n        });\n    }\n\n    void onWrite(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"write\");\n            return;\n        }\n    }\n\n    void read() {\n        if (device_settings_.use_ssl) {\n            ws_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        } else {\n            ws_tcp_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onRead(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"read\");\n            return;\n        }\n\n        std::string message = beast::buffers_to_string(buffer_.data());\n        buffer_.consume(buffer_.size());\n\n        log_->info(\"Received: {}\", message);\n\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string operation) {\n        log_->error(\"{} failed: {}\", operation, ec.message());\n\n        close();\n\n        socket_status_ = 0; // disconnected\n    }\n\n    void close() {\n        if (device_settings_.use_ssl) {\n            if (ws_) {\n                ws_->async_close(websocket::close_code::normal,\n                    [](beast::error_code) {});\n                ws_.reset();\n            }\n        } else {\n            if (ws_tcp_) {\n                ws_tcp_->async_close(websocket::close_code::normal,\n                    [](beast::error_code) {});\n                ws_tcp_.reset();\n            }\n        }\n    }\n\nprivate:\n    boost::asio::net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device& device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n};\n\n} // namespace WebOsClient",
      "#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/post.hpp>\n#include <memory>\n#include <queue>\n\nnamespace WebOsClient {\n\nclass Impl {\npublic:\n    using tcp = boost::asio::ip::tcp;\n    namespace ssl = boost::asio::ssl;\n    namespace beast = boost::beast;\n    namespace websocket = beast::websocket;\n\n    struct Work {\n        std::string type;\n        std::string data;\n    };\n\n    Impl(boost::asio::net::io_context& ioc, ssl::context& ctx, Device& device_settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(device_settings), log_(log.shared_from_this()),\n          resolver_(ioc), buffer_(8192), socket_status_(0) {}\n\n    void run() {\n        host_ = device_settings_.host + \":\" + std::to_string(device_settings_.port);\n        resolver_.async_resolve(device_settings_.host, std::to_string(device_settings_.port),\n            [this](beast::error_code ec, tcp::resolver::results_type results) {\n                onResolve(ec, results);\n            });\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) {\n            onError(ec, \"resolve\");\n            return;\n        }\n        if (device_settings_.use_ssl) {\n            ws_.emplace(ioc_, ctx_);\n            ws_->next_layer().async_connect(results.begin()->endpoint(),\n                [this, results](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        } else {\n            ws_tcp_.emplace(ioc_);\n            ws_tcp_->next_layer().async_connect(results.begin()->endpoint(),\n                [this, results](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n        if (ec) {\n            onError(ec, \"connect\");\n            return;\n        }\n        socket_status_ = 1; // connecting\n        if (device_settings_.use_ssl) {\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                [this](beast::error_code ec) {\n                    onSSLhandshake(ec);\n                });\n        } else {\n            ws_tcp_->async_handshake(host_, \"/\",\n                [this](beast::error_code ec) {\n                    onWinsockHandshake(ec);\n                });\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"ssl handshake\");\n            return;\n        }\n        ws_->async_handshake(host_, \"/\",\n            [this](beast::error_code ec) {\n                onWinsockHandshake(ec);\n            });\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"websocket handshake\");\n            return;\n        }\n        socket_status_ = 2; // connected\n        read();\n    }\n\n    void send(std::string type, std::string data) {\n        auto work = std::make_shared<Work>(Work{std::move(type), std::move(data)});\n        boost::asio::post(ioc_, [this, work]() {\n            bool is_writing = !write_queue_.empty();\n            write_queue_.push_back(*work);\n            if (!is_writing) {\n                doWrite();\n            }\n        });\n    }\n\n    void doWrite() {\n        if (write_queue_.empty()) return;\n        const auto& work = write_queue_.front();\n        if (device_settings_.use_ssl) {\n            ws_->async_write(net::buffer(std::string(work.type + \" \" + work.data)),\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onWrite(ec, bytes_transferred);\n                });\n        } else {\n            ws_tcp_->async_write(net::buffer(std::string(work.type + \" \" + work.data)),\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onWrite(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"write\");\n            return;\n        }\n        write_queue_.pop_front();\n        if (!write_queue_.empty()) {\n            doWrite();\n        }\n    }\n\n    void read() {\n        if (device_settings_.use_ssl) {\n            ws_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        } else {\n            ws_tcp_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onRead(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"read\");\n            return;\n        }\n        auto msg = beast::buffers_to_string(buffer_.data());\n        buffer_.consume(buffer_.size());\n        log_->onMessage(msg);\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string stage) {\n        if (ec == beast::errc::operation_aborted || ec == websocket::error::closed) {\n            socket_status_ = 0;\n            return;\n        }\n        log_->onError(ec.message(), stage);\n        close();\n    }\n\n    void enqueueWork(Work& work) {\n        boost::asio::post(ioc_, [this, &work] {\n            bool is_writing = !write_queue_.empty();\n            write_queue_.push_back(work);\n            if (!is_writing) {\n                doWrite();\n            }\n        });\n    }\n\n    void close() {\n        socket_status_ = 0;\n        if (device_settings_.use_ssl && ws_) {\n            ws_->async_close(websocket::close_reason(),\n                [](beast::error_code) {});\n        } else if (ws_tcp_) {\n            ws_tcp_->async_close(websocket::close_reason(),\n                [](beast::error_code) {});\n        }\n    }\n\nprivate:\n    boost::asio::net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device& device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n    std::deque<Work> write_queue_;\n};\n\n} // namespace WebOsClient",
      "#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <memory>\n#include <string>\n#include <queue>\n\nnamespace WebOsClient {\n\nclass Impl {\npublic:\n    using tcp = boost::asio::ip::tcp;\n    namespace ssl = boost::asio::ssl;\n    namespace beast = boost::beast;\n    namespace websocket = beast::websocket;\n    using Work = std::function<void()>;\n\n    Impl(boost::asio::net::io_context& ioc, ssl::context& ctx, Device& device_settings, Logging& log)\n        : ioc_(ioc),\n          ctx_(ctx),\n          device_settings_(device_settings),\n          log_(log.shared_from_this()),\n          resolver_(ioc),\n          buffer_(8192),\n          host_(device_settings.host + \":\" + std::to_string(device_settings.port)),\n          socket_status_(0) {}\n\n    void run() {\n        resolver_.async_resolve(host_, std::to_string(device_settings_.port),\n            [this](beast::error_code ec, tcp::resolver::results_type results) {\n                onResolve(ec, results);\n            });\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) {\n            onError(ec, \"resolve\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            ws_ = websocket::stream<beast::ssl_stream<beast::tcp_stream>>(ioc_, ctx_);\n            auto& stream = *ws_;\n            stream.next_layer().next_layer().async_connect(\n                results.begin()->endpoint(),\n                [this, &results](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        } else {\n            ws_tcp_ = websocket::stream<beast::tcp_stream>(ioc_);\n            auto& stream = *ws_tcp_;\n            stream.next_layer().async_connect(\n                results.begin()->endpoint(),\n                [this, &results](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                    onConnect(ec, ep);\n                });\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n        if (ec) {\n            onError(ec, \"connect\");\n            return;\n        }\n\n        if (device_settings_.use_ssl) {\n            auto& stream = *ws_;\n            stream.next_layer().async_handshake(\n                ssl::stream_base::client,\n                [this](beast::error_code ec) {\n                    onSSLhandshake(ec);\n                });\n        } else {\n            onWinsockHandshake({});\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"SSL handshake\");\n            return;\n        }\n\n        onWinsockHandshake({});\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"WebSocket handshake\");\n            return;\n        }\n\n        socket_status_ = 1; // connected\n        read();\n    }\n\n    void send(std::string message_type, std::string payload) {\n        std::string message = message_type + \":\" + payload;\n        enqueueWork([this, message]() {\n            if (device_settings_.use_ssl && ws_) {\n                ws_->text(true);\n                ws_->async_write(net::buffer(message),\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            } else if (!device_settings_.use_ssl && ws_tcp_) {\n                ws_tcp_->text(true);\n                ws_tcp_->async_write(net::buffer(message),\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            }\n        });\n    }\n\n    void onWrite(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"write\");\n            return;\n        }\n    }\n\n    void read() {\n        if (device_settings_.use_ssl && ws_) {\n            ws_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        } else if (!device_settings_.use_ssl && ws_tcp_) {\n            ws_tcp_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t bytes_transferred) {\n                    onRead(ec, bytes_transferred);\n                });\n        }\n    }\n\n    void onRead(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"read\");\n            return;\n        }\n\n        beast::flat_buffer buffer;\n        buffer.commit(buffer_.size());\n        std::istream is(&buffer_);\n        std::string message((std::istreambuf_iterator<char>(is)), std::istreambuf_iterator<char>());\n        buffer_.consume(buffer_.size());\n\n        // Process the message here\n\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string operation) {\n        log_->error(\"WebOS client error during {}: {}\", operation, ec.message());\n        close();\n    }\n\n    void enqueueWork(Work& work) {\n        net::post(ioc_, work);\n    }\n\n    void close() {\n        socket_status_ = 0; // disconnected\n\n        if (device_settings_.use_ssl && ws_) {\n            ws_->async_close(websocket::close_code::normal,\n                [this](beast::error_code ec) {});\n        } else if (!device_settings_.use_ssl && ws_tcp_) {\n            ws_tcp_->async_close(websocket::close_code::normal,\n                [this](beast::error_code ec) {});\n        }\n    }\n\nprivate:\n    boost::asio::net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device& device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n};\n\n} // namespace WebOsClient"
    ],
    "match_count": 4,
    "pass@3": 0.8333333333333334,
    "pass@5": 0.9761904761904762
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Implement a TCP client using Boost.Asio for asynchronous network communication, capable of connecting to a server, sending messages, and receiving responses.\n\nClass Description: The `chat_client` class encapsulates a TCP client that manages asynchronous network operations including connection establishment, message reading, and message writing.\n\nAttributes:\n- io_context_: boost::asio::io_context& - Reference to the I/O execution context for asynchronous operations.\n- socket_: tcp::socket - TCP socket for communication with the server.\n- read_msg_: chat_message - Buffer for storing the currently read message.\n- write_msgs_: chat_message_queue - Queue of messages waiting to be sent to the server.\n\nMethods:\n- Constructor: chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints) -> None - Initializes the client with I/O context and server endpoints, then starts the connection process.\n- write: write(const chat_message& msg) -> None - Enqueues a message for asynchronous sending to the server.\n- close: close() -> None - Initiates socket closure to terminate the connection cleanly.\n- do_connect: do_connect(const tcp::resolver::results_type& endpoints) -> None - Asynchronously connects to the server using the provided endpoints.\n- do_read_header: do_read_header() -> None - Asynchronously reads the message header from the server.\n- do_read_body: do_read_body() -> None - Asynchronously reads the message body from the server after header is processed.\n- do_write: do_write() -> None - Asynchronously writes the next queued message to the server.",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\ntypedef std::deque<chat_message> chat_message_queue;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context),\n      socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_,\n        [this, msg]()\n        {\n          bool write_in_progress = !write_msgs_.empty();\n          write_msgs_.push_back(msg);\n          if (!write_in_progress)\n          {\n            do_write();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]() { socket_.close(); });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            std::cout.write(read_msg_.body(), read_msg_.body_length());\n            std::cout << \"\\n\";\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(),\n          write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            write_msgs_.pop_front();\n            if (!write_msgs_.empty())\n            {\n              do_write();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\nprivate:\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  chat_message_queue write_msgs_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context) {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, msg]() {\n            bool write_in_progress = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!write_in_progress) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    // Handle received message\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write() {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    boost::asio::post([this]() {\n                        write_msgs_.pop_front();\n                        if (!write_msgs_.empty()) {\n                            do_write();\n                        }\n                    });\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    std::deque<chat_message> write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    using chat_message_queue = std::deque<chat_message>;\n\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context) {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, &msg]() {\n            bool write_in_progress = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!write_in_progress) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    on_read_handler(read_msg_);\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write() {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    boost::asio::post([this]() {\n                        write_msgs_.pop_front();\n                        if (!write_msgs_.empty()) {\n                            do_write();\n                        }\n                    });\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context), socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_, [this, &msg]()\n    {\n      bool write_in_progress = !write_msgs_.empty();\n      write_msgs_.push_back(msg);\n      if (!write_in_progress)\n      {\n        do_write();\n      }\n    });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]()\n    {\n      socket_.close();\n    });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n      [this](boost::system::error_code ec, const tcp::endpoint&)\n      {\n        if (!ec)\n        {\n          do_read_header();\n        }\n      });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n      boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n      [this](boost::system::error_code ec, std::size_t /*length*/)\n      {\n        if (!ec)\n        {\n          if (read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        }\n        else\n        {\n          socket_.close();\n        }\n      });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n      boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n      [this](boost::system::error_code ec, std::size_t /*length*/)\n      {\n        if (!ec)\n        {\n          // Handle received message here (e.g., print or process)\n          do_read_header();\n        }\n        else\n        {\n          socket_.close();\n        }\n      });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n      boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n      [this](boost::system::error_code ec, std::size_t /*length*/)\n      {\n        if (!ec)\n        {\n          write_msgs_.pop_front();\n          if (!write_msgs_.empty())\n          {\n            do_write();\n          }\n        }\n        else\n        {\n          socket_.close();\n        }\n      });\n  }\n\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  std::deque<chat_message> write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context) {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, &msg]() {\n            bool write_in_progress = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!write_in_progress) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    // Handle received message here (e.g., print or process)\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write() {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    write_msgs_.pop_front();\n                    if (!write_msgs_.empty()) {\n                        do_write();\n                    }\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    std::deque<chat_message> write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context) {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, &msg]() {\n            bool write_in_progress = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!write_in_progress) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    // Handle received message (e.g., print or process)\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write() {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    write_msgs_.pop_front();\n                    if (!write_msgs_.empty()) {\n                        do_write();\n                    }\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    std::deque<chat_message> write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    using chat_message_queue = std::deque<chat_message>;\n\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context) {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, &msg]() {\n            bool write_in_progress = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!write_in_progress) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    // Handle received message here (e.g., print or process)\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write() {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    boost::asio::post([this]() {\n                        write_msgs_.pop_front();\n                        if (!write_msgs_.empty()) {\n                            do_write();\n                        }\n                    });\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    using chat_message_queue = std::deque<chat_message>;\n\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context) {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, &msg]() {\n            bool write_in_progress = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!write_in_progress) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\nprivate:\n    void do_read_header() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    // Handle received message here (e.g., print or process)\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write() {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    write_msgs_.pop_front();\n                    if (!write_msgs_.empty()) {\n                        do_write();\n                    }\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context), socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_,\n        [this, msg]()\n        {\n          bool write_in_progress = !write_msgs_.empty();\n          write_msgs_.push_back(msg);\n          if (!write_in_progress)\n          {\n            do_write();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]() { socket_.close(); });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, const tcp::endpoint&)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            // Handle received message here (e.g., print or process)\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            boost::asio::post(io_context_, [this]()\n                {\n                  write_msgs_.pop_front();\n                  if (!write_msgs_.empty())\n                  {\n                    do_write();\n                  }\n                });\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  std::deque<chat_message> write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context) {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, &msg]() {\n            bool writing = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!writing) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    on_read_handler(read_msg_);\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write() {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    boost::asio::post([this]() {\n                        write_msgs_.pop_front();\n                        if (!write_msgs_.empty()) {\n                            do_write();\n                        }\n                    });\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    std::deque<chat_message> write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context) {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, &msg]() {\n            bool writing = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!writing) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    // Handle received message here (e.g., print or process)\n                    do_read_header();\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    void do_write() {\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    boost::asio::post([this]() {\n                        write_msgs_.pop_front();\n                        if (!write_msgs_.empty()) {\n                            do_write();\n                        }\n                    });\n                } else {\n                    socket_.close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    std::deque<chat_message> write_msgs_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  }
]