[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client cli(location.c_str());\n\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}, {\"Accept\", \"application/json\"}};\n\n    long status_code = 0;\n\n    if (method == \"GET\") {\n        auto res = cli.Get(URI.c_str(), headers);\n        if (res) {\n            status_code = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"POST\") {\n        std::string body = request_data ? request_data->dump() : \"\";\n        auto res = cli.Post(URI.c_str(), headers, body, \"application/json\");\n        if (res) {\n            status_code = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"PUT\") {\n        std::string body = request_data ? request_data->dump() : \"\";\n        auto res = cli.Put(URI.c_str(), headers, body, \"application/json\");\n        if (res) {\n            status_code = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    } else if (method == \"DELETE\") {\n        auto res = cli.Delete(URI.c_str(), headers);\n        if (res) {\n            status_code = res->status;\n            if (response_data && res->status >= 200 && res->status < 300) {\n                *response_data = json::parse(res->body);\n            }\n        }\n    }\n\n    return status_code;\n}"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Implement a TCP client socket class in C++ that handles connection establishment, data transmission, and connection management with a remote server, supporting both IPv4 and IPv6 protocols.\n\nClass Description: The ClientSocket class provides TCP client functionality with support for both IPv4 and IPv6 connections. It handles socket creation, connection establishment with timeout support, send buffer configuration, and connection cleanup. The class is designed to work within a multi-threaded context and supports encryption parameters.\n\nAttributes:\n- dest_: std::string - Destination hostname or IP address to connect to\n- threadCtx_: ThreadCtx& - Reference to thread context containing configuration options\n- sa_: struct addrinfo - Address information structure for socket configuration\n- socket_: std::unique_ptr<WdtSocket> - Smart pointer to the underlying socket implementation\n- peerIp_: std::string - IP address of the connected peer\n\nMethods:\n- Constructor: ClientSocket(ThreadCtx& threadCtx, const string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval) -> void - Initializes the client socket with destination, port, and encryption parameters\n- connect: connect() -> ErrorCode - Establishes connection to the remote server with timeout handling, returns connection status\n- getPeerIp: getPeerIp() -> const std::string& - Returns the IP address of the connected peer\n- setSendBufferSize: setSendBufferSize() -> void - Configures the socket's send buffer size based on thread context options\n- closeConnection: closeConnection() -> void [private] - Closes the active socket connection",
    "Canonical_solution": "#include <fcntl.h>\n#include <folly/Conv.h>\n#include <folly/ScopeGuard.h>\n#include <glog/logging.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <wdt/Reporting.h>\n#include <wdt/util/ClientSocket.h>\n\nnamespace facebook {\nnamespace wdt {\n\nusing std::string;\n\nclass ClientSocket {\npublic:\n  ClientSocket(ThreadCtx &threadCtx, const string &dest,\n               const int port,\n               const EncryptionParams &encryptionParams,\n               int64_t ivChangeInterval)\n      : dest_(dest), threadCtx_(threadCtx) {\n    memset(&sa_, 0, sizeof(sa_));\n    socket_ = std::make_unique<WdtSocket>(threadCtx, port, encryptionParams,\n                                          ivChangeInterval, nullptr);\n    if (threadCtx_.getOptions().ipv6) {\n      sa_.ai_family = AF_INET6;\n    }\n    if (threadCtx_.getOptions().ipv4) {\n      sa_.ai_family = AF_INET;\n    }\n    sa_.ai_socktype = SOCK_STREAM;\n  }\n\n  ErrorCode connect() {\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    WDT_CHECK(fd < 0) << \"Previous connection not closed \" << fd << \" \" << port;\n    \n    struct addrinfo *infoList = nullptr;\n    auto guard = folly::makeGuard([&] {\n      if (infoList) {\n        freeaddrinfo(infoList);\n      }\n    });\n    \n    string portStr = folly::to<string>(port);\n    int res = getaddrinfo(dest_.c_str(), portStr.c_str(), &sa_, &infoList);\n    if (res) {\n      WLOG(ERROR) << \"Failed getaddrinfo \" << dest_ << \" , \" << port << \" : \"\n                  << res << \" : \" << gai_strerror(res);\n      return CONN_ERROR;\n    }\n    \n    int count = 0;\n    for (struct addrinfo *info = infoList; info != nullptr;\n         info = info->ai_next) {\n      ++count;\n      std::string host, port_2;\n      WdtSocket::getNameInfo(info->ai_addr, info->ai_addrlen, host, port_2);\n      WVLOG(2) << \"will connect to \" << host << \" \" << port_2;\n      \n      fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);\n      if (fd == -1) {\n        WPLOG(WARNING) << \"Error making socket for port_2 \" << port_2;\n        continue;\n      }\n      \n      socket_->setFd(fd);\n      setSendBufferSize();\n\n      int sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg |= O_NONBLOCK;\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res < 0) {\n        WPLOG(ERROR) << \"Failed to make the socket non-blocking \" << port_2\n                     << \" sock \" << sockArg << \" res \" << res;\n        closeConnection();\n        continue;\n      }\n\n      if (::connect(fd, info->ai_addr, info->ai_addrlen) != 0) {\n        if (errno != EINPROGRESS) {\n          WPLOG(INFO) << \"Error connecting on \" << host << \" \" << port_2;\n          closeConnection();\n          continue;\n        }\n        \n        auto startTime = Clock::now();\n        int connectTimeout = threadCtx_.getOptions().connect_timeout_millis;\n\n        while (true) {\n          if (threadCtx_.getAbortChecker()->shouldAbort()) {\n            WLOG(ERROR) << \"Transfer aborted during connect \" << port_2 << \" \"\n                        << fd;\n            closeConnection();\n            return ABORT;\n          }\n          \n          int timeElapsed = durationMillis(Clock::now() - startTime);\n          if (timeElapsed >= connectTimeout) {\n            WVLOG(1) << \"connect() timed out\" << host << \" \" << port_2;\n            closeConnection();\n            return CONN_ERROR_RETRYABLE;\n          }\n          \n          int pollTimeout =\n              std::min(connectTimeout - timeElapsed,\n                       threadCtx_.getOptions().abort_check_interval_millis);\n          struct pollfd pollFds[] = {{fd, POLLOUT, 0}};\n\n          if ((res = poll(pollFds, 1, pollTimeout)) <= 0) {\n            if (errno == EINTR) {\n              WVLOG(1) << \"poll() call interrupted. retrying... \" << port_2;\n              continue;\n            }\n            if (res == 0) {\n              WVLOG(1) << \"poll() timed out \" << host << \" \" << port_2;\n              continue;\n            }\n            WPLOG(ERROR) << \"poll() failed \" << host << \" \" << port_2 << \" \"\n                         << fd;\n            closeConnection();\n            return CONN_ERROR;\n          }\n          break;\n        }\n\n        int connectResult;\n        socklen_t len = sizeof(connectResult);\n        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &connectResult, &len) < 0) {\n          WPLOG(WARNING) << \"getsockopt() failed\";\n          closeConnection();\n          continue;\n        }\n        if (connectResult != 0) {\n          WLOG(WARNING) << \"connect did not succeed on \" << host << \" \" << port_2\n                        << \" : \" << strerrorStr(connectResult);\n          closeConnection();\n          continue;\n        }\n      }\n\n      sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg &= (~O_NONBLOCK);\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res == -1) {\n        WPLOG(ERROR) << \"Could not make the socket blocking \" << port_2;\n        closeConnection();\n        continue;\n      }\n      \n      WVLOG(1) << \"Successful connect on \" << fd;\n      peerIp_ = host;\n      sa_ = *info;\n      break;\n    }\n    \n    if (socket_->getFd() < 0) {\n      if (count > 1) {\n        WLOG(INFO) << \"Unable to connect to either of the \" << count << \" addrs\";\n      }\n      return CONN_ERROR_RETRYABLE;\n    }\n    \n    socket_->setSocketTimeouts();\n    socket_->setDscp(threadCtx_.getOptions().dscp);\n    return OK;\n  }\n\n  const std::string &getPeerIp() const {\n    return peerIp_;\n  }\n\n  void setSendBufferSize() {\n    int bufSize = threadCtx_.getOptions().send_buffer_size;\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    if (bufSize <= 0) {\n      return;\n    }\n    int status =\n        ::setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bufSize, sizeof(bufSize));\n    if (status != 0) {\n      WPLOG(ERROR) << \"Failed to set send buffer \" << port << \" size \" << bufSize\n                   << \" fd \" << fd;\n      return;\n    }\n    WVLOG(1) << \"Send buffer size set to \" << bufSize << \" port \" << port;\n  }\n\nprivate:\n  std::string dest_;\n  ThreadCtx &threadCtx_;\n  struct addrinfo sa_;\n  std::unique_ptr<WdtSocket> socket_;\n  std::string peerIp_;\n\n  void closeConnection() {\n    socket_->close();\n  }\n};\n\n}  // namespace wdt\n}  // namespace facebook",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "wrong_result": "#include <string>\n#include <memory>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\nnamespace wdt {\n    class WdtSocket;\n    struct EncryptionParams;\n    struct ThreadCtx;\n\n    enum ErrorCode {\n        OK,\n        ERROR\n    };\n\n    class ClientSocket {\n    public:\n        ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n        ~ClientSocket();\n\n        ErrorCode connect();\n        const std::string& getPeerIp() const;\n        void setSendBufferSize();\n\n    private:\n        void closeConnection();\n\n        std::string dest_;\n        ThreadCtx& threadCtx_;\n        struct addrinfo sa_;\n        std::unique_ptr<WdtSocket> socket_;\n        std::string peerIp_;\n    };\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <vector>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 16\n#define BUFFER_SIZE 4096\n\nclass NetworkClientInfo {\npublic:\n    SOCKET client_socket;\n    std::string ip_address;\n    unsigned short port;\n    std::thread* listen_thread;\n    std::atomic<bool> active;\n\n    NetworkClientInfo(SOCKET sock) : client_socket(sock), port(0), listen_thread(nullptr), active(true) {}\n    ~NetworkClientInfo() {\n        if (listen_thread && listen_thread->joinable()) {\n            listen_thread->join();\n            delete listen_thread;\n        }\n        if (client_socket != INVALID_SOCKET) {\n            closesocket(client_socket);\n        }\n    }\n};\n\nclass NetworkServer {\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n\n    void ClientInfoChanged() {}\n    void ServerListeningChanged() {}\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[BUFFER_SIZE];\n        while (client_info->active.load() && server_online) {\n            int bytes_received = recv(client_info->client_socket, buffer, BUFFER_SIZE, 0);\n            if (bytes_received <= 0) {\n                break;\n            }\n            // Process received data here\n        }\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n            if (it != ServerClients.end()) {\n                ServerClients.erase(it);\n            }\n        }\n        ClientInfoChanged();\n\n        delete client_info;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            sockaddr_storage client_addr;\n            int addr_len = sizeof(client_addr);\n            SOCKET client_socket = accept(server_sock[socket_idx], (sockaddr*)&client_addr, &addr_len);\n\n            if (client_socket == INVALID_SOCKET) {\n                continue;\n            }\n\n            char ip_str[INET6_ADDRSTRLEN];\n            void* addr;\n            unsigned short client_port;\n\n            if (client_addr.ss_family == AF_INET) {\n                sockaddr_in* saddr = (sockaddr_in*)&client_addr;\n                addr = &(saddr->sin_addr);\n                client_port = ntohs(saddr->sin_port);\n            } else {\n                sockaddr_in6* saddr6 = (sockaddr_in6*)&client_addr;\n                addr = &(saddr6->sin6_addr);\n                client_port = ntohs(saddr6->sin6_port);\n            }\n\n            inet_ntop(client_addr.ss_family, addr, ip_str, sizeof(ip_str));\n            NetworkClientInfo* client_info = new NetworkClientInfo(client_socket);\n            client_info->ip_address = std::string(ip_str);\n            client_info->port = client_port;\n\n            {\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                ServerClients.push_back(client_info);\n            }\n            ClientInfoChanged();\n\n            client_info->listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int activity = select(0, &readfds, nullptr, nullptr, &timeout);\n        if (activity > 0 && FD_ISSET(sockfd, &readfds)) {\n            return accept(sockfd, nullptr, nullptr);\n        }\n        return -1;\n    }\n\npublic:\n    NetworkServer(std::vector<void*>& controllers) \n        : host(\"0.0.0.0\"), port_num(8080), server_online(false), server_listening(false), socket_count(0) {\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n            ConnectionThread[i] = nullptr;\n        }\n    }\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            return;\n        }\n\n        server_online = true;\n        struct addrinfo* result = nullptr, hints {};\n\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &result) != 0) {\n            WSACleanup();\n            return;\n        }\n\n        socket_count = 0;\n        for (struct addrinfo* ptr = result; ptr != nullptr && socket_count < MAXSOCK; ptr = ptr->ai_next) {\n            SOCKET sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n            if (sock == INVALID_SOCKET) {\n                continue;\n            }\n\n            int enable = 1;\n            if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<const char*>(&enable), sizeof(enable)) != 0) {\n                closesocket(sock);\n                continue;\n            }\n\n            if (bind(sock, ptr->ai_addr, static_cast<int>(ptr->ai_addrlen)) == SOCKET_ERROR) {\n                closesocket(sock);\n                continue;\n            }\n\n            if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {\n                closesocket(sock);\n                continue;\n            }\n\n            server_sock[socket_count++] = sock;\n        }\n\n        freeaddrinfo(result);\n\n        if (socket_count > 0) {\n            server_listening = true;\n            ServerListeningChanged();\n\n            for (int i = 0; i < socket_count; ++i) {\n                ConnectionThread[i] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, i);\n            }\n        } else {\n            WSACleanup();\n            server_online = false;\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) {\n            return;\n        }\n\n        server_online = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i] && ConnectionThread[i]->joinable()) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n\n            if (server_sock[i] != INVALID_SOCKET) {\n                shutdown(server_sock[i], SD_BOTH);\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            for (auto client : ServerClients) {\n                client->active.store(false);\n                shutdown(client->client_socket, SD_BOTH);\n                if (client->listen_thread && client->listen_thread->joinable()) {\n                    client->listen_thread->join();\n                }\n                delete client;\n            }\n            ServerClients.clear();\n        }\n\n        server_listening = false;\n        ServerListeningChanged();\n\n        WSACleanup();\n    }\n\n    unsigned short GetPort() const {\n        return port_num;\n    }\n};"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Implement a TCP server in C++ that listens for incoming connections, handles client requests in separate child processes, and responds to clients after processing their data.\n\nFunction Description: The function `tcp_server_communication` creates a TCP server that binds to a specified port, listens for incoming connections, and forks child processes to handle each client connection. Each child process reads a character from the client, increments it after a delay, and sends it back before terminating.\n\nInput: None (The function uses predefined constants: port number 9736 and INADDR_ANY for binding to all available network interfaces)\n\nOutput: None (The function runs indefinitely, servicing client requests and doesn't return any value)\n\nNote: The function includes signal handling to prevent zombie processes from terminated child processes. Each client connection is handled in a separate child process while the parent process continues to accept new connections.",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <signal.h>\n\nvoid tcp_server_communication()\n{\n    int server_sockfd = -1;\n    int client_sockfd = -1;\n    int client_len = 0;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n    \n    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(9736);\n    \n    bind(server_sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(server_sockfd, 5);\n    signal(SIGCHLD, SIG_IGN);\n\n    while(1)\n    {\n        char ch = '\\0';\n        client_len = sizeof(client_addr);\n        client_sockfd = accept(server_sockfd, (struct sockaddr*)&client_addr,\n                               (socklen_t *)&client_len);\n\n        if(fork() == 0)\n        {\n            read(client_sockfd, &ch, 1);\n            sleep(5);\n            ch++;\n            write(client_sockfd, &ch, 1);\n            close(client_sockfd);\n            exit(0);\n        }\n        else\n        {\n            close(client_sockfd);\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <iostream>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <signal.h>\n\n#define PORT 9736\n#define INADDR_ANY INADDR_ANY\n\nvoid handle_client(int client_socket) {\n    char buffer[1];\n    if (read(client_socket, buffer, sizeof(buffer)) > 0) {\n        sleep(1);\n        buffer[0]++;\n        write(client_socket, buffer, sizeof(buffer));\n    }\n    close(client_socket);\n    exit(0);\n}\n\nvoid tcp_server_communication() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    socklen_t addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    signal(SIGCHLD, SIG_IGN); // Prevent zombie processes\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, &addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n        if (child_pid == 0) { // Child process\n            close(server_fd);\n            handle_client(new_socket);\n        } else if (child_pid > 0) { // Parent process\n            close(new_socket);\n        } else {\n            perror(\"fork\");\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Implement a UDP echo server using Boost.Asio that listens on a specified port, receives incoming datagrams, and sends them back to the sender.\n\nFunction Description: The function creates a UDP socket bound to a specified port, then enters an infinite loop where it receives datagrams from clients and echoes them back to the sender. This demonstrates basic UDP communication using Boost.Asio.\n\nInput:\n- io_context: boost::asio::io_context& - Reference to an I/O execution context that manages asynchronous operations\n- port: unsigned short - The port number on which the server should listen for incoming UDP datagrams\n\nOutput: None (The function runs indefinitely in a loop, processing incoming datagrams)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\nenum { max_length = 1024 };\n\nvoid server(boost::asio::io_context& io_context, unsigned short port)\n{\n  udp::socket sock(io_context, udp::endpoint(udp::v4(), port));\n  for (;;)\n  {\n    char data[max_length];\n    udp::endpoint sender_endpoint;\n    size_t length = sock.receive_from(\n        boost::asio::buffer(data, max_length), sender_endpoint);\n    sock.send_to(boost::asio::buffer(data, length), sender_endpoint);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "void run_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n\n    while (true) {\n        char data[1024];\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        size_t length = socket.receive_from(boost::asio::buffer(data), sender_endpoint);\n        socket.send_to(boost::asio::buffer(data, length), sender_endpoint);\n    }\n}"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ that supports both plain and TLS (SSL) connections using the WebSocket++ library. The server should handle incoming messages, echo them back to clients, and manage secure connections with proper TLS initialization.\n\nClass Description: The WebSocketServer class encapsulates functionality for creating and managing both plain and TLS WebSocket servers. It initializes server endpoints, sets up message handlers, manages TLS contexts, and runs the server's event loop.\n\nAttributes:\n- ios_: boost::asio::io_service - ASIO I/O service for handling network operations\n- endpoint_plain_: server_plain - WebSocket++ server instance for plain (non-secure) connections\n- endpoint_tls_: server_tls - WebSocket++ server instance for TLS (secure) connections\n\nMethods:\n- init() -> void - Initializes both plain and TLS server endpoints, sets message handlers, TLS initialization handler, and starts listening on ports 80 (plain) and 443 (TLS)\n- run() -> void - Starts the server's event loop to handle connections and messages\n- on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) -> void - Template method that handles incoming messages from clients and echoes them back\n- get_password() -> std::string - Returns the password used for TLS private key encryption\n- on_tls_init(websocketpp::connection_hdl hdl) -> context_ptr - Initializes and configures the TLS context for secure connections",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(), endpoint_tls_() {}\n\n    void init() {\n        endpoint_plain_.init_asio(&ios_);\n        endpoint_plain_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, ::_1, ::_2));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.init_asio(&ios_);\n        endpoint_tls_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, ::_1, ::_2));\n        endpoint_tls_.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, ::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\nprivate:\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl,\n        typename EndpointType::message_ptr msg)\n    {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                << \" and message: \" << msg->get_payload()\n                << std::endl;\n\n        try {\n            s->send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                    << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        std::cout << \"on_tls_init called with hdl: \" << hdl.lock().get() << std::endl;\n        context_ptr ctx(new boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                            boost::asio::ssl::context::no_sslv2 |\n                            boost::asio::ssl::context::no_sslv3 |\n                            boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_client.hpp>\n#include <websocketpp/server_tls.hpp>\n#include <boost/thread.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\ntypedef server_plain::message_ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        endpoint_plain_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n        endpoint_tls_.set_message_handler(websocketpp::lib::bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n\n        endpoint_plain_.set_tls_init_handler(websocketpp::lib::bind(&WebSocketServer::on_tls_init, this, websocketpp::lib::placeholders::_1));\n\n        endpoint_plain_.listen(80);\n        endpoint_tls_.listen(443);\n\n        endpoint_plain_.start_accept();\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        boost::thread_group threads;\n        for(int i = 0; i < 4; ++i) {\n            threads.create_thread(boost::bind(&boost::asio::io_service::run, &ios_));\n        }\n        threads.join_all();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        std::cout << \"Received: \" << msg->get_payload() << std::endl;\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() const {\n        return \"password\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->password_callback(boost::bind(&WebSocketServer::get_password, this));\n        } catch (std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};"
  }
]