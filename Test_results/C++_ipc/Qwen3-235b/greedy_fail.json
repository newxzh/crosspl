[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "#include <httplib.h>\n#include <nlohmann/json.hpp>\nusing json = nlohmann::json;\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data = nullptr, json* response_data = nullptr) {\n    std::string host = location;\n    int port = 80;\n    size_t colon_pos = location.find(':');\n    if (colon_pos != std::string::npos) {\n        std::string port_str = location.substr(colon_pos + 1);\n        try {\n            port = std::stoi(port_str);\n            host = location.substr(0, colon_pos);\n        } catch (...) {}\n    }\n    httplib::Client cli(host.c_str(), port);\n    std::string json_str;\n    if (request_data) {\n        json_str = request_data->dump();\n    }\n    httplib::Result res;\n    if (method == \"GET\") {\n        res = cli.Get(URI.c_str());\n    } else if (method == \"POST\") {\n        res = cli.Post(URI.c_str(), json_str, \"application/json\");\n    } else if (method == \"PUT\") {\n        res = cli.Put(URI.c_str(), json_str, \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = cli.Delete(URI.c_str(), json_str, \"application/json\");\n    } else {\n        return -1;\n    }\n    if (!res) {\n        return -1;\n    }\n    long status_code = res->status;\n    if (status_code >= 200 && status_code < 300 && response_data) {\n        try {\n            *response_data = json::parse(res->body);\n        } catch (...) {}\n    }\n    return status_code;\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a TCP client class that can establish a connection to a server, send and receive data, and handle timeouts for non-blocking operations.\n\nClass Description: The TCPClient class provides functionality for TCP socket communication with a remote server. It supports both blocking and non-blocking operations with timeout capabilities, and handles cross-platform compatibility between Windows and Unix-like systems.\n\nAttributes:\n- address: std::string - The IP address or hostname of the server to connect to\n- port: u16 - The port number of the server to connect to\n- main_socket: SocketHolder (int) - The socket file descriptor for the connection\n- connected: bool - Flag indicating whether the client is currently connected to the server\n\nMethods:\n- Connect() -> bool - Establishes a connection to the server. Returns true if successful.\n- Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Reads data from the server into the buffer. Returns true if all requested bytes were read.\n- Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Writes data from the buffer to the server. Returns true if all bytes were written.\n- Disconnect() -> void - Closes the connection to the server.\n- SetNonBlock(SocketHolder sockFD, bool nonBlocking) -> bool - Sets the blocking mode of the socket. Returns true if successful.\n- ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) -> bool - Attempts to connect with a timeout. Returns true if successful.",
    "Canonical_solution": "#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <cerrno>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <string>\n\n#ifdef _WIN32\n#define WSAEAGAIN WSAEWOULDBLOCK\n#define WSAEMULTIHOP -1\n#define ERRNO(x) WSA##x\n#define GET_ERRNO WSAGetLastError()\n#define poll(x, y, z) WSAPoll(x, y, z);\n#define SHUT_RD SD_RECEIVE\n#define SHUT_WR SD_SEND\n#define SHUT_RDWR SD_BOTH\n#else\n#define ERRNO(x) x\n#define GET_ERRNO errno\n#define closesocket(x) close(x)\n#endif\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n\n    TCPClient(const std::string& address, u16 port) : address(address), port(port) {}\n\n    bool Connect() {\n        if (connected)\n            return true;\n\n        struct addrinfo hints, *addrinfo;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_family = AF_INET;\n\n        if (getaddrinfo(address.data(), NULL, &hints, &addrinfo) != 0) {\n            return false;\n        }\n\n        main_socket = ::socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == static_cast<SocketHolder>(-1)) {\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, true)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        struct sockaddr_in servaddr = {0};\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_addr.s_addr = ((struct sockaddr_in*)(addrinfo->ai_addr))->sin_addr.s_addr;\n        servaddr.sin_port = htons(port);\n        freeaddrinfo(addrinfo);\n\n        if (!ConnectWithTimeout(main_socket, &servaddr, sizeof(servaddr), 10)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t read_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (read_bytes != size) {\n            int new_read = ::recv(main_socket, (char*)((uintptr_t)buffer + read_bytes), \n                (int)(size - read_bytes), 0);\n            if (new_read < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                read_bytes = 0;\n                break;\n            }\n            read_bytes += new_read;\n        }\n        return read_bytes == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t write_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (write_bytes != size) {\n            int new_written = ::send(main_socket, (const char*)((uintptr_t)buffer + write_bytes),\n                                    (int)(size - write_bytes), 0);\n            if (new_written < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                write_bytes = 0;\n                break;\n            }\n            write_bytes += new_written;\n        }\n        return write_bytes == size;\n    }\n\n    void Disconnect() {\n        if (connected) {\n            shutdown(main_socket, SHUT_RDWR);\n            closesocket(main_socket);\n            connected = false;\n        }\n    }\n\nprivate:\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        bool blocking = !nonBlocking;\n#ifdef _WIN32\n        unsigned long nonblocking = (blocking) ? 0 : 1;\n        int ret = ioctlsocket(sockFD, FIONBIO, &nonblocking);\n        if (ret == -1) {\n            return false;\n        }\n#else\n        int flags = ::fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) {\n            return false;\n        }\n\n        flags &= ~O_NONBLOCK;\n        if (!blocking) {\n            flags |= O_NONBLOCK;\n        }\n\n        const int ret = ::fcntl(sockFD, F_SETFL, flags);\n        if (ret == -1) {\n            return false;\n        }\n#endif\n        return true;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len,\n                           int timeout_seconds) {\n        int res = ::connect(sockFD, (struct sockaddr*)server_addr, static_cast<int>(server_addr_len));\n        if (res == -1 && ((GET_ERRNO == ERRNO(EINPROGRESS) || GET_ERRNO == ERRNO(EWOULDBLOCK))) {\n            struct timeval tv;\n            fd_set fdset;\n            FD_ZERO(&fdset);\n            FD_SET(sockFD, &fdset);\n\n            tv.tv_sec = timeout_seconds;\n            tv.tv_usec = 0;\n            int select_res = ::select(static_cast<int>(sockFD + 1), NULL, &fdset, NULL, &tv);\n#ifdef _WIN32\n            if (select_res == 0) {\n                return false;\n            }\n#else\n            bool select_good = false;\n            if (select_res == 1) {\n                int so_error;\n                socklen_t len = sizeof so_error;\n\n                getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n                if (so_error == 0) {\n                    select_good = true;\n                }\n            }\n            if (!select_good) {\n                return false;\n            }\n#endif\n        } else if (res == -1) {\n            return false;\n        }\n        return true;\n    }\n\n    std::string address;\n    u16 port;\n    SocketHolder main_socket = -1;\n    bool connected = false;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "wrong_result": "#include <string>\n#include <cstdint>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <cstring>\n\n#ifdef _WIN32\n#include <Winsock2.h>\n#include <ws2tcpip.h>\nusing SocketHolder = SOCKET;\n#define CLOSE_SOCKET closesocket\n#define SHUT_RDWR SD_BOTH\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#define EINPROGRESS WSAEINPROGRESS\n#define EAGAIN WSAEWOULDBLOCK\n#else\nusing SocketHolder = int;\n#define CLOSE_SOCKET close\n#define SHUT_RDWR SHUT_RDWR\n#endif\n\nclass TCPClient {\npublic:\n    TCPClient(const std::string& address, uint16_t port);\n    ~TCPClient();\n    bool Connect();\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout);\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout);\n    void Disconnect();\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking);\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds);\n\nprivate:\n    std::string address;\n    uint16_t port;\n    SocketHolder main_socket;\n    bool connected;\n};\n\nTCPClient::TCPClient(const std::string& address, uint16_t port) : address(address), port(port), main_socket(INVALID_SOCKET), connected(false) {\n#ifdef _WIN32\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n#endif\n}\n\nTCPClient::~TCPClient() {\n    Disconnect();\n#ifdef _WIN32\n    WSACleanup();\n#endif\n}\n\nbool TCPClient::SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n#ifdef _WIN32\n    unsigned long mode = nonBlocking ? 1 : 0;\n    return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n#else\n    int flags = fcntl(sockFD, F_GETFL, 0);\n    if (flags == -1) return false;\n    flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n    return fcntl(sockFD, F_SETFL, flags) == 0;\n#endif\n}\n\nbool TCPClient::Connect() {\n    Disconnect();\n    main_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (main_socket == INVALID_SOCKET) return false;\n\n    sockaddr_in server_addr{};\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr);\n\n    if (::connect(main_socket, reinterpret_cast<sockaddr*>(&server_addr), sizeof(server_addr)) == 0) {\n        connected = true;\n        return true;\n    } else {\n        Disconnect();\n        return false;\n    }\n}\n\nbool TCPClient::ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n    SetNonBlock(sockFD, true);\n    int result = connect(sockFD, reinterpret_cast<sockaddr*>(server_addr), server_addr_len);\n    if (result == 0) {\n        connected = true;\n        SetNonBlock(sockFD, false);\n        return true;\n    }\n\n#ifdef _WIN32\n    if (errno != WSAEWOULDBLOCK) return false;\n#else\n    if (errno != EINPROGRESS) return false;\n#endif\n\n    timeval tv{};\n    tv.tv_sec = timeout_seconds;\n    fd_set write_fds, except_fds;\n    FD_ZERO(&write_fds);\n    FD_ZERO(&except_fds);\n    FD_SET(sockFD, &write_fds);\n    FD_SET(sockFD, &except_fds);\n\n    int select_result = select(sockFD + 1, nullptr, &write_fds, &except_fds, &tv);\n    if (select_result <= 0) return false;\n\n    if (FD_ISSET(sockFD, &except_fds)) return false;\n\n    int error = 0;\n    socklen_t len = sizeof(error);\n    getsockopt(sockFD, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&error), &len);\n\n    if (error != 0) return false;\n\n    SetNonBlock(sockFD, false);\n    connected = true;\n    return true;\n}\n\nbool TCPClient::Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n    if (!connected || !buffer || size == 0) return false;\n\n    auto timeout_usec = std::chrono::duration_cast<std::chrono::microseconds>(timeout).count();\n    timeval tv{};\n    tv.tv_sec = static_cast<long>(timeout_usec / 1000000);\n    tv.tv_usec = static_cast<long>(timeout_usec % 1000000);\n\n    char* buf = static_cast<char*>(buffer);\n    size_t total_read = 0;\n\n    while (total_read < size) {\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        timeval temp_tv = tv;\n        int select_result = select(main_socket + 1, &read_fds, nullptr, nullptr, &temp_tv);\n\n        if (select_result <= 0) return false;\n\n        if (FD_ISSET(main_socket, &read_fds)) {\n            int bytes_received = recv(main_socket, buf + total_read, static_cast<int>(size - total_read), 0);\n            if (bytes_received <= 0) return false;\n            total_read += bytes_received;\n        }\n    }\n\n    return true;\n}\n\nbool TCPClient::Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n    if (!connected || !buffer || size == 0) return false;\n\n    auto timeout_usec = std::chrono::duration_cast<std::chrono::microseconds>(timeout).count();\n    timeval tv{};\n    tv.tv_sec = static_cast<long>(timeout_usec / 1000000);\n    tv.tv_usec = static_cast<long>(timeout_usec % 1000000);\n\n    const char* buf = static_cast<const char*>(buffer);\n    size_t total_written = 0;\n\n    while (total_written < size) {\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        timeval temp_tv = tv;\n        int select_result = select(main_socket + 1, nullptr, &write_fds, nullptr, &temp_tv);\n\n        if (select_result <= 0) return false;\n\n        if (FD_ISSET(main_socket, &write_fds)) {\n            int bytes_sent = send(main_socket, buf + total_written, static_cast<int>(size - total_written), 0);\n            if (bytes_sent <= 0) return false;\n            total_written += bytes_sent;\n        }\n    }\n\n    return true;\n}\n\nvoid TCPClient::Disconnect() {\n    if (main_socket != INVALID_SOCKET) {\n        shutdown(main_socket, SHUT_RDWR);\n        CLOSE_SOCKET(main_socket);\n        main_socket = INVALID_SOCKET;\n        connected = false;\n    }\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <vector>\n#include <thread>\n#include <mutex>\n#include <string>\n#include <cstring>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\nclass NetworkClientInfo {\npublic:\n    int sock;\n    std::string address;\n};\n\nclass NetworkServer {\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    int server_sock[2];\n    int socket_count;\n    std::thread* ConnectionThread[2];\n\n    void ClientInfoChanged() {}\n    void ServerListeningChanged() {}\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        while (server_online) {\n            int bytes_received = recv(client_info->sock, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) break;\n            // Process received data here\n        }\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.erase(std::remove(ServerClients.begin(), ServerClients.end(), client_info), ServerClients.end());\n            delete client_info;\n        }\n        ClientInfoChanged();\n        close(client_info->sock);\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            fd_set read_fds;\n            FD_ZERO(&read_fds);\n            FD_SET(server_sock[socket_idx], &read_fds);\n\n            timeval timeout;\n            timeout.tv_sec = 1;\n            timeout.tv_usec = 0;\n\n            if (select(server_sock[socket_idx] + 1, &read_fds, nullptr, nullptr, &timeout) <= 0)\n                continue;\n\n            if (FD_ISSET(server_sock[socket_idx], &read_fds)) {\n                sockaddr_in client_addr;\n                socklen_t addr_len = sizeof(client_addr);\n                int client_sock = accept(server_sock[socket_idx], (sockaddr*)&client_addr, &addr_len);\n                if (client_sock >= 0) {\n                    NetworkClientInfo* client_info = new NetworkClientInfo();\n                    client_info->sock = client_sock;\n                    client_info->address = inet_ntoa(client_addr.sin_addr);\n\n                    {\n                        std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                        ServerClients.push_back(client_info);\n                    }\n                    ClientInfoChanged();\n\n                    std::thread* listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n                    listen_thread->detach();\n                }\n            }\n        }\n    }\n\npublic:\n    NetworkServer(std::vector<void*>& controllers) : host(\"0.0.0.0\"), port_num(8080), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        server_online = true;\n        socket_count = 0;\n\n        addrinfo hints, *res;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &res);\n\n        for (addrinfo* p = res; p != nullptr && socket_count < 2; p = p->ai_next) {\n            int sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (sock >= 0) {\n                int opt = 1;\n                setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n                if (bind(sock, p->ai_addr, p->ai_addrlen) == 0 && listen(sock, SOMAXCONN) == 0) {\n                    server_sock[socket_count++] = sock;\n                } else {\n                    close(sock);\n                }\n            }\n        }\n\n        freeaddrinfo(res);\n\n        if (socket_count > 0) {\n            server_listening = true;\n            ServerListeningChanged();\n            for (int i = 0; i < socket_count; ++i) {\n                ConnectionThread[i] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, i);\n            }\n        }\n    }\n\n    void StopServer() {\n        server_online = false;\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n            if (server_sock[i] >= 0) {\n                close(server_sock[i]);\n                server_sock[i] = -1;\n            }\n        }\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            for (NetworkClientInfo* client : ServerClients) {\n                close(client->sock);\n                delete client;\n            }\n            ServerClients.clear();\n        }\n\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    unsigned short GetPort() const {\n        return port_num;\n    }\n};"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a UDP client function using Boost.Asio that sends a request to a UDP server and receives a response.\n\nFunction Description: The function establishes a UDP connection to a specified host, sends a minimal request packet, waits for a response, and prints the received data to standard output. It uses Boost.Asio for asynchronous UDP operations.\n\nInput: \n- host: std::string - The hostname or IP address of the UDP server to connect to\n\nOutput: \n- None (void function), but prints the received data to standard output\n\nNote: The function uses a fixed service name \"daytime\" (port 13) for demonstration purposes. In a real application, this would typically be configurable. The function handles both IPv4 and UDP protocol operations.",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client(const std::string& host)\n{\n    boost::asio::io_context io_context;\n\n    udp::resolver resolver(io_context);\n    udp::endpoint receiver_endpoint =\n      *resolver.resolve(udp::v4(), host, \"daytime\").begin();\n\n    udp::socket socket(io_context);\n    socket.open(udp::v4());\n\n    std::array<char, 1> send_buf  = {{ 0 }};\n    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n\n    std::array<char, 128> recv_buf;\n    udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(\n        boost::asio::buffer(recv_buf), sender_endpoint);\n\n    std::cout.write(recv_buf.data(), len);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host) {\n    namespace asio = boost::asio;\n    using udp = asio::ip::udp;\n\n    asio::io_context io_context;\n    udp::resolver resolver(io_context);\n    auto endpoints = resolver.resolve(host, \"daytime\");\n    if (endpoints.empty()) return;\n    udp::socket socket(io_context);\n    socket.connect(*endpoints.begin());\n    socket.send(asio::buffer(\"\", 0));\n    char recv_buf[1024];\n    size_t len = socket.receive(asio::buffer(recv_buf));\n    std::cout.write(recv_buf, len);\n}"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, process incoming messages, and echo messages back to clients. The server should also support stopping the listening process upon receiving a specific command.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, managing connection handling, message processing, and server lifecycle operations.\n\nAttributes:\n- service_: [asio::io_service&] - Reference to the ASIO I/O service used for network operations\n- port_: [int] - The port number on which the server listens for connections\n- ws_server_: [ws_echo_server] - The WebSocket++ server instance\n\nMethods:\n- Constructor: [WebSocketServer]([asio::io_service& service, int port]) -> [void] - Initializes the WebSocket++ server, sets up logging, message handling, and starts listening on the specified port\n- on_message: [on_message]([websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg]) -> [void] - Callback function that processes incoming messages, echoes them back to clients, and handles the stop-listening command\n- run: [run]() -> [void] - Starts the server's event loop to handle connections and messages",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) \n        : service_(service), port_(port) {\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        if (msg->get_payload() == \"stop-listening\") {\n            ws_server_.stop_listening();\n            return;\n        }\n\n        try {\n            ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n\nusing ws_echo_server = websocketpp::server<websocketpp::config::asio>;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& service, int port)\n        : service_(service), port_(port), ws_server_(service) {\n        ws_server_.set_message_handler(websocketpp::lib::bind(\n            &WebSocketServer::on_message, this, websocketpp::lib::placeholders::_1,\n            websocketpp::lib::placeholders::_2));\n        ws_server_.set_access_channels(websocketpp::log::alevel::all ^ websocketpp::log::alevel::frame_payload);\n        ws_server_.set_error_channels(websocketpp::log::elevel::all);\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP_SERVER\") {\n            ws_server_.stop_listening();\n        }\n        ws_server_.send(hdl, payload, msg->get_opcode());\n    }\n\n    boost::asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections, process incoming messages, and support configurable threading for concurrent operations.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server implementation, providing methods to initialize, configure, and run the server with customizable port and threading settings.\n\nAttributes:\n- testee_server_: [server] - The WebSocket++ server instance that manages connections and message handling\n- port_: [short] - The port number on which the server listens for incoming connections\n- num_threads_: [size_t] - The number of threads to use for handling connections (1 for single-threaded mode)\n\nMethods:\n- WebSocketServer([short port = 9002], [size_t num_threads = 1]) -> [void] - Constructor that initializes the server with specified port and thread count (defaults to port 9002 and single-threaded)\n- run() -> [void] - Starts the WebSocket server, sets up message handlers, begins listening on the specified port, and manages the server's event loop(s)\n- on_message([websocketpp::connection_hdl hdl], [message_ptr msg]) -> [void] - Message handler that echoes received messages back to the client (private method)\n- on_socket_init([websocketpp::connection_hdl hdl], [boost::asio::ip::tcp::socket & s]) -> [void] - Socket initialization handler that enables TCP_NODELAY for reduced latency (private method)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/extensions/permessage_deflate/enabled.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <websocketpp/common/thread.hpp>\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::message_ptr message_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) \n        : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        try {\n            testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n            testee_server_.clear_error_channels(websocketpp::log::alevel::all);\n\n            testee_server_.init_asio();\n            testee_server_.set_reuse_addr(true);\n\n            testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n            testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, ::_1, ::_2));\n\n            testee_server_.set_listen_backlog(8192);\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n\n            if (num_threads_ == 1) {\n                testee_server_.run();\n            } else {\n                std::vector<websocketpp::lib::shared_ptr<websocketpp::lib::thread>> ts;\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts.push_back(websocketpp::lib::make_shared<websocketpp::lib::thread>(&server::run, &testee_server_));\n                }\n\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts[i]->join();\n                }\n            }\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket & s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <thread>\n#include <vector>\n\nclass WebSocketServer {\npublic:\n    using server = websocketpp::server<websocketpp::config::asio>;\n    using message_ptr = server::message_ptr;\n\n    WebSocketServer(short port = 9002, size_t num_threads = 1);\n    void run();\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg);\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s);\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};\n\nWebSocketServer::WebSocketServer(short port, size_t num_threads)\n    : port_(port), num_threads_(num_threads) {\n    testee_server_.set_reuse_addr(true);\n}\n\nvoid WebSocketServer::run() {\n    testee_server_.set_message_handler(std::bind(&WebSocketServer::on_message, this, _1, _2));\n    testee_server_.set_socket_init_handler(std::bind(&WebSocketServer::on_socket_init, this, _1, _2));\n\n    try {\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n    } catch (...) {\n        return;\n    }\n\n    if (num_threads_ == 1) {\n        testee_server_.run();\n    } else {\n        boost::asio::io_service& io = testee_server_.get_io_service();\n        std::vector<std::thread> threads;\n        for (size_t i = 0; i < num_threads_; ++i) {\n            threads.emplace_back([&io](){\n                io.run();\n            });\n        }\n        for (auto& t : threads) {\n            t.join();\n        }\n    }\n}\n\nvoid WebSocketServer::on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n    testee_server_.send(hdl, msg->get_payload());\n}\n\nvoid WebSocketServer::on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket& s) {\n    boost::asio::ip::tcp::no_delay option(true);\n    s.set_option(option);\n}"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio.hpp>\n#include <map>\n#include <string>\n#include <iostream>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_type;\ntypedef server_type::message_ptr message_ptr;\ntypedef server_type::connection_hdl connection_hdl;\n\nclass print_server {\nprivate:\n    struct connection_data {\n        int sessionid;\n        std::string name;\n    };\n    int m_next_sessionid;\n    server_type m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::runtime_error(\"Connection not found\");\n        }\n        return it->second;\n    }\n\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.set_open_handler([this](connection_hdl hdl) { this->on_open(hdl); });\n        m_server.set_close_handler([this](connection_hdl hdl) { this->on_close(hdl); });\n        m_server.set_message_handler([this](connection_hdl hdl, message_ptr msg) { this->on_message(hdl, msg); });\n        m_server.init_asio();\n    }\n\n    void on_open(connection_hdl hdl) {\n        int sid = m_next_sessionid++;\n        connection_data data;\n        data.sessionid = sid;\n        data.name = \"Unnamed\";\n        m_connections.emplace(hdl, data);\n        std::cout << \"Connection opened with session ID \" << sid << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n            std::cout << \"Connection closed for session ID \" << data.sessionid << \", name: \" << data.name << std::endl;\n            m_connections.erase(hdl);\n        } catch (...) {}\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n        std::string payload = msg->get_payload();\n        if (payload.substr(0, 5) == \"name:\") {\n            data.name = payload.substr(5);\n            std::cout << \"Session ID \" << data.sessionid << \" set name to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Message from session \" << data.sessionid << \" (\" << data.name << \"): \" << payload << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections and echo back received messages.\n\nClass Description: The utility_server class encapsulates a WebSocket server that listens for incoming connections, receives messages from clients, and echoes them back. It uses WebSocket++ with ASIO for network handling.\n\nAttributes:\n- m_endpoint: [server] - The WebSocket++ server instance that manages connections and message handling.\n\nMethods:\n- utility_server() - [Constructor] -> [void] - Initializes the server with logging settings, ASIO, and sets up the message handler.\n- echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by echoing them back to the client.\n- run() -> [void] - Starts the server, begins listening on port 9002, and runs the ASIO event loop.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <functional>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n         // Set logging settings\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all ^ websocketpp::log::alevel::frame_payload);\n\n        // Initialize Asio\n        m_endpoint.init_asio();\n\n        // Set the default message handler to the echo handler\n        m_endpoint.set_message_handler(std::bind(\n            &utility_server::echo_handler, this,\n            std::placeholders::_1, std::placeholders::_2\n        ));\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        // write a new message\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        // Listen on port 9002\n        m_endpoint.listen(9002);\n\n        // Queues a connection accept operation\n        m_endpoint.start_accept();\n\n        // Start the Asio io_service run loop\n        m_endpoint.run();\n    }\nprivate:\n    server m_endpoint;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio.hpp>\n\nclass utility_server {\nprivate:\n    using server = websocketpp::server<websocketpp::config::asio>;\n    server m_endpoint;\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\npublic:\n    utility_server() {\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n        m_endpoint.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {\n            echo_handler(hdl, msg);\n        });\n        m_endpoint.init();\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n};"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Implement a TCP client using Boost.Asio for asynchronous network communication, capable of connecting to a server, sending messages, and receiving responses.\n\nClass Description: The `chat_client` class encapsulates a TCP client that manages asynchronous network operations including connection establishment, message reading, and message writing.\n\nAttributes:\n- io_context_: boost::asio::io_context& - Reference to the I/O execution context for asynchronous operations.\n- socket_: tcp::socket - TCP socket for communication with the server.\n- read_msg_: chat_message - Buffer for storing the currently read message.\n- write_msgs_: chat_message_queue - Queue of messages waiting to be sent to the server.\n\nMethods:\n- Constructor: chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints) -> None - Initializes the client with I/O context and server endpoints, then starts the connection process.\n- write: write(const chat_message& msg) -> None - Enqueues a message for asynchronous sending to the server.\n- close: close() -> None - Initiates socket closure to terminate the connection cleanly.\n- do_connect: do_connect(const tcp::resolver::results_type& endpoints) -> None - Asynchronously connects to the server using the provided endpoints.\n- do_read_header: do_read_header() -> None - Asynchronously reads the message header from the server.\n- do_read_body: do_read_body() -> None - Asynchronously reads the message body from the server after header is processed.\n- do_write: do_write() -> None - Asynchronously writes the next queued message to the server.",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\ntypedef std::deque<chat_message> chat_message_queue;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context),\n      socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_,\n        [this, msg]()\n        {\n          bool write_in_progress = !write_msgs_.empty();\n          write_msgs_.push_back(msg);\n          if (!write_in_progress)\n          {\n            do_write();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]() { socket_.close(); });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            std::cout.write(read_msg_.body(), read_msg_.body_length());\n            std::cout << \"\\n\";\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(),\n          write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            write_msgs_.pop_front();\n            if (!write_msgs_.empty())\n            {\n              do_write();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\nprivate:\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  chat_message_queue write_msgs_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "#include <boost/asio.hpp>\n#include <deque>\n#include <memory>\n\nusing boost::asio::ip::tcp;\n\nclass chat_message {\npublic:\n    enum { header_length = 4 };\n    enum { max_body_length = 512 };\n\n    chat_message() : body_length_(0) {}\n\n    const char* data() const { return data_; }\n    char* data() { return data_; }\n    std::size_t length() const { return header_length + body_length_; }\n\n    const char* body() const { return data_ + header_length; }\n    char* body() { return data_ + header_length; }\n    std::size_t body_length() const { return body_length_; }\n\n    void body_length(std::size_t new_length) {\n        body_length_ = new_length;\n    }\n\nprivate:\n    std::size_t body_length_;\n    char data_[header_length + max_body_length];\n};\n\ntypedef std::deque<chat_message> chat_message_queue;\n\nclass chat_client : public std::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context), write_msgs_() {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        boost::asio::post(io_context_, [this, &msg]() {\n            bool write_in_progress = !write_msgs_.empty();\n            write_msgs_.push_back(msg);\n            if (!write_in_progress) {\n                do_write();\n            }\n        });\n    }\n\n    void close() {\n        boost::asio::post(io_context_, [this]() { socket_.close(); });\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        auto self(shared_from_this());\n        boost::asio::async_connect(socket_, endpoints,\n            [this, self](boost::system::error_code ec, tcp::endpoint) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        auto self(shared_from_this());\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this, self](boost::system::error_code ec, std::size_t) {\n                if (!ec) {\n                    read_msg_.body_length(0); // Assume header contains body length\n                    do_read_body();\n                }\n            });\n    }\n\n    void do_read_body() {\n        auto self(shared_from_this());\n        boost::asio::async_read(socket_,\n            boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this, self](boost::system::error_code ec, std::size_t) {\n                if (!ec) {\n                    // Process received message here\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_write() {\n        auto self(shared_from_this());\n        boost::asio::async_write(socket_,\n            boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this, self](boost::system::error_code ec, std::size_t) {\n                if (!ec) {\n                    write_msgs_.pop_front();\n                    if (!write_msgs_.empty()) {\n                        do_write();\n                    }\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n};"
  }
]