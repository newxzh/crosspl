[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "```cpp\n#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client cli(location);\n    cli.set_timeout(10, 0);\n\n    httplib::Headers headers;\n    headers.emplace(\"Content-Type\", \"application/json\");\n\n    std::string full_url = \"http://\" + location + URI;\n\n    if (method == \"GET\") {\n        auto res = cli.Get(full_url.c_str(), headers);\n        if (res && res->status >= 200 && res->status < 300) {\n            if (response_data && !res->body.empty()) {\n                try {\n                    *response_data = json::parse(res->body);\n                } catch (...) {\n                    // Handle parsing error if needed\n                }\n            }\n            return res->status;\n        }\n    } else if (method == \"POST\") {\n        std::string request_body;\n        if (request_data) {\n            request_body = request_data->dump();\n        }\n        auto res = cli.Post(full_url.c_str(), headers, request_body, \"application/json\");\n        if (res && res->status >= 200 && res->status < 300) {\n            if (response_data && !res->body.empty()) {\n                try {\n                    *response_data = json::parse(res->body);\n                } catch (...) {\n                    // Handle parsing error if needed\n                }\n            }\n            return res->status;\n        }\n    } else if (method == \"PUT\") {\n        std::string request_body;\n        if (request_data) {\n            request_body = request_data->dump();\n        }\n        auto res = cli.Put(full_url.c_str(), headers, request_body, \"application/json\");\n        if (res && res->status >= 200 && res->status < 300) {\n            if (response_data && !res->body.empty()) {\n                try {\n                    *response_data = json::parse(res->body);\n                } catch (...) {\n                    // Handle parsing error if needed\n                }\n            }\n            return res->status;\n        }\n    } else if (method == \"DELETE\") {\n        auto res = cli.Delete(full_url.c_str(), headers);\n        if (res && res->status >= 200 && res->status < 300) {\n            if (response_data && !res->body.empty()) {\n                try {\n                    *response_data = json::parse(res->body);\n                } catch (...) {\n                    // Handle parsing error if needed\n                }\n            }\n            return res->status;\n        }\n    }\n\n    return -1;\n}\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a TCP client class that can establish a connection to a server, send and receive data, and handle timeouts for non-blocking operations.\n\nClass Description: The TCPClient class provides functionality for TCP socket communication with a remote server. It supports both blocking and non-blocking operations with timeout capabilities, and handles cross-platform compatibility between Windows and Unix-like systems.\n\nAttributes:\n- address: std::string - The IP address or hostname of the server to connect to\n- port: u16 - The port number of the server to connect to\n- main_socket: SocketHolder (int) - The socket file descriptor for the connection\n- connected: bool - Flag indicating whether the client is currently connected to the server\n\nMethods:\n- Connect() -> bool - Establishes a connection to the server. Returns true if successful.\n- Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Reads data from the server into the buffer. Returns true if all requested bytes were read.\n- Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Writes data from the buffer to the server. Returns true if all bytes were written.\n- Disconnect() -> void - Closes the connection to the server.\n- SetNonBlock(SocketHolder sockFD, bool nonBlocking) -> bool - Sets the blocking mode of the socket. Returns true if successful.\n- ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) -> bool - Attempts to connect with a timeout. Returns true if successful.",
    "Canonical_solution": "#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <cerrno>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <string>\n\n#ifdef _WIN32\n#define WSAEAGAIN WSAEWOULDBLOCK\n#define WSAEMULTIHOP -1\n#define ERRNO(x) WSA##x\n#define GET_ERRNO WSAGetLastError()\n#define poll(x, y, z) WSAPoll(x, y, z);\n#define SHUT_RD SD_RECEIVE\n#define SHUT_WR SD_SEND\n#define SHUT_RDWR SD_BOTH\n#else\n#define ERRNO(x) x\n#define GET_ERRNO errno\n#define closesocket(x) close(x)\n#endif\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n\n    TCPClient(const std::string& address, u16 port) : address(address), port(port) {}\n\n    bool Connect() {\n        if (connected)\n            return true;\n\n        struct addrinfo hints, *addrinfo;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_family = AF_INET;\n\n        if (getaddrinfo(address.data(), NULL, &hints, &addrinfo) != 0) {\n            return false;\n        }\n\n        main_socket = ::socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == static_cast<SocketHolder>(-1)) {\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, true)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        struct sockaddr_in servaddr = {0};\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_addr.s_addr = ((struct sockaddr_in*)(addrinfo->ai_addr))->sin_addr.s_addr;\n        servaddr.sin_port = htons(port);\n        freeaddrinfo(addrinfo);\n\n        if (!ConnectWithTimeout(main_socket, &servaddr, sizeof(servaddr), 10)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t read_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (read_bytes != size) {\n            int new_read = ::recv(main_socket, (char*)((uintptr_t)buffer + read_bytes), \n                (int)(size - read_bytes), 0);\n            if (new_read < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                read_bytes = 0;\n                break;\n            }\n            read_bytes += new_read;\n        }\n        return read_bytes == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t write_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (write_bytes != size) {\n            int new_written = ::send(main_socket, (const char*)((uintptr_t)buffer + write_bytes),\n                                    (int)(size - write_bytes), 0);\n            if (new_written < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                write_bytes = 0;\n                break;\n            }\n            write_bytes += new_written;\n        }\n        return write_bytes == size;\n    }\n\n    void Disconnect() {\n        if (connected) {\n            shutdown(main_socket, SHUT_RDWR);\n            closesocket(main_socket);\n            connected = false;\n        }\n    }\n\nprivate:\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        bool blocking = !nonBlocking;\n#ifdef _WIN32\n        unsigned long nonblocking = (blocking) ? 0 : 1;\n        int ret = ioctlsocket(sockFD, FIONBIO, &nonblocking);\n        if (ret == -1) {\n            return false;\n        }\n#else\n        int flags = ::fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) {\n            return false;\n        }\n\n        flags &= ~O_NONBLOCK;\n        if (!blocking) {\n            flags |= O_NONBLOCK;\n        }\n\n        const int ret = ::fcntl(sockFD, F_SETFL, flags);\n        if (ret == -1) {\n            return false;\n        }\n#endif\n        return true;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len,\n                           int timeout_seconds) {\n        int res = ::connect(sockFD, (struct sockaddr*)server_addr, static_cast<int>(server_addr_len));\n        if (res == -1 && ((GET_ERRNO == ERRNO(EINPROGRESS) || GET_ERRNO == ERRNO(EWOULDBLOCK))) {\n            struct timeval tv;\n            fd_set fdset;\n            FD_ZERO(&fdset);\n            FD_SET(sockFD, &fdset);\n\n            tv.tv_sec = timeout_seconds;\n            tv.tv_usec = 0;\n            int select_res = ::select(static_cast<int>(sockFD + 1), NULL, &fdset, NULL, &tv);\n#ifdef _WIN32\n            if (select_res == 0) {\n                return false;\n            }\n#else\n            bool select_good = false;\n            if (select_res == 1) {\n                int so_error;\n                socklen_t len = sizeof so_error;\n\n                getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n                if (so_error == 0) {\n                    select_good = true;\n                }\n            }\n            if (!select_good) {\n                return false;\n            }\n#endif\n        } else if (res == -1) {\n            return false;\n        }\n        return true;\n    }\n\n    std::string address;\n    u16 port;\n    SocketHolder main_socket = -1;\n    bool connected = false;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "wrong_result": "#include <iostream>\n#include <string>\n#include <chrono>\n#include <thread>\n#include <vector>\n#include <stdexcept>\n#include <cstring>\n\n#if defined(_WIN32)\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#pragma comment(lib, \"Ws2_32.lib\")\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#endif\n\nclass SocketHolder {\npublic:\n    SocketHolder(int fd = -1) : fd_(fd) {}\n    ~SocketHolder() {\n        if (fd_ != -1) {\n#if defined(_WIN32)\n            closesocket(fd_);\n#else\n            close(fd_);\n#endif\n        }\n    }\n\n    int get() const { return fd_; }\n    void reset(int fd = -1) {\n        if (fd_ != -1) {\n#if defined(_WIN32)\n            closesocket(fd_);\n#else\n            close(fd_);\n#endif\n        }\n        fd_ = fd;\n    }\n\nprivate:\n    int fd_;\n};\n\nclass TCPClient {\npublic:\n    TCPClient(const std::string& address, uint16_t port) : address_(address), port_(port), connected_(false) {}\n\n    bool Connect() {\n        main_socket_.reset(socket(AF_INET, SOCK_STREAM, 0));\n        if (main_socket_.get() == -1) {\n            return false;\n        }\n\n        struct sockaddr_in server_addr{};\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port_);\n        inet_pton(AF_INET, address_.c_str(), &server_addr.sin_addr);\n\n        if (!ConnectWithTimeout(main_socket_.get(), &server_addr, sizeof(server_addr), 5)) {\n            return false;\n        }\n\n        connected_ = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected_) return false;\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket_.get(), &read_fds);\n\n        timeval tv;\n        tv.tv_sec = timeout / 1e9;\n        tv.tv_usec = (timeout % 1e9) / 1e3;\n\n        int select_result = select(main_socket_.get() + 1, &read_fds, nullptr, nullptr, &tv);\n        if (select_result <= 0) {\n            return false;\n        }\n\n        ssize_t bytes_read = recv(main_socket_.get(), static_cast<char*>(buffer), static_cast<int>(size), 0);\n        return bytes_read == static_cast<ssize_t>(size);\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected_) return false;\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket_.get(), &write_fds);\n\n        timeval tv;\n        tv.tv_sec = timeout / 1e9;\n        tv.tv_usec = (timeout % 1e9) / 1e3;\n\n        int select_result = select(main_socket_.get() + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result <= 0) {\n            return false;\n        }\n\n        ssize_t bytes_written = send(main_socket_.get(), static_cast<const char*>(buffer), static_cast<int>(size), 0);\n        return bytes_written == static_cast<ssize_t>(size);\n    }\n\n    void Disconnect() {\n        if (connected_) {\n            connected_ = false;\n            main_socket_.reset();\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n#if defined(_WIN32)\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) == 0;\n#endif\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        SetNonBlock(sockFD, true);\n\n        int connect_result = connect(sockFD, static_cast<struct sockaddr*>(server_addr), static_cast<int>(server_addr_len));\n        if (connect_result == 0) {\n            SetNonBlock(sockFD, false);\n            return true;\n        }\n\n        if (errno != EINPROGRESS) {\n            return false;\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        int select_result = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result <= 0) {\n            return false;\n        }\n\n        int so_error;\n        socklen_t error_len = sizeof(so_error);\n        if (getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &error_len) < 0) {\n            return false;\n        }\n\n        if (so_error != 0) {\n            return false;\n        }\n\n        SetNonBlock(sockFD, false);\n        return true;\n    }\n\nprivate:\n    std::string address_;\n    uint16_t port_;\n    SocketHolder main_socket_;\n    bool connected_;\n};"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a UDP receiver class in C++ that listens for incoming UDP packets on a specified port, processes them, and forwards them to a network handling component. The class should handle socket creation, binding, and packet reception in a non-blocking manner using polling.\n\nClass Description: The `UDPRecv` class is responsible for setting up a UDP socket server that listens for incoming messages on a specified port. It uses polling to check for incoming data without blocking, and forwards received messages to a network handling component (`DFNetWork`). The class manages the socket lifecycle and provides methods to initialize, start, and stop the receiver.\n\nAttributes:\n- m_poDFNetWork: [DFNetWork*] - Pointer to the network handling component that processes received messages\n- m_iSockFD: [int] - File descriptor for the UDP socket\n- m_bIsEnd: [bool] - Flag indicating whether the receiver should stop running\n- m_bIsStarted: [bool] - Flag indicating whether the receiver has started\n\nMethods:\n- UDPRecv(DFNetWork* poDFNetWork) -> [void] - Constructor that initializes the receiver with a network handling component\n- ~UDPRecv() -> [void] - Destructor that closes the socket if it's open\n- Stop() -> [void] - Signals the receiver to stop and waits for it to finish\n- Init(int iPort) -> [int] - Initializes the UDP socket and binds it to the specified port (returns 0 on success, -1 on failure)\n- run() -> [void] - Main execution loop that polls for incoming messages and processes them (runs in a separate thread)",
    "Canonical_solution": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include \"dfnetwork.h\"\n\nnamespace phxpaxos {\n\nclass UDPRecv\n{\npublic:\n    UDPRecv(DFNetWork * poDFNetWork);\n    ~UDPRecv();\n\n    void Stop();\n    int Init(const int iPort);\n    void run();\n\nprivate:\n    DFNetWork * m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n};\n\nUDPRecv::UDPRecv(DFNetWork * poDFNetWork) \n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false)\n{\n}\n\nUDPRecv::~UDPRecv()\n{\n    if (m_iSockFD != -1)\n    {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n    }\n}\n\nvoid UDPRecv::Stop()\n{\n    if (m_bIsStarted)\n    {\n        m_bIsEnd = true;\n        join();\n    }\n}\n\nint UDPRecv::Init(const int iPort)\n{\n    if ((m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0)) < 0) \n    {\n        return -1;\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(iPort);\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    int enable = 1;\n    setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int));\n\n    if (bind(m_iSockFD, (struct sockaddr *)&addr, sizeof(addr)) < 0) \n    {\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid UDPRecv::run()\n{\n    m_bIsStarted = true;\n\n    char sBuffer[65536] = {0};\n\n    struct sockaddr_in addr;\n    socklen_t addr_len = sizeof(struct sockaddr_in);\n    memset(&addr, 0, sizeof(addr));\n\n    while(true)\n    {\n        if (m_bIsEnd)\n        {\n            return;\n        }\n\n        struct pollfd fd;\n        int ret;\n\n        fd.fd = m_iSockFD;\n        fd.events = POLLIN;\n        ret = poll(&fd, 1, 500);\n\n        if (ret == 0 || ret == -1)\n        {\n            continue;\n        }\n        \n        int iRecvLen = recvfrom(m_iSockFD, sBuffer, sizeof(sBuffer), 0,\n                (struct sockaddr *)&addr, &addr_len);\n\n        if (iRecvLen > 0)\n        {\n            m_poDFNetWork->OnReceiveMessage(sBuffer, iRecvLen);\n        }\n    }\n}\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 152,
    "wrong_result": "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/poll.h>\n#include <thread>\n#include <atomic>\n\nclass DFNetWork;\n\nclass UDPRecv {\npublic:\n    UDPRecv(DFNetWork* poDFNetWork);\n    ~UDPRecv();\n\n    void Stop();\n    int Init(int iPort);\n    void run();\n\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    std::atomic<bool> m_bIsEnd;\n    std::atomic<bool> m_bIsStarted;\n    std::thread m_thread;\n};\n\nUDPRecv::UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(true), m_bIsStarted(false) {}\n\nUDPRecv::~UDPRecv() {\n    if (m_iSockFD != -1) {\n        close(m_iSockFD);\n    }\n}\n\nvoid UDPRecv::Stop() {\n    m_bIsEnd = true;\n    if (m_thread.joinable()) {\n        m_thread.join();\n    }\n}\n\nint UDPRecv::Init(int iPort) {\n    m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n    if (m_iSockFD == -1) {\n        return -1;\n    }\n\n    sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n    serverAddr.sin_port = htons(iPort);\n\n    if (bind(m_iSockFD, (sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n        return -1;\n    }\n\n    m_bIsEnd = false;\n    m_bIsStarted = true;\n    m_thread = std::thread(&UDPRecv::run, this);\n    return 0;\n}\n\nvoid UDPRecv::run() {\n    struct pollfd pfd;\n    pfd.fd = m_iSockFD;\n    pfd.events = POLLIN;\n\n    char buffer[65536];\n    socklen_t addrLen = sizeof(struct sockaddr_in);\n\n    while (!m_bIsEnd) {\n        int ret = poll(&pfd, 1, 100);\n        if (ret > 0 && (pfd.revents & POLLIN)) {\n            ssize_t bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, nullptr, &addrLen);\n            if (bytesReceived > 0) {\n                m_poDFNetWork->ProcessMessage(buffer, static_cast<size_t>(bytesReceived));\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a UDP server class using Boost.Asio that asynchronously receives datagrams and sends responses.\n\nClass Description: The udp_server class implements a UDP server that listens for incoming datagrams on a specified port and responds with a daytime string. It uses Boost.Asio for asynchronous network operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received message\n- recv_buffer_: [std::array<char, 1>] - Buffer for receiving incoming datagrams\n\nMethods:\n- udp_server([boost::asio::io_context&] io_context) -> [void] - Constructor that initializes the UDP socket and starts listening\n- start_receive() -> [void] - Begins asynchronous reception of UDP datagrams\n- handle_receive([const boost::system::error_code&] error) -> [void] - Callback for handling received datagrams and sending responses\n- handle_send([std::shared_ptr<std::string>] message) -> [void] - Callback for handling completed send operations",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error));\n  }\n\n  void handle_receive(const boost::system::error_code& error)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/)\n  {\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "wrong_result": "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint remote_endpoint_;\nstd::array<char, 1> recv_buffer_;\n\nudp_server(boost::asio::io_context& io_context) : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n    start_receive();\n}\n\nvoid start_receive() {\n    socket_.async_receive_from(boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n            handle_receive(error);\n        });\n}\n\nvoid handle_receive(const boost::system::error_code& error) {\n    if (!error) {\n        std::string daytime = boost::posix_time::second_clock::local_time().to_string();\n        std::shared_ptr<std::string> message = std::make_shared<std::string>(daytime);\n        socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n            [this, message](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                handle_send(message);\n            });\n    }\n    start_receive();\n}\n\nvoid handle_send(std::shared_ptr<std::string> message) {\n    // Handle send completion if needed\n}"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that can asynchronously receive and send datagrams.\n\nClass Description: The `server` class represents a UDP server that listens on a specified port, receives incoming datagrams asynchronously, and sends responses back to the sender. It utilizes Boost.Asio for asynchronous I/O operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- sender_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last sender\n- max_length: [enum] - Maximum size of the receive buffer (1024 bytes)\n- data_: [char[max_length]] - Buffer for storing received data\n\nMethods:\n- server: [constructor](boost::asio::io_context& io_context, short port) -> void - Initializes the UDP socket and starts the receive operation\n- do_receive: [method]() -> void - Asynchronously receives data from clients and triggers do_send if data is received\n- do_send: [method](std::size_t length) -> void - Asynchronously sends the received data back to the sender",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n\nusing boost::asio::ip::udp;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, short port)\n    : socket_(io_context, udp::endpoint(udp::v4(), port))\n  {\n    do_receive();\n  }\n\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd)\n        {\n          if (!ec && bytes_recvd > 0)\n          {\n            do_send(bytes_recvd);\n          }\n          else\n          {\n            do_receive();\n          }\n        });\n  }\n\n  void do_send(std::size_t length)\n  {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length), sender_endpoint_,\n        [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/)\n        {\n          do_receive();\n        });\n  }\n\nprivate:\n  udp::socket socket_;\n  udp::endpoint sender_endpoint_;\n  enum { max_length = 1024 };\n  char data_[max_length];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "wrong_result": "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)) {\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(boost::asio::buffer(data_, max_length), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t length) {\n            if (!ec) {\n                do_send(length);\n            }\n        });\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(boost::asio::buffer(data_, length), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t /*length*/) {\n            if (!ec) {\n                do_receive();\n            }\n        });\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a UDP multicast sender class using Boost.Asio that periodically sends messages to a specified multicast address.\n\nClass Description: The `sender` class encapsulates functionality for sending UDP multicast messages at regular intervals. It uses Boost.Asio for asynchronous network operations and timer management.\n\nAttributes:\n- endpoint_: [boost::asio::ip::udp::endpoint] - The multicast endpoint (address + port) to send messages to\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for sending messages\n- timer_: [boost::asio::steady_timer] - Timer used to schedule message sends\n- message_count_: [int] - Counter tracking the number of messages sent\n- message_: [std::string] - The current message content to be sent\n\nMethods:\n- sender([boost::asio::io_context&] io_context, [const boost::asio::ip::address&] multicast_address) -> [void] - Constructor that initializes the sender with IO context and multicast address\n- do_send() -> [void] - Asynchronously sends the current message to the multicast endpoint\n- do_timeout() -> [void] - Sets up a timer to schedule the next message send after a delay",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <string>\n#include <chrono>\n\nclass sender\n{\npublic:\n  sender(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& multicast_address)\n    : endpoint_(multicast_address, multicast_port),\n      socket_(io_context, endpoint_.protocol()),\n      timer_(io_context),\n      message_count_(0)\n  {\n    do_send();\n  }\n\nprivate:\n  void do_send()\n  {\n    std::ostringstream os;\n    os << \"Message \" << message_count_++;\n    message_ = os.str();\n\n    socket_.async_send_to(\n        boost::asio::buffer(message_), endpoint_,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && message_count_ < max_message_count)\n            do_timeout();\n        });\n  }\n\n  void do_timeout()\n  {\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(\n        [this](boost::system::error_code ec)\n        {\n          if (!ec)\n            do_send();\n        });\n  }\n\nprivate:\n  boost::asio::ip::udp::endpoint endpoint_;\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::steady_timer timer_;\n  int message_count_;\n  std::string message_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "wrong_result": "boost::asio::ip::udp::endpoint sender::endpoint_;\nboost::asio::ip::udp::socket sender::socket_;\nboost::asio::steady_timer sender::timer_;\nint sender::message_count_;\nstd::string sender::message_;\n\nsender::sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n  : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)),\n    timer_(io_context),\n    message_count_(0) {\n  endpoint_ = boost::asio::ip::udp::endpoint(multicast_address, 12345);\n  message_ = \"Multicast Message \" + std::to_string(message_count_);\n}\n\nvoid sender::do_send() {\n  socket_.async_send_to(boost::asio::buffer(message_), endpoint_,\n    [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n      if (!error) {\n        ++message_count_;\n        message_ = \"Multicast Message \" + std::to_string(message_count_);\n        do_timeout();\n      }\n    });\n}\n\nvoid sender::do_timeout() {\n  timer_.expires_from_now(boost::posix_time::seconds(1));\n  timer_.async_wait([this](const boost::system::error_code& error) {\n    if (!error) {\n      do_send();\n    }\n  });\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a UDP client communication function using Boost.Asio to send a message to a specified host and port, and receive a response.\n\nFunction Description: The function establishes a UDP client connection, sends a message to a specified server, and waits to receive a response. It uses Boost.Asio for asynchronous UDP operations.\n\nInput:\n- host: [std::string] - The hostname or IP address of the UDP server to connect to\n- port: [std::string] - The port number of the UDP server\n- message: [std::string] - The message to be sent to the server\n\nOutput: None (The function receives a reply from the server but doesn't return it. In a real implementation, you might want to return the reply or process it further.)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client_communication(const std::string& host, const std::string& port, const std::string& message)\n{\n    boost::asio::io_context io_context;\n    udp::socket s(io_context, udp::endpoint(udp::v4(), 0));\n    udp::resolver resolver(io_context);\n    udp::resolver::results_type endpoints = resolver.resolve(udp::v4(), host, port);\n\n    size_t request_length = message.length();\n    s.send_to(boost::asio::buffer(message, request_length), *endpoints.begin());\n\n    char reply[max_length];\n    udp::endpoint sender_endpoint;\n    size_t reply_length = s.receive_from(boost::asio::buffer(reply, max_length), sender_endpoint);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host, const std::string& port, const std::string& message) {\n    boost::asio::io_service io_service;\n    boost::asio::ip::udp::socket socket(io_service);\n    boost::asio::ip::udp::resolver resolver(io_service);\n    boost::asio::ip::udp::endpoint endpoint = *resolver.resolve({host, port});\n\n    socket.async_send_to(boost::asio::buffer(message), endpoint,\n        [&](const boost::system::error_code& error, std::size_t bytes_transferred) {\n            if (!error) {\n                char reply[1024];\n                boost::asio::ip::udp::endpoint sender_endpoint;\n                socket.async_receive_from(boost::asio::buffer(reply), sender_endpoint,\n                    [&](const boost::system::error_code& error, std::size_t bytes_received) {\n                        if (!error) {\n                            std::cout << \"Received: \" << std::string(reply, bytes_received) << std::endl;\n                        }\n                    });\n            }\n        });\n\n    io_service.run();\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that handles incoming UDP packets, processes them, and sends replies back to clients. The server should run asynchronously in a separate thread and provide a callback mechanism for handling incoming requests.\n\nClass Description: UDPServer::Impl is an implementation class for a UDP server that listens for incoming packets, validates them, and forwards valid packets to a callback function. It also provides functionality to send replies back to clients.\n\nAttributes:\n- worker_thread: std::thread - Thread that runs the IO context for asynchronous operations\n- io_context: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket: boost::asio::ip::udp::socket - UDP socket for communication\n- request_buffer: std::array<u8, MAX_PACKET_SIZE> - Buffer for storing incoming UDP packets\n- remote_endpoint: boost::asio::ip::udp::endpoint - Stores the endpoint of the last received packet\n- new_request_callback: std::function<void(std::unique_ptr<Packet>)> - Callback function for handling new valid packets\n\nMethods:\n- Impl(std::function<void(std::unique_ptr<Packet>)>) -> None - Constructor that initializes the UDP socket and starts the receive loop\n- ~Impl() -> None - Destructor that stops the IO context and joins the worker thread\n- StartReceive() -> None - Starts an asynchronous receive operation on the UDP socket\n- HandleReceive(const boost::system::error_code&, std::size_t) -> None - Handles received data, validates packets, and triggers the callback for valid packets\n- SendReply(boost::asio::ip::udp::endpoint, Packet&) -> None - Sends a reply packet back to the specified endpoint",
    "Canonical_solution": "#include <thread>\n#include <boost/asio.hpp>\n#include <functional>\n#include <memory>\n#include <array>\n#include \"common/common_types.h\"\n#include \"common/logging/log.h\"\n#include \"core/rpc/packet.h\"\n\nnamespace Core::RPC {\n\nclass UDPServer::Impl {\npublic:\n    explicit Impl(std::function<void(std::unique_ptr<Packet>)> new_request_callback)\n        : socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 45987)),\n          new_request_callback(std::move(new_request_callback)) {\n\n        StartReceive();\n        worker_thread = std::thread([this] { io_context.run(); });\n    }\n\n    ~Impl() {\n        io_context.stop();\n        worker_thread.join();\n    }\n\nprivate:\n    void StartReceive() {\n        socket.async_receive_from(boost::asio::buffer(request_buffer), remote_endpoint,\n                                  [this](const boost::system::error_code& error, std::size_t size) {\n                                      HandleReceive(error, size);\n                                  });\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t size) {\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to receive data on UDP socket: {}\", error.message());\n        } else if (size >= MIN_PACKET_SIZE && size <= MAX_PACKET_SIZE) {\n            PacketHeader header;\n            std::memcpy(&header, request_buffer.data(), sizeof(header));\n            if ((size - MIN_PACKET_SIZE) == header.packet_size) {\n                u8* data = request_buffer.data() + MIN_PACKET_SIZE;\n                std::function<void(Packet&)> send_reply_callback =\n                    std::bind(&Impl::SendReply, this, remote_endpoint, std::placeholders::_1);\n                std::unique_ptr<Packet> new_packet =\n                    std::make_unique<Packet>(header, data, send_reply_callback);\n\n                new_request_callback(std::move(new_packet));\n            }\n        } else {\n            LOG_WARNING(RPC_Server, \"Received message with wrong size: {}\", size);\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply_packet) {\n        std::vector<u8> reply_buffer(MIN_PACKET_SIZE + reply_packet.GetPacketDataSize());\n        auto reply_header = reply_packet.GetHeader();\n\n        std::memcpy(reply_buffer.data(), &reply_header, sizeof(reply_header));\n        std::memcpy(reply_buffer.data() + (4 * sizeof(u32)), reply_packet.GetPacketData().data(),\n                    reply_packet.GetPacketDataSize());\n\n        boost::system::error_code error;\n        socket.send_to(boost::asio::buffer(reply_buffer), endpoint, 0, error);\n\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to send reply: {}\", error.message());\n        } else {\n            LOG_INFO(RPC_Server, \"Sent reply version({}) id=({}) type=({}) size=({})\",\n                     reply_packet.GetVersion(), reply_packet.GetId(), reply_packet.GetPacketType(),\n                     reply_packet.GetPacketDataSize());\n        }\n    }\n\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace Core::RPC",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "wrong_result": "std::thread worker_thread;\nboost::asio::io_context io_context;\nboost::asio::ip::udp::socket socket;\nstd::array<u8, MAX_PACKET_SIZE> request_buffer;\nboost::asio::ip::udp::endpoint remote_endpoint;\nstd::function<void(std::unique_ptr<Packet>)> new_request_callback;\n\nImpl(std::function<void(std::unique_ptr<Packet>)> callback) : new_request_callback(callback), socket(io_context) {\n    socket.open(boost::asio::ip::udp::v4());\n    StartReceive();\n    worker_thread = std::thread([this]() { io_context.run(); });\n}\n\n~Impl() {\n    io_context.stop();\n    worker_thread.join();\n}\n\nvoid StartReceive() {\n    socket.async_receive_from(boost::asio::buffer(request_buffer), remote_endpoint,\n        [this](const boost::system::error_code& error, std::size_t bytes_received) {\n            HandleReceive(error, bytes_received);\n        });\n}\n\nvoid HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n    if (!error && bytes_received > 0) {\n        std::unique_ptr<Packet> packet = std::make_unique<Packet>(request_buffer.data(), bytes_received);\n        if (packet->IsValid()) {\n            new_request_callback(std::move(packet));\n        }\n    }\n    StartReceive();\n}\n\nvoid SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& packet) {\n    socket.send_to(boost::asio::buffer(packet.Data(), packet.Size()), endpoint);\n}"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Implement a server class that handles both TCP and UDP communications using Boost.Asio, managing client subscriptions and broadcasting data frames to subscribed clients.\n\nClass Description: The `server` class manages network communications using both TCP and UDP protocols. It accepts TCP connections for control messages, maintains a set of subscribed UDP endpoints, and periodically broadcasts data frames to all subscribed clients via UDP.\n\nAttributes:\n- acceptor_: [tcp::acceptor] - Handles incoming TCP connections\n- timer_: [boost::asio::steady_timer] - Manages periodic operations\n- udp_socket_: [udp::socket] - Handles UDP communications\n- next_frame_number_: [unsigned long] - Tracks the sequence number for frames\n- subscribers_: [std::set<udp::endpoint>] - Stores subscribed client endpoints\n\nMethods:\n- server([boost::asio::io_context&] io_context, [unsigned short] port) -> [void] - Constructor that initializes the server with IO context and port\n- handle_accept([const boost::system::error_code&] ec, [tcp_socket_ptr] socket) -> [void] - Handles new TCP connection acceptances\n- handle_control_request([const boost::system::error_code&] ec, [tcp_socket_ptr] socket, [control_request_ptr] request) -> [void] - Processes control requests from clients\n- handle_control_request_timer([tcp_socket_ptr] socket, [control_request_ptr] request, [timer_ptr] delay_timer) -> [void] - Handles delayed processing of control requests\n- handle_timer() -> [void] - Periodically broadcasts data frames to subscribed clients",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <set>\n#include <memory>\n#include \"protocol.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef std::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef std::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef std::shared_ptr<control_request> control_request_ptr;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, unsigned short port)\n    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n      timer_(io_context),\n      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n      next_frame_number_(1)\n  {\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\n  void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n  {\n    if (!ec)\n    {\n      control_request_ptr request(new control_request);\n      boost::asio::async_read(*socket, request->to_buffers(),\n          std::bind(&server::handle_control_request, this,\n            boost::asio::placeholders::error, socket, request));\n    }\n\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n  }\n\n  void handle_control_request(const boost::system::error_code& ec,\n      tcp_socket_ptr socket, control_request_ptr request)\n  {\n    if (!ec)\n    {\n      timer_ptr delay_timer(\n          new boost::asio::steady_timer(acceptor_.get_executor()));\n      delay_timer->expires_after(boost::asio::chrono::seconds(2));\n      delay_timer->async_wait(\n          std::bind(&server::handle_control_request_timer, this,\n            socket, request, delay_timer));\n    }\n  }\n\n  void handle_control_request_timer(tcp_socket_ptr socket,\n      control_request_ptr request, timer_ptr /*delay_timer*/)\n  {\n    boost::system::error_code ec;\n    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);\n    if (!ec)\n    {\n      if (unsigned short old_port = request->old_port())\n      {\n        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);\n        subscribers_.erase(old_endpoint);\n      }\n\n      if (unsigned short new_port = request->new_port())\n      {\n        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);\n        subscribers_.insert(new_endpoint);\n      }\n    }\n\n    boost::asio::async_read(*socket, request->to_buffers(),\n        std::bind(&server::handle_control_request, this,\n          boost::asio::placeholders::error, socket, request));\n  }\n\n  void handle_timer()\n  {\n    double x = next_frame_number_ * 0.2;\n    double y = std::sin(x);\n    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));\n    std::string payload;\n    for (int i = 0; i < frame::payload_size; ++i)\n      payload += (i == char_index ? '*' : '.');\n\n    frame f(next_frame_number_++, payload);\n\n    std::set<udp::endpoint>::iterator j;\n    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)\n    {\n      boost::system::error_code ec;\n      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);\n    }\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\nprivate:\n  tcp::acceptor acceptor_;\n  boost::asio::steady_timer timer_;\n  udp::socket udp_socket_;\n  unsigned long next_frame_number_;\n  std::set<udp::endpoint> subscribers_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "wrong_result": "server(boost::asio::io_context& io_context, unsigned short port) : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)), timer_(io_context), udp_socket_(io_context, udp::endpoint(udp::v4(), port)), next_frame_number_(0) {\n    acceptor_.listen();\n    acceptor_.async_accept(std::make_shared<tcp::socket>(io_context), [this](const boost::system::error_code& ec, tcp::socket socket) {\n        handle_accept(ec, std::make_shared<tcp::socket>(std::move(socket)));\n    });\n}\n\nvoid handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n    if (!ec) {\n        auto request = std::make_shared<control_request>();\n        socket->async_read_some(boost::asio::buffer(request->data(), control_request::size()), [this, socket, request](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n            handle_control_request(ec, socket, request);\n        });\n    }\n}\n\nvoid handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n    if (!ec) {\n        if (request->type() == control_request::SUBSCRIBE) {\n            subscribers_.insert(request->endpoint());\n        } else if (request->type() == control_request::UNSUBSCRIBE) {\n            subscribers_.erase(request->endpoint());\n        }\n        handle_control_request_timer(socket, request, std::make_shared<boost::asio::steady_timer>(io_context));\n    }\n}\n\nvoid handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer) {\n    delay_timer->expires_from_now(boost::posix_time::seconds(1));\n    delay_timer->async_wait([this, socket, request, delay_timer](const boost::system::error_code& ec) {\n        if (!ec) {\n            socket->close();\n        }\n    });\n}\n\nvoid handle_timer() {\n    if (!subscribers_.empty()) {\n        data_frame frame;\n        frame.set_frame_number(next_frame_number_++);\n        for (const auto& endpoint : subscribers_) {\n            udp_socket_.send_to(boost::asio::buffer(frame.data(), frame.size()), endpoint);\n        }\n    }\n    timer_.expires_from_now(boost::posix_time::seconds(1));\n    timer_.async_wait([this](const boost::system::error_code& ec) {\n        if (!ec) {\n            handle_timer();\n        }\n    });\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Implement a class for handling HTTP file downloads using libcurl in C++. The class should support URL downloading with retries, temporary file handling, and proper resource management.\n\nClass Description: The DownloadTask class provides functionality to download files from HTTP URLs using libcurl. It handles initialization/cleanup of libcurl, manages download retries, writes data to temporary files, and performs final file operations upon successful download.\n\nAttributes:\n- m_url: [std::string] - Primary URL for file download\n- m_urlBackup: [std::string] - Backup URL if primary fails\n- m_output: [std::string] - Final output file path\n- m_outputTmp: [std::string] - Temporary file path during download\n- m_default: [std::string] - Default file path if download fails\n- m_mtime: [time_t] - Modification time to set on downloaded file\n- m_retries: [unsigned int] - Number of download attempts made\n- m_name: [std::string] - Name identifier for the download task\n- m_userAgent: [std::string] - User agent string for HTTP requests\n- m_error: [std::string] - Last error message encountered\n\nMethods:\n- initialize(): [static void]() -> void - Initializes libcurl global state\n- uninitialize(): [static void]() -> void - Cleans up libcurl global state\n- DownloadTask(): [constructor](const std::string&, const std::string&, const std::string&, time_t, const std::string&) -> DownloadTask - Constructs a download task with URL, output path, default file, modification time, and optional name\n- run(): [bool]() -> bool - Executes the download task and returns success status\n- getRetries(): [unsigned int]() -> unsigned int - Returns number of retry attempts\n- writeData(): [size_t](void*, size_t, size_t) -> size_t - Callback for writing received data\n- downloadFile(): [bool](const std::string&) -> bool - Internal method to perform the actual file download",
    "Canonical_solution": "#include <curl/curl.h>\n#include <vector>\n#include <string>\n#include <utility>\n\nclass DownloadTask\n{\npublic:\n    DownloadTask(const std::string &url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\");\n    \n    static void initialize();\n    static void uninitialize();\n    \n    bool run();\n    unsigned int getRetries() const;\n    size_t writeData(void *buffer, size_t size, size_t nmemb);\n    \nprivate:\n    bool downloadFile(const std::string& url);\n    \n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n};\n\nsize_t writeTaskHttpData(void *buffer, size_t size, size_t nmemb, void *user_p)\n{\n    DownloadTask *task = reinterpret_cast<DownloadTask *>(user_p);\n    if (NULL != task)\n    {\n        return task->writeData(buffer, size, nmemb);\n    }\n    \n    return 0;\n}\n\nvoid DownloadTask::initialize()\n{\n    curl_global_init(CURL_GLOBAL_ALL);\n}\n\nvoid DownloadTask::uninitialize()\n{\n    curl_global_cleanup();\n}\n\nbool DownloadTask::downloadFile(const std::string& url)\n{\n    ++m_retries;\n    \n    m_outputTmp = m_output + \".tmp\";\n    deleteFile(m_outputTmp);\n\n    CURLcode res = CURLE_OK;\n    CURL *curl = NULL;\n    \n    std::string userAgent = m_userAgent.empty() ? \"WeChat/7.0.15.33 CFNetwork/978.0.7 Darwin/18.6.0\" : m_userAgent;\n    \n    curl = curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_USERAGENT, userAgent.c_str());\n    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);\n    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 60);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &::writeTaskHttpData);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, true);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0);\n\n    long httpStatus = 0;\n    res = curl_easy_perform(curl);\n    if (res != CURLE_OK)\n    {\n        m_error = \"Failed \" + m_name + \"\\r\\n\";\n        m_error += curl_easy_strerror(res);\n    }\n    else\n    {\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n    }\n    curl_easy_cleanup(curl);\n    \n    if (res == CURLE_OK && httpStatus == 200)\n    {\n        ::moveFile(m_outputTmp, m_output);\n        if (m_mtime > 0)\n        {\n            updateFileTime(m_output, m_mtime);\n        }\n        return true;\n    }\n\n    if (m_error.empty())\n    {\n        m_error = \"HTTP Status:\" + std::to_string(httpStatus);\n    }\n    return false;\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "wrong_result": "#include <string>\n#include <fstream>\n#include <curl/curl.h>\n\nclass DownloadTask {\npublic:\n    static void initialize();\n    static void uninitialize();\n\n    DownloadTask(const std::string& url, const std::string& urlBackup, const std::string& output, time_t mtime, const std::string& name = \"\");\n\n    bool run();\n    unsigned int getRetries() const;\n    size_t writeData(void* ptr, size_t size, size_t nmemb);\n    bool downloadFile(const std::string& url);\n\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n    CURL* m_curl;\n    std::ofstream m_tmpFile;\n};"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, process incoming messages, and echo messages back to clients. The server should also support stopping the listening process upon receiving a specific command.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, managing connection handling, message processing, and server lifecycle operations.\n\nAttributes:\n- service_: [asio::io_service&] - Reference to the ASIO I/O service used for network operations\n- port_: [int] - The port number on which the server listens for connections\n- ws_server_: [ws_echo_server] - The WebSocket++ server instance\n\nMethods:\n- Constructor: [WebSocketServer]([asio::io_service& service, int port]) -> [void] - Initializes the WebSocket++ server, sets up logging, message handling, and starts listening on the specified port\n- on_message: [on_message]([websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg]) -> [void] - Callback function that processes incoming messages, echoes them back to clients, and handles the stop-listening command\n- run: [run]() -> [void] - Starts the server's event loop to handle connections and messages",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) \n        : service_(service), port_(port) {\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        if (msg->get_payload() == \"stop-listening\") {\n            ws_server_.stop_listening();\n            return;\n        }\n\n        try {\n            ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "asio::io_service service;\nWebSocketServer server(service, 8080);\nserver.run();"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication\n- m_connections: [con_list (std::set<connection_hdl>)] - A set of active client connections\n\nMethods:\n- broadcast_server() - [Constructor] -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events\n- on_open(connection_hdl hdl) -> [void] - Handles new client connections by adding them to the connection set\n- on_close(connection_hdl hdl) -> [void] - Handles client disconnections by removing them from the connection set\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by broadcasting them to all connected clients\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass broadcast_server {\nprivate:\n    server m_server;\n    std::set<server::connection_hdl> m_connections;\n\n    void on_open(server::connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(server::connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(server::connection_hdl hdl, server::message_ptr msg) {\n        for (auto it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\npublic:\n    broadcast_server() {\n        m_server.set_open_handler([this](server::connection_hdl hdl) { this->on_open(hdl); });\n        m_server.set_close_handler([this](server::connection_hdl hdl) { this->on_close(hdl); });\n        m_server.set_message_handler([this](server::connection_hdl hdl, server::message_ptr msg) { this->on_message(hdl, msg); });\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};\n```"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage sessions, and process incoming messages.\n\nClass Description: The `print_server` class implements a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: int - Tracks the next available session ID to assign to new connections.\n- m_server: server - The WebSocket++ server instance configured with custom connection data.\n\nMethods:\n- print_server() - Constructor - Initializes the server with ASIO, sets up handlers for connection open, close, and message events.\n- on_open(connection_hdl hdl) -> void - Handler for new connections. Assigns a session ID to the new connection.\n- on_close(connection_hdl hdl) -> void - Handler for connection closures. Logs the connection's name and session ID.\n- on_message(connection_hdl hdl, server::message_ptr msg) -> void - Handler for incoming messages. Sets the connection name if not set, otherwise logs the message along with the connection's name and session ID.\n- run(uint16_t port) -> void - Starts the server listening on the specified port, begins accepting connections, and runs the event loop.",
    "Canonical_solution": "#include <iostream>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nstruct custom_config : public websocketpp::config::asio {\n    typedef websocketpp::config::asio core;\n    typedef core::concurrency_type concurrency_type;\n    typedef core::request_type request_type;\n    typedef core::response_type response_type;\n    typedef core::message_type message_type;\n    typedef core::con_msg_manager_type con_msg_manager_type;\n    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;\n    typedef core::alog_type alog_type;\n    typedef core::elog_type elog_type;\n    typedef core::rng_type rng_type;\n    typedef core::transport_type transport_type;\n    typedef core::endpoint_base endpoint_base;\n    typedef connection_data connection_base;\n};\n\ntypedef websocketpp::server<custom_config> server;\ntypedef server::connection_ptr connection_ptr;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->sessionid = m_next_sessionid++;\n    }\n    \n    void on_close(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Closing connection \" << con->name \n                  << \" with sessionid \" << con->sessionid << std::endl;\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        \n        if (con->name.empty()) {\n            con->name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \" \n                      << con->sessionid << \" to \" << con->name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << con->name \n                      << \" with sessionid \" << con->sessionid << std::endl;\n        }\n    }\n    \n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "print_server::print_server() : m_next_sessionid(0) {\n    m_server.init_asio();\n    m_server.set_open_handler([this](connection_hdl hdl) { on_open(hdl); });\n    m_server.set_close_handler([this](connection_hdl hdl) { on_close(hdl); });\n    m_server.set_message_handler([this](connection_hdl hdl, server::message_ptr msg) { on_message(hdl, msg); });\n}\n\nvoid print_server::on_open(connection_hdl hdl) {\n    std::string name = \"Unnamed\";\n    m_server.set_user_data(hdl, new std::string(name));\n    int session_id = m_next_sessionid++;\n    m_server.set_connection_userdata(hdl, new int(session_id));\n    std::cout << \"New connection: Session ID \" << session_id << \", Name: \" << name << std::endl;\n}\n\nvoid print_server::on_close(connection_hdl hdl) {\n    int* session_id = static_cast<int*>(m_server.get_connection_userdata(hdl));\n    std::string* name = static_cast<std::string*>(m_server.get_user_data(hdl));\n    std::cout << \"Connection closed: Session ID \" << *session_id << \", Name: \" << *name << std::endl;\n    delete session_id;\n    delete name;\n}\n\nvoid print_server::on_message(connection_hdl hdl, server::message_ptr msg) {\n    std::string* name = static_cast<std::string*>(m_server.get_user_data(hdl));\n    int* session_id = static_cast<int*>(m_server.get_connection_userdata(hdl));\n    if (name->empty()) {\n        *name = msg->get_payload();\n        std::cout << \"Set name for session \" << *session_id << \": \" << *name << std::endl;\n    } else {\n        std::cout << \"Message from \" << *name << \" (Session ID \" << *session_id << \"): \" << msg->get_payload() << std::endl;\n    }\n}\n\nvoid print_server::run(uint16_t port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <iostream>\n#include <stdexcept>\n\nclass print_server {\nprivate:\n    int m_next_sessionid;\n    websocketpp::server<websocketpp::config::asio> m_server;\n    std::map<websocketpp::connection_hdl, std::string, std::owner_less<websocketpp::connection_hdl>> m_connections;\n\n    void on_open(websocketpp::connection_hdl hdl) {\n        int sessionid = m_next_sessionid++;\n        m_connections[hdl] = \"Guest\" + std::to_string(sessionid);\n        std::cout << \"Connection opened. Session ID: \" << sessionid << \", Name: \" << m_connections[hdl] << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Connection closed. Session ID: \" << it->second << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::server<websocketpp::config::asio>::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload.substr(0, 5) == \"NAME:\") {\n            std::string name = payload.substr(5);\n            auto it = m_connections.find(hdl);\n            if (it != m_connections.end()) {\n                it->second = name;\n                std::cout << \"Session ID: \" << it->second << \" renamed to \" << name << std::endl;\n            }\n        } else {\n            auto it = m_connections.find(hdl);\n            if (it != m_connections.end()) {\n                std::cout << \"Message from \" << it->second << \": \" << payload << std::endl;\n            }\n        }\n    }\n\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler([this](websocketpp::connection_hdl hdl) { this->on_open(hdl); });\n        m_server.set_close_handler([this](websocketpp::connection_hdl hdl) { this->on_close(hdl); });\n        m_server.set_message_handler([this](websocketpp::connection_hdl hdl, websocketpp::server<websocketpp::config::asio>::message_ptr msg) { this->on_message(hdl, msg); });\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication.\n- m_connections: [con_list] - A set of active connection handles to keep track of connected clients.\n\nMethods:\n- broadcast_server(): [Constructor]() -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events (open, close, message).\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handler for new client connections; adds the connection handle to the active connections set.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handler for client disconnections; removes the connection handle from the active connections set.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Handler for incoming messages; broadcasts the received message to all connected clients.\n- run: [void]([uint16_t port]) -> [void] - Starts the server, begins listening on the specified port, and enters the event loop to handle connections and messages.",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n                \n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n    \n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass broadcast_server {\nprivate:\n    server m_server;\n    std::set<server::connection_hdl> m_connections;\n\n    void on_open(server::connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(server::connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(server::connection_hdl hdl, server::message_ptr msg) {\n        for (auto it = m_connections.begin(); it != m_connections.end(); ++it) {\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\npublic:\n    broadcast_server() {\n        m_server.set_open_handler([this](server::connection_hdl hdl) { this->on_open(hdl); });\n        m_server.set_close_handler([this](server::connection_hdl hdl) { this->on_close(hdl); });\n        m_server.set_message_handler([this](server::connection_hdl hdl, server::message_ptr msg) { this->on_message(hdl, msg); });\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ using the WebSocket++ library to handle client connections, process incoming messages, and manage server events.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, providing methods to initialize, configure, and run the server. It handles WebSocket connections, processes messages, and manages various server events like HTTP requests, connection failures, and closures.\n\nAttributes:\n- m_server: [websocketpp::server<websocketpp::config::debug_asio>] - The main WebSocket++ server instance that manages connections and events.\n\nMethods:\n- WebSocketServer() -> [Constructor] - Initializes the server with default settings, configures logging, sets up ASIO, and registers event handlers.\n- run(int port) -> [void] - Starts the server on the specified port, begins accepting connections, and runs the event loop.\n- validate(websocketpp::connection_hdl hdl) -> [bool] - Validates incoming connections (always returns true in this implementation).\n- on_http(websocketpp::connection_hdl hdl) -> [void] - Handles HTTP requests received by the server.\n- on_fail(websocketpp::connection_hdl hdl) -> [void] - Handles connection failure events.\n- on_close(websocketpp::connection_hdl hdl) -> [void] - Handles connection closure events.\n- on_message(websocketpp::connection_hdl hdl, message_ptr msg) -> [void] - Processes incoming WebSocket messages and echoes them back to the client.",
    "Canonical_solution": "#include <websocketpp/config/debug_asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/logger/syslog.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass WebSocketServer {\npublic:\n    typedef websocketpp::server<websocketpp::config::debug_asio> server;\n    typedef server::message_ptr message_ptr;\n\n    WebSocketServer() {\n        // Set logging settings\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        // Initialize ASIO\n        m_server.init_asio();\n        m_server.set_reuse_addr(true);\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, ::_1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, ::_1));\n        m_server.set_validate_handler(bind(&WebSocketServer::validate, this, ::_1));\n    }\n\n    void run(int port) {\n        try {\n            // Listen on specified port\n            m_server.listen(port);\n\n            // Start the server accept loop\n            m_server.start_accept();\n\n            // Start the ASIO io_service run loop\n            m_server.run();\n        } catch (websocketpp::exception const & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::string res = con->get_request_body();\n        std::stringstream ss;\n        ss << \"got HTTP request with \" << res.size() << \" bytes of body data.\";\n        con->set_body(ss.str());\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Fail handler: \" << con->get_ec() << \" \" << con->get_ec().message() << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Close handler\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \" \n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "websocketpp::server<websocketpp::config::debug_asio> m_server;\n\nWebSocketServer() {\n    m_server.set_access_channels(websocketpp::log::alevel::none);\n    m_server.set_error_channels(websocketpp::log::elevel::none);\n    m_server.init_asio();\n    m_server.set_validate_handler(bind(&WebSocketServer::validate, this, ::_1));\n    m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n    m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, ::_1));\n    m_server.set_close_handler(bind(&WebSocketServer::on_close, this, ::_1));\n    m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n}\n\nvoid run(int port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}\n\nbool validate(websocketpp::connection_hdl hdl) {\n    return true;\n}\n\nvoid on_http(websocketpp::connection_hdl hdl) {\n    std::cout << \"HTTP request received\" << std::endl;\n}\n\nvoid on_fail(websocketpp::connection_hdl hdl) {\n    std::cout << \"Connection failed\" << std::endl;\n}\n\nvoid on_close(websocketpp::connection_hdl hdl) {\n    std::cout << \"Connection closed\" << std::endl;\n}\n\nvoid on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n    std::string payload = msg->get_payload();\n    std::cout << \"Received: \" << payload << std::endl;\n    m_server.send(hdl, payload, msg->get_opcode());\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Implement a TCP client using Boost.Asio for asynchronous network communication, capable of connecting to a server, sending messages, and receiving responses.\n\nClass Description: The `chat_client` class encapsulates a TCP client that manages asynchronous network operations including connection establishment, message reading, and message writing.\n\nAttributes:\n- io_context_: boost::asio::io_context& - Reference to the I/O execution context for asynchronous operations.\n- socket_: tcp::socket - TCP socket for communication with the server.\n- read_msg_: chat_message - Buffer for storing the currently read message.\n- write_msgs_: chat_message_queue - Queue of messages waiting to be sent to the server.\n\nMethods:\n- Constructor: chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints) -> None - Initializes the client with I/O context and server endpoints, then starts the connection process.\n- write: write(const chat_message& msg) -> None - Enqueues a message for asynchronous sending to the server.\n- close: close() -> None - Initiates socket closure to terminate the connection cleanly.\n- do_connect: do_connect(const tcp::resolver::results_type& endpoints) -> None - Asynchronously connects to the server using the provided endpoints.\n- do_read_header: do_read_header() -> None - Asynchronously reads the message header from the server.\n- do_read_body: do_read_body() -> None - Asynchronously reads the message body from the server after header is processed.\n- do_write: do_write() -> None - Asynchronously writes the next queued message to the server.",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\ntypedef std::deque<chat_message> chat_message_queue;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context),\n      socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_,\n        [this, msg]()\n        {\n          bool write_in_progress = !write_msgs_.empty();\n          write_msgs_.push_back(msg);\n          if (!write_in_progress)\n          {\n            do_write();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]() { socket_.close(); });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            std::cout.write(read_msg_.body(), read_msg_.body_length());\n            std::cout << \"\\n\";\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(),\n          write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            write_msgs_.pop_front();\n            if (!write_msgs_.empty())\n            {\n              do_write();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\nprivate:\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  chat_message_queue write_msgs_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "chat_client::chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints) : io_context_(io_context), socket_(io_context), read_msg_(), write_msgs_() {\n    do_connect(endpoints);\n}\n\nvoid chat_client::write(const chat_message& msg) {\n    bool write_in_progress = !write_msgs_.empty();\n    write_msgs_.push_back(msg);\n    if (!write_in_progress) {\n        do_write();\n    }\n}\n\nvoid chat_client::close() {\n    socket_.close();\n}\n\nvoid chat_client::do_connect(const tcp::resolver::results_type& endpoints) {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint) {\n            if (!ec) {\n                do_read_header();\n            }\n        });\n}\n\nvoid chat_client::do_read_header() {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(&read_msg_.header_, sizeof(read_msg_.header_)),\n        [this](boost::system::error_code ec, std::size_t /*length*/) {\n            if (!ec && read_msg_.header_.length > 0) {\n                do_read_body();\n            }\n        });\n}\n\nvoid chat_client::do_read_body() {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body_, read_msg_.header_.length),\n        [this](boost::system::error_code ec, std::size_t /*length*/) {\n            if (!ec) {\n                // Process the received message\n                do_read_header();\n            }\n        });\n}\n\nvoid chat_client::do_write() {\n    if (write_msgs_.empty()) {\n        return;\n    }\n\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/) {\n            if (!ec) {\n                write_msgs_.pop_front();\n                if (!write_msgs_.empty()) {\n                    do_write();\n                }\n            }\n        });\n}"
  }
]