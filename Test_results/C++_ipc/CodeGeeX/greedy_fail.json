[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "```cpp\n#include <httplib.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client cli(location.c_str());\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n    httplib::Params params;\n\n    std::string body;\n    if (request_data) {\n        body = request_data->dump();\n    }\n\n    httplib::Response res;\n    if (method == \"GET\") {\n        res = cli.Get(URI.c_str(), headers, params);\n    } else if (method == \"PUT\") {\n        res = cli.Put(URI.c_str(), headers, body.c_str(), body.size());\n    } else if (method == \"DELETE\") {\n        res = cli.Delete(URI.c_str(), headers, params);\n    } else if (method == \"POST\") {\n        res = cli.Post(URI.c_str(), headers, body.c_str(), body.size());\n    } else {\n        return -1; // Invalid method\n    }\n\n    if (res && res.status >= 200 && res.status < 300) {\n        if (response_data) {\n            *response_data = json::parse(res.body);\n        }\n    }\n\n    return res.status;\n}\n```"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a C++ class that handles HTTP communication over TCP and UDP protocols, including sending requests and receiving responses from a server.\n\nClass Description: The LinHttpHandler class provides functionality for sending HTTP requests and receiving responses using both TCP (for standard HTTP communication) and UDP (for multicast communication). It includes error handling and resource management through RAII.\n\nAttributes:\n\nSocketCloser: [Nested Class] - A helper class that ensures sockets are properly closed when they go out of scope.\n\nMethods:\n\nsend: [Name](const std::string& msg, const std::string& adr, int port) -> std::string - Sends an HTTP message to the specified address and port using TCP and returns the server's response. Throws system_error on failure.\n\nsendMulticast: [Name](const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) -> std::vector<std::string> - Sends a multicast message using UDP and collects responses within the specified timeout period. Returns a vector of response strings. Throws system_error on failure.\n\nSocketCloser: [Name](int sockFd) -> None - Constructor that takes a socket file descriptor. The destructor automatically closes the socket.",
    "Canonical_solution": "#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <stdexcept>\n#include <system_error>\n#include <vector>\n\nnamespace hueplusplus\n{\nclass LinHttpHandler\n{\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) const\n    {\n        int socketFD = socket(AF_INET, SOCK_STREAM, 0);\n\n        SocketCloser closeMySocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to open socket\"));\n        }\n\n        hostent* server = gethostbyname(adr.c_str());\n        if (server == NULL)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: gethostbyname\"));\n        }\n\n        sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        memcpy(&server_addr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n        if (connect(socketFD, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to connect socket\"));\n        }\n\n        size_t total = msg.length();\n        size_t sent = 0;\n        do\n        {\n            ssize_t bytes = write(socketFD, msg.c_str() + sent, total - sent);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to write message to socket\"));\n            }\n            sent += bytes;\n        } while (sent < total);\n\n        std::string response;\n        char buffer[128] = {};\n        do\n        {\n            ssize_t bytes = read(socketFD, buffer, 127);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to read response from socket\"));\n            }\n            response.append(buffer, bytes);\n        } while (true);\n\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(\n        const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) const\n    {\n        hostent* server;\n        sockaddr_in server_addr;\n\n        memset((char*)&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n\n        server = gethostbyname(adr.c_str());\n        if (!server)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to obtain address of host\"));\n        }\n\n        memcpy((void*)&server_addr.sin_addr, server->h_addr_list[0], server->h_length);\n\n        int socketFD = socket(AF_INET, SOCK_DGRAM, 0);\n        SocketCloser closeMySendSocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to open socket\"));\n        }\n\n        if (sendto(socketFD, msg.c_str(), strlen(msg.c_str()), 0, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to send message\"));\n        }\n\n        std::string response;\n        char buffer[2048] = {};\n\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout)\n        {\n            ssize_t bytesReceived = recv(socketFD, &buffer, 2048, MSG_DONTWAIT);\n            if (bytesReceived < 0 && errno != EAGAIN && errno != EWOULDBLOCK)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to read response from socket\"));\n            }\n            if (bytesReceived > 0)\n            {\n                response.append(buffer, bytesReceived);\n            }\n        }\n\n        std::vector<std::string> returnString;\n        size_t pos = response.find(\"\\r\\n\\r\\n\");\n        size_t prevpos = 0;\n        while (pos != std::string::npos)\n        {\n            returnString.push_back(response.substr(prevpos, pos - prevpos));\n            pos += 4;\n            prevpos = pos;\n            pos = response.find(\"\\r\\n\\r\\n\", pos);\n        }\n        return returnString;\n    }\n\nprivate:\n    class SocketCloser\n    {\n    public:\n        explicit SocketCloser(int sockFd) : s(sockFd) {}\n        ~SocketCloser() { close(s); }\n\n    private:\n        int s;\n    };\n};\n} // namespace hueplusplus",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "wrong_result": "```cpp\n#include <string>\n#include <vector>\n#include <chrono>\n#include <system_error>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nclass LinHttpHandler {\npublic:\n    class SocketCloser {\n    public:\n        SocketCloser(int sockFd) : sockFd_(sockFd) {}\n        ~SocketCloser() {\n            close(sockFd_);\n        }\n    private:\n        int sockFd_;\n    };\n\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockFd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockFd == -1) {\n            throw std::system_error(errno, std::generic_category(), \"Failed to create socket\");\n        }\n        SocketCloser socketCloser(sockFd);\n\n        struct sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &(serverAddr.sin_addr)) <= 0) {\n            throw std::system_error(errno, std::generic_category(), \"Invalid address/ Address not supported\");\n        }\n\n        if (connect(sockFd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n            throw std::system_error(errno, std::generic_category(), \"Connection failed\");\n        }\n\n        if (send(sockFd, msg.c_str(), msg.length(), 0) < 0) {\n            throw std::system_error(errno, std::generic_category(), \"Send failed\");\n        }\n\n        char buffer[1024] = {0};\n        std::string response;\n        int valread = read(sockFd, buffer, 1024);\n        while (valread > 0) {\n            response += std::string(buffer, valread);\n            valread = read(sockFd, buffer, 1024);\n        }\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockFd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockFd == -1) {\n            throw std::system_error(errno, std::generic_category(), \"Failed to create socket\");\n        }\n        SocketCloser socketCloser(sockFd);\n\n        struct sockaddr_in serverAddr{};\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        if (inet_pton(AF_INET, adr.c_str(), &(serverAddr.sin_addr)) <= 0) {\n            throw std::system_error(errno, std::generic_category(), \"Invalid address/ Address not supported\");\n        }\n\n        std::vector<std::string> responses;\n        char buffer[1024] = {0};\n        struct sockaddr_in clientAddr{};\n        socklen_t addrLen = sizeof(clientAddr);\n        auto startTime = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - startTime < timeout) {\n            if (sendto(sockFd, msg.c_str(), msg.length(), 0, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n                throw std::system_error(errno, std::generic_category(), \"Send failed\");\n            }\n\n            int valread = recvfrom(sockFd, buffer, 1024, 0, (struct sockaddr*)&clientAddr, &addrLen);\n            if (valread > 0) {\n                responses.push_back(std::string(buffer, valread));\n            }\n        }\n        return responses;\n    }\n};\n```"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Implement a TCP client socket class in C++ that handles connection establishment, data transmission, and connection management with a remote server, supporting both IPv4 and IPv6 protocols.\n\nClass Description: The ClientSocket class provides TCP client functionality with support for both IPv4 and IPv6 connections. It handles socket creation, connection establishment with timeout support, send buffer configuration, and connection cleanup. The class is designed to work within a multi-threaded context and supports encryption parameters.\n\nAttributes:\n- dest_: std::string - Destination hostname or IP address to connect to\n- threadCtx_: ThreadCtx& - Reference to thread context containing configuration options\n- sa_: struct addrinfo - Address information structure for socket configuration\n- socket_: std::unique_ptr<WdtSocket> - Smart pointer to the underlying socket implementation\n- peerIp_: std::string - IP address of the connected peer\n\nMethods:\n- Constructor: ClientSocket(ThreadCtx& threadCtx, const string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval) -> void - Initializes the client socket with destination, port, and encryption parameters\n- connect: connect() -> ErrorCode - Establishes connection to the remote server with timeout handling, returns connection status\n- getPeerIp: getPeerIp() -> const std::string& - Returns the IP address of the connected peer\n- setSendBufferSize: setSendBufferSize() -> void - Configures the socket's send buffer size based on thread context options\n- closeConnection: closeConnection() -> void [private] - Closes the active socket connection",
    "Canonical_solution": "#include <fcntl.h>\n#include <folly/Conv.h>\n#include <folly/ScopeGuard.h>\n#include <glog/logging.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <wdt/Reporting.h>\n#include <wdt/util/ClientSocket.h>\n\nnamespace facebook {\nnamespace wdt {\n\nusing std::string;\n\nclass ClientSocket {\npublic:\n  ClientSocket(ThreadCtx &threadCtx, const string &dest,\n               const int port,\n               const EncryptionParams &encryptionParams,\n               int64_t ivChangeInterval)\n      : dest_(dest), threadCtx_(threadCtx) {\n    memset(&sa_, 0, sizeof(sa_));\n    socket_ = std::make_unique<WdtSocket>(threadCtx, port, encryptionParams,\n                                          ivChangeInterval, nullptr);\n    if (threadCtx_.getOptions().ipv6) {\n      sa_.ai_family = AF_INET6;\n    }\n    if (threadCtx_.getOptions().ipv4) {\n      sa_.ai_family = AF_INET;\n    }\n    sa_.ai_socktype = SOCK_STREAM;\n  }\n\n  ErrorCode connect() {\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    WDT_CHECK(fd < 0) << \"Previous connection not closed \" << fd << \" \" << port;\n    \n    struct addrinfo *infoList = nullptr;\n    auto guard = folly::makeGuard([&] {\n      if (infoList) {\n        freeaddrinfo(infoList);\n      }\n    });\n    \n    string portStr = folly::to<string>(port);\n    int res = getaddrinfo(dest_.c_str(), portStr.c_str(), &sa_, &infoList);\n    if (res) {\n      WLOG(ERROR) << \"Failed getaddrinfo \" << dest_ << \" , \" << port << \" : \"\n                  << res << \" : \" << gai_strerror(res);\n      return CONN_ERROR;\n    }\n    \n    int count = 0;\n    for (struct addrinfo *info = infoList; info != nullptr;\n         info = info->ai_next) {\n      ++count;\n      std::string host, port_2;\n      WdtSocket::getNameInfo(info->ai_addr, info->ai_addrlen, host, port_2);\n      WVLOG(2) << \"will connect to \" << host << \" \" << port_2;\n      \n      fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);\n      if (fd == -1) {\n        WPLOG(WARNING) << \"Error making socket for port_2 \" << port_2;\n        continue;\n      }\n      \n      socket_->setFd(fd);\n      setSendBufferSize();\n\n      int sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg |= O_NONBLOCK;\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res < 0) {\n        WPLOG(ERROR) << \"Failed to make the socket non-blocking \" << port_2\n                     << \" sock \" << sockArg << \" res \" << res;\n        closeConnection();\n        continue;\n      }\n\n      if (::connect(fd, info->ai_addr, info->ai_addrlen) != 0) {\n        if (errno != EINPROGRESS) {\n          WPLOG(INFO) << \"Error connecting on \" << host << \" \" << port_2;\n          closeConnection();\n          continue;\n        }\n        \n        auto startTime = Clock::now();\n        int connectTimeout = threadCtx_.getOptions().connect_timeout_millis;\n\n        while (true) {\n          if (threadCtx_.getAbortChecker()->shouldAbort()) {\n            WLOG(ERROR) << \"Transfer aborted during connect \" << port_2 << \" \"\n                        << fd;\n            closeConnection();\n            return ABORT;\n          }\n          \n          int timeElapsed = durationMillis(Clock::now() - startTime);\n          if (timeElapsed >= connectTimeout) {\n            WVLOG(1) << \"connect() timed out\" << host << \" \" << port_2;\n            closeConnection();\n            return CONN_ERROR_RETRYABLE;\n          }\n          \n          int pollTimeout =\n              std::min(connectTimeout - timeElapsed,\n                       threadCtx_.getOptions().abort_check_interval_millis);\n          struct pollfd pollFds[] = {{fd, POLLOUT, 0}};\n\n          if ((res = poll(pollFds, 1, pollTimeout)) <= 0) {\n            if (errno == EINTR) {\n              WVLOG(1) << \"poll() call interrupted. retrying... \" << port_2;\n              continue;\n            }\n            if (res == 0) {\n              WVLOG(1) << \"poll() timed out \" << host << \" \" << port_2;\n              continue;\n            }\n            WPLOG(ERROR) << \"poll() failed \" << host << \" \" << port_2 << \" \"\n                         << fd;\n            closeConnection();\n            return CONN_ERROR;\n          }\n          break;\n        }\n\n        int connectResult;\n        socklen_t len = sizeof(connectResult);\n        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &connectResult, &len) < 0) {\n          WPLOG(WARNING) << \"getsockopt() failed\";\n          closeConnection();\n          continue;\n        }\n        if (connectResult != 0) {\n          WLOG(WARNING) << \"connect did not succeed on \" << host << \" \" << port_2\n                        << \" : \" << strerrorStr(connectResult);\n          closeConnection();\n          continue;\n        }\n      }\n\n      sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg &= (~O_NONBLOCK);\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res == -1) {\n        WPLOG(ERROR) << \"Could not make the socket blocking \" << port_2;\n        closeConnection();\n        continue;\n      }\n      \n      WVLOG(1) << \"Successful connect on \" << fd;\n      peerIp_ = host;\n      sa_ = *info;\n      break;\n    }\n    \n    if (socket_->getFd() < 0) {\n      if (count > 1) {\n        WLOG(INFO) << \"Unable to connect to either of the \" << count << \" addrs\";\n      }\n      return CONN_ERROR_RETRYABLE;\n    }\n    \n    socket_->setSocketTimeouts();\n    socket_->setDscp(threadCtx_.getOptions().dscp);\n    return OK;\n  }\n\n  const std::string &getPeerIp() const {\n    return peerIp_;\n  }\n\n  void setSendBufferSize() {\n    int bufSize = threadCtx_.getOptions().send_buffer_size;\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    if (bufSize <= 0) {\n      return;\n    }\n    int status =\n        ::setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bufSize, sizeof(bufSize));\n    if (status != 0) {\n      WPLOG(ERROR) << \"Failed to set send buffer \" << port << \" size \" << bufSize\n                   << \" fd \" << fd;\n      return;\n    }\n    WVLOG(1) << \"Send buffer size set to \" << bufSize << \" port \" << port;\n  }\n\nprivate:\n  std::string dest_;\n  ThreadCtx &threadCtx_;\n  struct addrinfo sa_;\n  std::unique_ptr<WdtSocket> socket_;\n  std::string peerIp_;\n\n  void closeConnection() {\n    socket_->close();\n  }\n};\n\n}  // namespace wdt\n}  // namespace facebook",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "wrong_result": "```cpp\n#include <memory>\n#include <string>\n#include <thread>\n#include <chrono>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <cstring>\n#include <iostream>\n#include <stdexcept>\n\nclass ThreadCtx {\npublic:\n    bool useIPv6;\n    bool useEncryption;\n    int sendBufferSize;\n    // Other configuration options...\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct sockaddr* addr, socklen_t addrlen) = 0;\n    virtual int send(const void* buffer, size_t length, int flags) = 0;\n    virtual int close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp() const;\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), socket_(std::make_unique<WdtSocket>()) {\n    // Initialize socket and address info structure\n    // ...\n}\n\nErrorCode ClientSocket::connect() {\n    // Resolve destination address\n    // ...\n\n    // Create socket\n    // ...\n\n    // Connect to server with timeout\n    // ...\n\n    // Set send buffer size\n    setSendBufferSize();\n\n    // Return connection status\n    // ...\n}\n\nconst std::string& ClientSocket::getPeerIp() const {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    // Configure send buffer size based on thread context options\n    // ...\n}\n\nvoid ClientSocket::closeConnection() {\n    // Close the active socket connection\n    // ...\n}\n```"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "```cpp\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Implement a TCP server using UNIX domain sockets for inter-process communication that manages and provides access to statistics data. The server should handle multiple client connections concurrently, process different types of requests (get, reset, etc.), and maintain thread safety.\n\nClass Description: The Stats class implements a TCP server using UNIX domain sockets to manage and provide access to statistics data. It handles client connections, processes requests, and maintains thread safety for concurrent access to statistics.\n\nAttributes:\n- stats_socket_path_: std::string - Path to the UNIX domain socket file\n- sockfd_: int - File descriptor for the server socket\n- serv_addr_: sockaddr_un - Server address structure\n- stats_thread_: std::thread - Thread for running the socket server\n- statsThreadRunning_: std::atomic<bool> - Flag to control the server thread's execution\n- stats_mutex_: std::mutex - Mutex for protecting access to statistics data\n- thread_mutex_: std::mutex - Mutex for protecting thread count\n- thread_exited_: std::condition_variable - Condition variable for thread synchronization\n- thread_count_: int - Count of active threads\n- stats_: std::unordered_map<std::string, int> - Container for storing statistics data\n\nMethods:\n- Stats(const std::string& stats_socket_path) -> None - Constructor that initializes the socket server\n- ~Stats() -> None - Destructor that cleans up resources\n- get(const std::string& stats_socket_path) -> Stats& - Static method to get the singleton instance\n- get_for_unittest(const std::string& stats_socket_path) -> std::unique_ptr<Stats> - Static method to get an instance for unit testing\n- init(const std::string& stats_socket_path) -> bool - Static method to initialize the singleton\n- isInit() -> bool - Static method to check if the singleton is initialized\n- getAll() -> std::unordered_map<std::string, int> - Returns all statistics data\n- increment(const std::string& key, int val) -> int - Increments a statistic value\n- set(const std::string& key, int val) -> int - Sets a statistic value\n- reset() -> int - Resets all statistics\n- startSocket() -> bool - Starts the socket server\n- runSocket() -> void - Main server loop that accepts connections\n- processMsg(int sockfd) -> void - Processes a client message\n- isInitInternal() -> bool& - Internal static method for initialization status",
    "Canonical_solution": "#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n#include <json/value.h>\n\nnamespace Oomd {\n\nclass Stats {\npublic:\n  Stats(const std::string& stats_socket_path);\n  ~Stats();\n\n  static Stats& get(const std::string& stats_socket_path);\n  static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n  static bool init(const std::string& stats_socket_path);\n  static bool isInit();\n\n  std::unordered_map<std::string, int> getAll();\n  int increment(const std::string& key, int val);\n  int set(const std::string& key, int val);\n  int reset();\n\nprivate:\n  bool startSocket();\n  void runSocket();\n  void processMsg(int sockfd);\n  static bool& isInitInternal();\n\n  std::string stats_socket_path_;\n  int sockfd_{-1};\n  sockaddr_un serv_addr_{};\n  std::thread stats_thread_;\n  std::atomic<bool> statsThreadRunning_{true};\n  std::mutex stats_mutex_;\n  std::unordered_map<std::string, int> stats_;\n  std::mutex thread_mutex_;\n  std::condition_variable thread_exited_;\n  int thread_count_{0};\n};\n\nStats::Stats(const std::string& stats_socket_path)\n    : stats_socket_path_(stats_socket_path) {\n  if (!this->startSocket()) {\n    throw std::runtime_error(\"Socket thread failed to start\");\n  }\n}\n\nStats::~Stats() {\n  std::array<char, 64> err_buf = {};\n  statsThreadRunning_ = false;\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  if (!thread_exited_.wait_for(lock, std::chrono::seconds(5), [this] {\n        return this->thread_count_ == 0;\n      })) {\n    OCHECK(false);\n  }\n  lock.unlock();\n  if (stats_thread_.joinable()) {\n    stats_thread_.join();\n  }\n  if (::unlink(serv_addr_.sun_path) < 0) {\n    OLOG << \"Closing stats error: unlinking socket path: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  if (::close(sockfd_) < 0) {\n    OLOG << \"Closing stats error: closing stats socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n}\n\nbool Stats::startSocket() {\n  std::array<char, 64> err_buf = {};\n\n  sockfd_ = ::socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sockfd_ < 0) {\n    OLOG << \"Error creating socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size() - 1);\n    return false;\n  }\n  ::memset(&serv_addr_, '\\0', sizeof(serv_addr_));\n  serv_addr_.sun_family = AF_UNIX;\n  ::strcpy(serv_addr_.sun_path, stats_socket_path_.c_str());\n  if (::unlink(serv_addr_.sun_path) < 0 && errno != ENOENT) {\n    OLOG << \"Pre-unlinking of socket path failed. \" << serv_addr_.sun_path\n         << \". Errno: \" << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) < 0) {\n    OLOG << \"Error binding stats collection socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::listen(sockfd_, 5) < 0) {\n    OLOG << \"Error listening at socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  stats_thread_ = std::thread([this] { this->runSocket(); });\n  return true;\n}\n\nvoid Stats::runSocket() {\n  sockaddr_un cli_addr;\n  socklen_t clilen = sizeof(cli_addr);\n  std::array<char, 64> err_buf = {};\n  while (statsThreadRunning_) {\n    int sockfd = ::accept(sockfd_, (struct sockaddr*)&cli_addr, &clilen);\n    if (sockfd < 0) {\n      OLOG << \"Stats server error: accepting connection: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      continue;\n    }\n    std::unique_lock<std::mutex> lock(thread_mutex_);\n    ++thread_count_;\n    std::thread msg_thread_ =\n        std::thread([this, sockfd] { this->processMsg(sockfd); });\n    msg_thread_.detach();\n    lock.unlock();\n    thread_exited_.notify_one();\n  }\n}\n\nvoid Stats::processMsg(int sockfd) {\n  std::array<char, 64> err_buf = {};\n  OOMD_SCOPE_EXIT {\n    if (::close(sockfd) < 0) {\n      OLOG << \"Stats server error: closing file descriptor: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    }\n  };\n  char mode = 'a';\n  char byte_buf;\n  int num_read = 0;\n  for (; num_read < 32; num_read++) {\n    int res = ::read(sockfd, &byte_buf, 1);\n    if (res < 0) {\n      OLOG << \"Stats server error: reading from socket: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      return;\n    } else if (res == 0) {\n      break;\n    }\n    if (byte_buf == '\\n' || byte_buf == '\\0') {\n      break;\n    }\n    if (num_read == 0) {\n      mode = byte_buf;\n    }\n  }\n\n  Json::Value root;\n  root[\"error\"] = 0;\n  Json::Value body(Json::objectValue);\n  switch (mode) {\n    case 'g':\n      for (auto const& pair : getAll()) {\n        body[pair.first] = pair.second;\n      }\n      break;\n    case 'r':\n      Stats::reset();\n      break;\n    case '0':\n      break;\n    default:\n      root[\"error\"] = 1;\n      OLOG << \"Stats server error: received unknown request: \" << mode;\n  }\n  root[\"body\"] = body;\n  std::string ret = root.toStyledString();\n  if (Util::writeFull(sockfd, ret.c_str(), strlen(ret.c_str())) < 0) {\n    OLOG << \"Stats server error: writing to socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  thread_count_--;\n  lock.unlock();\n  thread_exited_.notify_one();\n}\n\n} // namespace Oomd",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "```cpp\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <thread>\n#include <atomic>\n#include <unordered_map>\n#include <mutex>\n#include <condition_variable>\n#include <iostream>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static bool isInitInternal();\n};\n```"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Implement a UDP server using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nFunction Description: The function `udp_server` creates a UDP server that listens on port 13 (daytime protocol port). When it receives any datagram from a client, it responds with the current time in string format. The server runs indefinitely until an exception occurs.\n\nInput: None\n\nOutput: None (The function runs indefinitely and sends responses to clients, but doesn't return any value)",
    "Canonical_solution": "#include <array>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n  using namespace std;\n  time_t now = time(0);\n  return ctime(&now);\n}\n\nvoid udp_server()\n{\n  try\n  {\n    boost::asio::io_context io_context;\n\n    udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n    for (;;)\n    {\n      std::array<char, 1> recv_buf;\n      udp::endpoint remote_endpoint;\n      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);\n\n      std::string message = make_daytime_string();\n\n      boost::system::error_code ignored_error;\n      socket.send_to(boost::asio::buffer(message),\n          remote_endpoint, 0, ignored_error);\n    }\n  }\n  catch (std::exception& e)\n  {\n    std::cerr << e.what() << std::endl;\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "```cpp\n#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n\nvoid udp_server()\n{\n    try\n    {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n\n        while (true)\n        {\n            boost::asio::ip::udp::endpoint remote_endpoint;\n            boost::asio::streambuf receive_buffer;\n            boost::asio::read(socket, boost::asio::buffer(receive_buffer.data()), boost::asio::transfer_all(), boost::system::error_code());\n\n            std::string message = boost::asio::buffer_cast<const char*>(receive_buffer.data());\n            std::cout << \"Received: \" << message << std::endl;\n\n            std::time_t now = std::time(nullptr);\n            std::string response = std::ctime(&now);\n\n            boost::asio::write(socket, boost::asio::buffer(response), boost::system::error_code());\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that handles incoming UDP packets, processes them, and sends replies back to clients. The server should run asynchronously in a separate thread and provide a callback mechanism for handling incoming requests.\n\nClass Description: UDPServer::Impl is an implementation class for a UDP server that listens for incoming packets, validates them, and forwards valid packets to a callback function. It also provides functionality to send replies back to clients.\n\nAttributes:\n- worker_thread: std::thread - Thread that runs the IO context for asynchronous operations\n- io_context: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket: boost::asio::ip::udp::socket - UDP socket for communication\n- request_buffer: std::array<u8, MAX_PACKET_SIZE> - Buffer for storing incoming UDP packets\n- remote_endpoint: boost::asio::ip::udp::endpoint - Stores the endpoint of the last received packet\n- new_request_callback: std::function<void(std::unique_ptr<Packet>)> - Callback function for handling new valid packets\n\nMethods:\n- Impl(std::function<void(std::unique_ptr<Packet>)>) -> None - Constructor that initializes the UDP socket and starts the receive loop\n- ~Impl() -> None - Destructor that stops the IO context and joins the worker thread\n- StartReceive() -> None - Starts an asynchronous receive operation on the UDP socket\n- HandleReceive(const boost::system::error_code&, std::size_t) -> None - Handles received data, validates packets, and triggers the callback for valid packets\n- SendReply(boost::asio::ip::udp::endpoint, Packet&) -> None - Sends a reply packet back to the specified endpoint",
    "Canonical_solution": "#include <thread>\n#include <boost/asio.hpp>\n#include <functional>\n#include <memory>\n#include <array>\n#include \"common/common_types.h\"\n#include \"common/logging/log.h\"\n#include \"core/rpc/packet.h\"\n\nnamespace Core::RPC {\n\nclass UDPServer::Impl {\npublic:\n    explicit Impl(std::function<void(std::unique_ptr<Packet>)> new_request_callback)\n        : socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 45987)),\n          new_request_callback(std::move(new_request_callback)) {\n\n        StartReceive();\n        worker_thread = std::thread([this] { io_context.run(); });\n    }\n\n    ~Impl() {\n        io_context.stop();\n        worker_thread.join();\n    }\n\nprivate:\n    void StartReceive() {\n        socket.async_receive_from(boost::asio::buffer(request_buffer), remote_endpoint,\n                                  [this](const boost::system::error_code& error, std::size_t size) {\n                                      HandleReceive(error, size);\n                                  });\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t size) {\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to receive data on UDP socket: {}\", error.message());\n        } else if (size >= MIN_PACKET_SIZE && size <= MAX_PACKET_SIZE) {\n            PacketHeader header;\n            std::memcpy(&header, request_buffer.data(), sizeof(header));\n            if ((size - MIN_PACKET_SIZE) == header.packet_size) {\n                u8* data = request_buffer.data() + MIN_PACKET_SIZE;\n                std::function<void(Packet&)> send_reply_callback =\n                    std::bind(&Impl::SendReply, this, remote_endpoint, std::placeholders::_1);\n                std::unique_ptr<Packet> new_packet =\n                    std::make_unique<Packet>(header, data, send_reply_callback);\n\n                new_request_callback(std::move(new_packet));\n            }\n        } else {\n            LOG_WARNING(RPC_Server, \"Received message with wrong size: {}\", size);\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply_packet) {\n        std::vector<u8> reply_buffer(MIN_PACKET_SIZE + reply_packet.GetPacketDataSize());\n        auto reply_header = reply_packet.GetHeader();\n\n        std::memcpy(reply_buffer.data(), &reply_header, sizeof(reply_header));\n        std::memcpy(reply_buffer.data() + (4 * sizeof(u32)), reply_packet.GetPacketData().data(),\n                    reply_packet.GetPacketDataSize());\n\n        boost::system::error_code error;\n        socket.send_to(boost::asio::buffer(reply_buffer), endpoint, 0, error);\n\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to send reply: {}\", error.message());\n        } else {\n            LOG_INFO(RPC_Server, \"Sent reply version({}) id=({}) type=({}) size=({})\",\n                     reply_packet.GetVersion(), reply_packet.GetId(), reply_packet.GetPacketType(),\n                     reply_packet.GetPacketDataSize());\n        }\n    }\n\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace Core::RPC",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "wrong_result": "```cpp\n#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/thread.hpp>\n#include <array>\n#include <memory>\n#include <functional>\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        Impl(std::function<void(std::unique_ptr<Packet>)> new_request_callback);\n        ~Impl();\n\n        void StartReceive();\n\n        void SendReply(boost::asio::ip::udp::endpoint, Packet&);\n\n    private:\n        void HandleReceive(const boost::system::error_code&, std::size_t);\n\n        boost::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<u8, MAX_PACKET_SIZE> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n\n    UDPServer(std::function<void(std::unique_ptr<Packet>)> new_request_callback);\n    ~UDPServer();\n\n    void StartReceive();\n\n    void SendReply(boost::asio::ip::udp::endpoint, Packet&);\n\nprivate:\n    std::unique_ptr<Impl> impl;\n};\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Implement a server class that handles both TCP and UDP communications using Boost.Asio, managing client subscriptions and broadcasting data frames to subscribed clients.\n\nClass Description: The `server` class manages network communications using both TCP and UDP protocols. It accepts TCP connections for control messages, maintains a set of subscribed UDP endpoints, and periodically broadcasts data frames to all subscribed clients via UDP.\n\nAttributes:\n- acceptor_: [tcp::acceptor] - Handles incoming TCP connections\n- timer_: [boost::asio::steady_timer] - Manages periodic operations\n- udp_socket_: [udp::socket] - Handles UDP communications\n- next_frame_number_: [unsigned long] - Tracks the sequence number for frames\n- subscribers_: [std::set<udp::endpoint>] - Stores subscribed client endpoints\n\nMethods:\n- server([boost::asio::io_context&] io_context, [unsigned short] port) -> [void] - Constructor that initializes the server with IO context and port\n- handle_accept([const boost::system::error_code&] ec, [tcp_socket_ptr] socket) -> [void] - Handles new TCP connection acceptances\n- handle_control_request([const boost::system::error_code&] ec, [tcp_socket_ptr] socket, [control_request_ptr] request) -> [void] - Processes control requests from clients\n- handle_control_request_timer([tcp_socket_ptr] socket, [control_request_ptr] request, [timer_ptr] delay_timer) -> [void] - Handles delayed processing of control requests\n- handle_timer() -> [void] - Periodically broadcasts data frames to subscribed clients",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <set>\n#include <memory>\n#include \"protocol.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef std::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef std::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef std::shared_ptr<control_request> control_request_ptr;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, unsigned short port)\n    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n      timer_(io_context),\n      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n      next_frame_number_(1)\n  {\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\n  void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n  {\n    if (!ec)\n    {\n      control_request_ptr request(new control_request);\n      boost::asio::async_read(*socket, request->to_buffers(),\n          std::bind(&server::handle_control_request, this,\n            boost::asio::placeholders::error, socket, request));\n    }\n\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n  }\n\n  void handle_control_request(const boost::system::error_code& ec,\n      tcp_socket_ptr socket, control_request_ptr request)\n  {\n    if (!ec)\n    {\n      timer_ptr delay_timer(\n          new boost::asio::steady_timer(acceptor_.get_executor()));\n      delay_timer->expires_after(boost::asio::chrono::seconds(2));\n      delay_timer->async_wait(\n          std::bind(&server::handle_control_request_timer, this,\n            socket, request, delay_timer));\n    }\n  }\n\n  void handle_control_request_timer(tcp_socket_ptr socket,\n      control_request_ptr request, timer_ptr /*delay_timer*/)\n  {\n    boost::system::error_code ec;\n    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);\n    if (!ec)\n    {\n      if (unsigned short old_port = request->old_port())\n      {\n        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);\n        subscribers_.erase(old_endpoint);\n      }\n\n      if (unsigned short new_port = request->new_port())\n      {\n        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);\n        subscribers_.insert(new_endpoint);\n      }\n    }\n\n    boost::asio::async_read(*socket, request->to_buffers(),\n        std::bind(&server::handle_control_request, this,\n          boost::asio::placeholders::error, socket, request));\n  }\n\n  void handle_timer()\n  {\n    double x = next_frame_number_ * 0.2;\n    double y = std::sin(x);\n    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));\n    std::string payload;\n    for (int i = 0; i < frame::payload_size; ++i)\n      payload += (i == char_index ? '*' : '.');\n\n    frame f(next_frame_number_++, payload);\n\n    std::set<udp::endpoint>::iterator j;\n    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)\n    {\n      boost::system::error_code ec;\n      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);\n    }\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\nprivate:\n  tcp::acceptor acceptor_;\n  boost::asio::steady_timer timer_;\n  udp::socket udp_socket_;\n  unsigned long next_frame_number_;\n  std::set<udp::endpoint> subscribers_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "wrong_result": "```cpp\n#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <set>\n#include <string>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\nclass server\n{\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          timer_(io_context),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n          next_frame_number_(0)\n    {\n        start_accept();\n        start_timer();\n    }\n\nprivate:\n    void start_accept()\n    {\n        tcp_socket_ptr socket(new tcp::socket(acceptor_.get_executor().context()));\n        acceptor_.async_accept(socket, boost::bind(&server::handle_accept, this,\n            boost::asio::placeholders::error, socket));\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n    {\n        if (!ec)\n        {\n            control_request_ptr request(new control_request);\n            boost::asio::async_read_until(socket, request->buffer(), \"\\n\",\n                boost::bind(&server::handle_control_request, this,\n                    boost::asio::placeholders::error, socket, request));\n        }\n\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request)\n    {\n        if (!ec)\n        {\n            std::istream is(&request->buffer());\n            std::string line;\n            std::getline(is, line);\n\n            if (line == \"subscribe\")\n            {\n                udp::endpoint endpoint = udp_socket_.local_endpoint();\n                std::string endpoint_str = endpoint.address().to_string() + \":\" + boost::lexical_cast<std::string>(endpoint.port());\n                boost::asio::async_write(socket, boost::asio::buffer(endpoint_str),\n                    boost::bind(&server::handle_control_response, this,\n                        boost::asio::placeholders::error, socket));\n            }\n            else if (line == \"unsubscribe\")\n            {\n                // Handle unsubscribe request\n            }\n\n            control_request_ptr new_request(new control_request);\n            boost::asio::async_read_until(socket, new_request->buffer(), \"\\n\",\n                boost::bind(&server::handle_control_request, this,\n                    boost::asio::placeholders::error, socket, new_request));\n        }\n    }\n\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer)\n    {\n        if (!ec)\n        {\n            handle_control_request(ec, socket, request);\n        }\n    }\n\n    void handle_control_response(const boost::system::error_code& ec, tcp_socket_ptr socket)\n    {\n        if (!ec)\n        {\n            // Send response to client\n        }\n    }\n\n    void start_timer()\n    {\n        timer_.expires_from_now(boost::posix_time::seconds(1));\n        timer_.async_wait(boost::bind(&server::handle_timer, this));\n    }\n\n    void handle_timer()\n    {\n        // Broadcast data frame to all subscribed clients\n        ++next_frame_number_;\n\n        start_timer();\n    }\n\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};\n```"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that supports secure TLS connections and handles both WebSocket and HTTP requests.\n\nClass Description: The WebSocketServer class encapsulates a secure WebSocket server implementation using WebSocket++ with ASIO and TLS support. It handles incoming connections, processes messages, and manages secure communication settings.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that manages connections and communication\n- tls_mode: [enum] - Enumeration defining TLS security modes (MOZILLA_INTERMEDIATE, MOZILLA_MODERN)\n\nMethods:\n- WebSocketServer() -> [constructor] - Initializes the server, sets up ASIO, and registers handler functions\n- run([int port]) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_message([websocketpp::connection_hdl hdl, message_ptr msg]) -> [void] - Handles incoming WebSocket messages by echoing them back to the client\n- on_http([websocketpp::connection_hdl hdl]) -> [void] - Handles HTTP requests by returning a simple \"Hello World!\" response\n- get_password() -> [std::string] - Returns the password used for TLS certificate encryption\n- on_tls_init([tls_mode mode, websocketpp::connection_hdl hdl]) -> [context_ptr] - Initializes and configures TLS/SSL context with appropriate security settings based on the specified mode",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/lib/asio.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\ntypedef websocketpp::config::asio::message_type::ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        // Initialize ASIO\n        m_server.init_asio();\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, MOZILLA_INTERMEDIATE, ::_1));\n    }\n\n    void run(int port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start the server accept loop\n        m_server.start_accept();\n\n        // Start the ASIO io_service run loop\n        m_server.run();\n    }\n\nprivate:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE = 1,\n        MOZILLA_MODERN = 2\n    };\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        namespace asio = websocketpp::lib::asio;\n\n        context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_MODERN) {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::no_tlsv1 |\n                                 asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::single_dh_use);\n            }\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dh.pem\");\n            \n            std::string ciphers = (mode == MOZILLA_MODERN) ? \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\" : \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\";\n            \n            if (SSL_CTX_set_cipher_list(ctx->native_handle(), ciphers.c_str()) != 1) {\n                std::cout << \"Error setting cipher list\" << std::endl;\n            }\n        } catch (std::exception& e) {\n            std::cout << \"Exception: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/thread.hpp>\n#include <websocketpp/common/functional.hpp>\n#include <websocketpp/common/memory.hpp>\n#include <websocketpp/extensions/permessage_deflate/enabled.hpp>\n#include <websocketpp/extensions/permessage_deflate/disabled.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/permessage_deflate/extension.hpp>\n#include <websocketpp/extensions/per"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "```cpp\n#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/asio/spawn.hpp>\n#include <boost/asio/steady_timer.hpp>\n#include <boost/asio/strand.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error.hpp>\n#include <boost/asio/ssl/verify_mode.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/ssl/stream_base.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <boost/asio/ssl/error"
  }
]