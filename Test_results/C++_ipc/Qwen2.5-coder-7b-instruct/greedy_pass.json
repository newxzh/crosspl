[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send messages, and receive responses.\n\nFunction Description: The code consists of two functions that together implement a basic TCP client. The first function creates and connects the socket, while the second handles the communication loop with the server.\n\nInput:\n- create_tcp_client:\n  - server_ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n- tcp_client_communication:\n  - sockfd: int - The socket file descriptor returned by create_tcp_client\n\nOutput:\n- create_tcp_client:\n  - Returns: int - The socket file descriptor if successful, -1 if failed\n- tcp_client_communication:\n  - No return value (void), but prints server responses and error messages to console",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(server_ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    while(true){\n        char buf[1024];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    const char* message = \"Hello from client\";\n    send(sockfd, message, strlen(message), 0);\n    std::cout << \"Message sent\" << std::endl;\n\n    char buffer[1024] = {0};\n    read(sockfd, buffer, 1024);\n    std::cout << \"Server response: \" << buffer << std::endl;\n\n    close(sockfd);\n}\n```"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send messages, and receive responses.\n\nFunction Description: The code consists of two main functions for creating and managing a TCP client connection. The first function creates and connects a TCP socket to a specified server, while the second function handles the communication loop for sending and receiving messages.\n\nInput:\n- createAndConnectTCPSocket:\n  - ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n\n- tcpClientCommunication:\n  - sockfd: int - The socket file descriptor returned by createAndConnectTCPSocket\n\nOutput:\n- createAndConnectTCPSocket:\n  - Returns: int - The socket file descriptor if successful, -1 if failed\n\n- tcpClientCommunication:\n  - No return value (void), but performs I/O operations until connection is terminated",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        perror(\"Socket creation error\");\n        return -1;\n    }\n\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Connection Failed\");\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024] = {0};\n    const char* message = \"Hello from client\";\n\n    while (true) {\n        send(sockfd, message, strlen(message), 0);\n        std::cout << \"Message sent\" << std::endl;\n\n        int valread = read(sockfd, buffer, 1024);\n        if (valread > 0) {\n            std::cout << \"Received: \" << buffer << std::endl;\n        } else if (valread == 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        } else {\n            perror(\"Read error\");\n            break;\n        }\n    }\n\n    close(sockfd);\n}\n```"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server (localhost on port 8888 in this case), and enters a loop where it reads user input from stdin, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed by either side.\n\nInput: None (The server IP and port are hardcoded as 127.0.0.1 and 8888 respectively in the current implementation, but could be parameterized)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)\n\nNote: The function handles socket creation, connection establishment, data transmission, and proper cleanup (socket closing) in case of errors or normal termination.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Could not create socket\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server;\n    server.sin_family = AF_INET;\n    server.sin_port = htons(8888);\n\n    if(inet_pton(AF_INET, \"127.0.0.1\", &server.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while(true) {\n        std::cout << \"Enter message: \";\n        std::string message;\n        std::getline(std::cin, message);\n\n        send(sock, message.c_str(), message.length(), 0);\n        if (message == \"exit\") break;\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) break;\n        std::cout << \"Server response: \" << buffer << std::endl;\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a TCP client function in C++ that establishes a connection to a server, sends and receives messages, and maintains the connection until terminated by the user.\n\nFunction Description: The function `create_tcp_client` initializes a TCP client that connects to a specified server IP address. It creates a socket, establishes a connection, and provides interactive communication where the user can send messages to the server and receive responses. The function handles basic error cases and properly closes the connection when done.\n\nInput: \n- `server_ip`: [const char*] - The IP address of the server to connect to in string format (e.g., \"127.0.0.1\")\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any error occurs during socket creation or connection establishment. The function runs indefinitely until manually terminated by the user.\n\nNote: The function uses a default port 6666 for the connection. Error messages are printed to stderr using `perror` for debugging purposes. The communication loop continues until the program is interrupted, allowing continuous message exchange between client and server.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n\n#define DEFAULT_PORT 6666\n\nint create_tcp_client(const char* server_ip) {\n    int connfd = 0;\n    struct sockaddr_in client;\n    \n    client.sin_family = AF_INET;\n    client.sin_port = htons(DEFAULT_PORT);\n    client.sin_addr.s_addr = inet_addr(server_ip);\n    \n    connfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(connfd < 0){\n        perror(\"socket\");\n        return -1;\n    }\n    \n    if(connect(connfd, (struct sockaddr *)&client, sizeof(client)) < 0){\n        perror(\"connect\");\n        close(connfd);\n        return -1;\n    }\n    \n    char buff[1024];\n    bzero(buff, sizeof(buff));\n    recv(connfd, buff, 1024, 0);\n    printf(\"recv : %s \\n\", buff);\n    \n    bzero(buff, sizeof(buff));\n    strcpy(buff, \"this is client \\n\");\n    send(connfd, buff, 1024, 0);\n    \n    while(1){\n        bzero(buff, sizeof(buff));\n        scanf(\"%s\", buff);\n        int p = strlen(buff);\n        buff[p] = '\\0';\n        send(connfd, buff, 1024, 0);\n        printf(\"i have send buff \\n\");\n    }\n    \n    close(connfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        perror(\"Failed to create socket\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/ Address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server at \" << server_ip << \":\" << 6666 << std::endl;\n\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send: \";\n        std::cin.getline(buffer, 1024);\n\n        send(sock, buffer, strlen(buffer), 0);\n        if (std::string(buffer) == \"exit\") break;\n\n        int bytes_received = recv(sock, buffer, 1023, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Received from server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}\n```"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends a single character, receives a response, and then closes the connection.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server address and port, sends a predefined character ('A') to the server, reads the server's response, prints the received character, and finally closes the socket. This demonstrates basic TCP client functionality using BSD sockets.\n\nInput: None (The server address and port are hardcoded as 127.0.0.1:9736 in the function)\n\nOutput: \n- Returns 0 on successful execution\n- Prints the received character from the server\n- Exits with error code 1 if connection fails",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint tcp_client_communication()\n{\n    int sockfd = -1;\n    int len = 0;\n    struct sockaddr_in address;\n    int result;\n    char ch = 'A';\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    address.sin_port = htons(9736);\n    len = sizeof(address);\n    \n    result = connect(sockfd, (struct sockaddr*)&address, len);\n\n    if(result == -1)\n    {\n        perror(\"ops:client\\n\");\n        exit(1);\n    }\n    \n    write(sockfd, &ch, 1);\n    read(sockfd, &ch, 1);\n    printf(\"char form server = %c\\n\", ch);\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Could not create socket\" << std::endl;\n        return 1;\n    }\n\n    sockaddr_in server;\n    server.sin_family = AF_INET;\n    server.sin_port = htons(9736);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &server.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char* message = \"A\";\n    send(sock, message, strlen(message), 0);\n\n    char buffer[256] = {0};\n    read(sock, buffer, 255);\n\n    std::cout << \"Received: \" << buffer << std::endl;\n\n    close(sock);\n    return 0;\n}\n```"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Implement a TCP client socket class in C++ that handles connection establishment, data transmission, and connection management with a remote server, supporting both IPv4 and IPv6 protocols.\n\nClass Description: The ClientSocket class provides TCP client functionality with support for both IPv4 and IPv6 connections. It handles socket creation, connection establishment with timeout support, send buffer configuration, and connection cleanup. The class is designed to work within a multi-threaded context and supports encryption parameters.\n\nAttributes:\n- dest_: std::string - Destination hostname or IP address to connect to\n- threadCtx_: ThreadCtx& - Reference to thread context containing configuration options\n- sa_: struct addrinfo - Address information structure for socket configuration\n- socket_: std::unique_ptr<WdtSocket> - Smart pointer to the underlying socket implementation\n- peerIp_: std::string - IP address of the connected peer\n\nMethods:\n- Constructor: ClientSocket(ThreadCtx& threadCtx, const string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval) -> void - Initializes the client socket with destination, port, and encryption parameters\n- connect: connect() -> ErrorCode - Establishes connection to the remote server with timeout handling, returns connection status\n- getPeerIp: getPeerIp() -> const std::string& - Returns the IP address of the connected peer\n- setSendBufferSize: setSendBufferSize() -> void - Configures the socket's send buffer size based on thread context options\n- closeConnection: closeConnection() -> void [private] - Closes the active socket connection",
    "Canonical_solution": "#include <fcntl.h>\n#include <folly/Conv.h>\n#include <folly/ScopeGuard.h>\n#include <glog/logging.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <wdt/Reporting.h>\n#include <wdt/util/ClientSocket.h>\n\nnamespace facebook {\nnamespace wdt {\n\nusing std::string;\n\nclass ClientSocket {\npublic:\n  ClientSocket(ThreadCtx &threadCtx, const string &dest,\n               const int port,\n               const EncryptionParams &encryptionParams,\n               int64_t ivChangeInterval)\n      : dest_(dest), threadCtx_(threadCtx) {\n    memset(&sa_, 0, sizeof(sa_));\n    socket_ = std::make_unique<WdtSocket>(threadCtx, port, encryptionParams,\n                                          ivChangeInterval, nullptr);\n    if (threadCtx_.getOptions().ipv6) {\n      sa_.ai_family = AF_INET6;\n    }\n    if (threadCtx_.getOptions().ipv4) {\n      sa_.ai_family = AF_INET;\n    }\n    sa_.ai_socktype = SOCK_STREAM;\n  }\n\n  ErrorCode connect() {\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    WDT_CHECK(fd < 0) << \"Previous connection not closed \" << fd << \" \" << port;\n    \n    struct addrinfo *infoList = nullptr;\n    auto guard = folly::makeGuard([&] {\n      if (infoList) {\n        freeaddrinfo(infoList);\n      }\n    });\n    \n    string portStr = folly::to<string>(port);\n    int res = getaddrinfo(dest_.c_str(), portStr.c_str(), &sa_, &infoList);\n    if (res) {\n      WLOG(ERROR) << \"Failed getaddrinfo \" << dest_ << \" , \" << port << \" : \"\n                  << res << \" : \" << gai_strerror(res);\n      return CONN_ERROR;\n    }\n    \n    int count = 0;\n    for (struct addrinfo *info = infoList; info != nullptr;\n         info = info->ai_next) {\n      ++count;\n      std::string host, port_2;\n      WdtSocket::getNameInfo(info->ai_addr, info->ai_addrlen, host, port_2);\n      WVLOG(2) << \"will connect to \" << host << \" \" << port_2;\n      \n      fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);\n      if (fd == -1) {\n        WPLOG(WARNING) << \"Error making socket for port_2 \" << port_2;\n        continue;\n      }\n      \n      socket_->setFd(fd);\n      setSendBufferSize();\n\n      int sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg |= O_NONBLOCK;\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res < 0) {\n        WPLOG(ERROR) << \"Failed to make the socket non-blocking \" << port_2\n                     << \" sock \" << sockArg << \" res \" << res;\n        closeConnection();\n        continue;\n      }\n\n      if (::connect(fd, info->ai_addr, info->ai_addrlen) != 0) {\n        if (errno != EINPROGRESS) {\n          WPLOG(INFO) << \"Error connecting on \" << host << \" \" << port_2;\n          closeConnection();\n          continue;\n        }\n        \n        auto startTime = Clock::now();\n        int connectTimeout = threadCtx_.getOptions().connect_timeout_millis;\n\n        while (true) {\n          if (threadCtx_.getAbortChecker()->shouldAbort()) {\n            WLOG(ERROR) << \"Transfer aborted during connect \" << port_2 << \" \"\n                        << fd;\n            closeConnection();\n            return ABORT;\n          }\n          \n          int timeElapsed = durationMillis(Clock::now() - startTime);\n          if (timeElapsed >= connectTimeout) {\n            WVLOG(1) << \"connect() timed out\" << host << \" \" << port_2;\n            closeConnection();\n            return CONN_ERROR_RETRYABLE;\n          }\n          \n          int pollTimeout =\n              std::min(connectTimeout - timeElapsed,\n                       threadCtx_.getOptions().abort_check_interval_millis);\n          struct pollfd pollFds[] = {{fd, POLLOUT, 0}};\n\n          if ((res = poll(pollFds, 1, pollTimeout)) <= 0) {\n            if (errno == EINTR) {\n              WVLOG(1) << \"poll() call interrupted. retrying... \" << port_2;\n              continue;\n            }\n            if (res == 0) {\n              WVLOG(1) << \"poll() timed out \" << host << \" \" << port_2;\n              continue;\n            }\n            WPLOG(ERROR) << \"poll() failed \" << host << \" \" << port_2 << \" \"\n                         << fd;\n            closeConnection();\n            return CONN_ERROR;\n          }\n          break;\n        }\n\n        int connectResult;\n        socklen_t len = sizeof(connectResult);\n        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &connectResult, &len) < 0) {\n          WPLOG(WARNING) << \"getsockopt() failed\";\n          closeConnection();\n          continue;\n        }\n        if (connectResult != 0) {\n          WLOG(WARNING) << \"connect did not succeed on \" << host << \" \" << port_2\n                        << \" : \" << strerrorStr(connectResult);\n          closeConnection();\n          continue;\n        }\n      }\n\n      sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg &= (~O_NONBLOCK);\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res == -1) {\n        WPLOG(ERROR) << \"Could not make the socket blocking \" << port_2;\n        closeConnection();\n        continue;\n      }\n      \n      WVLOG(1) << \"Successful connect on \" << fd;\n      peerIp_ = host;\n      sa_ = *info;\n      break;\n    }\n    \n    if (socket_->getFd() < 0) {\n      if (count > 1) {\n        WLOG(INFO) << \"Unable to connect to either of the \" << count << \" addrs\";\n      }\n      return CONN_ERROR_RETRYABLE;\n    }\n    \n    socket_->setSocketTimeouts();\n    socket_->setDscp(threadCtx_.getOptions().dscp);\n    return OK;\n  }\n\n  const std::string &getPeerIp() const {\n    return peerIp_;\n  }\n\n  void setSendBufferSize() {\n    int bufSize = threadCtx_.getOptions().send_buffer_size;\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    if (bufSize <= 0) {\n      return;\n    }\n    int status =\n        ::setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bufSize, sizeof(bufSize));\n    if (status != 0) {\n      WPLOG(ERROR) << \"Failed to set send buffer \" << port << \" size \" << bufSize\n                   << \" fd \" << fd;\n      return;\n    }\n    WVLOG(1) << \"Send buffer size set to \" << bufSize << \" port \" << port;\n  }\n\nprivate:\n  std::string dest_;\n  ThreadCtx &threadCtx_;\n  struct addrinfo sa_;\n  std::unique_ptr<WdtSocket> socket_;\n  std::string peerIp_;\n\n  void closeConnection() {\n    socket_->close();\n  }\n};\n\n}  // namespace wdt\n}  // namespace facebook",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <memory>\n#include <string>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <unistd.h>\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() {}\n    virtual int connect(const struct addrinfo* ai) = 0;\n    virtual ssize_t send(const void* buf, size_t len, int flags) = 0;\n    virtual ssize_t recv(void* buf, size_t len, int flags) = 0;\n};\n\nclass ThreadCtx {\npublic:\n    struct Options {\n        int sendBufferSize;\n    };\n    Options options;\n};\n\nclass EncryptionParams {\npublic:\n    // Define encryption parameters as needed\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n        : dest_(dest), threadCtx_(threadCtx), socket_(std::make_unique<WdtSocket>()) {}\n\n    ErrorCode connect() {\n        struct addrinfo hints, *res;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC; // Allow IPv4 or IPv6\n        hints.ai_socktype = SOCK_STREAM;\n\n        if (getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &hints, &res) != 0) {\n            return ErrorCode::GAI_ERROR;\n        }\n\n        socket_->connect(res);\n        freeaddrinfo(res);\n\n        return ErrorCode::SUCCESS;\n    }\n\n    const std::string& getPeerIp() const {\n        return peerIp_;\n    }\n\n    void setSendBufferSize() {\n        int optval = threadCtx_.options.sendBufferSize;\n        setsockopt(socket_->fd(), SOL_SOCKET, SO_SNDBUF, &optval, sizeof(optval));\n    }\n\nprivate:\n    void closeConnection() {\n        socket_->close();\n    }\n\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n};\n```"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 8888, respectively, within the function.)\n\nOutput: None (The function prints received messages from the server to the console but does not return any value.)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_socket == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server_address;\n    memset(&server_address, 0, sizeof(server_address));\n    server_address.sin_family = AF_INET;\n    server_address.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &server_address.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(client_socket);\n        return;\n    }\n\n    if (connect(client_socket, (struct sockaddr *)&server_address, sizeof(server_address)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(client_socket);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n        send(client_socket, buffer, strlen(buffer), 0);\n        if (strcmp(buffer, \"exit\") == 0) break;\n\n        int valread = read(client_socket, buffer, 1024);\n        if (valread <= 0) break;\n        std::cout << \"Server response: \" << buffer << std::endl;\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(client_socket);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}\n```"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a TCP client class that can establish a connection to a server, send and receive data, and handle timeouts for non-blocking operations.\n\nClass Description: The TCPClient class provides functionality for TCP socket communication with a remote server. It supports both blocking and non-blocking operations with timeout capabilities, and handles cross-platform compatibility between Windows and Unix-like systems.\n\nAttributes:\n- address: std::string - The IP address or hostname of the server to connect to\n- port: u16 - The port number of the server to connect to\n- main_socket: SocketHolder (int) - The socket file descriptor for the connection\n- connected: bool - Flag indicating whether the client is currently connected to the server\n\nMethods:\n- Connect() -> bool - Establishes a connection to the server. Returns true if successful.\n- Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Reads data from the server into the buffer. Returns true if all requested bytes were read.\n- Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Writes data from the buffer to the server. Returns true if all bytes were written.\n- Disconnect() -> void - Closes the connection to the server.\n- SetNonBlock(SocketHolder sockFD, bool nonBlocking) -> bool - Sets the blocking mode of the socket. Returns true if successful.\n- ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) -> bool - Attempts to connect with a timeout. Returns true if successful.",
    "Canonical_solution": "#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <cerrno>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <string>\n\n#ifdef _WIN32\n#define WSAEAGAIN WSAEWOULDBLOCK\n#define WSAEMULTIHOP -1\n#define ERRNO(x) WSA##x\n#define GET_ERRNO WSAGetLastError()\n#define poll(x, y, z) WSAPoll(x, y, z);\n#define SHUT_RD SD_RECEIVE\n#define SHUT_WR SD_SEND\n#define SHUT_RDWR SD_BOTH\n#else\n#define ERRNO(x) x\n#define GET_ERRNO errno\n#define closesocket(x) close(x)\n#endif\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n\n    TCPClient(const std::string& address, u16 port) : address(address), port(port) {}\n\n    bool Connect() {\n        if (connected)\n            return true;\n\n        struct addrinfo hints, *addrinfo;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_family = AF_INET;\n\n        if (getaddrinfo(address.data(), NULL, &hints, &addrinfo) != 0) {\n            return false;\n        }\n\n        main_socket = ::socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == static_cast<SocketHolder>(-1)) {\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, true)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        struct sockaddr_in servaddr = {0};\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_addr.s_addr = ((struct sockaddr_in*)(addrinfo->ai_addr))->sin_addr.s_addr;\n        servaddr.sin_port = htons(port);\n        freeaddrinfo(addrinfo);\n\n        if (!ConnectWithTimeout(main_socket, &servaddr, sizeof(servaddr), 10)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t read_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (read_bytes != size) {\n            int new_read = ::recv(main_socket, (char*)((uintptr_t)buffer + read_bytes), \n                (int)(size - read_bytes), 0);\n            if (new_read < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                read_bytes = 0;\n                break;\n            }\n            read_bytes += new_read;\n        }\n        return read_bytes == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t write_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (write_bytes != size) {\n            int new_written = ::send(main_socket, (const char*)((uintptr_t)buffer + write_bytes),\n                                    (int)(size - write_bytes), 0);\n            if (new_written < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                write_bytes = 0;\n                break;\n            }\n            write_bytes += new_written;\n        }\n        return write_bytes == size;\n    }\n\n    void Disconnect() {\n        if (connected) {\n            shutdown(main_socket, SHUT_RDWR);\n            closesocket(main_socket);\n            connected = false;\n        }\n    }\n\nprivate:\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        bool blocking = !nonBlocking;\n#ifdef _WIN32\n        unsigned long nonblocking = (blocking) ? 0 : 1;\n        int ret = ioctlsocket(sockFD, FIONBIO, &nonblocking);\n        if (ret == -1) {\n            return false;\n        }\n#else\n        int flags = ::fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) {\n            return false;\n        }\n\n        flags &= ~O_NONBLOCK;\n        if (!blocking) {\n            flags |= O_NONBLOCK;\n        }\n\n        const int ret = ::fcntl(sockFD, F_SETFL, flags);\n        if (ret == -1) {\n            return false;\n        }\n#endif\n        return true;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len,\n                           int timeout_seconds) {\n        int res = ::connect(sockFD, (struct sockaddr*)server_addr, static_cast<int>(server_addr_len));\n        if (res == -1 && ((GET_ERRNO == ERRNO(EINPROGRESS) || GET_ERRNO == ERRNO(EWOULDBLOCK))) {\n            struct timeval tv;\n            fd_set fdset;\n            FD_ZERO(&fdset);\n            FD_SET(sockFD, &fdset);\n\n            tv.tv_sec = timeout_seconds;\n            tv.tv_usec = 0;\n            int select_res = ::select(static_cast<int>(sockFD + 1), NULL, &fdset, NULL, &tv);\n#ifdef _WIN32\n            if (select_res == 0) {\n                return false;\n            }\n#else\n            bool select_good = false;\n            if (select_res == 1) {\n                int so_error;\n                socklen_t len = sizeof so_error;\n\n                getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n                if (so_error == 0) {\n                    select_good = true;\n                }\n            }\n            if (!select_good) {\n                return false;\n            }\n#endif\n        } else if (res == -1) {\n            return false;\n        }\n        return true;\n    }\n\n    std::string address;\n    u16 port;\n    SocketHolder main_socket = -1;\n    bool connected = false;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <chrono>\n#include <thread>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#else\n#include <sys/select.h>\n#endif\n\nusing namespace std;\n\ntypedef int SocketHolder;\ntypedef unsigned short u16;\n\nclass TCPClient {\npublic:\n    TCPClient(string address, u16 port)\n        : address(address), port(port), main_socket(-1), connected(false) {}\n\n    ~TCPClient() { Disconnect(); }\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            return false;\n        }\n\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket < 0) {\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, false)) {\n            close(main_socket);\n            return false;\n        }\n\n        if (!ConnectWithTimeout(main_socket, &server_addr, sizeof(server_addr), 5)) {\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const chrono::nanoseconds& timeout) {\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = timeout.count() / 1000000000;\n        tv.tv_usec = (timeout.count() % 1000000000) / 1000;\n\n        int ret = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (ret == -1) {\n            return false;\n        } else if (ret == 0) {\n            return false; // Timeout\n        }\n\n        ssize_t bytesRead = recv(main_socket, buffer, size, 0);\n        return bytesRead == static_cast<ssize_t>(size);\n    }\n\n    bool Write(const void* buffer, size_t size, const chrono::nanoseconds& timeout) {\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = timeout.count() / 1000000000;\n        tv.tv_usec = (timeout.count() % 1000000000) / 1000;\n\n        int ret = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (ret == -1) {\n            return false;\n        } else if (ret == 0) {\n            return false; // Timeout\n        }\n\n        ssize_t bytesWritten = send(main_socket, buffer, size, 0);\n        return bytesWritten == static_cast<ssize_t>(size);\n    }\n\n    void Disconnect() {\n        if (connected) {\n            close(main_socket);\n            connected = false;\n        }\n    }\n\nprivate:\n    string address;\n    u16 port;\n    SocketHolder main_socket;\n    bool connected;\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n#ifdef _WIN32\n        u_long argp = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &argp) == 0;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) {\n            return false;\n        }\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) != -1;\n#endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (connect(sockFD, static_cast<struct sockaddr*>(server_addr), server_addr_len) == 0) {\n            return true;\n        }\n\n#ifdef _WIN32\n        int error_code = WSAGetLastError();\n        if (error_code == WSAEWOULDBLOCK || error_code == WSAEINVAL) {\n#else\n        if (errno == EINPROGRESS) {\n#endif\n            fd_set write_fds;\n            FD_ZERO(&write_fds);\n            FD_SET(sockFD, &write_fds);\n\n            struct timeval tv;\n            tv.tv_sec = timeout_seconds;\n            tv.tv_usec = 0;\n\n            int ret = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n            if (ret == -1) {\n                return false;\n            } else if (ret == 0) {\n                return false; // Timeout\n            }\n\n            char dummy;\n            int optlen = sizeof(dummy);\n            getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &dummy, reinterpret_cast<socklen_t*>(&optlen));\n            return dummy == 0;\n        }\n\n        return false;\n    }\n};\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests and handling responses, including JSON parsing capabilities.\n\nClass Description: The CurlHttpClient class provides methods for performing HTTP GET requests and downloading web pages, with support for custom headers and request bodies. It includes JSON response handling and memory management for received data.\n\nAttributes:\nMemoryStruct: [struct] - A helper structure for storing received data in memory during curl operations\n  - memory: [char*] - Pointer to the allocated memory buffer\n  - size: [size_t] - Size of the allocated memory buffer\n\nMethods:\nWriteMemoryCallback: [static](void* contents, size_t size, size_t nmemb, void* userp) -> size_t - A static callback function for libcurl to write received data into memory\n  - contents: [void*] - Pointer to the received data\n  - size: [size_t] - Size of each data element\n  - nmemb: [size_t] - Number of data elements\n  - userp: [void*] - Pointer to user-provided memory structure\n  - Returns: The number of bytes actually written\n\ndownloadPage: [](const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) -> long - Downloads a web page and returns the HTTP status code\n  - url: [const std::string&] - The URL to request\n  - res: [std::string&] - Reference to store the response body\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response\n\ngetRequest: [](const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) -> long - Performs a GET request and parses the JSON response\n  - url: [const std::string&] - The URL to request\n  - res: [json&] - Reference to store the parsed JSON response\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <vector>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::ordered_json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n        if (ptr == NULL) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl_handle;\n        MemoryStruct chunk;\n        struct curl_slist* list = NULL;\n        long status_code;\n\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_global_init(CURL_GLOBAL_ALL);\n        curl_handle = curl_easy_init();\n        curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());\n        if (!headers.empty()) {\n            for (auto& h : headers) {\n                list = curl_slist_append(list, h.c_str());\n            }\n            curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, list);\n        }\n        if (body != \"\") {\n            curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"HamletDuFromage\");\n\n        curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);\n        curl_easy_perform(curl_handle);\n        curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &status_code);\n        curl_easy_cleanup(curl_handle);\n        res = std::string(chunk.memory);\n        free(chunk.memory);\n\n        curl_global_cleanup();\n        return status_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string request;\n        long status_code = downloadPage(url, request, headers, body);\n\n        if (json::accept(request))\n            res = json::parse(request);\n        else\n            res = json::object();\n\n        return status_code;\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <memory>\n#include <curl/curl.h>\n#include \"nlohmann/json.hpp\"\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char *memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {\n    size_t realsize = size * nmemb;\n    struct MemoryStruct *mem = (struct MemoryStruct *)userp;\n\n    char *ptr = (char *)realloc(mem->memory, mem->size + realsize + 1);\n    if(ptr == NULL) {\n        return 0; // out of memory!\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    long downloadPage(const std::string &url, std::string &res, const std::vector<std::string> &headers, const std::string &body) {\n        CURL *curl_handle;\n        CURLcode res_code;\n        struct MemoryStruct chunk;\n\n        chunk.memory = (char *)malloc(1);  // will be grown as needed by the realloc above\n        chunk.size = 0;    // no data at this point\n\n        curl_global_init(CURL_GLOBAL_ALL);\n\n        curl_handle = curl_easy_init();\n\n        if(curl_handle) {\n            curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());\n            curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n            curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);\n            curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"libcurl-agent/1.0\");\n\n            for(const auto &header : headers) {\n                curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, curl_slist_append(NULL, header.c_str()));\n            }\n\n            if(!body.empty()) {\n                curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, body.c_str());\n                curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDSIZE, (long)body.length());\n            }\n\n            res_code = curl_easy_perform(curl_handle);\n\n            if(res_code != CURLE_OK) {\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res_code) << std::endl;\n            } else {\n                res.assign(chunk.memory, chunk.size);\n            }\n\n            free(chunk.memory);\n            curl_easy_cleanup(curl_handle);\n        }\n\n        curl_global_cleanup();\n        return res_code;\n    }\n\n    long getRequest(const std::string &url, json &res, const std::vector<std::string> &headers, const std::string &body) {\n        std::string responseBody;\n        long statusCode = downloadPage(url, responseBody, headers, body);\n        if(statusCode == CURLE_OK) {\n            try {\n                res = json::parse(responseBody);\n            } catch(json::parse_error &e) {\n                std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n                return -1;\n            }\n        }\n        return statusCode;\n    }\n};\n```"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server (localhost on port 8888 in this case), and enters a loop where it reads user input from stdin, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed by either side.\n\nInput: None (The server IP and port are hardcoded as 127.0.0.1 and 8888 respectively in the function. User input is collected interactively during execution.)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value. All communication results are handled via side effects.)\n\nNote: The function handles its own socket cleanup by closing the connection before exiting.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Could not create socket\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server;\n    server.sin_family = AF_INET;\n    server.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &server.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) break;\n        std::cout << \"Server response: \" << buffer << std::endl;\n        memset(buffer, 0, 1024);\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}\n```"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input to the server, and prints the server's response. The function should handle basic error cases and properly close the connection when done.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and displays the server's response. The loop continues until an error occurs or the connection is closed by the server. The function handles socket creation, connection, data transmission, and cleanup.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 1234 respectively in the function)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(1234);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Could not create socket\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server;\n    server.sin_family = AF_INET;\n    server.sin_port = htons(1234);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &server.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message : \";\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server : \" << buffer << std::endl;\n    }\n\n    close(sock);\n}\n\nint main() {\n    tcp_client_communication();\n    return 0;\n}\n```"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a TCP server in C++ that listens for incoming connections, receives data from clients, and echoes the data back to the clients. The server should handle one client at a time and properly clean up resources when the connection is terminated.\n\nFunction Description: The function `create_tcp_server` establishes a TCP server that binds to a specified IP address and port, listens for incoming connections, and handles client communication. It reads data from the client and sends the same data back (echo). The server runs until the client disconnects or an error occurs.\n\nInput: \n- `ip`: [const char*] - The IP address the server should bind to (e.g., \"127.0.0.1\" for localhost).\n- `port`: [int] - The port number the server should listen on (e.g., 8080).\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any step fails (socket creation, binding, listening, or accepting connections).",
    "Canonical_solution": "#include <stdio.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(bind(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    if(listen(sockfd, SOMAXCONN) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    bzero(&clnt_addr, sizeof(clnt_addr));\n\n    int clnt_sockfd = accept(sockfd, (sockaddr*)&clnt_addr, &clnt_addr_len);\n    if(clnt_sockfd == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sockfd, inet_ntoa(clnt_addr.sin_addr), ntohs(clnt_addr.sin_port));\n    \n    char buf[1024];\n    while (true) {\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(clnt_sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from client fd %d: %s\\n\", clnt_sockfd, buf);\n            write(clnt_sockfd, buf, sizeof(buf));\n        } else if(read_bytes == 0){\n            printf(\"client fd %d disconnected\\n\", clnt_sockfd);\n            close(clnt_sockfd);\n            break;\n        } else if(read_bytes == -1){\n            close(clnt_sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    const int buffer_size = 1024;\n    char buffer[buffer_size] = {0};\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    // Setting up the address struct\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    // Binding the socket to the address and port\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    // Listening for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server listening on \" << ip << \":\" << port << std::endl;\n\n    while (true) {\n        // Accepting a new connection\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            break;\n        }\n\n        std::cout << \"New connection, socket fd is \" << new_socket << \", IP is : \"\n                  << inet_ntoa(address.sin_addr) << \", port : \" << ntohs(address.sin_port) << std::endl;\n\n        while (true) {\n            // Reading data from the client\n            int valread = read(new_socket, buffer, buffer_size);\n            if (valread <= 0) {\n                break;\n            }\n            buffer[valread] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n\n            // Sending data back to the client\n            send(new_socket, buffer, strlen(buffer), 0);\n            memset(buffer, 0, buffer_size);\n        }\n\n        // Closing the connection\n        close(new_socket);\n    }\n\n    // Cleaning up the server socket\n    close(server_fd);\n    return 0;\n}\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Implement a TCP server in C++ that listens for incoming connections, handles client requests in separate child processes, and responds to clients after processing their data.\n\nFunction Description: The function `tcp_server_communication` creates a TCP server that binds to a specified port, listens for incoming connections, and forks child processes to handle each client connection. Each child process reads a character from the client, increments it after a delay, and sends it back before terminating.\n\nInput: None (The function uses predefined constants: port number 9736 and INADDR_ANY for binding to all available network interfaces)\n\nOutput: None (The function runs indefinitely, servicing client requests and doesn't return any value)\n\nNote: The function includes signal handling to prevent zombie processes from terminated child processes. Each client connection is handled in a separate child process while the parent process continues to accept new connections.",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <signal.h>\n\nvoid tcp_server_communication()\n{\n    int server_sockfd = -1;\n    int client_sockfd = -1;\n    int client_len = 0;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n    \n    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(9736);\n    \n    bind(server_sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(server_sockfd, 5);\n    signal(SIGCHLD, SIG_IGN);\n\n    while(1)\n    {\n        char ch = '\\0';\n        client_len = sizeof(client_addr);\n        client_sockfd = accept(server_sockfd, (struct sockaddr*)&client_addr,\n                               (socklen_t *)&client_len);\n\n        if(fork() == 0)\n        {\n            read(client_sockfd, &ch, 1);\n            sleep(5);\n            ch++;\n            write(client_sockfd, &ch, 1);\n            close(client_sockfd);\n            exit(0);\n        }\n        else\n        {\n            close(client_sockfd);\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "right_result": "```cpp\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n\n#define PORT 9736\n\nvoid tcp_server_communication() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    pid_t pid;\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Setting up the address struct\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    // Binding the socket to the port\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listening for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        close(server_fd);\n        exit(EXIT_FAILURE);\n    }\n\n    while (true) {\n        // Accepting a new connection\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        // Forking a child process to handle the client\n        pid = fork();\n        if (pid == 0) {\n            // Child process\n            close(server_fd); // Close the listening socket\n            read(new_socket, buffer, 1);\n            sleep(1); // Delay\n            buffer[0]++;\n            send(new_socket, buffer, 1, 0);\n            close(new_socket);\n            exit(EXIT_SUCCESS);\n        } else if (pid > 0) {\n            // Parent process\n            close(new_socket); // Close the new socket\n        } else {\n            // Error in fork\n            perror(\"fork\");\n            close(new_socket);\n        }\n    }\n\n    // Wait for all child processes to finish\n    while (wait(NULL) > 0);\n}\n\nint main() {\n    tcp_server_communication();\n    return 0;\n}\n```"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Implement a TCP server using UNIX domain sockets for inter-process communication that manages and provides access to statistics data. The server should handle multiple client connections concurrently, process different types of requests (get, reset, etc.), and maintain thread safety.\n\nClass Description: The Stats class implements a TCP server using UNIX domain sockets to manage and provide access to statistics data. It handles client connections, processes requests, and maintains thread safety for concurrent access to statistics.\n\nAttributes:\n- stats_socket_path_: std::string - Path to the UNIX domain socket file\n- sockfd_: int - File descriptor for the server socket\n- serv_addr_: sockaddr_un - Server address structure\n- stats_thread_: std::thread - Thread for running the socket server\n- statsThreadRunning_: std::atomic<bool> - Flag to control the server thread's execution\n- stats_mutex_: std::mutex - Mutex for protecting access to statistics data\n- thread_mutex_: std::mutex - Mutex for protecting thread count\n- thread_exited_: std::condition_variable - Condition variable for thread synchronization\n- thread_count_: int - Count of active threads\n- stats_: std::unordered_map<std::string, int> - Container for storing statistics data\n\nMethods:\n- Stats(const std::string& stats_socket_path) -> None - Constructor that initializes the socket server\n- ~Stats() -> None - Destructor that cleans up resources\n- get(const std::string& stats_socket_path) -> Stats& - Static method to get the singleton instance\n- get_for_unittest(const std::string& stats_socket_path) -> std::unique_ptr<Stats> - Static method to get an instance for unit testing\n- init(const std::string& stats_socket_path) -> bool - Static method to initialize the singleton\n- isInit() -> bool - Static method to check if the singleton is initialized\n- getAll() -> std::unordered_map<std::string, int> - Returns all statistics data\n- increment(const std::string& key, int val) -> int - Increments a statistic value\n- set(const std::string& key, int val) -> int - Sets a statistic value\n- reset() -> int - Resets all statistics\n- startSocket() -> bool - Starts the socket server\n- runSocket() -> void - Main server loop that accepts connections\n- processMsg(int sockfd) -> void - Processes a client message\n- isInitInternal() -> bool& - Internal static method for initialization status",
    "Canonical_solution": "#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n#include <json/value.h>\n\nnamespace Oomd {\n\nclass Stats {\npublic:\n  Stats(const std::string& stats_socket_path);\n  ~Stats();\n\n  static Stats& get(const std::string& stats_socket_path);\n  static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n  static bool init(const std::string& stats_socket_path);\n  static bool isInit();\n\n  std::unordered_map<std::string, int> getAll();\n  int increment(const std::string& key, int val);\n  int set(const std::string& key, int val);\n  int reset();\n\nprivate:\n  bool startSocket();\n  void runSocket();\n  void processMsg(int sockfd);\n  static bool& isInitInternal();\n\n  std::string stats_socket_path_;\n  int sockfd_{-1};\n  sockaddr_un serv_addr_{};\n  std::thread stats_thread_;\n  std::atomic<bool> statsThreadRunning_{true};\n  std::mutex stats_mutex_;\n  std::unordered_map<std::string, int> stats_;\n  std::mutex thread_mutex_;\n  std::condition_variable thread_exited_;\n  int thread_count_{0};\n};\n\nStats::Stats(const std::string& stats_socket_path)\n    : stats_socket_path_(stats_socket_path) {\n  if (!this->startSocket()) {\n    throw std::runtime_error(\"Socket thread failed to start\");\n  }\n}\n\nStats::~Stats() {\n  std::array<char, 64> err_buf = {};\n  statsThreadRunning_ = false;\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  if (!thread_exited_.wait_for(lock, std::chrono::seconds(5), [this] {\n        return this->thread_count_ == 0;\n      })) {\n    OCHECK(false);\n  }\n  lock.unlock();\n  if (stats_thread_.joinable()) {\n    stats_thread_.join();\n  }\n  if (::unlink(serv_addr_.sun_path) < 0) {\n    OLOG << \"Closing stats error: unlinking socket path: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  if (::close(sockfd_) < 0) {\n    OLOG << \"Closing stats error: closing stats socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n}\n\nbool Stats::startSocket() {\n  std::array<char, 64> err_buf = {};\n\n  sockfd_ = ::socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sockfd_ < 0) {\n    OLOG << \"Error creating socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size() - 1);\n    return false;\n  }\n  ::memset(&serv_addr_, '\\0', sizeof(serv_addr_));\n  serv_addr_.sun_family = AF_UNIX;\n  ::strcpy(serv_addr_.sun_path, stats_socket_path_.c_str());\n  if (::unlink(serv_addr_.sun_path) < 0 && errno != ENOENT) {\n    OLOG << \"Pre-unlinking of socket path failed. \" << serv_addr_.sun_path\n         << \". Errno: \" << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) < 0) {\n    OLOG << \"Error binding stats collection socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::listen(sockfd_, 5) < 0) {\n    OLOG << \"Error listening at socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  stats_thread_ = std::thread([this] { this->runSocket(); });\n  return true;\n}\n\nvoid Stats::runSocket() {\n  sockaddr_un cli_addr;\n  socklen_t clilen = sizeof(cli_addr);\n  std::array<char, 64> err_buf = {};\n  while (statsThreadRunning_) {\n    int sockfd = ::accept(sockfd_, (struct sockaddr*)&cli_addr, &clilen);\n    if (sockfd < 0) {\n      OLOG << \"Stats server error: accepting connection: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      continue;\n    }\n    std::unique_lock<std::mutex> lock(thread_mutex_);\n    ++thread_count_;\n    std::thread msg_thread_ =\n        std::thread([this, sockfd] { this->processMsg(sockfd); });\n    msg_thread_.detach();\n    lock.unlock();\n    thread_exited_.notify_one();\n  }\n}\n\nvoid Stats::processMsg(int sockfd) {\n  std::array<char, 64> err_buf = {};\n  OOMD_SCOPE_EXIT {\n    if (::close(sockfd) < 0) {\n      OLOG << \"Stats server error: closing file descriptor: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    }\n  };\n  char mode = 'a';\n  char byte_buf;\n  int num_read = 0;\n  for (; num_read < 32; num_read++) {\n    int res = ::read(sockfd, &byte_buf, 1);\n    if (res < 0) {\n      OLOG << \"Stats server error: reading from socket: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      return;\n    } else if (res == 0) {\n      break;\n    }\n    if (byte_buf == '\\n' || byte_buf == '\\0') {\n      break;\n    }\n    if (num_read == 0) {\n      mode = byte_buf;\n    }\n  }\n\n  Json::Value root;\n  root[\"error\"] = 0;\n  Json::Value body(Json::objectValue);\n  switch (mode) {\n    case 'g':\n      for (auto const& pair : getAll()) {\n        body[pair.first] = pair.second;\n      }\n      break;\n    case 'r':\n      Stats::reset();\n      break;\n    case '0':\n      break;\n    default:\n      root[\"error\"] = 1;\n      OLOG << \"Stats server error: received unknown request: \" << mode;\n  }\n  root[\"body\"] = body;\n  std::string ret = root.toStyledString();\n  if (Util::writeFull(sockfd, ret.c_str(), strlen(ret.c_str())) < 0) {\n    OLOG << \"Stats server error: writing to socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  thread_count_--;\n  lock.unlock();\n  thread_exited_.notify_one();\n}\n\n} // namespace Oomd",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "right_result": "```cpp\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n\nclass Stats {\npublic:\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n\nprivate:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    void startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\n\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static Stats* instance_;\n    static std::atomic<bool> is_init_;\n};\n\nStats* Stats::instance_ = nullptr;\nstd::atomic<bool> Stats::is_init_(false);\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!is_init_) {\n        throw std::runtime_error(\"Stats is not initialized\");\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    if (is_init_) {\n        throw std::runtime_error(\"Stats is already initialized\");\n    }\n    auto stats = std::make_unique<Stats>(stats_socket_path);\n    instance_ = stats.get();\n    is_init_.store(true);\n    return stats;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (is_init_) {\n        return false;\n    }\n    instance_ = new Stats(stats_socket_path);\n    is_init_.store(true);\n    return true;\n}\n\nbool Stats::isInit() {\n    return is_init_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it == stats_.end()) {\n        stats_[key] = val;\n    } else {\n        it->second += val;\n    }\n    return stats_[key];\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return stats_[key];\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nStats::Stats(const std::string& stats_socket_path)\n    : stats_socket_path_(stats_socket_path),\n      sockfd_(-1),\n      statsThreadRunning_(true),\n      thread_count_(0) {}\n\nStats::~Stats() {\n    stopSocket();\n    if (sockfd_ != -1) {\n        close(sockfd_);\n    }\n    if (instance_ == this) {\n        delete instance_;\n        instance_ = nullptr;\n    }\n}\n\nvoid Stats::startSocket() {\n    stats_thread_ = std::thread(&Stats::runSocket, this);\n}\n\nvoid Stats::runSocket() {\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        perror(\"socket creation failed\");\n        return;\n    }\n\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n\n    unlink(stats_socket_path_.c_str());\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        perror(\"bind failed\");\n        close(sockfd_);\n        return;\n    }\n\n    listen(sockfd_, 5);\n    while (statsThreadRunning_) {\n        int connfd = accept(sockfd_, NULL, NULL);\n        if (connfd >= 0) {\n            std::thread([this, connfd]() { processMsg(connfd); }).detach();\n        }\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024] = {0};\n    read(sockfd, buffer, 1024);\n    // Process the request and send response\n    write(sockfd, \"Response\", 8);\n    close(sockfd);\n}\n\nvoid Stats::stopSocket() {\n    statsThreadRunning_.store(false);\n    stats_thread_.join();\n}\n```"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a UDP server class using Boost.Asio that asynchronously receives datagrams and sends responses.\n\nClass Description: The udp_server class implements a UDP server that listens for incoming datagrams on a specified port and responds with a daytime string. It uses Boost.Asio for asynchronous network operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received message\n- recv_buffer_: [std::array<char, 1>] - Buffer for receiving incoming datagrams\n\nMethods:\n- udp_server([boost::asio::io_context&] io_context) -> [void] - Constructor that initializes the UDP socket and starts listening\n- start_receive() -> [void] - Begins asynchronous reception of UDP datagrams\n- handle_receive([const boost::system::error_code&] error) -> [void] - Callback for handling received datagrams and sending responses\n- handle_send([std::shared_ptr<std::string>] message) -> [void] - Callback for handling completed send operations",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error));\n  }\n\n  void handle_receive(const boost::system::error_code& error)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/)\n  {\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n#include <memory>\n#include <ctime>\n\nusing boost::asio::ip::udp;\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, udp::endpoint(udp::v4(), 13)) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                handle_receive(ec, bytes_recvd);\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_recvd) {\n        if (!error || error == boost::asio::error::message_size) {\n            std::time_t now = std::time(nullptr);\n            std::string response = std::ctime(&now);\n\n            auto send_msg = std::make_shared<std::string>(response);\n            socket_.async_send_to(\n                boost::asio::buffer(*send_msg), remote_endpoint_,\n                [this, send_msg](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/) {\n                    handle_send(send_msg);\n                });\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/) {\n        // No action needed after send completion\n    }\n\nprivate:\n    udp::socket socket_;\n    udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nClass Description: The `udp_server` class implements a UDP server that listens on a specified port (13 in this case) for incoming datagrams. When a datagram is received, it responds with the current daytime string. The class uses asynchronous operations for receiving and sending data.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received datagram\n- recv_buffer_: [std::array<char, 1>] - Buffer for storing received data\n\nMethods:\n- Constructor: [udp_server]([boost::asio::io_context& io_context]) -> [void] - Initializes the UDP socket and starts listening for incoming datagrams\n- start_receive: [start_receive]() -> [void] - Begins an asynchronous receive operation on the socket\n- handle_receive: [handle_receive]([const boost::system::error_code& error, std::size_t bytes_transferred]) -> [void] - Handles the completion of a receive operation and initiates a response\n- handle_send: [handle_send]([std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred]) -> [void] - Handles the completion of a send operation\n- make_daytime_string: [make_daytime_string]() -> [std::string] - Generates and returns the current daytime string",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\n\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error,\n          boost::asio::placeholders::bytes_transferred));\n  }\n\n  void handle_receive(const boost::system::error_code& error,\n      std::size_t /*bytes_transferred*/)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message,\n            boost::asio::placeholders::error,\n            boost::asio::placeholders::bytes_transferred));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/,\n      const boost::system::error_code& /*error*/,\n      std::size_t /*bytes_transferred*/)\n  {\n  }\n\n  std::string make_daytime_string()\n  {\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <ctime>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, udp::endpoint(udp::v4(), 13)),\n          recv_buffer_{0} {\n        start_receive();\n    }\n\nprivate:\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            [this](boost::system::error_code ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    handle_receive(ec, 1);\n                }\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n        if (!ec) {\n            auto now = std::time(nullptr);\n            auto daytime_str = make_daytime_string(now);\n\n            socket_.async_send_to(\n                boost::asio::buffer(daytime_str), remote_endpoint_,\n                [this, daytime_str](boost::system::error_code ec, std::size_t /*bytes_transferred*/) {\n                    if (!ec) {\n                        start_receive();\n                    }\n                });\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> /*message*/, const boost::system::error_code& /*ec*/, std::size_t /*bytes_transferred*/) {}\n\n    static std::string make_daytime_string(std::time_t now = std::time(nullptr)) {\n        return std::ctime(&now);\n    }\n\n    udp::socket socket_;\n    udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};\n\nint main() {\n    try {\n        boost::asio::io_context io_context;\n        udp_server server(io_context);\n        io_context.run();\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n\n    return 0;\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests to a specified base URL.\n\nClass Description: The HTTPClient class provides a simple interface for making HTTP GET requests to a given base URL. It handles libcurl initialization, request configuration, execution, and cleanup, while providing a method to append endpoints to the base URL and make requests.\n\nAttributes:\nbaseURL: std::string - The base URL to which endpoints will be appended for HTTP requests\n\nMethods:\nmakeRequest: makeRequest(const std::string& endpoint) -> std::string - Makes an HTTP GET request to the base URL plus the specified endpoint, returning the response as a string\nwrite_to_string: write_to_string(void* ptr, size_t size, size_t count, void* stream) -> size_t - Static callback function for libcurl to write response data into a string",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <sstream>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string URL = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, URL.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_perform(curl);\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, 0, size*count);\n        return size*count;\n    }\n\n    std::string baseURL;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "```cpp\n#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseURL) : baseURL(baseURL) {}\n\n    ~HTTPClient() {\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL *curl;\n        CURLcode res;\n        std::string readBuffer;\n\n        curl = curl_easy_init();\n        if(curl) {\n            std::string fullUrl = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n\n            res = curl_easy_perform(curl);\n            if(res != CURLE_OK)\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n\n            curl_easy_cleanup(curl);\n        }\n        return readBuffer;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n};\n```"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that can asynchronously receive and send datagrams.\n\nClass Description: The `server` class represents a UDP server that listens on a specified port, receives incoming datagrams asynchronously, and sends responses back to the sender. It utilizes Boost.Asio for asynchronous I/O operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- sender_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last sender\n- max_length: [enum] - Maximum size of the receive buffer (1024 bytes)\n- data_: [char[max_length]] - Buffer for storing received data\n\nMethods:\n- server: [constructor](boost::asio::io_context& io_context, short port) -> void - Initializes the UDP socket and starts the receive operation\n- do_receive: [method]() -> void - Asynchronously receives data from clients and triggers do_send if data is received\n- do_send: [method](std::size_t length) -> void - Asynchronously sends the received data back to the sender",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n\nusing boost::asio::ip::udp;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, short port)\n    : socket_(io_context, udp::endpoint(udp::v4(), port))\n  {\n    do_receive();\n  }\n\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd)\n        {\n          if (!ec && bytes_recvd > 0)\n          {\n            do_send(bytes_recvd);\n          }\n          else\n          {\n            do_receive();\n          }\n        });\n  }\n\n  void do_send(std::size_t length)\n  {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length), sender_endpoint_,\n        [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/)\n        {\n          do_receive();\n        });\n  }\n\nprivate:\n  udp::socket socket_;\n  udp::endpoint sender_endpoint_;\n  enum { max_length = 1024 };\n  char data_[max_length];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nclass server {\npublic:\n    server(boost::asio::io_context& io_context, short port)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n          max_length(1024) {\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t length) {\n                if (!ec && length > 0) {\n                    do_send(length);\n                }\n                do_receive();\n            });\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length), sender_endpoint_,\n            [](boost::system::error_code /*ec*/, std::size_t /*length*/) {});\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    enum { max_length = 1024 };\n    char data_[max_length];\n};\n```"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Implement a UDP server using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nFunction Description: The function `udp_server` creates a UDP server that listens on port 13 (daytime protocol port). When it receives any datagram from a client, it responds with the current time in string format. The server runs indefinitely until an exception occurs.\n\nInput: None\n\nOutput: None (The function runs indefinitely and sends responses to clients, but doesn't return any value)",
    "Canonical_solution": "#include <array>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n  using namespace std;\n  time_t now = time(0);\n  return ctime(&now);\n}\n\nvoid udp_server()\n{\n  try\n  {\n    boost::asio::io_context io_context;\n\n    udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n    for (;;)\n    {\n      std::array<char, 1> recv_buf;\n      udp::endpoint remote_endpoint;\n      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);\n\n      std::string message = make_daytime_string();\n\n      boost::system::error_code ignored_error;\n      socket.send_to(boost::asio::buffer(message),\n          remote_endpoint, 0, ignored_error);\n    }\n  }\n  catch (std::exception& e)\n  {\n    std::cerr << e.what() << std::endl;\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <iostream>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string get_daytime_string() {\n    auto now = std::chrono::system_clock::now();\n    auto in_time_t = std::chrono::system_clock::to_time_t(now);\n    std::stringstream ss;\n    ss << std::put_time(std::localtime(&in_time_t), \"%Y-%m-%d %H:%M:%S\");\n    return ss.str();\n}\n\nvoid udp_server(boost::asio::io_context& io_context, short port) {\n    udp::socket socket(io_context, udp::endpoint(udp::v4(), port));\n    while (true) {\n        udp::endpoint remote_endpoint;\n        char data[1024];\n        size_t length = socket.receive_from(\n            boost::asio::buffer(data, sizeof(data)), remote_endpoint);\n\n        std::string message = get_daytime_string();\n\n        socket.send_to(boost::asio::buffer(message), remote_endpoint);\n    }\n}\n\nint main() {\n    try {\n        boost::asio::io_context io_context;\n        udp_server(io_context, 13);\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n\n    return 0;\n}\n```"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a UDP multicast sender class using Boost.Asio that periodically sends messages to a specified multicast address.\n\nClass Description: The `sender` class encapsulates functionality for sending UDP multicast messages at regular intervals. It uses Boost.Asio for asynchronous network operations and timer management.\n\nAttributes:\n- endpoint_: [boost::asio::ip::udp::endpoint] - The multicast endpoint (address + port) to send messages to\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for sending messages\n- timer_: [boost::asio::steady_timer] - Timer used to schedule message sends\n- message_count_: [int] - Counter tracking the number of messages sent\n- message_: [std::string] - The current message content to be sent\n\nMethods:\n- sender([boost::asio::io_context&] io_context, [const boost::asio::ip::address&] multicast_address) -> [void] - Constructor that initializes the sender with IO context and multicast address\n- do_send() -> [void] - Asynchronously sends the current message to the multicast endpoint\n- do_timeout() -> [void] - Sets up a timer to schedule the next message send after a delay",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <string>\n#include <chrono>\n\nclass sender\n{\npublic:\n  sender(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& multicast_address)\n    : endpoint_(multicast_address, multicast_port),\n      socket_(io_context, endpoint_.protocol()),\n      timer_(io_context),\n      message_count_(0)\n  {\n    do_send();\n  }\n\nprivate:\n  void do_send()\n  {\n    std::ostringstream os;\n    os << \"Message \" << message_count_++;\n    message_ = os.str();\n\n    socket_.async_send_to(\n        boost::asio::buffer(message_), endpoint_,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && message_count_ < max_message_count)\n            do_timeout();\n        });\n  }\n\n  void do_timeout()\n  {\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(\n        [this](boost::system::error_code ec)\n        {\n          if (!ec)\n            do_send();\n        });\n  }\n\nprivate:\n  boost::asio::ip::udp::endpoint endpoint_;\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::steady_timer timer_;\n  int message_count_;\n  std::string message_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : socket_(io_context, udp::endpoint(udp::v4(), 0)),\n          timer_(io_context),\n          message_(\"Hello, Multicast!\"),\n          message_count_(0) {\n        endpoint_ = udp::endpoint(multicast_address, 12345);\n        do_send();\n        do_timeout();\n    }\n\nprivate:\n    void do_send() {\n        auto self(shared_from_this());\n        socket_.async_send_to(\n            boost::asio::buffer(message_),\n            endpoint_,\n            [this, self](boost::system::error_code /*e*/, std::size_t /*bytes_sent*/) {\n                ++message_count_;\n                std::cout << \"Message \" << message_count_ << \" sent.\" << std::endl;\n                do_timeout();\n            });\n    }\n\n    void do_timeout() {\n        timer_.expires_after(std::chrono::seconds(1));\n        timer_.async_wait(\n            [this](boost::system::error_code /*e*/) {\n                if (!e) {\n                    do_send();\n                }\n            });\n    }\n\n    udp::endpoint endpoint_;\n    udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};\n```"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Implement a UDP echo server using Boost.Asio that listens on a specified port, receives incoming datagrams, and sends them back to the sender.\n\nFunction Description: The function creates a UDP socket bound to a specified port, then enters an infinite loop where it receives datagrams from clients and echoes them back to the sender. This demonstrates basic UDP communication using Boost.Asio.\n\nInput:\n- io_context: boost::asio::io_context& - Reference to an I/O execution context that manages asynchronous operations\n- port: unsigned short - The port number on which the server should listen for incoming UDP datagrams\n\nOutput: None (The function runs indefinitely in a loop, processing incoming datagrams)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\nenum { max_length = 1024 };\n\nvoid server(boost::asio::io_context& io_context, unsigned short port)\n{\n  udp::socket sock(io_context, udp::endpoint(udp::v4(), port));\n  for (;;)\n  {\n    char data[max_length];\n    udp::endpoint sender_endpoint;\n    size_t length = sock.receive_from(\n        boost::asio::buffer(data, max_length), sender_endpoint);\n    sock.send_to(boost::asio::buffer(data, length), sender_endpoint);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nvoid start_udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    char data[1024];\n    while (true) {\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::size_t length = socket.receive_from(boost::asio::buffer(data, 1024), remote_endpoint);\n        socket.send_to(boost::asio::buffer(data, length), remote_endpoint);\n    }\n}\n```"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a UDP client communication function using Boost.Asio to send a message to a specified host and port, and receive a response.\n\nFunction Description: The function establishes a UDP client connection, sends a message to a specified server, and waits to receive a response. It uses Boost.Asio for asynchronous UDP operations.\n\nInput:\n- host: [std::string] - The hostname or IP address of the UDP server to connect to\n- port: [std::string] - The port number of the UDP server\n- message: [std::string] - The message to be sent to the server\n\nOutput: None (The function receives a reply from the server but doesn't return it. In a real implementation, you might want to return the reply or process it further.)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client_communication(const std::string& host, const std::string& port, const std::string& message)\n{\n    boost::asio::io_context io_context;\n    udp::socket s(io_context, udp::endpoint(udp::v4(), 0));\n    udp::resolver resolver(io_context);\n    udp::resolver::results_type endpoints = resolver.resolve(udp::v4(), host, port);\n\n    size_t request_length = message.length();\n    s.send_to(boost::asio::buffer(message, request_length), *endpoints.begin());\n\n    char reply[max_length];\n    udp::endpoint sender_endpoint;\n    size_t reply_length = s.receive_from(boost::asio::buffer(reply, max_length), sender_endpoint);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_client(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::resolver resolver(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint = *resolver.resolve(host, port).begin();\n        boost::asio::ip::udp::socket socket(io_context);\n\n        socket.open(boost::asio::ip::udp::v4());\n\n        boost::system::error_code error;\n        socket.send_to(boost::asio::buffer(message), remote_endpoint, 0, error);\n\n        if (!error) {\n            char reply[128];\n            boost::array<boost::asio::mutable_buffer, 1> buffers{ { boost::asio::buffer(reply, sizeof(reply)) } };\n            boost::asio::endpoint sender_endpoint;\n            size_t length = socket.receive_from(buffers[0], sender_endpoint, 0, error);\n\n            if (!error) {\n                std::cout << \"Reply: \";\n                std::cout.write(reply, length);\n                std::cout << std::endl;\n            }\n        } else {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}\n```"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a UDP multicast receiver class using Boost.Asio that listens for incoming datagrams on a specified multicast address and port, and prints received messages to the console.\n\nClass Description: The `receiver` class encapsulates functionality for receiving UDP multicast messages. It initializes a UDP socket, joins a multicast group, and asynchronously receives datagrams, printing their contents to standard output.\n\nAttributes:\n- socket_: boost::asio::ip::udp::socket - The UDP socket used for communication\n- sender_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint of the sender of the last received message\n- data_: std::array<char, 1024> - Buffer for storing received data\n\nMethods:\n- receiver(boost::asio::io_context&, const boost::asio::ip::address&, const boost::asio::ip::address&) -> None - Constructor that initializes the socket, binds it to the listening address and port, joins the multicast group, and starts receiving\n- do_receive() -> None - Private method that asynchronously receives data and prints it to console, then continues listening for more data",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nconstexpr short multicast_port = 30001;\n\nclass receiver\n{\npublic:\n  receiver(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& listen_address,\n      const boost::asio::ip::address& multicast_address)\n    : socket_(io_context)\n  {\n    // Create the socket so that multiple may be bound to the same address.\n    boost::asio::ip::udp::endpoint listen_endpoint(\n        listen_address, multicast_port);\n    socket_.open(listen_endpoint.protocol());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(listen_endpoint);\n\n    // Join the multicast group.\n    socket_.set_option(\n        boost::asio::ip::multicast::join_group(multicast_address));\n\n    do_receive();\n  }\n\nprivate:\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::cout.write(data_.data(), length);\n            std::cout << std::endl;\n\n            do_receive();\n          }\n        });\n  }\n\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::ip::udp::endpoint sender_endpoint_;\n  std::array<char, 1024> data_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context,\n              const boost::asio::ip::address& listen_address,\n              const boost::asio::ip::address& multicast_address)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 13117)),\n          sender_endpoint_(),\n          data_()\n    {\n        socket_.set_option(boost::asio::ip::multicast::join_group(multicast_address));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, data_.size()), sender_endpoint_,\n            [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};\n```"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a UDP client function using Boost.Asio that sends a request to a UDP server and receives a response.\n\nFunction Description: The function establishes a UDP connection to a specified host, sends a minimal request packet, waits for a response, and prints the received data to standard output. It uses Boost.Asio for asynchronous UDP operations.\n\nInput: \n- host: std::string - The hostname or IP address of the UDP server to connect to\n\nOutput: \n- None (void function), but prints the received data to standard output\n\nNote: The function uses a fixed service name \"daytime\" (port 13) for demonstration purposes. In a real application, this would typically be configurable. The function handles both IPv4 and UDP protocol operations.",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client(const std::string& host)\n{\n    boost::asio::io_context io_context;\n\n    udp::resolver resolver(io_context);\n    udp::endpoint receiver_endpoint =\n      *resolver.resolve(udp::v4(), host, \"daytime\").begin();\n\n    udp::socket socket(io_context);\n    socket.open(udp::v4());\n\n    std::array<char, 1> send_buf  = {{ 0 }};\n    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n\n    std::array<char, 128> recv_buf;\n    udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(\n        boost::asio::buffer(recv_buf), sender_endpoint);\n\n    std::cout.write(recv_buf.data(), len);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing boost::asio::ip::udp;\n\nvoid udp_client(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        udp::resolver resolver(io_context);\n        udp::endpoint endpoint = *resolver.resolve(host, \"daytime\").begin();\n        udp::socket socket(io_context);\n\n        socket.open(udp::v4());\n        socket.send_to(boost::asio::buffer(\"Request\"), endpoint);\n\n        char reply[1024];\n        udp::endpoint sender_endpoint;\n        size_t reply_length = socket.receive_from(\n            boost::asio::buffer(reply, sizeof(reply)), sender_endpoint);\n\n        std::cout.write(reply, reply_length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: udp_client <host>\\n\";\n        return 1;\n    }\n\n    udp_client(argv[1]);\n    return 0;\n}\n```"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a UDP-based client-server communication system using Boost.Asio in C++ that demonstrates asynchronous sending and receiving of datagrams.\n\nClass Description: The `udp_communicator` class provides asynchronous UDP communication capabilities for both sending and receiving datagrams. It manages socket operations, IO context, and buffers for network communication.\n\nAttributes:\n- io_context_: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket_: boost::asio::ip::udp::socket - Represents the UDP socket for communication\n- receiver_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint information for receiving data\n- sender_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint information of the sender\n- receive_buffer_: std::array<char, 1024> - Buffer for storing received data\n- send_buffer_: std::string - Buffer for storing data to be sent\n\nMethods:\n- constructor(io_context, port) -> void - Initializes the UDP socket and binds it to the specified port\n- start_receive() -> void - Begins asynchronous reception of UDP datagrams\n- handle_receive(error_code, bytes_transferred) -> void - Callback for handling received data\n- send_to(message, endpoint) -> void - Asynchronously sends a message to the specified endpoint\n- handle_send(error_code, bytes_transferred) -> void - Callback for handling send completion\n- get_socket() -> boost::asio::ip::udp::socket& - Returns a reference to the UDP socket\n- get_io_context() -> boost::asio::io_context& - Returns a reference to the IO context",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <istream>\n#include <ostream>\n#include \"icmp_header.hpp\"\n#include \"ipv4_header.hpp\"\n\nusing boost::asio::ip::icmp;\nusing boost::asio::steady_timer;\nnamespace chrono = boost::asio::chrono;\n\nclass pinger\n{\npublic:\n  pinger(boost::asio::io_context& io_context, const char* destination)\n    : resolver_(io_context), socket_(io_context, icmp::v4()),\n      timer_(io_context), sequence_number_(0), num_replies_(0)\n  {\n    destination_ = *resolver_.resolve(icmp::v4(), destination, \"\").begin();\n\n    start_send();\n    start_receive();\n  }\n\nprivate:\n  void start_send()\n  {\n    std::string body(\"\\\"Hello!\\\" from Asio ping.\");\n\n    icmp_header echo_request;\n    echo_request.type(icmp_header::echo_request);\n    echo_request.code(0);\n    echo_request.identifier(get_identifier());\n    echo_request.sequence_number(++sequence_number_);\n    compute_checksum(echo_request, body.begin(), body.end());\n\n    boost::asio::streambuf request_buffer;\n    std::ostream os(&request_buffer);\n    os << echo_request << body;\n\n    time_sent_ = steady_timer::clock_type::now();\n    socket_.send_to(request_buffer.data(), destination_);\n\n    num_replies_ = 0;\n    timer_.expires_at(time_sent_ + chrono::seconds(5));\n    timer_.async_wait(std::bind(&pinger::handle_timeout, this));\n  }\n\n  void handle_timeout()\n  {\n    if (num_replies_ == 0)\n      std::cout << \"Request timed out\" << std::endl;\n\n    timer_.expires_at(time_sent_ + chrono::seconds(1));\n    timer_.async_wait(std::bind(&pinger::start_send, this));\n  }\n\n  void start_receive()\n  {\n    reply_buffer_.consume(reply_buffer_.size());\n\n    socket_.async_receive(reply_buffer_.prepare(65536),\n        std::bind(&pinger::handle_receive, this, std::placeholders::_2));\n  }\n\n  void handle_receive(std::size_t length)\n  {\n    reply_buffer_.commit(length);\n\n    std::istream is(&reply_buffer_);\n    ipv4_header ipv4_hdr;\n    icmp_header icmp_hdr;\n    is >> ipv4_hdr >> icmp_hdr;\n\n    if (is && icmp_hdr.type() == icmp_header::echo_reply\n          && icmp_hdr.identifier() == get_identifier()\n          && icmp_hdr.sequence_number() == sequence_number_)\n    {\n      if (num_replies_++ == 0)\n        timer_.cancel();\n\n      chrono::steady_clock::time_point now = chrono::steady_clock::now();\n      chrono::steady_clock::duration elapsed = now - time_sent_;\n      std::cout << length - ipv4_hdr.header_length()\n        << \" bytes from \" << ipv4_hdr.source_address()\n        << \": icmp_seq=\" << icmp_hdr.sequence_number()\n        << \", ttl=\" << ipv4_hdr.time_to_live()\n        << \", time=\"\n        << chrono::duration_cast<chrono::milliseconds>(elapsed).count()\n        << std::endl;\n    }\n\n    start_receive();\n  }\n\n  static unsigned short get_identifier()\n  {\n#if defined(BOOST_ASIO_WINDOWS)\n    return static_cast<unsigned short>(::GetCurrentProcessId());\n#else\n    return static_cast<unsigned short>(::getpid());\n#endif\n  }\n\n  icmp::resolver resolver_;\n  icmp::endpoint destination_;\n  icmp::socket socket_;\n  steady_timer timer_;\n  unsigned short sequence_number_;\n  chrono::steady_clock::time_point time_sent_;\n  boost::asio::streambuf reply_buffer_;\n  std::size_t num_replies_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n#include <array>\n\nclass udp_communicator {\npublic:\n    udp_communicator(boost::asio::io_context& io_context, short port)\n        : io_context_(io_context),\n          socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n          receiver_endpoint_(),\n          sender_endpoint_(),\n          receive_buffer_(),\n          send_buffer_(\"Hello, Server!\") {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                handle_receive(error, bytes_transferred);\n            });\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error) {\n            std::cout << \"Received: \" << std::string(receive_buffer_.begin(), receive_buffer_.begin() + bytes_transferred) << std::endl;\n            send_to(\"Hello, Client!\", receiver_endpoint_);\n        }\n        start_receive();\n    }\n\n    void send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n        send_buffer_ = message;\n        socket_.async_send_to(\n            boost::asio::buffer(send_buffer_), endpoint,\n            [this](const boost::system::error_code& error, std::size_t bytes_transferred) {\n                handle_send(error, bytes_transferred);\n            });\n    }\n\n    void handle_send(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (error) {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        } else {\n            std::cout << \"Sent: \" << send_buffer_ << std::endl;\n        }\n    }\n\n    boost::asio::ip::udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint receiver_endpoint_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Implement a server class that handles both TCP and UDP communications using Boost.Asio, managing client subscriptions and broadcasting data frames to subscribed clients.\n\nClass Description: The `server` class manages network communications using both TCP and UDP protocols. It accepts TCP connections for control messages, maintains a set of subscribed UDP endpoints, and periodically broadcasts data frames to all subscribed clients via UDP.\n\nAttributes:\n- acceptor_: [tcp::acceptor] - Handles incoming TCP connections\n- timer_: [boost::asio::steady_timer] - Manages periodic operations\n- udp_socket_: [udp::socket] - Handles UDP communications\n- next_frame_number_: [unsigned long] - Tracks the sequence number for frames\n- subscribers_: [std::set<udp::endpoint>] - Stores subscribed client endpoints\n\nMethods:\n- server([boost::asio::io_context&] io_context, [unsigned short] port) -> [void] - Constructor that initializes the server with IO context and port\n- handle_accept([const boost::system::error_code&] ec, [tcp_socket_ptr] socket) -> [void] - Handles new TCP connection acceptances\n- handle_control_request([const boost::system::error_code&] ec, [tcp_socket_ptr] socket, [control_request_ptr] request) -> [void] - Processes control requests from clients\n- handle_control_request_timer([tcp_socket_ptr] socket, [control_request_ptr] request, [timer_ptr] delay_timer) -> [void] - Handles delayed processing of control requests\n- handle_timer() -> [void] - Periodically broadcasts data frames to subscribed clients",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <set>\n#include <memory>\n#include \"protocol.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef std::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef std::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef std::shared_ptr<control_request> control_request_ptr;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, unsigned short port)\n    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n      timer_(io_context),\n      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n      next_frame_number_(1)\n  {\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\n  void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n  {\n    if (!ec)\n    {\n      control_request_ptr request(new control_request);\n      boost::asio::async_read(*socket, request->to_buffers(),\n          std::bind(&server::handle_control_request, this,\n            boost::asio::placeholders::error, socket, request));\n    }\n\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n  }\n\n  void handle_control_request(const boost::system::error_code& ec,\n      tcp_socket_ptr socket, control_request_ptr request)\n  {\n    if (!ec)\n    {\n      timer_ptr delay_timer(\n          new boost::asio::steady_timer(acceptor_.get_executor()));\n      delay_timer->expires_after(boost::asio::chrono::seconds(2));\n      delay_timer->async_wait(\n          std::bind(&server::handle_control_request_timer, this,\n            socket, request, delay_timer));\n    }\n  }\n\n  void handle_control_request_timer(tcp_socket_ptr socket,\n      control_request_ptr request, timer_ptr /*delay_timer*/)\n  {\n    boost::system::error_code ec;\n    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);\n    if (!ec)\n    {\n      if (unsigned short old_port = request->old_port())\n      {\n        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);\n        subscribers_.erase(old_endpoint);\n      }\n\n      if (unsigned short new_port = request->new_port())\n      {\n        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);\n        subscribers_.insert(new_endpoint);\n      }\n    }\n\n    boost::asio::async_read(*socket, request->to_buffers(),\n        std::bind(&server::handle_control_request, this,\n          boost::asio::placeholders::error, socket, request));\n  }\n\n  void handle_timer()\n  {\n    double x = next_frame_number_ * 0.2;\n    double y = std::sin(x);\n    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));\n    std::string payload;\n    for (int i = 0; i < frame::payload_size; ++i)\n      payload += (i == char_index ? '*' : '.');\n\n    frame f(next_frame_number_++, payload);\n\n    std::set<udp::endpoint>::iterator j;\n    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)\n    {\n      boost::system::error_code ec;\n      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);\n    }\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\nprivate:\n  tcp::acceptor acceptor_;\n  boost::asio::steady_timer timer_;\n  udp::socket udp_socket_;\n  unsigned long next_frame_number_;\n  std::set<udp::endpoint> subscribers_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n#include <memory>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\nclass server {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n          timer_(io_context),\n          udp_socket_(io_context, udp::endpoint(udp::v4(), 0)) {}\n\n    void start_accept() {\n        auto socket = std::make_shared<tcp::socket>(acceptor_.get_executor().context());\n        acceptor_.async_accept(*socket, [this, socket](const boost::system::error_code& ec) {\n            handle_accept(ec, socket);\n        });\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n        if (!ec) {\n            // Handle TCP connection\n            auto request = std::make_shared<control_request>();\n            read_control_request(*socket, request, [this, socket, request]() {\n                handle_control_request(socket, request);\n            });\n        }\n        start_accept();\n    }\n\n    void handle_control_request(tcp_socket_ptr socket, control_request_ptr request) {\n        // Process control request\n        if (request->type == \"subscribe\") {\n            subscribers_.insert(request->endpoint);\n        } else if (request->type == \"unsubscribe\") {\n            subscribers_.erase(request->endpoint);\n        }\n    }\n\n    void broadcast_frame() {\n        std::string frame = create_data_frame(next_frame_number_++);\n        for (auto& endpoint : subscribers_) {\n            udp_socket_.async_send_to(asio::buffer(frame), endpoint, [](const boost::system::error_code& /*ec*/, std::size_t /*bytes_sent*/) {});\n        }\n    }\n\nprivate:\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_ = 0;\n    std::set<udp::endpoint> subscribers_;\n\n    void read_control_request(tcp::socket& socket, control_request_ptr request, std::function<void()> callback) {\n        // Read control request from socket\n        asio::read(socket, asio::buffer(&request->type, sizeof(request->type)));\n        asio::read(socket, asio::buffer(&request->endpoint, sizeof(request->endpoint)));\n        callback();\n    }\n\n    std::string create_data_frame(unsigned long frame_number) {\n        return \"Frame \" + std::to_string(frame_number);\n    }\n};\n```"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Implement a class for handling HTTP file downloads using libcurl in C++. The class should support URL downloading with retries, temporary file handling, and proper resource management.\n\nClass Description: The DownloadTask class provides functionality to download files from HTTP URLs using libcurl. It handles initialization/cleanup of libcurl, manages download retries, writes data to temporary files, and performs final file operations upon successful download.\n\nAttributes:\n- m_url: [std::string] - Primary URL for file download\n- m_urlBackup: [std::string] - Backup URL if primary fails\n- m_output: [std::string] - Final output file path\n- m_outputTmp: [std::string] - Temporary file path during download\n- m_default: [std::string] - Default file path if download fails\n- m_mtime: [time_t] - Modification time to set on downloaded file\n- m_retries: [unsigned int] - Number of download attempts made\n- m_name: [std::string] - Name identifier for the download task\n- m_userAgent: [std::string] - User agent string for HTTP requests\n- m_error: [std::string] - Last error message encountered\n\nMethods:\n- initialize(): [static void]() -> void - Initializes libcurl global state\n- uninitialize(): [static void]() -> void - Cleans up libcurl global state\n- DownloadTask(): [constructor](const std::string&, const std::string&, const std::string&, time_t, const std::string&) -> DownloadTask - Constructs a download task with URL, output path, default file, modification time, and optional name\n- run(): [bool]() -> bool - Executes the download task and returns success status\n- getRetries(): [unsigned int]() -> unsigned int - Returns number of retry attempts\n- writeData(): [size_t](void*, size_t, size_t) -> size_t - Callback for writing received data\n- downloadFile(): [bool](const std::string&) -> bool - Internal method to perform the actual file download",
    "Canonical_solution": "#include <curl/curl.h>\n#include <vector>\n#include <string>\n#include <utility>\n\nclass DownloadTask\n{\npublic:\n    DownloadTask(const std::string &url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\");\n    \n    static void initialize();\n    static void uninitialize();\n    \n    bool run();\n    unsigned int getRetries() const;\n    size_t writeData(void *buffer, size_t size, size_t nmemb);\n    \nprivate:\n    bool downloadFile(const std::string& url);\n    \n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n};\n\nsize_t writeTaskHttpData(void *buffer, size_t size, size_t nmemb, void *user_p)\n{\n    DownloadTask *task = reinterpret_cast<DownloadTask *>(user_p);\n    if (NULL != task)\n    {\n        return task->writeData(buffer, size, nmemb);\n    }\n    \n    return 0;\n}\n\nvoid DownloadTask::initialize()\n{\n    curl_global_init(CURL_GLOBAL_ALL);\n}\n\nvoid DownloadTask::uninitialize()\n{\n    curl_global_cleanup();\n}\n\nbool DownloadTask::downloadFile(const std::string& url)\n{\n    ++m_retries;\n    \n    m_outputTmp = m_output + \".tmp\";\n    deleteFile(m_outputTmp);\n\n    CURLcode res = CURLE_OK;\n    CURL *curl = NULL;\n    \n    std::string userAgent = m_userAgent.empty() ? \"WeChat/7.0.15.33 CFNetwork/978.0.7 Darwin/18.6.0\" : m_userAgent;\n    \n    curl = curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_USERAGENT, userAgent.c_str());\n    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);\n    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 60);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &::writeTaskHttpData);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, true);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0);\n\n    long httpStatus = 0;\n    res = curl_easy_perform(curl);\n    if (res != CURLE_OK)\n    {\n        m_error = \"Failed \" + m_name + \"\\r\\n\";\n        m_error += curl_easy_strerror(res);\n    }\n    else\n    {\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n    }\n    curl_easy_cleanup(curl);\n    \n    if (res == CURLE_OK && httpStatus == 200)\n    {\n        ::moveFile(m_outputTmp, m_output);\n        if (m_mtime > 0)\n        {\n            updateFileTime(m_output, m_mtime);\n        }\n        return true;\n    }\n\n    if (m_error.empty())\n    {\n        m_error = \"HTTP Status:\" + std::to_string(httpStatus);\n    }\n    return false;\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <curl/curl.h>\n\nclass DownloadTask {\npublic:\n    static void initialize() { curl_global_init(CURL_GLOBAL_DEFAULT); }\n    static void uninitialize() { curl_global_cleanup(); }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultPath, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_urlBackup(\"\"), m_output(output), m_outputTmp(\"/tmp/download.tmp\"), m_default(defaultPath), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"libcurl-agent/1.0\"), m_error(\"\") {}\n\n    bool run() {\n        for (m_retries = 0; m_retries <= 3; ++m_retries) {\n            if (downloadFile(m_url)) {\n                rename(m_outputTmp.c_str(), m_output.c_str());\n                struct utimbuf times;\n                times.actime = times.modtime = m_mtime;\n                utime(m_output.c_str(), &times);\n                return true;\n            } else if (!m_urlBackup.empty()) {\n                m_url = m_urlBackup;\n            } else {\n                break;\n            }\n        }\n        if (!m_default.empty()) {\n            rename(m_default.c_str(), m_output.c_str());\n            return true;\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const { return m_retries; }\n\nprivate:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    size_t writeData(void* ptr, size_t size, size_t nmemb) {\n        FILE* fp = fopen(m_outputTmp.c_str(), \"ab\");\n        if (!fp) {\n            m_error = \"Failed to open temporary file\";\n            return 0;\n        }\n        fwrite(ptr, size, nmemb, fp);\n        fclose(fp);\n        return size * nmemb;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl;\n        CURLcode res;\n        curl = curl_easy_init();\n        if(curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n            res = curl_easy_perform(curl);\n            if(res != CURLE_OK) {\n                m_error = std::string(curl_easy_strerror(res));\n                curl_easy_cleanup(curl);\n                return false;\n            }\n            curl_easy_cleanup(curl);\n            return true;\n        }\n        m_error = \"Failed to initialize libcurl\";\n        return false;\n    }\n};\n```"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, process incoming messages, and echo messages back to clients. The server should also support stopping the listening process upon receiving a specific command.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, managing connection handling, message processing, and server lifecycle operations.\n\nAttributes:\n- service_: [asio::io_service&] - Reference to the ASIO I/O service used for network operations\n- port_: [int] - The port number on which the server listens for connections\n- ws_server_: [ws_echo_server] - The WebSocket++ server instance\n\nMethods:\n- Constructor: [WebSocketServer]([asio::io_service& service, int port]) -> [void] - Initializes the WebSocket++ server, sets up logging, message handling, and starts listening on the specified port\n- on_message: [on_message]([websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg]) -> [void] - Callback function that processes incoming messages, echoes them back to clients, and handles the stop-listening command\n- run: [run]() -> [void] - Starts the server's event loop to handle connections and messages",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) \n        : service_(service), port_(port) {\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        if (msg->get_payload() == \"stop-listening\") {\n            ws_server_.stop_listening();\n            return;\n        }\n\n        try {\n            ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port)\n        : service_(service), port_(port) {\n        ws_server_.init_asio(&service_);\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"stop\") {\n            ws_server_.stop_listening();\n        } else {\n            ws_server_.send(hdl, payload, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        try {\n            ws_server_.listen(port_);\n            ws_server_.start_accept();\n            service_.run();\n        } catch (const std::exception & e) {\n            std::cerr << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};\n```"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication\n- m_connections: [con_list (std::set<connection_hdl>)] - A set of active client connections\n\nMethods:\n- broadcast_server() - [Constructor] -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events\n- on_open(connection_hdl hdl) -> [void] - Handles new client connections by adding them to the connection set\n- on_close(connection_hdl hdl) -> [void] - Handles client disconnections by removing them from the connection set\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by broadcasting them to all connected clients\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n        m_server.set_open_handler(websocketpp::lib::bind(&broadcast_server::on_open, this, websocketpp::lib::placeholders::_1));\n        m_server.set_close_handler(websocketpp::lib::bind(&broadcast_server::on_close, this, websocketpp::lib::placeholders::_1));\n        m_server.set_message_handler(websocketpp::lib::bind(&broadcast_server::on_message, this, websocketpp::lib::placeholders::_1, websocketpp::lib::placeholders::_2));\n    }\n\n    void on_open(server::connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(server::connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(server::connection_hdl hdl, server::message_ptr msg) {\n        for(auto it = m_connections.begin(); it != m_connections.end(); ++it) {\n            if(*it == hdl) continue;\n            m_server.send(*it, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    std::set<server::connection_hdl> m_connections;\n};\n```"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections, process incoming messages, and support configurable threading for concurrent operations.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server implementation, providing methods to initialize, configure, and run the server with customizable port and threading settings.\n\nAttributes:\n- testee_server_: [server] - The WebSocket++ server instance that manages connections and message handling\n- port_: [short] - The port number on which the server listens for incoming connections\n- num_threads_: [size_t] - The number of threads to use for handling connections (1 for single-threaded mode)\n\nMethods:\n- WebSocketServer([short port = 9002], [size_t num_threads = 1]) -> [void] - Constructor that initializes the server with specified port and thread count (defaults to port 9002 and single-threaded)\n- run() -> [void] - Starts the WebSocket server, sets up message handlers, begins listening on the specified port, and manages the server's event loop(s)\n- on_message([websocketpp::connection_hdl hdl], [message_ptr msg]) -> [void] - Message handler that echoes received messages back to the client (private method)\n- on_socket_init([websocketpp::connection_hdl hdl], [boost::asio::ip::tcp::socket & s]) -> [void] - Socket initialization handler that enables TCP_NODELAY for reduced latency (private method)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/extensions/permessage_deflate/enabled.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <websocketpp/common/thread.hpp>\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::message_ptr message_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) \n        : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        try {\n            testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n            testee_server_.clear_error_channels(websocketpp::log::alevel::all);\n\n            testee_server_.init_asio();\n            testee_server_.set_reuse_addr(true);\n\n            testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n            testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, ::_1, ::_2));\n\n            testee_server_.set_listen_backlog(8192);\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n\n            if (num_threads_ == 1) {\n                testee_server_.run();\n            } else {\n                std::vector<websocketpp::lib::shared_ptr<websocketpp::lib::thread>> ts;\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts.push_back(websocketpp::lib::make_shared<websocketpp::lib::thread>(&server::run, &testee_server_));\n                }\n\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts[i]->join();\n                }\n            }\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket & s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) : testee_server_(), port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        testee_server_.init_asio();\n        testee_server_.set_access_channels(websocketpp::log::alevel::all);\n        testee_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, ::_1, ::_2));\n\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ > 1) {\n            testee_server_.run(num_threads_);\n        } else {\n            testee_server_.run();\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket & s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};\n```"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage sessions, and process incoming messages.\n\nClass Description: The `print_server` class implements a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: int - Tracks the next available session ID to assign to new connections.\n- m_server: server - The WebSocket++ server instance configured with custom connection data.\n\nMethods:\n- print_server() - Constructor - Initializes the server with ASIO, sets up handlers for connection open, close, and message events.\n- on_open(connection_hdl hdl) -> void - Handler for new connections. Assigns a session ID to the new connection.\n- on_close(connection_hdl hdl) -> void - Handler for connection closures. Logs the connection's name and session ID.\n- on_message(connection_hdl hdl, server::message_ptr msg) -> void - Handler for incoming messages. Sets the connection name if not set, otherwise logs the message along with the connection's name and session ID.\n- run(uint16_t port) -> void - Starts the server listening on the specified port, begins accepting connections, and runs the event loop.",
    "Canonical_solution": "#include <iostream>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nstruct custom_config : public websocketpp::config::asio {\n    typedef websocketpp::config::asio core;\n    typedef core::concurrency_type concurrency_type;\n    typedef core::request_type request_type;\n    typedef core::response_type response_type;\n    typedef core::message_type message_type;\n    typedef core::con_msg_manager_type con_msg_manager_type;\n    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;\n    typedef core::alog_type alog_type;\n    typedef core::elog_type elog_type;\n    typedef core::rng_type rng_type;\n    typedef core::transport_type transport_type;\n    typedef core::endpoint_base endpoint_base;\n    typedef connection_data connection_base;\n};\n\ntypedef websocketpp::server<custom_config> server;\ntypedef server::connection_ptr connection_ptr;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->sessionid = m_next_sessionid++;\n    }\n    \n    void on_close(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Closing connection \" << con->name \n                  << \" with sessionid \" << con->sessionid << std::endl;\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        \n        if (con->name.empty()) {\n            con->name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \" \n                      << con->sessionid << \" to \" << con->name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << con->name \n                      << \" with sessionid \" << con->sessionid << std::endl;\n        }\n    }\n    \n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass print_server {\nprivate:\n    int m_next_sessionid;\n    server m_server;\n\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, ::_1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, ::_1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, ::_1, ::_2));\n    }\n\n    void on_open(server::connection_hdl hdl) {\n        std::shared_ptr<server::connection> con = m_server.get_con_from_hdl(hdl);\n        con->set_user_value(m_next_sessionid++);\n        std::cout << \"Open connection \" << con->get_user_value() << std::endl;\n    }\n\n    void on_close(server::connection_hdl hdl) {\n        std::shared_ptr<server::connection> con = m_server.get_con_from_hdl(hdl);\n        std::string name = static_cast<std::string>(con->get_user_value());\n        std::cout << \"Close connection \" << name << \" (\" << con->get_user_value() << \")\" << std::endl;\n    }\n\n    void on_message(server::connection_hdl hdl, server::message_ptr msg) {\n        std::shared_ptr<server::connection> con = m_server.get_con_from_hdl(hdl);\n        if (!con->get_name().empty()) {\n            std::cout << con->get_name() << \": \" << msg->get_payload() << std::endl;\n        } else {\n            con->set_name(msg->get_payload());\n            std::cout << \"Connection \" << con->get_user_value() << \" named \" << con->get_name() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};\n```"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\n\nstruct connection_data {\n    int session_id;\n    std::string name;\n};\n\nclass print_server {\nprivate:\n    int m_next_sessionid = 0;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n\npublic:\n    print_server() {\n        m_server.init_asio();\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, ::_1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, ::_1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, ::_1, ::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"Client\" + std::to_string(data.session_id);\n        m_connections[hdl] = data;\n        std::cout << \"Connection opened: Session ID \" << data.session_id << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto data = get_data_from_hdl(hdl);\n        std::cout << \"Connection closed: Session ID \" << data.session_id << std::endl;\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            auto data = get_data_from_hdl(hdl);\n            if (data.name.empty()) {\n                data.name = msg->get_payload();\n                m_connections[hdl] = data;\n                std::cout << \"Client \" << data.session_id << \" named themselves as \" << data.name << std::endl;\n            } else {\n                std::cout << \"Message from \" << data.name << \": \" << msg->get_payload() << std::endl;\n            }\n        } catch (...) {\n            std::cerr << \"Error processing message\" << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::runtime_error(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};\n```"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication.\n- m_connections: [con_list] - A set of active connection handles to keep track of connected clients.\n\nMethods:\n- broadcast_server(): [Constructor]() -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events (open, close, message).\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handler for new client connections; adds the connection handle to the active connections set.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handler for client disconnections; removes the connection handle from the active connections set.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Handler for incoming messages; broadcasts the received message to all connected clients.\n- run: [void]([uint16_t port]) -> [void] - Starts the server, begins listening on the specified port, and enters the event loop to handle connections and messages.",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n                \n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n    \n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass broadcast_server {\nprivate:\n    server m_server;\n    std::set<server::connection_hdl> m_connections;\n\npublic:\n    broadcast_server() {\n        // Initialize Asio transport policy\n        m_server.init_asio();\n\n        // Register handler callbacks\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void on_open(server::connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(server::connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(server::connection_hdl hdl, server::message_ptr msg) {\n        for (auto& connection : m_connections) {\n            if (connection != hdl) {\n                m_server.send(connection, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        try {\n            m_server.listen(port);\n            m_server.start_accept();\n            m_server.run();\n        } catch (const std::exception & e) {\n            std::cerr << \"Exception: \" << e.what() << \"\\n\";\n        }\n    }\n};\n```"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections and echo back received messages.\n\nClass Description: The utility_server class encapsulates a WebSocket server that listens for incoming connections, receives messages from clients, and echoes them back. It uses WebSocket++ with ASIO for network handling.\n\nAttributes:\n- m_endpoint: [server] - The WebSocket++ server instance that manages connections and message handling.\n\nMethods:\n- utility_server() - [Constructor] -> [void] - Initializes the server with logging settings, ASIO, and sets up the message handler.\n- echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by echoing them back to the client.\n- run() -> [void] - Starts the server, begins listening on port 9002, and runs the ASIO event loop.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <functional>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n         // Set logging settings\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all ^ websocketpp::log::alevel::frame_payload);\n\n        // Initialize Asio\n        m_endpoint.init_asio();\n\n        // Set the default message handler to the echo handler\n        m_endpoint.set_message_handler(std::bind(\n            &utility_server::echo_handler, this,\n            std::placeholders::_1, std::placeholders::_2\n        ));\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        // write a new message\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        // Listen on port 9002\n        m_endpoint.listen(9002);\n\n        // Queues a connection accept operation\n        m_endpoint.start_accept();\n\n        // Start the Asio io_service run loop\n        m_endpoint.run();\n    }\nprivate:\n    server m_endpoint;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        // Initialize Asio transport policy\n        m_endpoint.init_asio();\n        \n        // Set logging policies\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        \n        // Register the message handler\n        m_endpoint.set_message_handler(bind(&utility_server::echo_handler, this, ::_1, ::_2));\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        // Listen on port 9002\n        m_endpoint.listen(9002);\n        \n        // Start accepting connections\n        m_endpoint.start_accept();\n        \n        // Run the ASIO event loop\n        m_endpoint.run();\n    }\nprivate:\n    server m_endpoint;\n};\n```"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ using the WebSocket++ library to handle client connections, process incoming messages, and manage server events.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, providing methods to initialize, configure, and run the server. It handles WebSocket connections, processes messages, and manages various server events like HTTP requests, connection failures, and closures.\n\nAttributes:\n- m_server: [websocketpp::server<websocketpp::config::debug_asio>] - The main WebSocket++ server instance that manages connections and events.\n\nMethods:\n- WebSocketServer() -> [Constructor] - Initializes the server with default settings, configures logging, sets up ASIO, and registers event handlers.\n- run(int port) -> [void] - Starts the server on the specified port, begins accepting connections, and runs the event loop.\n- validate(websocketpp::connection_hdl hdl) -> [bool] - Validates incoming connections (always returns true in this implementation).\n- on_http(websocketpp::connection_hdl hdl) -> [void] - Handles HTTP requests received by the server.\n- on_fail(websocketpp::connection_hdl hdl) -> [void] - Handles connection failure events.\n- on_close(websocketpp::connection_hdl hdl) -> [void] - Handles connection closure events.\n- on_message(websocketpp::connection_hdl hdl, message_ptr msg) -> [void] - Processes incoming WebSocket messages and echoes them back to the client.",
    "Canonical_solution": "#include <websocketpp/config/debug_asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/logger/syslog.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass WebSocketServer {\npublic:\n    typedef websocketpp::server<websocketpp::config::debug_asio> server;\n    typedef server::message_ptr message_ptr;\n\n    WebSocketServer() {\n        // Set logging settings\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        // Initialize ASIO\n        m_server.init_asio();\n        m_server.set_reuse_addr(true);\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, ::_1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, ::_1));\n        m_server.set_validate_handler(bind(&WebSocketServer::validate, this, ::_1));\n    }\n\n    void run(int port) {\n        try {\n            // Listen on specified port\n            m_server.listen(port);\n\n            // Start the server accept loop\n            m_server.start_accept();\n\n            // Start the ASIO io_service run loop\n            m_server.run();\n        } catch (websocketpp::exception const & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::string res = con->get_request_body();\n        std::stringstream ss;\n        ss << \"got HTTP request with \" << res.size() << \" bytes of body data.\";\n        con->set_body(ss.str());\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Fail handler: \" << con->get_ec() << \" \" << con->get_ec().message() << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Close handler\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \" \n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\nprivate:\n    server m_server;\n\npublic:\n    WebSocketServer() {\n        // Initialize the server\n        m_server.init_asio();\n\n        // Set logging to console for all levels\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        m_server.set_error_channels(websocketpp::log::elevel::all);\n\n        // Register handler callbacks\n        m_server.set_validate_handler(bind(&WebSocketServer::validate, this, ::_1));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, ::_1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, ::_1));\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1));\n    }\n\n    void run(int port) {\n        // Listen on the specified port\n        m_server.listen(port);\n\n        // Start accepting connections\n        m_server.start_accept();\n\n        // Run the server's event loop\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string response = \"Echo: \" + msg->get_payload();\n        m_server.send(hdl, response, websocketpp::frame::opcode::text);\n    }\n};\n```"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that supports secure TLS connections and handles both WebSocket and HTTP requests.\n\nClass Description: The WebSocketServer class encapsulates a secure WebSocket server implementation using WebSocket++ with ASIO and TLS support. It handles incoming connections, processes messages, and manages secure communication settings.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that manages connections and communication\n- tls_mode: [enum] - Enumeration defining TLS security modes (MOZILLA_INTERMEDIATE, MOZILLA_MODERN)\n\nMethods:\n- WebSocketServer() -> [constructor] - Initializes the server, sets up ASIO, and registers handler functions\n- run([int port]) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_message([websocketpp::connection_hdl hdl, message_ptr msg]) -> [void] - Handles incoming WebSocket messages by echoing them back to the client\n- on_http([websocketpp::connection_hdl hdl]) -> [void] - Handles HTTP requests by returning a simple \"Hello World!\" response\n- get_password() -> [std::string] - Returns the password used for TLS certificate encryption\n- on_tls_init([tls_mode mode, websocketpp::connection_hdl hdl]) -> [context_ptr] - Initializes and configures TLS/SSL context with appropriate security settings based on the specified mode",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/lib/asio.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\ntypedef websocketpp::config::asio::message_type::ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        // Initialize ASIO\n        m_server.init_asio();\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, MOZILLA_INTERMEDIATE, ::_1));\n    }\n\n    void run(int port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start the server accept loop\n        m_server.start_accept();\n\n        // Start the ASIO io_service run loop\n        m_server.run();\n    }\n\nprivate:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE = 1,\n        MOZILLA_MODERN = 2\n    };\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        namespace asio = websocketpp::lib::asio;\n\n        context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_MODERN) {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::no_tlsv1 |\n                                 asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::single_dh_use);\n            }\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dh.pem\");\n            \n            std::string ciphers = (mode == MOZILLA_MODERN) ? \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\" : \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\";\n            \n            if (SSL_CTX_set_cipher_list(ctx->native_handle(), ciphers.c_str()) != 1) {\n                std::cout << \"Error setting cipher list\" << std::endl;\n            }\n        } catch (std::exception& e) {\n            std::cout << \"Exception: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\nusing namespace websocketpp;\nusing namespace websocketpp::lib;\n\ntypedef server<config::asio> server_type;\ntypedef server_type::message_ptr message_ptr;\ntypedef server_type::connection_hdl connection_hdl;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode { MOZILLA_INTERMEDIATE, MOZILLA_MODERN };\n\nprivate:\n    server_type m_server;\n    tls_mode m_tls_mode;\n\npublic:\n    WebSocketServer(tls_mode mode) : m_tls_mode(mode) {\n        m_server.init_asio();\n        m_server.set_access_channels(log::alevel::all);\n        m_server.clear_access_channels(log::alevel::frame_payload);\n\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, ::_1, ::_2));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), frame::opcode::text);\n    }\n\n    void on_http(connection_hdl hdl) {\n        http::response res(http::status::ok, http::version::http11);\n        res.set(http::field::content_type, \"text/plain\");\n        res.keep_alive(true);\n        res.body() = \"Hello World!\";\n        m_server.send(hdl, res.to_string());\n    }\n\n    std::string get_password() {\n        return \"password\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, connection_hdl hdl) {\n        context_ptr ctx = m_server.get_context();\n        switch (mode) {\n            case MOZILLA_INTERMEDIATE:\n                ctx.set_options(context_base::options::default_workarounds |\n                               context_base::options::no_sslv2 | context_base::options::no_sslv3 |\n                               context_base::options::single_dh_use);\n                break;\n            case MOZILLA_MODERN:\n                ctx.set_options(context_base::options::default_workarounds |\n                               context_base::options::no_sslv2 | context_base::options::no_sslv3 |\n                               context_base::options::no_tlsv1 | context_base::options::no_tlsv1_1 |\n                               context_base::options::single_dh_use);\n                break;\n        }\n        ctx.use_private_key_file(\"path/to/private.key\", context_base::file_format::pem);\n        ctx.use_certificate_chain_file(\"path/to/certificate.crt\", context_base::file_format::pem);\n        ctx.set_password_callback(bind(&WebSocketServer::get_password, this));\n        return ctx;\n    }\n};\n```"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Implement a WebSocket broadcast server in C++ using the WebSocket++ library that can handle multiple client connections, manage subscriptions, and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and can broadcast messages to all connected clients. It handles connection events (open/close) and message events using a thread-safe action queue system.\n\nAttributes:\n- m_server: [server] - WebSocket++ server instance configured with ASIO\n- m_connections: [con_list] - Set of active WebSocket connection handles\n- m_actions: [std::queue<action>] - Queue of pending actions to process\n- m_action_lock: [mutex] - Mutex for protecting access to the action queue\n- m_connection_lock: [mutex] - Mutex for protecting access to the connections set\n- m_action_cond: [condition_variable] - Condition variable for action queue notification\n\nMethods:\n- broadcast_server() -> [constructor] - Initializes the WebSocket server and sets up event handlers\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_open(connection_hdl hdl) -> [void] - Handler for new WebSocket connections (adds SUBSCRIBE action)\n- on_close(connection_hdl hdl) -> [void] - Handler for closed WebSocket connections (adds UNSUBSCRIBE action)\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handler for incoming messages (adds MESSAGE action)\n- process_messages() -> [void] - Processes actions from the queue (manages subscriptions and broadcasts messages)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/thread.hpp>\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\nusing websocketpp::lib::thread;\nusing websocketpp::lib::mutex;\nusing websocketpp::lib::lock_guard;\nusing websocketpp::lib::unique_lock;\nusing websocketpp::lib::condition_variable;\n\nenum action_type {\n    SUBSCRIBE,\n    UNSUBSCRIBE,\n    MESSAGE\n};\n\nstruct action {\n    action(action_type t, connection_hdl h) : type(t), hdl(h) {}\n    action(action_type t, connection_hdl h, server::message_ptr m)\n      : type(t), hdl(h), msg(m) {}\n\n    action_type type;\n    websocketpp::connection_hdl hdl;\n    server::message_ptr msg;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        try {\n            m_server.run();\n        } catch (const std::exception & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\n    void on_open(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(SUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(UNSUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(MESSAGE,hdl,msg));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while(1) {\n            unique_lock<mutex> lock(m_action_lock);\n            while(m_actions.empty()) {\n                m_action_cond.wait(lock);\n            }\n\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.type == SUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.type == UNSUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.type == MESSAGE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                con_list::iterator it;\n                for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n                    m_server.send(*it,a.msg);\n                }\n            }\n        }\n    }\n\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl> > con_list;\n    server m_server;\n    con_list m_connections;\n    std::queue<action> m_actions;\n    mutex m_action_lock;\n    mutex m_connection_lock;\n    condition_variable m_action_cond;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&broadcast_server::on_open, this, ::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, ::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, ::_1, ::_2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        std::thread([this]() { while(true) process_messages(); }).detach();\n        m_server.run();\n    }\n\nprivate:\n    typedef server::connection_hdl connection_hdl;\n    typedef boost::shared_ptr<server::connection> connection_ptr;\n    typedef std::function<void()> action;\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        m_actions.push([this, hdl]() {\n            std::cout << \"Client connected\" << std::endl;\n        });\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        m_actions.push([this, hdl]() {\n            std::cout << \"Client disconnected\" << std::endl;\n        });\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        m_actions.push([this, hdl, payload]() {\n            std::cout << \"Received message: \" << payload << std::endl;\n            broadcast(payload);\n        });\n        m_action_cond.notify_one();\n    }\n\n    void broadcast(const std::string& message) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        for(auto it = m_connections.begin(); it != m_connections.end(); ++it) {\n            if(m_server.is_open(*it)) {\n                m_server.send(*it, message, websocketpp::frame::opcode::text);\n            }\n        }\n    }\n\n    void process_messages() {\n        while(true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this]{ return !m_actions.empty(); });\n            action act = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n            act();\n        }\n    }\n};\n```"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a C++ class that provides HTTP request functionality using libcurl, supporting both file and network resource retrieval.\n\nClass Description: HttpWebRequest is a class that encapsulates HTTP request functionality, allowing users to make GET requests to either network resources (via HTTP) or local files (via file:// protocol). It handles request configuration, execution, and response processing.\n\nAttributes:\n- uri_: std::string - The target URI for the HTTP request\n- method_: std::string - The HTTP method to use (defaults to GET)\n- header_: std::map<std::string, std::string> - HTTP headers to include in the request\n- is_: std::iostream - Internal stream used for request processing\n\nMethods:\n- HttpWebRequest(std::string &uri) -> void - Constructor that initializes the request with a target URI\n- callback(void *buffer, size_t size, size_t nmemb, void *data) -> static size_t - Static callback function for libcurl to write response data\n- GetFileResponse(const char *uri) -> HttpWebResponse* - Handles file:// protocol requests and returns the file content as a response\n- GetNetResponse(const char *uri) -> HttpWebResponse* - Performs HTTP network requests using libcurl and returns the response\n- GetResponse() -> HttpWebResponse* - Main method that determines request type (file or network) and returns the appropriate response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <fstream>\n\nnamespace System {\nnamespace Net {\n\nclass HttpWebRequest {\npublic:\n    HttpWebRequest(std::string &uri)\n        : is_(std::ios_base::in | std::ios_base::out | std::ios_base::binary) {\n        uri_ = uri;\n        method_ = HttpWebRequest::Method::GET;\n    }\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        HttpWebResponse *resp = (HttpWebResponse *) data;\n        std::stringstream &ss = resp->GetResponseStream();\n        ss.write((char *) buffer, size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse *GetFileResponse(const char *uri) {\n        assert(strlen(uri) > 6);\n        HttpWebResponse *resp = new HttpWebResponse();\n        const char *filename = uri + 6;\n\n        std::ifstream file;\n        file.open(filename);\n        if (file.is_open()) {\n            resp->os_ << file.rdbuf();\n            file.close();\n        }\n\n        return resp;\n    }\n\n    HttpWebResponse *GetNetResponse(const char *uri) {\n        HttpWebResponse *resp = new HttpWebResponse();\n\n        CURL *curl = curl_easy_init();\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n\n        curl_slist *http_headers = NULL;\n        for (std::map<std::string, std::string>::iterator it = header_.begin();\n             it != header_.end(); it++) {\n            http_headers = curl_slist_append(http_headers,\n                                             (it->first + \":\" + it->second).c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, http_headers);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) resp);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 2);\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 2);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\n        curl_easy_perform(curl);\n\n        long retcode = 0;\n        CURLcode code = curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &retcode);\n        if (code == CURLE_OK && retcode == 200) {\n            resp->status_.SetCode(200);\n\n            char *ctype = NULL;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &ctype);\n            std::string type(ctype);\n            resp->header_.Put(HttpHeader::ContentType, type);\n\n            double length = 0;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &length);\n            std::ostringstream os;\n            os << (long) length;\n            resp->header_.Put(HttpHeader::ContentLength, os.str());\n        }\n\n        curl_slist_free_all(http_headers);\n        curl_easy_cleanup(curl);\n\n        return resp;\n    }\n\n    HttpWebResponse *GetResponse() {\n        const char *uri = uri_.c_str();\n        if (strncmp(uri, \"file://\", 7) == 0) {\n            return GetFileResponse(uri);\n        }\n        return GetNetResponse(uri);\n    }\n\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n};\n\n}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "```cpp\n#include <iostream>\n#include <map>\n#include <string>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    std::string body;\n    int statusCode;\n\n    HttpWebResponse(std::string body, int statusCode) : body(body), statusCode(statusCode) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_ = \"GET\";\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        ((std::string*)data)->append((char*)buffer, size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        std::ifstream file(uri, std::ios::binary);\n        if (!file.is_open()) {\n            return new HttpWebResponse(\"\", 404);\n        }\n        std::ostringstream oss;\n        oss << file.rdbuf();\n        file.close();\n        return new HttpWebResponse(oss.str(), 200);\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl;\n        CURLcode res;\n        std::string readBuffer;\n\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n        if(curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, uri);\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n            res = curl_easy_perform(curl);\n            long http_code = 0;\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n            curl_easy_cleanup(curl);\n            curl_global_cleanup();\n            if(res != CURLE_OK) {\n                return new HttpWebResponse(\"\", http_code);\n            }\n            return new HttpWebResponse(readBuffer, http_code);\n        }\n        return nullptr;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri) {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str() + 7);\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};\n```"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ that supports both plain and TLS (SSL) connections using the WebSocket++ library. The server should handle incoming messages, echo them back to clients, and manage secure connections with proper TLS initialization.\n\nClass Description: The WebSocketServer class encapsulates functionality for creating and managing both plain and TLS WebSocket servers. It initializes server endpoints, sets up message handlers, manages TLS contexts, and runs the server's event loop.\n\nAttributes:\n- ios_: boost::asio::io_service - ASIO I/O service for handling network operations\n- endpoint_plain_: server_plain - WebSocket++ server instance for plain (non-secure) connections\n- endpoint_tls_: server_tls - WebSocket++ server instance for TLS (secure) connections\n\nMethods:\n- init() -> void - Initializes both plain and TLS server endpoints, sets message handlers, TLS initialization handler, and starts listening on ports 80 (plain) and 443 (TLS)\n- run() -> void - Starts the server's event loop to handle connections and messages\n- on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) -> void - Template method that handles incoming messages from clients and echoes them back\n- get_password() -> std::string - Returns the password used for TLS private key encryption\n- on_tls_init(websocketpp::connection_hdl hdl) -> context_ptr - Initializes and configures the TLS context for secure connections",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(), endpoint_tls_() {}\n\n    void init() {\n        endpoint_plain_.init_asio(&ios_);\n        endpoint_plain_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, ::_1, ::_2));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.init_asio(&ios_);\n        endpoint_tls_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, ::_1, ::_2));\n        endpoint_tls_.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, ::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\nprivate:\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl,\n        typename EndpointType::message_ptr msg)\n    {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                << \" and message: \" << msg->get_payload()\n                << std::endl;\n\n        try {\n            s->send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                    << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        std::cout << \"on_tls_init called with hdl: \" << hdl.lock().get() << std::endl;\n        context_ptr ctx(new boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                            boost::asio::ssl::context::no_sslv2 |\n                            boost::asio::ssl::context::no_sslv3 |\n                            boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "right_result": "```cpp\n#include <websocketpp/config/asio_no_tls_client.hpp>\n#include <websocketpp/server.hpp>\n\nusing namespace websocketpp;\ntypedef server<config::asio> server_plain;\ntypedef server<config::asio_tls> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(boost::asio::io_service& ios)\n        : ios_(ios),\n          endpoint_plain_(),\n          endpoint_tls_()\n    {}\n\n    void init() {\n        // Initialize plain server\n        endpoint_plain_.init_asio(&ios_);\n        endpoint_plain_.set_message_handler(bind(\n            &WebSocketServer::on_message<server_plain>, this,\n            &endpoint_plain_, ::placeholders::_1, ::placeholders::_2));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // Initialize TLS server\n        endpoint_tls_.init_asio(&ios_);\n        endpoint_tls_.set_message_handler(bind(\n            &WebSocketServer::on_message<server_tls>, this,\n            &endpoint_tls_, ::placeholders::_1, ::placeholders::_2));\n        endpoint_tls_.set_tls_init_handler(bind(\n            &WebSocketServer::on_tls_init, this, ::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\nprivate:\n    template<typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"password\";\n    }\n\n    template<typename EndpointType>\n    typename EndpointType::context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_private_key_file(\"path/to/private/key.pem\", boost::asio::ssl::context::pem);\n            ctx->use_certificate_chain_file(\"path/to/certificate.pem\");\n            ctx->set_password_callback(std::bind(&WebSocketServer::get_password, this));\n        } catch (std::exception& e) {\n            // Handle exceptions\n        }\n        return ctx;\n    }\n\n    boost::asio::io_service& ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};\n```"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Implement a function that demonstrates inter-process communication between a parent and child process using pipes in C++. The function should create a pipe, fork a child process, and have the parent process write data to the pipe while the child process reads and displays the data.\n\nFunction Description: The function `pipe_communication` sets up a pipe for communication between a parent and child process. The parent process writes a string to the pipe, and the child process reads and prints the data. The function handles pipe creation, process forking, and proper cleanup of file descriptors.\n\nInput: None\n\nOutput: None (The function prints messages to stdout indicating the progress and results of the pipe communication:\n- \"pipe create error\" if pipe creation fails\n- \"Read data from the pipe is [data]\" from the child process\n- \"Write data [data]\" and \"Parent write over\" from the parent process\n- \"parent close fd[1] over\" when parent completes cleanup)",
    "Canonical_solution": "#include <unistd.h>\n#include <stdio.h>\n#include <cstring>\n#include <cstdlib>\n\nvoid pipe_communication() {\n    int pipe_fd[2];\n    pid_t pid;\n\n    char r_buf[4];\n    char w_buf[100];\n    memset(r_buf,0,sizeof(r_buf));\n    memset(w_buf,0,sizeof(w_buf));\n    int r_num;\n\n    if(pipe(pipe_fd)<0) {\n        printf(\"pipe create error\\n\");\n        return;\n    }\n\n    if((pid=fork())==0) {\n        printf(\"\\n\");\n        close(pipe_fd[1]);\n        sleep(5);\n        while((r_num=read(pipe_fd[0],r_buf,4))!=0)\n            printf(\"Read data from the pipe is %s\\n\", r_buf);\n\n        close(pipe_fd[0]);\n        exit(0);\n    }\n    else if(pid>0) {\n        close(pipe_fd[0]);\n        const char* content = \"1111222233334444\";\n        strncpy(w_buf, content, strlen(content));\n        if(write(pipe_fd[1],w_buf, strlen(content))!=-1) {\n            printf(\"Write data %s\\n\", w_buf);\n            printf(\"Parent write over\\n\");\n        }\n        close(pipe_fd[1]);\n        printf(\"parent close fd[1] over\\n\");\n        wait(&pid);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 155,
    "right_result": "```cpp\n#include <iostream>\n#include <unistd.h>\n#include <cstring>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    char buffer[100];\n\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    } else if (pid == 0) {\n        // Child process\n        close(pipefd[1]); // Close write end\n        read(pipefd[0], buffer, sizeof(buffer));\n        std::cout << \"Read data from the pipe is [\" << buffer << \"]\" << std::endl;\n        close(pipefd[0]);\n    } else {\n        // Parent process\n        close(pipefd[0]); // Close read end\n        const char* message = \"Hello from parent\";\n        write(pipefd[1], message, strlen(message) + 1);\n        std::cout << \"Write data [\" << message << \"]\" << std::endl;\n        sleep(1); // Wait for child to finish reading\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n    }\n}\n\nint main() {\n    pipe_communication();\n    return 0;\n}\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Implement a multi-threaded HTTP download manager using libcurl in C++ that can handle multiple download tasks concurrently, avoid duplicate downloads, and manage resources efficiently.\n\nClass Description: The DownloadPool class manages a pool of worker threads that process download tasks. Each task downloads a file from a given URL and saves it to a specified output path. The class ensures thread safety and prevents duplicate downloads.\n\nAttributes:\n- m_threads: std::vector<std::thread> - Collection of worker threads\n- m_queue: std::queue<Task> - Queue of pending download tasks\n- m_urls: std::unordered_set<std::string> - Set of unique task identifiers to prevent duplicates\n- m_mtx: std::mutex - Mutex for thread synchronization\n- m_noMoreTask: bool - Flag indicating no more tasks will be added\n\nMethods:\n- DownloadPool() -> void - Constructor initializes libcurl and creates worker threads\n- ~DownloadPool() -> void - Destructor cleans up libcurl resources\n- addTask(const std::string& url, const std::string& output) -> void - Adds a new download task if not already present\n- setNoMoreTask() -> void - Signals that no more tasks will be added\n- finishAndWaitForExit() -> void - Waits for all threads to complete current tasks\n- run() -> void - Worker thread function that processes tasks from the queue\n\nTask Class Description: The Task class represents an individual download task with URL and output file path.\n\nAttributes:\n- m_url: std::string - URL to download from\n- m_output: std::string - Local file path to save to\n\nMethods:\n- run() -> void - Executes the download task using libcurl\n- writeData(void* buffer, size_t size, size_t nmemb) -> size_t - Callback function for writing received data to file",
    "Canonical_solution": "#include <curl/curl.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <queue>\n#include <unordered_set>\n\nclass Task\n{\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n    \n    void run()\n    {\n        std::ofstream output(m_output, std::fstream::in | std::fstream::out | std::fstream::trunc);\n        output.close();\n        \n        CURL *curl_handler = curl_easy_init();\n        curl_easy_setopt(curl_handler, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl_handler, CURLOPT_TIMEOUT, 60);\n        curl_easy_setopt(curl_handler, CURLOPT_WRITEFUNCTION, &Task::writeData);\n        curl_easy_setopt(curl_handler, CURLOPT_WRITEDATA, this);\n\n        curl_easy_perform(curl_handler);\n        \n        curl_easy_cleanup(curl_handler);\n    }\n\n    size_t writeData(void *buffer, size_t size, size_t nmemb)\n    {\n        std::ofstream file;\n        file.open(m_output, std::fstream::in | std::fstream::out | std::fstream::app | std::fstream::binary);\n        size_t bytesToWrite = size * nmemb;\n        file.write(reinterpret_cast<const char *>(buffer), bytesToWrite);\n        file.close();\n        \n        return bytesToWrite;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool\n{\npublic:\n    DownloadPool()\n    {\n        m_noMoreTask = false;\n        curl_global_init(CURL_GLOBAL_ALL);\n        \n        for (int idx = 0; idx < 4; idx++)\n        {\n            m_threads.push_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool()\n    {\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string &url, const std::string& output)\n    {\n        std::string uid = url + output;\n        bool existed = false;\n        Task task(url, output);\n        m_mtx.lock();\n        if (!(existed = (m_urls.find(uid) != m_urls.cend())))\n        {\n            m_urls.insert(uid);\n            m_queue.push(task);\n        }\n        m_mtx.unlock();\n    }\n\n    void setNoMoreTask()\n    {\n        m_mtx.lock();\n        m_noMoreTask = true;\n        m_mtx.unlock();\n    }\n\n    void finishAndWaitForExit()\n    {\n        setNoMoreTask();\n        for (auto& thread : m_threads)\n        {\n            thread.join();\n        }\n    }\n\nprivate:\n    void run()\n    {\n        while(true)\n        {\n            bool found = false;\n            Task task;\n            \n            m_mtx.lock();\n            if (!m_queue.empty())\n            {\n                task = m_queue.front();\n                m_queue.pop();\n                found = true;\n            }\n            bool noMoreTask = m_noMoreTask;\n            m_mtx.unlock();\n            \n            if (found)\n            {\n                task.run();\n                continue;\n            }\n            if (noMoreTask)\n            {\n                break;\n            }\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    bool m_noMoreTask;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <curl/curl.h>\n\nclass Task {\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL *curl;\n        FILE *fp;\n        CURLcode res;\n\n        curl = curl_easy_init();\n        if(curl) {\n            fp = fopen(m_output.c_str(), \"wb\");\n            if(!fp)\n                return;\n\n            curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n            res = curl_easy_perform(curl);\n            fclose(fp);\n\n            if(res != CURLE_OK)\n                std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n\n            curl_easy_cleanup(curl);\n        }\n    }\n\nprivate:\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE *stream = (FILE *)userp;\n        if(stream) {\n            fwrite(buffer, 1, realsize, stream);\n        }\n        return realsize;\n    }\n\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool(size_t numThreads) : m_noMoreTask(false) {\n        for(size_t i = 0; i < numThreads; ++i) {\n            m_threads.emplace_back(&DownloadPool::run, this);\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        for(auto& t : m_threads) {\n            t.join();\n        }\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if(m_urls.find(url) == m_urls.end()) {\n            m_urls.insert(url);\n            m_queue.push(Task(url, output));\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n        m_cv.notify_all();\n    }\n\n    void finishAndWaitForExit() {\n        for(auto& t : m_threads) {\n            t.join();\n        }\n    }\n\nprivate:\n    void run() {\n        while(true) {\n            Task task;\n            {\n                std::unique_lock<std::mutex> lock(m_mtx);\n                m_cv.wait(lock, [this]{ return !m_queue.empty() || m_noMoreTask; });\n                if(m_noMoreTask && m_queue.empty())\n                    break;\n                task = m_queue.front();\n                m_queue.pop();\n            }\n            task.run();\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};\n```"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a TCP client class using Boost.Asio that handles asynchronous communication with a chat server, including reading from standard input and writing to standard output.\n\nClass Description: The posix_chat_client class implements an asynchronous TCP client for a chat application. It manages socket connections, handles message reading/writing, and processes user input/output asynchronously using Boost.Asio.\n\nAttributes:\n- socket_: [tcp::socket] - The TCP socket for communication with the server\n- input_: [posix::stream_descriptor] - Handles asynchronous reading from standard input\n- output_: [posix::stream_descriptor] - Handles asynchronous writing to standard output\n- read_msg_: [chat_message] - Stores the message being read from the server\n- write_msg_: [chat_message] - Stores the message to be written to the server\n- input_buffer_: [boost::asio::streambuf] - Buffer for storing input data\n\nMethods:\n- Constructor: [posix_chat_client]([boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints]) -> [void] - Initializes the client with IO context and server endpoints\n- do_connect: [do_connect]([const tcp::resolver::results_type& endpoints]) -> [void] - Asynchronously connects to the server endpoints\n- do_read_header: [do_read_header]() -> [void] - Asynchronously reads the message header from the server\n- do_read_body: [do_read_body]() -> [void] - Asynchronously reads the message body from the server after header is processed\n- do_write_output: [do_write_output]() -> [void] - Asynchronously writes received messages to standard output\n- do_read_input: [do_read_input]() -> [void] - Asynchronously reads input from standard input\n- do_write_message: [do_write_message]() -> [void] - Asynchronously writes the composed message to the server\n- close: [close]() -> [void] - Closes all connections and cleans up resources",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\n#include \"chat_message.hpp\"\nusing boost::asio::ip::tcp;\nnamespace posix = boost::asio::posix;\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO)),\n      input_buffer_(chat_message::max_body_length)\n  {\n    do_connect(endpoints);\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    static char eol[] = { '\\n' };\n    std::array<boost::asio::const_buffer, 2> buffers = {{\n      boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n      boost::asio::buffer(eol) }};\n    boost::asio::async_write(output_, buffers,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            write_msg_.body_length(length - 1);\n            input_buffer_.sgetn(write_msg_.body(), length - 1);\n            input_buffer_.consume(1);\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else if (ec == boost::asio::error::not_found)\n          {\n            write_msg_.body_length(input_buffer_.size());\n            input_buffer_.sgetn(write_msg_.body(), input_buffer_.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  posix::stream_descriptor input_;\n  posix::stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\n\nclass posix_chat_client {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, tcp::endpoint) {\n                if (!ec) {\n                    do_read_header();\n                    do_read_input();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_output() {\n        std::cout.write(read_msg_.data(), read_msg_.total_length());\n        std::cout << \"\\n\";\n        do_read_header();\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, '\\n',\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    std::istream is(&input_buffer_);\n                    std::string line;\n                    std::getline(is, line);\n                    write_msg_.write(line.c_str(), line.size());\n                    do_write_message();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.data(), write_msg_.total_length()),\n            [this](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    do_read_header();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\n    tcp::socket socket_;\n    posix::stream_descriptor input_;\n    posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};\n```"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Implement a TCP client using Boost.Asio for asynchronous network communication, capable of connecting to a server, sending messages, and receiving responses.\n\nClass Description: The `chat_client` class encapsulates a TCP client that manages asynchronous network operations including connection establishment, message reading, and message writing.\n\nAttributes:\n- io_context_: boost::asio::io_context& - Reference to the I/O execution context for asynchronous operations.\n- socket_: tcp::socket - TCP socket for communication with the server.\n- read_msg_: chat_message - Buffer for storing the currently read message.\n- write_msgs_: chat_message_queue - Queue of messages waiting to be sent to the server.\n\nMethods:\n- Constructor: chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints) -> None - Initializes the client with I/O context and server endpoints, then starts the connection process.\n- write: write(const chat_message& msg) -> None - Enqueues a message for asynchronous sending to the server.\n- close: close() -> None - Initiates socket closure to terminate the connection cleanly.\n- do_connect: do_connect(const tcp::resolver::results_type& endpoints) -> None - Asynchronously connects to the server using the provided endpoints.\n- do_read_header: do_read_header() -> None - Asynchronously reads the message header from the server.\n- do_read_body: do_read_body() -> None - Asynchronously reads the message body from the server after header is processed.\n- do_write: do_write() -> None - Asynchronously writes the next queued message to the server.",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\ntypedef std::deque<chat_message> chat_message_queue;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context),\n      socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_,\n        [this, msg]()\n        {\n          bool write_in_progress = !write_msgs_.empty();\n          write_msgs_.push_back(msg);\n          if (!write_in_progress)\n          {\n            do_write();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]() { socket_.close(); });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            std::cout.write(read_msg_.body(), read_msg_.body_length());\n            std::cout << \"\\n\";\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(),\n          write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            write_msgs_.pop_front();\n            if (!write_msgs_.empty())\n            {\n              do_write();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\nprivate:\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  chat_message_queue write_msgs_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "right_result": "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing boost::asio::ip::tcp;\n\nclass chat_client {\npublic:\n    chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context), read_msg_(), write_msgs_() {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        write_msgs_.push_back(msg);\n        if (write_msgs_.size() == 1) {\n            do_write();\n        }\n    }\n\n    void close() {\n        socket_.close();\n    }\n\nprivate:\n    void do_connect(const tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](boost::system::error_code ec, const tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        auto self(shared_from_this());\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n            [this, self](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec && read_msg_.decode_header()) {\n                    do_read_body();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        auto self(shared_from_this());\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n            [this, self](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    std::cout.write(read_msg_.body(), read_msg_.body_length());\n                    std::cout << \"\\n\";\n                    do_read_header();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write() {\n        auto self(shared_from_this());\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msgs_.front().data(), write_msgs_.front().length()),\n            [this, self](boost::system::error_code ec, std::size_t /*length*/) {\n                if (!ec) {\n                    write_msgs_.pop_front();\n                    if (!write_msgs_.empty()) {\n                        do_write();\n                    }\n                } else {\n                    close();\n                }\n            });\n    }\n\n    boost::asio::io_context& io_context_;\n    tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n};\n```"
  }
]