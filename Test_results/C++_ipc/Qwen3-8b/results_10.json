[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "matched_results": [],
    "unmatched_results": [
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client client(location);\n    httplib::Headers headers;\n    headers[\"Content-Type\"] = \"application/json\";\n\n    httplib::Response res;\n    auto req = client.request(method, URI);\n\n    if (request_data) {\n        req.body = request_data->dump();\n    }\n\n    req.headers = headers;\n\n    long status = 0;\n    if (client.get(URI, [&](const httplib::Response& res) {\n        status = res.status;\n        if (status >= 200 && status < 300) {\n            if (response_data) {\n                *response_data = json::parse(res.body);\n            }\n        }\n    }) || client.post(URI, req.body, headers, [&](const httplib::Response& res) {\n        status = res.status;\n        if (status >= 200 && status < 300) {\n            if (response_data) {\n                *response_data = json::parse(res.body);\n            }\n        }\n    }) || client.put(URI, req.body, headers, [&](const httplib::Response& res) {\n        status = res.status;\n        if (status >= 200 && status < 300) {\n            if (response_data) {\n                *response_data = json::parse(res.body);\n            }\n        }\n    }) || client.del(URI, [&](const httplib::Response& res) {\n        status = res.status;\n        if (status >= 200 && status < 300) {\n            if (response_data) {\n                *response_data = json::parse(res.body);\n            }\n        }\n    })) {\n        return status;\n    } else {\n        return -1;\n    }\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client client(location);\n    httplib::Headers headers;\n    headers[\"Content-Type\"] = \"application/json\";\n\n    httplib::Response res;\n    auto req = client.request(method, URI);\n\n    if (request_data) {\n        req.set_body(request_data->dump());\n    }\n\n    req.set_headers(headers);\n\n    auto status = client.get(req, res);\n\n    if (status == 200) {\n        if (response_data) {\n            try {\n                *response_data = json::parse(res.body);\n            } catch (const json::exception& e) {\n                // Handle JSON parsing error\n            }\n        }\n    }\n\n    return status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client cli(location);\n    httplib::Headers headers;\n    headers[\"Content-Type\"] = \"application/json\";\n\n    httplib::Response res;\n    auto req = cli.prepare_request(method, URI, headers);\n\n    if (request_data) {\n        req->body = request_data->dump();\n    }\n\n    cli.send(req, res);\n\n    long status = res.status;\n\n    if (status >= 200 && status < 300) {\n        if (response_data) {\n            *response_data = json::parse(res.body);\n        }\n    }\n\n    return status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client client(location);\n    httplib::Headers headers;\n    headers[\"Content-Type\"] = \"application/json\";\n\n    httplib::Response res;\n    auto req = client.request(method, URI);\n\n    if (request_data) {\n        req.body = request_data->dump();\n    }\n\n    req.set_headers(headers);\n\n    auto status = client.get(URI, [&](const httplib::Response& res) {\n        res >> res;\n    });\n\n    if (status == 200) {\n        if (response_data) {\n            try {\n                *response_data = json::parse(res.body);\n            } catch (const json::parse_error& e) {\n                // Handle parsing error\n            }\n        }\n    }\n\n    return status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client cli(location);\n    httplib::Headers headers;\n    headers[\"Content-Type\"] = \"application/json\";\n\n    httplib::Response res;\n    auto req = cli.prepare_request(method, URI, headers);\n\n    if (request_data) {\n        req->body = request_data->dump();\n    }\n\n    cli.send(req, res);\n\n    long status = res.status;\n    if (status >= 200 && status < 300) {\n        if (response_data) {\n            *response_data = json::parse(res.body);\n        }\n    }\n\n    return status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client client(location);\n    httplib::Headers headers;\n    headers[\"Content-Type\"] = \"application/json\";\n\n    httplib::Response res;\n    auto req = client.request(method, URI);\n\n    if (request_data) {\n        req.body = request_data->dump();\n    }\n\n    req.headers = headers;\n\n    long status = 0;\n    if (client.get(URI, [&](const httplib::Response& res) {\n        status = res.status;\n        if (status >= 200 && status < 300) {\n            if (response_data) {\n                *response_data = json::parse(res.body);\n            }\n        }\n    }) || client.post(URI, req.body, headers, [&](const httplib::Response& res) {\n        status = res.status;\n        if (status >= 200 && status < 300) {\n            if (response_data) {\n                *response_data = json::parse(res.body);\n            }\n        }\n    }) || client.put(URI, req.body, headers, [&](const httplib::Response& res) {\n        status = res.status;\n        if (status >= 200 && status < 300) {\n            if (response_data) {\n                *response_data = json::parse(res.body);\n            }\n        }\n    }) || client.del(URI, [&](const httplib::Response& res) {\n        status = res.status;\n        if (status >= 200 && status < 300) {\n            if (response_data) {\n                *response_data = json::parse(res.body);\n            }\n        }\n    })) {\n        return status;\n    } else {\n        return -1;\n    }\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client cli(location);\n    httplib::Headers headers;\n    httplib::Response res;\n    std::string body;\n\n    if (request_data) {\n        body = request_data->dump();\n        headers[\"Content-Type\"] = \"application/json\";\n    }\n\n    auto req = cli.request(method, URI);\n    req.set_headers(headers);\n    req.body(body);\n\n    long status = req.send(res);\n\n    if (status >= 200 && status < 300) {\n        if (response_data) {\n            try {\n                *response_data = json::parse(res.body);\n            } catch (const json::parse_error& e) {\n                // Handle parsing error\n            }\n        }\n    }\n\n    return status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client cli(location);\n    httplib::Headers headers;\n    httplib::Response res;\n\n    if (method == \"GET\") {\n        auto req = cli.get(URI);\n        res = req;\n    } else if (method == \"PUT\") {\n        auto req = cli.put(URI, request_data->dump(), \"application/json\");\n        res = req;\n    } else if (method == \"DELETE\") {\n        auto req = cli.del(URI);\n        res = req;\n    } else if (method == \"POST\") {\n        auto req = cli.post(URI, request_data->dump(), \"application/json\");\n        res = req;\n    } else {\n        return 400;\n    }\n\n    long status = res.status;\n    if (status >= 200 && status < 300) {\n        if (response_data) {\n            try {\n                *response_data = json::parse(res.body);\n            } catch (const json::parse_error& e) {\n                // Handle parsing error\n            }\n        }\n    }\n    return status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client client(location);\n    httplib::Headers headers;\n    headers[\"Content-Type\"] = \"application/json\";\n\n    httplib::Response res;\n    auto req = client.request(method, URI);\n\n    if (request_data) {\n        req.set_body(request_data->dump());\n    }\n\n    auto status = req.send(res);\n\n    if (status == 200) {\n        if (response_data) {\n            *response_data = json::parse(res.body);\n        }\n    }\n\n    return status;\n}",
      "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <memory>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data, json* response_data) {\n    httplib::Client cli(location);\n    httplib::Request req;\n    httplib::Response res;\n\n    req.method = method;\n    req.path = URI;\n\n    if (request_data) {\n        req.body = request_data->dump();\n        req.headers[\"Content-Type\"] = \"application/json\";\n    }\n\n    cli.send(req, res);\n\n    long status = res.status;\n\n    if (status >= 200 && status < 300) {\n        if (response_data) {\n            try {\n                *response_data = json::parse(res.body);\n            } catch (const json::parse_error& e) {\n                // Handle parsing error\n            }\n        }\n    }\n\n    return status;\n}"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send messages, and receive responses.\n\nFunction Description: The code consists of two functions that together implement a basic TCP client. The first function creates and connects the socket, while the second handles the communication loop with the server.\n\nInput:\n- create_tcp_client:\n  - server_ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n- tcp_client_communication:\n  - sockfd: int - The socket file descriptor returned by create_tcp_client\n\nOutput:\n- create_tcp_client:\n  - Returns: int - The socket file descriptor if successful, -1 if failed\n- tcp_client_communication:\n  - No return value (void), but prints server responses and error messages to console",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(server_ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    while(true){\n        char buf[1024];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, 1024);\n\n        if (strcmp(buffer, \"exit\") == 0) {\n            std::cout << \"Exiting...\" << std::endl;\n            break;\n        }\n\n        send(sockfd, buffer, strlen(buffer), 0);\n        int bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            std::cout << \"Server response: \" << buffer << std::endl;\n        } else {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        int bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, 1024);\n\n        if (strcmp(buffer, \"exit\") == 0) {\n            std::cout << \"Exiting...\" << std::endl;\n            break;\n        }\n\n        send(sockfd, buffer, strlen(buffer), 0);\n        int bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            std::cout << \"Server response: \" << buffer << std::endl;\n        } else {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n        if (std::string(buffer) == \"exit\") break;\n\n        send(sockfd, buffer, strlen(buffer), 0);\n        int bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin >> buffer;\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        int bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n        if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n        if (strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n        ssize_t bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send messages, and receive responses.\n\nFunction Description: The code consists of two main functions for creating and managing a TCP client connection. The first function creates and connects a TCP socket to a specified server, while the second function handles the communication loop for sending and receiving messages.\n\nInput:\n- createAndConnectTCPSocket:\n  - ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n\n- tcpClientCommunication:\n  - sockfd: int - The socket file descriptor returned by createAndConnectTCPSocket\n\nOutput:\n- createAndConnectTCPSocket:\n  - Returns: int - The socket file descriptor if successful, -1 if failed\n\n- tcpClientCommunication:\n  - No return value (void), but performs I/O operations until connection is terminated",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            std::cout << \"Server response: \" << buffer << std::endl;\n        } else if (bytes_received == 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        } else {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, 1024);\n        if (std::string(buffer) == \"exit\") break;\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n\n        if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sockfd, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n\n        if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sockfd, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n\n        if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sockfd, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n        if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::cin.getline(buffer, 1024);\n\n        if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sockfd, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, 1024);\n\n        if (strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, 1024, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server (localhost on port 8888 in this case), and enters a loop where it reads user input from stdin, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed by either side.\n\nInput: None (The server IP and port are hardcoded as 127.0.0.1 and 8888 respectively in the current implementation, but could be parameterized)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)\n\nNote: The function handles socket creation, connection establishment, data transmission, and proper cleanup (socket closing) in case of errors or normal termination.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (!std::cin) break;\n\n        send(sock, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) break;\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        send(sock, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) break;\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        send(sock, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) break;\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (!std::cin) break;\n\n        send(sock, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) break;\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (!std::cin) break;\n\n        send(sock, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) break;\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        ssize_t bytes_sent = send(sock, buffer, strlen(buffer), 0);\n        if (bytes_sent <= 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Receive failed or connection closed\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a TCP client function in C++ that establishes a connection to a server, sends and receives messages, and maintains the connection until terminated by the user.\n\nFunction Description: The function `create_tcp_client` initializes a TCP client that connects to a specified server IP address. It creates a socket, establishes a connection, and provides interactive communication where the user can send messages to the server and receive responses. The function handles basic error cases and properly closes the connection when done.\n\nInput: \n- `server_ip`: [const char*] - The IP address of the server to connect to in string format (e.g., \"127.0.0.1\")\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any error occurs during socket creation or connection establishment. The function runs indefinitely until manually terminated by the user.\n\nNote: The function uses a default port 6666 for the connection. Error messages are printed to stderr using `perror` for debugging purposes. The communication loop continues until the program is interrupted, allowing continuous message exchange between client and server.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n\n#define DEFAULT_PORT 6666\n\nint create_tcp_client(const char* server_ip) {\n    int connfd = 0;\n    struct sockaddr_in client;\n    \n    client.sin_family = AF_INET;\n    client.sin_port = htons(DEFAULT_PORT);\n    client.sin_addr.s_addr = inet_addr(server_ip);\n    \n    connfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(connfd < 0){\n        perror(\"socket\");\n        return -1;\n    }\n    \n    if(connect(connfd, (struct sockaddr *)&client, sizeof(client)) < 0){\n        perror(\"connect\");\n        close(connfd);\n        return -1;\n    }\n    \n    char buff[1024];\n    bzero(buff, sizeof(buff));\n    recv(connfd, buff, 1024, 0);\n    printf(\"recv : %s \\n\", buff);\n    \n    bzero(buff, sizeof(buff));\n    strcpy(buff, \"this is client \\n\");\n    send(connfd, buff, 1024, 0);\n    \n    while(1){\n        bzero(buff, sizeof(buff));\n        scanf(\"%s\", buff);\n        int p = strlen(buff);\n        buff[p] = '\\0';\n        send(connfd, buff, 1024, 0);\n        printf(\"i have send buff \\n\");\n    }\n    \n    close(connfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type messages and press Enter. Type 'exit' to quit.\\n\";\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected or error receiving data.\\n\";\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type 'exit' to quit.\\n\";\n\n    char buffer[1024];\n    while (true) {\n        std::cin >> buffer;\n        if (std::string(buffer) == \"exit\") break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            perror(\"Send failed\");\n            close(sock);\n            return -1;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected.\\n\";\n            break;\n        }\n        std::cout << \"Server: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <signal.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type 'exit' to quit.\\n\";\n\n    signal(SIGINT, []{ exit(0); });\n\n    char buffer[1024];\n    while (true) {\n        std::cin >> buffer;\n        if (std::string(buffer) == \"exit\") break;\n\n        ssize_t bytes_sent = send(sock, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            perror(\"Send failed\");\n            close(sock);\n            return -1;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            perror(\"Receive failed\");\n            close(sock);\n            return -1;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type messages and press Enter. Type 'exit' to quit.\\n\";\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected.\\n\";\n            break;\n        }\n        std::cout << \"Server: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type messages and press Enter. Type 'exit' to quit.\\n\";\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        if (recv(sock, buffer, sizeof(buffer) - 1, 0) < 0) {\n            perror(\"Receive failed\");\n            break;\n        }\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <signal.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type 'exit' to quit.\\n\";\n\n    signal(SIGINT, []() { std::cout << \"\\nClient terminating...\\n\"; });\n\n    char buffer[1024];\n    while (true) {\n        std::cin >> buffer;\n        if (std::string(buffer) == \"exit\") break;\n\n        ssize_t bytes_sent = send(sock, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            perror(\"Send failed\");\n            close(sock);\n            return -1;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            perror(\"Receive failed\");\n            close(sock);\n            return -1;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cerrno>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type messages and press Enter. Type 'exit' to quit.\\n\";\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        if (recv(sock, buffer, sizeof(buffer) - 1, 0) < 0) {\n            perror(\"Receive failed\");\n            break;\n        }\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type 'exit' to quit.\\n\";\n\n    char buffer[1024];\n    while (true) {\n        std::cin >> buffer;\n        if (std::string(buffer) == \"exit\") break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            perror(\"Send failed\");\n            close(sock);\n            return -1;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        int valread = read(sock, buffer, sizeof(buffer));\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected.\\n\";\n            break;\n        }\n        std::cout << \"Server: \" << buffer << \"\\n\";\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cerrno>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type messages and press Enter. Type 'exit' to quit.\\n\";\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            perror(\"Send failed\");\n            close(sock);\n            return -1;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            if (bytes_received < 0) perror(\"Recv failed\");\n            else std::cerr << \"Server disconnected\\n\";\n            close(sock);\n            return -1;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address or address not supported\");\n        close(sock);\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(sock);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type messages to send (type 'exit' to quit):\\n\";\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            perror(\"Send failed\");\n            break;\n        }\n\n        memset(buffer, 0, sizeof(buffer));\n        if (recv(sock, buffer, sizeof(buffer) - 1, 0) < 0) {\n            perror(\"Receive failed\");\n            break;\n        }\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a C++ class that handles HTTP communication over TCP and UDP protocols, including sending requests and receiving responses from a server.\n\nClass Description: The LinHttpHandler class provides functionality for sending HTTP requests and receiving responses using both TCP (for standard HTTP communication) and UDP (for multicast communication). It includes error handling and resource management through RAII.\n\nAttributes:\n\nSocketCloser: [Nested Class] - A helper class that ensures sockets are properly closed when they go out of scope.\n\nMethods:\n\nsend: [Name](const std::string& msg, const std::string& adr, int port) -> std::string - Sends an HTTP message to the specified address and port using TCP and returns the server's response. Throws system_error on failure.\n\nsendMulticast: [Name](const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) -> std::vector<std::string> - Sends a multicast message using UDP and collects responses within the specified timeout period. Returns a vector of response strings. Throws system_error on failure.\n\nSocketCloser: [Name](int sockFd) -> None - Constructor that takes a socket file descriptor. The destructor automatically closes the socket.",
    "Canonical_solution": "#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <stdexcept>\n#include <system_error>\n#include <vector>\n\nnamespace hueplusplus\n{\nclass LinHttpHandler\n{\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) const\n    {\n        int socketFD = socket(AF_INET, SOCK_STREAM, 0);\n\n        SocketCloser closeMySocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to open socket\"));\n        }\n\n        hostent* server = gethostbyname(adr.c_str());\n        if (server == NULL)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: gethostbyname\"));\n        }\n\n        sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        memcpy(&server_addr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n        if (connect(socketFD, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to connect socket\"));\n        }\n\n        size_t total = msg.length();\n        size_t sent = 0;\n        do\n        {\n            ssize_t bytes = write(socketFD, msg.c_str() + sent, total - sent);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to write message to socket\"));\n            }\n            sent += bytes;\n        } while (sent < total);\n\n        std::string response;\n        char buffer[128] = {};\n        do\n        {\n            ssize_t bytes = read(socketFD, buffer, 127);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to read response from socket\"));\n            }\n            response.append(buffer, bytes);\n        } while (true);\n\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(\n        const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) const\n    {\n        hostent* server;\n        sockaddr_in server_addr;\n\n        memset((char*)&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n\n        server = gethostbyname(adr.c_str());\n        if (!server)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to obtain address of host\"));\n        }\n\n        memcpy((void*)&server_addr.sin_addr, server->h_addr_list[0], server->h_length);\n\n        int socketFD = socket(AF_INET, SOCK_DGRAM, 0);\n        SocketCloser closeMySendSocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to open socket\"));\n        }\n\n        if (sendto(socketFD, msg.c_str(), strlen(msg.c_str()), 0, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to send message\"));\n        }\n\n        std::string response;\n        char buffer[2048] = {};\n\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout)\n        {\n            ssize_t bytesReceived = recv(socketFD, &buffer, 2048, MSG_DONTWAIT);\n            if (bytesReceived < 0 && errno != EAGAIN && errno != EWOULDBLOCK)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to read response from socket\"));\n            }\n            if (bytesReceived > 0)\n            {\n                response.append(buffer, bytesReceived);\n            }\n        }\n\n        std::vector<std::string> returnString;\n        size_t pos = response.find(\"\\r\\n\\r\\n\");\n        size_t prevpos = 0;\n        while (pos != std::string::npos)\n        {\n            returnString.push_back(response.substr(prevpos, pos - prevpos));\n            pos += 4;\n            prevpos = pos;\n            pos = response.find(\"\\r\\n\\r\\n\", pos);\n        }\n        return returnString;\n    }\n\nprivate:\n    class SocketCloser\n    {\n    public:\n        explicit SocketCloser(int sockFd) : s(sockFd) {}\n        ~SocketCloser() { close(s); }\n\n    private:\n        int s;\n    };\n};\n} // namespace hueplusplus",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "matched_results": [],
    "unmatched_results": [
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\n    std::string getHttpResponse(const std::string& rawResponse);\n    std::vector<std::string> parseMulticastResponses(const std::string& rawResponses);\npublic:\n    LinHttpHandler() = default;\n    ~LinHttpHandler() = default;\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n};",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpMulticast(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\npublic:\n    LinHttpHandler() = default;\n    ~LinHttpHandler() = default;\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n};",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\n    std::string parseHttpResponse(const std::string& response);\n    bool isHttpResponseComplete(const std::string& response);\n    std::vector<std::string> splitMulticastResponses(const std::string& rawResponses);\n    std::string getMulticastGroupAddress(const std::string& adr);\n    int setupMulticastSocket(int sockfd, const std::string& groupAddr, int port);\n    void setSocketOptions(int sockfd, int level, int optname, const void* optval, socklen_t len);\n    void bindSocket(int sockfd, const std::string& adr, int port);\n    void joinMulticastGroup(int sockfd, const std::string& groupAddr, int port);\n    void setSocketTimeout(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string receiveData(int sockfd, size_t maxLen);\n    void sendData(int sockfd, const std::string& data);\n    std::string getLastErrorString();\npublic:\n    LinHttpHandler() = default;\n    ~LinHttpHandler() = default;\n    LinHttpHandler(const LinHttpHandler&) = delete;\n    LinHttpHandler& operator=(const LinHttpHandler&) = delete;\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n};",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\n    std::string parseHttpResponse(const std::string& response);\n    std::vector<std::string> parseMulticastResponses(const std::string& response);\n    std::string getLocalIpAddress();\n    bool isMulticastAddress(const std::string& ip);\n    void setupMulticastSocket(int sockfd, const std::string& group, int port);\n    void setSocketOptions(int sockfd);\n    void bindSocket(int sockfd, const std::string& ip, int port);\n    void connectSocket(int sockfd, const std::string& ip, int port);\n    void sendDatagram(int sockfd, const std::string& msg, const std::string& ip, int port);\n    std::string receiveDatagram(int sockfd);\n    std::vector<std::string> collectResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string getResponseString(const std::string& data);\n    std::vector<std::string> splitResponses(const std::string& data);\n    std::string trim(const std::string& str);\n    std::string removeCrlf(const std::string& str);\n    std::string extractBody(const std::string& response);\n    std::string extractHeaders(const std::string& response);\n    std::string extractStatusLine(const std::string& response);\n    std::string extractStatusCode(const std::string& statusLine);\n    std::string extractStatusMessage(const std::string& statusLine);\n    std::string extractContentLength(const std::string& headers);\n    std::string extractContentType(const std::string& headers);\n    std::string extractServer(const std::string& headers);\n    std::string extractDate(const std::string& headers);\n    std::string extractConnection(const std::string& headers);\n    std::string extractVia(const std::string& headers);\n    std::string extractPragma(const std::string& headers);\n    std::string extractCacheControl(const std::string& headers);\n    std::string extractExpires(const std::string& headers);\n    std::string extractLastModified(const std::string& headers);\n    std::string extractETag(const std::string& headers);\n    std::string extractLocation(const std::string& headers);\n    std::string extractAcceptRanges(const std::string& headers);\n    std::string extractAge(const std::string& headers);\n    std::string extractAllow(const std::string& headers);\n    std::string extractAuthorization(const std::string& headers);\n    std::string extractWWWAuthenticate(const std::string& headers);\n    std::string extractProxyAuthenticate(const std::string& headers);\n    std::string extractProxyAuthorization(const std::string& headers);\n    std::string extractSetCookie(const std::string& headers);\n    std::string extractCookie(const std::string& headers);\n    std::string extractTransferEncoding(const std::string& headers);\n    std::string extractUpgrade(const std::string& headers);\n    std::string extractVia2(const std::string& headers);\n    std::string extractWarning(const std::string& headers);\n    std::string extractContentDisposition(const std::string& headers);\n    std::string extractContentEncoding(const std::string& headers);\n    std::string extractContentLanguage(const std::string& headers);\n    std::string extractContentLocation(const std::string& headers);\n    std::string extractContentMd5(const std::string& headers);\n    std::string extractContentRange(const std::string& headers);\n    std::string extractContentTypeParam(const std::string& headers);\n    std::string extractContentSecurityPolicy(const std::string& headers);\n    std::string extractCrossOriginEmbedderPolicy(const std::string& headers);\n    std::string extractCrossOriginOpenerPolicy(const std::string& headers);\n    std::string extractCrossOriginResourcePolicy(const std::string& headers);\n    std::string extractExpect(const std::string& headers);\n    std::string extractExposeHeaders(const std::string& headers);\n    std::string extractFrom(const std::string& headers);\n    std::string extractHost(const std::string& headers);\n    std::string extractIfMatch(const std::string& headers);\n    std::string extractIfModifiedSince(const std::string& headers);\n    std::string extractIfNoneMatch(const std::string& headers);\n    std::string extractIfRange(const std::string& headers);\n    std::string extractIfUnmodifiedSince(const std::string& headers);\n    std::string extractMaxForwards(const std::string& headers);\n    std::string extractPriority(const std::string& headers);\n    std::string extractProxyConnection(const std::string& headers);\n    std::string extractReferer(const std::string& headers);\n    std::string extractRetryAfter(const std::string& headers);\n    std::string extractTe(const std::string& headers);\n    std::string extractTimingAllowOrigin(const std::string& headers);\n    std::string extractTrailer(const std::string& headers);\n    std::string extractTransferCoding(const std::string& headers);\n    std::string extractUpgradeInsecureRequests(const std::string& headers);\n    std::string extractUserAgent(const std::string& headers);\n    std::string extractVary(const std::string& headers);\n    std::string extractVia3(const std::string& headers);\n    std::string extractWarning2(const std::string& headers);\n    std::string extractWarning3(const std::string& headers);\n    std::string extractWarning4(const std::string& headers);\n    std::string extractWarning5(const std::string& headers);\n    std::string extractWarning6(const std::string& headers);\n    std::string extractWarning7(const std::string& headers);\n    std::string extractWarning8(const std::string& headers);\n    std::string extractWarning9(const std::string& headers);\n    std::string extractWarning10(const std::string& headers);\n    std::string extractWarning11(const std::string& headers);\n    std::string extractWarning12(const std::string& headers);\n    std::string extractWarning13(const std::string& headers);\n    std::string extractWarning14(const std::string& headers);\n    std::string extractWarning15(const std::string& headers);\n    std::string extractWarning16(const std::string& headers);\n    std::string extractWarning17(const std::string& headers);\n    std::string extractWarning18(const std::string& headers);\n    std::string extractWarning19(const std::string& headers);\n    std::string extractWarning20(const std::string& headers);\n    std::string extractWarning21(const std::string& headers);\n    std::string extractWarning22(const std::string& headers);\n    std::string extractWarning23(const std::string& headers);\n    std::string extractWarning24(const std::string& headers);\n    std::string extractWarning25(const std::string& headers);\n    std::string extractWarning26(const std::string& headers);\n    std::string extractWarning27(const std::string& headers);\n    std::string extractWarning28(const std::string& headers);\n    std::string extractWarning29(const std::string& headers);\n    std::string extractWarning30(const std::string& headers);\n    std::string extractWarning31(const std::string& headers);\n    std::string extractWarning32(const std::string& headers);\n    std::string extractWarning33(const std::string& headers);\n    std::string extractWarning34(const std::string& headers);\n    std::string extractWarning35(const std::string& headers);\n    std::string extractWarning36(const std::string& headers);\n    std::string extractWarning37(const std::string& headers);\n    std::string extractWarning38(const std::string& headers);\n    std::string extractWarning39(const std::string& headers);\n    std::string extractWarning40(const std::string& headers);\n    std::string extractWarning41(const std::string& headers);\n    std::string extractWarning42(const std::string& headers);\n    std::string extractWarning43(const std::string& headers);\n    std::string extractWarning44(const std::string& headers);\n    std::string extractWarning45(const std::string& headers);\n    std::string extractWarning46(const std::string& headers);\n    std::string extractWarning47(const std::string& headers);\n    std::string extractWarning48(const std::string& headers);\n    std::string extractWarning49(const std::string& headers);\n    std::string extractWarning50(const std::string& headers);\n    std::string extractWarning51(const std::string& headers);\n    std::string extractWarning52(const std::string& headers);\n    std::string extractWarning53(const std::string& headers);\n    std::string extractWarning54(const std::string& headers);\n    std::string extractWarning55(const std::string& headers);\n    std::string extractWarning56(const std::string& headers);\n    std::string extractWarning57(const std::string& headers);\n    std::string extractWarning58(const std::string& headers);\n    std::string extractWarning59(const std::string& headers);\n    std::string extractWarning60(const std::string& headers);\n    std::string extractWarning61(const std::string& headers);\n    std::string extractWarning62(const std::string& headers);\n    std::string extractWarning63(const std::string& headers);\n    std::string extractWarning64(const std::string& headers);\n    std::string extractWarning65(const std::string& headers);\n    std::string extractWarning66(const std::string& headers);\n    std::string extractWarning67(const std::string& headers);\n    std::string extractWarning68(const std::string& headers);\n    std::string extractWarning69(const std::string& headers);\n    std::string extractWarning70(const std::string& headers);\n    std::string extractWarning71(const std::string& headers);\n    std::string extractWarning72(const std::string& headers);\n    std::string extractWarning73(const std::string& headers);\n    std::string extractWarning74(const std::string& headers);\n    std::string extractWarning75(const std::string& headers);\n    std::string extractWarning76(const std::string& headers);\n    std::string extractWarning77(const std::string& headers);\n    std::string extractWarning78(const std::string& headers);\n    std::string extractWarning79(const std::string& headers);\n    std::string extractWarning80(const std::string& headers);\n    std::string extractWarning81(const std::string& headers);\n    std::string extractWarning82(const std::string& headers);\n    std::string extractWarning83(const std::string& headers);\n    std::string extractWarning84(const std::string& headers);\n    std::string extractWarning85(const std::string& headers);\n    std::string extractWarning86(const std::string& headers);\n    std::string extractWarning87(const std::string& headers);\n    std::string extractWarning88(const std::string& headers);\n    std::string extractWarning89(const std::string& headers);\n    std::string extractWarning90(const std::string& headers);\n    std::string extractWarning91(const std::string& headers);\n    std::string extractWarning92(const std::string& headers);\n    std::string extractWarning93(const std::string& headers);\n    std::string extractWarning94(const std::string& headers);\n    std::string extractWarning95(const std::string& headers);\n    std::string extractWarning96(const std::string& headers);\n    std::string extractWarning97(const std::string& headers);\n    std::string extractWarning98(const std::string& headers);\n    std::string extractWarning99(const std::string& headers);\n    std::string extractWarning100(const std::string& headers);\n    std::string extractWarning101(const std::string& headers);\n    std::string extractWarning102(const std::string& headers);\n    std::string extractWarning103(const std::string& headers);\n    std::string extractWarning104(const std::string& headers);\n    std::string extractWarning105(const std::string& headers);\n    std::string extractWarning106(const std::string& headers);\n    std::string extractWarning107(const std::string& headers);\n    std::string extractWarning108(const std::string& headers);\n    std::string extractWarning109(const std::string& headers);\n    std::string extractWarning110(const std::string& headers);\n    std::string extractWarning111(const std::string& headers);\n    std::string extractWarning112(const std::string& headers);\n    std::string extractWarning113(const std::string& headers);\n    std::string extractWarning114(const std::string& headers);\n    std::string extractWarning115(const std::string& headers);\n    std::string extractWarning116(const std::string& headers);\n    std::string extractWarning117(const std::string& headers);\n    std::string extractWarning118(const std::string& headers);\n    std::string extractWarning119(const std::string& headers);\n    std::string extractWarning120(const std::string& headers);\n    std::string extractWarning121(const std::string& headers);\n    std::string extractWarning122(const std::string& headers);\n    std::string extractWarning123(const std::string& headers);\n    std::string extractWarning124(const std::string& headers);\n    std::string extractWarning125(const std::string& headers);\n    std::string extractWarning126(const std::string& headers);\n    std::string extractWarning127(const std::string& headers);\n    std::string extractWarning128(const std::string& headers);\n    std::string extractWarning129(const std::string& headers);\n    std::string extractWarning130(const std::string& headers);\n    std::string extractWarning131(const std::string& headers);\n    std::string extractWarning132(const std::string& headers);\n    std::string extractWarning133(const std::string& headers);\n    std::string extractWarning134(const std::string& headers);\n    std::string extractWarning135(const std::string& headers);\n    std::string extractWarning136(const std::string& headers);\n    std::string extractWarning137(const std::string& headers);\n    std::string extractWarning138(const std::string& headers);\n    std::string extractWarning139(const std::string& headers);\n    std::string extractWarning140(const std::string& headers);\n    std::string extractWarning141(const std::string& headers);\n    std::string extractWarning142(const std::string& headers);\n    std::string extractWarning143(const std::string& headers);\n    std::string extractWarning144(const std::string& headers);\n    std::string extractWarning145(const std::string& headers);\n    std::string extractWarning146(const std::string& headers);\n    std::string extractWarning147(const std::string& headers);\n    std::string extractWarning148(const std::string& headers);\n    std::string extractWarning149(const std::string& headers);\n    std::string extractWarning150(const std::string& headers);\n    std::string extractWarning151(const std::string& headers);\n    std::string extractWarning152(const std::string& headers);\n    std::string extractWarning153(const std::string& headers);\n    std::string extractWarning154(const std::string& headers);\n    std::string extractWarning155(const std::string& headers);\n    std::string extractWarning156(const std::string& headers);\n    std::string extractWarning157(const std::string& headers);\n    std::string extractWarning158(const std::string& headers);\n    std::string extractWarning159(const std::string& headers);\n    std::string extractWarning160(const std::string& headers);\n    std::string extractWarning161(const std::string& headers);\n    std::string extractWarning162(const std::string& headers);\n    std::string extractWarning163(const std::string& headers);\n    std::string extractWarning164(const std::string& headers);\n    std::string extractWarning165(const std::string& headers);\n    std::string extractWarning166(const std::string& headers);\n    std::string extractWarning167(const std::string& headers);\n    std::string extractWarning168(const std::string& headers);\n    std::string extractWarning169(const std::string& headers);\n    std::string extractWarning170(const std::string& headers);\n    std::string extractWarning171(const std::string& headers);\n    std::string extractWarning172(const std::string& headers);\n    std::string extractWarning173(const std::string& headers);\n    std::string extractWarning174(const std::string& headers);\n    std::string extractWarning175(const std::string& headers);\n    std::string extractWarning176(const std::string& headers);\n    std::string extractWarning177(const std::string& headers);\n    std::string extractWarning178(const std::string& headers);\n    std::string extractWarning179(const std::string& headers);\n    std::string extractWarning180(const std::string& headers);\n    std::string extractWarning181(const std::string& headers);\n    std::string extractWarning182(const std::string& headers);\n    std::string extractWarning183(const std::string& headers);\n    std::string extractWarning184(const std::string& headers);\n    std::string extractWarning185(const std::string& headers);\n    std::string extractWarning186(const std::string& headers);\n    std::string extractWarning187(const std::string& headers);\n    std::string extractWarning188(const std::string& headers);\n    std::string extractWarning189(const std::string& headers);\n    std::string extractWarning190(const std::string& headers);\n    std::string extractWarning191(const std::string& headers);\n    std::string extractWarning192(const std::string& headers);\n    std::string extractWarning193(const std::string& headers);\n    std::string extractWarning194(const std::string& headers);\n    std::string extractWarning195(const std::string& headers);\n    std::string extractWarning196(const std::string& headers);\n    std::string extractWarning197(const std::string& headers);\n    std::string extractWarning198(const std::string& headers);\n    std::string extractWarning199(const std::string& headers);\n    std::string extractWarning200(const std::string& headers);\n    std::string extractWarning201(const std::string& headers);\n    std::string extractWarning202(const std::string& headers);\n    std::string extractWarning203(const std::string& headers);\n    std::string extractWarning204(const std::string& headers);\n    std::string extractWarning205(const std::string& headers);\n    std::string extractWarning206(const std::string& headers);\n    std::string extractWarning207(const std::string& headers);\n    std::string extractWarning208(const std::string& headers);\n    std::string extractWarning209(const std::string& headers);\n    std::string extractWarning210(const std::string& headers);\n    std::string extractWarning211(const std::string& headers);\n    std::string extractWarning212(const std::string& headers);\n    std::string extractWarning213(const std::string& headers);\n    std::string extractWarning214(const std::string& headers);\n    std::string extractWarning215(const std::string& headers);\n    std::string extractWarning216(const std::string& headers);\n    std::string extractWarning217(const std::string& headers);\n    std::string extractWarning218(const std::string& headers);\n    std::string extractWarning219(const std::string& headers);\n    std::string extractWarning220(const std::string& headers);\n    std::string extractWarning221(const std::string& headers);\n    std::string extractWarning222(const std::string& headers);\n    std::string extractWarning223(const std::string& headers);\n    std::string extractWarning224(const std::string& headers);\n    std::string extractWarning225(const std::string& headers);\n    std::string extractWarning226(const std::string& headers);\n    std::string extractWarning227(const std::string& headers);\n    std::string extractWarning228(const std::string& headers);\n    std::string extractWarning229(const std::string& headers);\n    std::string extractWarning230(const std::string& headers);\n    std::string extractWarning231(const std::string& headers);\n    std::string extractWarning232(const std::string& headers);\n    std::string extractWarning233(const std::string& headers);\n    std::string extractWarning234(const std::string& headers);\n    std::string extractWarning235(const std::string& headers);\n    std::string extractWarning236(const std::string& headers);\n    std::string extractWarning237(const std::string& headers);\n    std::string extractWarning238(const std::string& headers);\n    std::string extractWarning239(const std::string& headers);\n    std::string extractWarning240(const std::string& headers);\n    std::string extractWarning241(const std::string& headers);\n    std::string extractWarning242(const std::string& headers);\n    std::string extractWarning243(const std::string& headers);\n    std::string extractWarning244(const std::string& headers);\n    std::string extractWarning245(const std::string& headers);\n    std::string extractWarning246(const std::string& headers);\n    std::string extractWarning247(const std::string& headers);\n    std::string extractWarning248(const std::string& headers);\n    std::string extractWarning249(const std::string& headers);\n    std::string extractWarning250(const std::string& headers);\n    std::string extractWarning251(const std::string& headers);\n    std::string extractWarning252(const std::string& headers);\n    std::string extractWarning253(const std::string& headers);\n    std::string extractWarning254(const std::string& headers);\n    std::string extractWarning255(const std::string& headers);\n    std::string extractWarning256(const std::string& headers);\n    std::string extractWarning257(const std::string& headers);\n    std::string extractWarning258(const std::string& headers);\n    std::string extractWarning259(const std::string& headers);\n    std::string extractWarning260(const std::string& headers);\n    std::string extractWarning261(const std::string& headers);\n    std::string extractWarning262(const std::string& headers);\n    std::string extractWarning263(const std::string& headers);\n    std::string extractWarning264(const std::string& headers);\n    std::string extractWarning265(const std::string& headers);\n    std::string extractWarning266(const std::string& headers);\n    std::string extractWarning267(const std::string& headers);\n    std::string extractWarning268(const std::string& headers);\n    std::string extractWarning269(const std::string& headers);\n    std::string extractWarning270(const std::string& headers);\n    std::string extractWarning271(const std::string& headers);\n    std::string extractWarning272(const std::string& headers);\n    std::string extractWarning273(const std::string& headers);\n    std::string extractWarning274(const std::string& headers);\n    std::string extractWarning275(const std::string& headers);\n    std::string extractWarning276(const std::string& headers);\n    std::string extractWarning277(const std::string& headers);\n    std::string extractWarning278(const std::string& headers);\n    std::string extractWarning279(const std::string& headers);\n    std::string extractWarning280(const std::string& headers);\n    std::string extractWarning281(const std::string& headers);\n    std::string extractWarning282(const std::string& headers);\n    std::string extractWarning283(const std::string& headers);\n    std::string extractWarning284(const std::string& headers);\n    std::string extractWarning285(const std::string& headers);\n    std::string extractWarning286(const std::string& headers);\n    std::string extractWarning287(const std::string& headers);\n    std::string extractWarning288(const std::string& headers);\n    std::string extractWarning289(const std::string& headers);\n    std::string extractWarning290(const std::string& headers);\n    std::string extractWarning291(const std::string& headers);\n    std::string extractWarning292(const std::string& headers);\n    std::string extractWarning293(const std::string& headers);\n    std::string extractWarning294(const std::string& headers);\n    std::string extractWarning295(const std::string& headers);\n    std::string extractWarning296(const std::string& headers);\n    std::string extractWarning297(const std::string& headers);\n    std::string extractWarning298(const std::string& headers);\n    std::string extractWarning299(const std::string& headers);\n    std::string extractWarning300(const std::string& headers);\n    std::string extractWarning301(const std::string& headers);\n    std::string extractWarning302(const std::string& headers);\n    std::string extractWarning303(const std::string& headers);\n    std::string extractWarning304(const std::string& headers);\n    std::string extractWarning305(const std::string& headers);\n    std::string extractWarning306(const std::string& headers);\n    std::string extractWarning307(const std::string& headers);\n    std::string extractWarning308(const std::string& headers);\n    std::string extractWarning309(const std::string& headers);\n    std::string extractWarning310(const std::string& headers);\n    std::string extractWarning311(const std::string& headers);\n    std::string extractWarning312(const std::string& headers);\n    std::string extractWarning313(const std::string& headers);\n    std::string extractWarning314(const std::string& headers);\n    std::string extractWarning315(const std::string& headers);\n    std::string extractWarning316(const std::string& headers);\n    std::string extractWarning317(const std::string& headers);\n    std::string extractWarning318(const std::string& headers);\n    std::string extractWarning319(const std::string& headers);\n    std::string extractWarning320(const std::string& headers);\n    std::string extractWarning321(const std::string& headers);\n    std::string extractWarning322(const std::string& headers);\n    std::string extractWarning323(const std::string& headers);\n    std::string extractWarning324(const std::string& headers);\n    std::string extractWarning325(const std::string& headers);\n    std::string extractWarning326(const std::string& headers);\n    std::string extractWarning327(const std::string& headers);\n    std::string extractWarning328(const std::string& headers);\n    std::string extractWarning329(const std::string& headers);\n    std::string extractWarning330(const std::string& headers);\n    std::string extractWarning331(const std::string& headers);\n    std::string extractWarning332(const std::string& headers);\n    std::string extractWarning333(const std::string& headers);\n    std::string extractWarning334(const std::string& headers);\n    std::string extractWarning335(const std::string& headers);\n    std::string extractWarning336(const std::string& headers);\n    std::string extractWarning337(const std::string& headers);\n    std::string extractWarning338(const std::string& headers);\n    std::string extractWarning339(const std::string& headers);\n    std::string extractWarning340(const std::string& headers);\n    std::string extractWarning341(const std::string& headers);\n    std::string extractWarning342(const std::string& headers);\n    std::string extractWarning343(const std::string& headers);\n    std::string extractWarning344(const std::string& headers);\n    std::string extractWarning345(const std::string& headers);\n    std::string extractWarning346(const std::string& headers);\n    std::string extractWarning347(const std::string& headers);\n    std::string extractWarning348(const std::string& headers);\n    std::string extractWarning349(const std::string& headers);\n    std::string extractWarning350(const std::string& headers);\n    std::string extractWarning351(const std::string& headers);\n    std::string extractWarning352(const std::string& headers);\n    std::string extractWarning353(const std::string& headers);\n    std::string extractWarning354(const std::string& headers);\n    std::string extractWarning355(const std::string& headers);\n    std::string extractWarning356(const std::string& headers);\n    std::string extractWarning357(const std::string& headers);\n    std::string extractWarning358(const std::string& headers);\n    std::string extractWarning359(const std::string& headers);\n    std::string extractWarning360(const std::string& headers);\n    std::string extractWarning361(const std::string& headers);\n    std::string extractWarning362(const std::string& headers);\n    std::string extractWarning363(const std::string& headers);\n    std::string extractWarning364(const std::string& headers);\n    std::string extractWarning365(const std::string& headers);\n    std::string extractWarning366(const std::string& headers);\n    std::string extractWarning367(const std::string& headers);\n    std::string extractWarning368(const std::string& headers);\n    std::string extractWarning369(const std::string& headers);\n    std::string extractWarning370(const std::string& headers);\n    std::string extractWarning371(const std::string& headers);\n    std::string extractWarning372(const std::string& headers);\n    std::string extractWarning373(const std::string& headers);\n    std::string extractWarning374(const std::string& headers);\n    std::string extractWarning375(const std::string& headers);\n    std::string extractWarning376(const std::string& headers);\n    std::string extractWarning377(const std::string& headers);\n    std::string extractWarning378(const std::string& headers);\n    std::string extractWarning379(const std::string& headers);\n    std::string extractWarning380(const std::string& headers);\n    std::string extractWarning381(const std::string& headers);\n    std::string extractWarning382(const std::string& headers);\n    std::string extractWarning383(const std::string& headers);\n    std::string extractWarning384(const std::string& headers);\n    std::string extractWarning385(const std::string& headers);\n    std::string extractWarning386(const std::string& headers);\n    std::string extractWarning387(const std::string& headers);\n    std::string extractWarning388(const std::string& headers);\n    std::string extractWarning389(const std::string& headers);\n    std::string extractWarning390(const std::string& headers);\n    std::string extractWarning391(const std::string& headers);\n    std::string extractWarning392(const std::string& headers);\n    std::string extractWarning393(const std::string& headers);\n    std::string extractWarning394(const std::string& headers);\n    std::string extractWarning395(const std::string& headers);\n    std::string extractWarning396(const std::string& headers);\n    std::string extractWarning397(const std::string& headers);\n    std::string extractWarning398(const std::string& headers);\n    std::string extractWarning399(const std::string& headers);\n    std::string extractWarning400(const std::string& headers);\n    std::string extractWarning401(const std::string& headers);\n    std::string extractWarning402(const std::string& headers);\n    std::string extractWarning403(const std::string& headers);\n    std::string extractWarning404(const std::string& headers);\n    std::string extractWarning405(const std::string& headers);\n    std::string extractWarning406(const std::string& headers);\n    std::string extractWarning407(const std::string& headers);\n    std::string extractWarning408(const std::string& headers);\n    std::string extractWarning409(const std::string& headers);\n    std::string extractWarning410(const std::string& headers);\n    std::string extractWarning411(const std::string& headers);\n    std::string extractWarning412(const std::string& headers);\n    std::string extractWarning413(const std::string& headers);\n    std::string extractWarning414(const std::string& headers);\n    std::string extractWarning415(const std::string& headers);\n    std::string extractWarning416(const std::string& headers);\n    std::string extractWarning417(const std::string& headers);\n    std::string extractWarning418(const std::string& headers);\n    std::string extractWarning419(const std::string& headers);\n    std::string extractWarning420(const std::string& headers);\n    std::string extractWarning421(const std::string& headers);\n    std::string extractWarning422(const std::string& headers);\n    std::string extractWarning423(const std::string& headers);\n    std::string extractWarning424(const std::string& headers);\n    std::string extractWarning425(const std::string& headers);\n    std::string extractWarning426(const std::string& headers);\n    std::string extractWarning427(const std::string& headers);\n    std::string extractWarning428(const std::string& headers);\n    std::string extractWarning429(const std::string& headers);\n    std::string extractWarning430(const std::string& headers);\n    std::string extractWarning431(const std::string& headers);\n    std::string extractWarning432(const std::string& headers);\n    std::string extractWarning433(const std::string& headers);\n    std::string extractWarning434(const std::string& headers);\n    std::string extractWarning435(const std::string& headers);\n    std::string extractWarning436(const std::string& headers);\n    std::string extractWarning437(const std::string& headers);\n    std::string extractWarning438(const std::string& headers);\n    std",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\n    std::string parseHttpResponse(const std::string& response);\n    std::vector<std::string> parseMulticastResponses(const std::string& response);\npublic:\n    LinHttpHandler() {}\n    ~LinHttpHandler() {}\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n};",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\n    std::string parseHttpResponse(const std::string& response);\n    bool isResponseComplete(const std::string& buffer);\n    std::vector<std::string> splitMulticastResponses(const std::string& buffer);\n\npublic:\n    LinHttpHandler() = default;\n    ~LinHttpHandler() = default;\n\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n};",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\n    std::string parseHttpResponse(const std::string& response);\n    bool isValidResponse(const std::string& response);\n    std::vector<std::string> splitMulticastResponses(const std::string& data);\n\npublic:\n    LinHttpHandler() = default;\n    ~LinHttpHandler() = default;\n\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n};",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\n    std::vector<std::string> splitMulticastResponses(const std::string& data);\n\npublic:\n    LinHttpHandler() = default;\n    ~LinHttpHandler() = default;\n\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n};",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    void handleSocketError(const std::string& msg, int sockfd);\n\npublic:\n    LinHttpHandler() = default;\n    ~LinHttpHandler() = default;\n\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n}; \n\nint LinHttpHandler::createTcpSocket(const std::string& adr, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        throw std::system_error(errno, std::generic_category(), \"Failed to create TCP socket\");\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n        handleSocketError(\"Invalid address or address family for TCP socket\", sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        handleSocketError(\"Connection failed for TCP socket\", sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nint LinHttpHandler::createUdpSocket() {\n    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sockfd == -1) {\n        throw std::system_error(errno, std::generic_category(), \"Failed to create UDP socket\");\n    }\n\n    return sockfd;\n}\n\nvoid LinHttpHandler::sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port) {\n    if (send(sockfd, msg.c_str(), msg.size(), 0) < 0) {\n        handleSocketError(\"Failed to send TCP request\", sockfd);\n    }\n}\n\nstd::string LinHttpHandler::receiveTcpResponse(int sockfd) {\n    char buffer[4096];\n    ssize_t bytesReceived = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n    if (bytesReceived <= 0) {\n        throw std::system_error(errno, std::generic_category(), \"Failed to receive TCP response\");\n    }\n    buffer[bytesReceived] = '\\0';\n    return std::string(buffer);\n}\n\nvoid LinHttpHandler::sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port) {\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    if (inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr) <= 0) {\n        throw std::system_error(errno, std::generic_category(), \"Invalid address or address family for UDP socket\");\n    }\n\n    if (sendto(sockfd, msg.c_str(), msg.size(), 0, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        throw std::system_error(errno, std::generic_category(), \"Failed to send UDP request\");\n    }\n}\n\nstd::vector<std::string> LinHttpHandler::receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout) {\n    std::vector<std::string> responses;\n    struct sockaddr_in fromAddr;\n    socklen_t fromLen = sizeof(fromAddr);\n    char buffer[4096];\n    std::chrono::steady_clock::time_point startTime = std::chrono::steady_clock::now();\n\n    while (true) {\n        ssize_t bytesReceived = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, (struct sockaddr*)&fromAddr, &fromLen);\n        if (bytesReceived <= 0) {\n            if (std::chrono::steady_clock::now() - startTime > timeout) {\n                break;\n            }\n            continue;\n        }\n        buffer[bytesReceived] = '\\0';\n        responses.push_back(std::string(buffer));\n    }\n\n    return responses;\n}\n\nstd::string LinHttpHandler::resolveIpAddress(const std::string& hostname) {\n    struct hostent* hostEntry = gethostbyname(hostname.c_str());\n    if (!hostEntry) {\n        throw std::system_error(errno, std::generic_category(), \"Failed to resolve hostname\");\n    }\n    return inet_ntoa(*static_cast<struct in_addr*>(hostEntry->h_addr));\n}\n\nvoid LinHttpHandler::handleSocketError(const std::string& msg, int sockfd) {\n    std::cerr << msg << \": \" << strerror(errno) << std::endl;\n    close(sockfd);\n    throw std::system_error(errno, std::generic_category(), msg + \": \" + std::string(strerror(errno)));\n}\n\nstd::string LinHttpHandler::send(const std::string& msg, const std::string& adr, int port) {\n    int sockfd = createTcpSocket(adr, port);\n    SocketCloser closer(sockfd);\n    sendTcpRequest(sockfd, msg, adr, port);\n    return receiveTcpResponse(sockfd);\n}\n\nstd::vector<std::string> LinHttpHandler::sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n    int sockfd = createUdpSocket();\n    SocketCloser closer(sockfd);\n    sendUdpRequest(sockfd, msg, adr, port);\n    return receiveUdpResponses(sockfd, timeout);\n}",
      "SocketCloser {\n    int sockFd;\npublic:\n    SocketCloser(int sockFd) : sockFd(sockFd) {}\n    ~SocketCloser() {\n        if (sockFd != -1) {\n            close(sockFd);\n        }\n    }\n};\n\nclass LinHttpHandler {\nprivate:\n    int createTcpSocket(const std::string& adr, int port);\n    int createUdpSocket();\n    void sendTcpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::string receiveTcpResponse(int sockfd);\n    void sendUdpRequest(int sockfd, const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> receiveUdpResponses(int sockfd, std::chrono::steady_clock::duration timeout);\n    std::string resolveIpAddress(const std::string& hostname);\n    std::string formatHttpRequest(const std::string& msg);\n    std::string getHttpResponse(const std::string& rawResponse);\n    std::vector<std::string> parseMulticastResponses(const std::string& rawResponses);\n\npublic:\n    LinHttpHandler() = default;\n    ~LinHttpHandler() = default;\n\n    std::string send(const std::string& msg, const std::string& adr, int port);\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout);\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends a single character, receives a response, and then closes the connection.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server address and port, sends a predefined character ('A') to the server, reads the server's response, prints the received character, and finally closes the socket. This demonstrates basic TCP client functionality using BSD sockets.\n\nInput: None (The server address and port are hardcoded as 127.0.0.1:9736 in the function)\n\nOutput: \n- Returns 0 on successful execution\n- Prints the received character from the server\n- Exits with error code 1 if connection fails",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint tcp_client_communication()\n{\n    int sockfd = -1;\n    int len = 0;\n    struct sockaddr_in address;\n    int result;\n    char ch = 'A';\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    address.sin_port = htons(9736);\n    len = sizeof(address);\n    \n    result = connect(sockfd, (struct sockaddr*)&address, len);\n\n    if(result == -1)\n    {\n        perror(\"ops:client\\n\");\n        exit(1);\n    }\n    \n    write(sockfd, &ch, 1);\n    read(sockfd, &ch, 1);\n    printf(\"char form server = %c\\n\", ch);\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char send_char = 'A';\n    send(sock, &send_char, sizeof(send_char), 0);\n\n    char recv_char;\n    ssize_t bytes_received = recv(sock, &recv_char, sizeof(recv_char), 0);\n    if (bytes_received <= 0) {\n        std::cerr << \"Server response error\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char send_char = 'A';\n    send(sock, &send_char, sizeof(send_char), 0);\n\n    char recv_char;\n    ssize_t bytes_received = recv(sock, &recv_char, sizeof(recv_char), 0);\n    if (bytes_received <= 0) {\n        std::cerr << \"Server response error\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char send_char = 'A';\n    if (send(sock, &send_char, sizeof(send_char), 0) < 0) {\n        std::cerr << \"Send failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    char recv_char;\n    if (recv(sock, &recv_char, sizeof(recv_char), 0) < 0) {\n        std::cerr << \"Receive failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char send_char = 'A';\n    if (send(sock, &send_char, sizeof(send_char), 0) < 0) {\n        std::cerr << \"Send failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    char recv_char;\n    if (recv(sock, &recv_char, sizeof(recv_char), 0) < 0) {\n        std::cerr << \"Receive failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    char send_char = 'A';\n    send(sock, &send_char, sizeof(send_char), 0);\n\n    char recv_char;\n    int bytes_received = recv(sock, &recv_char, sizeof(recv_char), 0);\n    if (bytes_received > 0) {\n        std::cout << \"Received: \" << recv_char << std::endl;\n    } else {\n        std::cerr << \"No response received\" << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char send_char = 'A';\n    send(sock, &send_char, sizeof(send_char), 0);\n\n    char recv_char;\n    ssize_t bytes_received = recv(sock, &recv_char, sizeof(recv_char), 0);\n    if (bytes_received <= 0) {\n        std::cerr << \"Server response error\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    char send_char = 'A';\n    send(sock, &send_char, sizeof(send_char), 0);\n\n    char recv_char;\n    int bytes_received = recv(sock, &recv_char, sizeof(recv_char), 0);\n    if (bytes_received > 0) {\n        std::cout << \"Received: \" << recv_char << std::endl;\n    } else {\n        std::cerr << \"No response received\" << std::endl;\n    }\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char send_char = 'A';\n    send(sock, &send_char, sizeof(send_char), 0);\n\n    char recv_char;\n    ssize_t bytes_received = recv(sock, &recv_char, sizeof(recv_char), 0);\n    if (bytes_received <= 0) {\n        std::cerr << \"Server response error\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char send_char = 'A';\n    if (send(sock, &send_char, sizeof(send_char), 0) < 0) {\n        std::cerr << \"Send failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    char recv_char;\n    if (recv(sock, &recv_char, sizeof(recv_char), 0) < 0) {\n        std::cerr << \"Receive failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    const char send_char = 'A';\n    if (send(sock, &send_char, sizeof(send_char), 0) < 0) {\n        std::cerr << \"Send failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    char recv_char;\n    if (recv(sock, &recv_char, sizeof(recv_char), 0) < 0) {\n        std::cerr << \"Receive failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sock);\n    return 0;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send data, and receive responses.\n\nFunction Description: The code consists of two main functions for creating and communicating with a TCP client. The first function creates and connects a TCP socket to a specified server, while the second function handles the communication loop for sending and receiving data.\n\nInput:\n- create_tcp_client:\n  - server_ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n- tcp_client_communication:\n  - sockfd: int - The socket file descriptor returned by create_tcp_client\n\nOutput:\n- create_tcp_client:\n  - Returns: int - The socket file descriptor on success, -1 on failure\n- tcp_client_communication:\n  - No return value (void), but performs continuous communication until connection is terminated",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(server_ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") {\n            break;\n        }\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin >> buffer;\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin >> buffer;\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024] = {0};\n    while (true) {\n        std::cin >> buffer;\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") {\n            break;\n        }\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") {\n            break;\n        }\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") break;\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/Address not supported\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        std::cout << \"Enter message to send (type 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::string(buffer) == \"exit\") {\n            break;\n        }\n\n        ssize_t bytes_sent = send(sockfd, buffer, strlen(buffer), 0);\n        if (bytes_sent < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Receive failed\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Implement a TCP client socket class in C++ that handles connection establishment, data transmission, and connection management with a remote server, supporting both IPv4 and IPv6 protocols.\n\nClass Description: The ClientSocket class provides TCP client functionality with support for both IPv4 and IPv6 connections. It handles socket creation, connection establishment with timeout support, send buffer configuration, and connection cleanup. The class is designed to work within a multi-threaded context and supports encryption parameters.\n\nAttributes:\n- dest_: std::string - Destination hostname or IP address to connect to\n- threadCtx_: ThreadCtx& - Reference to thread context containing configuration options\n- sa_: struct addrinfo - Address information structure for socket configuration\n- socket_: std::unique_ptr<WdtSocket> - Smart pointer to the underlying socket implementation\n- peerIp_: std::string - IP address of the connected peer\n\nMethods:\n- Constructor: ClientSocket(ThreadCtx& threadCtx, const string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval) -> void - Initializes the client socket with destination, port, and encryption parameters\n- connect: connect() -> ErrorCode - Establishes connection to the remote server with timeout handling, returns connection status\n- getPeerIp: getPeerIp() -> const std::string& - Returns the IP address of the connected peer\n- setSendBufferSize: setSendBufferSize() -> void - Configures the socket's send buffer size based on thread context options\n- closeConnection: closeConnection() -> void [private] - Closes the active socket connection",
    "Canonical_solution": "#include <fcntl.h>\n#include <folly/Conv.h>\n#include <folly/ScopeGuard.h>\n#include <glog/logging.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <wdt/Reporting.h>\n#include <wdt/util/ClientSocket.h>\n\nnamespace facebook {\nnamespace wdt {\n\nusing std::string;\n\nclass ClientSocket {\npublic:\n  ClientSocket(ThreadCtx &threadCtx, const string &dest,\n               const int port,\n               const EncryptionParams &encryptionParams,\n               int64_t ivChangeInterval)\n      : dest_(dest), threadCtx_(threadCtx) {\n    memset(&sa_, 0, sizeof(sa_));\n    socket_ = std::make_unique<WdtSocket>(threadCtx, port, encryptionParams,\n                                          ivChangeInterval, nullptr);\n    if (threadCtx_.getOptions().ipv6) {\n      sa_.ai_family = AF_INET6;\n    }\n    if (threadCtx_.getOptions().ipv4) {\n      sa_.ai_family = AF_INET;\n    }\n    sa_.ai_socktype = SOCK_STREAM;\n  }\n\n  ErrorCode connect() {\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    WDT_CHECK(fd < 0) << \"Previous connection not closed \" << fd << \" \" << port;\n    \n    struct addrinfo *infoList = nullptr;\n    auto guard = folly::makeGuard([&] {\n      if (infoList) {\n        freeaddrinfo(infoList);\n      }\n    });\n    \n    string portStr = folly::to<string>(port);\n    int res = getaddrinfo(dest_.c_str(), portStr.c_str(), &sa_, &infoList);\n    if (res) {\n      WLOG(ERROR) << \"Failed getaddrinfo \" << dest_ << \" , \" << port << \" : \"\n                  << res << \" : \" << gai_strerror(res);\n      return CONN_ERROR;\n    }\n    \n    int count = 0;\n    for (struct addrinfo *info = infoList; info != nullptr;\n         info = info->ai_next) {\n      ++count;\n      std::string host, port_2;\n      WdtSocket::getNameInfo(info->ai_addr, info->ai_addrlen, host, port_2);\n      WVLOG(2) << \"will connect to \" << host << \" \" << port_2;\n      \n      fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);\n      if (fd == -1) {\n        WPLOG(WARNING) << \"Error making socket for port_2 \" << port_2;\n        continue;\n      }\n      \n      socket_->setFd(fd);\n      setSendBufferSize();\n\n      int sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg |= O_NONBLOCK;\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res < 0) {\n        WPLOG(ERROR) << \"Failed to make the socket non-blocking \" << port_2\n                     << \" sock \" << sockArg << \" res \" << res;\n        closeConnection();\n        continue;\n      }\n\n      if (::connect(fd, info->ai_addr, info->ai_addrlen) != 0) {\n        if (errno != EINPROGRESS) {\n          WPLOG(INFO) << \"Error connecting on \" << host << \" \" << port_2;\n          closeConnection();\n          continue;\n        }\n        \n        auto startTime = Clock::now();\n        int connectTimeout = threadCtx_.getOptions().connect_timeout_millis;\n\n        while (true) {\n          if (threadCtx_.getAbortChecker()->shouldAbort()) {\n            WLOG(ERROR) << \"Transfer aborted during connect \" << port_2 << \" \"\n                        << fd;\n            closeConnection();\n            return ABORT;\n          }\n          \n          int timeElapsed = durationMillis(Clock::now() - startTime);\n          if (timeElapsed >= connectTimeout) {\n            WVLOG(1) << \"connect() timed out\" << host << \" \" << port_2;\n            closeConnection();\n            return CONN_ERROR_RETRYABLE;\n          }\n          \n          int pollTimeout =\n              std::min(connectTimeout - timeElapsed,\n                       threadCtx_.getOptions().abort_check_interval_millis);\n          struct pollfd pollFds[] = {{fd, POLLOUT, 0}};\n\n          if ((res = poll(pollFds, 1, pollTimeout)) <= 0) {\n            if (errno == EINTR) {\n              WVLOG(1) << \"poll() call interrupted. retrying... \" << port_2;\n              continue;\n            }\n            if (res == 0) {\n              WVLOG(1) << \"poll() timed out \" << host << \" \" << port_2;\n              continue;\n            }\n            WPLOG(ERROR) << \"poll() failed \" << host << \" \" << port_2 << \" \"\n                         << fd;\n            closeConnection();\n            return CONN_ERROR;\n          }\n          break;\n        }\n\n        int connectResult;\n        socklen_t len = sizeof(connectResult);\n        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &connectResult, &len) < 0) {\n          WPLOG(WARNING) << \"getsockopt() failed\";\n          closeConnection();\n          continue;\n        }\n        if (connectResult != 0) {\n          WLOG(WARNING) << \"connect did not succeed on \" << host << \" \" << port_2\n                        << \" : \" << strerrorStr(connectResult);\n          closeConnection();\n          continue;\n        }\n      }\n\n      sockArg = fcntl(fd, F_GETFL, nullptr);\n      sockArg &= (~O_NONBLOCK);\n      res = fcntl(fd, F_SETFL, sockArg);\n      if (res == -1) {\n        WPLOG(ERROR) << \"Could not make the socket blocking \" << port_2;\n        closeConnection();\n        continue;\n      }\n      \n      WVLOG(1) << \"Successful connect on \" << fd;\n      peerIp_ = host;\n      sa_ = *info;\n      break;\n    }\n    \n    if (socket_->getFd() < 0) {\n      if (count > 1) {\n        WLOG(INFO) << \"Unable to connect to either of the \" << count << \" addrs\";\n      }\n      return CONN_ERROR_RETRYABLE;\n    }\n    \n    socket_->setSocketTimeouts();\n    socket_->setDscp(threadCtx_.getOptions().dscp);\n    return OK;\n  }\n\n  const std::string &getPeerIp() const {\n    return peerIp_;\n  }\n\n  void setSendBufferSize() {\n    int bufSize = threadCtx_.getOptions().send_buffer_size;\n    auto fd = socket_->getFd();\n    auto port = socket_->getPort();\n    if (bufSize <= 0) {\n      return;\n    }\n    int status =\n        ::setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bufSize, sizeof(bufSize));\n    if (status != 0) {\n      WPLOG(ERROR) << \"Failed to set send buffer \" << port << \" size \" << bufSize\n                   << \" fd \" << fd;\n      return;\n    }\n    WVLOG(1) << \"Send buffer size set to \" << bufSize << \" port \" << port;\n  }\n\nprivate:\n  std::string dest_;\n  ThreadCtx &threadCtx_;\n  struct addrinfo sa_;\n  std::unique_ptr<WdtSocket> socket_;\n  std::string peerIp_;\n\n  void closeConnection() {\n    socket_->close();\n  }\n};\n\n}  // namespace wdt\n}  // namespace facebook",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <thread>\n#include <chrono>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <stdexcept>\n#include <atomic>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool enableEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo& sa) = 0;\n    virtual ssize_t send(const void* data, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    // Initialize address info\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC; // IPv4 or IPv6\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    int status = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &hints, &sa_);\n    if (status != 0) {\n        throw std::runtime_error(\"getaddrinfo error: \" + std::string(gai_strerror(status)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    if (connected_) {\n        return ErrorCode::AlreadyConnected;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SocketCreationFailed;\n    }\n\n    // Set send buffer size\n    setSendBufferSize();\n\n    // Connect with timeout\n    struct timeval timeout;\n    timeout.tv_sec = 5;\n    timeout.tv_usec = 0;\n    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        closeConnection();\n        return ErrorCode::ConnectionFailed;\n    }\n\n    // Get peer IP\n    char ip[INET6_ADDRSTRLEN];\n    if (sa_.ai_family == AF_INET) {\n        struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n        inet_ntop(AF_INET, &ipv4->sin_addr, ip, sizeof(ip));\n    } else {\n        struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n        inet_ntop(AF_INET6, &ipv6->sin6_addr, ip, sizeof(ip));\n    }\n    peerIp_ = ip;\n\n    connected_ = true;\n    return ErrorCode::Success;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (socket_ && socket_->connect(sa_)) {\n        int bufferSize = threadCtx_.sendBufferSize;\n        setsockopt(socket_->getFd(), SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <thread>\n#include <chrono>\n#include <stdexcept>\n#include <atomic>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool enableEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo* sa) = 0;\n    virtual ssize_t send(const void* data, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    memset(&sa_, 0, sizeof(sa_));\n    sa_.ai_family = AF_UNSPEC;\n    sa_.ai_socktype = SOCK_STREAM;\n    sa_.ai_protocol = IPPROTO_TCP;\n\n    int status = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &sa_, &sa_);\n    if (status != 0) {\n        throw std::runtime_error(\"getaddrinfo error: \" + std::string(gai_strerror(status)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    if (connected_) {\n        return ErrorCode::AlreadyConnected;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SocketCreationFailed;\n    }\n\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) < 0) {\n        close(sockfd);\n        return ErrorCode::SocketOptionSetFailed;\n    }\n\n    if (threadCtx_.sendBufferSize > 0) {\n        if (setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &threadCtx_.sendBufferSize, sizeof(threadCtx_.sendBufferSize)) < 0) {\n            close(sockfd);\n            return ErrorCode::SendBufferSizeSetFailed;\n        }\n    }\n\n    int timeout = 5000; // milliseconds\n    struct timeval tv = {timeout / 1000, (timeout % 1000) * 1000};\n    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {\n        close(sockfd);\n        return ErrorCode::SendTimeoutSetFailed;\n    }\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        close(sockfd);\n        return ErrorCode::ConnectionFailed;\n    }\n\n    char ip[INET6_ADDRSTRLEN];\n    if (sa_.ai_family == AF_INET) {\n        struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n        inet_ntop(AF_INET, &ipv4->sin_addr, ip, sizeof(ip));\n    } else {\n        struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n        inet_ntop(AF_INET6, &ipv6->sin6_addr, ip, sizeof(ip));\n    }\n\n    peerIp_ = ip;\n    connected_ = true;\n\n    return ErrorCode::Success;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (threadCtx_.sendBufferSize > 0) {\n        if (socket_) {\n            if (setsockopt(socket_->getFd(), SOL_SOCKET, SO_SNDBUF, &threadCtx_.sendBufferSize, sizeof(threadCtx_.sendBufferSize)) < 0) {\n                std::cerr << \"Failed to set send buffer size\" << std::endl;\n            }\n        }\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <thread>\n#include <chrono>\n#include <atomic>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool enableEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo* sa) = 0;\n    virtual ssize_t send(const void* buf, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    memset(&sa_, 0, sizeof(sa_));\n    sa_.ai_family = AF_UNSPEC;\n    sa_.ai_socktype = SOCK_STREAM;\n    sa_.ai_protocol = IPPROTO_TCP;\n\n    int status = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &sa_, &sa_);\n    if (status != 0) {\n        std::cerr << \"getaddrinfo error: \" << gai_strerror(status) << std::endl;\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    if (connected_) {\n        return ErrorCode::ALREADY_CONNECTED;\n    }\n\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return ErrorCode::SOCKET_CREATION_FAILED;\n    }\n\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) < 0) {\n        std::cerr << \"Setsockopt failed\" << std::endl;\n        close(sockfd);\n        return ErrorCode::SETSOCKOPT_FAILED;\n    }\n\n    if (setSendBufferSize()) {\n        std::cerr << \"Set send buffer size failed\" << std::endl;\n        close(sockfd);\n        return ErrorCode::SET_BUFFER_SIZE_FAILED;\n    }\n\n    int timeout = 5000; // milliseconds\n    struct timeval tv = {timeout / 1000, (timeout % 1000) * 1000};\n    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {\n        std::cerr << \"Set send timeout failed\" << std::endl;\n        close(sockfd);\n        return ErrorCode::SET_TIMEOUT_FAILED;\n    }\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return ErrorCode::CONNECTION_FAILED;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    socket_->connect(&sa_);\n\n    char ip[INET6_ADDRSTRLEN];\n    if (sa_.ai_family == AF_INET) {\n        struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n        inet_ntop(AF_INET, &ipv4->sin_addr, ip, sizeof(ip));\n    } else {\n        struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n        inet_ntop(AF_INET6, &ipv6->sin6_addr, ip, sizeof(ip));\n    }\n    peerIp_ = ip;\n\n    connected_ = true;\n    return ErrorCode::SUCCESS;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (setsockopt(socket_->getSocket(), SOL_SOCKET, SO_SNDBUF, &threadCtx_.sendBufferSize, sizeof(threadCtx_.sendBufferSize)) < 0) {\n        return;\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <thread>\n#include <atomic>\n#include <chrono>\n#include <stdexcept>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool useEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo& sa) = 0;\n    virtual ssize_t send(const void* data, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC; // IPv4 or IPv6\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    int status = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &hints, &sa_);\n    if (status != 0) {\n        throw std::runtime_error(\"getaddrinfo error: \" + std::string(gai_strerror(status)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    socket_ = std::make_unique<WdtSocket>();\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SOCKET_CREATION_FAILED;\n    }\n\n    int timeout = 5000; // milliseconds\n    struct timeval tv = {timeout / 1000, (timeout % 1000) * 1000};\n    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));\n\n    if (connect(sockfd, sa_.ai_addr, sa_.ai_addrlen) == -1) {\n        close(sockfd);\n        return ErrorCode::CONNECTION_FAILED;\n    }\n\n    socklen_t addrLen = sizeof(struct sockaddr_in6);\n    getpeername(sockfd, (struct sockaddr*)&sa_, &addrLen);\n    char ip[INET6_ADDRSTRLEN];\n    inet_ntop(sa_.ai_family, &((struct sockaddr_in6*)sa_.ai_addr)->sin6_addr, ip, sizeof(ip));\n    peerIp_ = ip;\n\n    setSendBufferSize();\n    connected_ = true;\n    return ErrorCode::SUCCESS;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (socket_) {\n        int bufferSize = threadCtx_.sendBufferSize;\n        setsockopt(socket_->getFd(), SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <thread>\n#include <chrono>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <stdexcept>\n#include <atomic>\n#include <mutex>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool useEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo& sa) = 0;\n    virtual ssize_t send(const void* data, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    std::mutex mtx_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval) \n    : dest_(dest), threadCtx_(threadCtx), connected_(false) {\n    memset(&sa_, 0, sizeof(sa_));\n    sa_.ai_family = AF_UNSPEC;\n    sa_.ai_socktype = SOCK_STREAM;\n    sa_.ai_protocol = IPPROTO_TCP;\n\n    int status = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &sa_, &sa_);\n    if (status != 0) {\n        throw std::runtime_error(\"getaddrinfo error: \" + std::string(gai_strerror(status)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    std::lock_guard<std::mutex> lock(mtx_);\n    if (connected_) {\n        return ErrorCode::ALREADY_CONNECTED;\n    }\n\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SOCKET_CREATION_FAILED;\n    }\n\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) == -1) {\n        close(sockfd);\n        return ErrorCode::SETSOCKOPT_FAILED;\n    }\n\n    if (setSendBufferSize()) {\n        return ErrorCode::SET_SEND_BUFFER_FAILED;\n    }\n\n    int timeout = 5000; // milliseconds\n    struct timeval tv = {timeout / 1000, (timeout % 1000) * 1000};\n    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {\n        close(sockfd);\n        return ErrorCode::SET_TIMEOUT_FAILED;\n    }\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        close(sockfd);\n        return ErrorCode::CONNECT_FAILED;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    socket_->connect(sa_);\n\n    char ip[INET6_ADDRSTRLEN];\n    if (sa_.ai_family == AF_INET) {\n        struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n        inet_ntop(AF_INET, &ipv4->sin_addr, ip, sizeof(ip));\n    } else {\n        struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n        inet_ntop(AF_INET6, &ipv6->sin6_addr, ip, sizeof(ip));\n    }\n    peerIp_ = ip;\n\n    connected_ = true;\n    return ErrorCode::SUCCESS;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    std::lock_guard<std::mutex> lock(mtx_);\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    int bufferSize = threadCtx_.sendBufferSize;\n    if (setsockopt(socket_->getSocket(), SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize)) == -1) {\n        throw std::runtime_error(\"Failed to set send buffer size\");\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    std::lock_guard<std::mutex> lock(mtx_);\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <thread>\n#include <chrono>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <stdexcept>\n#include <atomic>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool useEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo& sa) = 0;\n    virtual ssize_t send(const void* data, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    // Initialize address info\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC; // IPv4 or IPv6\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    int status = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &hints, &sa_);\n    if (status != 0) {\n        throw std::runtime_error(\"getaddrinfo error: \" + std::string(gai_strerror(status)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    if (connected_) {\n        return ErrorCode::AlreadyConnected;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SocketCreationFailed;\n    }\n\n    // Set send buffer size\n    setSendBufferSize();\n\n    // Connect with timeout\n    struct timeval timeout;\n    timeout.tv_sec = 5;\n    timeout.tv_usec = 0;\n    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        closeConnection();\n        return ErrorCode::ConnectionFailed;\n    }\n\n    // Get peer IP\n    char ip[INET6_ADDRSTRLEN];\n    if (sa_.ai_family == AF_INET) {\n        struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n        inet_ntop(AF_INET, &ipv4->sin_addr, ip, sizeof(ip));\n    } else {\n        struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n        inet_ntop(AF_INET6, &ipv6->sin6_addr, ip, sizeof(ip));\n    }\n    peerIp_ = ip;\n\n    connected_ = true;\n    return ErrorCode::Success;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (socket_) {\n        int bufferSize = threadCtx_.sendBufferSize;\n        setsockopt(socket_->getSocket(), SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n    }\n    connected_ = false;\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <thread>\n#include <chrono>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <stdexcept>\n#include <atomic>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool useEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo& sa) = 0;\n    virtual ssize_t send(const void* data, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    memset(&sa_, 0, sizeof(sa_));\n    sa_.ai_family = AF_UNSPEC;\n    sa_.ai_socktype = SOCK_STREAM;\n    sa_.ai_protocol = IPPROTO_TCP;\n\n    int result = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &sa_, &sa_);\n    if (result != 0) {\n        throw std::runtime_error(\"getaddrinfo failed: \" + std::string(gai_strerror(result)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    if (connected_) {\n        return ErrorCode::AlreadyConnected;\n    }\n\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SocketCreationFailed;\n    }\n\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) == -1) {\n        close(sockfd);\n        return ErrorCode::SocketOptionSetFailed;\n    }\n\n    if (setSendBufferSize()) {\n        close(sockfd);\n        return ErrorCode::SendBufferSizeSetFailed;\n    }\n\n    int timeout = 5000; // milliseconds\n    struct timeval tv = {timeout / 1000, (timeout % 1000) * 1000};\n    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {\n        close(sockfd);\n        return ErrorCode::SocketTimeoutSetFailed;\n    }\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        close(sockfd);\n        return ErrorCode::ConnectionFailed;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    socket_->connect(sa_);\n\n    char ip[INET6_ADDRSTRLEN];\n    if (sa_.ai_family == AF_INET) {\n        struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n        inet_ntop(AF_INET, &ipv4->sin_addr, ip, sizeof(ip));\n    } else {\n        struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n        inet_ntop(AF_INET6, &ipv6->sin6_addr, ip, sizeof(ip));\n    }\n    peerIp_ = ip;\n    connected_ = true;\n    return ErrorCode::Success;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (setsockopt(socket_->getFd(), SOL_SOCKET, SO_SNDBUF, &threadCtx_.sendBufferSize, sizeof(threadCtx_.sendBufferSize)) == -1) {\n        throw std::runtime_error(\"Failed to set send buffer size\");\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <thread>\n#include <chrono>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <stdexcept>\n#include <atomic>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool useEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo* sa) = 0;\n    virtual ssize_t send(const void* buf, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    memset(&sa_, 0, sizeof(sa_));\n    sa_.ai_family = AF_UNSPEC;\n    sa_.ai_socktype = SOCK_STREAM;\n    sa_.ai_protocol = IPPROTO_TCP;\n\n    int result = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &sa_, &sa_);\n    if (result != 0) {\n        throw std::runtime_error(\"getaddrinfo failed: \" + std::string(gai_strerror(result)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    if (connected_) {\n        return ErrorCode::AlreadyConnected;\n    }\n\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SocketCreationFailed;\n    }\n\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) == -1) {\n        close(sockfd);\n        return ErrorCode::SocketOptionSetFailed;\n    }\n\n    if (setSendBufferSize()) {\n        close(sockfd);\n        return ErrorCode::SendBufferSizeSetFailed;\n    }\n\n    int timeout = 5000; // milliseconds\n    struct timeval tv = {timeout / 1000, (timeout % 1000) * 1000};\n    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {\n        close(sockfd);\n        return ErrorCode::SocketTimeoutSetFailed;\n    }\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        close(sockfd);\n        return ErrorCode::ConnectionFailed;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    socket_->connect(&sa_);\n\n    char ip[INET6_ADDRSTRLEN];\n    if (sa_.ai_family == AF_INET) {\n        struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n        inet_ntop(AF_INET, &ipv4->sin_addr, ip, sizeof(ip));\n    } else {\n        struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n        inet_ntop(AF_INET6, &ipv6->sin6_addr, ip, sizeof(ip));\n    }\n    peerIp_ = ip;\n    connected_ = true;\n    return ErrorCode::Success;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (setsockopt(socket_->getFd(), SOL_SOCKET, SO_SNDBUF, &threadCtx_.sendBufferSize, sizeof(threadCtx_.sendBufferSize)) == -1) {\n        throw std::runtime_error(\"Failed to set send buffer size\");\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <thread>\n#include <atomic>\n#include <chrono>\n#include <stdexcept>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool enableEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo* sa) = 0;\n    virtual ssize_t send(const void* buf, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    memset(&sa_, 0, sizeof(sa_));\n    sa_.ai_family = AF_UNSPEC;\n    sa_.ai_socktype = SOCK_STREAM;\n    sa_.ai_protocol = IPPROTO_TCP;\n\n    int status = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &sa_, &sa_);\n    if (status != 0) {\n        throw std::runtime_error(\"getaddrinfo error: \" + std::string(gai_strerror(status)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    if (connected_) {\n        return ErrorCode::ALREADY_CONNECTED;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SOCKET_CREATION_FAILED;\n    }\n\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) == -1) {\n        close(sockfd);\n        return ErrorCode::SETSOCKOPT_FAILED;\n    }\n\n    if (setSendBufferSize()) {\n        return ErrorCode::SET_SEND_BUFFER_FAILED;\n    }\n\n    int timeout = 5000; // milliseconds\n    struct timeval tv = {timeout / 1000, (timeout % 1000) * 1000};\n    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {\n        close(sockfd);\n        return ErrorCode::SET_SOCKOPT_TIMEOUT_FAILED;\n    }\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        close(sockfd);\n        return ErrorCode::CONNECT_FAILED;\n    }\n\n    connected_ = true;\n    peerIp_ = inet_ntoa(((struct sockaddr_in*)sa_.ai_addr)->sin_addr);\n    return ErrorCode::SUCCESS;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (threadCtx_.sendBufferSize > 0) {\n        if (setsockopt(socket_->getFd(), SOL_SOCKET, SO_SNDBUF, &threadCtx_.sendBufferSize, sizeof(threadCtx_.sendBufferSize)) == -1) {\n            std::cerr << \"Failed to set send buffer size\" << std::endl;\n        }\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}",
      "#include <iostream>\n#include <string>\n#include <memory>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <thread>\n#include <chrono>\n#include <atomic>\n#include <stdexcept>\n\nstruct ThreadCtx {\n    int sendBufferSize;\n};\n\nstruct EncryptionParams {\n    bool enableEncryption;\n};\n\nclass WdtSocket {\npublic:\n    virtual ~WdtSocket() = default;\n    virtual int connect(const struct addrinfo* sa) = 0;\n    virtual ssize_t send(const void* data, size_t len) = 0;\n    virtual void close() = 0;\n};\n\nclass ClientSocket {\npublic:\n    ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval);\n    ErrorCode connect();\n    const std::string& getPeerIp();\n    void setSendBufferSize();\n    void closeConnection();\n\nprivate:\n    std::string dest_;\n    ThreadCtx& threadCtx_;\n    struct addrinfo sa_;\n    std::unique_ptr<WdtSocket> socket_;\n    std::string peerIp_;\n    std::atomic<bool> connected_;\n    int64_t ivChangeInterval_;\n};\n\nClientSocket::ClientSocket(ThreadCtx& threadCtx, const std::string& dest, int port, const EncryptionParams& encryptionParams, int64_t ivChangeInterval)\n    : dest_(dest), threadCtx_(threadCtx), ivChangeInterval_(ivChangeInterval), connected_(false) {\n    memset(&sa_, 0, sizeof(sa_));\n    sa_.ai_family = AF_UNSPEC;\n    sa_.ai_socktype = SOCK_STREAM;\n    sa_.ai_protocol = IPPROTO_TCP;\n\n    int result = getaddrinfo(dest_.c_str(), std::to_string(port).c_str(), &sa_, &sa_);\n    if (result != 0) {\n        throw std::runtime_error(\"getaddrinfo failed: \" + std::string(gai_strerror(result)));\n    }\n}\n\nErrorCode ClientSocket::connect() {\n    if (connected_) {\n        return ErrorCode::AlreadyConnected;\n    }\n\n    int sockfd = socket(sa_.ai_family, sa_.ai_socktype, sa_.ai_protocol);\n    if (sockfd == -1) {\n        return ErrorCode::SocketCreationFailed;\n    }\n\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) < 0) {\n        close(sockfd);\n        return ErrorCode::SetsockoptFailed;\n    }\n\n    if (setSendBufferSize()) {\n        return ErrorCode::SetSendBufferSizeFailed;\n    }\n\n    int timeout = 5000; // milliseconds\n    struct timeval tv = {timeout / 1000, (timeout % 1000) * 1000};\n    if (setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {\n        close(sockfd);\n        return ErrorCode::SetsockoptTimeoutFailed;\n    }\n\n    int result = connect(sockfd, sa_.ai_addr, sa_.ai_addrlen);\n    if (result == -1) {\n        close(sockfd);\n        return ErrorCode::ConnectFailed;\n    }\n\n    socket_ = std::make_unique<WdtSocket>();\n    socket_->connect(&sa_);\n\n    char ip[INET6_ADDRSTRLEN];\n    if (sa_.ai_family == AF_INET) {\n        struct sockaddr_in* ipv4 = reinterpret_cast<struct sockaddr_in*>(sa_.ai_addr);\n        inet_ntop(AF_INET, &ipv4->sin_addr, ip, sizeof(ip));\n    } else {\n        struct sockaddr_in6* ipv6 = reinterpret_cast<struct sockaddr_in6*>(sa_.ai_addr);\n        inet_ntop(AF_INET6, &ipv6->sin6_addr, ip, sizeof(ip));\n    }\n    peerIp_ = ip;\n    connected_ = true;\n    return ErrorCode::Success;\n}\n\nconst std::string& ClientSocket::getPeerIp() {\n    return peerIp_;\n}\n\nvoid ClientSocket::setSendBufferSize() {\n    if (threadCtx_.sendBufferSize > 0) {\n        if (setsockopt(socket_->getSocket(), SOL_SOCKET, SO_SNDBUF, &threadCtx_.sendBufferSize, sizeof(threadCtx_.sendBufferSize)) < 0) {\n            std::cerr << \"Failed to set send buffer size\" << std::endl;\n        }\n    }\n}\n\nvoid ClientSocket::closeConnection() {\n    if (socket_) {\n        socket_->close();\n        socket_.reset();\n        connected_ = false;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 8888, respectively, within the function.)\n\nOutput: None (The function prints received messages from the server to the console but does not return any value.)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr) <= 0) {\n        std::cerr << \"Invalid address or address not supported\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr) <= 0) {\n        std::cerr << \"Invalid address or address not supported\" << std::endl;\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return;\n    }\n\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr) <= 0) {\n        std::cerr << \"Invalid address or address not supported\" << std::endl;\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return;\n    }\n\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr) <= 0) {\n        std::cerr << \"Invalid address or address not supported\" << std::endl;\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return;\n    }\n\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr) <= 0) {\n        std::cerr << \"Invalid address or address not supported\" << std::endl;\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return;\n    }\n\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr) <= 0) {\n        std::cerr << \"Invalid address or address not supported\" << std::endl;\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return;\n    }\n\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr) <= 0) {\n        std::cerr << \"Invalid address or address not supported\" << std::endl;\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return;\n    }\n\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_socket < 0) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(client_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(client_socket);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        send(client_socket, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(client_socket, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(client_socket);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket creation error\" << std::endl;\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(8888);\n\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr) <= 0) {\n        std::cerr << \"Invalid address or address not supported\" << std::endl;\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        return;\n    }\n\n    while (true) {\n        std::cin.getline(buffer, 1024);\n        send(sock, buffer, strlen(buffer), 0);\n\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[valread] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_socket < 0) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(client_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(client_socket);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        send(client_socket, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(client_socket, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(client_socket);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a TCP client class that can establish a connection to a server, send and receive data, and handle timeouts for non-blocking operations.\n\nClass Description: The TCPClient class provides functionality for TCP socket communication with a remote server. It supports both blocking and non-blocking operations with timeout capabilities, and handles cross-platform compatibility between Windows and Unix-like systems.\n\nAttributes:\n- address: std::string - The IP address or hostname of the server to connect to\n- port: u16 - The port number of the server to connect to\n- main_socket: SocketHolder (int) - The socket file descriptor for the connection\n- connected: bool - Flag indicating whether the client is currently connected to the server\n\nMethods:\n- Connect() -> bool - Establishes a connection to the server. Returns true if successful.\n- Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Reads data from the server into the buffer. Returns true if all requested bytes were read.\n- Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Writes data from the buffer to the server. Returns true if all bytes were written.\n- Disconnect() -> void - Closes the connection to the server.\n- SetNonBlock(SocketHolder sockFD, bool nonBlocking) -> bool - Sets the blocking mode of the socket. Returns true if successful.\n- ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) -> bool - Attempts to connect with a timeout. Returns true if successful.",
    "Canonical_solution": "#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <cerrno>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <string>\n\n#ifdef _WIN32\n#define WSAEAGAIN WSAEWOULDBLOCK\n#define WSAEMULTIHOP -1\n#define ERRNO(x) WSA##x\n#define GET_ERRNO WSAGetLastError()\n#define poll(x, y, z) WSAPoll(x, y, z);\n#define SHUT_RD SD_RECEIVE\n#define SHUT_WR SD_SEND\n#define SHUT_RDWR SD_BOTH\n#else\n#define ERRNO(x) x\n#define GET_ERRNO errno\n#define closesocket(x) close(x)\n#endif\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n\n    TCPClient(const std::string& address, u16 port) : address(address), port(port) {}\n\n    bool Connect() {\n        if (connected)\n            return true;\n\n        struct addrinfo hints, *addrinfo;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_family = AF_INET;\n\n        if (getaddrinfo(address.data(), NULL, &hints, &addrinfo) != 0) {\n            return false;\n        }\n\n        main_socket = ::socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == static_cast<SocketHolder>(-1)) {\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, true)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        struct sockaddr_in servaddr = {0};\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_addr.s_addr = ((struct sockaddr_in*)(addrinfo->ai_addr))->sin_addr.s_addr;\n        servaddr.sin_port = htons(port);\n        freeaddrinfo(addrinfo);\n\n        if (!ConnectWithTimeout(main_socket, &servaddr, sizeof(servaddr), 10)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t read_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (read_bytes != size) {\n            int new_read = ::recv(main_socket, (char*)((uintptr_t)buffer + read_bytes), \n                (int)(size - read_bytes), 0);\n            if (new_read < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                read_bytes = 0;\n                break;\n            }\n            read_bytes += new_read;\n        }\n        return read_bytes == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t write_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (write_bytes != size) {\n            int new_written = ::send(main_socket, (const char*)((uintptr_t)buffer + write_bytes),\n                                    (int)(size - write_bytes), 0);\n            if (new_written < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                write_bytes = 0;\n                break;\n            }\n            write_bytes += new_written;\n        }\n        return write_bytes == size;\n    }\n\n    void Disconnect() {\n        if (connected) {\n            shutdown(main_socket, SHUT_RDWR);\n            closesocket(main_socket);\n            connected = false;\n        }\n    }\n\nprivate:\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        bool blocking = !nonBlocking;\n#ifdef _WIN32\n        unsigned long nonblocking = (blocking) ? 0 : 1;\n        int ret = ioctlsocket(sockFD, FIONBIO, &nonblocking);\n        if (ret == -1) {\n            return false;\n        }\n#else\n        int flags = ::fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) {\n            return false;\n        }\n\n        flags &= ~O_NONBLOCK;\n        if (!blocking) {\n            flags |= O_NONBLOCK;\n        }\n\n        const int ret = ::fcntl(sockFD, F_SETFL, flags);\n        if (ret == -1) {\n            return false;\n        }\n#endif\n        return true;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len,\n                           int timeout_seconds) {\n        int res = ::connect(sockFD, (struct sockaddr*)server_addr, static_cast<int>(server_addr_len));\n        if (res == -1 && ((GET_ERRNO == ERRNO(EINPROGRESS) || GET_ERRNO == ERRNO(EWOULDBLOCK))) {\n            struct timeval tv;\n            fd_set fdset;\n            FD_ZERO(&fdset);\n            FD_SET(sockFD, &fdset);\n\n            tv.tv_sec = timeout_seconds;\n            tv.tv_usec = 0;\n            int select_res = ::select(static_cast<int>(sockFD + 1), NULL, &fdset, NULL, &tv);\n#ifdef _WIN32\n            if (select_res == 0) {\n                return false;\n            }\n#else\n            bool select_good = false;\n            if (select_res == 1) {\n                int so_error;\n                socklen_t len = sizeof so_error;\n\n                getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n                if (so_error == 0) {\n                    select_good = true;\n                }\n            }\n            if (!select_good) {\n                return false;\n            }\n#endif\n        } else if (res == -1) {\n            return false;\n        }\n        return true;\n    }\n\n    std::string address;\n    u16 port;\n    SocketHolder main_socket = -1;\n    bool connected = false;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        socklen_t server_addr_len = sizeof(server_addr);\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) return false;\n\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, server_addr_len) < 0) {\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (select_result == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (select_result == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_read = read(main_socket, buffer, size);\n        if (bytes_read > 0) {\n            SetNonBlock(main_socket, false);\n            return bytes_read == size;\n        }\n\n        SetNonBlock(main_socket, false);\n        return false;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (select_result == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_written = write(main_socket, buffer, size);\n        if (bytes_written > 0) {\n            SetNonBlock(main_socket, false);\n            return bytes_written == size;\n        }\n\n        SetNonBlock(main_socket, false);\n        return false;\n    }\n\n    void Disconnect() {\n        if (connected && main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        if (sockFD == -1) return false;\n\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n\n        if (fcntl(sockFD, F_SETFL, flags) == -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (sockFD == -1) return false;\n\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        setsockopt(sockFD, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));\n        setsockopt(sockFD, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n\n        if (connect(sockFD, (struct sockaddr*)server_addr, server_addr_len) < 0) {\n            if (errno == EINPROGRESS) {\n                fd_set write_fds;\n                FD_ZERO(&write_fds);\n                FD_SET(sockFD, &write_fds);\n\n                int select_result = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n                if (select_result == -1) return false;\n                if (select_result == 0) return false;\n\n                int optval;\n                socklen_t optlen = sizeof(optval);\n                if (getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &optval, &optlen) < 0) return false;\n                if (optval != 0) return false;\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            std::cerr << \"Invalid address/Address not supported\" << std::endl;\n            return false;\n        }\n\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket < 0) {\n            std::cerr << \"Socket creation failed\" << std::endl;\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, false)) {\n            std::cerr << \"Failed to set blocking mode\" << std::endl;\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n            std::cerr << \"Connection failed\" << std::endl;\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket < 0) return false;\n\n        SetNonBlock(main_socket, true);\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int ret = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (ret < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            return false;\n        } else if (ret == 0) {\n            std::cerr << \"Read timeout\" << std::endl;\n            return false;\n        }\n\n        ssize_t bytes_read = read(main_socket, buffer, size);\n        if (bytes_read < 0) {\n            std::cerr << \"Read error\" << std::endl;\n            return false;\n        }\n        return bytes_read == static_cast<ssize_t>(size);\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket < 0) return false;\n\n        SetNonBlock(main_socket, true);\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int ret = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (ret < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            return false;\n        } else if (ret == 0) {\n            std::cerr << \"Write timeout\" << std::endl;\n            return false;\n        }\n\n        ssize_t bytes_written = write(main_socket, buffer, size);\n        if (bytes_written < 0) {\n            std::cerr << \"Write error\" << std::endl;\n            return false;\n        }\n        return bytes_written == static_cast<ssize_t>(size);\n    }\n\n    void Disconnect() {\n        if (connected && main_socket >= 0) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n\n        if (fcntl(sockFD, F_SETFL, flags) == -1) {\n            return false;\n        }\n        return true;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        socklen_t len = server_addr_len;\n        int ret = connect(sockFD, (struct sockaddr*)server_addr, len);\n        if (ret < 0 && errno != EINPROGRESS) {\n            std::cerr << \"Connection failed\" << std::endl;\n            return false;\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        int sel_ret = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n        if (sel_ret < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            return false;\n        } else if (sel_ret == 0) {\n            std::cerr << \"Connection timeout\" << std::endl;\n            return false;\n        }\n\n        int err = 0;\n        socklen_t err_len = sizeof(err);\n        if (getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &err, &err_len) < 0) {\n            std::cerr << \"Getsockopt error\" << std::endl;\n            return false;\n        }\n\n        if (err != 0) {\n            std::cerr << \"Connection failed with error: \" << strerror(err) << std::endl;\n            return false;\n        }\n\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        socklen_t server_addr_len = sizeof(server_addr);\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) return false;\n\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, server_addr_len) < 0) {\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (select_result == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (select_result == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_read = read(main_socket, buffer, size);\n        if (bytes_read <= 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        SetNonBlock(main_socket, false);\n        return true;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (select_result == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_written = write(main_socket, buffer, size);\n        if (bytes_written <= 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        SetNonBlock(main_socket, false);\n        return true;\n    }\n\n    void Disconnect() {\n        if (connected && main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        if (sockFD == -1) return false;\n\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n\n        if (fcntl(sockFD, F_SETFL, flags) == -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (sockFD == -1) return false;\n\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        if (setsockopt(sockFD, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) {\n            return false;\n        }\n\n        if (connect(sockFD, (struct sockaddr*)server_addr, server_addr_len) < 0) {\n            return false;\n        }\n\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        socklen_t server_addr_len = sizeof(server_addr);\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) return false;\n\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, server_addr_len) < 0) {\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int ret = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (ret == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (ret == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_read = read(main_socket, buffer, size);\n        if (bytes_read > 0) {\n            SetNonBlock(main_socket, false);\n            return bytes_read == static_cast<ssize_t>(size);\n        }\n\n        SetNonBlock(main_socket, false);\n        return false;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int ret = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (ret == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (ret == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_written = write(main_socket, buffer, size);\n        if (bytes_written > 0) {\n            SetNonBlock(main_socket, false);\n            return bytes_written == static_cast<ssize_t>(size);\n        }\n\n        SetNonBlock(main_socket, false);\n        return false;\n    }\n\n    void Disconnect() {\n        if (connected && main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        if (sockFD == -1) return false;\n\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n\n        if (fcntl(sockFD, F_SETFL, flags) == -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (sockFD == -1) return false;\n\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        setsockopt(sockFD, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));\n        setsockopt(sockFD, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n\n        if (connect(sockFD, (struct sockaddr*)server_addr, server_addr_len) < 0) {\n            if (errno != EINPROGRESS) {\n                return false;\n            }\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        int ret = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n        if (ret == -1) return false;\n        if (ret == 0) return false;\n\n        int err;\n        socklen_t len = sizeof(err);\n        getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &err, &len);\n        if (err != 0) {\n            return false;\n        }\n\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) return false;\n\n        sockaddr_in server_addr{};\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            close(main_socket);\n            return false;\n        }\n\n        if (!ConnectWithTimeout(main_socket, reinterpret_cast<void*>(&server_addr), sizeof(server_addr), 5)) {\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int ret = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (ret == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (ret == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_read = read(main_socket, buffer, size);\n        SetNonBlock(main_socket, false);\n\n        return bytes_read == static_cast<ssize_t>(size);\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int ret = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (ret == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (ret == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_written = write(main_socket, buffer, size);\n        SetNonBlock(main_socket, false);\n\n        return bytes_written == static_cast<ssize_t>(size);\n    }\n\n    void Disconnect() {\n        if (connected && main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n\n        if (fcntl(sockFD, F_SETFL, flags) == -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (connect(sockFD, reinterpret_cast<sockaddr*>(server_addr), server_addr_len) == 0) {\n            return true;\n        }\n\n        if (errno != EINPROGRESS) {\n            return false;\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        int ret = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n        if (ret == -1) {\n            return false;\n        } else if (ret == 0) {\n            return false;\n        }\n\n        int so_error;\n        socklen_t len = sizeof(so_error);\n        if (getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len) < 0) {\n            return false;\n        }\n\n        return so_error == 0;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <chrono>\n#include <thread>\n#include <mutex>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        socklen_t server_addr_len = sizeof(server_addr);\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) return false;\n\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, server_addr_len) < 0) {\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (select_result == -1) return false;\n        if (select_result == 0) return false;\n\n        if (FD_ISSET(main_socket, &read_fds)) {\n            ssize_t bytes_read = read(main_socket, buffer, size);\n            if (bytes_read > 0) return true;\n        }\n        return false;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result == -1) return false;\n        if (select_result == 0) return false;\n\n        if (FD_ISSET(main_socket, &write_fds)) {\n            ssize_t bytes_written = write(main_socket, buffer, size);\n            if (bytes_written == static_cast<ssize_t>(size)) return true;\n        }\n        return false;\n    }\n\n    void Disconnect() {\n        if (connected && main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n        if (fcntl(sockFD, F_SETFL, flags) == -1) return false;\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        if (setsockopt(sockFD, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) return false;\n        if (setsockopt(sockFD, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) return false;\n\n        if (connect(sockFD, (struct sockaddr*)server_addr, server_addr_len) < 0) {\n            return false;\n        }\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <cerrno>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        socklen_t server_addr_len = sizeof(server_addr);\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) return false;\n\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, server_addr_len) < 0) {\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (select_result == -1) return false;\n        if (select_result == 0) return false;\n\n        ssize_t bytes_read = read(main_socket, buffer, size);\n        if (bytes_read > 0) {\n            SetNonBlock(main_socket, false);\n            return true;\n        }\n        return false;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result == -1) return false;\n        if (select_result == 0) return false;\n\n        ssize_t bytes_written = write(main_socket, buffer, size);\n        if (bytes_written == static_cast<ssize_t>(size)) {\n            SetNonBlock(main_socket, false);\n            return true;\n        }\n        return false;\n    }\n\n    void Disconnect() {\n        if (connected && main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n        if (fcntl(sockFD, F_SETFL, flags) == -1) return false;\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (sockFD == -1) return false;\n        if (connect(sockFD, (struct sockaddr*)server_addr, server_addr_len) < 0) {\n            if (errno != EINPROGRESS) return false;\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        int select_result = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result == -1) return false;\n        if (select_result == 0) return false;\n\n        int optval;\n        socklen_t optlen = sizeof(optval);\n        if (getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &optval, &optlen) < 0) return false;\n        if (optval != 0) return false;\n\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        socklen_t server_addr_len = sizeof(server_addr);\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) return false;\n\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, server_addr_len) < 0) {\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (select_result == -1) return false;\n        if (select_result == 0) return false;\n\n        if (FD_ISSET(main_socket, &read_fds)) {\n            ssize_t bytes_read = read(main_socket, buffer, size);\n            if (bytes_read > 0) return true;\n        }\n        return false;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result == -1) return false;\n        if (select_result == 0) return false;\n\n        if (FD_ISSET(main_socket, &write_fds)) {\n            ssize_t bytes_written = write(main_socket, buffer, size);\n            if (bytes_written == static_cast<ssize_t>(size)) return true;\n        }\n        return false;\n    }\n\n    void Disconnect() {\n        if (connected && main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n        if (fcntl(sockFD, F_SETFL, flags) == -1) return false;\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        if (setsockopt(sockFD, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) < 0) return false;\n        if (setsockopt(sockFD, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) return false;\n\n        if (connect(sockFD, (struct sockaddr*)server_addr, server_addr_len) < 0) {\n            return false;\n        }\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            std::cerr << \"Invalid address/Address not supported\" << std::endl;\n            return false;\n        }\n\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket < 0) {\n            std::cerr << \"Socket creation failed\" << std::endl;\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, false)) {\n            std::cerr << \"Failed to set blocking mode\" << std::endl;\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n            std::cerr << \"Connection failed\" << std::endl;\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket < 0) return false;\n\n        SetNonBlock(main_socket, true);\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int ret = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (ret < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            return false;\n        } else if (ret == 0) {\n            std::cerr << \"Read timeout\" << std::endl;\n            return false;\n        }\n\n        ssize_t bytes_read = read(main_socket, buffer, size);\n        if (bytes_read <= 0) {\n            std::cerr << \"Read failed or connection closed\" << std::endl;\n            Disconnect();\n            return false;\n        }\n\n        return true;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket < 0) return false;\n\n        SetNonBlock(main_socket, true);\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int ret = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (ret < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            return false;\n        } else if (ret == 0) {\n            std::cerr << \"Write timeout\" << std::endl;\n            return false;\n        }\n\n        ssize_t bytes_written = write(main_socket, buffer, size);\n        if (bytes_written <= 0) {\n            std::cerr << \"Write failed or connection closed\" << std::endl;\n            Disconnect();\n            return false;\n        }\n\n        return true;\n    }\n\n    void Disconnect() {\n        if (connected && main_socket >= 0) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n\n        if (fcntl(sockFD, F_SETFL, flags) == -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (connect(sockFD, (struct sockaddr*)server_addr, server_addr_len) < 0) {\n            std::cerr << \"Connection failed\" << std::endl;\n            return false;\n        }\n\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        int ret = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n        if (ret < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            return false;\n        } else if (ret == 0) {\n            std::cerr << \"Connect timeout\" << std::endl;\n            return false;\n        }\n\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nclass TCPClient {\npublic:\n    std::string address;\n    uint16_t port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) return false;\n\n        sockaddr_in server_addr{};\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            close(main_socket);\n            return false;\n        }\n\n        if (!ConnectWithTimeout(main_socket, reinterpret_cast<void*>(&server_addr), sizeof(server_addr), 5)) {\n            close(main_socket);\n            return false;\n        }\n\n        SetNonBlock(main_socket, false);\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(main_socket, &read_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n        if (select_result == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (select_result == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_read = read(main_socket, buffer, size);\n        if (bytes_read <= 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        SetNonBlock(main_socket, false);\n        return true;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        SetNonBlock(main_socket, true);\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(main_socket, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = static_cast<int>(timeout.count() / 1e9);\n        tv.tv_usec = static_cast<int>((timeout.count() % 1e9) * 1e3);\n\n        int select_result = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result == -1) {\n            SetNonBlock(main_socket, false);\n            return false;\n        } else if (select_result == 0) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        ssize_t bytes_written = write(main_socket, buffer, size);\n        if (bytes_written != static_cast<ssize_t>(size)) {\n            SetNonBlock(main_socket, false);\n            return false;\n        }\n\n        SetNonBlock(main_socket, false);\n        return true;\n    }\n\n    void Disconnect() {\n        if (connected && main_socket != -1) {\n            close(main_socket);\n            main_socket = -1;\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        if (sockFD == -1) return false;\n\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n\n        if (fcntl(sockFD, F_SETFL, flags) == -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (sockFD == -1) return false;\n\n        struct timeval tv;\n        tv.tv_sec = timeout_seconds;\n        tv.tv_usec = 0;\n\n        setsockopt(sockFD, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));\n        setsockopt(sockFD, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n\n        if (connect(sockFD, reinterpret_cast<sockaddr*>(server_addr), server_addr_len) == -1) {\n            if (errno != EINPROGRESS) {\n                return false;\n            }\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockFD, &write_fds);\n\n        int select_result = select(sockFD + 1, nullptr, &write_fds, nullptr, &tv);\n        if (select_result == -1) {\n            return false;\n        } else if (select_result == 0) {\n            return false;\n        }\n\n        int optval;\n        socklen_t optlen = sizeof(optval);\n        if (getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &optval, &optlen) < 0) {\n            return false;\n        }\n\n        if (optval != 0) {\n            return false;\n        }\n\n        return true;\n    }\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests and handling responses, including JSON parsing capabilities.\n\nClass Description: The CurlHttpClient class provides methods for performing HTTP GET requests and downloading web pages, with support for custom headers and request bodies. It includes JSON response handling and memory management for received data.\n\nAttributes:\nMemoryStruct: [struct] - A helper structure for storing received data in memory during curl operations\n  - memory: [char*] - Pointer to the allocated memory buffer\n  - size: [size_t] - Size of the allocated memory buffer\n\nMethods:\nWriteMemoryCallback: [static](void* contents, size_t size, size_t nmemb, void* userp) -> size_t - A static callback function for libcurl to write received data into memory\n  - contents: [void*] - Pointer to the received data\n  - size: [size_t] - Size of each data element\n  - nmemb: [size_t] - Number of data elements\n  - userp: [void*] - Pointer to user-provided memory structure\n  - Returns: The number of bytes actually written\n\ndownloadPage: [](const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) -> long - Downloads a web page and returns the HTTP status code\n  - url: [const std::string&] - The URL to request\n  - res: [std::string&] - Reference to store the response body\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response\n\ngetRequest: [](const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) -> long - Performs a GET request and parses the JSON response\n  - url: [const std::string&] - The URL to request\n  - res: [json&] - Reference to store the parsed JSON response\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <vector>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::ordered_json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n        if (ptr == NULL) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl_handle;\n        MemoryStruct chunk;\n        struct curl_slist* list = NULL;\n        long status_code;\n\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_global_init(CURL_GLOBAL_ALL);\n        curl_handle = curl_easy_init();\n        curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());\n        if (!headers.empty()) {\n            for (auto& h : headers) {\n                list = curl_slist_append(list, h.c_str());\n            }\n            curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, list);\n        }\n        if (body != \"\") {\n            curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"HamletDuFromage\");\n\n        curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);\n        curl_easy_perform(curl_handle);\n        curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &status_code);\n        curl_easy_cleanup(curl_handle);\n        res = std::string(chunk.memory);\n        free(chunk.memory);\n\n        curl_global_cleanup();\n        return status_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string request;\n        long status_code = downloadPage(url, request, headers, body);\n\n        if (json::accept(request))\n            res = json::parse(request);\n        else\n            res = json::object();\n\n        return status_code;\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_easy_init();\n        if (!curl) {\n            return -1;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POST, 1L);\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode res_code = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        res = std::string(chunk.memory, chunk.size);\n\n        free(chunk.memory);\n        curl_slist_free_all(header_list);\n        curl_easy_cleanup(curl);\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status_code = downloadPage(url, res, headers, body);\n        if (status_code != 200) {\n            return status_code;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return -1;\n        }\n\n        return status_code;\n    }\n\nprivate:\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_easy_init();\n        if (!curl) {\n            return CURLE_FAILED_INIT;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POST, 1L);\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode res_code = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        res = std::string(chunk.memory, chunk.size);\n\n        free(chunk.memory);\n        curl_slist_free_all(header_list);\n        curl_easy_cleanup(curl);\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status_code = downloadPage(url, res, headers, body);\n        if (status_code != 200) {\n            return status_code;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return -1;\n        }\n\n        return status_code;\n    }\n\nprivate:\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    static long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl;\n        CURLcode res_code;\n        long http_code = 0;\n\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n\n        if (curl) {\n            MemoryStruct chunk = {nullptr, 0};\n            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n\n            struct curl_slist* header_list = nullptr;\n            for (const auto& header : headers) {\n                header_list = curl_slist_append(header_list, header.c_str());\n            }\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n            if (!body.empty()) {\n                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n            }\n\n            res_code = curl_easy_perform(curl);\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n            res = std::string(chunk.memory, chunk.size);\n\n            free(chunk.memory);\n            curl_slist_free_all(header_list);\n            curl_easy_cleanup(curl);\n        }\n\n        curl_global_cleanup();\n        return http_code;\n    }\n\n    static long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string response;\n        long status = downloadPage(url, response, headers, body);\n        if (status == 200) {\n            try {\n                res = json::parse(response);\n            } catch (const json::parse_error& e) {\n                std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            }\n        }\n        return status;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_easy_init();\n        if (!curl) {\n            return CURLE_FAILED_INIT;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode res_code = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        res = chunk.memory ? chunk.memory : \"\";\n        free(chunk.memory);\n\n        if (header_list) {\n            curl_slist_free_all(header_list);\n        }\n\n        curl_easy_cleanup(curl);\n        curl = nullptr;\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status_code = downloadPage(url, res, headers, body);\n        if (status_code != 200) {\n            return status_code;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return -1;\n        }\n\n        return status_code;\n    }\n\nprivate:\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_easy_init();\n        if (!curl) {\n            return CURLE_FAILED_INIT;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode res_code = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        res = chunk.memory ? std::string(chunk.memory, chunk.size) : \"\";\n        free(chunk.memory);\n\n        curl_slist_free_all(header_list);\n        curl_easy_cleanup(curl);\n        curl = nullptr;\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status_code = downloadPage(url, res, headers, body);\n        if (status_code != 200) {\n            return status_code;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return 500;\n        }\n\n        return 200;\n    }\n\nprivate:\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_easy_init();\n        if (!curl) {\n            return CURLE_FAILED_INIT;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode res_code = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        res = chunk.memory ? std::string(chunk.memory) : \"\";\n        free(chunk.memory);\n\n        curl_slist_free_all(header_list);\n        curl_easy_cleanup(curl);\n        curl = nullptr;\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status = downloadPage(url, res, headers, body);\n        if (status != CURLE_OK) {\n            return status;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return CURLE_ABORTED_BY_CALLBACK;\n        }\n\n        return status;\n    }\n\nprivate:\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_easy_init();\n        if (!curl) {\n            return -1;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode res_code = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        res = std::string(chunk.memory, chunk.size);\n\n        free(chunk.memory);\n        curl_slist_free_all(header_list);\n        curl_easy_cleanup(curl);\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status = downloadPage(url, res, headers, body);\n        if (status != 200) {\n            return status;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return -1;\n        }\n\n        return 200;\n    }\n\nprivate:\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr), easyHandle(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (easyHandle) {\n            curl_easy_cleanup(easyHandle);\n        }\n        if (curl) {\n            curl_global_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_global_init(CURL_GLOBAL_DEFAULT);\n        if (!curl) {\n            std::cerr << \"Failed to initialize libcurl\" << std::endl;\n            return -1;\n        }\n\n        easyHandle = curl_easy_init();\n        if (!easyHandle) {\n            std::cerr << \"Failed to create CURL handle\" << std::endl;\n            return -1;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(easyHandle, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(easyHandle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(easyHandle, CURLOPT_WRITEDATA, &chunk);\n        curl_easy_setopt(easyHandle, CURLOPT_FOLLOWLOCATION, 1L);\n\n        for (const auto& header : headers) {\n            curl_easy_setopt(easyHandle, CURLOPT_HTTPHEADER, header.c_str());\n        }\n\n        if (!body.empty()) {\n            curl_easy_setopt(easyHandle, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode resCode = curl_easy_perform(easyHandle);\n        if (resCode != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(resCode) << std::endl;\n            return -1;\n        }\n\n        res = std::string(chunk.memory, chunk.size);\n        free(chunk.memory);\n\n        long httpCode = 0;\n        curl_easy_getinfo(easyHandle, CURLINFO_RESPONSE_CODE, &httpCode);\n\n        curl_easy_cleanup(easyHandle);\n        curl_global_cleanup(curl);\n\n        return httpCode;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status = downloadPage(url, res, headers, body);\n        if (status != 200) {\n            return status;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return -1;\n        }\n\n        return 200;\n    }\n\nprivate:\n    CURL* curl;\n    CURL* easyHandle;\n};",
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_easy_init();\n        if (!curl) {\n            return CURLE_FAILED_INIT;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode res_code = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        res = chunk.memory ? chunk.memory : \"\";\n        free(chunk.memory);\n\n        if (header_list) {\n            curl_slist_free_all(header_list);\n        }\n\n        curl_easy_cleanup(curl);\n        curl = nullptr;\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status_code = downloadPage(url, res, headers, body);\n        if (status_code != 200) {\n            return status_code;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return -1;\n        }\n\n        return status_code;\n    }\n\nprivate:\n    CURL* curl;\n};"
    ],
    "unmatched_results": [
      "#include <iostream>\n#include <string>\n#include <vector>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    MemoryStruct* mem = (MemoryStruct*)userp;\n\n    char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n    if (!ptr) {\n        std::cerr << \"Memory reallocation failed\" << std::endl;\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    CurlHttpClient() : curl(nullptr) {}\n\n    ~CurlHttpClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        curl = curl_easy_init();\n        if (!curl) {\n            return CURLE_FAILED_INIT;\n        }\n\n        MemoryStruct chunk;\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POST, 1L);\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        CURLcode res_code = curl_easy_perform(curl);\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n\n        res = std::string(chunk.memory, chunk.size);\n\n        free(chunk.memory);\n        curl_slist_free_all(header_list);\n\n        return http_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        long status_code = downloadPage(url, res, headers, body);\n        if (status_code != 200) {\n            return status_code;\n        }\n\n        try {\n            res = json::parse(res);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parsing error: \" << e.what() << std::endl;\n            return -1;\n        }\n\n        return status_code;\n    }\n\nprivate:\n    CURL* curl;\n};"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Implement a TCP client function that establishes a connection to a server, sends data, and reads the server's response in a continuous loop, handling connection errors and reconnection attempts.\n\nFunction Description: The function `readwrite_routine` implements a TCP client that continuously attempts to connect to a specified server endpoint. Once connected, it sends a fixed message and reads the server's response. If the connection fails or is lost, it automatically attempts to reconnect. The function handles connection states and errors appropriately, including non-blocking connection scenarios.\n\nInput: \n- `arg` (void pointer): A pointer to a `stEndPoint` structure containing:\n  - `ip` (char pointer): The IP address of the server to connect to (can be NULL or special values for default behavior)\n  - `port` (unsigned short int): The port number of the server to connect to\n\nOutput: \n- Returns NULL (void pointer) when the loop exits (though the provided implementation has an infinite loop)\n- No explicit return value, but performs I/O operations through the socket\n\nNote: The function runs in an infinite loop and should typically be executed in a separate thread. It manages its own socket lifecycle, creating and closing sockets as needed during connection attempts and communication.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nstruct stEndPoint\n{\n    char *ip;\n    unsigned short int port;\n};\n\nstatic void SetAddr(const char *pszIP, const unsigned short shPort, struct sockaddr_in &addr)\n{\n    bzero(&addr, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(shPort);\n    int nIP = 0;\n    if(!pszIP || '\\0' == *pszIP   \n            || 0 == strcmp(pszIP,\"0\") || 0 == strcmp(pszIP,\"0.0.0.0\") \n            || 0 == strcmp(pszIP,\"*\") \n      )\n    {\n        nIP = htonl(INADDR_ANY);\n    }\n    else\n    {\n        nIP = inet_addr(pszIP);\n    }\n    addr.sin_addr.s_addr = nIP;\n}\n\nstatic void *readwrite_routine(void *arg)\n{\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    char str[8] = \"sarlmol\";\n    char buf[1024 * 16];\n    int fd = -1;\n    int ret = 0;\n    \n    for(;;)\n    {\n        if(fd < 0)\n        {\n            fd = socket(PF_INET, SOCK_STREAM, 0);\n            struct sockaddr_in addr;\n            SetAddr(endpoint->ip, endpoint->port, addr);\n            ret = connect(fd, (struct sockaddr*)&addr, sizeof(addr));\n            \n            if(errno == EALREADY || errno == EINPROGRESS)\n            {       \n                struct pollfd pf = {0};\n                pf.fd = fd;\n                pf.events = (POLLOUT|POLLERR|POLLHUP);\n                co_poll(co_get_epoll_ct(), &pf, 1, 200);\n                \n                int error = 0;\n                uint32_t socklen = sizeof(error);\n                errno = 0;\n                ret = getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *)&error, &socklen);\n                if(ret == -1)\n                {       \n                    close(fd);\n                    fd = -1;\n                    continue;\n                }       \n                if(error)\n                {       \n                    errno = error;\n                    close(fd);\n                    fd = -1;\n                    continue;\n                }       \n            }\n        }\n        \n        ret = write(fd, str, 8);\n        if(ret > 0)\n        {\n            ret = read(fd, buf, sizeof(buf));\n            if(ret <= 0)\n            {\n                close(fd);\n                fd = -1;\n            }\n        }\n        else\n        {\n            close(fd);\n            fd = -1;\n        }\n    }\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct stEndPoint {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    const char *message = \"Hello from client\";\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    const int MAX_RETRIES = 5;\n    int flags;\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            fprintf(stderr, \"Socket creation failed: %s\\n\", strerror(errno));\n            sleep(1);\n            continue;\n        }\n\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        if (endpoint->ip != NULL) {\n            if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n                fprintf(stderr, \"Invalid address or address not supported: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n        } else {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        flags = fcntl(sockfd, F_GETFL, 0);\n        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n\n        if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (errno == EINPROGRESS) {\n                fprintf(stderr, \"Connection in progress...\\n\");\n                while (1) {\n                    fd_set write_fds;\n                    FD_ZERO(&write_fds);\n                    FD_SET(sockfd, &write_fds);\n\n                    struct timeval timeout = {1, 0};\n                    int select_result = select(sockfd + 1, NULL, &write_fds, NULL, &timeout);\n                    if (select_result < 0) {\n                        fprintf(stderr, \"Select error: %s\\n\", strerror(errno));\n                        close(sockfd);\n                        sleep(1);\n                        break;\n                    } else if (select_result > 0) {\n                        if (FD_ISSET(sockfd, &write_fds)) {\n                            int so_error;\n                            socklen_t len = sizeof(so_error);\n                            if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len) < 0) {\n                                fprintf(stderr, \"Getsockopt error: %s\\n\", strerror(errno));\n                                close(sockfd);\n                                sleep(1);\n                                break;\n                            } else if (so_error != 0) {\n                                fprintf(stderr, \"Connection failed: %s\\n\", strerror(so_error));\n                                close(sockfd);\n                                sleep(1);\n                                break;\n                            } else {\n                                fprintf(stderr, \"Connected to server.\\n\");\n                                break;\n                            }\n                        }\n                    } else {\n                        fprintf(stderr, \"Timeout during connection.\\n\");\n                        close(sockfd);\n                        sleep(1);\n                        break;\n                    }\n                }\n            } else {\n                fprintf(stderr, \"Connection failed: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n        } else {\n            fprintf(stderr, \"Connected to server.\\n\");\n        }\n\n        if (retry_count >= MAX_RETRIES) {\n            fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n            close(sockfd);\n            break;\n        }\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            fprintf(stderr, \"Send failed: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            continue;\n        }\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            fprintf(stderr, \"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            fprintf(stderr, \"Server closed the connection.\\n\");\n        } else {\n            fprintf(stderr, \"Recv failed: %s\\n\", strerror(errno));\n        }\n\n        close(sockfd);\n        sleep(1);\n    }\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct stEndPoint {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    const char *message = \"Hello from client\";\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    int max_retries = 5;\n    int timeout_ms = 1000;\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            fprintf(stderr, \"Socket creation failed: %s\\n\", strerror(errno));\n            sleep(1);\n            continue;\n        }\n\n        if (endpoint->ip == NULL) {\n            strcpy((char *)&server_addr.sin_addr.s_addr, \"127.0.0.1\");\n        } else {\n            inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr);\n        }\n\n        server_addr.sin_port = htons(endpoint->port);\n        server_addr.sin_family = AF_INET;\n\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n\n        int connect_result = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n        if (connect_result < 0 && errno != EINPROGRESS) {\n            fprintf(stderr, \"Connection failed: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= max_retries) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockfd, &write_fds);\n\n        struct timeval tv;\n        tv.tv_sec = timeout_ms / 1000;\n        tv.tv_usec = (timeout_ms % 1000) * 1000;\n\n        int select_result = select(sockfd + 1, NULL, &write_fds, NULL, &tv);\n        if (select_result < 0) {\n            fprintf(stderr, \"Select failed: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= max_retries) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (FD_ISSET(sockfd, &write_fds)) {\n            int so_error;\n            socklen_t len = sizeof(so_error);\n            getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len);\n            if (so_error != 0) {\n                fprintf(stderr, \"Connection failed: %s\\n\", strerror(so_error));\n                close(sockfd);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= max_retries) {\n                    fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        }\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            fprintf(stderr, \"Send failed: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= max_retries) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            fprintf(stderr, \"Server closed the connection.\\n\");\n        } else {\n            fprintf(stderr, \"Recv failed: %s\\n\", strerror(errno));\n        }\n\n        close(sockfd);\n        sleep(1);\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    const int MAX_RETRIES = 5;\n    const char *message = \"Hello from client\";\n    const int RECONNECT_DELAY = 5; // seconds\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"Socket creation failed\");\n            sleep(RECONNECT_DELAY);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        if (endpoint->ip != NULL) {\n            if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n                perror(\"Invalid address/Address not supported\");\n                close(sockfd);\n                sleep(RECONNECT_DELAY);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        } else {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        if (flags == -1) {\n            perror(\"fcntl failed\");\n            close(sockfd);\n            sleep(RECONNECT_DELAY);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) == -1) {\n            perror(\"Setting non-blocking failed\");\n            close(sockfd);\n            sleep(RECONNECT_DELAY);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (errno == EINPROGRESS) {\n                printf(\"Connection in progress...\\n\");\n                fd_set write_fds;\n                FD_ZERO(&write_fds);\n                FD_SET(sockfd, &write_fds);\n\n                struct timeval timeout;\n                timeout.tv_sec = 10;\n                timeout.tv_usec = 0;\n\n                int select_result = select(sockfd + 1, NULL, &write_fds, NULL, &timeout);\n                if (select_result == -1) {\n                    perror(\"Select failed\");\n                    close(sockfd);\n                    sleep(RECONNECT_DELAY);\n                    retry_count++;\n                    if (retry_count >= MAX_RETRIES) {\n                        fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                        break;\n                    }\n                    continue;\n                } else if (select_result == 0) {\n                    fprintf(stderr, \"Connection timed out\\n\");\n                    close(sockfd);\n                    sleep(RECONNECT_DELAY);\n                    retry_count++;\n                    if (retry_count >= MAX_RETRIES) {\n                        fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                        break;\n                    }\n                    continue;\n                }\n\n                if (FD_ISSET(sockfd, &write_fds)) {\n                    int so_error;\n                    socklen_t len = sizeof(so_error);\n                    if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len) < 0) {\n                        perror(\"getsockopt failed\");\n                        close(sockfd);\n                        sleep(RECONNECT_DELAY);\n                        retry_count++;\n                        if (retry_count >= MAX_RETRIES) {\n                            fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                            break;\n                        }\n                        continue;\n                    }\n\n                    if (so_error != 0) {\n                        fprintf(stderr, \"Connection failed with error: %s\\n\", strerror(so_error));\n                        close(sockfd);\n                        sleep(RECONNECT_DELAY);\n                        retry_count++;\n                        if (retry_count >= MAX_RETRIES) {\n                            fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                            break;\n                        }\n                        continue;\n                    }\n                }\n            } else {\n                perror(\"Connection failed\");\n                close(sockfd);\n                sleep(RECONNECT_DELAY);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        }\n\n        printf(\"Connected to server.\\n\");\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            perror(\"Send failed\");\n            close(sockfd);\n            sleep(RECONNECT_DELAY);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        printf(\"Message sent to server.\\n\");\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            printf(\"Server closed the connection.\\n\");\n        } else {\n            perror(\"Recv failed\");\n        }\n\n        close(sockfd);\n        sleep(1); // brief pause before next attempt\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct stEndPoint {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    const int MAX_RETRIES = 5;\n    const char *message = \"Hello from client\";\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"Socket creation failed\");\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        if (endpoint->ip != NULL) {\n            if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n                perror(\"Invalid address or address not supported\");\n                close(sockfd);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    printf(\"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        } else {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        if (flags == -1) {\n            perror(\"fcntl failed\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) == -1) {\n            perror(\"Setting non-blocking failed\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (errno != EINPROGRESS) {\n                perror(\"Connection failed\");\n                close(sockfd);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    printf(\"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockfd, &write_fds);\n\n        struct timeval timeout = {1, 0};\n        int select_result = select(sockfd + 1, NULL, &write_fds, NULL, &timeout);\n        if (select_result < 0) {\n            perror(\"Select failed\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        } else if (select_result == 0) {\n            printf(\"Connection timeout\\n\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            perror(\"Send failed\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            printf(\"Server closed the connection\\n\");\n        } else {\n            perror(\"Recv failed\");\n        }\n\n        close(sockfd);\n        sleep(1);\n        retry_count = 0;\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sock;\n    struct sockaddr_in server_addr;\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    const int MAX_RETRIES = 5;\n\n    while (1) {\n        sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (sock < 0) {\n            fprintf(stderr, \"Socket creation failed: %s\\n\", strerror(errno));\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        if (endpoint->ip != NULL) {\n            if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n                fprintf(stderr, \"Invalid address or address not supported: %s\\n\", strerror(errno));\n                close(sock);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        } else {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        int flags = fcntl(sock, F_GETFL, 0);\n        if (flags == -1) {\n            fprintf(stderr, \"Failed to get socket flags: %s\\n\", strerror(errno));\n            close(sock);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) == -1) {\n            fprintf(stderr, \"Failed to set non-blocking mode: %s\\n\", strerror(errno));\n            close(sock);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (errno != EINPROGRESS) {\n                fprintf(stderr, \"Connection failed: %s\\n\", strerror(errno));\n                close(sock);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sock, &write_fds);\n\n        struct timeval timeout = {1, 0};\n        int select_result = select(sock + 1, NULL, &write_fds, NULL, &timeout);\n        if (select_result < 0) {\n            fprintf(stderr, \"Select error: %s\\n\", strerror(errno));\n            close(sock);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        } else if (select_result == 0) {\n            fprintf(stderr, \"Connection timed out.\\n\");\n            close(sock);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (FD_ISSET(sock, &write_fds)) {\n            int so_error;\n            socklen_t len = sizeof(so_error);\n            if (getsockopt(sock, SOL_SOCKET, SO_ERROR, &so_error, &len) < 0) {\n                fprintf(stderr, \"Getsockopt error: %s\\n\", strerror(errno));\n                close(sock);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n\n            if (so_error != 0) {\n                fprintf(stderr, \"Connection failed with error: %s\\n\", strerror(so_error));\n                close(sock);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        }\n\n        const char *message = \"Hello from client\";\n        if (send(sock, message, strlen(message), 0) < 0) {\n            fprintf(stderr, \"Send failed: %s\\n\", strerror(errno));\n            close(sock);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        while ((bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0)) > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        }\n\n        if (bytes_received < 0) {\n            fprintf(stderr, \"Recv failed: %s\\n\", strerror(errno));\n            close(sock);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        close(sock);\n        sleep(1);\n        retry_count = 0;\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct stEndPoint {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    const char *message = \"Hello from client\";\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    const int max_retries = 5;\n    int flags;\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            fprintf(stderr, \"Socket creation failed: %s\\n\", strerror(errno));\n            sleep(1);\n            continue;\n        }\n\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        if (endpoint->ip != NULL) {\n            if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n                fprintf(stderr, \"Invalid address or address not supported: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n        } else {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        flags = fcntl(sockfd, F_GETFL, 0);\n        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n\n        if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (errno == EINPROGRESS) {\n                fprintf(stderr, \"Connection in progress...\\n\");\n                while (1) {\n                    fd_set write_fds;\n                    FD_ZERO(&write_fds);\n                    FD_SET(sockfd, &write_fds);\n\n                    select(sockfd + 1, NULL, &write_fds, NULL, NULL);\n\n                    if (FD_ISSET(sockfd, &write_fds)) {\n                        int so_error;\n                        socklen_t len = sizeof(so_error);\n                        getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len);\n                        if (so_error == 0) {\n                            break;\n                        } else {\n                            fprintf(stderr, \"Connection failed: %s\\n\", strerror(so_error));\n                            close(sockfd);\n                            sleep(1);\n                            retry_count++;\n                            if (retry_count >= max_retries) {\n                                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                                return;\n                            }\n                            break;\n                        }\n                    }\n                }\n            } else {\n                fprintf(stderr, \"Connection failed: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= max_retries) {\n                    fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                    return;\n                }\n                continue;\n            }\n        }\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            fprintf(stderr, \"Send failed: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= max_retries) {\n                fprintf(stderr, \"Max retries reached. Exiting.\\n\");\n                return;\n            }\n            continue;\n        }\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            fprintf(stderr, \"Server closed the connection.\\n\");\n        } else {\n            fprintf(stderr, \"Recv failed: %s\\n\", strerror(errno));\n        }\n\n        close(sockfd);\n        sleep(1);\n    }\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct stEndPoint {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    const char *message = \"Hello from client\";\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    const int max_retries = 5;\n    int flags;\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            fprintf(stderr, \"Socket creation failed: %s\\n\", strerror(errno));\n            sleep(1);\n            continue;\n        }\n\n        if (endpoint->ip == NULL || strcmp(endpoint->ip, \"\") == 0) {\n            strcpy((char *)&server_addr.sin_addr.s_addr, \"127.0.0.1\");\n        } else {\n            inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr);\n        }\n\n        server_addr.sin_port = htons(endpoint->port);\n        server_addr.sin_family = AF_INET;\n\n        if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (retry_count < max_retries) {\n                fprintf(stderr, \"Connection failed, retrying... (%d/%d)\\n\", retry_count + 1, max_retries);\n                close(sockfd);\n                sleep(1);\n                retry_count++;\n                continue;\n            } else {\n                fprintf(stderr, \"Max retries reached, exiting.\\n\");\n                close(sockfd);\n                break;\n            }\n        }\n\n        retry_count = 0;\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            fprintf(stderr, \"Send failed: %s\\n\", strerror(errno));\n            close(sockfd);\n            continue;\n        }\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            fprintf(stderr, \"Server closed the connection.\\n\");\n        } else {\n            fprintf(stderr, \"Recv failed: %s\\n\", strerror(errno));\n        }\n\n        close(sockfd);\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    const int MAX_RETRIES = 5;\n    const char *message = \"Hello from client\";\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            perror(\"Socket creation failed\");\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        if (endpoint->ip != NULL) {\n            if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n                perror(\"Invalid address/Address not supported\");\n                close(sockfd);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    printf(\"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        } else {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        if (flags == -1) {\n            perror(\"fcntl failed\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n        flags |= O_NONBLOCK;\n        if (fcntl(sockfd, F_SETFL, flags) == -1) {\n            perror(\"Setting non-blocking failed\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (errno != EINPROGRESS) {\n                perror(\"Connection failed\");\n                close(sockfd);\n                sleep(1);\n                retry_count++;\n                if (retry_count >= MAX_RETRIES) {\n                    printf(\"Max retries reached. Exiting.\\n\");\n                    break;\n                }\n                continue;\n            }\n        }\n\n        // Wait for connection to complete\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockfd, &write_fds);\n\n        struct timeval timeout = {1, 0};\n        int select_result = select(sockfd + 1, NULL, &write_fds, NULL, &timeout);\n        if (select_result < 0) {\n            perror(\"Select failed\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        } else if (select_result == 0) {\n            printf(\"Connection timed out\\n\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            perror(\"Send failed\");\n            close(sockfd);\n            sleep(1);\n            retry_count++;\n            if (retry_count >= MAX_RETRIES) {\n                printf(\"Max retries reached. Exiting.\\n\");\n                break;\n            }\n            continue;\n        }\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            printf(\"Server closed the connection\\n\");\n        } else {\n            perror(\"Recv failed\");\n        }\n\n        close(sockfd);\n        retry_count = 0;\n        sleep(1);\n    }\n\n    return NULL;\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct stEndPoint {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    const char *message = \"Hello from client\";\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    const int max_retries = 5;\n    int flags;\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            fprintf(stderr, \"Socket creation failed: %s\\n\", strerror(errno));\n            sleep(1);\n            continue;\n        }\n\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        if (endpoint->ip != NULL) {\n            if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n                fprintf(stderr, \"Invalid address or address not supported: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n        } else {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        flags = fcntl(sockfd, F_GETFL, 0);\n        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n\n        if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (errno == EINPROGRESS) {\n                fprintf(stderr, \"Connection in progress...\\n\");\n                while (1) {\n                    fd_set write_fds;\n                    FD_ZERO(&write_fds);\n                    FD_SET(sockfd, &write_fds);\n\n                    struct timeval timeout = {1, 0};\n                    int select_result = select(sockfd + 1, NULL, &write_fds, NULL, &timeout);\n                    if (select_result < 0) {\n                        fprintf(stderr, \"Select error: %s\\n\", strerror(errno));\n                        close(sockfd);\n                        sleep(1);\n                        break;\n                    } else if (select_result > 0) {\n                        if (FD_ISSET(sockfd, &write_fds)) {\n                            int so_error;\n                            socklen_t len = sizeof(so_error);\n                            if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len) < 0) {\n                                fprintf(stderr, \"Getsockopt error: %s\\n\", strerror(errno));\n                                close(sockfd);\n                                sleep(1);\n                                break;\n                            } else if (so_error != 0) {\n                                fprintf(stderr, \"Connection failed: %s\\n\", strerror(so_error));\n                                close(sockfd);\n                                sleep(1);\n                                break;\n                            } else {\n                                fprintf(stderr, \"Connected to server.\\n\");\n                                break;\n                            }\n                        }\n                    } else {\n                        fprintf(stderr, \"Connection timeout.\\n\");\n                        close(sockfd);\n                        sleep(1);\n                        break;\n                    }\n                }\n            } else {\n                fprintf(stderr, \"Connection failed: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n        } else {\n            fprintf(stderr, \"Connected to server.\\n\");\n        }\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            fprintf(stderr, \"Send failed: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            continue;\n        }\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            fprintf(stderr, \"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            fprintf(stderr, \"Server closed the connection.\\n\");\n        } else {\n            fprintf(stderr, \"Recv failed: %s\\n\", strerror(errno));\n        }\n\n        close(sockfd);\n        sleep(1);\n    }\n}",
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n\ntypedef struct {\n    char *ip;\n    unsigned short int port;\n} stEndPoint;\n\nvoid readwrite_routine(void *arg) {\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    int sockfd;\n    struct sockaddr_in server_addr;\n    const char *message = \"Hello from client\";\n    char buffer[1024];\n    ssize_t bytes_received;\n    int retry_count = 0;\n    int max_retries = 5;\n    int timeout_ms = 1000;\n\n    while (1) {\n        sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd < 0) {\n            fprintf(stderr, \"Socket creation failed: %s\\n\", strerror(errno));\n            sleep(1);\n            continue;\n        }\n\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endpoint->port);\n\n        if (endpoint->ip) {\n            if (inet_pton(AF_INET, endpoint->ip, &server_addr.sin_addr) <= 0) {\n                fprintf(stderr, \"Invalid address or address not supported: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n        } else {\n            server_addr.sin_addr.s_addr = INADDR_ANY;\n        }\n\n        int flags = fcntl(sockfd, F_GETFL, 0);\n        if (flags == -1) {\n            fprintf(stderr, \"Failed to get socket flags: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            continue;\n        }\n\n        if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) == -1) {\n            fprintf(stderr, \"Failed to set non-blocking mode: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            continue;\n        }\n\n        if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n            if (errno != EINPROGRESS) {\n                fprintf(stderr, \"Connection failed: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n        }\n\n        fd_set write_fds;\n        FD_ZERO(&write_fds);\n        FD_SET(sockfd, &write_fds);\n\n        struct timeval tv = {timeout_ms / 1000, (timeout_ms % 1000) * 1000};\n        int select_result = select(sockfd + 1, NULL, &write_fds, NULL, &tv);\n        if (select_result < 0) {\n            fprintf(stderr, \"Select error: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            continue;\n        } else if (select_result == 0) {\n            fprintf(stderr, \"Connection timeout\\n\");\n            close(sockfd);\n            sleep(1);\n            continue;\n        }\n\n        if (FD_ISSET(sockfd, &write_fds)) {\n            int so_error;\n            socklen_t len = sizeof(so_error);\n            if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len) < 0) {\n                fprintf(stderr, \"Getsockopt error: %s\\n\", strerror(errno));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n\n            if (so_error != 0) {\n                fprintf(stderr, \"Connection failed: %s\\n\", strerror(so_error));\n                close(sockfd);\n                sleep(1);\n                continue;\n            }\n        }\n\n        if (send(sockfd, message, strlen(message), 0) < 0) {\n            fprintf(stderr, \"Send failed: %s\\n\", strerror(errno));\n            close(sockfd);\n            sleep(1);\n            continue;\n        }\n\n        bytes_received = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        } else if (bytes_received == 0) {\n            printf(\"Server closed connection\\n\");\n        } else {\n            fprintf(stderr, \"Recv failed: %s\\n\", strerror(errno));\n        }\n\n        close(sockfd);\n        sleep(1);\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server (localhost on port 8888 in this case), and enters a loop where it reads user input from stdin, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed by either side.\n\nInput: None (The server IP and port are hardcoded as 127.0.0.1 and 8888 respectively in the function. User input is collected interactively during execution.)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value. All communication results are handled via side effects.)\n\nNote: The function handles its own socket cleanup by closing the connection before exiting.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (!std::cin) break;\n\n        send(sock, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) break;\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        send(sock, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) break;\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        ssize_t bytes_sent = send(sock, buffer, strlen(buffer), 0);\n        if (bytes_sent <= 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Receive failed or connection closed\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        ssize_t bytes_sent = send(sock, buffer, strlen(buffer), 0);\n        if (bytes_sent <= 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Receive failed or connection closed\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        ssize_t bytes_sent = send(sock, buffer, strlen(buffer), 0);\n        if (bytes_sent <= 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Receive failed or connection closed\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (!std::cin) break;\n\n        send(sock, buffer, strlen(buffer), 0);\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) break;\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        ssize_t bytes_sent = send(sock, buffer, strlen(buffer), 0);\n        if (bytes_sent <= 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Receive failed or connection closed\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input to the server, and prints the server's response. The function should handle basic error cases and properly close the connection when done.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and displays the server's response. The loop continues until an error occurs or the connection is closed by the server. The function handles socket creation, connection, data transmission, and cleanup.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 1234 respectively in the function)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(1234);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <string>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid tcp_client_communication() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::cin.eof()) break;\n\n        if (send(sock, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Send failed\" << std::endl;\n            break;\n        }\n\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Server closed connection\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(sock);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a TCP server in C++ that listens for incoming connections, receives data from clients, and echoes the data back to the clients. The server should handle one client at a time and properly clean up resources when the connection is terminated.\n\nFunction Description: The function `create_tcp_server` establishes a TCP server that binds to a specified IP address and port, listens for incoming connections, and handles client communication. It reads data from the client and sends the same data back (echo). The server runs until the client disconnects or an error occurs.\n\nInput: \n- `ip`: [const char*] - The IP address the server should bind to (e.g., \"127.0.0.1\" for localhost).\n- `port`: [int] - The port number the server should listen on (e.g., 8080).\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any step fails (socket creation, binding, listening, or accepting connections).",
    "Canonical_solution": "#include <stdio.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(bind(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    if(listen(sockfd, SOMAXCONN) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    bzero(&clnt_addr, sizeof(clnt_addr));\n\n    int clnt_sockfd = accept(sockfd, (sockaddr*)&clnt_addr, &clnt_addr_len);\n    if(clnt_sockfd == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sockfd, inet_ntoa(clnt_addr.sin_addr), ntohs(clnt_addr.sin_port));\n    \n    char buf[1024];\n    while (true) {\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(clnt_sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from client fd %d: %s\\n\", clnt_sockfd, buf);\n            write(clnt_sockfd, buf, sizeof(buf));\n        } else if(read_bytes == 0){\n            printf(\"client fd %d disconnected\\n\", clnt_sockfd);\n            close(clnt_sockfd);\n            break;\n        } else if(read_bytes == -1){\n            close(clnt_sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Accept failed\" << std::endl;\n            close(server_fd);\n            return -1;\n        }\n\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            close(new_socket);\n            continue;\n        }\n\n        send(new_socket, buffer, valread, 0);\n        close(new_socket);\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server is listening on \" << ip << \":\" << port << std::endl;\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Accept failed\" << std::endl;\n            close(server_fd);\n            return -1;\n        }\n\n        std::cout << \"New connection accepted\" << std::endl;\n\n        int valread;\n        while ((valread = read(new_socket, buffer, 1024)) > 0) {\n            std::cout << \"Received: \" << buffer << std::endl;\n            send(new_socket, buffer, valread, 0);\n            memset(buffer, 0, 1024);\n        }\n\n        std::cout << \"Client disconnected\" << std::endl;\n        close(new_socket);\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server is listening on \" << ip << \":\" << port << std::endl;\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Accept failed\" << std::endl;\n            close(server_fd);\n            return -1;\n        }\n\n        std::cout << \"New connection accepted\" << std::endl;\n\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            close(new_socket);\n            continue;\n        }\n\n        std::cout << \"Received: \" << buffer << std::endl;\n\n        send(new_socket, buffer, strlen(buffer), 0);\n        std::cout << \"Echoed back to client\" << std::endl;\n\n        close(new_socket);\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Accept failed\" << std::endl;\n            close(server_fd);\n            return -1;\n        }\n\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            close(new_socket);\n            continue;\n        }\n\n        send(new_socket, buffer, valread, 0);\n        close(new_socket);\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Accept failed\" << std::endl;\n            close(server_fd);\n            return -1;\n        }\n\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            close(new_socket);\n            continue;\n        }\n\n        send(new_socket, buffer, valread, 0);\n        close(new_socket);\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n        std::cerr << \"Accept failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    while (true) {\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            break;\n        }\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n        std::cerr << \"Accept failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    while (true) {\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            break;\n        }\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Accept failed\" << std::endl;\n            close(server_fd);\n            return -1;\n        }\n\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            close(new_socket);\n            continue;\n        }\n\n        send(new_socket, buffer, valread, 0);\n        close(new_socket);\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n        std::cerr << \"Accept failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    while (true) {\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            break;\n        }\n        send(new_socket, buffer, valread, 0);\n        memset(buffer, 0, sizeof(buffer));\n    }\n\n    close(new_socket);\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server is listening on \" << ip << \":\" << port << std::endl;\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Accept failed\" << std::endl;\n            close(server_fd);\n            return -1;\n        }\n\n        std::cout << \"New connection accepted\" << std::endl;\n\n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            std::cerr << \"Client disconnected\" << std::endl;\n            close(new_socket);\n            continue;\n        }\n\n        std::cout << \"Received: \" << buffer << std::endl;\n\n        send(new_socket, buffer, valread, 0);\n        close(new_socket);\n    }\n\n    close(server_fd);\n    return 0;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "matched_results": [],
    "unmatched_results": [
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <stdexcept>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    bool connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            throw std::runtime_error(\"Failed to initialize Winsock\");\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            WSACleanup();\n            throw std::runtime_error(\"Failed to get address info\");\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            server_sock[socket_count] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET) {\n                continue;\n            }\n\n            int optval = 1;\n            setsockopt(server_sock[socket_count], SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(optval));\n\n            if (bind(server_sock[socket_count], p->ai_addr, (int)p->ai_addrlen) == 0) {\n                break;\n            }\n\n            closesocket(server_sock[socket_count]);\n            server_sock[socket_count] = INVALID_SOCKET;\n        }\n\n        freeaddrinfo(servinfo);\n\n        if (server_sock[socket_count] == INVALID_SOCKET) {\n            WSACleanup();\n            throw std::runtime_error(\"Failed to bind socket\");\n        }\n\n        if (listen(server_sock[socket_count], SOMAXCONN) == SOCKET_ERROR) {\n            closesocket(server_sock[socket_count]);\n            WSACleanup();\n            throw std::runtime_error(\"Failed to listen on socket\");\n        }\n\n        server_listening = true;\n        server_online = true;\n\n        ConnectionThread[socket_count] = new std::thread(ConnectionThreadFunction, socket_count);\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_listening = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i] != nullptr) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        WSACleanup();\n        server_online = false;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_listening) {\n            SOCKET client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket == INVALID_SOCKET) continue;\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_socket;\n            client_info->connected = true;\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::cout << \"Client connected: \" << inet_ntoa(client_info->socket) << std::endl;\n\n            std::thread listen_thread(ListenThreadFunction, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 };\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == -1) {\n            return INVALID_SOCKET;\n        } else if (select_result == 0) {\n            return INVALID_SOCKET;\n        }\n\n        sockaddr_in client_addr;\n        int client_len = sizeof(client_addr);\n        SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n\n        if (client_socket == INVALID_SOCKET) {\n            return INVALID_SOCKET;\n        }\n\n        char ip[INET6_ADDRSTRLEN];\n        inet_ntop(AF_INET, &(client_addr.sin_addr), ip, sizeof(ip));\n        std::cout << \"Accepted connection from \" << ip << std::endl;\n\n        return client_socket;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->connected) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                client_info->connected = false;\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                delete client_info;\n                std::cout << \"Client disconnected: \" << client_info->ip << std::endl;\n                break;\n            }\n\n            std::cout << \"Received data from client: \" << buffer << std::endl;\n            // Process data as needed\n        }\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <mutex>\n#include <thread>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    std::atomic<bool> connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            std::cerr << \"Failed to initialize Winsock\" << std::endl;\n            return;\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            std::cerr << \"getaddrinfo failed\" << std::endl;\n            WSACleanup();\n            return;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            server_sock[socket_count] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET) {\n                std::cerr << \"Socket creation failed\" << std::endl;\n                continue;\n            }\n\n            if (bind(server_sock[socket_count], p->ai_addr, (int)p->ai_addrlen) == SOCKET_ERROR) {\n                std::cerr << \"Bind failed\" << std::endl;\n                closesocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            if (listen(server_sock[socket_count], SOMAXCONN) == SOCKET_ERROR) {\n                std::cerr << \"Listen failed\" << std::endl;\n                closesocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            std::cout << \"Server started on \" << host << \":\" << port_num << std::endl;\n            server_listening = true;\n            server_online = true;\n            socket_count++;\n\n            break;\n        }\n\n        freeaddrinfo(servinfo);\n\n        if (server_sock[0] == INVALID_SOCKET) {\n            std::cerr << \"Failed to bind server socket\" << std::endl;\n            WSACleanup();\n            return;\n        }\n\n        ConnectionThread[0] = new std::thread(ConnectionThreadFunction, 0);\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_online = false;\n        server_listening = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                shutdown(server_sock[i], SD_BOTH);\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i] != nullptr) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        WSACleanup();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online && server_listening) {\n            SOCKET client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket == INVALID_SOCKET) {\n                continue;\n            }\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_socket;\n            client_info->connected = true;\n\n            char ip[INET6_ADDRSTRLEN];\n            sockaddr_in6* sin6 = reinterpret_cast<sockaddr_in6*>(client_socket);\n            inet_ntop(AF_INET6, &sin6->sin6_addr, ip, sizeof(ip));\n            client_info->ip = ip;\n            client_info->port = ntohs(sin6->sin6_port);\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::thread listen_thread(ListenThreadFunction, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 };\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == -1) {\n            std::cerr << \"Select failed\" << std::endl;\n            return INVALID_SOCKET;\n        } else if (select_result == 0) {\n            std::cerr << \"Timeout on accept\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        sockaddr_in6 client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n        if (client_socket == INVALID_SOCKET) {\n            std::cerr << \"Accept failed\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        return client_socket;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->connected.load()) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                client_info->connected = false;\n                break;\n            }\n\n            // Process received data\n            std::cout << \"Received: \" << std::string(buffer, bytes_received) << std::endl;\n        }\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <stdexcept>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    bool connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            throw std::runtime_error(\"Failed to initialize Winsock\");\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            WSACleanup();\n            throw std::runtime_error(\"Failed to get address info\");\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            server_sock[socket_count] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET) {\n                continue;\n            }\n\n            int opt = 1;\n            if (setsockopt(server_sock[socket_count], SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt)) == SOCKET_ERROR) {\n                closesocket(server_sock[socket_count]);\n                continue;\n            }\n\n            if (bind(server_sock[socket_count], p->ai_addr, (int)p->ai_addrlen) == SOCKET_ERROR) {\n                closesocket(server_sock[socket_count]);\n                continue;\n            }\n\n            if (listen(server_sock[socket_count], SOMAXCONN) == SOCKET_ERROR) {\n                closesocket(server_sock[socket_count]);\n                continue;\n            }\n\n            std::cout << \"Server listening on \" << host << \":\" << port_num << std::endl;\n            server_listening = true;\n            server_online = true;\n            socket_count++;\n            break;\n        }\n\n        freeaddrinfo(servinfo);\n\n        if (!server_listening) {\n            WSACleanup();\n            throw std::runtime_error(\"Failed to bind server socket\");\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            ConnectionThread[i] = new std::thread(ConnectionThreadFunction, i);\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_online = false;\n        server_listening = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i] != nullptr) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        WSACleanup();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            SOCKET client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket == INVALID_SOCKET) {\n                continue;\n            }\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_socket;\n            client_info->connected = true;\n\n            char ip_buffer[INET6_ADDRSTRLEN];\n            sockaddr_in6* sin6 = reinterpret_cast<sockaddr_in6*>(client_socket);\n            inet_ntop(AF_INET6, &sin6->sin6_addr, ip_buffer, sizeof(ip_buffer));\n            client_info->ip = std::string(ip_buffer);\n            client_info->port = ntohs(sin6->sin6_port);\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::thread listen_thread(ListenThreadFunction, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 }; // 5 seconds\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n        if (select_result == -1) {\n            return INVALID_SOCKET;\n        } else if (select_result == 0) {\n            return INVALID_SOCKET;\n        }\n\n        sockaddr_in6 client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &addr_len);\n        if (client_socket == INVALID_SOCKET) {\n            return INVALID_SOCKET;\n        }\n\n        return client_socket;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->connected && server_online) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                client_info->connected = false;\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                delete client_info;\n                break;\n            }\n\n            // Process received data\n            std::cout << \"Received: \" << std::string(buffer, bytes_received) << std::endl;\n        }\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nstruct RGBController;\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    std::atomic<bool> is_connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            std::cerr << \"Failed to initialize Winsock\" << std::endl;\n            return;\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            std::cerr << \"getaddrinfo failed\" << std::endl;\n            WSACleanup();\n            return;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            SOCKET sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (sock == INVALID_SOCKET) {\n                std::cerr << \"Socket creation failed\" << std::endl;\n                continue;\n            }\n\n            if (bind(sock, p->ai_addr, (int)p->ai_addrlen) == SOCKET_ERROR) {\n                std::cerr << \"Bind failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {\n                std::cerr << \"Listen failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            server_sock[socket_count++] = sock;\n            server_listening = true;\n            server_online = true;\n\n            std::thread t(ConnectionThreadFunction, socket_count - 1);\n            ConnectionThread[socket_count - 1] = &t;\n            t.detach();\n\n            break;\n        }\n\n        freeaddrinfo(servinfo);\n        WSACleanup();\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                shutdown(server_sock[i], SD_BOTH);\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i] != nullptr) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        server_online = false;\n        server_listening = false;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online && server_listening) {\n            SOCKET client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket == INVALID_SOCKET) {\n                continue;\n            }\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_socket;\n            client_info->is_connected = true;\n\n            char ip_buffer[INET6_ADDRSTRLEN];\n            sockaddr_in6* sin6 = reinterpret_cast<sockaddr_in6*>(malloc(sizeof(sockaddr_in6)));\n            socklen_t sin6_len = sizeof(*sin6);\n            getpeername(client_socket, reinterpret_cast<sockaddr*>(sin6), &sin6_len);\n\n            if (sin6->sin6_family == AF_INET6) {\n                inet_ntop(AF_INET6, &sin6->sin6_addr, ip_buffer, sizeof(ip_buffer));\n            } else {\n                inet_ntop(AF_INET, &sin6->sin_addr, ip_buffer, sizeof(ip_buffer));\n            }\n\n            client_info->ip = ip_buffer;\n            client_info->port = ntohs(sin6->sin6_port);\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::thread listen_thread(ListenThreadFunction, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 };\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == SOCKET_ERROR) {\n            return INVALID_SOCKET;\n        }\n\n        if (select_result == 0) {\n            return INVALID_SOCKET;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            sockaddr_in6 client_addr;\n            socklen_t client_len = sizeof(client_addr);\n            SOCKET client_socket = accept(sockfd, reinterpret_cast<sockaddr*>(&client_addr), &client_len);\n            if (client_socket == INVALID_SOCKET) {\n                return INVALID_SOCKET;\n            }\n            return client_socket;\n        }\n\n        return INVALID_SOCKET;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->is_connected.load()) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                client_info->is_connected = false;\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                delete client_info;\n                break;\n            }\n\n            // Process received data\n        }\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nstruct RGBController;\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    bool connected;\n    std::atomic<bool> active;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            std::cerr << \"Failed to initialize Winsock\" << std::endl;\n            return;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            std::cerr << \"Failed to get address info\" << std::endl;\n            WSACleanup();\n            return;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            SOCKET sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (sock == INVALID_SOCKET) {\n                std::cerr << \"Failed to create socket\" << std::endl;\n                continue;\n            }\n\n            if (bind(sock, p->ai_addr, (int)p->ai_addrlen) == SOCKET_ERROR) {\n                std::cerr << \"Bind failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {\n                std::cerr << \"Listen failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            server_sock[socket_count++] = sock;\n            server_listening = true;\n            server_online = true;\n\n            std::thread t(ConnectionThreadFunction, socket_count - 1);\n            ConnectionThread[socket_count - 1] = &t;\n            t.detach();\n\n            break;\n        }\n\n        freeaddrinfo(servinfo);\n        WSACleanup();\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        for (int i = 0; i < socket_count; ++i) {\n            closesocket(server_sock[i]);\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n            }\n        }\n\n        server_online = false;\n        server_listening = false;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online && server_listening) {\n            SOCKET client_sock = accept_select(server_sock[socket_idx]);\n            if (client_sock == INVALID_SOCKET) {\n                std::cerr << \"Accept failed\" << std::endl;\n                continue;\n            }\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_sock;\n            client_info->connected = true;\n            client_info->active = true;\n            client_info->ip = \"\";\n            client_info->port = 0;\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::thread listen_thread(ListenThreadFunction, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 }; // 5 seconds timeout\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == -1) {\n            std::cerr << \"Select failed\" << std::endl;\n            return INVALID_SOCKET;\n        } else if (select_result == 0) {\n            std::cerr << \"Timeout on accept\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            sockaddr_in client_addr;\n            int client_len = sizeof(client_addr);\n            SOCKET client_sock = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n            if (client_sock == INVALID_SOCKET) {\n                std::cerr << \"Accept failed\" << std::endl;\n                return INVALID_SOCKET;\n            }\n\n            char ip[INET6_ADDRSTRLEN];\n            inet_ntop(AF_INET, &client_addr.sin_addr, ip, sizeof(ip));\n            client_info->ip = ip;\n            client_info->port = ntohs(client_addr.sin_port);\n\n            return client_sock;\n        }\n\n        return INVALID_SOCKET;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->active.load()) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                std::cerr << \"Client disconnected\" << std::endl;\n                client_info->connected = false;\n                client_info->active = false;\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                delete client_info;\n                break;\n            }\n\n            // Process received data\n            std::cout << \"Received: \" << std::string(buffer, bytes_received) << std::endl;\n        }\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <WS2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    bool connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            std::cerr << \"Failed to initialize Winsock\" << std::endl;\n            return;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            std::cerr << \"Failed to get address info\" << std::endl;\n            WSACleanup();\n            return;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            SOCKET sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (sock == INVALID_SOCKET) {\n                std::cerr << \"Failed to create socket\" << std::endl;\n                continue;\n            }\n\n            if (bind(sock, p->ai_addr, (int)p->ai_addrlen) == SOCKET_ERROR) {\n                std::cerr << \"Bind failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {\n                std::cerr << \"Listen failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            server_sock[socket_count++] = sock;\n            server_listening = true;\n            server_online = true;\n\n            std::thread t(ConnectionThreadFunction, socket_count - 1);\n            ConnectionThread[socket_count - 1] = &t;\n            t.detach();\n\n            break;\n        }\n\n        freeaddrinfo(servinfo);\n        WSACleanup();\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        for (int i = 0; i < socket_count; ++i) {\n            closesocket(server_sock[i]);\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n            }\n        }\n\n        server_online = false;\n        server_listening = false;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online && server_listening) {\n            int sockfd = server_sock[socket_idx];\n            sockaddr_in client_addr;\n            int client_len = sizeof(client_addr);\n            SOCKET client_sock = accept_select(sockfd);\n\n            if (client_sock == INVALID_SOCKET) {\n                std::cerr << \"Accept failed\" << std::endl;\n                continue;\n            }\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_sock;\n            client_info->connected = true;\n            client_info->ip = inet_ntoa(client_addr.sin_addr);\n            client_info->port = ntohs(client_addr.sin_port);\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::thread listen_thread(ListenThreadFunction, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 }; // 5 seconds timeout\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == SOCKET_ERROR) {\n            std::cerr << \"Select failed\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        if (select_result == 0) {\n            std::cerr << \"Timeout on accept\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        sockaddr_in client_addr;\n        int client_len = sizeof(client_addr);\n        SOCKET client_sock = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n\n        if (client_sock == INVALID_SOCKET) {\n            std::cerr << \"Accept failed\" << std::endl;\n        }\n\n        return client_sock;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Callback implementation\n    }\n\n    void ServerListeningChanged() {\n        // Callback implementation\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->connected && server_online) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                client_info->connected = false;\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                delete client_info;\n                break;\n            }\n\n            // Process received data\n            std::cout << \"Received: \" << std::string(buffer, bytes_received) << std::endl;\n        }\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <stdexcept>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    bool connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            throw std::runtime_error(\"Failed to initialize Winsock\");\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            WSACleanup();\n            throw std::runtime_error(\"Failed to get address info\");\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            server_sock[socket_count] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET) {\n                continue;\n            }\n\n            int optval = 1;\n            setsockopt(server_sock[socket_count], SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(optval));\n\n            if (bind(server_sock[socket_count], p->ai_addr, (int)p->ai_addrlen) == SOCKET_ERROR) {\n                closesocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            break;\n        }\n\n        freeaddrinfo(servinfo);\n\n        if (server_sock[socket_count] == INVALID_SOCKET) {\n            WSACleanup();\n            throw std::runtime_error(\"Failed to bind socket\");\n        }\n\n        if (listen(server_sock[socket_count], SOMAXCONN) == SOCKET_ERROR) {\n            closesocket(server_sock[socket_count]);\n            WSACleanup();\n            throw std::runtime_error(\"Failed to listen on socket\");\n        }\n\n        server_listening = true;\n        server_online = true;\n\n        ConnectionThread[socket_count] = new std::thread(ConnectionThreadFunction, socket_count);\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_listening = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i] != nullptr) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        WSACleanup();\n        server_online = false;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_listening) {\n            SOCKET client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket == INVALID_SOCKET) continue;\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_socket;\n            client_info->connected = true;\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::thread listen_thread(ListenThreadFunction, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 }; // 5 seconds timeout\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == -1) {\n            return INVALID_SOCKET;\n        } else if (select_result == 0) {\n            return INVALID_SOCKET;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            sockaddr_in client_addr;\n            int client_len = sizeof(client_addr);\n            SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n            if (client_socket == INVALID_SOCKET) {\n                return INVALID_SOCKET;\n            }\n\n            char ip[INET6_ADDRSTRLEN];\n            inet_ntop(AF_INET, &(client_addr.sin_addr), ip, sizeof(ip));\n            std::string client_ip(ip);\n            unsigned short client_port = ntohs(client_addr.sin_port);\n\n            return client_socket;\n        }\n\n        return INVALID_SOCKET;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->connected) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                client_info->connected = false;\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                delete client_info;\n                break;\n            }\n\n            // Process received data\n            std::cout << \"Received: \" << std::string(buffer, bytes_received) << std::endl;\n        }\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    std::atomic<bool> connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            std::cerr << \"Failed to initialize Winsock\" << std::endl;\n            return;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            std::cerr << \"Failed to get address info\" << std::endl;\n            WSACleanup();\n            return;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            SOCKET sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (sock == INVALID_SOCKET) {\n                std::cerr << \"Failed to create socket\" << std::endl;\n                continue;\n            }\n\n            if (bind(sock, p->ai_addr, (int)p->ai_addrlen) == SOCKET_ERROR) {\n                std::cerr << \"Bind failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {\n                std::cerr << \"Listen failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            server_sock[socket_count++] = sock;\n            server_listening = true;\n            server_online = true;\n\n            ConnectionThread[socket_count - 1] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, socket_count - 1);\n\n            freeaddrinfo(servinfo);\n            break;\n        }\n\n        if (!server_listening) {\n            std::cerr << \"Failed to start server\" << std::endl;\n            WSACleanup();\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n            }\n            closesocket(server_sock[i]);\n        }\n\n        server_online = false;\n        server_listening = false;\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            SOCKET client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket == INVALID_SOCKET) continue;\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_socket;\n            client_info->connected = true;\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::cout << \"Client connected: \" << inet_ntoa(inet_addr(client_info->ip.c_str())) << \":\" << client_info->port << std::endl;\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 };\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == SOCKET_ERROR) {\n            std::cerr << \"Select failed\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        if (select_result == 0) {\n            std::cerr << \"Timeout on accept\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        sockaddr_in client_addr;\n        int client_len = sizeof(client_addr);\n        SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n\n        if (client_socket == INVALID_SOCKET) {\n            std::cerr << \"Accept failed\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        char ip[INET6_ADDRSTRLEN];\n        inet_ntop(AF_INET, &(client_addr.sin_addr), ip, sizeof(ip));\n        client_info->ip = ip;\n        client_info->port = ntohs(client_addr.sin_port);\n\n        return client_socket;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        // Implementation for handling communication with a specific client\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <stdexcept>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    bool connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            throw std::runtime_error(\"Failed to initialize Winsock\");\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        int status = getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo);\n        if (status != 0) {\n            WSACleanup();\n            throw std::runtime_error(\"getaddrinfo failed with error: \" + std::string(gai_strerror(status)));\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            server_sock[socket_count] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET) {\n                continue;\n            }\n\n            int optval = 1;\n            setsockopt(server_sock[socket_count], SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(optval));\n\n            if (bind(server_sock[socket_count], p->ai_addr, (int)p->ai_addrlen) == 0) {\n                break;\n            }\n\n            closesocket(server_sock[socket_count]);\n            server_sock[socket_count] = INVALID_SOCKET;\n        }\n\n        freeaddrinfo(servinfo);\n\n        if (server_sock[socket_count] == INVALID_SOCKET) {\n            WSACleanup();\n            throw std::runtime_error(\"Failed to bind socket\");\n        }\n\n        if (listen(server_sock[socket_count], SOMAXCONN) == SOCKET_ERROR) {\n            closesocket(server_sock[socket_count]);\n            WSACleanup();\n            throw std::runtime_error(\"Listen failed with error: \" + std::to_string(WSAGetLastError()));\n        }\n\n        server_listening = true;\n        server_online = true;\n\n        ConnectionThread[socket_count] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, socket_count);\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_listening = false;\n        server_online = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i] != nullptr) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        WSACleanup();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_listening) {\n            SOCKET client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket == INVALID_SOCKET) {\n                continue;\n            }\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_socket;\n            client_info->connected = true;\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::thread listen_thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 }; // 5 seconds timeout\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == -1) {\n            return INVALID_SOCKET;\n        } else if (select_result == 0) {\n            return INVALID_SOCKET;\n        } else {\n            sockaddr_in client_addr;\n            int client_len = sizeof(client_addr);\n            SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n            if (client_socket == INVALID_SOCKET) {\n                return INVALID_SOCKET;\n            }\n\n            char ip[INET6_ADDRSTRLEN];\n            inet_ntop(client_addr.sin_family, &client_addr.sin_addr, ip, sizeof(ip));\n            unsigned short port = ntohs(client_addr.sin_port);\n            std::cout << \"Accepted connection from \" << ip << \":\" << port << std::endl;\n\n            return client_socket;\n        }\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->connected) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                client_info->connected = false;\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                delete client_info;\n                break;\n            }\n\n            buffer[bytes_received] = '\\0';\n            std::cout << \"Received: \" << buffer << std::endl;\n\n            // Process data and update RGB controllers\n            for (auto& controller : controllers) {\n                controller->Update(buffer);\n            }\n        }\n    }\n};",
      "#include <iostream>\n#include <vector>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define MAXSOCK 1024\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    std::string ip;\n    unsigned short port;\n    bool connected;\n};\n\nclass NetworkServer {\npublic:\n    std::string host;\n    unsigned short port_num;\n    std::atomic<bool> server_online;\n    std::atomic<bool> server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n    std::vector<RGBController*>& controllers;\n\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control), server_online(false), server_listening(false), socket_count(0) {}\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            std::cerr << \"Failed to initialize Winsock\" << std::endl;\n            return;\n        }\n\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n        }\n\n        struct addrinfo hints, *servinfo, *p;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &servinfo) != 0) {\n            std::cerr << \"getaddrinfo failed\" << std::endl;\n            WSACleanup();\n            return;\n        }\n\n        for (p = servinfo; p != nullptr; p = p->ai_next) {\n            SOCKET sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (sock == INVALID_SOCKET) {\n                std::cerr << \"Socket creation failed\" << std::endl;\n                continue;\n            }\n\n            if (bind(sock, p->ai_addr, (int)p->ai_addrlen) == SOCKET_ERROR) {\n                std::cerr << \"Bind failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {\n                std::cerr << \"Listen failed\" << std::endl;\n                closesocket(sock);\n                continue;\n            }\n\n            server_sock[socket_count++] = sock;\n            std::cout << \"Server listening on \" << host << \":\" << port_num << std::endl;\n            break;\n        }\n\n        freeaddrinfo(servinfo);\n        server_listening = true;\n        server_online = true;\n\n        for (int i = 0; i < socket_count; ++i) {\n            ConnectionThread[i] = new std::thread(ConnectionThreadFunction, i);\n        }\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n\n        server_online = false;\n        server_listening = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n            }\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                closesocket(server_sock[i]);\n            }\n        }\n\n        WSACleanup();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            if (socket_idx >= socket_count) continue;\n\n            SOCKET client_socket = accept_select(server_sock[socket_idx]);\n            if (client_socket == INVALID_SOCKET) continue;\n\n            sockaddr_in client_addr;\n            int client_len = sizeof(client_addr);\n            getsockname(client_socket, (sockaddr*)&client_addr, &client_len);\n            std::string ip = inet_ntoa(client_addr.sin_addr);\n            unsigned short port = ntohs(client_addr.sin_port);\n\n            NetworkClientInfo* client_info = new NetworkClientInfo();\n            client_info->socket = client_socket;\n            client_info->ip = ip;\n            client_info->port = port;\n            client_info->connected = true;\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::cout << \"Client connected: \" << ip << \":\" << port << std::endl;\n\n            std::thread listen_thread(ListenThreadFunction, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout = { 5, 0 }; // 5 seconds timeout\n        int select_result = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n\n        if (select_result == -1) {\n            std::cerr << \"Select error\" << std::endl;\n            return INVALID_SOCKET;\n        } else if (select_result == 0) {\n            std::cerr << \"Timeout on accept\" << std::endl;\n            return INVALID_SOCKET;\n        }\n\n        if (FD_ISSET(sockfd, &readfds)) {\n            sockaddr_in client_addr;\n            int client_len = sizeof(client_addr);\n            SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n            if (client_socket == INVALID_SOCKET) {\n                std::cerr << \"Accept failed\" << std::endl;\n                return INVALID_SOCKET;\n            }\n            return client_socket;\n        }\n\n        return INVALID_SOCKET;\n    }\n\n    unsigned short GetPort() {\n        return port_num;\n    }\n\n    void ClientInfoChanged() {\n        // Implementation for client list changes\n    }\n\n    void ServerListeningChanged() {\n        // Implementation for server listening state changes\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (client_info->connected && server_online) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                client_info->connected = false;\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n                if (it != ServerClients.end()) {\n                    ServerClients.erase(it);\n                }\n                std::cout << \"Client disconnected: \" << client_info->ip << \":\" << client_info->port << std::endl;\n                break;\n            }\n\n            std::cout << \"Received from \" << client_info->ip << \":\" << client_info->port << \": \" << std::string(buffer, bytes_received) << std::endl;\n            send(client_info->socket, buffer, bytes_received, 0);\n        }\n\n        closesocket(client_info->socket);\n        delete client_info;\n    }\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Implement a TCP server in C++ that listens for incoming connections, handles client requests in separate child processes, and responds to clients after processing their data.\n\nFunction Description: The function `tcp_server_communication` creates a TCP server that binds to a specified port, listens for incoming connections, and forks child processes to handle each client connection. Each child process reads a character from the client, increments it after a delay, and sends it back before terminating.\n\nInput: None (The function uses predefined constants: port number 9736 and INADDR_ANY for binding to all available network interfaces)\n\nOutput: None (The function runs indefinitely, servicing client requests and doesn't return any value)\n\nNote: The function includes signal handling to prevent zombie processes from terminated child processes. Each client connection is handled in a separate child process while the parent process continues to accept new connections.",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <signal.h>\n\nvoid tcp_server_communication()\n{\n    int server_sockfd = -1;\n    int client_sockfd = -1;\n    int client_len = 0;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n    \n    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(9736);\n    \n    bind(server_sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(server_sockfd, 5);\n    signal(SIGCHLD, SIG_IGN);\n\n    while(1)\n    {\n        char ch = '\\0';\n        client_len = sizeof(client_addr);\n        client_sockfd = accept(server_sockfd, (struct sockaddr*)&client_addr,\n                               (socklen_t *)&client_len);\n\n        if(fork() == 0)\n        {\n            read(client_sockfd, &ch, 1);\n            sleep(5);\n            ch++;\n            write(client_sockfd, &ch, 1);\n            close(client_sockfd);\n            exit(0);\n        }\n        else\n        {\n            close(client_sockfd);\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "matched_results": [
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    int opt = 1;\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                buffer[0]++;\n                write(new_socket, buffer, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server is listening on port 9736\\n\";\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept failed\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork failed\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                char response = buffer[0] + 1;\n                write(new_socket, &response, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server is listening on port 9736\\n\";\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept failed\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork failed\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                char response = buffer[0] + 1;\n                write(new_socket, &response, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    int opt = 1;\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    std::cout << \"Server is listening on port 9736\\n\";\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                buffer[0]++;\n                write(new_socket, buffer, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    int opt = 1;\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                buffer[0]++;\n                write(new_socket, buffer, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    int opt = 1;\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    std::cout << \"Server is listening on port 9736\\n\";\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                buffer[0]++;\n                write(new_socket, buffer, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    int opt = 1;\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    std::cout << \"Server is listening on port 9736\\n\";\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                buffer[0]++;\n                write(new_socket, buffer, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    int opt = 1;\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    std::cout << \"Server is listening on port 9736\\n\";\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                buffer[0]++;\n                write(new_socket, buffer, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server is listening on port 9736\\n\";\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept failed\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork failed\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 0.1 second delay\n                char response = buffer[0] + 1;\n                write(new_socket, &response, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}",
      "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <cstring>\n\nvoid handle_signal(int) {\n    while (waitpid(-1, nullptr, WNOHANG) > 0);\n}\n\nint tcp_server_communication() {\n    signal(SIGCHLD, handle_signal);\n\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen failed\");\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server is listening on port 9736\\n\";\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"accept failed\");\n            continue;\n        }\n\n        pid_t child_pid = fork();\n\n        if (child_pid < 0) {\n            perror(\"fork failed\");\n            close(new_socket);\n            continue;\n        } else if (child_pid == 0) {\n            char buffer[1];\n            ssize_t bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read > 0) {\n                usleep(100000); // 100ms delay\n                char response = buffer[0] + 1;\n                write(new_socket, &response, 1);\n            }\n            close(new_socket);\n            exit(0);\n        } else {\n            close(new_socket);\n        }\n    }\n\n    close(server_fd);\n    return 0;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Implement a TCP server using UNIX domain sockets for inter-process communication that manages and provides access to statistics data. The server should handle multiple client connections concurrently, process different types of requests (get, reset, etc.), and maintain thread safety.\n\nClass Description: The Stats class implements a TCP server using UNIX domain sockets to manage and provide access to statistics data. It handles client connections, processes requests, and maintains thread safety for concurrent access to statistics.\n\nAttributes:\n- stats_socket_path_: std::string - Path to the UNIX domain socket file\n- sockfd_: int - File descriptor for the server socket\n- serv_addr_: sockaddr_un - Server address structure\n- stats_thread_: std::thread - Thread for running the socket server\n- statsThreadRunning_: std::atomic<bool> - Flag to control the server thread's execution\n- stats_mutex_: std::mutex - Mutex for protecting access to statistics data\n- thread_mutex_: std::mutex - Mutex for protecting thread count\n- thread_exited_: std::condition_variable - Condition variable for thread synchronization\n- thread_count_: int - Count of active threads\n- stats_: std::unordered_map<std::string, int> - Container for storing statistics data\n\nMethods:\n- Stats(const std::string& stats_socket_path) -> None - Constructor that initializes the socket server\n- ~Stats() -> None - Destructor that cleans up resources\n- get(const std::string& stats_socket_path) -> Stats& - Static method to get the singleton instance\n- get_for_unittest(const std::string& stats_socket_path) -> std::unique_ptr<Stats> - Static method to get an instance for unit testing\n- init(const std::string& stats_socket_path) -> bool - Static method to initialize the singleton\n- isInit() -> bool - Static method to check if the singleton is initialized\n- getAll() -> std::unordered_map<std::string, int> - Returns all statistics data\n- increment(const std::string& key, int val) -> int - Increments a statistic value\n- set(const std::string& key, int val) -> int - Sets a statistic value\n- reset() -> int - Resets all statistics\n- startSocket() -> bool - Starts the socket server\n- runSocket() -> void - Main server loop that accepts connections\n- processMsg(int sockfd) -> void - Processes a client message\n- isInitInternal() -> bool& - Internal static method for initialization status",
    "Canonical_solution": "#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n#include <json/value.h>\n\nnamespace Oomd {\n\nclass Stats {\npublic:\n  Stats(const std::string& stats_socket_path);\n  ~Stats();\n\n  static Stats& get(const std::string& stats_socket_path);\n  static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n  static bool init(const std::string& stats_socket_path);\n  static bool isInit();\n\n  std::unordered_map<std::string, int> getAll();\n  int increment(const std::string& key, int val);\n  int set(const std::string& key, int val);\n  int reset();\n\nprivate:\n  bool startSocket();\n  void runSocket();\n  void processMsg(int sockfd);\n  static bool& isInitInternal();\n\n  std::string stats_socket_path_;\n  int sockfd_{-1};\n  sockaddr_un serv_addr_{};\n  std::thread stats_thread_;\n  std::atomic<bool> statsThreadRunning_{true};\n  std::mutex stats_mutex_;\n  std::unordered_map<std::string, int> stats_;\n  std::mutex thread_mutex_;\n  std::condition_variable thread_exited_;\n  int thread_count_{0};\n};\n\nStats::Stats(const std::string& stats_socket_path)\n    : stats_socket_path_(stats_socket_path) {\n  if (!this->startSocket()) {\n    throw std::runtime_error(\"Socket thread failed to start\");\n  }\n}\n\nStats::~Stats() {\n  std::array<char, 64> err_buf = {};\n  statsThreadRunning_ = false;\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  if (!thread_exited_.wait_for(lock, std::chrono::seconds(5), [this] {\n        return this->thread_count_ == 0;\n      })) {\n    OCHECK(false);\n  }\n  lock.unlock();\n  if (stats_thread_.joinable()) {\n    stats_thread_.join();\n  }\n  if (::unlink(serv_addr_.sun_path) < 0) {\n    OLOG << \"Closing stats error: unlinking socket path: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  if (::close(sockfd_) < 0) {\n    OLOG << \"Closing stats error: closing stats socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n}\n\nbool Stats::startSocket() {\n  std::array<char, 64> err_buf = {};\n\n  sockfd_ = ::socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sockfd_ < 0) {\n    OLOG << \"Error creating socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size() - 1);\n    return false;\n  }\n  ::memset(&serv_addr_, '\\0', sizeof(serv_addr_));\n  serv_addr_.sun_family = AF_UNIX;\n  ::strcpy(serv_addr_.sun_path, stats_socket_path_.c_str());\n  if (::unlink(serv_addr_.sun_path) < 0 && errno != ENOENT) {\n    OLOG << \"Pre-unlinking of socket path failed. \" << serv_addr_.sun_path\n         << \". Errno: \" << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) < 0) {\n    OLOG << \"Error binding stats collection socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  if (::listen(sockfd_, 5) < 0) {\n    OLOG << \"Error listening at socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    return false;\n  }\n  stats_thread_ = std::thread([this] { this->runSocket(); });\n  return true;\n}\n\nvoid Stats::runSocket() {\n  sockaddr_un cli_addr;\n  socklen_t clilen = sizeof(cli_addr);\n  std::array<char, 64> err_buf = {};\n  while (statsThreadRunning_) {\n    int sockfd = ::accept(sockfd_, (struct sockaddr*)&cli_addr, &clilen);\n    if (sockfd < 0) {\n      OLOG << \"Stats server error: accepting connection: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      continue;\n    }\n    std::unique_lock<std::mutex> lock(thread_mutex_);\n    ++thread_count_;\n    std::thread msg_thread_ =\n        std::thread([this, sockfd] { this->processMsg(sockfd); });\n    msg_thread_.detach();\n    lock.unlock();\n    thread_exited_.notify_one();\n  }\n}\n\nvoid Stats::processMsg(int sockfd) {\n  std::array<char, 64> err_buf = {};\n  OOMD_SCOPE_EXIT {\n    if (::close(sockfd) < 0) {\n      OLOG << \"Stats server error: closing file descriptor: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n    }\n  };\n  char mode = 'a';\n  char byte_buf;\n  int num_read = 0;\n  for (; num_read < 32; num_read++) {\n    int res = ::read(sockfd, &byte_buf, 1);\n    if (res < 0) {\n      OLOG << \"Stats server error: reading from socket: \"\n           << ::strerror_r(errno, err_buf.data(), err_buf.size());\n      return;\n    } else if (res == 0) {\n      break;\n    }\n    if (byte_buf == '\\n' || byte_buf == '\\0') {\n      break;\n    }\n    if (num_read == 0) {\n      mode = byte_buf;\n    }\n  }\n\n  Json::Value root;\n  root[\"error\"] = 0;\n  Json::Value body(Json::objectValue);\n  switch (mode) {\n    case 'g':\n      for (auto const& pair : getAll()) {\n        body[pair.first] = pair.second;\n      }\n      break;\n    case 'r':\n      Stats::reset();\n      break;\n    case '0':\n      break;\n    default:\n      root[\"error\"] = 1;\n      OLOG << \"Stats server error: received unknown request: \" << mode;\n  }\n  root[\"body\"] = body;\n  std::string ret = root.toStyledString();\n  if (Util::writeFull(sockfd, ret.c_str(), strlen(ret.c_str())) < 0) {\n    OLOG << \"Stats server error: writing to socket: \"\n         << ::strerror_r(errno, err_buf.data(), err_buf.size());\n  }\n  std::unique_lock<std::mutex> lock(thread_mutex_);\n  thread_count_--;\n  lock.unlock();\n  thread_exited_.notify_one();\n}\n\n} // namespace Oomd",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <thread>\n#include <condition_variable>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n    bool isInitInternal();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), thread_count_(0), statsThreadRunning_(false) {\n    if (init(stats_socket_path)) {\n        std::cout << \"Stats server initialized.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to initialize Stats server.\" << std::endl;\n    }\n}\n\nStats::~Stats() {\n    if (statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!initialized_) {\n        if (!init(stats_socket_path)) {\n            throw std::runtime_error(\"Failed to initialize Stats server.\");\n        }\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    auto ptr = std::make_unique<Stats>(stats_socket_path);\n    if (!ptr->init(stats_socket_path)) {\n        ptr.reset();\n    }\n    return ptr;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return true;\n    }\n    if (stats_socket_path.empty()) {\n        std::cerr << \"Socket path cannot be empty.\" << std::endl;\n        return false;\n    }\n    if (access(stats_socket_path.c_str(), F_OK) == 0) {\n        unlink(stats_socket_path.c_str());\n    }\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        std::cerr << \"Failed to create socket.\" << std::endl;\n        return false;\n    }\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        std::cerr << \"Failed to bind socket.\" << std::endl;\n        close(sockfd_);\n        sockfd_ = -1;\n        return false;\n    }\n    if (listen(sockfd_, 5) == -1) {\n        std::cerr << \"Failed to listen on socket.\" << std::endl;\n        close(sockfd_);\n        sockfd_ = -1;\n        return false;\n    }\n    statsThreadRunning_ = true;\n    stats_thread_ = std::thread(&Stats::runSocket, this);\n    initialized_ = true;\n    instance_ = this;\n    return true;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    if (!statsThreadRunning_) {\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n    return false;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd == -1) {\n            continue;\n        }\n        ++thread_count_;\n        thread_exited_.notify_one();\n        std::thread([this, client_fd]() {\n            processMsg(client_fd);\n            --thread_count_;\n        }).detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n    buffer[bytes_read] = '\\0';\n    std::string request(buffer);\n    std::istringstream iss(request);\n    std::string cmd;\n    iss >> cmd;\n    if (cmd == \"GET\") {\n        std::string key;\n        iss >> key;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            std::string response = \"GET \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            std::string response = \"ERROR: Key not found\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"SET\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        std::string response = \"SET \" + key + \" \" + std::to_string(val) + \"\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else if (cmd == \"INCREMENT\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            it->second += val;\n            std::string response = \"INCREMENT \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            std::string response = \"ERROR: Key not found\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        std::string response = \"RESET\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else {\n        std::string response = \"UNKNOWN COMMAND\\n\";\n        write(sockfd, response.c_str(), response.size());\n    }\n    close(sockfd);\n}\n\nbool Stats::isInitInternal() {\n    return initialized_;\n}",
      "#include <iostream>\n#include <string>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <condition_variable>\n#include <unordered_map>\n#include <stdexcept>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n    bool isInitInternal();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), thread_count_(0), statsThreadRunning_(false) {\n    if (isInitInternal()) {\n        throw std::runtime_error(\"Stats instance already initialized\");\n    }\n}\n\nStats::~Stats() {\n    if (statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!isInitInternal()) {\n        init(stats_socket_path);\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    auto ptr = std::make_unique<Stats>(stats_socket_path);\n    if (!ptr->init(stats_socket_path)) {\n        return nullptr;\n    }\n    return ptr;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (isInitInternal()) {\n        return false;\n    }\n    instance_ = new Stats(stats_socket_path);\n    if (!instance_->startSocket()) {\n        delete instance_;\n        instance_ = nullptr;\n        return false;\n    }\n    initialized_ = true;\n    return true;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return false;\n    }\n\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n\n    if (unlink(stats_socket_path_.c_str()) == -1 && errno != ENOENT) {\n        std::cerr << \"Failed to remove existing socket\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        std::cerr << \"Failed to bind socket\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    if (listen(sockfd_, 5) == -1) {\n        std::cerr << \"Failed to listen on socket\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    statsThreadRunning_ = true;\n    stats_thread_ = std::thread(&Stats::runSocket, this);\n    return true;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd == -1) {\n            continue;\n        }\n\n        std::lock_guard<std::mutex> lock(thread_mutex_);\n        thread_count_++;\n        std::thread t(&Stats::processMsg, this, client_fd);\n        t.detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n\n    std::string request(buffer, bytes_read);\n    std::istringstream iss(request);\n    std::string cmd;\n    iss >> cmd;\n\n    if (cmd == \"GET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        std::string key;\n        iss >> key;\n        if (!key.empty()) {\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                std::string response = \"GET \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                write(sockfd, \"NOTFOUND\\n\", 10);\n            }\n        } else {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            std::string response;\n            for (const auto& pair : stats_) {\n                response += \"GET \" + pair.first + \" \" + std::to_string(pair.second) + \"\\n\";\n            }\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"INCREMENT\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                it->second += val;\n                std::string response = \"INCREMENT \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                write(sockfd, \"NOTFOUND\\n\", 10);\n            }\n        }\n    } else if (cmd == \"SET\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] = val;\n            std::string response = \"SET \" + key + \" \" + std::to_string(val) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        write(sockfd, \"RESET\\n\", 6);\n    } else {\n        write(sockfd, \"UNKNOWN\\n\", 8);\n    }\n\n    close(sockfd);\n    std::lock_guard<std::mutex> lock(thread_mutex_);\n    thread_count_--;\n}\n\nbool Stats::isInitInternal() {\n    return initialized_;\n}",
      "#include <iostream>\n#include <string>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <condition_variable>\n#include <unordered_map>\n#include <stdexcept>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n\n    bool initInternal();\n    void handleClient(int sockfd);\n    void cleanup();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), thread_count_(0), statsThreadRunning_(false) {\n    if (initInternal()) {\n        startSocket();\n    }\n}\n\nStats::~Stats() {\n    cleanup();\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!initialized_) {\n        throw std::runtime_error(\"Stats not initialized\");\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    auto ptr = std::make_unique<Stats>(stats_socket_path);\n    if (ptr->initInternal()) {\n        ptr->startSocket();\n    }\n    return ptr;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return true;\n    }\n    instance_ = new Stats(stats_socket_path);\n    if (instance_->initInternal()) {\n        instance_->startSocket();\n        initialized_ = true;\n        return true;\n    }\n    delete instance_;\n    instance_ = nullptr;\n    return false;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    if (sockfd_ != -1) {\n        return true;\n    }\n    unlink(stats_socket_path_.c_str());\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        return false;\n    }\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        close(sockfd_);\n        sockfd_ = -1;\n        return false;\n    }\n    if (listen(sockfd_, 5) == -1) {\n        close(sockfd_);\n        sockfd_ = -1;\n        return false;\n    }\n    return true;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd == -1) {\n            continue;\n        }\n        ++thread_count_;\n        std::thread([this, client_fd]() {\n            processMsg(client_fd);\n            std::lock_guard<std::mutex> lock(thread_mutex_);\n            --thread_count_;\n            thread_exited_.notify_one();\n        }).detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n    std::string request(buffer, bytes_read);\n    std::istringstream iss(request);\n    std::string cmd;\n    iss >> cmd;\n    if (cmd == \"GET\") {\n        std::string key;\n        iss >> key;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            std::string response = \"GET \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            std::string response = \"ERROR: Key not found\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"INCREMENT\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            it->second += val;\n            std::string response = \"INCREMENT \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            std::string response = \"ERROR: Key not found\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"SET\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        std::string response = \"SET \" + key + \" \" + std::to_string(val) + \"\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else if (cmd == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        std::string response = \"RESET\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else {\n        std::string response = \"UNKNOWN COMMAND\\n\";\n        write(sockfd, response.c_str(), response.size());\n    }\n    close(sockfd);\n}\n\nvoid Stats::cleanup() {\n    if (sockfd_ != -1) {\n        close(sockfd_);\n    }\n    if (initialized_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    if (stats_socket_path_.size() > 0) {\n        unlink(stats_socket_path_.c_str());\n    }\n}\n\nbool Stats::initInternal() {\n    if (startSocket()) {\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        statsThreadRunning_ = true;\n        return true;\n    }\n    return false;\n}",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <thread>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <condition_variable>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n    bool isInitInternal();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), thread_count_(0), statsThreadRunning_(false) {\n    if (init(stats_socket_path)) {\n        std::cout << \"Stats server initialized.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to initialize Stats server.\" << std::endl;\n    }\n}\n\nStats::~Stats() {\n    if (statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!isInit()) {\n        init(stats_socket_path);\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    auto ptr = std::make_unique<Stats>(stats_socket_path);\n    return ptr;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return true;\n    }\n    instance_ = new Stats(stats_socket_path);\n    if (!instance_->startSocket()) {\n        delete instance_;\n        instance_ = nullptr;\n        return false;\n    }\n    initialized_ = true;\n    return true;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        std::cerr << \"Failed to create socket.\" << std::endl;\n        return false;\n    }\n\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n\n    if (unlink(stats_socket_path_.c_str()) == -1 && errno != ENOENT) {\n        std::cerr << \"Failed to remove existing socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        std::cerr << \"Failed to bind socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    if (listen(sockfd_, 5) == -1) {\n        std::cerr << \"Failed to listen on socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    statsThreadRunning_ = true;\n    stats_thread_ = std::thread(&Stats::runSocket, this);\n    return true;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        int client_sock = accept(sockfd_, (struct sockaddr*)&client_addr, &addr_len);\n        if (client_sock == -1) {\n            continue;\n        }\n\n        std::lock_guard<std::mutex> lock(thread_mutex_);\n        thread_count_++;\n        std::thread t(&Stats::processMsg, this, client_sock);\n        t.detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n\n    std::string request(buffer, bytes_read);\n    std::istringstream iss(request);\n    std::string command;\n    iss >> command;\n\n    if (command == \"GET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        std::string key;\n        iss >> key;\n        if (!key.empty()) {\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                std::string response = \"GET \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                std::string response = \"NOTFOUND\\n\";\n                write(sockfd, response.c_str(), response.size());\n            }\n        } else {\n            std::string response = \"ALL\\n\";\n            write(sockfd, response.c_str(), response.size());\n            for (const auto& pair : stats_) {\n                std::string line = pair.first + \" \" + std::to_string(pair.second) + \"\\n\";\n                write(sockfd, line.c_str(), line.size());\n            }\n        }\n    } else if (command == \"INCREMENT\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                it->second += val;\n                std::string response = \"INCREMENT \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                std::string response = \"NOTFOUND\\n\";\n                write(sockfd, response.c_str(), response.size());\n            }\n        }\n    } else if (command == \"SET\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] = val;\n            std::string response = \"SET \" + key + \" \" + std::to_string(val) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (command == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        std::string response = \"RESET\\n\";\n        write(sockfd, response.c_str(), response.size());\n    }\n\n    close(sockfd);\n}\n\nbool Stats::isInitInternal() {\n    return initialized_;\n}",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <thread>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <condition_variable>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n\n    bool isInitInternal();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), statsThreadRunning_(false), thread_count_(0) {\n    // Initialize socket\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n    }\n\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n\n    unlink(stats_socket_path_.c_str());\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        std::cerr << \"Failed to bind socket\" << std::endl;\n    }\n\n    if (listen(sockfd_, 5) == -1) {\n        std::cerr << \"Failed to listen on socket\" << std::endl;\n    }\n}\n\nStats::~Stats() {\n    if (sockfd_ != -1) {\n        close(sockfd_);\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!isInit()) {\n        init(stats_socket_path);\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    return std::unique_ptr<Stats>(new Stats(stats_socket_path));\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return true;\n    }\n    instance_ = new Stats(stats_socket_path);\n    if (instance_->startSocket()) {\n        initialized_ = true;\n        return true;\n    }\n    delete instance_;\n    instance_ = nullptr;\n    return false;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    if (!statsThreadRunning_) {\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        statsThreadRunning_ = true;\n    }\n    return true;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd == -1) {\n            continue;\n        }\n        std::lock_guard<std::mutex> lock(thread_mutex_);\n        thread_count_++;\n        std::thread t(&Stats::processMsg, this, client_fd);\n        t.detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n    std::string request(buffer, bytes_read);\n    std::istringstream iss(request);\n    std::string cmd;\n    iss >> cmd;\n\n    if (cmd == \"GET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        std::string key;\n        iss >> key;\n        if (!key.empty()) {\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                std::string response = \"GET \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                std::string response = \"GET \" + key + \" NOT_FOUND\\n\";\n                write(sockfd, response.c_str(), response.size());\n            }\n        } else {\n            std::string response = \"GET ALL\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"SET\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] = val;\n            std::string response = \"SET \" + key + \" \" + std::to_string(val) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"INCREMENT\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                it->second += val;\n                std::string response = \"INCREMENT \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                std::string response = \"INCREMENT \" + key + \" NOT_FOUND\\n\";\n                write(sockfd, response.c_str(), response.size());\n            }\n        }\n    } else if (cmd == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        std::string response = \"RESET\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else {\n        std::string response = \"UNKNOWN COMMAND\\n\";\n        write(sockfd, response.c_str(), response.size());\n    }\n\n    close(sockfd);\n    std::lock_guard<std::mutex> lock(thread_mutex_);\n    thread_count_--;\n}",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <thread>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <condition_variable>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n    bool isInitInternal();\n};\n\nstd::atomic<bool> Stats::initialized_(false);\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), thread_count_(0), statsThreadRunning_(false) {\n    if (init(stats_socket_path)) {\n        std::cout << \"Stats server initialized.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to initialize Stats server.\" << std::endl;\n    }\n}\n\nStats::~Stats() {\n    if (statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!initialized_) {\n        if (!init(stats_socket_path)) {\n            throw std::runtime_error(\"Failed to initialize Stats server.\");\n        }\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    auto stats = std::make_unique<Stats>(stats_socket_path);\n    if (!stats->init(stats_socket_path)) {\n        return nullptr;\n    }\n    return stats;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return true;\n    }\n    if (stats_socket_path.empty()) {\n        std::cerr << \"Socket path cannot be empty.\" << std::endl;\n        return false;\n    }\n    if (access(stats_socket_path.c_str(), F_OK) == 0) {\n        unlink(stats_socket_path.c_str());\n    }\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        std::cerr << \"Failed to create socket.\" << std::endl;\n        return false;\n    }\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        std::cerr << \"Failed to bind socket.\" << std::endl;\n        close(sockfd_);\n        sockfd_ = -1;\n        return false;\n    }\n    if (listen(sockfd_, 5) == -1) {\n        std::cerr << \"Failed to listen on socket.\" << std::endl;\n        close(sockfd_);\n        sockfd_ = -1;\n        return false;\n    }\n    statsThreadRunning_ = true;\n    stats_thread_ = std::thread(&Stats::runSocket, this);\n    initialized_ = true;\n    instance_ = this;\n    return true;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    if (!statsThreadRunning_) {\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n    return false;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd == -1) {\n            continue;\n        }\n        ++thread_count_;\n        thread_exited_.notify_one();\n        std::thread([this, client_fd]() {\n            processMsg(client_fd);\n            --thread_count_;\n        }).detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n    buffer[bytes_read] = '\\0';\n    std::string request(buffer);\n    std::istringstream iss(request);\n    std::string cmd;\n    iss >> cmd;\n    if (cmd == \"GET\") {\n        std::string key;\n        iss >> key;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            std::string response = \"GET \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            std::string response = \"ERROR: Key not found\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"SET\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = val;\n        std::string response = \"SET \" + key + \" \" + std::to_string(val) + \"\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else if (cmd == \"INCREMENT\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            it->second += val;\n            std::string response = \"INCREMENT \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            std::string response = \"ERROR: Key not found\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        std::string response = \"RESET\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else {\n        std::string response = \"UNKNOWN COMMAND\\n\";\n        write(sockfd, response.c_str(), response.size());\n    }\n    close(sockfd);\n}\n\nbool Stats::isInitInternal() {\n    return initialized_;\n}",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n    bool isInitInternal();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), thread_count_(0), statsThreadRunning_(false) {\n    if (init(stats_socket_path)) {\n        std::cout << \"Stats server initialized.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to initialize Stats server.\" << std::endl;\n    }\n}\n\nStats::~Stats() {\n    if (statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!isInit()) {\n        init(stats_socket_path);\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    auto ptr = std::make_unique<Stats>(stats_socket_path);\n    return ptr;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return true;\n    }\n    instance_ = new Stats(stats_socket_path);\n    if (!instance_->startSocket()) {\n        delete instance_;\n        instance_ = nullptr;\n        return false;\n    }\n    initialized_ = true;\n    return true;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        std::cerr << \"Failed to create socket.\" << std::endl;\n        return false;\n    }\n\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n\n    if (unlink(stats_socket_path_.c_str()) == -1 && errno != ENOENT) {\n        std::cerr << \"Failed to remove existing socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        std::cerr << \"Failed to bind socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    if (listen(sockfd_, 5) == -1) {\n        std::cerr << \"Failed to listen on socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    statsThreadRunning_ = true;\n    stats_thread_ = std::thread(&Stats::runSocket, this);\n    return true;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd == -1) {\n            continue;\n        }\n\n        std::lock_guard<std::mutex> lock(thread_mutex_);\n        thread_count_++;\n        std::thread t(&Stats::processMsg, this, client_fd);\n        t.detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n\n    std::string request(buffer, bytes_read);\n    std::istringstream iss(request);\n    std::string cmd;\n    iss >> cmd;\n\n    if (cmd == \"GET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        std::string key;\n        iss >> key;\n        if (!key.empty()) {\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                std::string response = \"GET \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                write(sockfd, \"NOTFOUND\\n\", 10);\n            }\n        } else {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            std::string response;\n            for (const auto& pair : stats_) {\n                response += \"GET \" + pair.first + \" \" + std::to_string(pair.second) + \"\\n\";\n            }\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"INCREMENT\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                it->second += val;\n                std::string response = \"INCREMENT \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                write(sockfd, \"NOTFOUND\\n\", 10);\n            }\n        }\n    } else if (cmd == \"SET\") {\n        std::string key;\n        int val;\n        iss >> key >> val;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] = val;\n            std::string response = \"SET \" + key + \" \" + std::to_string(val) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        write(sockfd, \"RESET\\n\", 6);\n    } else {\n        write(sockfd, \"UNKNOWN\\n\", 8);\n    }\n\n    close(sockfd);\n    std::lock_guard<std::mutex> lock(thread_mutex_);\n    thread_count_--;\n}",
      "#include <iostream>\n#include <string>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <condition_variable>\n#include <unordered_map>\n#include <stdexcept>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n    bool isInitInternal();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), thread_count_(0), statsThreadRunning_(false) {\n    if (init(stats_socket_path)) {\n        std::cout << \"Stats server initialized.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to initialize Stats server.\" << std::endl;\n    }\n}\n\nStats::~Stats() {\n    if (statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!isInit()) {\n        if (!init(stats_socket_path)) {\n            throw std::runtime_error(\"Failed to initialize Stats server.\");\n        }\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    auto stats = std::make_unique<Stats>(stats_socket_path);\n    if (!stats->init(stats_socket_path)) {\n        return nullptr;\n    }\n    return stats;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return true;\n    }\n    if (instance_) {\n        delete instance_;\n        instance_ = nullptr;\n    }\n    instance_ = new Stats(stats_socket_path);\n    if (!instance_->startSocket()) {\n        delete instance_;\n        instance_ = nullptr;\n        return false;\n    }\n    initialized_ = true;\n    return true;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        std::cerr << \"Failed to create socket.\" << std::endl;\n        return false;\n    }\n\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path_.c_str(), sizeof(serv_addr_.sun_path) - 1);\n\n    if (unlink(stats_socket_path_.c_str()) == -1 && errno != ENOENT) {\n        std::cerr << \"Failed to remove existing socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        std::cerr << \"Failed to bind socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    if (listen(sockfd_, 5) == -1) {\n        std::cerr << \"Failed to listen on socket.\" << std::endl;\n        close(sockfd_);\n        return false;\n    }\n\n    statsThreadRunning_ = true;\n    stats_thread_ = std::thread(&Stats::runSocket, this);\n    return true;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd == -1) {\n            continue;\n        }\n\n        std::lock_guard<std::mutex> lock(thread_mutex_);\n        thread_count_++;\n        std::thread t(&Stats::processMsg, this, client_fd);\n        t.detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n\n    std::string request(buffer, bytes_read);\n    std::istringstream iss(request);\n    std::string cmd;\n    iss >> cmd;\n\n    if (cmd == \"GET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        std::string key;\n        iss >> key;\n        if (!key.empty()) {\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                std::string response = \"GET \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                std::string response = \"GET \" + key + \" NOT_FOUND\\n\";\n                write(sockfd, response.c_str(), response.size());\n            }\n        } else {\n            std::string response = \"GET ALL\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"SET\") {\n        std::string key;\n        int value;\n        iss >> key >> value;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            stats_[key] = value;\n            std::string response = \"SET \" + key + \" \" + std::to_string(value) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (cmd == \"INCREMENT\") {\n        std::string key;\n        int value;\n        iss >> key >> value;\n        if (!key.empty()) {\n            std::lock_guard<std::mutex> lock(stats_mutex_);\n            auto it = stats_.find(key);\n            if (it != stats_.end()) {\n                it->second += value;\n                std::string response = \"INCREMENT \" + key + \" \" + std::to_string(it->second) + \"\\n\";\n                write(sockfd, response.c_str(), response.size());\n            } else {\n                std::string response = \"INCREMENT \" + key + \" NOT_FOUND\\n\";\n                write(sockfd, response.c_str(), response.size());\n            }\n        }\n    } else if (cmd == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        std::string response = \"RESET OK\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else {\n        std::string response = \"UNKNOWN COMMAND\\n\";\n        write(sockfd, response.c_str(), response.size());\n    }\n\n    close(sockfd);\n    std::lock_guard<std::mutex> lock(thread_mutex_);\n    thread_count_--;\n}",
      "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <thread>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <cstring>\n#include <condition_variable>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n    bool isInitInternal();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), thread_count_(0), statsThreadRunning_(false) {\n    if (init(stats_socket_path)) {\n        std::cout << \"Stats server initialized.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to initialize Stats server.\" << std::endl;\n    }\n}\n\nStats::~Stats() {\n    if (statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!initialized_) {\n        if (!init(stats_socket_path)) {\n            throw std::runtime_error(\"Failed to initialize Stats server.\");\n        }\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    auto ptr = std::make_unique<Stats>(stats_socket_path);\n    if (!ptr->init(stats_socket_path)) {\n        ptr.reset();\n    }\n    return ptr;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return true;\n    }\n    if (stats_socket_path.empty()) {\n        std::cerr << \"Socket path cannot be empty.\" << std::endl;\n        return false;\n    }\n    if (access(stats_socket_path.c_str(), F_OK) == 0) {\n        unlink(stats_socket_path.c_str());\n    }\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ == -1) {\n        std::cerr << \"Failed to create socket.\" << std::endl;\n        return false;\n    }\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n    if (bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_)) == -1) {\n        std::cerr << \"Failed to bind socket.\" << std::endl;\n        close(sockfd_);\n        sockfd_ = -1;\n        return false;\n    }\n    if (listen(sockfd_, 5) == -1) {\n        std::cerr << \"Failed to listen on socket.\" << std::endl;\n        close(sockfd_);\n        sockfd_ = -1;\n        return false;\n    }\n    initialized_ = true;\n    instance_ = this;\n    return true;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    if (!statsThreadRunning_) {\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n    return false;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        struct sockaddr_un client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &addr_len);\n        if (client_fd == -1) {\n            continue;\n        }\n        ++thread_count_;\n        std::lock_guard<std::mutex> lock(thread_mutex_);\n        thread_exited_.notify_one();\n        processMsg(client_fd);\n        close(client_fd);\n        --thread_count_;\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        return;\n    }\n    buffer[bytes_read] = '\\0';\n    std::string request(buffer);\n    std::istringstream iss(request);\n    std::string command;\n    iss >> command;\n    if (command == \"GET\") {\n        std::string key;\n        iss >> key;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        if (stats_.find(key) != stats_.end()) {\n            std::string response = key + \": \" + std::to_string(stats_[key]) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            std::string response = \"Key not found: \" + key + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (command == \"SET\") {\n        std::string key;\n        int value;\n        iss >> key >> value;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = value;\n        std::string response = \"Set \" + key + \" to \" + std::to_string(value) + \"\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else if (command == \"INCREMENT\") {\n        std::string key;\n        int value;\n        iss >> key >> value;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            it->second += value;\n            std::string response = key + \" incremented by \" + std::to_string(value) + \" -> \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            std::string response = \"Key not found: \" + key + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        }\n    } else if (command == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        std::string response = \"All statistics reset.\\n\";\n        write(sockfd, response.c_str(), response.size());\n    } else {\n        std::string response = \"Unknown command: \" + command + \"\\n\";\n        write(sockfd, response.c_str(), response.size());\n    }\n}\n\nbool Stats::isInitInternal() {\n    return initialized_;\n}"
    ],
    "unmatched_results": [
      "#include <iostream>\n#include <string>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <condition_variable>\n#include <unordered_map>\n#include <stdexcept>\n\nclass Stats {\npublic:\n    Stats(const std::string& stats_socket_path);\n    ~Stats();\n    static Stats& get(const std::string& stats_socket_path);\n    static std::unique_ptr<Stats> get_for_unittest(const std::string& stats_socket_path);\n    static bool init(const std::string& stats_socket_path);\n    static bool isInit();\n    std::unordered_map<std::string, int> getAll();\n    int increment(const std::string& key, int val);\n    int set(const std::string& key, int val);\n    int reset();\n    bool startSocket();\n    void runSocket();\n    void processMsg(int sockfd);\n\nprivate:\n    std::string stats_socket_path_;\n    int sockfd_;\n    struct sockaddr_un serv_addr_;\n    std::thread stats_thread_;\n    std::atomic<bool> statsThreadRunning_;\n    std::mutex stats_mutex_;\n    std::mutex thread_mutex_;\n    std::condition_variable thread_exited_;\n    int thread_count_;\n    std::unordered_map<std::string, int> stats_;\n\n    static std::atomic<bool> initialized_;\n    static Stats* instance_;\n\n    bool initInternal(const std::string& stats_socket_path);\n    void handleClient(int sockfd);\n    void cleanup();\n};\n\nstd::atomic<bool> Stats::initialized_ = false;\nStats* Stats::instance_ = nullptr;\n\nStats::Stats(const std::string& stats_socket_path) : stats_socket_path_(stats_socket_path), sockfd_(-1), statsThreadRunning_(false), thread_count_(0) {\n    if (initInternal(stats_socket_path)) {\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n    }\n}\n\nStats::~Stats() {\n    if (statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n        if (stats_thread_.joinable()) {\n            stats_thread_.join();\n        }\n    }\n    cleanup();\n}\n\nStats& Stats::get(const std::string& stats_socket_path) {\n    if (!initialized_) {\n        throw std::runtime_error(\"Stats not initialized\");\n    }\n    return *instance_;\n}\n\nstd::unique_ptr<Stats> Stats::get_for_unittest(const std::string& stats_socket_path) {\n    if (initialized_) {\n        throw std::runtime_error(\"Stats already initialized\");\n    }\n    auto stats = std::unique_ptr<Stats>(new Stats(stats_socket_path));\n    return stats;\n}\n\nbool Stats::init(const std::string& stats_socket_path) {\n    if (initialized_) {\n        return false;\n    }\n    instance_ = new Stats(stats_socket_path);\n    initialized_ = true;\n    return true;\n}\n\nbool Stats::isInit() {\n    return initialized_;\n}\n\nstd::unordered_map<std::string, int> Stats::getAll() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    return stats_;\n}\n\nint Stats::increment(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    auto it = stats_.find(key);\n    if (it != stats_.end()) {\n        it->second += val;\n        return it->second;\n    } else {\n        stats_[key] = val;\n        return val;\n    }\n}\n\nint Stats::set(const std::string& key, int val) {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_[key] = val;\n    return val;\n}\n\nint Stats::reset() {\n    std::lock_guard<std::mutex> lock(stats_mutex_);\n    stats_.clear();\n    return 0;\n}\n\nbool Stats::startSocket() {\n    if (!statsThreadRunning_) {\n        statsThreadRunning_ = true;\n        stats_thread_ = std::thread(&Stats::runSocket, this);\n        return true;\n    }\n    return false;\n}\n\nvoid Stats::runSocket() {\n    while (statsThreadRunning_) {\n        sockaddr_un client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(sockfd_, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd < 0) {\n            continue;\n        }\n        ++thread_count_;\n        thread_exited_.notify_one();\n        std::thread([this, client_fd]() { handleClient(client_fd); }).detach();\n    }\n}\n\nvoid Stats::processMsg(int sockfd) {\n    char buffer[1024];\n    ssize_t bytes_read = read(sockfd, buffer, sizeof(buffer));\n    if (bytes_read <= 0) {\n        close(sockfd);\n        return;\n    }\n    std::string request(buffer, bytes_read);\n    std::istringstream iss(request);\n    std::string cmd;\n    iss >> cmd;\n    if (cmd == \"GET\") {\n        std::string key;\n        iss >> key;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            std::string response = \"VALUE: \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            write(sockfd, \"NOTFOUND\\n\", 10);\n        }\n    } else if (cmd == \"SET\") {\n        std::string key;\n        int value;\n        iss >> key >> value;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_[key] = value;\n        write(sockfd, \"OK\\n\", 3);\n    } else if (cmd == \"INCREMENT\") {\n        std::string key;\n        int value;\n        iss >> key >> value;\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        auto it = stats_.find(key);\n        if (it != stats_.end()) {\n            it->second += value;\n            std::string response = \"NEWVALUE: \" + std::to_string(it->second) + \"\\n\";\n            write(sockfd, response.c_str(), response.size());\n        } else {\n            stats_[key] = value;\n            write(sockfd, \"OK\\n\", 3);\n        }\n    } else if (cmd == \"RESET\") {\n        std::lock_guard<std::mutex> lock(stats_mutex_);\n        stats_.clear();\n        write(sockfd, \"RESET\\n\", 7);\n    } else {\n        write(sockfd, \"UNKNOWN\\n\", 9);\n    }\n    close(sockfd);\n}\n\nvoid Stats::handleClient(int sockfd) {\n    processMsg(sockfd);\n    --thread_count_;\n    std::lock_guard<std::mutex> lock(thread_mutex_);\n    if (thread_count_ == 0 && statsThreadRunning_) {\n        statsThreadRunning_ = false;\n        thread_exited_.notify_all();\n    }\n}\n\nvoid Stats::cleanup() {\n    if (sockfd_ > 0) {\n        close(sockfd_);\n    }\n    unlink(stats_socket_path_.c_str());\n}\n\nbool Stats::initInternal(const std::string& stats_socket_path) {\n    sockfd_ = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd_ < 0) {\n        return false;\n    }\n\n    memset(&serv_addr_, 0, sizeof(serv_addr_));\n    serv_addr_.sun_family = AF_UNIX;\n    strncpy(serv_addr_.sun_path, stats_socket_path.c_str(), sizeof(serv_addr_.sun_path) - 1);\n\n    int bind_result = bind(sockfd_, (struct sockaddr*)&serv_addr_, sizeof(serv_addr_));\n    if (bind_result < 0) {\n        close(sockfd_);\n        return false;\n    }\n\n    if (listen(sockfd_, 5) < 0) {\n        close(sockfd_);\n        return false;\n    }\n\n    return true;\n}"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a UDP receiver class in C++ that listens for incoming UDP packets on a specified port, processes them, and forwards them to a network handling component. The class should handle socket creation, binding, and packet reception in a non-blocking manner using polling.\n\nClass Description: The `UDPRecv` class is responsible for setting up a UDP socket server that listens for incoming messages on a specified port. It uses polling to check for incoming data without blocking, and forwards received messages to a network handling component (`DFNetWork`). The class manages the socket lifecycle and provides methods to initialize, start, and stop the receiver.\n\nAttributes:\n- m_poDFNetWork: [DFNetWork*] - Pointer to the network handling component that processes received messages\n- m_iSockFD: [int] - File descriptor for the UDP socket\n- m_bIsEnd: [bool] - Flag indicating whether the receiver should stop running\n- m_bIsStarted: [bool] - Flag indicating whether the receiver has started\n\nMethods:\n- UDPRecv(DFNetWork* poDFNetWork) -> [void] - Constructor that initializes the receiver with a network handling component\n- ~UDPRecv() -> [void] - Destructor that closes the socket if it's open\n- Stop() -> [void] - Signals the receiver to stop and waits for it to finish\n- Init(int iPort) -> [int] - Initializes the UDP socket and binds it to the specified port (returns 0 on success, -1 on failure)\n- run() -> [void] - Main execution loop that polls for incoming messages and processes them (runs in a separate thread)",
    "Canonical_solution": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include \"dfnetwork.h\"\n\nnamespace phxpaxos {\n\nclass UDPRecv\n{\npublic:\n    UDPRecv(DFNetWork * poDFNetWork);\n    ~UDPRecv();\n\n    void Stop();\n    int Init(const int iPort);\n    void run();\n\nprivate:\n    DFNetWork * m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n};\n\nUDPRecv::UDPRecv(DFNetWork * poDFNetWork) \n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false)\n{\n}\n\nUDPRecv::~UDPRecv()\n{\n    if (m_iSockFD != -1)\n    {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n    }\n}\n\nvoid UDPRecv::Stop()\n{\n    if (m_bIsStarted)\n    {\n        m_bIsEnd = true;\n        join();\n    }\n}\n\nint UDPRecv::Init(const int iPort)\n{\n    if ((m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0)) < 0) \n    {\n        return -1;\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(iPort);\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    int enable = 1;\n    setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int));\n\n    if (bind(m_iSockFD, (struct sockaddr *)&addr, sizeof(addr)) < 0) \n    {\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid UDPRecv::run()\n{\n    m_bIsStarted = true;\n\n    char sBuffer[65536] = {0};\n\n    struct sockaddr_in addr;\n    socklen_t addr_len = sizeof(struct sockaddr_in);\n    memset(&addr, 0, sizeof(addr));\n\n    while(true)\n    {\n        if (m_bIsEnd)\n        {\n            return;\n        }\n\n        struct pollfd fd;\n        int ret;\n\n        fd.fd = m_iSockFD;\n        fd.events = POLLIN;\n        ret = poll(&fd, 1, 500);\n\n        if (ret == 0 || ret == -1)\n        {\n            continue;\n        }\n        \n        int iRecvLen = recvfrom(m_iSockFD, sBuffer, sizeof(sBuffer), 0,\n                (struct sockaddr *)&addr, &addr_len);\n\n        if (iRecvLen > 0)\n        {\n            m_poDFNetWork->OnReceiveMessage(sBuffer, iRecvLen);\n        }\n    }\n}\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 152,
    "matched_results": [
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <thread>\n#include <atomic>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int length) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    std::atomic<bool> m_bIsEnd;\n    std::atomic<bool> m_bIsStarted;\n\n    void PollForMessages();\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork);\n    ~UDPRecv();\n    void Stop();\n    int Init(int iPort);\n    void run();\n};\n\nUDPRecv::UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\nUDPRecv::~UDPRecv() {\n    if (m_iSockFD != -1) {\n        close(m_iSockFD);\n    }\n}\n\nvoid UDPRecv::Stop() {\n    m_bIsEnd = true;\n    if (m_bIsStarted) {\n        // Wait for the thread to finish\n        while (m_bIsStarted) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    }\n}\n\nint UDPRecv::Init(int iPort) {\n    m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n    if (m_iSockFD == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(iPort);\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n        std::cerr << \"Failed to bind socket\" << std::endl;\n        close(m_iSockFD);\n        m_iSockFD = -1;\n        return -1;\n    }\n\n    m_bIsStarted = false;\n    m_bIsEnd = false;\n    return 0;\n}\n\nvoid UDPRecv::run() {\n    m_bIsStarted = true;\n    fd_set read_fds;\n    struct timeval tv;\n\n    while (!m_bIsEnd) {\n        FD_ZERO(&read_fds);\n        FD_SET(m_iSockFD, &read_fds);\n\n        tv.tv_sec = 0;\n        tv.tv_usec = 100000; // 100ms\n\n        int activity = select(m_iSockFD + 1, &read_fds, nullptr, nullptr, &tv);\n        if (activity == -1) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        } else if (activity == 0) {\n            continue; // No data available\n        }\n\n        char buffer[65536];\n        sockaddr_in clientAddr;\n        socklen_t addrLen = sizeof(clientAddr);\n\n        int bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &addrLen);\n        if (bytesReceived > 0) {\n            m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n        }\n    }\n\n    m_bIsStarted = false;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <poll.h>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int length) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n\n    struct pollfd m_pollFd;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_bIsStarted) {\n            // Wait for the run() thread to finish\n            // In a real scenario, you would use a condition variable or similar\n            // For simplicity, this is a placeholder\n            while (m_bIsStarted) {\n                usleep(100000);\n            }\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return -1;\n        }\n\n        sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_addr.s_addr = INADDR_ANY;\n        serverAddr.sin_port = htons(iPort);\n\n        if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n            std::cerr << \"Failed to bind socket\" << std::endl;\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_pollFd.fd = m_iSockFD;\n        m_pollFd.events = POLLIN;\n\n        m_bIsStarted = false;\n        m_bIsEnd = false;\n\n        return 0;\n    }\n\n    void run() {\n        m_bIsStarted = true;\n        char buffer[65536];\n        while (!m_bIsEnd) {\n            int pollResult = poll(&m_pollFd, 1, 100); // 100ms timeout\n            if (pollResult == -1) {\n                std::cerr << \"Poll error\" << std::endl;\n                break;\n            } else if (pollResult == 0) {\n                continue; // Timeout, no data\n            } else {\n                if (m_pollFd.revents & POLLIN) {\n                    socklen_t addrLen = sizeof(sockaddr_in);\n                    sockaddr_in clientAddr;\n                    int bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &addrLen);\n                    if (bytesReceived > 0) {\n                        m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n                    }\n                }\n            }\n        }\n        m_bIsStarted = false;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <poll.h>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int length) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n\n    struct pollfd m_pollFd;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_bIsStarted) {\n            // Wait for the run loop to exit\n            while (m_bIsStarted) {\n                usleep(100000);\n            }\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return -1;\n        }\n\n        sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_addr.s_addr = INADDR_ANY;\n        serverAddr.sin_port = htons(iPort);\n\n        if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n            std::cerr << \"Failed to bind socket\" << std::endl;\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_pollFd.fd = m_iSockFD;\n        m_pollFd.events = POLLIN;\n\n        m_bIsStarted = false;\n        m_bIsEnd = false;\n\n        return 0;\n    }\n\n    void run() {\n        m_bIsStarted = true;\n        while (!m_bIsEnd) {\n            int pollResult = poll(&m_pollFd, 1, 100); // 100ms timeout\n            if (pollResult == -1) {\n                std::cerr << \"Poll error\" << std::endl;\n                break;\n            } else if (pollResult == 0) {\n                continue; // Timeout, no data\n            } else {\n                if (m_pollFd.revents & POLLIN) {\n                    char buffer[65536];\n                    sockaddr_in clientAddr;\n                    socklen_t addrLen = sizeof(clientAddr);\n                    int bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &addrLen);\n                    if (bytesReceived > 0) {\n                        m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n                    }\n                }\n            }\n        }\n        m_bIsStarted = false;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <sys/poll.h>\n#include <thread>\n#include <atomic>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, size_t len) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    std::atomic<bool> m_bIsEnd;\n    std::atomic<bool> m_bIsStarted;\n    struct pollfd m_pollFd;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {\n        m_pollFd.fd = -1;\n        m_pollFd.events = 0;\n        m_pollFd.revents = 0;\n    }\n\n    ~UDPRecv() {\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return -1;\n        }\n\n        sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(iPort);\n        serverAddr.sin_addr.s_addr = INADDR_ANY;\n\n        if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n            std::cerr << \"Failed to bind socket\" << std::endl;\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_pollFd.fd = m_iSockFD;\n        m_pollFd.events = POLLIN;\n\n        m_bIsStarted = false;\n        return 0;\n    }\n\n    void run() {\n        while (!m_bIsEnd) {\n            int pollResult = poll(&m_pollFd, 1, 100); // 100ms timeout\n            if (pollResult == -1) {\n                std::cerr << \"Poll error\" << std::endl;\n                continue;\n            } else if (pollResult == 0) {\n                continue; // Timeout, no data\n            } else {\n                if (m_pollFd.revents & POLLIN) {\n                    char buffer[65536];\n                    socklen_t addrLen = sizeof(sockaddr_in);\n                    sockaddr_in clientAddr;\n                    ssize_t bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (sockaddr*)&clientAddr, &addrLen);\n                    if (bytesReceived > 0) {\n                        m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n                    }\n                }\n            }\n        }\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <sys/poll.h>\n#include <thread>\n#include <atomic>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int len) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    std::atomic<bool> m_bIsEnd;\n    std::atomic<bool> m_bIsStarted;\n    struct pollfd m_pollFd;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {\n        m_pollFd.fd = -1;\n        m_pollFd.events = 0;\n    }\n\n    ~UDPRecv() {\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_bIsStarted) {\n            // Wait for the run() thread to finish\n            // In a real scenario, you might need a condition variable or similar\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return -1;\n        }\n\n        sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_addr.s_addr = INADDR_ANY;\n        serverAddr.sin_port = htons(iPort);\n\n        if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n            std::cerr << \"Failed to bind socket\" << std::endl;\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_pollFd.fd = m_iSockFD;\n        m_pollFd.events = POLLIN;\n\n        m_bIsStarted = false;\n        return 0;\n    }\n\n    void run() {\n        m_bIsStarted = true;\n        while (!m_bIsEnd) {\n            int pollResult = poll(&m_pollFd, 1, 100); // 100ms timeout\n            if (pollResult == -1) {\n                std::cerr << \"Poll error\" << std::endl;\n                break;\n            } else if (pollResult > 0 && m_pollFd.revents & POLLIN) {\n                char buffer[65536];\n                sockaddr_in clientAddr;\n                socklen_t addrLen = sizeof(clientAddr);\n                int bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &addrLen);\n                if (bytesReceived > 0) {\n                    m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n                }\n            }\n        }\n        m_bIsStarted = false;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <poll.h>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int length) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n\n    struct pollfd m_pollFd;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_bIsStarted) {\n            // Wait for the run() thread to finish\n            // In a real scenario, you would use a thread join or similar mechanism\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return -1;\n        }\n\n        sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_addr.s_addr = INADDR_ANY;\n        serverAddr.sin_port = htons(iPort);\n\n        if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n            std::cerr << \"Failed to bind socket\" << std::endl;\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_pollFd.fd = m_iSockFD;\n        m_pollFd.events = POLLIN;\n\n        m_bIsStarted = false;\n        return 0;\n    }\n\n    void run() {\n        m_bIsStarted = true;\n        while (!m_bIsEnd) {\n            int pollResult = poll(&m_pollFd, 1, 100); // 100ms timeout\n\n            if (pollResult == -1) {\n                std::cerr << \"Poll error\" << std::endl;\n                break;\n            } else if (pollResult == 0) {\n                continue; // Timeout, no data\n            } else {\n                if (m_pollFd.revents & POLLIN) {\n                    char buffer[65536];\n                    socklen_t addrLen = sizeof(sockaddr_in);\n                    sockaddr_in clientAddr;\n                    int bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &addrLen);\n\n                    if (bytesReceived > 0) {\n                        m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n                    }\n                }\n            }\n        }\n\n        m_bIsStarted = false;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <thread>\n#include <atomic>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int length) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    std::atomic<bool> m_bIsEnd;\n    std::atomic<bool> m_bIsStarted;\n\n    void PollForMessages();\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork);\n    ~UDPRecv();\n    void Stop();\n    int Init(int iPort);\n    void run();\n};\n\nUDPRecv::UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\nUDPRecv::~UDPRecv() {\n    if (m_iSockFD != -1) {\n        close(m_iSockFD);\n    }\n}\n\nvoid UDPRecv::Stop() {\n    m_bIsEnd = true;\n    if (m_bIsStarted) {\n        // Wait for the thread to finish\n        while (m_bIsStarted) {\n            usleep(100000); // Sleep for 100ms\n        }\n    }\n}\n\nint UDPRecv::Init(int iPort) {\n    m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n    if (m_iSockFD == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(iPort);\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n        std::cerr << \"Failed to bind socket\" << std::endl;\n        close(m_iSockFD);\n        m_iSockFD = -1;\n        return -1;\n    }\n\n    m_bIsStarted = false;\n    m_bIsEnd = false;\n    return 0;\n}\n\nvoid UDPRecv::run() {\n    m_bIsStarted = true;\n    fd_set read_fds;\n    struct timeval timeout;\n\n    while (!m_bIsEnd) {\n        FD_ZERO(&read_fds);\n        FD_SET(m_iSockFD, &read_fds);\n\n        timeout.tv_sec = 0;\n        timeout.tv_usec = 100000; // 100ms\n\n        int activity = select(m_iSockFD + 1, &read_fds, nullptr, nullptr, &timeout);\n        if (activity == -1) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        } else if (activity == 0) {\n            continue; // No data available\n        }\n\n        char buffer[65536];\n        socklen_t addr_len = sizeof(struct sockaddr_in);\n        struct sockaddr_in clientAddr;\n        int bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &addr_len);\n        if (bytesReceived > 0) {\n            m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n        }\n    }\n\n    m_bIsStarted = false;\n}\n\nint main() {\n    DFNetWork* networkHandler = new class DFNetWork {\n        void ProcessMessage(const char* data, int length) override {\n            std::cout << \"Received \" << length << \" bytes: \" << std::string(data, length) << std::endl;\n        }\n    };\n\n    UDPRecv udpReceiver(networkHandler);\n    if (udpReceiver.Init(8080) == 0) {\n        std::thread receiverThread(&UDPRecv::run, &udpReceiver);\n        receiverThread.join();\n    }\n\n    delete networkHandler;\n    return 0;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <poll.h>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int length) = 0;\n};\n\nclass UDPRecv {\npublic:\n    UDPRecv(DFNetWork* poDFNetWork);\n    ~UDPRecv();\n    void Stop();\n    int Init(int iPort);\n    void run();\n\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n};\n\nUDPRecv::UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\nUDPRecv::~UDPRecv() {\n    if (m_iSockFD != -1) {\n        close(m_iSockFD);\n    }\n}\n\nvoid UDPRecv::Stop() {\n    m_bIsEnd = true;\n    if (m_bIsStarted) {\n        // Wait for the run() thread to finish\n        // In a real scenario, you would use a condition variable or similar synchronization\n        // This is a simplified example\n        while (m_bIsStarted) {\n            usleep(100000); // Sleep for 100ms\n        }\n    }\n}\n\nint UDPRecv::Init(int iPort) {\n    m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n    if (m_iSockFD == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(iPort);\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(m_iSockFD, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Failed to bind socket\" << std::endl;\n        close(m_iSockFD);\n        m_iSockFD = -1;\n        return -1;\n    }\n\n    m_bIsStarted = false;\n    m_bIsEnd = false;\n    return 0;\n}\n\nvoid UDPRecv::run() {\n    m_bIsStarted = true;\n    struct pollfd fds[1];\n    fds[0].fd = m_iSockFD;\n    fds[0].events = POLLIN;\n\n    char buffer[65536];\n    while (!m_bIsEnd) {\n        int poll_result = poll(fds, 1, 100); // Wait up to 100ms\n        if (poll_result < 0) {\n            std::cerr << \"Poll error\" << std::endl;\n            break;\n        }\n        if (poll_result == 0) {\n            continue; // Timeout, no data\n        }\n\n        if (fds[0].revents & POLLIN) {\n            socklen_t addr_len = sizeof(struct sockaddr_in);\n            struct sockaddr_in client_addr;\n            int bytes_received = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&client_addr, &addr_len);\n            if (bytes_received > 0) {\n                m_poDFNetWork->ProcessMessage(buffer, bytes_received);\n            }\n        }\n    }\n\n    m_bIsStarted = false;\n}",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <poll.h>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int length) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n\n    struct pollfd m_pollFd;\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        if (m_iSockFD != -1) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_bIsStarted) {\n            // Wait for the run() thread to finish\n            // In a real scenario, you would use a thread join or similar mechanism\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD == -1) {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return -1;\n        }\n\n        sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_addr.s_addr = INADDR_ANY;\n        serverAddr.sin_port = htons(iPort);\n\n        if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n            std::cerr << \"Failed to bind socket\" << std::endl;\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_pollFd.fd = m_iSockFD;\n        m_pollFd.events = POLLIN;\n\n        m_bIsStarted = false;\n        return 0;\n    }\n\n    void run() {\n        m_bIsStarted = true;\n        while (!m_bIsEnd) {\n            int pollResult = poll(&m_pollFd, 1, 100); // 100ms timeout\n            if (pollResult == -1) {\n                std::cerr << \"Poll error\" << std::endl;\n                break;\n            } else if (pollResult > 0 && m_pollFd.revents & POLLIN) {\n                char buffer[65536];\n                sockaddr_in clientAddr;\n        socklen_t addrLen = sizeof(clientAddr);\n                int bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &addrLen);\n                if (bytesReceived > 0) {\n                    m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n                }\n            }\n        }\n        m_bIsStarted = false;\n    }\n};",
      "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <thread>\n#include <atomic>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, int length) = 0;\n};\n\nclass UDPRecv {\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    std::atomic<bool> m_bIsEnd;\n    std::atomic<bool> m_bIsStarted;\n\n    void PollForMessages();\n\npublic:\n    UDPRecv(DFNetWork* poDFNetWork);\n    ~UDPRecv();\n    void Stop();\n    int Init(int iPort);\n    void run();\n};\n\nUDPRecv::UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\nUDPRecv::~UDPRecv() {\n    if (m_iSockFD != -1) {\n        close(m_iSockFD);\n    }\n}\n\nvoid UDPRecv::Stop() {\n    m_bIsEnd = true;\n    if (m_bIsStarted) {\n        // Wait for the thread to finish\n        // In a real scenario, you might need a condition variable or similar\n    }\n}\n\nint UDPRecv::Init(int iPort) {\n    m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n    if (m_iSockFD == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in serverAddr;\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_addr.s_addr = INADDR_ANY;\n    serverAddr.sin_port = htons(iPort);\n\n    if (bind(m_iSockFD, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n        std::cerr << \"Failed to bind socket\" << std::endl;\n        close(m_iSockFD);\n        m_iSockFD = -1;\n        return -1;\n    }\n\n    m_bIsStarted = false;\n    return 0;\n}\n\nvoid UDPRecv::run() {\n    m_bIsStarted = true;\n    while (!m_bIsEnd) {\n        fd_set read_fds;\n        FD_ZERO(&read_fds);\n        FD_SET(m_iSockFD, &read_fds);\n\n        struct timeval timeout;\n        timeout.tv_sec = 0;\n        timeout.tv_usec = 100000; // 100ms\n\n        int activity = select(m_iSockFD + 1, &read_fds, nullptr, nullptr, &timeout);\n        if (activity < 0) {\n            std::cerr << \"Select error\" << std::endl;\n            break;\n        } else if (activity == 0) {\n            // No data received, continue polling\n            continue;\n        }\n\n        if (FD_ISSET(m_iSockFD, &read_fds)) {\n            char buffer[65536];\n            struct sockaddr_in clientAddr;\n            socklen_t addrLen = sizeof(clientAddr);\n\n            int bytesReceived = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&clientAddr, &addrLen);\n            if (bytesReceived > 0) {\n                m_poDFNetWork->ProcessMessage(buffer, bytesReceived);\n            }\n        }\n    }\n    m_bIsStarted = false;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a UDP server class using Boost.Asio that asynchronously receives datagrams and sends responses.\n\nClass Description: The udp_server class implements a UDP server that listens for incoming datagrams on a specified port and responds with a daytime string. It uses Boost.Asio for asynchronous network operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received message\n- recv_buffer_: [std::array<char, 1>] - Buffer for receiving incoming datagrams\n\nMethods:\n- udp_server([boost::asio::io_context&] io_context) -> [void] - Constructor that initializes the UDP socket and starts listening\n- start_receive() -> [void] - Begins asynchronous reception of UDP datagrams\n- handle_receive([const boost::system::error_code&] error) -> [void] - Callback for handling received datagrams and sending responses\n- handle_send([std::shared_ptr<std::string>] message) -> [void] - Callback for handling completed send operations",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error));\n  }\n\n  void handle_receive(const boost::system::error_code& error)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/)\n  {\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1)\n        );\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg_ptr(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg_ptr), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg_ptr, _1)\n            );\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        if (!error) {\n            // Send completed successfully\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg_ptr(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg_ptr), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg_ptr,\n                            boost::asio::placeholders::error));\n        } else {\n            std::cerr << \"Receive error: \" << error.message() << std::endl;\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        if (error) {\n            std::cerr << \"Send error: \" << error.message() << std::endl;\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1)\n        );\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg_ptr(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg_ptr), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg_ptr, _1)\n            );\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        if (!error) {\n            // Send completed successfully\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1)\n    {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"The time is \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg_ptr(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg_ptr), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg_ptr, _1));\n        } else {\n            // Handle error\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        if (!error) {\n            start_receive();\n        } else {\n            // Handle error\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1)\n        );\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg_ptr(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg_ptr), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg_ptr, _1)\n            );\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        if (!error) {\n            // Send completed successfully\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        recv_buffer_.fill(0);\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error)\n        );\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg,\n                            boost::asio::placeholders::error)\n            );\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        // No action needed on send completion\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg,\n                            boost::asio::placeholders::error));\n        } else {\n            std::cerr << \"Error receiving: \" << error.message() << std::endl;\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        if (error) {\n            std::cerr << \"Error sending: \" << error.message() << std::endl;\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        recv_buffer_.fill(0);\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error)\n        );\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg,\n                            boost::asio::placeholders::error)\n            );\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        // No action needed on send completion\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        recv_buffer_.fill(0);\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error));\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg_ptr(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg_ptr), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg_ptr,\n                            boost::asio::placeholders::error));\n        } else {\n            std::cerr << \"Receive error: \" << error.message() << std::endl;\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        if (error) {\n            std::cerr << \"Send error: \" << error.message() << std::endl;\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n#include <array>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 0)) {\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this, _1)\n        );\n    }\n\n    void handle_receive(const boost::system::error_code& error) {\n        if (!error) {\n            std::string message = \"Daytime: \" + std::to_string(std::time(nullptr));\n            std::shared_ptr<std::string> msg_ptr(new std::string(message));\n            socket_.async_send_to(\n                boost::asio::buffer(*msg_ptr), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this, msg_ptr, _1)\n            );\n        }\n        start_receive();\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error) {\n        if (!error) {\n            // Send completed successfully\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nClass Description: The `udp_server` class implements a UDP server that listens on a specified port (13 in this case) for incoming datagrams. When a datagram is received, it responds with the current daytime string. The class uses asynchronous operations for receiving and sending data.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received datagram\n- recv_buffer_: [std::array<char, 1>] - Buffer for storing received data\n\nMethods:\n- Constructor: [udp_server]([boost::asio::io_context& io_context]) -> [void] - Initializes the UDP socket and starts listening for incoming datagrams\n- start_receive: [start_receive]() -> [void] - Begins an asynchronous receive operation on the socket\n- handle_receive: [handle_receive]([const boost::system::error_code& error, std::size_t bytes_transferred]) -> [void] - Handles the completion of a receive operation and initiates a response\n- handle_send: [handle_send]([std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred]) -> [void] - Handles the completion of a send operation\n- make_daytime_string: [make_daytime_string]() -> [std::string] - Generates and returns the current daytime string",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\n\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error,\n          boost::asio::placeholders::bytes_transferred));\n  }\n\n  void handle_receive(const boost::system::error_code& error,\n      std::size_t /*bytes_transferred*/)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message,\n            boost::asio::placeholders::error,\n            boost::asio::placeholders::bytes_transferred));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/,\n      const boost::system::error_code& /*error*/,\n      std::size_t /*bytes_transferred*/)\n  {\n  }\n\n  std::string make_daytime_string()\n  {\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        (void)error;\n        (void)bytes_transferred;\n        start_receive();\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error) {\n            start_receive();\n        }\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        (void)error;\n        (void)bytes_transferred;\n        start_receive();\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        (void)error;\n        (void)bytes_transferred;\n        start_receive();\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        (void)error;\n        (void)bytes_transferred;\n        start_receive();\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        (void)error;\n        (void)bytes_transferred;\n        start_receive();\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        (void)error;\n        (void)bytes_transferred;\n        start_receive();\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error) {\n            start_receive();\n        }\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        (void)error;\n        (void)bytes_transferred;\n        start_receive();\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <ctime>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13)),\n          remote_endpoint_(boost::asio::ip::udp::endpoint()),\n          recv_buffer_(1) {\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                        boost::asio::placeholders::error,\n                        boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            std::shared_ptr<std::string> message(new std::string(\" \"));\n            *message = make_daytime_string();\n            socket_.async_send_to(\n                boost::asio::buffer(*message), remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                            message,\n                            boost::asio::placeholders::error,\n                            boost::asio::placeholders::bytes_transferred));\n        } else {\n            start_receive();\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred) {\n        if (!error) {\n            start_receive();\n        }\n    }\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[1024];\n        strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S %Z\", localtime(&now));\n        return std::string(buffer);\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    std::array<char, 1> recv_buffer_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests to a specified base URL.\n\nClass Description: The HTTPClient class provides a simple interface for making HTTP GET requests to a given base URL. It handles libcurl initialization, request configuration, execution, and cleanup, while providing a method to append endpoints to the base URL and make requests.\n\nAttributes:\nbaseURL: std::string - The base URL to which endpoints will be appended for HTTP requests\n\nMethods:\nmakeRequest: makeRequest(const std::string& endpoint) -> std::string - Makes an HTTP GET request to the base URL plus the specified endpoint, returning the response as a string\nwrite_to_string: write_to_string(void* ptr, size_t size, size_t count, void* stream) -> size_t - Static callback function for libcurl to write response data into a string",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <sstream>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string URL = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, URL.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_perform(curl);\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, 0, size*count);\n        return size*count;\n    }\n\n    std::string baseURL;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [],
    "unmatched_results": [
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        size_t realsize = size * count;\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), realsize);\n        return realsize;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        size_t realsize = size * count;\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), realsize);\n        return realsize;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};",
      "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string fullUrl = baseURL + endpoint;\n        std::string response;\n\n        curl_easy_setopt(curl, CURLOPT_URL, fullUrl.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* response = static_cast<std::string*>(stream);\n        response->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL;\n    CURL* curl;\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that can asynchronously receive and send datagrams.\n\nClass Description: The `server` class represents a UDP server that listens on a specified port, receives incoming datagrams asynchronously, and sends responses back to the sender. It utilizes Boost.Asio for asynchronous I/O operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- sender_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last sender\n- max_length: [enum] - Maximum size of the receive buffer (1024 bytes)\n- data_: [char[max_length]] - Buffer for storing received data\n\nMethods:\n- server: [constructor](boost::asio::io_context& io_context, short port) -> void - Initializes the UDP socket and starts the receive operation\n- do_receive: [method]() -> void - Asynchronously receives data from clients and triggers do_send if data is received\n- do_send: [method](std::size_t length) -> void - Asynchronously sends the received data back to the sender",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n\nusing boost::asio::ip::udp;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, short port)\n    : socket_(io_context, udp::endpoint(udp::v4(), port))\n  {\n    do_receive();\n  }\n\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd)\n        {\n          if (!ec && bytes_recvd > 0)\n          {\n            do_send(bytes_recvd);\n          }\n          else\n          {\n            do_receive();\n          }\n        });\n  }\n\n  void do_send(std::size_t length)\n  {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length), sender_endpoint_,\n        [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/)\n        {\n          do_receive();\n        });\n  }\n\nprivate:\n  udp::socket socket_;\n  udp::endpoint sender_endpoint_;\n  enum { max_length = 1024 };\n  char data_[max_length];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n\nclass server {\npublic:\n    enum max_length { MAX_LENGTH = 1024 };\n    char data_[MAX_LENGTH];\n\n    server(boost::asio::io_context& io_context, short port) : socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)), sender_endpoint_(boost::asio::ip::udp::endpoint()) {\n        do_receive();\n    }\n\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, MAX_LENGTH),\n            sender_endpoint_,\n            boost::bind(&server::do_send, this, _1)\n        );\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length),\n            sender_endpoint_,\n            boost::bind(&server::do_receive, this)\n        );\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n};"
    ],
    "unmatched_results": [
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            } else {\n                do_receive();\n            }\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (!ec) {\n                do_receive();\n            }\n        }\n    );\n}",
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            } else {\n                do_receive();\n            }\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (!ec) {\n                do_receive();\n            }\n        }\n    );\n}",
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            } else {\n                do_receive();\n            }\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (!ec) {\n                do_receive();\n            }\n        }\n    );\n}",
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            } else {\n                do_receive();\n            }\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (!ec) {\n                do_receive();\n            }\n        }\n    );\n}",
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            }\n            do_receive();\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (ec) {\n                // Handle error\n            }\n        }\n    );\n}",
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            } else {\n                do_receive();\n            }\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (!ec) {\n                do_receive();\n            }\n        }\n    );\n}",
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            } else {\n                do_receive();\n            }\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (!ec) {\n                do_receive();\n            }\n        }\n    );\n}",
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            }\n            do_receive();\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (ec) {\n                // Handle error\n            }\n        }\n    );\n}",
      "boost::asio::ip::udp::socket socket_;\nboost::asio::ip::udp::endpoint sender_endpoint_;\nenum max_length { max_length = 1024 };\nchar data_[max_length];\n\nserver(boost::asio::io_context& io_context, short port) {\n    socket_.open(boost::asio::ip::udp::v4());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    do_receive();\n}\n\nvoid do_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                do_send(bytes_recvd);\n            } else {\n                do_receive();\n            }\n        }\n    );\n}\n\nvoid do_send(std::size_t length) {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length),\n        sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_sent) {\n            if (!ec) {\n                do_receive();\n            }\n        }\n    );\n}"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Implement a UDP server using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nFunction Description: The function `udp_server` creates a UDP server that listens on port 13 (daytime protocol port). When it receives any datagram from a client, it responds with the current time in string format. The server runs indefinitely until an exception occurs.\n\nInput: None\n\nOutput: None (The function runs indefinitely and sends responses to clients, but doesn't return any value)",
    "Canonical_solution": "#include <array>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n  using namespace std;\n  time_t now = time(0);\n  return ctime(&now);\n}\n\nvoid udp_server()\n{\n  try\n  {\n    boost::asio::io_context io_context;\n\n    udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n    for (;;)\n    {\n      std::array<char, 1> recv_buf;\n      udp::endpoint remote_endpoint;\n      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);\n\n      std::string message = make_daytime_string();\n\n      boost::system::error_code ignored_error;\n      socket.send_to(boost::asio::buffer(message),\n          remote_endpoint, 0, ignored_error);\n    }\n  }\n  catch (std::exception& e)\n  {\n    std::cerr << e.what() << std::endl;\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received \" << length << \" bytes from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received \" << length << \" bytes from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received \" << length << \" bytes from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received \" << length << \" bytes from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received \" << length << \" bytes from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received \" << length << \" bytes from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received \" << length << \" bytes from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char data[1024];\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n            std::cout << \"Received \" << length << \" bytes from \" << remote_endpoint << std::endl;\n\n            boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n            std::string response = boost::posix_time::to_simple_string(now);\n\n            socket.send_to(boost::asio::buffer(response), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a UDP multicast sender class using Boost.Asio that periodically sends messages to a specified multicast address.\n\nClass Description: The `sender` class encapsulates functionality for sending UDP multicast messages at regular intervals. It uses Boost.Asio for asynchronous network operations and timer management.\n\nAttributes:\n- endpoint_: [boost::asio::ip::udp::endpoint] - The multicast endpoint (address + port) to send messages to\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for sending messages\n- timer_: [boost::asio::steady_timer] - Timer used to schedule message sends\n- message_count_: [int] - Counter tracking the number of messages sent\n- message_: [std::string] - The current message content to be sent\n\nMethods:\n- sender([boost::asio::io_context&] io_context, [const boost::asio::ip::address&] multicast_address) -> [void] - Constructor that initializes the sender with IO context and multicast address\n- do_send() -> [void] - Asynchronously sends the current message to the multicast endpoint\n- do_timeout() -> [void] - Sets up a timer to schedule the next message send after a delay",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <string>\n#include <chrono>\n\nclass sender\n{\npublic:\n  sender(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& multicast_address)\n    : endpoint_(multicast_address, multicast_port),\n      socket_(io_context, endpoint_.protocol()),\n      timer_(io_context),\n      message_count_(0)\n  {\n    do_send();\n  }\n\nprivate:\n  void do_send()\n  {\n    std::ostringstream os;\n    os << \"Message \" << message_count_++;\n    message_ = os.str();\n\n    socket_.async_send_to(\n        boost::asio::buffer(message_), endpoint_,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && message_count_ < max_message_count)\n            do_timeout();\n        });\n  }\n\n  void do_timeout()\n  {\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(\n        [this](boost::system::error_code ec)\n        {\n          if (!ec)\n            do_send();\n        });\n  }\n\nprivate:\n  boost::asio::ip::udp::endpoint endpoint_;\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::steady_timer timer_;\n  int message_count_;\n  std::string message_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        socket_.open(endpoint_.protocol());\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        socket_.bind(endpoint_);\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(1));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(2));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        socket_.open(endpoint_.protocol());\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        socket_.bind(endpoint_);\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(1));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(2));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        socket_.open(endpoint_.protocol());\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        socket_.bind(endpoint_);\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(1));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(2));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        socket_.open(endpoint_.protocol());\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        socket_.bind(endpoint_);\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(1));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(2));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        socket_.open(endpoint_.protocol());\n        socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n        socket_.bind(endpoint_);\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(1));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(multicast_address, 50001), socket_(io_context), timer_(io_context), message_count_(0), message_(\"Hello, Multicast!\") {\n        do_timeout();\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n        do_timeout();\n    }\n\n    void do_timeout() {\n        timer_.expires_from_now(boost::asio::chrono::seconds(2));\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Implement a UDP echo server using Boost.Asio that listens on a specified port, receives incoming datagrams, and sends them back to the sender.\n\nFunction Description: The function creates a UDP socket bound to a specified port, then enters an infinite loop where it receives datagrams from clients and echoes them back to the sender. This demonstrates basic UDP communication using Boost.Asio.\n\nInput:\n- io_context: boost::asio::io_context& - Reference to an I/O execution context that manages asynchronous operations\n- port: unsigned short - The port number on which the server should listen for incoming UDP datagrams\n\nOutput: None (The function runs indefinitely in a loop, processing incoming datagrams)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\nenum { max_length = 1024 };\n\nvoid server(boost::asio::io_context& io_context, unsigned short port)\n{\n  udp::socket sock(io_context, udp::endpoint(udp::v4(), port));\n  for (;;)\n  {\n    char data[max_length];\n    udp::endpoint sender_endpoint;\n    size_t length = sock.receive_from(\n        boost::asio::buffer(data, max_length), sender_endpoint);\n    sock.send_to(boost::asio::buffer(data, length), sender_endpoint);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::array<char, 65536> recv_buffer;\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    char data[65536];\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(data), remote_endpoint);\n        socket.send_to(boost::asio::buffer(data, length), remote_endpoint);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::array<char, 65536> recv_buffer;\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::array<char, 1024> recv_buffer;\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::array<char, 65536> recv_buffer;\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::array<char, 65536> recv_buffer;\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    try {\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::array<char, 65536> recv_buffer;\n\n        while (true) {\n            size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n            socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n        std::cerr << \"Exception in UDP echo server: \" << e.what() << \"\\n\";\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::array<char, 65536> recv_buffer;\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::array<char, 1024> recv_buffer;\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid udp_echo_server(boost::asio::io_context& io_context, unsigned short port) {\n    boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port));\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::array<char, 65536> recv_buffer;\n\n    while (true) {\n        size_t length = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        socket.send_to(boost::asio::buffer(recv_buffer, length), remote_endpoint);\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a UDP client communication function using Boost.Asio to send a message to a specified host and port, and receive a response.\n\nFunction Description: The function establishes a UDP client connection, sends a message to a specified server, and waits to receive a response. It uses Boost.Asio for asynchronous UDP operations.\n\nInput:\n- host: [std::string] - The hostname or IP address of the UDP server to connect to\n- port: [std::string] - The port number of the UDP server\n- message: [std::string] - The message to be sent to the server\n\nOutput: None (The function receives a reply from the server but doesn't return it. In a real implementation, you might want to return the reply or process it further.)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client_communication(const std::string& host, const std::string& port, const std::string& message)\n{\n    boost::asio::io_context io_context;\n    udp::socket s(io_context, udp::endpoint(udp::v4(), 0));\n    udp::resolver resolver(io_context);\n    udp::resolver::results_type endpoints = resolver.resolve(udp::v4(), host, port);\n\n    size_t request_length = message.length();\n    s.send_to(boost::asio::buffer(message, request_length), *endpoints.begin());\n\n    char reply[max_length];\n    udp::endpoint sender_endpoint;\n    size_t reply_length = s.receive_from(boost::asio::buffer(reply, max_length), sender_endpoint);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n\n        socket.open(boost::asio::ip::udp::v4());\n        socket.send_to(boost::asio::buffer(message), remote_endpoint);\n\n        boost::asio::streambuf receive_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        socket.receive_from(boost::asio::buffer(receive_buffer), sender_endpoint);\n\n        std::istream is(&receive_buffer);\n        std::string reply((std::istreambuf_iterator<char>(is)), std::istreambuf_iterator<char>());\n        std::cout << \"Received: \" << reply << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n        boost::asio::ip::udp::socket socket(io_context);\n        socket.open(endpoint.protocol());\n        socket.send_to(boost::asio::buffer(message), endpoint);\n\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::array<char, 1024> recv_buffer;\n        size_t bytes_received = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        std::cout.write(recv_buffer.data(), bytes_received);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n        boost::asio::ip::udp::socket socket(io_context);\n        socket.open(endpoint.protocol());\n        socket.send_to(boost::asio::buffer(message), endpoint);\n\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        std::array<char, 1024> recv_buffer;\n        size_t bytes_received = socket.receive_from(boost::asio::buffer(recv_buffer), sender_endpoint);\n        std::cout.write(recv_buffer.data(), bytes_received);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n\n        socket.open(boost::asio::ip::udp::v4());\n        socket.send_to(boost::asio::buffer(message), remote_endpoint);\n\n        boost::asio::streambuf receive_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        socket.receive_from(boost::asio::buffer(receive_buffer), sender_endpoint);\n\n        std::istream is(&receive_buffer);\n        std::string reply((std::istreambuf_iterator<char>(is)), std::istreambuf_iterator<char>());\n        std::cout << \"Received: \" << reply << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n\n        socket.open(boost::asio::ip::udp::v4());\n        socket.send_to(boost::asio::buffer(message), remote_endpoint);\n\n        boost::asio::streambuf receive_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        socket.receive_from(boost::asio::buffer(receive_buffer), sender_endpoint);\n\n        std::istream is(&receive_buffer);\n        std::string reply((std::istreambuf_iterator<char>(is)), std::istreambuf_iterator<char>());\n        std::cout << \"Received: \" << reply << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n\n        socket.open(boost::asio::ip::udp::v4());\n        socket.send_to(boost::asio::buffer(message), remote_endpoint);\n\n        boost::asio::streambuf receive_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        socket.receive_from(boost::asio::buffer(receive_buffer), sender_endpoint);\n\n        std::istream is(&receive_buffer);\n        std::string reply((std::istreambuf_iterator<char>(is)), std::istreambuf_iterator<char>());\n        std::cout << \"Received: \" << reply << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n        boost::asio::ip::udp::socket socket(io_context);\n        socket.open(endpoint.protocol());\n        socket.send_to(boost::asio::buffer(message), endpoint);\n\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::array<char, 1024> recv_buffer;\n        size_t bytes_received = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        std::cout.write(recv_buffer.data(), bytes_received);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n\n        socket.open(boost::asio::ip::udp::v4());\n        socket.send_to(boost::asio::buffer(message), remote_endpoint);\n\n        boost::asio::streambuf receive_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        socket.receive_from(boost::asio::buffer(receive_buffer), sender_endpoint);\n\n        std::istream is(&receive_buffer);\n        std::string reply((std::istreambuf_iterator<char>(is)), std::istreambuf_iterator<char>());\n        std::cout << \"Received: \" << reply << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n        boost::asio::ip::udp::socket socket(io_context);\n        socket.open(endpoint.protocol());\n        socket.send_to(boost::asio::buffer(message), endpoint);\n\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::array<char, 1024> recv_buffer;\n        size_t bytes_received = socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint);\n        std::cout.write(recv_buffer.data(), bytes_received);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n\n        socket.open(boost::asio::ip::udp::v4());\n        socket.send_to(boost::asio::buffer(message), remote_endpoint);\n\n        boost::asio::streambuf reply_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        socket.receive_from(boost::asio::buffer(reply_buffer), sender_endpoint);\n\n        std::cout << \"Received reply: \";\n        std::istream is(&reply_buffer);\n        std::string reply;\n        std::getline(is, reply);\n        std::cout << reply << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that handles incoming UDP packets, processes them, and sends replies back to clients. The server should run asynchronously in a separate thread and provide a callback mechanism for handling incoming requests.\n\nClass Description: UDPServer::Impl is an implementation class for a UDP server that listens for incoming packets, validates them, and forwards valid packets to a callback function. It also provides functionality to send replies back to clients.\n\nAttributes:\n- worker_thread: std::thread - Thread that runs the IO context for asynchronous operations\n- io_context: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket: boost::asio::ip::udp::socket - UDP socket for communication\n- request_buffer: std::array<u8, MAX_PACKET_SIZE> - Buffer for storing incoming UDP packets\n- remote_endpoint: boost::asio::ip::udp::endpoint - Stores the endpoint of the last received packet\n- new_request_callback: std::function<void(std::unique_ptr<Packet>)> - Callback function for handling new valid packets\n\nMethods:\n- Impl(std::function<void(std::unique_ptr<Packet>)>) -> None - Constructor that initializes the UDP socket and starts the receive loop\n- ~Impl() -> None - Destructor that stops the IO context and joins the worker thread\n- StartReceive() -> None - Starts an asynchronous receive operation on the UDP socket\n- HandleReceive(const boost::system::error_code&, std::size_t) -> None - Handles received data, validates packets, and triggers the callback for valid packets\n- SendReply(boost::asio::ip::udp::endpoint, Packet&) -> None - Sends a reply packet back to the specified endpoint",
    "Canonical_solution": "#include <thread>\n#include <boost/asio.hpp>\n#include <functional>\n#include <memory>\n#include <array>\n#include \"common/common_types.h\"\n#include \"common/logging/log.h\"\n#include \"core/rpc/packet.h\"\n\nnamespace Core::RPC {\n\nclass UDPServer::Impl {\npublic:\n    explicit Impl(std::function<void(std::unique_ptr<Packet>)> new_request_callback)\n        : socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 45987)),\n          new_request_callback(std::move(new_request_callback)) {\n\n        StartReceive();\n        worker_thread = std::thread([this] { io_context.run(); });\n    }\n\n    ~Impl() {\n        io_context.stop();\n        worker_thread.join();\n    }\n\nprivate:\n    void StartReceive() {\n        socket.async_receive_from(boost::asio::buffer(request_buffer), remote_endpoint,\n                                  [this](const boost::system::error_code& error, std::size_t size) {\n                                      HandleReceive(error, size);\n                                  });\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t size) {\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to receive data on UDP socket: {}\", error.message());\n        } else if (size >= MIN_PACKET_SIZE && size <= MAX_PACKET_SIZE) {\n            PacketHeader header;\n            std::memcpy(&header, request_buffer.data(), sizeof(header));\n            if ((size - MIN_PACKET_SIZE) == header.packet_size) {\n                u8* data = request_buffer.data() + MIN_PACKET_SIZE;\n                std::function<void(Packet&)> send_reply_callback =\n                    std::bind(&Impl::SendReply, this, remote_endpoint, std::placeholders::_1);\n                std::unique_ptr<Packet> new_packet =\n                    std::make_unique<Packet>(header, data, send_reply_callback);\n\n                new_request_callback(std::move(new_packet));\n            }\n        } else {\n            LOG_WARNING(RPC_Server, \"Received message with wrong size: {}\", size);\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply_packet) {\n        std::vector<u8> reply_buffer(MIN_PACKET_SIZE + reply_packet.GetPacketDataSize());\n        auto reply_header = reply_packet.GetHeader();\n\n        std::memcpy(reply_buffer.data(), &reply_header, sizeof(reply_header));\n        std::memcpy(reply_buffer.data() + (4 * sizeof(u32)), reply_packet.GetPacketData().data(),\n                    reply_packet.GetPacketDataSize());\n\n        boost::system::error_code error;\n        socket.send_to(boost::asio::buffer(reply_buffer), endpoint, 0, error);\n\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to send reply: {}\", error.message());\n        } else {\n            LOG_INFO(RPC_Server, \"Sent reply version({}) id=({}) type=({}) size=({})\",\n                     reply_packet.GetVersion(), reply_packet.GetId(), reply_packet.GetPacketType(),\n                     reply_packet.GetPacketDataSize());\n        }\n    }\n\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace Core::RPC",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nusing boost::asio::ip::udp;\nusing boost::system::error_code;\n\nstruct Packet {\n    std::array<u8, 1024> data;\n    size_t size;\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : new_request_callback(callback), io_context(), socket(io_context, udp::endpoint(udp::v4(), 12345)), request_buffer(1024), remote_endpoint() {\n            worker_thread = std::thread([this]() { io_context.run(); });\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer), remote_endpoint,\n                [this](const error_code& ec, std::size_t bytes_recvd) {\n                    HandleReceive(ec, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const error_code& ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                std::unique_ptr<Packet> packet = std::make_unique<Packet>();\n                packet->size = bytes_recvd;\n                std::copy(request_buffer.begin(), request_buffer.begin() + bytes_recvd, packet->data.begin());\n                new_request_callback(std::move(packet));\n                StartReceive();\n            }\n        }\n\n        void SendReply(udp::endpoint endpoint, Packet& reply) {\n            socket.send_to(boost::asio::buffer(reply.data, reply.size), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        udp::socket socket;\n        std::array<u8, 1024> request_buffer;\n        udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nnamespace UDPServer {\n\nclass Impl {\npublic:\n    using u8 = unsigned char;\n    static constexpr std::size_t MAX_PACKET_SIZE = 65535;\n\n    Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n        : new_request_callback(callback), io_context(), socket(io_context), request_buffer(MAX_PACKET_SIZE), remote_endpoint() {\n        worker_thread = std::thread([this]() { io_context.run(); });\n        StartReceive();\n    }\n\n    ~Impl() {\n        io_context.stop();\n        if (worker_thread.joinable()) {\n            worker_thread.join();\n        }\n    }\n\n    void StartReceive() {\n        socket.async_receive_from(\n            boost::asio::buffer(request_buffer), remote_endpoint,\n            std::bind(&Impl::HandleReceive, this, std::placeholders::_1, std::placeholders::_2)\n        );\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n        if (!error && bytes_received > 0) {\n            std::unique_ptr<Packet> packet(new Packet());\n            // Assume Packet is a class that can be constructed from the buffer\n            packet->data = std::vector<u8>(request_buffer.begin(), request_buffer.begin() + bytes_received);\n            new_request_callback(std::move(packet));\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply) {\n        socket.send_to(boost::asio::buffer(reply.data), endpoint);\n    }\n\nprivate:\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace UDPServer",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nnamespace UDPServer {\n\nclass Impl {\npublic:\n    using u8 = unsigned char;\n    static constexpr std::size_t MAX_PACKET_SIZE = 65535;\n\n    Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n        : new_request_callback(callback), io_context(), socket(io_context), request_buffer(MAX_PACKET_SIZE), remote_endpoint() {\n        worker_thread = std::thread([this]() { io_context.run(); });\n        StartReceive();\n    }\n\n    ~Impl() {\n        io_context.stop();\n        if (worker_thread.joinable()) {\n            worker_thread.join();\n        }\n    }\n\n    void StartReceive() {\n        socket.async_receive_from(\n            boost::asio::buffer(request_buffer), remote_endpoint,\n            std::bind(&Impl::HandleReceive, this, std::placeholders::_1, std::placeholders::_2)\n        );\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n        if (!error && bytes_received > 0) {\n            std::unique_ptr<Packet> packet(new Packet());\n            packet->data = std::vector<u8>(request_buffer.begin(), request_buffer.begin() + bytes_received);\n            packet->source = remote_endpoint;\n            new_request_callback(std::move(packet));\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply) {\n        socket.send_to(boost::asio::buffer(reply.data), endpoint);\n    }\n\nprivate:\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace UDPServer",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nnamespace UDPServer {\n\nclass Impl {\npublic:\n    using u8 = unsigned char;\n    static constexpr std::size_t MAX_PACKET_SIZE = 65535;\n\n    Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n        : new_request_callback(callback), io_context(), socket(io_context), request_buffer(MAX_PACKET_SIZE), remote_endpoint() {\n        worker_thread = std::thread([this]() { io_context.run(); });\n        StartReceive();\n    }\n\n    ~Impl() {\n        io_context.stop();\n        if (worker_thread.joinable()) {\n            worker_thread.join();\n        }\n    }\n\n    void StartReceive() {\n        socket.async_receive_from(\n            boost::asio::buffer(request_buffer), remote_endpoint,\n            std::bind(&Impl::HandleReceive, this, std::placeholders::_1, std::placeholders::_2)\n        );\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n        if (!error && bytes_received > 0) {\n            std::unique_ptr<Packet> packet(new Packet());\n            // Assume Packet is a class that can be constructed from the buffer\n            packet->data = std::vector<u8>(request_buffer.begin(), request_buffer.begin() + bytes_received);\n            new_request_callback(std::move(packet));\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply) {\n        socket.send_to(boost::asio::buffer(reply.data), endpoint);\n    }\n\nprivate:\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace UDPServer",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nnamespace UDPServer {\n\nclass Impl {\npublic:\n    using u8 = unsigned char;\n    static constexpr std::size_t MAX_PACKET_SIZE = 65535;\n\n    Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n        : new_request_callback(callback), io_context(), socket(io_context), request_buffer(MAX_PACKET_SIZE), remote_endpoint() {\n        worker_thread = std::thread([this]() { io_context.run(); });\n        StartReceive();\n    }\n\n    ~Impl() {\n        io_context.stop();\n        if (worker_thread.joinable()) {\n            worker_thread.join();\n        }\n    }\n\n    void StartReceive() {\n        socket.async_receive_from(\n            boost::asio::buffer(request_buffer), remote_endpoint,\n            std::bind(&Impl::HandleReceive, this, std::placeholders::_1, std::placeholders::_2)\n        );\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n        if (!error && bytes_received > 0) {\n            std::unique_ptr<Packet> packet(new Packet());\n            // Assume Packet is a class that can be constructed from the buffer\n            packet->data = std::vector<u8>(request_buffer.begin(), request_buffer.begin() + bytes_received);\n            new_request_callback(std::move(packet));\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply) {\n        socket.send_to(boost::asio::buffer(reply.data), endpoint);\n    }\n\nprivate:\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace UDPServer",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nnamespace UDPServer {\n\nclass Impl {\npublic:\n    using u8 = unsigned char;\n    static constexpr std::size_t MAX_PACKET_SIZE = 65535;\n\n    Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n        : new_request_callback(callback), io_context(), socket(io_context), request_buffer(MAX_PACKET_SIZE), remote_endpoint() {\n        worker_thread = std::thread([this]() { io_context.run(); });\n        StartReceive();\n    }\n\n    ~Impl() {\n        io_context.stop();\n        if (worker_thread.joinable()) {\n            worker_thread.join();\n        }\n    }\n\n    void StartReceive() {\n        socket.async_receive_from(\n            boost::asio::buffer(request_buffer), remote_endpoint,\n            std::bind(&Impl::HandleReceive, this, std::placeholders::_1, std::placeholders::_2)\n        );\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n        if (!error && bytes_received > 0) {\n            std::unique_ptr<Packet> packet(new Packet());\n            // Assume Packet is a class that can be constructed from the buffer\n            packet->data = std::vector<u8>(request_buffer.begin(), request_buffer.begin() + bytes_received);\n            new_request_callback(std::move(packet));\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply) {\n        socket.send_to(boost::asio::buffer(reply.data), endpoint);\n    }\n\nprivate:\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace UDPServer",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nnamespace UDPServer {\n\nclass Impl {\npublic:\n    using u8 = unsigned char;\n    static constexpr std::size_t MAX_PACKET_SIZE = 65535;\n\n    Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n        : new_request_callback(callback), io_context(), socket(io_context), request_buffer(MAX_PACKET_SIZE), remote_endpoint() {\n        worker_thread = std::thread([this]() { io_context.run(); });\n        StartReceive();\n    }\n\n    ~Impl() {\n        io_context.stop();\n        if (worker_thread.joinable()) {\n            worker_thread.join();\n        }\n    }\n\n    void StartReceive() {\n        socket.async_receive_from(\n            boost::asio::buffer(request_buffer), remote_endpoint,\n            std::bind(&Impl::HandleReceive, this, std::placeholders::_1, std::placeholders::_2)\n        );\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n        if (!error && bytes_received > 0) {\n            std::unique_ptr<Packet> packet(new Packet());\n            packet->data = std::vector<u8>(request_buffer.begin(), request_buffer.begin() + bytes_received);\n            if (ValidatePacket(*packet)) {\n                new_request_callback(std::move(packet));\n            }\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply) {\n        socket.send_to(boost::asio::buffer(reply.data), endpoint);\n    }\n\nprivate:\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n\n    bool ValidatePacket(Packet& packet) {\n        // Implement packet validation logic here\n        return true;\n    }\n};\n\n} // namespace UDPServer",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nnamespace UDPServer {\n\nclass Impl {\npublic:\n    using u8 = unsigned char;\n    static constexpr std::size_t MAX_PACKET_SIZE = 65535;\n\n    Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n        : new_request_callback(callback), io_context(), socket(io_context), request_buffer(MAX_PACKET_SIZE), remote_endpoint() {\n        worker_thread = std::thread([this]() { io_context.run(); });\n        StartReceive();\n    }\n\n    ~Impl() {\n        io_context.stop();\n        if (worker_thread.joinable()) {\n            worker_thread.join();\n        }\n    }\n\n    void StartReceive() {\n        socket.async_receive_from(\n            boost::asio::buffer(request_buffer), remote_endpoint,\n            std::bind(&Impl::HandleReceive, this, std::placeholders::_1, std::placeholders::_2)\n        );\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n        if (!error && bytes_received > 0) {\n            std::unique_ptr<Packet> packet(new Packet());\n            // Assume Packet is a class that can be constructed from the buffer\n            packet->data = std::vector<u8>(request_buffer.begin(), request_buffer.begin() + bytes_received);\n            new_request_callback(std::move(packet));\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply) {\n        socket.send_to(boost::asio::buffer(reply.data), endpoint);\n    }\n\nprivate:\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace UDPServer",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nnamespace UDPServer {\n\nclass Impl {\npublic:\n    using u8 = unsigned char;\n    static constexpr std::size_t MAX_PACKET_SIZE = 65535;\n\n    Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n        : new_request_callback(callback), io_context(), socket(io_context), request_buffer(MAX_PACKET_SIZE), remote_endpoint() {\n        worker_thread = std::thread([this]() { io_context.run(); });\n        StartReceive();\n    }\n\n    ~Impl() {\n        io_context.stop();\n        if (worker_thread.joinable()) {\n            worker_thread.join();\n        }\n    }\n\n    void StartReceive() {\n        socket.async_receive_from(\n            boost::asio::buffer(request_buffer), remote_endpoint,\n            std::bind(&Impl::HandleReceive, this, std::placeholders::_1, std::placeholders::_2)\n        );\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t bytes_received) {\n        if (!error && bytes_received > 0) {\n            std::unique_ptr<Packet> packet(new Packet());\n            packet->data = std::vector<u8>(request_buffer.begin(), request_buffer.begin() + bytes_received);\n            packet->source = remote_endpoint;\n            new_request_callback(std::move(packet));\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply) {\n        socket.send_to(boost::asio::buffer(reply.data), endpoint);\n    }\n\nprivate:\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace UDPServer",
      "#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n#include <array>\n\nusing boost::asio::ip::udp;\nusing boost::system::error_code;\n\nstruct Packet {\n    std::array<u8, 1024> data;\n    size_t size;\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        Impl(std::function<void(std::unique_ptr<Packet>)> callback)\n            : new_request_callback(callback), io_context(), socket(io_context, udp::endpoint(udp::v4(), 12345)), request_buffer(1024), remote_endpoint() {\n            worker_thread = std::thread([this]() { io_context.run(); });\n            StartReceive();\n        }\n\n        ~Impl() {\n            io_context.stop();\n            if (worker_thread.joinable()) {\n                worker_thread.join();\n            }\n        }\n\n        void StartReceive() {\n            socket.async_receive_from(\n                boost::asio::buffer(request_buffer), remote_endpoint,\n                [this](const error_code& ec, std::size_t bytes_recvd) {\n                    HandleReceive(ec, bytes_recvd);\n                });\n        }\n\n        void HandleReceive(const error_code& ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                std::unique_ptr<Packet> packet = std::make_unique<Packet>();\n                packet->size = bytes_recvd;\n                std::copy(request_buffer.begin(), request_buffer.begin() + bytes_recvd, packet->data.begin());\n                new_request_callback(std::move(packet));\n                StartReceive();\n            } else {\n                StartReceive();\n            }\n        }\n\n        void SendReply(udp::endpoint endpoint, Packet& reply) {\n            socket.send_to(boost::asio::buffer(reply.data, reply.size), endpoint);\n        }\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        udp::socket socket;\n        std::array<u8, 1024> request_buffer;\n        udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a UDP multicast receiver class using Boost.Asio that listens for incoming datagrams on a specified multicast address and port, and prints received messages to the console.\n\nClass Description: The `receiver` class encapsulates functionality for receiving UDP multicast messages. It initializes a UDP socket, joins a multicast group, and asynchronously receives datagrams, printing their contents to standard output.\n\nAttributes:\n- socket_: boost::asio::ip::udp::socket - The UDP socket used for communication\n- sender_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint of the sender of the last received message\n- data_: std::array<char, 1024> - Buffer for storing received data\n\nMethods:\n- receiver(boost::asio::io_context&, const boost::asio::ip::address&, const boost::asio::ip::address&) -> None - Constructor that initializes the socket, binds it to the listening address and port, joins the multicast group, and starts receiving\n- do_receive() -> None - Private method that asynchronously receives data and prints it to console, then continues listening for more data",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nconstexpr short multicast_port = 30001;\n\nclass receiver\n{\npublic:\n  receiver(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& listen_address,\n      const boost::asio::ip::address& multicast_address)\n    : socket_(io_context)\n  {\n    // Create the socket so that multiple may be bound to the same address.\n    boost::asio::ip::udp::endpoint listen_endpoint(\n        listen_address, multicast_port);\n    socket_.open(listen_endpoint.protocol());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(listen_endpoint);\n\n    // Join the multicast group.\n    socket_.set_option(\n        boost::asio::ip::multicast::join_group(multicast_address));\n\n    do_receive();\n  }\n\nprivate:\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::cout.write(data_.data(), length);\n            std::cout << std::endl;\n\n            do_receive();\n          }\n        });\n  }\n\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::ip::udp::endpoint sender_endpoint_;\n  std::array<char, 1024> data_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 0)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 0);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 50001)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 50001);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 0)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 0);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 0)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 0);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 0)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 0);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 0)), data_(1024) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 0);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 0)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 0);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 0)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 0);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 50000)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 50000);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};",
      "#include <boost/asio.hpp>\n#include <array>\n#include <iostream>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address) \n        : socket_(io_context, boost::asio::ip::udp::endpoint(listen_address, 50000)) {\n        boost::asio::ip::udp::endpoint group_endpoint(multicast_address, 50000);\n        socket_.set_option(boost::asio::ip::multicast::join_group(group_endpoint));\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_), sender_endpoint_,\n            [&](const boost::system::error_code& error, std::size_t bytes_recvd) {\n                if (!error && bytes_recvd > 0) {\n                    std::cout.write(data_.data(), bytes_recvd);\n                    std::cout << std::endl;\n                }\n                do_receive();\n            }\n        );\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a UDP client function using Boost.Asio that sends a request to a UDP server and receives a response.\n\nFunction Description: The function establishes a UDP connection to a specified host, sends a minimal request packet, waits for a response, and prints the received data to standard output. It uses Boost.Asio for asynchronous UDP operations.\n\nInput: \n- host: std::string - The hostname or IP address of the UDP server to connect to\n\nOutput: \n- None (void function), but prints the received data to standard output\n\nNote: The function uses a fixed service name \"daytime\" (port 13) for demonstration purposes. In a real application, this would typically be configurable. The function handles both IPv4 and UDP protocol operations.",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client(const std::string& host)\n{\n    boost::asio::io_context io_context;\n\n    udp::resolver resolver(io_context);\n    udp::endpoint receiver_endpoint =\n      *resolver.resolve(udp::v4(), host, \"daytime\").begin();\n\n    udp::socket socket(io_context);\n    socket.open(udp::v4());\n\n    std::array<char, 1> send_buf  = {{ 0 }};\n    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n\n    std::array<char, 128> recv_buf;\n    udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(\n        boost::asio::buffer(recv_buf), sender_endpoint);\n\n    std::cout.write(recv_buf.data(), len);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), 13);\n\n        std::string request = \"Hello, server!\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        char response[1024];\n        size_t length = socket.receive_from(boost::asio::buffer(response), sender_endpoint);\n        std::cout.write(response, length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), 13);\n\n        std::string request = \"Hello, server!\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        char response[1024];\n        size_t response_length = socket.receive_from(boost::asio::buffer(response), sender_endpoint);\n\n        std::cout.write(response, response_length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), 13);\n\n        std::string request = \"Hello, server!\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        char response[1024];\n        size_t response_length = socket.receive_from(boost::asio::buffer(response), sender_endpoint);\n\n        std::cout.write(response, response_length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), 13);\n\n        std::string request = \"Hello, server!\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        char response[1024];\n        size_t length = socket.receive_from(boost::asio::buffer(response), sender_endpoint);\n\n        std::cout.write(response, length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), 13);\n\n        std::string request = \"Hello, server!\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        char response[1024];\n        size_t length = socket.receive_from(boost::asio::buffer(response), sender_endpoint);\n\n        std::cout.write(response, length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::udp::v4(), 13);\n\n        // Resolve the host to an endpoint\n        boost::asio::ip::udp::resolver resolver(io_context);\n        boost::asio::ip::udp::endpoint endpoint = *resolver.resolve({host, \"daytime\"}).begin();\n\n        // Set the remote endpoint\n        socket.connect(endpoint);\n\n        // Send a minimal request packet (e.g., empty or simple message)\n        std::string request = \"\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        // Receive the response\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        char response[1024];\n        size_t length = socket.receive_from(boost::asio::buffer(response), sender_endpoint);\n\n        // Print the received data\n        std::cout.write(response, length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::udp::v4(), 13);\n\n        // Resolve the host to an endpoint\n        boost::asio::ip::udp::resolver resolver(io_context);\n        boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(host, \"daytime\").begin();\n\n        // Send a request (minimal packet)\n        std::string request = \"request\";\n        socket.send_to(boost::asio::buffer(request), endpoint);\n\n        // Receive the response\n        boost::asio::streambuf response_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        size_t bytes_received = socket.receive_from(boost::asio::buffer(response_buffer), sender_endpoint);\n\n        // Print the received data\n        std::cout << std::string(response_buffer.data(), bytes_received) << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), 13);\n\n        std::string request = \"Hello, server!\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        char response[1024];\n        size_t response_length = socket.receive_from(boost::asio::buffer(response), sender_endpoint);\n\n        std::cout.write(response, response_length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), 13);\n\n        std::string request = \"Hello, server!\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        boost::array<char, 1024> recv_buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        size_t bytes_received = socket.receive_from(boost::asio::buffer(recv_buffer), sender_endpoint);\n\n        std::cout.write(recv_buffer.data(), bytes_received);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}",
      "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket(io_context);\n        boost::asio::ip::udp::endpoint remote_endpoint(boost::asio::ip::address::from_string(host), 13);\n\n        std::string request = \"Hello, server!\";\n        socket.send_to(boost::asio::buffer(request), remote_endpoint);\n\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        char response[1024];\n        size_t length = socket.receive_from(boost::asio::buffer(response), sender_endpoint);\n\n        std::cout.write(response, length);\n        std::cout << std::endl;\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a UDP-based client-server communication system using Boost.Asio in C++ that demonstrates asynchronous sending and receiving of datagrams.\n\nClass Description: The `udp_communicator` class provides asynchronous UDP communication capabilities for both sending and receiving datagrams. It manages socket operations, IO context, and buffers for network communication.\n\nAttributes:\n- io_context_: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket_: boost::asio::ip::udp::socket - Represents the UDP socket for communication\n- receiver_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint information for receiving data\n- sender_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint information of the sender\n- receive_buffer_: std::array<char, 1024> - Buffer for storing received data\n- send_buffer_: std::string - Buffer for storing data to be sent\n\nMethods:\n- constructor(io_context, port) -> void - Initializes the UDP socket and binds it to the specified port\n- start_receive() -> void - Begins asynchronous reception of UDP datagrams\n- handle_receive(error_code, bytes_transferred) -> void - Callback for handling received data\n- send_to(message, endpoint) -> void - Asynchronously sends a message to the specified endpoint\n- handle_send(error_code, bytes_transferred) -> void - Callback for handling send completion\n- get_socket() -> boost::asio::ip::udp::socket& - Returns a reference to the UDP socket\n- get_io_context() -> boost::asio::io_context& - Returns a reference to the IO context",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <istream>\n#include <ostream>\n#include \"icmp_header.hpp\"\n#include \"ipv4_header.hpp\"\n\nusing boost::asio::ip::icmp;\nusing boost::asio::steady_timer;\nnamespace chrono = boost::asio::chrono;\n\nclass pinger\n{\npublic:\n  pinger(boost::asio::io_context& io_context, const char* destination)\n    : resolver_(io_context), socket_(io_context, icmp::v4()),\n      timer_(io_context), sequence_number_(0), num_replies_(0)\n  {\n    destination_ = *resolver_.resolve(icmp::v4(), destination, \"\").begin();\n\n    start_send();\n    start_receive();\n  }\n\nprivate:\n  void start_send()\n  {\n    std::string body(\"\\\"Hello!\\\" from Asio ping.\");\n\n    icmp_header echo_request;\n    echo_request.type(icmp_header::echo_request);\n    echo_request.code(0);\n    echo_request.identifier(get_identifier());\n    echo_request.sequence_number(++sequence_number_);\n    compute_checksum(echo_request, body.begin(), body.end());\n\n    boost::asio::streambuf request_buffer;\n    std::ostream os(&request_buffer);\n    os << echo_request << body;\n\n    time_sent_ = steady_timer::clock_type::now();\n    socket_.send_to(request_buffer.data(), destination_);\n\n    num_replies_ = 0;\n    timer_.expires_at(time_sent_ + chrono::seconds(5));\n    timer_.async_wait(std::bind(&pinger::handle_timeout, this));\n  }\n\n  void handle_timeout()\n  {\n    if (num_replies_ == 0)\n      std::cout << \"Request timed out\" << std::endl;\n\n    timer_.expires_at(time_sent_ + chrono::seconds(1));\n    timer_.async_wait(std::bind(&pinger::start_send, this));\n  }\n\n  void start_receive()\n  {\n    reply_buffer_.consume(reply_buffer_.size());\n\n    socket_.async_receive(reply_buffer_.prepare(65536),\n        std::bind(&pinger::handle_receive, this, std::placeholders::_2));\n  }\n\n  void handle_receive(std::size_t length)\n  {\n    reply_buffer_.commit(length);\n\n    std::istream is(&reply_buffer_);\n    ipv4_header ipv4_hdr;\n    icmp_header icmp_hdr;\n    is >> ipv4_hdr >> icmp_hdr;\n\n    if (is && icmp_hdr.type() == icmp_header::echo_reply\n          && icmp_hdr.identifier() == get_identifier()\n          && icmp_hdr.sequence_number() == sequence_number_)\n    {\n      if (num_replies_++ == 0)\n        timer_.cancel();\n\n      chrono::steady_clock::time_point now = chrono::steady_clock::now();\n      chrono::steady_clock::duration elapsed = now - time_sent_;\n      std::cout << length - ipv4_hdr.header_length()\n        << \" bytes from \" << ipv4_hdr.source_address()\n        << \": icmp_seq=\" << icmp_hdr.sequence_number()\n        << \", ttl=\" << ipv4_hdr.time_to_live()\n        << \", time=\"\n        << chrono::duration_cast<chrono::milliseconds>(elapsed).count()\n        << std::endl;\n    }\n\n    start_receive();\n  }\n\n  static unsigned short get_identifier()\n  {\n#if defined(BOOST_ASIO_WINDOWS)\n    return static_cast<unsigned short>(::GetCurrentProcessId());\n#else\n    return static_cast<unsigned short>(::getpid());\n#endif\n  }\n\n  icmp::resolver resolver_;\n  icmp::endpoint destination_;\n  icmp::socket socket_;\n  steady_timer timer_;\n  unsigned short sequence_number_;\n  chrono::steady_clock::time_point time_sent_;\n  boost::asio::streambuf reply_buffer_;\n  std::size_t num_replies_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [],
    "unmatched_results": [
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n            handle_receive(ec, bytes_transferred);\n        });\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n    if (!ec && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n            handle_send(ec, bytes_transferred);\n        });\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n    if (ec) {\n        // Handle send error\n    }\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        std::bind(&udp_communicator::handle_receive, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (!error && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data here\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        std::bind(&udp_communicator::handle_send, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (error) {\n        // Handle send error\n    }\n    // Optionally reset send buffer or handle next send\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        std::bind(&udp_communicator::handle_receive, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (!error && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data here\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        std::bind(&udp_communicator::handle_send, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (error) {\n        // Handle send error\n    }\n    send_buffer_.clear();\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        std::bind(&udp_communicator::handle_receive, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (!error && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        std::bind(&udp_communicator::handle_send, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (error) {\n        // Handle send error\n    }\n    send_buffer_.clear();\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n            handle_receive(ec, bytes_transferred);\n        });\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n    if (!ec && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data here\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n            handle_send(ec, bytes_transferred);\n        });\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n    if (ec) {\n        // Handle send error\n    }\n    // Optionally reset send buffer or handle further logic\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        std::bind(&udp_communicator::handle_receive, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (!error && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data here\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        std::bind(&udp_communicator::handle_send, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (error) {\n        // Handle send error\n    }\n    // Optionally reset send buffer or handle further sends\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        std::bind(&udp_communicator::handle_receive, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (!error && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        std::bind(&udp_communicator::handle_send, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (error) {\n        // Handle send error\n    }\n    send_buffer_.clear();\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n            handle_receive(ec, bytes_transferred);\n        });\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n    if (!ec && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n            handle_send(ec, bytes_transferred);\n        });\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n    if (ec) {\n        // Handle send error\n    }\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        std::bind(&udp_communicator::handle_receive, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (!error && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data here\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        std::bind(&udp_communicator::handle_send, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (error) {\n        // Handle send error\n    }\n    // Optionally reset send buffer or handle further sends\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}",
      "udp_communicator::udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n    : io_context_(io_context),\n      socket_(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), port)),\n      receiver_endpoint_(),\n      sender_endpoint_(),\n      receive_buffer_(1024),\n      send_buffer_(\"\") {}\n\nvoid udp_communicator::start_receive() {\n    socket_.async_receive_from(\n        boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n        std::bind(&udp_communicator::handle_receive, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_receive(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (!error && bytes_transferred > 0) {\n        std::string received_data(receive_buffer_.data(), bytes_transferred);\n        // Process received data here\n    }\n    start_receive();\n}\n\nvoid udp_communicator::send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n    send_buffer_ = message;\n    socket_.async_send_to(\n        boost::asio::buffer(send_buffer_), endpoint,\n        std::bind(&udp_communicator::handle_send, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid udp_communicator::handle_send(const boost::system::error_code& error, size_t bytes_transferred) {\n    if (error) {\n        // Handle send error\n    }\n    // Optionally reset send buffer or handle further logic\n}\n\nboost::asio::ip::udp::socket& udp_communicator::get_socket() {\n    return socket_;\n}\n\nboost::asio::io_context& udp_communicator::get_io_context() {\n    return io_context_;\n}"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Implement a server class that handles both TCP and UDP communications using Boost.Asio, managing client subscriptions and broadcasting data frames to subscribed clients.\n\nClass Description: The `server` class manages network communications using both TCP and UDP protocols. It accepts TCP connections for control messages, maintains a set of subscribed UDP endpoints, and periodically broadcasts data frames to all subscribed clients via UDP.\n\nAttributes:\n- acceptor_: [tcp::acceptor] - Handles incoming TCP connections\n- timer_: [boost::asio::steady_timer] - Manages periodic operations\n- udp_socket_: [udp::socket] - Handles UDP communications\n- next_frame_number_: [unsigned long] - Tracks the sequence number for frames\n- subscribers_: [std::set<udp::endpoint>] - Stores subscribed client endpoints\n\nMethods:\n- server([boost::asio::io_context&] io_context, [unsigned short] port) -> [void] - Constructor that initializes the server with IO context and port\n- handle_accept([const boost::system::error_code&] ec, [tcp_socket_ptr] socket) -> [void] - Handles new TCP connection acceptances\n- handle_control_request([const boost::system::error_code&] ec, [tcp_socket_ptr] socket, [control_request_ptr] request) -> [void] - Processes control requests from clients\n- handle_control_request_timer([tcp_socket_ptr] socket, [control_request_ptr] request, [timer_ptr] delay_timer) -> [void] - Handles delayed processing of control requests\n- handle_timer() -> [void] - Periodically broadcasts data frames to subscribed clients",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <set>\n#include <memory>\n#include \"protocol.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef std::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef std::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef std::shared_ptr<control_request> control_request_ptr;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, unsigned short port)\n    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n      timer_(io_context),\n      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n      next_frame_number_(1)\n  {\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\n  void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n  {\n    if (!ec)\n    {\n      control_request_ptr request(new control_request);\n      boost::asio::async_read(*socket, request->to_buffers(),\n          std::bind(&server::handle_control_request, this,\n            boost::asio::placeholders::error, socket, request));\n    }\n\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n  }\n\n  void handle_control_request(const boost::system::error_code& ec,\n      tcp_socket_ptr socket, control_request_ptr request)\n  {\n    if (!ec)\n    {\n      timer_ptr delay_timer(\n          new boost::asio::steady_timer(acceptor_.get_executor()));\n      delay_timer->expires_after(boost::asio::chrono::seconds(2));\n      delay_timer->async_wait(\n          std::bind(&server::handle_control_request_timer, this,\n            socket, request, delay_timer));\n    }\n  }\n\n  void handle_control_request_timer(tcp_socket_ptr socket,\n      control_request_ptr request, timer_ptr /*delay_timer*/)\n  {\n    boost::system::error_code ec;\n    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);\n    if (!ec)\n    {\n      if (unsigned short old_port = request->old_port())\n      {\n        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);\n        subscribers_.erase(old_endpoint);\n      }\n\n      if (unsigned short new_port = request->new_port())\n      {\n        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);\n        subscribers_.insert(new_endpoint);\n      }\n    }\n\n    boost::asio::async_read(*socket, request->to_buffers(),\n        std::bind(&server::handle_control_request, this,\n          boost::asio::placeholders::error, socket, request));\n  }\n\n  void handle_timer()\n  {\n    double x = next_frame_number_ * 0.2;\n    double y = std::sin(x);\n    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));\n    std::string payload;\n    for (int i = 0; i < frame::payload_size; ++i)\n      payload += (i == char_index ? '*' : '.');\n\n    frame f(next_frame_number_++, payload);\n\n    std::set<udp::endpoint>::iterator j;\n    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)\n    {\n      boost::system::error_code ec;\n      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);\n    }\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\nprivate:\n  tcp::acceptor acceptor_;\n  boost::asio::steady_timer timer_;\n  udp::socket udp_socket_;\n  unsigned long next_frame_number_;\n  std::set<udp::endpoint> subscribers_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\nusing boost::system::error_code;\n\ntypedef boost::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::deadline_timer> delay_timer_ptr;\ntypedef boost::shared_ptr<void> control_request_ptr;\n\nclass server {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n}; \n\nserver::server(boost::asio::io_context& io_context, unsigned short port) : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)), timer_(io_context), udp_socket_(io_context, udp::endpoint(udp::v4(), 0)), next_frame_number_(0) {\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, this));\n    start_accept();\n}\n\nvoid server::start_accept() {\n    tcp_socket_ptr socket(new tcp::socket(acceptor_.get_io_context()));\n    acceptor_.async_accept(*socket, boost::bind(&server::handle_accept, this, _1, socket));\n}\n\nvoid server::handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n    if (!ec) {\n        control_request_ptr request(new boost::asio::streambuf);\n        boost::asio::async_read(*socket, *request, boost::bind(&server::handle_control_request, this, _1, socket, request));\n    }\n    start_accept();\n}\n\nvoid server::handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n    if (!ec) {\n        std::string command((std::istreambuf_iterator<char>(request)), std::istreambuf_iterator<char>());\n        if (command == \"subscribe\") {\n            udp::endpoint endpoint = udp::endpoint(udp::v4(), 0);\n            boost::asio::ip::address address = boost::asio::ip::address::from_string(\"127.0.0.1\");\n            endpoint = udp::endpoint(address, 0);\n            subscribers_.insert(endpoint);\n        } else if (command == \"unsubscribe\") {\n            udp::endpoint endpoint = udp::endpoint(udp::v4(), 0);\n            boost::asio::ip::address address = boost::asio::ip::address::from_string(\"127.0.0.1\");\n            endpoint = udp::endpoint(address, 0);\n            subscribers_.erase(endpoint);\n        }\n        timer_.expires_after(std::chrono::seconds(1));\n        timer_.async_wait(boost::bind(&server::handle_timer, this));\n    }\n}\n\nvoid server::handle_timer() {\n    for (const auto& endpoint : subscribers_) {\n        boost::asio::ip::address address = endpoint.address();\n        boost::asio::ip::udp::endpoint remote_endpoint(address, endpoint.port());\n        boost::asio::streambuf buffer;\n        std::ostream os(&buffer);\n        os << \"frame \" << next_frame_number_++;\n        udp_socket_.send_to(buffer.data(), remote_endpoint);\n    }\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, this));\n}",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\nusing boost::system::error_code;\n\ntypedef boost::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::deadline_timer> delay_timer_ptr;\ntypedef boost::shared_ptr<void> control_request_ptr;\n\nclass server {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n}; \n\nserver::server(boost::asio::io_context& io_context, unsigned short port) : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)), timer_(io_context), udp_socket_(io_context, udp::endpoint(udp::v4(), 0)), next_frame_number_(0) {\n    timer_.expires_after(boost::asio::chrono::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, this));\n    start_accept();\n}\n\nvoid server::start_accept() {\n    tcp_socket_ptr socket(new tcp::socket(acceptor_.get_io_context()));\n    acceptor_.async_accept(*socket, boost::bind(&server::handle_accept, this, _1, socket));\n}\n\nvoid server::handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n    if (!ec) {\n        control_request_ptr request(new boost::asio::streambuf);\n        boost::asio::async_read(*socket, *request, boost::bind(&server::handle_control_request, this, _1, socket, request));\n    }\n    start_accept();\n}\n\nvoid server::handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n    if (!ec) {\n        std::string command((std::istreambuf_iterator<char>(request)), std::istreambuf_iterator<char>());\n        if (command == \"subscribe\") {\n            udp::endpoint endpoint = udp::endpoint(udp::v4(), 0);\n            boost::asio::ip::address address = boost::asio::ip::address::from_string(\"127.0.0.1\");\n            endpoint.address(address);\n            endpoint.port(50000 + next_frame_number_++);\n            subscribers_.insert(endpoint);\n        } else if (command == \"unsubscribe\") {\n            udp::endpoint endpoint = udp::endpoint(udp::v4(), 0);\n            boost::asio::ip::address address = boost::asio::ip::address::from_string(\"127.0.0.1\");\n            endpoint.address(address);\n            endpoint.port(50000 + next_frame_number_++);\n            subscribers_.erase(endpoint);\n        }\n        timer_.expires_after(boost::asio::chrono::seconds(1));\n        timer_.async_wait(boost::bind(&server::handle_timer, this));\n    }\n}\n\nvoid server::handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer) {\n    if (!delay_timer->wait_for(boost::asio::chrono::seconds(1))) {\n        boost::asio::async_read(*socket, *request, boost::bind(&server::handle_control_request, this, _1, socket, request));\n    }\n}\n\nvoid server::handle_timer() {\n    for (const auto& endpoint : subscribers_) {\n        boost::asio::ip::address address = endpoint.address();\n        boost::asio::ip::udp::endpoint remote_endpoint(address, endpoint.port());\n        boost::asio::streambuf buffer;\n        std::ostream os(&buffer);\n        os << \"frame \" << next_frame_number_;\n        udp_socket_.send_to(buffer.data(), remote_endpoint);\n    }\n    timer_.expires_after(boost::asio::chrono::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, this));\n}",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\nusing boost::system::error_code;\n\ntypedef boost::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::deadline_timer> delay_timer_ptr;\ntypedef boost::shared_ptr<void> control_request_ptr;\n\nclass server {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n}; \n\nserver::server(boost::asio::io_context& io_context, unsigned short port) : acceptor_(io_context), timer_(io_context), udp_socket_(io_context), next_frame_number_(0) {\n    tcp::endpoint endpoint(tcp::v4(), port);\n    acceptor_.open(endpoint.protocol());\n    acceptor_.set_option(tcp::acceptor::reuse_address(true));\n    acceptor_.bind(endpoint);\n    acceptor_.listen();\n    acceptor_.async_accept(\n        boost::bind(&server::handle_accept, this, _1, tcp_socket_ptr(new tcp::socket(io_context)))\n    );\n    timer_.expires_from_now(boost::posix_time::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, this));\n}\n\nvoid server::handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n    if (!ec) {\n        boost::shared_ptr<control_request_ptr> request(new control_request_ptr);\n        *request = boost::shared_ptr<void>(new void);\n        socket->async_read_some(boost::asio::buffer(request.get(), sizeof(void*)), \n            boost::bind(&server::handle_control_request, this, _1, socket, request));\n    }\n    acceptor_.async_accept(\n        boost::bind(&server::handle_accept, this, _1, tcp_socket_ptr(new tcp::socket(io_context)))\n    );\n}\n\nvoid server::handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n    if (!ec) {\n        timer_ptr delay_timer(new boost::asio::steady_timer(io_context));\n        delay_timer->expires_from_now(boost::posix_time::seconds(1));\n        delay_timer->async_wait(boost::bind(&server::handle_control_request_timer, this, socket, request, delay_timer));\n    }\n}\n\nvoid server::handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer) {\n    // Process control request\n    // Example: Add UDP endpoint to subscribers_\n    // udp::endpoint endpoint = ...;\n    // subscribers_.insert(endpoint);\n    delay_timer->cancel();\n}\n\nvoid server::handle_timer() {\n    // Broadcast data frame to all subscribed clients\n    // Example: Create a data frame and send via UDP\n    // boost::asio::buffer buffer(...);\n    // for (const auto& endpoint : subscribers_) {\n    //     udp_socket_.send_to(buffer, endpoint);\n    // }\n    timer_.expires_from_now(boost::posix_time::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, this));\n}"
    ],
    "unmatched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\ntypedef boost::asio::ip::tcp tcp;\ntypedef boost::asio::ip::udp udp;\ntypedef boost::shared_ptr<boost::asio::ip::tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::socket> udp_socket_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    boost::asio::ip::tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    boost::asio::ip::udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\ntypedef boost::asio::ip::tcp tcp;\ntypedef boost::asio::ip::udp udp;\ntypedef boost::shared_ptr<boost::asio::ip::tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::socket> udp_socket_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    boost::asio::ip::tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    boost::asio::ip::udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\ntypedef boost::asio::ip::tcp tcp;\ntypedef boost::asio::ip::udp udp;\ntypedef boost::shared_ptr<boost::asio::ip::tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::socket> udp_socket_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    boost::asio::ip::tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    boost::asio::ip::udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\ntypedef boost::asio::ip::tcp tcp;\ntypedef boost::asio::ip::udp udp;\ntypedef boost::shared_ptr<boost::asio::ip::tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::socket> udp_socket_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    boost::asio::ip::tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    boost::asio::ip::udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\nusing boost::system::error_code;\nusing boost::shared_ptr;\n\ntypedef shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef shared_ptr<boost::asio::deadline_timer> delay_timer_ptr;\ntypedef shared_ptr<void> control_request_ptr;\n\nclass server {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n}; \n\nserver::server(boost::asio::io_context& io_context, unsigned short port) : acceptor_(io_context), timer_(io_context), udp_socket_(io_context), next_frame_number_(0) {\n    tcp::endpoint endpoint(tcp::v4(), port);\n    acceptor_.open(endpoint.protocol());\n    acceptor_.set_option(tcp::acceptor::reuse_address(true));\n    acceptor_.bind(endpoint);\n    acceptor_.listen();\n    acceptor_.async_accept(boost::bind(&server::handle_accept, this, _1, shared_ptr<tcp::socket>(new tcp::socket(io_context))));\n    timer_.expires_after(boost::asio::chrono::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, this));\n}\n\nvoid server::handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n    if (!ec) {\n        // Handle TCP connection\n        control_request_ptr request(new void);\n        socket->async_read_some(boost::asio::buffer(request.get(), sizeof(void)), boost::bind(&server::handle_control_request, this, _1, socket, request));\n    }\n    acceptor_.async_accept(boost::bind(&server::handle_accept, this, _1, shared_ptr<tcp::socket>(new tcp::socket(io_context))));\n}\n\nvoid server::handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request) {\n    if (!ec) {\n        // Process control request\n        timer_ptr delay_timer(new boost::asio::steady_timer(io_context_));\n        delay_timer->expires_after(boost::asio::chrono::seconds(1));\n        delay_timer->async_wait(boost::bind(&server::handle_control_request_timer, this, socket, request, delay_timer));\n    }\n}\n\nvoid server::handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer) {\n    // Delayed processing of control request\n    // Example: Add subscriber to UDP list\n    udp::endpoint endpoint = udp::endpoint(udp::v4(), 5000); // Example endpoint\n    subscribers_.insert(endpoint);\n    delay_timer->cancel();\n}\n\nvoid server::handle_timer() {\n    // Broadcast data frame to all subscribed clients\n    for (const auto& endpoint : subscribers_) {\n        udp::endpoint target_endpoint = endpoint;\n        boost::asio::write(udp_socket_, boost::asio::buffer(reinterpret_cast<const char*>(&next_frame_number_), sizeof(unsigned long)));\n    }\n    next_frame_number_++;\n    timer_.expires_after(boost::asio::chrono::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, this));\n}",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\ntypedef boost::asio::ip::tcp tcp;\ntypedef boost::asio::ip::udp udp;\ntypedef boost::shared_ptr<boost::asio::ip::tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::endpoint> udp_endpoint_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::socket> udp_socket_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, control_request_ptr request);\n    void handle_control_request_timer(tcp_socket_ptr socket, control_request_ptr request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    boost::asio::ip::tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    boost::asio::ip::udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <set>\n\ntypedef boost::asio::ip::tcp tcp;\ntypedef boost::asio::ip::udp udp;\ntypedef boost::shared_ptr<boost::asio::ip::tcp::socket> tcp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::ip::udp::socket> udp_socket_ptr;\ntypedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef boost::shared_ptr<boost::asio::io_context> io_context_ptr;\n\nclass server : public boost::enable_shared_from_this<server> {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port);\n    void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket);\n    void handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, boost::shared_ptr<std::string> request);\n    void handle_control_request_timer(tcp_socket_ptr socket, boost::shared_ptr<std::string> request, timer_ptr delay_timer);\n    void handle_timer();\n\nprivate:\n    boost::asio::ip::tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    boost::asio::ip::udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n};\n\nserver::server(boost::asio::io_context& io_context, unsigned short port) : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)), timer_(io_context), udp_socket_(io_context, udp::endpoint(udp::v4(), 0)), next_frame_number_(0) {\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, shared_from_this()));\n    start_accept();\n}\n\nvoid server::start_accept() {\n    tcp_socket_ptr socket(new tcp::socket(acceptor_.get_io_context()));\n    acceptor_.async_accept(*socket, boost::bind(&server::handle_accept, shared_from_this(), _1, socket));\n}\n\nvoid server::handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket) {\n    if (!ec) {\n        boost::shared_ptr<std::string> request(new std::string());\n        boost::asio::async_read(*socket, boost::asio::buffer(request.get()), boost::bind(&server::handle_control_request, shared_from_this(), _1, socket, request));\n    }\n    start_accept();\n}\n\nvoid server::handle_control_request(const boost::system::error_code& ec, tcp_socket_ptr socket, boost::shared_ptr<std::string> request) {\n    if (!ec && !request->empty()) {\n        std::istringstream iss(*request);\n        std::string command;\n        iss >> command;\n        if (command == \"subscribe\") {\n            udp::endpoint endpoint = udp::endpoint(udp::v4(), 0);\n            boost::asio::ip::address address = boost::asio::ip::address::from_string(\"127.0.0.1\");\n            endpoint = udp::endpoint(address, 0);\n            subscribers_.insert(endpoint);\n        } else if (command == \"unsubscribe\") {\n            udp::endpoint endpoint = udp::endpoint(udp::v4(), 0);\n            boost::asio::ip::address address = boost::asio::ip::address::from_string(\"127.0.0.1\");\n            endpoint = udp::endpoint(address, 0);\n            subscribers_.erase(endpoint);\n        } else if (command == \"frame\") {\n            boost::asio::post(io_context_, boost::bind(&server::handle_control_request_timer, shared_from_this(), socket, request, timer_));\n        }\n    }\n}\n\nvoid server::handle_control_request_timer(tcp_socket_ptr socket, boost::shared_ptr<std::string> request, timer_ptr delay_timer) {\n    delay_timer->expires_after(std::chrono::seconds(1));\n    delay_timer->async_wait(boost::bind(&server::handle_control_request_timer, shared_from_this(), socket, request, delay_timer));\n}\n\nvoid server::handle_timer() {\n    for (const auto& endpoint : subscribers_) {\n        boost::asio::ip::udp::endpoint sender_endpoint = endpoint;\n        boost::asio::ip::udp::endpoint receiver_endpoint = sender_endpoint;\n        boost::asio::write(udp_socket_, boost::asio::buffer(reinterpret_cast<const char*>(&next_frame_number_), sizeof(next_frame_number_)));\n        next_frame_number_++;\n    }\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(boost::bind(&server::handle_timer, shared_from_this()));\n}"
    ],
    "match_count": 3,
    "pass@3": 0.7083333333333333,
    "pass@5": 0.9166666666666666
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Implement a class for handling HTTP file downloads using libcurl in C++. The class should support URL downloading with retries, temporary file handling, and proper resource management.\n\nClass Description: The DownloadTask class provides functionality to download files from HTTP URLs using libcurl. It handles initialization/cleanup of libcurl, manages download retries, writes data to temporary files, and performs final file operations upon successful download.\n\nAttributes:\n- m_url: [std::string] - Primary URL for file download\n- m_urlBackup: [std::string] - Backup URL if primary fails\n- m_output: [std::string] - Final output file path\n- m_outputTmp: [std::string] - Temporary file path during download\n- m_default: [std::string] - Default file path if download fails\n- m_mtime: [time_t] - Modification time to set on downloaded file\n- m_retries: [unsigned int] - Number of download attempts made\n- m_name: [std::string] - Name identifier for the download task\n- m_userAgent: [std::string] - User agent string for HTTP requests\n- m_error: [std::string] - Last error message encountered\n\nMethods:\n- initialize(): [static void]() -> void - Initializes libcurl global state\n- uninitialize(): [static void]() -> void - Cleans up libcurl global state\n- DownloadTask(): [constructor](const std::string&, const std::string&, const std::string&, time_t, const std::string&) -> DownloadTask - Constructs a download task with URL, output path, default file, modification time, and optional name\n- run(): [bool]() -> bool - Executes the download task and returns success status\n- getRetries(): [unsigned int]() -> unsigned int - Returns number of retry attempts\n- writeData(): [size_t](void*, size_t, size_t) -> size_t - Callback for writing received data\n- downloadFile(): [bool](const std::string&) -> bool - Internal method to perform the actual file download",
    "Canonical_solution": "#include <curl/curl.h>\n#include <vector>\n#include <string>\n#include <utility>\n\nclass DownloadTask\n{\npublic:\n    DownloadTask(const std::string &url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\");\n    \n    static void initialize();\n    static void uninitialize();\n    \n    bool run();\n    unsigned int getRetries() const;\n    size_t writeData(void *buffer, size_t size, size_t nmemb);\n    \nprivate:\n    bool downloadFile(const std::string& url);\n    \n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n};\n\nsize_t writeTaskHttpData(void *buffer, size_t size, size_t nmemb, void *user_p)\n{\n    DownloadTask *task = reinterpret_cast<DownloadTask *>(user_p);\n    if (NULL != task)\n    {\n        return task->writeData(buffer, size, nmemb);\n    }\n    \n    return 0;\n}\n\nvoid DownloadTask::initialize()\n{\n    curl_global_init(CURL_GLOBAL_ALL);\n}\n\nvoid DownloadTask::uninitialize()\n{\n    curl_global_cleanup();\n}\n\nbool DownloadTask::downloadFile(const std::string& url)\n{\n    ++m_retries;\n    \n    m_outputTmp = m_output + \".tmp\";\n    deleteFile(m_outputTmp);\n\n    CURLcode res = CURLE_OK;\n    CURL *curl = NULL;\n    \n    std::string userAgent = m_userAgent.empty() ? \"WeChat/7.0.15.33 CFNetwork/978.0.7 Darwin/18.6.0\" : m_userAgent;\n    \n    curl = curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_USERAGENT, userAgent.c_str());\n    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);\n    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 60);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &::writeTaskHttpData);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, true);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0);\n\n    long httpStatus = 0;\n    res = curl_easy_perform(curl);\n    if (res != CURLE_OK)\n    {\n        m_error = \"Failed \" + m_name + \"\\r\\n\";\n        m_error += curl_easy_strerror(res);\n    }\n    else\n    {\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n    }\n    curl_easy_cleanup(curl);\n    \n    if (res == CURLE_OK && httpStatus == 200)\n    {\n        ::moveFile(m_outputTmp, m_output);\n        if (m_mtime > 0)\n        {\n            updateFileTime(m_output, m_mtime);\n        }\n        return true;\n    }\n\n    if (m_error.empty())\n    {\n        m_error = \"HTTP Status:\" + std::to_string(httpStatus);\n    }\n    return false;\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <ctime>\n#include <curl/curl.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <unistd.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"Mozilla/5.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    bool run() {\n        if (!m_output.empty()) {\n            if (m_outputTmp.empty()) {\n                m_outputTmp = m_output + \".tmp\";\n            }\n            if (downloadFile(m_url)) {\n                if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n                    m_error = \"Failed to rename temporary file.\";\n                    return false;\n                }\n                if (m_mtime != 0) {\n                    struct utimbuf t;\n                    t.actime = m_mtime;\n                    t.modtime = m_mtime;\n                    utime(m_output.c_str(), &t);\n                }\n                return true;\n            } else if (m_urlBackup.empty()) {\n                m_error = \"Download failed and no backup URL provided.\";\n                return false;\n            } else {\n                m_url = m_urlBackup;\n                m_retries++;\n                return downloadFile(m_url);\n            }\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        char* data = static_cast<char*>(contents);\n        std::ofstream outFile(m_outputTmp, std::ios::binary | std::ios::app);\n        if (outFile.is_open()) {\n            outFile.write(data, realsize);\n            outFile.close();\n        } else {\n            m_error = \"Failed to open temporary file for writing.\";\n        }\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl;\n        CURLcode res;\n        std::string error;\n        curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL.\";\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);\n        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);\n\n        FILE* fp;\n        fopen_s(&fp, m_outputTmp.c_str(), \"wb\");\n        if (!fp) {\n            m_error = \"Failed to create temporary file.\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            fclose(fp);\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n\n        if (access(m_outputTmp.c_str(), F_OK) == 0) {\n            return true;\n        } else {\n            m_error = \"Download failed: File not found in temporary location.\";\n            return false;\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <ctime>\n#include <curl/curl.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <unistd.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"Mozilla/5.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    bool run() {\n        if (!m_output.empty()) {\n            if (downloadFile(m_url)) {\n                return finalizeDownload();\n            } else if (!m_urlBackup.empty()) {\n                m_retries++;\n                if (downloadFile(m_urlBackup)) {\n                    return finalizeDownload();\n                }\n            }\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        char* buffer = static_cast<char*>(contents);\n        std::ofstream file(m_outputTmp, std::ios::binary | std::ios::app);\n        if (file.is_open()) {\n            file.write(buffer, realsize);\n            file.close();\n        }\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl;\n        CURLcode res;\n        std::string error;\n        curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);\n\n        struct curl_slist* headers = NULL;\n        headers = curl_slist_append(headers, \"Expect:\");\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n        FILE* fp = fopen(m_outputTmp.c_str(), \"wb\");\n        if (!fp) {\n            m_error = \"Failed to open temporary file\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            fclose(fp);\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n\n        return true;\n    }\n\n    bool finalizeDownload() {\n        if (m_output.empty()) {\n            m_error = \"Output path is empty\";\n            return false;\n        }\n\n        if (access(m_outputTmp.c_str(), F_OK) != 0) {\n            m_error = \"Temporary file not found\";\n            return false;\n        }\n\n        if (access(m_output.c_str(), F_OK) == 0) {\n            remove(m_output.c_str());\n        }\n\n        if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n            m_error = \"Failed to rename temporary file\";\n            return false;\n        }\n\n        struct utimbuf times;\n        times.actime = m_mtime;\n        times.modtime = m_mtime;\n        utime(m_output.c_str(), &times);\n\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <fstream>\n#include <curl/curl.h>\n#include <ctime>\n#include <unistd.h>\n#include <sys/stat.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\") \n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"Mozilla/5.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    bool run() {\n        if (!m_url.empty()) {\n            if (downloadFile(m_url)) {\n                return true;\n            }\n            if (!m_urlBackup.empty()) {\n                return downloadFile(m_urlBackup);\n            }\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        char* buffer = static_cast<char*>(contents);\n        std::ofstream file(m_outputTmp, std::ios::binary | std::ios::app);\n        if (file.is_open()) {\n            file.write(buffer, realsize);\n            file.close();\n        } else {\n            m_error = \"Failed to open temporary file for writing.\";\n        }\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl;\n        CURLcode res;\n        FILE* fp;\n        std::string error;\n\n        curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL handle.\";\n            return false;\n        }\n\n        fp = fopen(m_outputTmp.c_str(), \"wb\");\n        if (!fp) {\n            m_error = \"Failed to open temporary file.\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, static_cast<void*>(fp));\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            m_retries++;\n            fclose(fp);\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n\n        if (access(m_outputTmp.c_str(), F_OK) == 0) {\n            struct stat st;\n            if (stat(m_outputTmp.c_str(), &st) == 0) {\n                m_mtime = st.st_mtime;\n            }\n            if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n                m_error = \"Failed to rename temporary file to final output.\";\n                return false;\n            }\n            return true;\n        } else {\n            m_error = \"Temporary file not found after download.\";\n            return false;\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <ctime>\n#include <curl/curl.h>\n#include <fstream>\n#include <sys/stat.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"Mozilla/5.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    bool run() {\n        if (!m_url.empty()) {\n            if (downloadFile(m_url)) {\n                return true;\n            }\n            if (!m_urlBackup.empty()) {\n                return downloadFile(m_urlBackup);\n            }\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        char* buffer = static_cast<char*>(contents);\n        std::ofstream file(m_outputTmp, std::ios::binary | std::ios::app);\n        if (file.is_open()) {\n            file.write(buffer, realsize);\n            file.close();\n        } else {\n            m_error = \"Failed to open temporary file for writing.\";\n        }\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl;\n        CURLcode res;\n        std::string error;\n        m_retries++;\n        curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL handle.\";\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);\n        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 5L);\n\n        FILE* fp;\n        fopen_s(&fp, m_outputTmp.c_str(), \"wb\");\n        if (!fp) {\n            m_error = \"Failed to open temporary file.\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            fclose(fp);\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n\n        if (std::ifstream(m_outputTmp).good()) {\n            if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n                m_error = \"Failed to rename temporary file.\";\n                return false;\n            }\n            struct stat st;\n            if (stat(m_output.c_str(), &st) == 0) {\n                m_mtime = st.st_mtime;\n            }\n            return true;\n        } else {\n            m_error = \"Download failed or file is empty.\";\n            return false;\n        }\n    }\n};",
      "#include <curl/curl.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <ctime>\n#include <unistd.h>\n#include <sys/stat.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static CURL* curl;\n    static bool initialized;\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\") \n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"Mozilla/5.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    ~DownloadTask() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    static void initialize() {\n        if (!initialized) {\n            curl_global_init(CURL_GLOBAL_DEFAULT);\n            initialized = true;\n        }\n    }\n\n    static void uninitialize() {\n        if (initialized) {\n            curl_global_cleanup();\n            initialized = false;\n        }\n    }\n\n    bool run() {\n        initialize();\n        if (!downloadFile(m_url)) {\n            if (!downloadFile(m_urlBackup)) {\n                m_error = \"Failed to download from both URLs.\";\n                return false;\n            }\n        }\n        uninitialize();\n        return true;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        char* buffer = static_cast<char*>(contents);\n        std::ofstream file(m_outputTmp, std::ios::binary | std::ios::app);\n        if (!file) {\n            m_error = \"Failed to open temporary file.\";\n            return realsize;\n        }\n        file.write(buffer, realsize);\n        file.close();\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURLcode res;\n        curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL.\";\n            return false;\n        }\n\n        struct curl_slist* headers = NULL;\n        headers = curl_slist_append(headers, (\"User-Agent: \" + m_userAgent).c_str());\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n        std::ofstream file(m_output, std::ios::binary | std::ios::trunc);\n        if (!file) {\n            m_error = \"Failed to open output file.\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n        file.close();\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            m_retries++;\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_cleanup(curl);\n        curl = nullptr;\n\n        if (m_outputTmp.empty()) {\n            m_error = \"Temporary file not created.\";\n            return false;\n        }\n\n        if (!rename(m_outputTmp.c_str(), m_output.c_str())) {\n            m_error = \"Failed to rename temporary file.\";\n            return false;\n        }\n\n        struct stat st;\n        if (stat(m_output.c_str(), &st) == 0) {\n            m_mtime = st.st_mtime;\n        }\n\n        return true;\n    }\n\nprivate:\n    static CURL* curl;\n    static bool initialized;\n}; \n\nCURL* DownloadTask::curl = nullptr;\nbool DownloadTask::initialized = false;",
      "#include <iostream>\n#include <string>\n#include <ctime>\n#include <fstream>\n#include <curl/curl.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"Mozilla/5.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    bool run() {\n        if (!m_url.empty()) {\n            if (downloadFile(m_url)) {\n                return true;\n            }\n            if (!m_urlBackup.empty()) {\n                return downloadFile(m_urlBackup);\n            }\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        char* buffer = static_cast<char*>(contents);\n        std::ofstream file(m_outputTmp, std::ios::binary | std::ios::app);\n        if (file.is_open()) {\n            file.write(buffer, realsize);\n            file.close();\n        } else {\n            m_error = \"Failed to open temporary file for writing.\";\n        }\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl;\n        CURLcode res;\n        std::string error;\n        m_retries++;\n        curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL handle.\";\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30);\n        curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, error.data());\n\n        FILE* fp;\n        fopen_s(&fp, m_outputTmp.c_str(), \"wb\");\n        if (!fp) {\n            m_error = \"Failed to open temporary file.\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            fclose(fp);\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n\n        if (std::ifstream(m_outputTmp).good()) {\n            std::rename(m_outputTmp.c_str(), m_output.c_str());\n            std::ofstream outFile(m_output, std::ios::binary);\n            outFile << \"\";\n            outFile.close();\n            std::remove(m_outputTmp.c_str());\n            return true;\n        } else {\n            m_error = \"Download failed or file not written properly.\";\n            return false;\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <ctime>\n#include <curl/curl.h>\n#include <fstream>\n#include <sys/stat.h>\n#include <unistd.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"Mozilla/5.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    bool run() {\n        if (!m_output.empty()) {\n            if (m_outputTmp.empty()) {\n                m_outputTmp = m_output + \".tmp\";\n            }\n            if (!downloadFile(m_url)) {\n                if (!m_urlBackup.empty()) {\n                    m_retries++;\n                    if (downloadFile(m_urlBackup)) {\n                        return true;\n                    }\n                }\n            } else {\n                return true;\n            }\n        }\n        m_error = \"Download failed after all retries.\";\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* ptr, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        char* data = static_cast<char*>(ptr);\n        std::ofstream file(m_outputTmp, std::ios::binary | std::ios::app);\n        if (file.is_open()) {\n            file.write(data, realsize);\n            file.close();\n        } else {\n            m_error = \"Failed to open temporary file for writing.\";\n        }\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl;\n        CURLcode res;\n        std::string error;\n        curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL.\";\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);\n\n        FILE* fp;\n        fopen_s(&fp, m_outputTmp.c_str(), \"wb\");\n        if (!fp) {\n            m_error = \"Failed to open temporary file.\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            fclose(fp);\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n\n        if (m_output != m_outputTmp) {\n            if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n                m_error = \"Failed to rename temporary file.\";\n                return false;\n            }\n        }\n\n        struct stat st;\n        if (stat(m_output.c_str(), &st) == 0) {\n            m_mtime = st.st_mtime;\n        }\n\n        return true;\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <ctime>\n#include <curl/curl.h>\n#include <fstream>\n#include <unistd.h>\n#include <sys/stat.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\") \n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"Mozilla/5.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    bool run() {\n        if (!m_output.empty()) {\n            if (m_outputTmp.empty()) {\n                m_outputTmp = m_output + \".tmp\";\n            }\n            if (!downloadFile(m_url)) {\n                if (!m_urlBackup.empty()) {\n                    m_retries++;\n                    if (downloadFile(m_urlBackup)) {\n                        return true;\n                    }\n                }\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        char* buffer = static_cast<char*>(contents);\n        std::ofstream file(m_outputTmp, std::ios::binary | std::ios::app);\n        if (file.is_open()) {\n            file.write(buffer, realsize);\n            file.close();\n        } else {\n            m_error = \"Failed to open temporary file for writing.\";\n        }\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl;\n        CURLcode res;\n        std::string error;\n        curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL handle.\";\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);\n\n        FILE* fp;\n        fopen_s(&fp, m_outputTmp.c_str(), \"wb\");\n        if (!fp) {\n            m_error = \"Failed to open temporary file.\";\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            fclose(fp);\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n\n        if (access(m_outputTmp.c_str(), F_OK) == 0) {\n            if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n                m_error = \"Failed to rename temporary file.\";\n                remove(m_outputTmp.c_str());\n                return false;\n            }\n            struct stat st;\n            if (stat(m_output.c_str(), &st) == 0) {\n                m_mtime = st.st_mtime;\n            }\n            return true;\n        } else {\n            m_error = \"Temporary file not found after download.\";\n            remove(m_outputTmp.c_str());\n            return false;\n        }\n    }\n};"
    ],
    "unmatched_results": [
      "#include <curl/curl.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <ctime>\n#include <unistd.h>\n#include <sys/stat.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static CURL* curl;\n    static std::string user_agent;\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"DownloadTask/1.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    ~DownloadTask() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        user_agent = \"DownloadTask/1.0\";\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    bool run() {\n        if (!curl) {\n            curl = curl_easy_init();\n            if (!curl) {\n                m_error = \"Failed to initialize libcurl\";\n                return false;\n            }\n        }\n\n        std::string currentUrl = m_url;\n        for (m_retries = 0; m_retries <= 3; ++m_retries) {\n            curl_easy_setopt(curl, CURLOPT_URL, currentUrl.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n            curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30);\n            curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res == CURLE_OK) {\n                long http_code = 0;\n                curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n                if (http_code >= 200 && http_code < 300) {\n                    if (rename(m_outputTmp.c_str(), m_output.c_str()) != 0) {\n                        m_error = \"Failed to rename temporary file\";\n                        return false;\n                    }\n                    struct stat st;\n                    if (stat(m_output.c_str(), &st) == 0) {\n                        m_mtime = st.st_mtime;\n                    }\n                    return true;\n                } else {\n                    m_error = \"HTTP error code: \" + std::to_string(http_code);\n                    return false;\n                }\n            } else {\n                m_error = \"Download failed with error: \" + std::string(curl_easy_strerror(res));\n                if (m_retries < 3) {\n                    currentUrl = m_urlBackup;\n                    continue;\n                }\n                return false;\n            }\n        }\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        std::ofstream outFile(m_outputTmp, std::ios::binary | std::ios::app);\n        if (!outFile) {\n            m_error = \"Failed to open temporary file\";\n            return realsize;\n        }\n        outFile.write(static_cast<char*>(contents), realsize);\n        outFile.close();\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"Download failed: \" + std::string(curl_easy_strerror(res));\n            return false;\n        }\n        return true;\n    }\n\nprivate:\n    static CURL* curl;\n    static std::string user_agent;\n}; \n\nCURL* DownloadTask::curl = nullptr;\nstd::string DownloadTask::user_agent = \"DownloadTask/1.0\";",
      "#include <curl/curl.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <ctime>\n#include <unistd.h>\n#include <sys/stat.h>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static CURL* curl;\n    static std::string user_agent;\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\")\n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_retries(0), m_name(name), m_userAgent(\"DownloadTask/1.0\") {\n        m_outputTmp = m_output + \".tmp\";\n    }\n\n    ~DownloadTask() {\n        if (curl) {\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        user_agent = \"DownloadTask/1.0\";\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    bool run() {\n        if (!curl) {\n            curl = curl_easy_init();\n            if (!curl) {\n                m_error = \"Failed to initialize libcurl\";\n                return false;\n            }\n        }\n\n        std::string currentUrl = m_url;\n        for (unsigned int attempt = 0; attempt <= m_retries; ++attempt) {\n            curl_easy_setopt(curl, CURLOPT_URL, currentUrl.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &DownloadTask::writeData);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n            curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30);\n            curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 5);\n\n            CURLcode res = curl_easy_perform(curl);\n            if (res == CURLE_OK) {\n                long http_code = 0;\n                curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n                if (http_code >= 200 && http_code < 400) {\n                    if (m_mtime != 0) {\n                        struct utimbuf times;\n                        times.actime = m_mtime;\n                        times.modtime = m_mtime;\n                        utime(m_output.c_str(), &times);\n                    }\n                    rename(m_outputTmp.c_str(), m_output.c_str());\n                    return true;\n                } else {\n                    m_error = \"HTTP error code: \" + std::to_string(http_code);\n                    currentUrl = m_urlBackup;\n                }\n            } else {\n                m_error = \"Download failed with error: \" + std::string(curl_easy_strerror(res));\n                currentUrl = m_urlBackup;\n            }\n\n            m_retries++;\n            if (m_retries > 5) {\n                m_error = \"Max retries exceeded\";\n                return false;\n            }\n        }\n\n        return false;\n    }\n\n    unsigned int getRetries() const {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb) {\n        size_t realsize = size * nmemb;\n        std::ofstream file(m_outputTmp, std::ios::binary | std::ios::app);\n        if (!file) {\n            m_error = \"Failed to open temporary file\";\n            return realsize;\n        }\n        file.write(static_cast<char*>(contents), realsize);\n        file.close();\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"Download failed with error: \" + std::string(curl_easy_strerror(res));\n            return false;\n        }\n        return true;\n    }\n\nprivate:\n    static CURL* curl;\n    static std::string user_agent;\n}; \n\nCURL* DownloadTask::curl = nullptr;\nstd::string DownloadTask::user_agent;"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, process incoming messages, and echo messages back to clients. The server should also support stopping the listening process upon receiving a specific command.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, managing connection handling, message processing, and server lifecycle operations.\n\nAttributes:\n- service_: [asio::io_service&] - Reference to the ASIO I/O service used for network operations\n- port_: [int] - The port number on which the server listens for connections\n- ws_server_: [ws_echo_server] - The WebSocket++ server instance\n\nMethods:\n- Constructor: [WebSocketServer]([asio::io_service& service, int port]) -> [void] - Initializes the WebSocket++ server, sets up logging, message handling, and starts listening on the specified port\n- on_message: [on_message]([websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg]) -> [void] - Callback function that processes incoming messages, echoes them back to clients, and handles the stop-listening command\n- run: [run]() -> [void] - Starts the server's event loop to handle connections and messages",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) \n        : service_(service), port_(port) {\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        if (msg->get_payload() == \"stop-listening\") {\n            ws_server_.stop_listening();\n            return;\n        }\n\n        try {\n            ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.init_asio();\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string message = msg->get_payload();\n        if (message == \"STOP\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, message, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.init_asio();\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string message = msg->get_payload();\n        if (message == \"STOP\") {\n            ws_server_.stop_listening();\n        } else {\n            ws_server_.send(hdl, message, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.init_asio();\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string message = msg->get_payload();\n        if (message == \"stop\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, message, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.init_asio();\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP\") {\n            ws_server_.stop_listening();\n            std::cout << \"Received STOP command. Stopping server.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};"
    ],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.set_error_channels(websocketpp::log::alevel::all);\n        ws_server_.init_asio();\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string message = msg->get_payload();\n        if (message == \"STOP\") {\n            ws_server_.stop_listening();\n            std::cout << \"Received STOP command. Server is stopping.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, message, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.enable_multithreading(true);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string message = msg->get_payload();\n        if (message == \"STOP\") {\n            ws_server_.stop_listening();\n            std::cout << \"Received STOP command. Stopping server.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, message, websocketpp::frame::opcode::text);\n        }\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        ws_server_.init_asio();\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        std::string payload = msg->get_payload();\n        if (payload == \"STOP\") {\n            ws_server_.stop_listening();\n            std::cout << \"Received STOP command. Stopping server.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, payload, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.set_error_handler([](const std::string& msg) {\n            std::cerr << \"Error: \" << msg << std::endl;\n        });\n        ws_server_.set_open_handler([this](websocketpp::connection_hdl hdl) {\n            std::cout << \"Connection opened\" << std::endl;\n        });\n        ws_server_.set_close_handler([this](websocketpp::connection_hdl hdl) {\n            std::cout << \"Connection closed\" << std::endl;\n        });\n        ws_server_.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string message = msg->get_payload();\n        if (message == \"stop\") {\n            std::cout << \"Received stop command. Stopping server...\" << std::endl;\n            ws_server_.close_all_connections();\n            ws_server_.stop_listening();\n            return;\n        }\n        ws_server_.send(hdl, message, websocketpp::frame::opcode::text);\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.set_error_channels(websocketpp::log::alevel::all);\n        ws_server_.init_asio();\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string message = msg->get_payload();\n        if (message == \"STOP\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, message, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n        ws_server_.set_port(port_);\n        ws_server_.set_max_connections(100);\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.set_error_channels(websocketpp::log::alevel::all);\n        ws_server_.init_asio();\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        std::string message = msg->get_payload();\n        if (message == \"STOP\") {\n            ws_server_.stop_listening();\n            std::cout << \"Server stopped listening.\" << std::endl;\n        } else {\n            ws_server_.send(hdl, message, websocketpp::frame::opcode::text);\n        }\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    server ws_server_;\n};"
    ],
    "match_count": 4,
    "pass@3": 0.8333333333333334,
    "pass@5": 0.9761904761904762
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication\n- m_connections: [con_list (std::set<connection_hdl>)] - A set of active client connections\n\nMethods:\n- broadcast_server() - [Constructor] -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events\n- on_open(connection_hdl hdl) -> [void] - Handles new client connections by adding them to the connection set\n- on_close(connection_hdl hdl) -> [void] - Handles client disconnections by removing them from the connection set\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by broadcasting them to all connected clients\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef server::message_ptr message_ptr;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections, process incoming messages, and support configurable threading for concurrent operations.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server implementation, providing methods to initialize, configure, and run the server with customizable port and threading settings.\n\nAttributes:\n- testee_server_: [server] - The WebSocket++ server instance that manages connections and message handling\n- port_: [short] - The port number on which the server listens for incoming connections\n- num_threads_: [size_t] - The number of threads to use for handling connections (1 for single-threaded mode)\n\nMethods:\n- WebSocketServer([short port = 9002], [size_t num_threads = 1]) -> [void] - Constructor that initializes the server with specified port and thread count (defaults to port 9002 and single-threaded)\n- run() -> [void] - Starts the WebSocket server, sets up message handlers, begins listening on the specified port, and manages the server's event loop(s)\n- on_message([websocketpp::connection_hdl hdl], [message_ptr msg]) -> [void] - Message handler that echoes received messages back to the client (private method)\n- on_socket_init([websocketpp::connection_hdl hdl], [boost::asio::ip::tcp::socket & s]) -> [void] - Socket initialization handler that enables TCP_NODELAY for reduced latency (private method)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/extensions/permessage_deflate/enabled.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <websocketpp/common/thread.hpp>\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::message_ptr message_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) \n        : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        try {\n            testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n            testee_server_.clear_error_channels(websocketpp::log::alevel::all);\n\n            testee_server_.init_asio();\n            testee_server_.set_reuse_addr(true);\n\n            testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n            testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, ::_1, ::_2));\n\n            testee_server_.set_listen_backlog(8192);\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n\n            if (num_threads_ == 1) {\n                testee_server_.run();\n            } else {\n                std::vector<websocketpp::lib::shared_ptr<websocketpp::lib::thread>> ts;\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts.push_back(websocketpp::lib::make_shared<websocketpp::lib::thread>(&server::run, &testee_server_));\n                }\n\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts[i]->join();\n                }\n            }\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket & s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) {\n        testee_server_.set_port(port);\n        testee_server_.set_max_connections(1000);\n        testee_server_.set_concurrency_model(websocketpp::concurrency::model::thread_per_connection);\n        testee_server_.init_asio();\n        testee_server_.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.set_socket_init_handler(std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.listen(port);\n        testee_server_.start_accept();\n        testee_server_.run_async();\n    }\n\n    void run() {\n        testee_server_.run();\n    }\n\nprivate:\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) {\n        testee_server_.set_port(port);\n        testee_server_.set_max_connections(1000);\n        testee_server_.set_concurrency_model(websocketpp::concurrency::model::thread_per_connection);\n        testee_server_.init_asio();\n        testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, _1, _2));\n        testee_server_.listen(port);\n        testee_server_.start_accept();\n        testee_server_.run();\n    }\n\n    void run() {\n        testee_server_.run();\n    }\n\nprivate:\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket & s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) {\n        testee_server_.set_port(port);\n        testee_server_.set_max_connections(1000);\n        testee_server_.set_concurrency_model(websocketpp::concurrency::model::thread_per_connection);\n        testee_server_.init_asio();\n        testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, _1, _2));\n        testee_server_.listen(port);\n        testee_server_.start_accept();\n        testee_server_.run();\n    }\n\n    void run() {\n        testee_server_.run();\n    }\n\nprivate:\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket & s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        testee_server_.set_port(port_);\n        testee_server_.set_max_connections(1000);\n        testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n        testee_server_.clear_error_channels(websocketpp::log::elevel::all);\n\n        testee_server_.init_asio();\n\n        testee_server_.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.set_socket_init_handler(std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2));\n\n        testee_server_.listen(port_);\n\n        testee_server_.start_accept();\n\n        if (num_threads_ > 1) {\n            for (size_t i = 0; i < num_threads_; ++i) {\n                testee_server_.run_async();\n            }\n        } else {\n            testee_server_.run();\n        }\n    }\n\nprivate:\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n};"
    ],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) {\n        testee_server_.set_port(port);\n        testee_server_.set_max_connections(1000);\n        testee_server_.set_concurrency_model(websocketpp::concurrency::model::thread_per_connection);\n        testee_server_.set_thread_pool_size(num_threads);\n    }\n\n    void run() {\n        testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n        testee_server_.clear_error_channels(websocketpp::log::elevel::all);\n\n        testee_server_.on_message(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.on_socket_init(std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2));\n\n        try {\n            testee_server_.listen(testee_server_.get_port());\n            testee_server_.start_accept();\n            testee_server_.run();\n        } catch (const std::exception& e) {\n            std::cerr << \"Exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        testee_server_.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.set_socket_init_handler(std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2));\n\n        try {\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n\n            if (num_threads_ > 1) {\n                testee_server_.run_async();\n            } else {\n                testee_server_.run();\n            }\n        } catch (const std::exception& e) {\n            std::cerr << \"Exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) {\n        testee_server_.set_port(port);\n        testee_server_.set_max_connections(1000);\n        testee_server_.set_concurrency_model(websocketpp::concurrency::model::thread_per_connection);\n        testee_server_.set_thread_pool_size(num_threads);\n        testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n        testee_server_.clear_error_channels(websocketpp::log::elevel::all);\n        testee_server_.on_message(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.on_socket_init(std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run() {\n        try {\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n            testee_server_.run();\n        } catch (const std::exception& e) {\n            std::cerr << \"Exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket & s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        testee_server_.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.set_socket_init_handler(std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2));\n\n        try {\n            testee_server_.init_asio();\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n\n            if (num_threads_ > 1) {\n                for (size_t i = 0; i < num_threads_; ++i) {\n                    testee_server_.run();\n                }\n            } else {\n                testee_server_.run();\n            }\n        } catch (const std::exception& e) {\n            std::cerr << \"Exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) {\n        testee_server_.set_port(port);\n        testee_server_.set_max_connections(1000);\n        testee_server_.set_concurrency_model(websocketpp::concurrency::model::thread_per_connection);\n        testee_server_.set_thread_pool_size(num_threads);\n        testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n        testee_server_.clear_error_channels(websocketpp::log::elevel::all);\n        testee_server_.on_message(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.on_socket_init(std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run() {\n        try {\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n            testee_server_.run();\n        } catch (const std::exception& e) {\n            std::cerr << \"Exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) : port_(port), num_threads_(num_threads) {\n        testee_server_.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        testee_server_.set_socket_init_handler(std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run() {\n        testee_server_.init_asio();\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        boost::asio::io_service io_service;\n        std::vector<boost::thread> threads;\n\n        for (size_t i = 0; i < num_threads_; ++i) {\n            threads.emplace_back([&io_service]() { io_service.run(); });\n        }\n\n        testee_server_.run();\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl hdl, boost::asio::ip::tcp::socket &s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};"
    ],
    "match_count": 4,
    "pass@3": 0.8333333333333334,
    "pass@5": 0.9761904761904762
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage sessions, and process incoming messages.\n\nClass Description: The `print_server` class implements a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: int - Tracks the next available session ID to assign to new connections.\n- m_server: server - The WebSocket++ server instance configured with custom connection data.\n\nMethods:\n- print_server() - Constructor - Initializes the server with ASIO, sets up handlers for connection open, close, and message events.\n- on_open(connection_hdl hdl) -> void - Handler for new connections. Assigns a session ID to the new connection.\n- on_close(connection_hdl hdl) -> void - Handler for connection closures. Logs the connection's name and session ID.\n- on_message(connection_hdl hdl, server::message_ptr msg) -> void - Handler for incoming messages. Sets the connection name if not set, otherwise logs the message along with the connection's name and session ID.\n- run(uint16_t port) -> void - Starts the server listening on the specified port, begins accepting connections, and runs the event loop.",
    "Canonical_solution": "#include <iostream>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nstruct custom_config : public websocketpp::config::asio {\n    typedef websocketpp::config::asio core;\n    typedef core::concurrency_type concurrency_type;\n    typedef core::request_type request_type;\n    typedef core::response_type response_type;\n    typedef core::message_type message_type;\n    typedef core::con_msg_manager_type con_msg_manager_type;\n    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;\n    typedef core::alog_type alog_type;\n    typedef core::elog_type elog_type;\n    typedef core::rng_type rng_type;\n    typedef core::transport_type transport_type;\n    typedef core::endpoint_base endpoint_base;\n    typedef connection_data connection_base;\n};\n\ntypedef websocketpp::server<custom_config> server;\ntypedef server::connection_ptr connection_ptr;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->sessionid = m_next_sessionid++;\n    }\n    \n    void on_close(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Closing connection \" << con->name \n                  << \" with sessionid \" << con->sessionid << std::endl;\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        \n        if (con->name.empty()) {\n            con->name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \" \n                      << con->sessionid << \" to \" << con->name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << con->name \n                      << \" with sessionid \" << con->sessionid << std::endl;\n        }\n    }\n    \n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        session_data data;\n        data.session_id = m_next_sessionid++;\n        m_server.get_con_from_hdl(hdl)->set_user_data(data);\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        std::cout << \"Connection closed. Name: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            m_server.get_con_from_hdl(hdl)->set_user_data(data);\n            std::cout << \"Connection name set to: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n        } else {\n            std::cout << \"Message received from \" << data.name << \" (Session ID: \" << data.session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        session_data data;\n        data.session_id = m_next_sessionid++;\n        m_server.get_con_from_hdl(hdl)->set_user_data(data);\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        std::cout << \"Connection closed. Name: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            m_server.get_con_from_hdl(hdl)->set_user_data(data);\n            std::cout << \"Connection name set to: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n        } else {\n            std::cout << \"Message received from \" << data.name << \" (Session ID: \" << data.session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        session_data data;\n        data.session_id = m_next_sessionid++;\n        m_server.get_con_from_hdl(hdl)->set_user_data(data);\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        std::cout << \"Connection closed. Name: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            m_server.get_con_from_hdl(hdl)->set_user_data(data);\n            std::cout << \"Connection name set to: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n        } else {\n            std::cout << \"Message received from \" << data.name << \" (Session ID: \" << data.session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        session_data data;\n        data.session_id = m_next_sessionid++;\n        m_server.get_con_from_hdl(hdl)->set_user_data(data);\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        std::cout << \"Connection closed. Name: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            m_server.get_con_from_hdl(hdl)->set_user_data(data);\n            std::cout << \"Connection name set to: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n        } else {\n            std::cout << \"Message received from \" << data.name << \" (Session ID: \" << data.session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    int session_id;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        con->set_user_data(new session_data{m_next_sessionid++, \"\"});\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        session_data* data = static_cast<session_data*>(con->get_user_data());\n        if (data) {\n            std::cout << \"Connection closed. Name: \" << data->name << \", Session ID: \" << data->session_id << std::endl;\n            delete data;\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        session_data* data = static_cast<session_data*>(con->get_user_data());\n        if (data->name.empty()) {\n            data->name = msg->get_payload();\n            std::cout << \"Connection named: \" << data->name << \", Session ID: \" << data->session_id << std::endl;\n        } else {\n            std::cout << \"Message from \" << data->name << \" (Session ID: \" << data->session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        session_data data;\n        data.session_id = m_next_sessionid++;\n        m_server.get_con_from_hdl(hdl)->set_user_data(data);\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        std::cout << \"Connection closed. Name: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            m_server.get_con_from_hdl(hdl)->set_user_data(data);\n            std::cout << \"Connection name set to: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n        } else {\n            std::cout << \"Message received from \" << data.name << \" (Session ID: \" << data.session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    int session_id;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        con->set_user_data(new session_data{m_next_sessionid++, \"\"});\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        session_data* data = static_cast<session_data*>(con->get_user_data());\n        if (data) {\n            std::cout << \"Connection closed. Name: \" << data->name << \", Session ID: \" << data->session_id << std::endl;\n            delete data;\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        session_data* data = static_cast<session_data*>(con->get_user_data());\n        if (data->name.empty()) {\n            data->name = msg->get_payload();\n            std::cout << \"Connection named: \" << data->name << \", Session ID: \" << data->session_id << std::endl;\n        } else {\n            std::cout << \"Message from \" << data->name << \" (Session ID: \" << data->session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct connection_data {\n    int session_id;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        con->set_user_data(new connection_data{m_next_sessionid++, \"\"});\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        connection_data* data = static_cast<connection_data*>(con->get_user_data());\n        if (data) {\n            std::cout << \"Connection closed. Name: \" << data->name << \", Session ID: \" << data->session_id << std::endl;\n            delete data;\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        connection_data* data = static_cast<connection_data*>(con->get_user_data());\n        if (data->name.empty()) {\n            data->name = msg->get_payload();\n            std::cout << \"Connection named: \" << data->name << \", Session ID: \" << data->session_id << std::endl;\n        } else {\n            std::cout << \"Message from \" << data->name << \" (Session ID: \" << data->session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <map>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        con->set_user_data(new session_data{ \"\", m_next_sessionid++ });\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        session_data* data = reinterpret_cast<session_data*>(con->get_user_data());\n        if (data) {\n            std::cout << \"Connection closed: Name: \" << data->name << \", Session ID: \" << data->session_id << std::endl;\n            delete data;\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        auto con = m_server.get_con_from_hdl(hdl);\n        session_data* data = reinterpret_cast<session_data*>(con->get_user_data());\n        if (!data->name.empty()) {\n            std::cout << \"Message from \" << data->name << \" (Session ID: \" << data->session_id << \"): \" << msg->get_payload() << std::endl;\n        } else {\n            data->name = \"Anonymous\";\n            std::cout << \"Connection established for anonymous user (Session ID: \" << data->session_id << \")\" << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nstruct session_data {\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        session_data data;\n        data.session_id = m_next_sessionid++;\n        m_server.get_con_from_hdl(hdl)->set_user_data(data);\n    }\n\n    void on_close(connection_hdl hdl) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        std::cout << \"Connection closed. Name: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        session_data data = m_server.get_con_from_hdl(hdl)->get_user_data();\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            m_server.get_con_from_hdl(hdl)->set_user_data(data);\n            std::cout << \"Connection name set to: \" << data.name << \", Session ID: \" << data.session_id << std::endl;\n        } else {\n            std::cout << \"Message received from \" << data.name << \" (Session ID: \" << data.session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, std::pair<std::string, int>, std::owner_less<connection_hdl>> connection_map;\n\nclass connection_data {\npublic:\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Welcome to the WebSocket server!\", websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            get_data_from_hdl(hdl).name = msg->get_payload();\n            m_server.send(hdl, \"Name set successfully\", websocketpp::frame::opcode::text);\n        } catch (const std::out_of_range& e) {\n            m_server.send(hdl, \"Error: Could not set name\", websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> connection_map;\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Connected with session ID: \" + std::to_string(data.session_id), websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n        m_server.send(hdl, \"Connection closed\", websocketpp::frame::opcode::text);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            get_data_from_hdl(hdl);\n            if (msg->get_type() == websocketpp::message::type::text) {\n                std::string payload = msg->get_payload();\n                size_t colon_pos = payload.find(':');\n                if (colon_pos != std::string::npos) {\n                    std::string name = payload.substr(0, colon_pos);\n                    m_connections[hdl].name = name;\n                    m_server.send(hdl, \"Name set to: \" + name, websocketpp::frame::opcode::text);\n                } else {\n                    m_server.send(hdl, \"Message received: \" + payload, websocketpp::frame::opcode::text);\n                }\n            }\n        } catch (const std::out_of_range& e) {\n            m_server.send(hdl, \"Error processing message\", websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> connection_map;\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Welcome to the WebSocket server!\", websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            get_data_from_hdl(hdl).name = msg->get_payload();\n            m_server.send(hdl, \"Name set successfully\", websocketpp::frame::opcode::text);\n        } catch (const std::out_of_range& e) {\n            m_server.send(hdl, \"Error: Could not set name\", websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, std::pair<std::string, int>, std::owner_less<connection_hdl>> connection_map;\n\nclass connection_data {\npublic:\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Welcome to the WebSocket server!\", websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n            if (msg->get_type() == websocketpp::frame::opcode::text) {\n                std::string payload = msg->get_payload();\n                if (payload.find(\"name:\") == 0) {\n                    data.name = payload.substr(5);\n                    m_server.send(hdl, \"Name set to: \" + data.name, websocketpp::frame::opcode::text);\n                } else {\n                    m_server.send(hdl, \"Received message: \" + payload, websocketpp::frame::opcode::text);\n                }\n            }\n        } catch (const std::exception& e) {\n            m_server.send(hdl, \"Error: \" + std::string(e.what()), websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, std::pair<std::string, int>, std::owner_less<connection_hdl>> connection_map;\n\nclass connection_data {\npublic:\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"unnamed\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Connected\", websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n        m_server.send(hdl, \"Connection closed\", websocketpp::frame::opcode::text);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            auto& data = get_data_from_hdl(hdl);\n            if (msg->get_type() == websocketpp::frame::opcode::text) {\n                std::string payload = msg->get_payload();\n                if (payload.find(\"name:\") == 0) {\n                    data.name = payload.substr(5);\n                    m_server.send(hdl, \"Name set\", websocketpp::frame::opcode::text);\n                } else {\n                    m_server.send(hdl, \"Message received: \" + payload, websocketpp::frame::opcode::text);\n                }\n            }\n        } catch (const std::exception& e) {\n            m_server.send(hdl, \"Error: \" + std::string(e.what()), websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> connection_map;\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Connected with session ID: \" + std::to_string(data.session_id), websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n        m_server.send(hdl, \"Connection closed\", websocketpp::frame::opcode::text);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            get_data_from_hdl(hdl);\n            if (msg->get_type() == websocketpp::message::type::text) {\n                std::string payload = msg->get_payload();\n                size_t colon_pos = payload.find(':');\n                if (colon_pos != std::string::npos) {\n                    std::string name = payload.substr(0, colon_pos);\n                    m_connections[hdl].name = name;\n                    m_server.send(hdl, \"Name set to: \" + name, websocketpp::frame::opcode::text);\n                } else {\n                    m_server.send(hdl, \"Message received: \" + payload, websocketpp::frame::opcode::text);\n                }\n            }\n        } catch (const std::out_of_range& e) {\n            m_server.send(hdl, \"Error processing message\", websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> connection_map;\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Connected with session ID: \" + std::to_string(data.session_id), websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n        m_server.send(hdl, \"Connection closed\", websocketpp::frame::opcode::text);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            get_data_from_hdl(hdl);\n            if (msg->get_type() == websocketpp::frame::opcode::text) {\n                std::string payload = msg->get_payload();\n                size_t colon_pos = payload.find(':');\n                if (colon_pos != std::string::npos) {\n                    std::string name = payload.substr(0, colon_pos);\n                    std::string message = payload.substr(colon_pos + 1);\n                    get_data_from_hdl(hdl).name = name;\n                    m_server.send(hdl, \"Name set to: \" + name, websocketpp::frame::opcode::text);\n                    m_server.send(hdl, \"Received: \" + message, websocketpp::frame::opcode::text);\n                } else {\n                    m_server.send(hdl, \"Received: \" + payload, websocketpp::frame::opcode::text);\n                }\n            }\n        } catch (const std::out_of_range& e) {\n            m_server.send(hdl, \"Error processing message\", websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, std::pair<std::string, int>, std::owner_less<connection_hdl>> connection_map;\n\nclass connection_data {\npublic:\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Welcome to the WebSocket server!\", websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            get_data_from_hdl(hdl).name = msg->get_payload();\n            m_server.send(hdl, \"Name set successfully.\", websocketpp::frame::opcode::text);\n        } catch (const std::out_of_range& e) {\n            m_server.send(hdl, \"Error: Could not set name.\", websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> connection_map;\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Connected to server\", websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n        m_server.send(hdl, \"Connection closed\", websocketpp::frame::opcode::text);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n            if (msg->get_type() == websocketpp::frame::opcode::text) {\n                std::string payload = msg->get_payload();\n                size_t colon_pos = payload.find(':');\n                if (colon_pos != std::string::npos) {\n                    std::string name = payload.substr(0, colon_pos);\n                    data.name = name;\n                    m_server.send(hdl, \"Name set to: \" + name, websocketpp::frame::opcode::text);\n                } else {\n                    m_server.send(hdl, \"Message received: \" + payload, websocketpp::frame::opcode::text);\n                }\n            }\n        } catch (const std::exception& e) {\n            m_server.send(hdl, \"Error: \" + std::string(e.what()), websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::map<connection_hdl, std::pair<std::string, int>, std::owner_less<connection_hdl>> connection_map;\n\nclass connection_data {\npublic:\n    std::string name;\n    int session_id;\n};\n\nclass print_server {\npublic:\n    int m_next_sessionid;\n    server m_server;\n    connection_map m_connections;\n\n    print_server() : m_next_sessionid(1) {\n        m_server.set_open_handler(std::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n        data.session_id = m_next_sessionid++;\n        data.name = \"anonymous\";\n        m_connections[hdl] = data;\n        m_server.send(hdl, \"Welcome to the WebSocket server!\", websocketpp::frame::opcode::text);\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        try {\n            get_data_from_hdl(hdl).name = msg->get_payload();\n            m_server.send(hdl, \"Name set successfully.\", websocketpp::frame::opcode::text);\n        } catch (const std::out_of_range& e) {\n            m_server.send(hdl, \"Error: Could not set name.\", websocketpp::frame::opcode::text);\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication.\n- m_connections: [con_list] - A set of active connection handles to keep track of connected clients.\n\nMethods:\n- broadcast_server(): [Constructor]() -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events (open, close, message).\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handler for new client connections; adds the connection handle to the active connections set.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handler for client disconnections; removes the connection handle from the active connections set.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Handler for incoming messages; broadcasts the received message to all connected clients.\n- run: [void]([uint16_t port]) -> [void] - Starts the server, begins listening on the specified port, and enters the event loop to handle connections and messages.",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n                \n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n    \n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it = m_connections.begin(); it != m_connections.end(); ++it) {\n            if (*it != hdl) {\n                m_server.send(*it, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it = m_connections.begin(); it != m_connections.end(); ++it) {\n            if (*it != hdl) {\n                m_server.send(*it, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it = m_connections.begin(); it != m_connections.end(); ++it) {\n            if (*it != hdl) {\n                m_server.send(*it, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it = m_connections.begin(); it != m_connections.end(); ++it) {\n            if (*it != hdl) {\n                m_server.send(*it, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::set<connection_hdl> con_list;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto& conn : m_connections) {\n            if (conn != hdl) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections and echo back received messages.\n\nClass Description: The utility_server class encapsulates a WebSocket server that listens for incoming connections, receives messages from clients, and echoes them back. It uses WebSocket++ with ASIO for network handling.\n\nAttributes:\n- m_endpoint: [server] - The WebSocket++ server instance that manages connections and message handling.\n\nMethods:\n- utility_server() - [Constructor] -> [void] - Initializes the server with logging settings, ASIO, and sets up the message handler.\n- echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by echoing them back to the client.\n- run() -> [void] - Starts the server, begins listening on port 9002, and runs the ASIO event loop.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <functional>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n         // Set logging settings\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all ^ websocketpp::log::alevel::frame_payload);\n\n        // Initialize Asio\n        m_endpoint.init_asio();\n\n        // Set the default message handler to the echo handler\n        m_endpoint.set_message_handler(std::bind(\n            &utility_server::echo_handler, this,\n            std::placeholders::_1, std::placeholders::_2\n        ));\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        // write a new message\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        // Listen on port 9002\n        m_endpoint.listen(9002);\n\n        // Queues a connection accept operation\n        m_endpoint.start_accept();\n\n        // Start the Asio io_service run loop\n        m_endpoint.run();\n    }\nprivate:\n    server m_endpoint;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() : m_endpoint() {\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, std::placeholders::_1, std::placeholders::_2));\n        m_endpoint.set_open_handler([this](websocketpp::connection_hdl hdl) {\n            std::cout << \"Connection opened\" << std::endl;\n        });\n        m_endpoint.set_close_handler([this](websocketpp::connection_hdl hdl) {\n            std::cout << \"Connection closed\" << std::endl;\n        });\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass utility_server {\npublic:\n    utility_server() : m_endpoint() {\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, std::placeholders::_1, std::placeholders::_2));\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass utility_server {\npublic:\n    utility_server() : m_endpoint() {\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, std::placeholders::_1, std::placeholders::_2));\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass utility_server {\npublic:\n    utility_server() : m_endpoint() {\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, std::placeholders::_1, std::placeholders::_2));\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass utility_server {\npublic:\n    utility_server() : m_endpoint() {\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, std::placeholders::_1, std::placeholders::_2));\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint = std::make_shared<server>();\n        m_endpoint->set_message_handler(std::bind(&utility_server::echo_handler, this, _1, _2));\n        m_endpoint->set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint->enable_multithreading();\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint->listen(9002);\n        m_endpoint->start_accept();\n        m_endpoint->run();\n    }\n\nprivate:\n    std::shared_ptr<server> m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass utility_server {\npublic:\n    utility_server() : m_endpoint() {\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, std::placeholders::_1, std::placeholders::_2));\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass utility_server {\npublic:\n    utility_server() : m_endpoint() {\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, std::placeholders::_1, std::placeholders::_2));\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    server m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint = std::make_shared<server>();\n        m_endpoint->set_message_handler(std::bind(&utility_server::echo_handler, this, _1, _2));\n        m_endpoint->set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint->set_error_channels(websocketpp::log::elevel::all);\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint->send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void run() {\n        m_endpoint->listen(9002);\n        m_endpoint->start_accept();\n        m_endpoint->run();\n    }\n\nprivate:\n    std::shared_ptr<server> m_endpoint;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_no_tls> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint = std::make_shared<server>();\n        m_endpoint->set_message_handler(std::bind(&utility_server::echo_handler, this, _1, _2));\n        m_endpoint->set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint->set_error_channels(websocketpp::log::elevel::all);\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        m_endpoint->send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void run() {\n        m_endpoint->listen(9002);\n        m_endpoint->start_accept();\n        m_endpoint->run();\n    }\n\nprivate:\n    std::shared_ptr<server> m_endpoint;\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ using the WebSocket++ library to handle client connections, process incoming messages, and manage server events.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, providing methods to initialize, configure, and run the server. It handles WebSocket connections, processes messages, and manages various server events like HTTP requests, connection failures, and closures.\n\nAttributes:\n- m_server: [websocketpp::server<websocketpp::config::debug_asio>] - The main WebSocket++ server instance that manages connections and events.\n\nMethods:\n- WebSocketServer() -> [Constructor] - Initializes the server with default settings, configures logging, sets up ASIO, and registers event handlers.\n- run(int port) -> [void] - Starts the server on the specified port, begins accepting connections, and runs the event loop.\n- validate(websocketpp::connection_hdl hdl) -> [bool] - Validates incoming connections (always returns true in this implementation).\n- on_http(websocketpp::connection_hdl hdl) -> [void] - Handles HTTP requests received by the server.\n- on_fail(websocketpp::connection_hdl hdl) -> [void] - Handles connection failure events.\n- on_close(websocketpp::connection_hdl hdl) -> [void] - Handles connection closure events.\n- on_message(websocketpp::connection_hdl hdl, message_ptr msg) -> [void] - Processes incoming WebSocket messages and echoes them back to the client.",
    "Canonical_solution": "#include <websocketpp/config/debug_asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/logger/syslog.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass WebSocketServer {\npublic:\n    typedef websocketpp::server<websocketpp::config::debug_asio> server;\n    typedef server::message_ptr message_ptr;\n\n    WebSocketServer() {\n        // Set logging settings\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        // Initialize ASIO\n        m_server.init_asio();\n        m_server.set_reuse_addr(true);\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, ::_1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, ::_1));\n        m_server.set_validate_handler(bind(&WebSocketServer::validate, this, ::_1));\n    }\n\n    void run(int port) {\n        try {\n            // Listen on specified port\n            m_server.listen(port);\n\n            // Start the server accept loop\n            m_server.start_accept();\n\n            // Start the ASIO io_service run loop\n            m_server.run();\n        } catch (websocketpp::exception const & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::string res = con->get_request_body();\n        std::stringstream ss;\n        ss << \"got HTTP request with \" << res.size() << \" bytes of body data.\";\n        con->set_body(ss.str());\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Fail handler: \" << con->get_ec() << \" \" << con->get_ec().message() << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Close handler\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \" \n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        m_server.set_open_handler(bind(&WebSocketServer::on_open, this, _1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, _1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, _1));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, _1));\n        m_server.set_log_level(websocketpp::log::alevel::none);\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        m_server.set_open_handler(bind(&WebSocketServer::on_open, this, _1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, _1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, _1));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, _1));\n        m_server.set_log_level(websocketpp::log::alevel::none);\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"Received: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        m_server.set_open_handler(bind(&WebSocketServer::on_open, this, _1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, _1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, _1));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, _1));\n        m_server.set_log_level(websocketpp::log::alevel::none);\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        m_server.set_open_handler(bind(&WebSocketServer::on_open, this, _1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, _1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, _1));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, _1));\n        m_server.set_log_level(websocketpp::log::alevel::none);\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_string() << std::endl;\n        m_server.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        m_server.set_open_handler(bind(&WebSocketServer::on_open, this, _1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, _1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, _1));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, _1));\n        m_server.set_log_level(websocketpp::log::alevel::none);\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_string() << std::endl;\n        m_server.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_open_handler(std::bind(&WebSocketServer::on_open, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server.set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server.set_log_level(websocketpp::log::alevel::none);\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    server m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, _1, _2));\n        m_server.set_open_handler(bind(&WebSocketServer::on_open, this, _1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, _1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, _1));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, _1));\n        m_server.set_log_level(websocketpp::log::alevel::none);\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_string() << std::endl;\n        m_server.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\nprivate:\n    server m_server;\n};"
    ],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server = std::make_shared<server>();\n        m_server->set_error_handler([](const std::string& err) {\n            std::cerr << \"Error: \" << err << std::endl;\n        });\n        m_server->set_open_handler([this](websocketpp::connection_hdl hdl) {\n            std::cout << \"Connection opened\" << std::endl;\n        });\n        m_server->set_close_handler([this](websocketpp::connection_hdl hdl) {\n            std::cout << \"Connection closed\" << std::endl;\n        });\n        m_server->set_message_handler([this](websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n            if (msg->get_type() == websocketpp::message::type::text) {\n                std::cout << \"Received: \" << msg->get_payload() << std::endl;\n                m_server->send(hdl, msg->get_payload(), websocketpp::frame::opcode::text);\n            }\n        });\n        m_server->set_http_handler([this](websocketpp::connection_hdl hdl) {\n            std::cout << \"HTTP request received\" << std::endl;\n        });\n    }\n\n    void run(int port) {\n        m_server->listen(port);\n        m_server->start_accept();\n        m_server->run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"Handling HTTP request\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        if (msg->get_type() == websocketpp::message::type::text) {\n            std::cout << \"Received: \" << msg->get_payload() << std::endl;\n            m_server->send(hdl, msg->get_payload(), websocketpp::frame::opcode::text);\n        }\n    }\n\nprivate:\n    std::shared_ptr<server> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server = std::make_shared<server>();\n        m_server->set_port(8080);\n        m_server->set_max_connections(100);\n        m_server->enable_multithreaded();\n        m_server->clear_access_channels(websocketpp::log::alevel::all);\n        m_server->clear_error_channels(websocketpp::log::alevel::all);\n        m_server->set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server->set_open_handler(std::bind(&WebSocketServer::on_open, this, std::placeholders::_1));\n        m_server->set_close_handler(std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server->set_fail_handler(std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server->set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server->set_port(port);\n        m_server->listen();\n        m_server->start_accept();\n        m_server->run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\nprivate:\n    std::shared_ptr<server> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server = std::make_shared<server>();\n        m_server->set_access_channels(websocketpp::log::alevel::all);\n        m_server->set_error_channels(websocketpp::log::elevel::all);\n        m_server->init_asio();\n        m_server->register_handler(\"on_http\", std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n        m_server->register_handler(\"on_fail\", std::bind(&WebSocketServer::on_fail, this, std::placeholders::_1));\n        m_server->register_handler(\"on_close\", std::bind(&WebSocketServer::on_close, this, std::placeholders::_1));\n        m_server->register_handler(\"on_message\", std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void run(int port) {\n        m_server->listen(port);\n        m_server->start_accept();\n        m_server->run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\nprivate:\n    std::shared_ptr<server> m_server;\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received\" << std::endl;\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed\" << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        std::cout << \"Received message: \" << msg->get_payload() << std::endl;\n        m_server->send(hdl, msg->get_payload(), websocketpp::frame::opcode::text);\n    }\n};"
    ],
    "match_count": 7,
    "pass@3": 0.9916666666666667,
    "pass@5": 1.0
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that supports secure TLS connections and handles both WebSocket and HTTP requests.\n\nClass Description: The WebSocketServer class encapsulates a secure WebSocket server implementation using WebSocket++ with ASIO and TLS support. It handles incoming connections, processes messages, and manages secure communication settings.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that manages connections and communication\n- tls_mode: [enum] - Enumeration defining TLS security modes (MOZILLA_INTERMEDIATE, MOZILLA_MODERN)\n\nMethods:\n- WebSocketServer() -> [constructor] - Initializes the server, sets up ASIO, and registers handler functions\n- run([int port]) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_message([websocketpp::connection_hdl hdl, message_ptr msg]) -> [void] - Handles incoming WebSocket messages by echoing them back to the client\n- on_http([websocketpp::connection_hdl hdl]) -> [void] - Handles HTTP requests by returning a simple \"Hello World!\" response\n- get_password() -> [std::string] - Returns the password used for TLS certificate encryption\n- on_tls_init([tls_mode mode, websocketpp::connection_hdl hdl]) -> [context_ptr] - Initializes and configures TLS/SSL context with appropriate security settings based on the specified mode",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/lib/asio.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\ntypedef websocketpp::config::asio::message_type::ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        // Initialize ASIO\n        m_server.init_asio();\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, MOZILLA_INTERMEDIATE, ::_1));\n    }\n\n    void run(int port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start the server accept loop\n        m_server.start_accept();\n\n        // Start the ASIO io_service run loop\n        m_server.run();\n    }\n\nprivate:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE = 1,\n        MOZILLA_MODERN = 2\n    };\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        namespace asio = websocketpp::lib::asio;\n\n        context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_MODERN) {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::no_tlsv1 |\n                                 asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::single_dh_use);\n            }\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dh.pem\");\n            \n            std::string ciphers = (mode == MOZILLA_MODERN) ? \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\" : \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\";\n            \n            if (SSL_CTX_set_cipher_list(ctx->native_handle(), ciphers.c_str()) != 1) {\n                std::cout << \"Error setting cipher list\" << std::endl;\n            }\n        } catch (std::exception& e) {\n            std::cout << \"Exception: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n#include <memory>\n\nnamespace websocketpp {\n    namespace transport {\n        namespace asio {\n            namespace ssl_socket {\n                template<typename TransportType>\n                class socket : public boost::asio::ssl::stream<boost::asio::ip::tcp::socket>\n                {\n                public:\n                    typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> base;\n                    socket(TransportType& transport) : base(transport.get_io_service()) {}\n                };\n            }\n        }\n    }\n}\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        config::asio_client::enable_text(true);\n        config::asio_client::enable_binary(true);\n        m_server.init_asio();\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        m_server.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto resp = m_server.http_response(hdl);\n        resp->set_status(http::status::ok);\n        resp->set_header(\"Content-Type\", \"text/plain\");\n        resp->set_body(\"Hello World!\");\n        m_server.reply(hdl, resp);\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    void on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->load_verify_file(\"ca.crt\");\n            ctx->set_verify_mode(boost::asio::ssl::context::verify_peer);\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::no_tlsv1 |\n                             boost::asio::ssl::context::no_tlsv1_1 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->load_verify_file(\"ca.crt\");\n            ctx->set_verify_mode(boost::asio::ssl::context::verify_peer);\n        }\n        return ctx;\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n#include <memory>\n\nnamespace websocketpp {\n    namespace transport {\n        namespace asio {\n            namespace ssl_socket {\n                template<typename T>\n                struct socket;\n            }\n        }\n    }\n}\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        m_server.init_asio();\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        m_server.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto& server = m_server;\n        server.http_response(hdl)\n            .set_status(http::status::ok)\n            .set_header(http::field::server, \"WebSocket++\")\n            .set_header(http::field::content_type, \"text/plain\")\n            .set_body(\"Hello World!\");\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->set_verify_mode(boost::asio::ssl::verify_peer);\n            ctx->set_verify_callback(boost::asio::ssl::verify_mode::peer);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::no_tlsv1 |\n                             boost::asio::ssl::context::no_tlsv1_1 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->set_verify_mode(boost::asio::ssl::verify_peer);\n            ctx->set_verify_callback(boost::asio::ssl::verify_mode::peer);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n        }\n        return ctx;\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_server;\n};"
    ],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/http.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <string>\n#include <memory>\n\nnamespace websocketpp = boost::beast::websocket;\nnamespace http = boost::beast::http;\nnamespace ssl = boost::beast::ssl;\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server() {\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        m_server.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto& connection = m_server.get_con_from_hdl(hdl);\n        http::request<http::string_body> req = connection.get_request();\n        if (req.method() == http::verb::get) {\n            http::response<http::string_body> res{http::status::ok, 11};\n            res.set(http::field::server, \"Boost.Beast\");\n            res.set(http::field::content_type, \"text/plain\");\n            res.body() = \"Hello World!\";\n            res.prepare_payload();\n            connection.reply(res);\n        }\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::single_dh_use |\n                             boost::asio::ssl::context::no_compresseed_rfc1321_padding);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n        }\n        return ctx;\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/json_parser.hpp>\n#include <memory>\n#include <string>\n\nnamespace websocketpp {\n    namespace transport {\n        namespace asio {\n            namespace socket {\n                template<typename T>\n                struct socket_traits;\n            }\n        }\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass WebSocketServer {\npublic:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE,\n        MOZILLA_MODERN\n    };\n\nprivate:\n    server m_server;\n    std::string m_password;\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto& ctx = m_server.get_con_from_hdl(hdl);\n        ctx.set(\"HTTP/1.1\", \"200 OK\");\n        ctx.set(\"Content-Type\", \"text/plain\");\n        ctx.set(\"Content-Length\", \"12\");\n        ctx.write(\"Hello World!\");\n    }\n\n    std::string get_password() {\n        return m_password;\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        boost::asio::ssl::context::method method = boost::asio::ssl::context::sslv23;\n        boost::asio::ssl::context::options options = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols protocols = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            protocols &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            protocols &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options2 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols2 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols2 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols2 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options3 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols3 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols3 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols3 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options4 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols4 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols4 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols4 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options5 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols5 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols5 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols5 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options6 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols6 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols6 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols6 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options7 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols7 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols7 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols7 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options8 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols8 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols8 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols8 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options9 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols9 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols9 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols9 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options10 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols10 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols10 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols10 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options11 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols11 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols11 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols11 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options12 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols12 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols12 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols12 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options13 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols13 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols13 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols13 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options14 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols14 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols14 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols14 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options15 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols15 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols15 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols15 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options16 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols16 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols16 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols16 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options17 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols17 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols17 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols17 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options18 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols18 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols18 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols18 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options19 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols19 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols19 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols19 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options20 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols20 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols20 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols20 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options21 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols21 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols21 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols21 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options22 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols22 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols22 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols22 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options23 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols23 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols23 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols23 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options24 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols24 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols24 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols24 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options25 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols25 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols25 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols25 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options26 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols26 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols26 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols26 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options27 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols27 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols27 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols27 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options28 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols28 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols28 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols28 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options29 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols29 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols29 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols29 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options30 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols30 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols30 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols30 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options31 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols31 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols31 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols31 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options32 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols32 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols32 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols32 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options33 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols33 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols33 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols33 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options34 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols34 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols34 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols34 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options35 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols35 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols35 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols35 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options36 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols36 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols36 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols36 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options37 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols37 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols37 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols37 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options38 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols38 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols38 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols38 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options39 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols39 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols39 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols39 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options40 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols40 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols40 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols40 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options41 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols41 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols41 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols41 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options42 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols42 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols42 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols42 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options43 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols43 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols43 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols43 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options44 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols44 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols44 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols44 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options45 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols45 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols45 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols45 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options46 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols46 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols46 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols46 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options47 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols47 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols47 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols47 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options48 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols48 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols48 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if (mode == MOZILLA_MODERN) {\n            ssl_protocols48 &= boost::asio::ssl::context::protocols::tlsv1_3;\n        }\n\n        boost::asio::ssl::context::options ssl_options49 = boost::asio::ssl::context::default_workarounds\n            | boost::asio::ssl::context::no_sslv2\n            | boost::asio::ssl::context::no_sslv3;\n\n        boost::asio::ssl::context::protocols ssl_protocols49 = boost::asio::ssl::context::default_protocols;\n        if (mode == MOZILLA_INTERMEDIATE) {\n            ssl_protocols49 &= boost::asio::ssl::context::protocols::tlsv1_2;\n        } else if",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n#include <memory>\n\nnamespace websocketpp {\n    namespace transport {\n        namespace asio {\n            namespace ssl_socket {\n                template<typename T>\n                struct socket;\n            }\n        }\n    }\n}\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server() {\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto resp = m_server.http_response(hdl);\n        resp->set_status(http::status::ok);\n        resp->set_header(\"Content-Type\", \"text/plain\");\n        resp->set_body(\"Hello World!\");\n        m_server.reply(hdl, resp);\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->load_verify_file(\"ca.crt\");\n            ctx->set_verify_mode(boost::asio::ssl::context::verify_peer);\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::no_tlsv1 |\n                             boost::asio::ssl::context::no_tlsv1_1 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->load_verify_file(\"ca.crt\");\n            ctx->set_verify_mode(boost::asio::ssl::context::verify_peer);\n        }\n        return ctx;\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/http.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <string>\n#include <memory>\n\nnamespace websocket = websocketpp;\nnamespace asio = boost::asio;\nnamespace ssl = boost::beast::ssl;\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server() {\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        try {\n            asio::io_context io;\n            m_server.init_asio();\n            m_server.listen(port);\n            m_server.start_accept();\n            m_server.run();\n        } catch (std::exception const& e) {\n            std::cerr << \"Exception: \" << e.what() << \"\\n\";\n        }\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), websocketpp::frame::opcode::text);\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto& connection = m_server.get_con_from_hdl(hdl);\n        connection.http().response.status = 200;\n        connection.http().response.set(http::field::content_type, \"text/plain\");\n        connection.http().response.body = \"Hello World!\";\n        connection.close(websocketpp::close::status::normal, \"Closing\");\n    }\n\n    std::string get_password() {\n        return \"securepassword123\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<ssl::context>(ssl::context::sslv23);\n        std::string password = get_password();\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx->set_options(ssl::context::default_verify_paths | ssl::context::verify_fail_if_no_peer_cert);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", ssl::context::pem);\n            ctx->set_password_callback([password](const char* /*arg*/, int /*len*/, int /*ver*/){ return password; });\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx->set_options(ssl::context::default_verify_paths | ssl::context::verify_fail_if_no_peer_cert);\n            ctx->use_certificate_chain_file(\"modern_server.crt\");\n            ctx->use_private_key_file(\"modern_server.key\", ssl::context::pem);\n            ctx->set_password_callback([password](const char* /*arg*/, int /*len*/, int /*ver*/){ return password; });\n        }\n        return ctx;\n    }\n\nprivate:\n    websocket::server<websocket::config::asio> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/json_parser.hpp>\n#include <string>\n#include <memory>\n\nnamespace websocketpp {\n    namespace transport {\n        namespace asio {\n            namespace ssl_socket {\n                typedef boost::asio::ssl::context context;\n            }\n        }\n    }\n}\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server() {\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(connection_hdl hdl) {\n        m_server.http_response(hdl).set_status(http_status::ok);\n        m_server.http_response(hdl).set_header(\"Content-Type\", \"text/plain\");\n        m_server.http_response(hdl).set_body(\"Hello World!\");\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths | boost::asio::ssl::context::verify_fail_if_no_peer_cert);\n            ctx->set_verify_mode(boost::asio::ssl::context::verify_peer);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths | boost::asio::ssl::context::verify_fail_if_no_peer_cert);\n            ctx->set_verify_mode(boost::asio::ssl::context::verify_peer);\n            ctx->use_certificate_chain_file(\"modern_server.crt\");\n            ctx->use_private_key_file(\"modern_server.key\", boost::asio::ssl::context::pem);\n        }\n        return ctx;\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio_ssl> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/json_parser.hpp>\n#include <string>\n#include <memory>\n\nnamespace websocketpp {\n    namespace transport {\n        namespace asio {\n            namespace ssl_socket {\n                template<typename T>\n                struct socket;\n            }\n        }\n    }\n}\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server() {\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        m_server.send(hdl, msg->get_string(), websocketpp::frame::opcode::text);\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto& connection = m_server.get_con_from_hdl(hdl);\n        connection.respond(200);\n        connection.write(\"HTTP/1.1 200 OK\\r\\nContent-Length: 12\\r\\n\\r\\nHello World!\");\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::beast::ssl::context>(boost::beast::ssl::context::tlsv12_client);\n        boost::property_tree::ptree pt;\n        boost::property_tree::read_json(\"tls_config.json\", pt);\n\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx->set_options(boost::beast::ssl::context::default_verify_paths | boost::beast::ssl::context::verify_fail_if_no_peer_cert);\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx->set_options(boost::beast::ssl::context::default_verify_paths | boost::beast::ssl::context::verify_fail_if_no_peer_cert | boost::beast::ssl::context::verify_hostname);\n        }\n\n        ctx->set_password_callback([this](boost::beast::ssl::context::password_purpose purpose) {\n            return get_password();\n        });\n\n        return ctx;\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/json_parser.hpp>\n#include <string>\n#include <memory>\n\nnamespace ws = websocketpp;\nnamespace beast = boost::beast;\nnamespace ssl = boost::beast::ssl;\nnamespace pt = boost::property_tree;\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server() {\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        try {\n            boost::asio::io_context io_context;\n            boost::asio::executor_work_guard<boost::asio::io_context::executor_type> work_guard(\n                boost::asio::make_work_guard(io_context)\n            );\n\n            // Set up TLS context\n            auto ctx = std::make_shared<ssl::context>(ssl::context::sslv23);\n            on_tls_init(tls_mode::MOZILLA_INTERMEDIATE, nullptr);\n            m_server.set_tls_context(ctx);\n\n            m_server.listen(port);\n            m_server.start_accept();\n            io_context.run();\n        } catch (std::exception const& e) {\n            std::cerr << \"Exception: \" << e.what() << \"\\n\";\n        }\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto& connection = m_server.get_con_from_hdl(hdl);\n        connection.response().set_status(websocketpp::http::status::ok);\n        connection.response().set_header(\"Content-Type\", \"text/plain\");\n        connection.response().set_body(\"Hello World!\");\n        connection.close(websocketpp::close::status::normal, \"Closing\");\n    }\n\n    std::string get_password() {\n        return \"securepassword123\";\n    }\n\n    void on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        auto& connection = m_server.get_con_from_hdl(hdl);\n        auto& ctx = connection.get_tls_context();\n        std::string cert_path = \"server.crt\";\n        std::string key_path = \"server.key\";\n\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx.set_options(ssl::context::default_verify_paths | ssl::context::verify_peer);\n            ctx.use_certificate_chain_file(cert_path);\n            ctx.use_private_key_file(key_path, ssl::context::pem);\n            ctx.set_verify_mode(ssl::context::verify_peer);\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx.set_options(ssl::context::default_verify_paths | ssl::context::verify_peer);\n            ctx.use_certificate_chain_file(cert_path);\n            ctx.use_private_key_file(key_path, ssl::context::pem);\n            ctx.set_verify_mode(ssl::context::verify_peer);\n        }\n    }\n\nprivate:\n    ws::server<ws::config::asio> m_server;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/http.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/asio/ssl/context.hpp>\n#include <string>\n#include <memory>\n\nnamespace websocketpp = boost::beast::websocket;\nnamespace http = boost::beast::http;\nnamespace ssl = boost::beast::ssl;\n\nenum class tls_mode {\n    MOZILLA_INTERMEDIATE,\n    MOZILLA_MODERN\n};\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server() {\n        m_server.set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_http_handler(std::bind(&WebSocketServer::on_http, this, std::placeholders::_1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), websocketpp::frame::opcode::text);\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        auto& con = m_server.get_con_from_hdl(hdl);\n        http::request<http::string_body> req = con.get_request();\n        http::response<http::string_body> res{http::status::ok, 11};\n        res.set(http::field::server, \"Boost.Beast\");\n        res.set(http::field::content_type, \"text/plain\");\n        res.body() = \"Hello World!\";\n        res.prepare_payload();\n        con.reply(res);\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        if (mode == tls_mode::MOZILLA_INTERMEDIATE) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dhparams.pem\");\n        } else if (mode == tls_mode::MOZILLA_MODERN) {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::single_dh_use |\n                             boost::asio::ssl::context::no_compresseed_length);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dhparams.pem\");\n        }\n        return ctx;\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_server;\n};"
    ],
    "match_count": 2,
    "pass@3": 0.5333333333333333,
    "pass@5": 0.7777777777777778
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Implement a WebSocket broadcast server in C++ using the WebSocket++ library that can handle multiple client connections, manage subscriptions, and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and can broadcast messages to all connected clients. It handles connection events (open/close) and message events using a thread-safe action queue system.\n\nAttributes:\n- m_server: [server] - WebSocket++ server instance configured with ASIO\n- m_connections: [con_list] - Set of active WebSocket connection handles\n- m_actions: [std::queue<action>] - Queue of pending actions to process\n- m_action_lock: [mutex] - Mutex for protecting access to the action queue\n- m_connection_lock: [mutex] - Mutex for protecting access to the connections set\n- m_action_cond: [condition_variable] - Condition variable for action queue notification\n\nMethods:\n- broadcast_server() -> [constructor] - Initializes the WebSocket server and sets up event handlers\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_open(connection_hdl hdl) -> [void] - Handler for new WebSocket connections (adds SUBSCRIBE action)\n- on_close(connection_hdl hdl) -> [void] - Handler for closed WebSocket connections (adds UNSUBSCRIBE action)\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handler for incoming messages (adds MESSAGE action)\n- process_messages() -> [void] - Processes actions from the queue (manages subscriptions and broadcasts messages)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/thread.hpp>\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\nusing websocketpp::lib::thread;\nusing websocketpp::lib::mutex;\nusing websocketpp::lib::lock_guard;\nusing websocketpp::lib::unique_lock;\nusing websocketpp::lib::condition_variable;\n\nenum action_type {\n    SUBSCRIBE,\n    UNSUBSCRIBE,\n    MESSAGE\n};\n\nstruct action {\n    action(action_type t, connection_hdl h) : type(t), hdl(h) {}\n    action(action_type t, connection_hdl h, server::message_ptr m)\n      : type(t), hdl(h), msg(m) {}\n\n    action_type type;\n    websocketpp::connection_hdl hdl;\n    server::message_ptr msg;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        try {\n            m_server.run();\n        } catch (const std::exception & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\n    void on_open(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(SUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(UNSUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(MESSAGE,hdl,msg));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while(1) {\n            unique_lock<mutex> lock(m_action_lock);\n            while(m_actions.empty()) {\n                m_action_cond.wait(lock);\n            }\n\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.type == SUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.type == UNSUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.type == MESSAGE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                con_list::iterator it;\n                for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n                    m_server.send(*it,a.msg);\n                }\n            }\n        }\n    }\n\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl> > con_list;\n    server m_server;\n    con_list m_connections;\n    std::queue<action> m_actions;\n    mutex m_action_lock;\n    mutex m_connection_lock;\n    condition_variable m_action_cond;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string payload;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        m_actions.push({action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        m_actions.push({action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push({action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.payload, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string data;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.data, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string data;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.data, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string data;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        m_actions.push({action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        m_actions.push({action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push({action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.data, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string data;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        m_actions.push({action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        m_actions.push({action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push({action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.data, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::function<void(connection_hdl)> action;\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        m_actions.push(action([hdl]() { \n            std::lock_guard<std::mutex> lock(m_connection_lock);\n            m_connections.insert(hdl); \n        }));\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        m_actions.push(action([hdl]() { \n            std::lock_guard<std::mutex> lock(m_connection_lock);\n            m_connections.erase(hdl); \n        }));\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push(action([hdl, msg]() { \n            std::lock_guard<std::mutex> lock(m_connection_lock);\n            for (auto& conn : m_connections) {\n                m_server.send(conn, msg->get_payload(), msg->get_opcode());\n            }\n        }));\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            if (m_actions.empty()) continue;\n            action act = m_actions.front();\n            m_actions.pop();\n            act(m_connections.begin());\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string data;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.data, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string data;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.data, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string data;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.data, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <memory>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\ntypedef std::shared_ptr<server> server_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE } t;\n    connection_hdl hdl;\n    std::string payload;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.insert(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connection_lock);\n        m_connections.erase(hdl);\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        std::lock_guard<std::mutex> action_lock(m_action_lock);\n        m_actions.push(action{action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.t == action::SUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.t == action::UNSUBSCRIBE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.t == action::MESSAGE) {\n                std::lock_guard<std::mutex> lock(m_connection_lock);\n                for (auto& conn : m_connections) {\n                    m_server.send(conn, a.payload, websocketpp::frame::opcode::text);\n                }\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a C++ class that provides HTTP request functionality using libcurl, supporting both file and network resource retrieval.\n\nClass Description: HttpWebRequest is a class that encapsulates HTTP request functionality, allowing users to make GET requests to either network resources (via HTTP) or local files (via file:// protocol). It handles request configuration, execution, and response processing.\n\nAttributes:\n- uri_: std::string - The target URI for the HTTP request\n- method_: std::string - The HTTP method to use (defaults to GET)\n- header_: std::map<std::string, std::string> - HTTP headers to include in the request\n- is_: std::iostream - Internal stream used for request processing\n\nMethods:\n- HttpWebRequest(std::string &uri) -> void - Constructor that initializes the request with a target URI\n- callback(void *buffer, size_t size, size_t nmemb, void *data) -> static size_t - Static callback function for libcurl to write response data\n- GetFileResponse(const char *uri) -> HttpWebResponse* - Handles file:// protocol requests and returns the file content as a response\n- GetNetResponse(const char *uri) -> HttpWebResponse* - Performs HTTP network requests using libcurl and returns the response\n- GetResponse() -> HttpWebResponse* - Main method that determines request type (file or network) and returns the appropriate response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <fstream>\n\nnamespace System {\nnamespace Net {\n\nclass HttpWebRequest {\npublic:\n    HttpWebRequest(std::string &uri)\n        : is_(std::ios_base::in | std::ios_base::out | std::ios_base::binary) {\n        uri_ = uri;\n        method_ = HttpWebRequest::Method::GET;\n    }\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        HttpWebResponse *resp = (HttpWebResponse *) data;\n        std::stringstream &ss = resp->GetResponseStream();\n        ss.write((char *) buffer, size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse *GetFileResponse(const char *uri) {\n        assert(strlen(uri) > 6);\n        HttpWebResponse *resp = new HttpWebResponse();\n        const char *filename = uri + 6;\n\n        std::ifstream file;\n        file.open(filename);\n        if (file.is_open()) {\n            resp->os_ << file.rdbuf();\n            file.close();\n        }\n\n        return resp;\n    }\n\n    HttpWebResponse *GetNetResponse(const char *uri) {\n        HttpWebResponse *resp = new HttpWebResponse();\n\n        CURL *curl = curl_easy_init();\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n\n        curl_slist *http_headers = NULL;\n        for (std::map<std::string, std::string>::iterator it = header_.begin();\n             it != header_.end(); it++) {\n            http_headers = curl_slist_append(http_headers,\n                                             (it->first + \":\" + it->second).c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, http_headers);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) resp);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 2);\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 2);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\n        curl_easy_perform(curl);\n\n        long retcode = 0;\n        CURLcode code = curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &retcode);\n        if (code == CURLE_OK && retcode == 200) {\n            resp->status_.SetCode(200);\n\n            char *ctype = NULL;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &ctype);\n            std::string type(ctype);\n            resp->header_.Put(HttpHeader::ContentType, type);\n\n            double length = 0;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &length);\n            std::ostringstream os;\n            os << (long) length;\n            resp->header_.Put(HttpHeader::ContentLength, os.str());\n        }\n\n        curl_slist_free_all(http_headers);\n        curl_easy_cleanup(curl);\n\n        return resp;\n    }\n\n    HttpWebResponse *GetResponse() {\n        const char *uri = uri_.c_str();\n        if (strncmp(uri, \"file://\", 7) == 0) {\n            return GetFileResponse(uri);\n        }\n        return GetNetResponse(uri);\n    }\n\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n};\n\n}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int status_code;\n    HttpWebResponse() : status_code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::ifstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        HttpWebResponse* response = static_cast<HttpWebResponse*>(data);\n        response->content.append(static_cast<char*>(buffer), static_cast<char*>(buffer) + realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::ifstream file(uri, std::ios::binary | std::ios::ate);\n        if (!file) {\n            delete response;\n            return nullptr;\n        }\n        response->content = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        response->status_code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            delete response;\n            return nullptr;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            delete response;\n            return nullptr;\n        }\n\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n        response->status_code = static_cast<int>(http_code);\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int status_code;\n    HttpWebResponse() : status_code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::ifstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        HttpWebResponse* response = static_cast<HttpWebResponse*>(data);\n        response->content.append(static_cast<char*>(buffer), static_cast<char*>(buffer) + realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::ifstream file(uri, std::ios::binary | std::ios::ate);\n        if (!file) {\n            delete response;\n            return nullptr;\n        }\n        response->content = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        response->status_code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            delete response;\n            return nullptr;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_HTTPGET, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            delete response;\n            return nullptr;\n        }\n\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n        response->status_code = static_cast<int>(http_code);\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.find(\"file://\") == 0) {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n#include <sstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int status_code;\n    HttpWebResponse() : status_code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::istringstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        std::string *response = static_cast<std::string*>(data);\n        response->append(static_cast<char*>(buffer), realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        std::ifstream file(uri);\n        if (!file.is_open()) {\n            return nullptr;\n        }\n        std::ostringstream oss;\n        oss << file.rdbuf();\n        HttpWebResponse* response = new HttpWebResponse();\n        response->content = oss.str();\n        response->status_code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl;\n        CURLcode res;\n        std::string response_str;\n        curl = curl_easy_init();\n        if (curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, uri);\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_str);\n            res = curl_easy_perform(curl);\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response->status_code);\n            curl_easy_cleanup(curl);\n        }\n        HttpWebResponse* response = new HttpWebResponse();\n        response->content = response_str;\n        response->status_code = res == CURLE_OK ? 200 : 500;\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.find(\"file://\") == 0) {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n#include <sstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int status_code;\n    HttpWebResponse() : status_code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::istringstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        std::string *response = static_cast<std::string*>(data);\n        response->append(static_cast<char*>(buffer), realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        std::ifstream file(uri);\n        if (!file.is_open()) {\n            return nullptr;\n        }\n        std::ostringstream oss;\n        oss << file.rdbuf();\n        HttpWebResponse* response = new HttpWebResponse();\n        response->content = oss.str();\n        response->status_code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl;\n        CURLcode res;\n        std::string response_str;\n        curl = curl_easy_init();\n        if (curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, uri);\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_str);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n            res = curl_easy_perform(curl);\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response->status_code);\n            curl_easy_cleanup(curl);\n        }\n        HttpWebResponse* response = new HttpWebResponse();\n        response->content = response_str;\n        response->status_code = res == CURLE_OK ? 200 : 500;\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.find(\"file://\") == 0) {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n#include <sstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int code;\n    HttpWebResponse() : code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::ifstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        HttpWebResponse* response = static_cast<HttpWebResponse*>(data);\n        response->content.append(static_cast<char*>(buffer), static_cast<char*>(buffer) + realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::string file_uri(uri);\n        if (file_uri.substr(0, 7) == \"file://\") {\n            file_uri.erase(0, 7);\n        }\n        is_.open(file_uri.c_str(), std::ios::binary | std::ios::ate);\n        if (!is_) {\n            delete response;\n            return nullptr;\n        }\n        response->content.assign(is_.rdbuf(), is_.rdbuf() + is_.tellg());\n        is_.close();\n        response->code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            delete response;\n            return nullptr;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_HTTPGET, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            delete response;\n            curl_easy_cleanup(curl);\n            return nullptr;\n        }\n\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response->code);\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n#include <sstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int code;\n    HttpWebResponse() : code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::ifstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        HttpWebResponse* response = static_cast<HttpWebResponse*>(data);\n        size_t realsize = size * nmemb;\n        response->content.append(static_cast<char*>(buffer), realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::ifstream file(uri, std::ios::binary | std::ios::ate);\n        if (!file) {\n            delete response;\n            return nullptr;\n        }\n        response->content = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        response->code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            delete response;\n            return nullptr;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_HTTPGET, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            delete response;\n            return nullptr;\n        }\n\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n        response->code = static_cast<int>(http_code);\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int status_code;\n    HttpWebResponse() : status_code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::ifstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        HttpWebResponse* response = static_cast<HttpWebResponse*>(data);\n        response->content.append(static_cast<char*>(buffer), static_cast<char*>(buffer) + realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::ifstream file(uri, std::ios::binary | std::ios::ate);\n        if (!file) {\n            delete response;\n            return nullptr;\n        }\n        response->content = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        response->status_code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            delete response;\n            return nullptr;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_HTTPGET, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            delete response;\n            return nullptr;\n        }\n\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n        response->status_code = static_cast<int>(http_code);\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int status_code;\n    HttpWebResponse() : status_code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::ifstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        HttpWebResponse* response = static_cast<HttpWebResponse*>(data);\n        response->content.append(static_cast<char*>(buffer), static_cast<char*>(buffer) + realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::ifstream file(uri, std::ios::binary | std::ios::ate);\n        if (!file) {\n            delete response;\n            return nullptr;\n        }\n        response->content = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        response->status_code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            delete response;\n            return nullptr;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_HTTPGET, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            delete response;\n            return nullptr;\n        }\n\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n        response->status_code = static_cast<int>(http_code);\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.substr(0, 7) == \"file://\") {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int code;\n    HttpWebResponse() : code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::ifstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        HttpWebResponse* response = static_cast<HttpWebResponse*>(data);\n        response->content.append(static_cast<char*>(buffer), static_cast<char*>(buffer) + realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        std::ifstream file(uri, std::ios::binary | std::ios::ate);\n        if (!file) {\n            delete response;\n            return nullptr;\n        }\n        response->content = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n        response->code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        HttpWebResponse* response = new HttpWebResponse();\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            delete response;\n            return nullptr;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            delete response;\n            return nullptr;\n        }\n\n        long http_code = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);\n        response->code = static_cast<int>(http_code);\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.find(\"file://\") == 0) {\n            return GetFileResponse(uri_.c_str() + 7);\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};",
      "#include <iostream>\n#include <string>\n#include <map>\n#include <curl/curl.h>\n#include <fstream>\n#include <sstream>\n\nclass HttpWebResponse {\npublic:\n    std::string content;\n    int status_code;\n    HttpWebResponse() : status_code(0) {}\n};\n\nclass HttpWebRequest {\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::istringstream is_;\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        size_t realsize = size * nmemb;\n        std::string *response = static_cast<std::string*>(data);\n        response->append(static_cast<char*>(buffer), realsize);\n        return realsize;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        std::ifstream file(uri);\n        if (!file.is_open()) {\n            return nullptr;\n        }\n        std::ostringstream oss;\n        oss << file.rdbuf();\n        HttpWebResponse* response = new HttpWebResponse();\n        response->content = oss.str();\n        response->status_code = 200;\n        return response;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        CURL *curl;\n        CURLcode res;\n        std::string response_str;\n        curl = curl_easy_init();\n        if (curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, uri);\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, callback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_str);\n            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n            res = curl_easy_perform(curl);\n            curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response->status_code);\n            curl_easy_cleanup(curl);\n        }\n        HttpWebResponse* response = new HttpWebResponse();\n        response->content = response_str;\n        response->status_code = res == CURLE_OK ? 200 : 500;\n        return response;\n    }\n\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {}\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.find(\"file://\") == 0) {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ that supports both plain and TLS (SSL) connections using the WebSocket++ library. The server should handle incoming messages, echo them back to clients, and manage secure connections with proper TLS initialization.\n\nClass Description: The WebSocketServer class encapsulates functionality for creating and managing both plain and TLS WebSocket servers. It initializes server endpoints, sets up message handlers, manages TLS contexts, and runs the server's event loop.\n\nAttributes:\n- ios_: boost::asio::io_service - ASIO I/O service for handling network operations\n- endpoint_plain_: server_plain - WebSocket++ server instance for plain (non-secure) connections\n- endpoint_tls_: server_tls - WebSocket++ server instance for TLS (secure) connections\n\nMethods:\n- init() -> void - Initializes both plain and TLS server endpoints, sets message handlers, TLS initialization handler, and starts listening on ports 80 (plain) and 443 (TLS)\n- run() -> void - Starts the server's event loop to handle connections and messages\n- on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) -> void - Template method that handles incoming messages from clients and echoes them back\n- get_password() -> std::string - Returns the password used for TLS private key encryption\n- on_tls_init(websocketpp::connection_hdl hdl) -> context_ptr - Initializes and configures the TLS context for secure connections",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(), endpoint_tls_() {}\n\n    void init() {\n        endpoint_plain_.init_asio(&ios_);\n        endpoint_plain_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, ::_1, ::_2));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.init_asio(&ios_);\n        endpoint_tls_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, ::_1, ::_2));\n        endpoint_tls_.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, ::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\nprivate:\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl,\n        typename EndpointType::message_ptr msg)\n    {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                << \" and message: \" << msg->get_payload()\n                << std::endl;\n\n        try {\n            s->send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                    << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        std::cout << \"on_tls_init called with hdl: \" << hdl.lock().get() << std::endl;\n        context_ptr ctx(new boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                            boost::asio::ssl::context::no_sslv2 |\n                            boost::asio::ssl::context::no_sslv3 |\n                            boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "matched_results": [],
    "unmatched_results": [
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\nnamespace websocketpp {\n    namespace server {\n        template <typename Config>\n        class endpoint;\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::ssl::context::pointer on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<websocketpp::ssl::context>(websocketpp::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths | boost::asio::ssl::context::verify_fail_if_no_peer_cert);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->load_verify_file(\"ca.crt\");\n            ctx->set_verify_mode(boost::asio::ssl::context::verify_peer);\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n\n    WebSocketServer() : endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template<typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::lib::shared_ptr<boost::asio::ssl::context> on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dhparams.pem\");\n        } catch (const boost::system::error_code& e) {\n            // Handle error\n        }\n        return ctx;\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\nnamespace websocketpp {\n    namespace server {\n        template <typename Config>\n        class endpoint;\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::lib::shared_ptr<boost::asio::ssl::context> on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback(std::bind(&WebSocketServer::get_password, this));\n        } catch (const std::exception& e) {\n            // Handle error\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n\n    WebSocketServer() : endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain server setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS server setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::lib::shared_ptr<boost::asio::ssl::context> on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::no_sslv3 |\n                             boost::asio::ssl::context::single_dh_use);\n\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dhparams.pem\");\n\n            std::string password = get_password();\n            ctx->set_password_callback(\n                [password](boost::asio::ssl::context::password_verification& callback) {\n                    callback.password(password.c_str(), password.size());\n                }\n            );\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\nnamespace websocketpp {\n    namespace server {\n        template <typename Config>\n        class endpoint;\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    websocketpp::ssl::context::pointer on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<websocketpp::ssl::context>(websocketpp::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths | boost::asio::ssl::context::verify_fail_if_no_peer_cert);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->load_verify_file(\"ca.crt\");\n            ctx->set_verify_mode(boost::asio::ssl::context::verify_peer);\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\nnamespace websocketpp {\n    namespace server {\n        template <typename Config>\n        class endpoint;\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::ssl::context::pointer on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<websocketpp::ssl::context>(websocketpp::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths | boost::asio::ssl::context::verify_none);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback(std::bind(&WebSocketServer::get_password, this));\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\nnamespace websocketpp {\n    namespace server {\n        template <typename Config>\n        class endpoint;\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::ssl::context::pointer on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<websocketpp::ssl::context>(websocketpp::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths | boost::asio::ssl::context::verify_fail_if_no_peer_cert);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback(std::bind(&WebSocketServer::get_password, this));\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\nnamespace websocketpp {\n    namespace server {\n        template <typename Config>\n        class endpoint;\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::ssl::context::pointer on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<websocketpp::ssl::context>(websocketpp::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback(std::bind(&WebSocketServer::get_password, this));\n        } catch (const std::exception& e) {\n            std::cerr << \"Error initializing TLS context: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\nnamespace websocketpp {\n    namespace server {\n        template <typename Config>\n        class endpoint;\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::ssl::context::pointer on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<websocketpp::ssl::context>(websocketpp::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_verify_paths | boost::asio::ssl::context::verify_fail_if_no_peer_cert);\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->set_password_callback(std::bind(&WebSocketServer::get_password, this));\n        } catch (const std::exception& e) {\n            std::cerr << \"TLS initialization error: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n};",
      "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/config/asio_ssl.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/asio/ssl.hpp>\n#include <string>\n\nnamespace websocketpp {\n    namespace server {\n        template <typename Config>\n        class endpoint;\n    }\n}\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_ssl> server_tls;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(ios_), endpoint_tls_(ios_) {}\n\n    void init() {\n        // Plain WebSocket setup\n        endpoint_plain_.set_message_handler(std::bind(&WebSocketServer::on_message<server_plain>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        // TLS WebSocket setup\n        endpoint_tls_.set_message_handler(std::bind(&WebSocketServer::on_message<server_tls>, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        endpoint_tls_.set_tls_init_handler(std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"your_secure_password\";\n    }\n\n    websocketpp::ssl::context::pointer on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                             boost::asio::ssl::context::no_sslv2 |\n                             boost::asio::ssl::context::single_dh_use);\n            ctx->use_certificate_chain_file(\"server.crt\");\n            ctx->use_private_key_file(\"server.key\", boost::asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dhparams.pem\");\n        } catch (const boost::system::error_code& e) {\n            // Handle error\n        }\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Implement a function that demonstrates inter-process communication between a parent and child process using pipes in C++. The function should create a pipe, fork a child process, and have the parent process write data to the pipe while the child process reads and displays the data.\n\nFunction Description: The function `pipe_communication` sets up a pipe for communication between a parent and child process. The parent process writes a string to the pipe, and the child process reads and prints the data. The function handles pipe creation, process forking, and proper cleanup of file descriptors.\n\nInput: None\n\nOutput: None (The function prints messages to stdout indicating the progress and results of the pipe communication:\n- \"pipe create error\" if pipe creation fails\n- \"Read data from the pipe is [data]\" from the child process\n- \"Write data [data]\" and \"Parent write over\" from the parent process\n- \"parent close fd[1] over\" when parent completes cleanup)",
    "Canonical_solution": "#include <unistd.h>\n#include <stdio.h>\n#include <cstring>\n#include <cstdlib>\n\nvoid pipe_communication() {\n    int pipe_fd[2];\n    pid_t pid;\n\n    char r_buf[4];\n    char w_buf[100];\n    memset(r_buf,0,sizeof(r_buf));\n    memset(w_buf,0,sizeof(w_buf));\n    int r_num;\n\n    if(pipe(pipe_fd)<0) {\n        printf(\"pipe create error\\n\");\n        return;\n    }\n\n    if((pid=fork())==0) {\n        printf(\"\\n\");\n        close(pipe_fd[1]);\n        sleep(5);\n        while((r_num=read(pipe_fd[0],r_buf,4))!=0)\n            printf(\"Read data from the pipe is %s\\n\", r_buf);\n\n        close(pipe_fd[0]);\n        exit(0);\n    }\n    else if(pid>0) {\n        close(pipe_fd[0]);\n        const char* content = \"1111222233334444\";\n        strncpy(w_buf, content, strlen(content));\n        if(write(pipe_fd[1],w_buf, strlen(content))!=-1) {\n            printf(\"Write data %s\\n\", w_buf);\n            printf(\"Parent write over\\n\");\n        }\n        close(pipe_fd[1]);\n        printf(\"parent close fd[1] over\\n\");\n        wait(&pid);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 155,
    "matched_results": [
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"Fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    } else if (pid == 0) {\n        // Child process\n        close(pipefd[1]); // Close write end\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << std::string(buffer) << std::endl;\n        }\n        close(pipefd[0]);\n    } else {\n        // Parent process\n        close(pipefd[0]); // Close read end\n        const char* message = \"Hello from parent\";\n        ssize_t bytes_written = write(pipefd[1], message, strlen(message));\n        if (bytes_written == -1) {\n            std::cerr << \"Write error\" << std::endl;\n        } else {\n            std::cout << \"Write data [\" << std::string(message) << \"]\" << std::endl;\n        }\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr);\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"Fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    } else if (pid > 0) {\n        // Parent process\n        close(pipefd[0]); // Close unused read end\n        const char* message = \"Hello from parent\";\n        write(pipefd[1], message, strlen(message) + 1);\n        std::cout << \"Write data \" << message << std::endl;\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n        wait(nullptr);\n    } else {\n        // Child process\n        close(pipefd[1]); // Close unused write end\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        }\n        close(pipefd[0]);\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <cstdlib>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Close write end\n        char buffer[100];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << std::string(buffer) << std::endl;\n        }\n        close(pipefd[0]);\n        exit(0);\n    } else { // Parent process\n        close(pipefd[0]); // Close read end\n        const char* message = \"Hello from parent\";\n        ssize_t bytes_written = write(pipefd[1], message, strlen(message));\n        if (bytes_written == -1) {\n            std::cerr << \"Write error\" << std::endl;\n        } else {\n            std::cout << \"Write data [\" << std::string(message) << \"]\" << std::endl;\n        }\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"Fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    } else if (pid > 0) {\n        // Parent process\n        close(pipefd[0]); // Close unused read end\n        const char* message = \"Hello from parent\";\n        write(pipefd[1], message, strlen(message) + 1);\n        std::cout << \"Write data \" << message << std::endl;\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n        wait(nullptr);\n    } else {\n        // Child process\n        close(pipefd[1]); // Close unused write end\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        }\n        close(pipefd[0]);\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <cstdlib>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    } else if (pid > 0) {\n        // Parent process\n        close(pipefd[0]); // Close unused read end\n        const char* message = \"Hello from parent\";\n        write(pipefd[1], message, strlen(message) + 1);\n        std::cout << \"Write data \" << message << std::endl;\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    } else {\n        // Child process\n        close(pipefd[1]); // Close unused write end\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        }\n        close(pipefd[0]);\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"Fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    } else if (pid == 0) {\n        close(pipefd[1]); // Child doesn't need to write\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << std::string(buffer) << std::endl;\n        }\n        close(pipefd[0]);\n    } else {\n        close(pipefd[0]); // Parent doesn't need to read\n        const char* message = \"Hello from parent\";\n        ssize_t bytes_written = write(pipefd[1], message, strlen(message));\n        if (bytes_written == -1) {\n            std::cerr << \"Write error\" << std::endl;\n        } else {\n            std::cout << \"Write data \" << std::string(message) << std::endl;\n        }\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr);\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"Fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    } else if (pid > 0) {\n        // Parent process\n        close(pipefd[0]); // Close unused read end\n        const char* message = \"Hello from parent\";\n        write(pipefd[1], message, strlen(message) + 1);\n        std::cout << \"Write data \" << message << std::endl;\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        std::cout << \"parent close fd[1] over\" << std::endl;\n        wait(nullptr);\n    } else {\n        // Child process\n        close(pipefd[1]); // Close unused write end\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << buffer << std::endl;\n        }\n        close(pipefd[0]);\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"Fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Close write end\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << std::string(buffer) << std::endl;\n        }\n        close(pipefd[0]);\n        exit(0);\n    } else { // Parent process\n        close(pipefd[0]); // Close read end\n        const char* message = \"Hello from parent\";\n        ssize_t bytes_written = write(pipefd[1], message, strlen(message));\n        if (bytes_written == -1) {\n            std::cerr << \"Write error\" << std::endl;\n        } else {\n            std::cout << \"Write data \" << std::string(message) << std::endl;\n        }\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr);\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"Fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Close write end\n        char buffer[100];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << std::string(buffer) << std::endl;\n        }\n        close(pipefd[0]);\n        exit(0);\n    } else { // Parent process\n        close(pipefd[0]); // Close read end\n        const char* message = \"Hello from parent\";\n        ssize_t bytes_written = write(pipefd[1], message, strlen(message));\n        if (bytes_written == -1) {\n            std::cerr << \"Write error\" << std::endl;\n        } else {\n            std::cout << \"Write data \" << std::string(message) << std::endl;\n        }\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr);\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    }\n}",
      "#include <iostream>\n#include <unistd.h>\n#include <cstring>\n#include <sys/wait.h>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"Fork error\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Close write end\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << std::string(buffer) << std::endl;\n        }\n        close(pipefd[0]);\n        exit(0);\n    } else { // Parent process\n        close(pipefd[0]); // Close read end\n        const char* message = \"Hello from parent\";\n        ssize_t bytes_written = write(pipefd[1], message, strlen(message));\n        if (bytes_written == -1) {\n            std::cerr << \"Write error\" << std::endl;\n        } else {\n            std::cout << \"Write data \" << std::string(message) << std::endl;\n        }\n        close(pipefd[1]);\n        std::cout << \"Parent write over\" << std::endl;\n        wait(nullptr);\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Implement a multi-threaded HTTP download manager using libcurl in C++ that can handle multiple download tasks concurrently, avoid duplicate downloads, and manage resources efficiently.\n\nClass Description: The DownloadPool class manages a pool of worker threads that process download tasks. Each task downloads a file from a given URL and saves it to a specified output path. The class ensures thread safety and prevents duplicate downloads.\n\nAttributes:\n- m_threads: std::vector<std::thread> - Collection of worker threads\n- m_queue: std::queue<Task> - Queue of pending download tasks\n- m_urls: std::unordered_set<std::string> - Set of unique task identifiers to prevent duplicates\n- m_mtx: std::mutex - Mutex for thread synchronization\n- m_noMoreTask: bool - Flag indicating no more tasks will be added\n\nMethods:\n- DownloadPool() -> void - Constructor initializes libcurl and creates worker threads\n- ~DownloadPool() -> void - Destructor cleans up libcurl resources\n- addTask(const std::string& url, const std::string& output) -> void - Adds a new download task if not already present\n- setNoMoreTask() -> void - Signals that no more tasks will be added\n- finishAndWaitForExit() -> void - Waits for all threads to complete current tasks\n- run() -> void - Worker thread function that processes tasks from the queue\n\nTask Class Description: The Task class represents an individual download task with URL and output file path.\n\nAttributes:\n- m_url: std::string - URL to download from\n- m_output: std::string - Local file path to save to\n\nMethods:\n- run() -> void - Executes the download task using libcurl\n- writeData(void* buffer, size_t size, size_t nmemb) -> size_t - Callback function for writing received data to file",
    "Canonical_solution": "#include <curl/curl.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <queue>\n#include <unordered_set>\n\nclass Task\n{\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n    \n    void run()\n    {\n        std::ofstream output(m_output, std::fstream::in | std::fstream::out | std::fstream::trunc);\n        output.close();\n        \n        CURL *curl_handler = curl_easy_init();\n        curl_easy_setopt(curl_handler, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl_handler, CURLOPT_TIMEOUT, 60);\n        curl_easy_setopt(curl_handler, CURLOPT_WRITEFUNCTION, &Task::writeData);\n        curl_easy_setopt(curl_handler, CURLOPT_WRITEDATA, this);\n\n        curl_easy_perform(curl_handler);\n        \n        curl_easy_cleanup(curl_handler);\n    }\n\n    size_t writeData(void *buffer, size_t size, size_t nmemb)\n    {\n        std::ofstream file;\n        file.open(m_output, std::fstream::in | std::fstream::out | std::fstream::app | std::fstream::binary);\n        size_t bytesToWrite = size * nmemb;\n        file.write(reinterpret_cast<const char *>(buffer), bytesToWrite);\n        file.close();\n        \n        return bytesToWrite;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool\n{\npublic:\n    DownloadPool()\n    {\n        m_noMoreTask = false;\n        curl_global_init(CURL_GLOBAL_ALL);\n        \n        for (int idx = 0; idx < 4; idx++)\n        {\n            m_threads.push_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool()\n    {\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string &url, const std::string& output)\n    {\n        std::string uid = url + output;\n        bool existed = false;\n        Task task(url, output);\n        m_mtx.lock();\n        if (!(existed = (m_urls.find(uid) != m_urls.cend())))\n        {\n            m_urls.insert(uid);\n            m_queue.push(task);\n        }\n        m_mtx.unlock();\n    }\n\n    void setNoMoreTask()\n    {\n        m_mtx.lock();\n        m_noMoreTask = true;\n        m_mtx.unlock();\n    }\n\n    void finishAndWaitForExit()\n    {\n        setNoMoreTask();\n        for (auto& thread : m_threads)\n        {\n            thread.join();\n        }\n    }\n\nprivate:\n    void run()\n    {\n        while(true)\n        {\n            bool found = false;\n            Task task;\n            \n            m_mtx.lock();\n            if (!m_queue.empty())\n            {\n                task = m_queue.front();\n                m_queue.pop();\n                found = true;\n            }\n            bool noMoreTask = m_noMoreTask;\n            m_mtx.unlock();\n            \n            if (found)\n            {\n                task.run();\n                continue;\n            }\n            if (noMoreTask)\n            {\n                break;\n            }\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    bool m_noMoreTask;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "matched_results": [
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* file = fopen(m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open output file: \" << m_output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE* file = (FILE*)userp;\n        if (!file) return 0;\n\n        size_t written = fwrite(buffer, size, nmemb, file);\n        return written;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < 4; ++i) {\n            m_threads.emplace_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) != m_urls.end()) return;\n        m_urls.insert(url);\n        m_queue.push(Task{ url, output });\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            while (m_queue.empty() && !m_noMoreTask) {\n                m_cv.wait(lock);\n            }\n\n            if (m_noMoreTask && m_queue.empty()) break;\n\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run();\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp);\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool();\n    ~DownloadPool();\n    void addTask(const std::string& url, const std::string& output);\n    void setNoMoreTask();\n    void finishAndWaitForExit();\n    void run();\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    bool m_noMoreTask;\n};\n\nDownloadPool::DownloadPool() : m_noMoreTask(false) {\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    for (int i = 0; i < 4; ++i) {\n        m_threads.emplace_back(&DownloadPool::run, this);\n    }\n}\n\nDownloadPool::~DownloadPool() {\n    setNoMoreTask();\n    for (auto& thread : m_threads) {\n        if (thread.joinable()) {\n            thread.join();\n        }\n    }\n    curl_global_cleanup();\n}\n\nvoid DownloadPool::addTask(const std::string& url, const std::string& output) {\n    std::lock_guard<std::mutex> lock(m_mtx);\n    if (m_urls.find(url) == m_urls.end()) {\n        m_urls.insert(url);\n        Task task;\n        task.m_url = url;\n        task.m_output = output;\n        m_queue.push(task);\n    }\n}\n\nvoid DownloadPool::setNoMoreTask() {\n    std::lock_guard<std::mutex> lock(m_mtx);\n    m_noMoreTask = true;\n}\n\nvoid DownloadPool::finishAndWaitForExit() {\n    setNoMoreTask();\n    for (auto& thread : m_threads) {\n        if (thread.joinable()) {\n            thread.join();\n        }\n    }\n}\n\nvoid DownloadPool::run() {\n    CURL* curl;\n    CURLcode res;\n    while (true) {\n        std::unique_lock<std::mutex> lock(m_mtx);\n        while (m_queue.empty() && !m_noMoreTask) {\n            lock.unlock();\n            std::this_thread::yield();\n            lock.lock();\n        }\n        if (m_queue.empty() && m_noMoreTask) {\n            break;\n        }\n        Task task = m_queue.front();\n        m_queue.pop();\n        lock.unlock();\n\n        curl = curl_easy_init();\n        if (!curl) continue;\n\n        FILE* file = fopen(task.m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open file: \" << task.m_output << std::endl;\n            curl_easy_cleanup(curl);\n            continue;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, task.m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, Task::writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n}\n\nsize_t Task::writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n    FILE* file = static_cast<FILE*>(userp);\n    return fwrite(buffer, size, nmemb, file);\n}\n\nvoid Task::run() {\n    // Implementation not needed as it's handled in DownloadPool::run\n}",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run();\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp);\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool();\n    ~DownloadPool();\n    void addTask(const std::string& url, const std::string& output);\n    void setNoMoreTask();\n    void finishAndWaitForExit();\n    void run();\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    bool m_noMoreTask;\n};\n\nDownloadPool::DownloadPool() : m_noMoreTask(false) {\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    for (int i = 0; i < 4; ++i) {\n        m_threads.emplace_back(&DownloadPool::run, this);\n    }\n}\n\nDownloadPool::~DownloadPool() {\n    setNoMoreTask();\n    for (auto& thread : m_threads) {\n        if (thread.joinable()) {\n            thread.join();\n        }\n    }\n    curl_global_cleanup();\n}\n\nvoid DownloadPool::addTask(const std::string& url, const std::string& output) {\n    std::lock_guard<std::mutex> lock(m_mtx);\n    if (m_urls.find(url) == m_urls.end()) {\n        m_urls.insert(url);\n        Task task;\n        task.m_url = url;\n        task.m_output = output;\n        m_queue.push(task);\n    }\n}\n\nvoid DownloadPool::setNoMoreTask() {\n    std::lock_guard<std::mutex> lock(m_mtx);\n    m_noMoreTask = true;\n}\n\nvoid DownloadPool::finishAndWaitForExit() {\n    setNoMoreTask();\n    for (auto& thread : m_threads) {\n        if (thread.joinable()) {\n            thread.join();\n        }\n    }\n}\n\nvoid DownloadPool::run() {\n    CURL* curl;\n    CURLcode res;\n    while (true) {\n        std::unique_lock<std::mutex> lock(m_mtx);\n        while (m_queue.empty() && !m_noMoreTask) {\n            lock.unlock();\n            std::this_thread::yield();\n            lock.lock();\n        }\n        if (m_queue.empty() && m_noMoreTask) {\n            break;\n        }\n        Task task = m_queue.front();\n        m_queue.pop();\n        lock.unlock();\n\n        curl = curl_easy_init();\n        if (!curl) continue;\n\n        FILE* file = fopen(task.m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open file: \" << task.m_output << std::endl;\n            curl_easy_cleanup(curl);\n            continue;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, task.m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, Task::writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n}\n\nsize_t Task::writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n    FILE* file = static_cast<FILE*>(userp);\n    return fwrite(buffer, size, nmemb, file);\n}\n\nvoid Task::run() {\n    // Implementation would be here if needed\n}",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* file = fopen(m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open output file: \" << m_output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE* file = (FILE*)userp;\n        if (!file) return 0;\n        fwrite(buffer, size, nmemb, file);\n        return realsize;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < 4; ++i) {\n            m_threads.emplace_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) != m_urls.end()) return;\n        m_urls.insert(url);\n        m_queue.push(Task{url, output});\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            while (m_queue.empty() && !m_noMoreTask) {\n                m_cv.wait(lock);\n            }\n            if (m_noMoreTask && m_queue.empty()) break;\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* file = fopen(m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open output file: \" << m_output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE* file = (FILE*)userp;\n        if (!file) return 0;\n        fwrite(buffer, size, nmemb, file);\n        return realsize;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < 4; ++i) {\n            m_threads.emplace_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) != m_urls.end()) return;\n        m_urls.insert(url);\n        m_queue.push(Task{url, output});\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            while (m_queue.empty() && !m_noMoreTask) {\n                m_cv.wait(lock);\n            }\n            if (m_noMoreTask && m_queue.empty()) break;\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* file = fopen(m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open output file: \" << m_output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE* file = (FILE*)userp;\n        if (!file) return 0;\n\n        size_t n = fwrite(buffer, size, nmemb, file);\n        return n;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < 4; ++i) {\n            m_threads.emplace_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) != m_urls.end()) return;\n        m_urls.insert(url);\n        m_queue.push(Task{url, output});\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            while (m_queue.empty() && !m_noMoreTask) {\n                m_cond.wait(lock);\n            }\n\n            if (m_noMoreTask && m_queue.empty()) {\n                break;\n            }\n\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cond;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* file = fopen(m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open output file: \" << m_output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE* file = (FILE*)userp;\n        if (!file) return 0;\n        fwrite(buffer, size, nmemb, file);\n        return realsize;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < 4; ++i) {\n            m_threads.emplace_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) != m_urls.end()) return;\n        m_urls.insert(url);\n        m_queue.push(Task{ url, output });\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            while (m_queue.empty() && !m_noMoreTask) {\n                m_cv.wait(lock);\n            }\n            if (m_noMoreTask && m_queue.empty()) break;\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* file = fopen(m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open file: \" << m_output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE* file = (FILE*)userp;\n        if (!file) return 0;\n        fwrite(buffer, size, nmemb, file);\n        return realsize;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < 4; ++i) {\n            m_threads.emplace_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) != m_urls.end()) return;\n        m_urls.insert(url);\n        m_queue.push(Task{ url, output });\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            while (m_queue.empty() && !m_noMoreTask) {\n                m_cv.wait(lock);\n            }\n            if (m_noMoreTask && m_queue.empty()) break;\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* file = fopen(m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open output file: \" << m_output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE* file = (FILE*)userp;\n        if (!file) return 0;\n\n        fwrite(buffer, size, nmemb, file);\n        return realsize;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < 4; ++i) {\n            m_threads.emplace_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) != m_urls.end()) return;\n        m_urls.insert(url);\n        m_queue.push(Task{url, output});\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) thread.join();\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            while (m_queue.empty() && !m_noMoreTask) {\n                m_cv.wait(lock);\n            }\n            if (m_queue.empty() && m_noMoreTask) break;\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cv;\n    bool m_noMoreTask;\n};",
      "#include <iostream>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n#include <curl/curl.h>\n#include <fstream>\n#include <string>\n\nstruct Task {\n    std::string m_url;\n    std::string m_output;\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (!curl) return;\n\n        FILE* file = fopen(m_output.c_str(), \"wb\");\n        if (!file) {\n            std::cerr << \"Failed to open file: \" << m_output << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"Download failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(file);\n        curl_easy_cleanup(curl);\n    }\n\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        FILE* file = (FILE*)userp;\n        if (!file) return 0;\n\n        if (fwrite(buffer, size, nmemb, file) != nmemb) {\n            std::cerr << \"Write failed\" << std::endl;\n            return 0;\n        }\n\n        return realsize;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() : m_noMoreTask(false) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        for (int i = 0; i < 4; ++i) {\n            m_threads.emplace_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        finishAndWaitForExit();\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) != m_urls.end()) {\n            return;\n        }\n        m_urls.insert(url);\n        m_queue.push(Task{ url, output });\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_mtx);\n            while (m_queue.empty() && !m_noMoreTask) {\n                m_cond.wait(lock);\n            }\n\n            if (m_noMoreTask && m_queue.empty()) {\n                break;\n            }\n\n            Task task = m_queue.front();\n            m_queue.pop();\n            lock.unlock();\n\n            task.run();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    std::condition_variable m_cond;\n    bool m_noMoreTask;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a TCP client class using Boost.Asio that handles asynchronous communication with a chat server, including reading from standard input and writing to standard output.\n\nClass Description: The posix_chat_client class implements an asynchronous TCP client for a chat application. It manages socket connections, handles message reading/writing, and processes user input/output asynchronously using Boost.Asio.\n\nAttributes:\n- socket_: [tcp::socket] - The TCP socket for communication with the server\n- input_: [posix::stream_descriptor] - Handles asynchronous reading from standard input\n- output_: [posix::stream_descriptor] - Handles asynchronous writing to standard output\n- read_msg_: [chat_message] - Stores the message being read from the server\n- write_msg_: [chat_message] - Stores the message to be written to the server\n- input_buffer_: [boost::asio::streambuf] - Buffer for storing input data\n\nMethods:\n- Constructor: [posix_chat_client]([boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints]) -> [void] - Initializes the client with IO context and server endpoints\n- do_connect: [do_connect]([const tcp::resolver::results_type& endpoints]) -> [void] - Asynchronously connects to the server endpoints\n- do_read_header: [do_read_header]() -> [void] - Asynchronously reads the message header from the server\n- do_read_body: [do_read_body]() -> [void] - Asynchronously reads the message body from the server after header is processed\n- do_write_output: [do_write_output]() -> [void] - Asynchronously writes received messages to standard output\n- do_read_input: [do_read_input]() -> [void] - Asynchronously reads input from standard input\n- do_write_message: [do_write_message]() -> [void] - Asynchronously writes the composed message to the server\n- close: [close]() -> [void] - Closes all connections and cleans up resources",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\n#include \"chat_message.hpp\"\nusing boost::asio::ip::tcp;\nnamespace posix = boost::asio::posix;\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO)),\n      input_buffer_(chat_message::max_body_length)\n  {\n    do_connect(endpoints);\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    static char eol[] = { '\\n' };\n    std::array<boost::asio::const_buffer, 2> buffers = {{\n      boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n      boost::asio::buffer(eol) }};\n    boost::asio::async_write(output_, buffers,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            write_msg_.body_length(length - 1);\n            input_buffer_.sgetn(write_msg_.body(), length - 1);\n            input_buffer_.consume(1);\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else if (ec == boost::asio::error::not_found)\n          {\n            write_msg_.body_length(input_buffer_.size());\n            input_buffer_.sgetn(write_msg_.body(), input_buffer_.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  posix::stream_descriptor input_;\n  posix::stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    boost::array<char, header> header_;\n    boost::array<char, body> body_;\n    std::size_t length_;\n    chat_message() : length_(0) {}\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.header_, read_msg_.header_.size()),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec && read_msg_.header_[0] == 'C' && read_msg_.header_[1] == 'H') {\n                    read_msg_.length_ = *reinterpret_cast<std::size_t*>(read_msg_.header_.data() + 2);\n                    do_read_body();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.body_.data(), read_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::streambuf& buffer = input_buffer_;\n        std::ostream os(&buffer);\n        os << \"Received: \";\n        os.write(read_msg_.body_.data(), read_msg_.length_);\n        os << \"\\n\";\n        boost::asio::async_write(output_, buffer,\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    input_buffer_.consume(input_buffer_.size());\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, \"\\n\",\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    std::istream is(&input_buffer_);\n                    std::string line;\n                    std::getline(is, line);\n                    if (!line.empty()) {\n                        write_msg_.length_ = line.size();\n                        std::memcpy(write_msg_.body_.data(), line.data(), write_msg_.length_);\n                        do_write_message();\n                    }\n                    do_read_input();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.body_.data(), write_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    write_msg_.length_ = 0;\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    char data[header + body];\n    int length;\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.data, chat_message::header),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    read_msg_.length = *reinterpret_cast<int*>(read_msg_.data);\n                    do_read_body();\n                } else {\n                    std::cerr << \"Read header error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.data + chat_message::header, read_msg_.length),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    std::cerr << \"Read body error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::write(output_, boost::asio::buffer(read_msg_.data, read_msg_.length + chat_message::header),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_read_header();\n                } else {\n                    std::cerr << \"Write output error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, \"\\n\",\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    std::string input_line;\n                    std::istream is(&input_buffer_);\n                    std::getline(is, input_line);\n                    if (!input_line.empty()) {\n                        write_msg_.length = input_line.size();\n                        std::memcpy(write_msg_.data, input_line.c_str(), write_msg_.length);\n                        do_write_message();\n                    }\n                    do_read_input();\n                } else {\n                    std::cerr << \"Read input error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.data, write_msg_.length + chat_message::header),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_read_header();\n                } else {\n                    std::cerr << \"Write message error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    char data[header + body];\n    int length;\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.data, chat_message::header),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    read_msg_.length = *reinterpret_cast<int*>(read_msg_.data);\n                    do_read_body();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.data + chat_message::header, read_msg_.length),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::write(output_, boost::asio::buffer(read_msg_.data, read_msg_.length + chat_message::header));\n        do_read_header();\n    }\n\n    void do_read_input() {\n        input_.async_read_some(boost::asio::buffer(input_buffer_), [this](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n            if (!ec && bytes_transferred > 0) {\n                std::istream is(&input_buffer_);\n                std::string line;\n                std::getline(is, line);\n                if (!line.empty()) {\n                    write_msg_.length = static_cast<int>(line.size());\n                    std::memcpy(write_msg_.data, line.c_str(), line.size());\n                    do_write_message();\n                }\n                do_read_input();\n            } else {\n                close();\n            }\n        });\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.data, write_msg_.length + chat_message::header),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (ec) {\n                    close();\n                } else {\n                    do_read_header();\n                }\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    boost::array<char, header> header_;\n    boost::array<char, body> body_;\n    std::size_t length_;\n    chat_message() : length_(0) {}\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.header_, read_msg_.header_.size()),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    read_msg_.length_ = ntohs(*reinterpret_cast<const unsigned short*>(read_msg_.header_.data()));\n                    do_read_body();\n                } else {\n                    std::cerr << \"Read header error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.body_.data(), read_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    std::cerr << \"Read body error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::write(output_, boost::asio::buffer(read_msg_.body_.data(), read_msg_.length_));\n        do_read_header();\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, \"\\n\",\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    std::string input_line = boost::asio::buffer_cast<const char*>(input_buffer_.data());\n                    input_buffer_.consume(input_buffer_.size());\n                    if (!input_line.empty()) {\n                        write_msg_.length_ = static_cast<std::size_t>(input_line.size());\n                        std::memcpy(write_msg_.body_.data(), input_line.data(), write_msg_.length_);\n                        do_write_message();\n                    }\n                    do_read_input();\n                } else {\n                    std::cerr << \"Read input error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.body_.data(), write_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (ec) {\n                    std::cerr << \"Write message error: \" << ec.message() << std::endl;\n                }\n                do_read_header();\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    boost::array<char, header> header_;\n    boost::array<char, body> body_;\n    std::size_t length_;\n    chat_message() : length_(0) {}\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.header_, read_msg_.header_.size()),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    read_msg_.length_ = ntohs(*reinterpret_cast<const uint16_t*>(read_msg_.header_.data()));\n                    do_read_body();\n                } else {\n                    std::cerr << \"Read header error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.body_.data(), read_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    std::cerr << \"Read body error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::write(output_, boost::asio::buffer(read_msg_.body_.data(), read_msg_.length_));\n        do_read_header();\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, \"\\n\",\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    std::string input_line = boost::asio::buffer_cast<const char*>(input_buffer_.data());\n                    input_buffer_.consume(input_buffer_.size());\n                    if (!input_line.empty()) {\n                        write_msg_.length_ = static_cast<std::size_t>(input_line.size());\n                        std::memcpy(write_msg_.body_.data(), input_line.data(), write_msg_.length_);\n                        do_write_message();\n                    }\n                    do_read_input();\n                } else {\n                    std::cerr << \"Read input error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.body_.data(), write_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (ec) {\n                    std::cerr << \"Write message error: \" << ec.message() << std::endl;\n                }\n                do_read_header();\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { namespace ip { namespace tcp { typedef basic_socket<stream_protocol> socket; } } } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    char data[header + body];\n    int length;\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            boost::bind(&posix_chat_client::handle_connect, shared_from_this(),\n                boost::asio::placeholders::error));\n    }\n\n    void handle_connect(const boost::system::error_code& error) {\n        if (!error) {\n            do_read_header();\n        }\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, input_buffer_,\n            boost::asio::buffer(read_msg_.data, read_msg_.header),\n            boost::bind(&posix_chat_client::handle_read_header, shared_from_this(),\n                boost::asio::placeholders::error));\n    }\n\n    void handle_read_header(const boost::system::error_code& error) {\n        if (!error) {\n            read_msg_.length = *reinterpret_cast<int*>(read_msg_.data);\n            do_read_body();\n        }\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, input_buffer_,\n            boost::asio::buffer(read_msg_.data + read_msg_.header, read_msg_.length),\n            boost::bind(&posix_chat_client::handle_read_body, shared_from_this(),\n                boost::asio::placeholders::error));\n    }\n\n    void handle_read_body(const boost::system::error_code& error) {\n        if (!error) {\n            do_write_output();\n        }\n    }\n\n    void do_write_output() {\n        boost::asio::async_write(output_, boost::asio::buffer(read_msg_.data, read_msg_.length + read_msg_.header),\n            boost::bind(&posix_chat_client::handle_write_output, shared_from_this(),\n                boost::asio::placeholders::error));\n    }\n\n    void handle_write_output(const boost::system::error_code& error) {\n        if (!error) {\n            do_read_input();\n        }\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, \"\\n\",\n            boost::bind(&posix_chat_client::handle_read_input, shared_from_this(),\n                boost::asio::placeholders::error));\n    }\n\n    void handle_read_input(const boost::system::error_code& error) {\n        if (!error) {\n            std::string input;\n            std::istream is(&input_buffer_);\n            std::getline(is, input);\n            if (!input.empty()) {\n                write_msg_.length = input.length();\n                std::memcpy(write_msg_.data, input.c_str(), write_msg_.length);\n                do_write_message();\n            }\n            do_read_input();\n        }\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.data, write_msg_.length),\n            boost::bind(&posix_chat_client::handle_write_message, shared_from_this(),\n                boost::asio::placeholders::error));\n    }\n\n    void handle_write_message(const boost::system::error_code& error) {\n        if (!error) {\n            do_read_input();\n        }\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    boost::array<char, header> header_;\n    boost::array<char, body> body_;\n    std::size_t length_;\n    chat_message() : length_(0) {}\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.header_, read_msg_.header_.size()),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec && read_msg_.header_[0] == 'C' && read_msg_.header_[1] == 'H') {\n                    read_msg_.length_ = *reinterpret_cast<std::size_t*>(read_msg_.header_.data() + 2);\n                    do_read_body();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.body_, read_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::write(output_, boost::asio::buffer(read_msg_.body_, read_msg_.length_));\n        do_read_header();\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, \"\\n\",\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    std::istream is(&input_buffer_);\n                    std::string line;\n                    std::getline(is, line);\n                    if (!line.empty()) {\n                        write_msg_.length_ = line.size();\n                        std::memcpy(write_msg_.body_.data(), line.data(), write_msg_.length_);\n                        do_write_message();\n                    }\n                    do_read_input();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::write(socket_, boost::asio::buffer(write_msg_.body_, write_msg_.length_));\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    boost::array<char, header> header_;\n    boost::array<char, body> body_;\n    std::size_t length_;\n    chat_message() : length_(0) {}\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.header_, read_msg_.header_.size()),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    read_msg_.length_ = ntohs(*reinterpret_cast<const unsigned short*>(read_msg_.header_.data()));\n                    do_read_body();\n                } else {\n                    std::cerr << \"Read header error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.body_.data(), read_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    std::cerr << \"Read body error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::write(output_, boost::asio::buffer(read_msg_.body_.data(), read_msg_.length_));\n        do_read_header();\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, \"\\n\",\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    std::string input_line = boost::asio::buffer_cast<const char*>(input_buffer_.data());\n                    input_buffer_.consume(input_buffer_.size());\n                    if (!input_line.empty()) {\n                        write_msg_.length_ = static_cast<std::size_t>(input_line.size());\n                        std::memcpy(write_msg_.body_.data(), input_line.data(), write_msg_.length_);\n                        do_write_message();\n                    }\n                    do_read_input();\n                } else {\n                    std::cerr << \"Read input error: \" << ec.message() << std::endl;\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.body_.data(), write_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (ec) {\n                    std::cerr << \"Write message error: \" << ec.message() << std::endl;\n                }\n                do_read_header();\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    char data[header + body];\n    int length;\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.data, read_msg_.header),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec && read_msg_.length > 0) {\n                    do_read_body();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, socket_.socket(),\n            boost::asio::buffer(read_msg_.data + read_msg_.header, read_msg_.length),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::write(output_, boost::asio::buffer(read_msg_.data, read_msg_.length + read_msg_.header),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_read_header();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_input() {\n        input_.async_read_some(boost::asio::buffer(input_buffer_),\n            [this](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n                if (!ec && bytes_transferred > 0) {\n                    std::istream is(&input_buffer_);\n                    std::string line;\n                    std::getline(is, line);\n                    if (!line.empty()) {\n                        write_msg_.length = static_cast<int>(line.size());\n                        std::memcpy(write_msg_.data, line.c_str(), write_msg_.length);\n                        do_write_message();\n                    }\n                    do_read_input();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::write(socket_, boost::asio::buffer(write_msg_.data, write_msg_.length),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_read_header();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    boost::array<char, header> header_;\n    boost::array<char, body> body_;\n    std::size_t length_;\n    chat_message() : length_(0) {}\n};\n\nclass posix_chat_client : public boost::enable_shared_from_this<posix_chat_client> {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : socket_(io_context), input_(io_context), output_(io_context), read_msg_(), write_msg_(), input_buffer_() {\n        do_connect(endpoints);\n        do_read_input();\n    }\n\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        boost::asio::async_connect(socket_, endpoints,\n            [this](const boost::system::error_code& ec, const boost::asio::ip::tcp::endpoint&) {\n                if (!ec) {\n                    do_read_header();\n                }\n            });\n    }\n\n    void do_read_header() {\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.header_, read_msg_.header_.size()),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec && read_msg_.header_[0] == 'C' && read_msg_.header_[1] == 'H') {\n                    read_msg_.length_ = *reinterpret_cast<std::size_t*>(read_msg_.header_.data() + 2);\n                    do_read_body();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_body() {\n        boost::asio::async_read(socket_, boost::asio::buffer(read_msg_.body_, read_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_write_output();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_output() {\n        boost::asio::streambuf output_buffer;\n        std::ostream os(&output_buffer);\n        os << std::string(read_msg_.body_.data(), read_msg_.length_) << std::endl;\n        boost::asio::async_write(output_, output_buffer,\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_read_header();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_read_input() {\n        boost::asio::async_read_until(input_, input_buffer_, \"\\n\",\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    std::istream is(&input_buffer_);\n                    std::string line;\n                    std::getline(is, line);\n                    if (!line.empty()) {\n                        write_msg_.length_ = line.size();\n                        std::memcpy(write_msg_.body_.data(), line.data(), write_msg_.length_);\n                        write_msg_.header_[0] = 'C';\n                        write_msg_.header_[1] = 'H';\n                        *(std::size_t*)(write_msg_.header_.data() + 2) = write_msg_.length_;\n                        do_write_message();\n                    }\n                    do_read_input();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void do_write_message() {\n        boost::asio::async_write(socket_, boost::asio::buffer(write_msg_.header_, write_msg_.header_.size() + write_msg_.length_),\n            [this](const boost::system::error_code& ec, std::size_t /*bytes_transferred*/) {\n                if (!ec) {\n                    do_read_header();\n                } else {\n                    close();\n                }\n            });\n    }\n\n    void close() {\n        socket_.close();\n        input_.close();\n        output_.close();\n    }\n\nprivate:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "matched_results": [],
    "unmatched_results": [
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = boost::beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        void connect();\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n        net::ip::tcp::socket socket_;\n        net::ip::tcp::socket socket_ssl_;\n        std::vector<Work> work_queue_;\n        std::mutex queue_mutex_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = boost::beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        void setHost(const std::string&);\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = boost::beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        void operator()();\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = boost::beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        void connect();\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n        net::ip::tcp::socket socket_;\n        net::ip::tcp::socket socket_ssl_;\n        std::vector<Work> work_queue_;\n        std::mutex queue_mutex_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace net = boost::asio;\nnamespace ssl = net::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        void start();\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n        std::vector<Work> work_queue_;\n        std::mutex queue_mutex_;\n        std::atomic<bool> is_running_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace ssl = net::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        \n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace net = boost::asio;\nnamespace ssl = net::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        void start();\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n        std::vector<Work> work_queue_;\n        std::mutex mtx_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace ssl = net::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace ssl = net::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        \n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n    };\n};",
      "#include <boost/asio.hpp>\n#include <boost/beast.hpp>\n#include <memory>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace ssl = net::ssl;\nnamespace beast = boost::beast;\nnamespace websocket = beast::websocket;\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context&, ssl::context&, Device&, std::shared_ptr<Logging>);\n        ~Impl();\n\n        void run();\n        void onResolve(beast::error_code, tcp::resolver::results_type);\n        void onConnect(beast::error_code, tcp::resolver::results_type::endpoint_type);\n        void onSSLhandshake(beast::error_code);\n        void onWinsockHandshake(beast::error_code);\n        void send(const std::string&, const std::string&);\n        void onWrite(beast::error_code, std::size_t);\n        void read();\n        void onRead(beast::error_code, std::size_t);\n        void onError(beast::error_code&, std::string);\n        void enqueueWork(Work&);\n        void close();\n        \n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n    };\n};"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Implement a TCP client using Boost.Asio for asynchronous network communication, capable of connecting to a server, sending messages, and receiving responses.\n\nClass Description: The `chat_client` class encapsulates a TCP client that manages asynchronous network operations including connection establishment, message reading, and message writing.\n\nAttributes:\n- io_context_: boost::asio::io_context& - Reference to the I/O execution context for asynchronous operations.\n- socket_: tcp::socket - TCP socket for communication with the server.\n- read_msg_: chat_message - Buffer for storing the currently read message.\n- write_msgs_: chat_message_queue - Queue of messages waiting to be sent to the server.\n\nMethods:\n- Constructor: chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints) -> None - Initializes the client with I/O context and server endpoints, then starts the connection process.\n- write: write(const chat_message& msg) -> None - Enqueues a message for asynchronous sending to the server.\n- close: close() -> None - Initiates socket closure to terminate the connection cleanly.\n- do_connect: do_connect(const tcp::resolver::results_type& endpoints) -> None - Asynchronously connects to the server using the provided endpoints.\n- do_read_header: do_read_header() -> None - Asynchronously reads the message header from the server.\n- do_read_body: do_read_body() -> None - Asynchronously reads the message body from the server after header is processed.\n- do_write: do_write() -> None - Asynchronously writes the next queued message to the server.",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\ntypedef std::deque<chat_message> chat_message_queue;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context),\n      socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_,\n        [this, msg]()\n        {\n          bool write_in_progress = !write_msgs_.empty();\n          write_msgs_.push_back(msg);\n          if (!write_in_progress)\n          {\n            do_write();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]() { socket_.close(); });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            std::cout.write(read_msg_.body(), read_msg_.body_length());\n            std::cout << \"\\n\";\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(),\n          write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            write_msgs_.pop_front();\n            if (!write_msgs_.empty())\n            {\n              do_write();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\nprivate:\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  chat_message_queue write_msgs_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "matched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef ip::tcp::socket socket;\ntypedef ip::tcp::resolver resolver;\n}\n}\n\nstruct chat_message {\n    enum { header = 20, body = 1024 };\n    std::string data;\n    int length;\n};\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& ec, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& ec, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& ec, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& ec, size_t bytes_transferred);\n\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    std::queue<chat_message> write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n}; \n\nchat_client::chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n    : io_context_(io_context), socket_(io_context), resolver_(io_context) {\n    do_connect(endpoints);\n}\n\nvoid chat_client::write(const chat_message& msg) {\n    write_msgs_.push(msg);\n    if (!write_msgs_.empty()) {\n        do_write();\n    }\n}\n\nvoid chat_client::close() {\n    boost::asio::post(io_context_, boost::bind(&chat_client::do_close, shared_from_this()));\n}\n\nvoid chat_client::do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n    boost::asio::async_connect(socket_, endpoints,\n        boost::bind(&chat_client::handle_connect, shared_from_this(),\n            boost::asio::placeholders::error,\n            boost::asio::placeholders::iterator));\n}\n\nvoid chat_client::do_read_header() {\n    boost::asio::async_read(socket_, socket_.lowest_layer(), boost::asio::buffer(&read_msg_.length, sizeof(read_msg_.length)),\n        boost::bind(&chat_client::handle_read_header, shared_from_this(),\n            boost::asio::placeholders::error,\n            boost::asio::placeholders::bytes_transferred));\n}\n\nvoid chat_client::do_read_body() {\n    boost::asio::async_read(socket_, socket_.lowest_layer(), boost::asio::buffer(read_msg_.data.data(), read_msg_.length),\n        boost::bind(&chat_client::handle_read_body, shared_from_this(),\n            boost::asio::placeholders::error,\n            boost::asio::placeholders::bytes_transferred));\n}\n\nvoid chat_client::do_write() {\n    if (!write_msgs_.empty()) {\n        chat_message msg = write_msgs_.front();\n        write_msgs_.pop();\n        boost::asio::async_write(socket_, boost::asio::buffer(&msg.length, sizeof(msg.length)) \n            + boost::asio::buffer(msg.data.data(), msg.length),\n            boost::bind(&chat_client::handle_write, shared_from_this(),\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n}\n\nvoid chat_client::handle_connect(const boost::system::error_code& ec, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter) {\n    if (!ec) {\n        do_read_header();\n    } else {\n        // Handle connection error\n    }\n}\n\nvoid chat_client::handle_read_header(const boost::system::error_code& ec, size_t bytes_transferred) {\n    if (!ec) {\n        do_read_body();\n    } else {\n        // Handle read header error\n    }\n}\n\nvoid chat_client::handle_read_body(const boost::system::error_code& ec, size_t bytes_transferred) {\n    if (!ec) {\n        do_read_header();\n    } else {\n        // Handle read body error\n    }\n}\n\nvoid chat_client::handle_write(const boost::system::error_code& ec, size_t bytes_transferred) {\n    if (!ec) {\n        do_write();\n    } else {\n        // Handle write error\n    }\n}"
    ],
    "unmatched_results": [
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef io_service io_service;\ntypedef ip::tcp tcp;\n}\n}\n\nstruct chat_message {\n    enum { header = 20, body = 1024 };\n    std::string data;\n    int length;\n};\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_service& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& error, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& error, size_t bytes_transferred);\n\n    boost::asio::io_service& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    std::queue<chat_message> write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef ip::tcp::socket socket;\ntypedef ip::tcp::resolver resolver;\n}\n}\n\nstruct chat_message {\n    enum { header = 20, body = 1024 };\n    std::string data;\n    int length;\n};\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& error, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& error, size_t bytes_transferred);\n\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    std::queue<chat_message> write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef ip::tcp::socket socket;\ntypedef ip::tcp::resolver resolver;\n}\n}\n\nstruct chat_message {\n    enum { header = 20, body = 1024 };\n    std::string data;\n    int length;\n};\n\ntypedef std::queue<chat_message> chat_message_queue;\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& error, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& error, size_t bytes_transferred);\n\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef ip::tcp::socket socket;\ntypedef ip::tcp::resolver resolver;\n}\n}\n\nstruct chat_message {\n    enum { header = 20, body = 1024 };\n    std::string data;\n    int length;\n};\n\ntypedef std::queue<chat_message> chat_message_queue;\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& error, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& error, size_t bytes_transferred);\n\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef io_service io_service;\ntypedef ip::tcp tcp;\ntypedef ip::address address;\ntypedef ip::tcp::resolver resolver;\ntypedef ip::tcp::socket socket;\n} // namespace asio\n} // namespace boost\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    char data[header + body];\n    int length;\n};\n\ntypedef std::queue<chat_message> chat_message_queue;\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_service& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& error, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& error, size_t bytes_transferred);\n    boost::asio::io_service& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef io_service io_service;\ntypedef ip::tcp tcp;\n}\n}\n\nstruct chat_message {\n    enum { header = 20, body = 1024 };\n    char data[header + body];\n    unsigned int length;\n};\n\ntypedef std::queue<chat_message> chat_message_queue;\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_service& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& error, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& error, size_t bytes_transferred);\n\n    boost::asio::io_service& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef io_service io_service;\ntypedef ip::tcp tcp;\n}\n}\n\nstruct chat_message {\n    enum { header = 20, body = 1024 };\n    unsigned int length_;\n    char data_[body];\n};\n\ntypedef std::queue<chat_message> chat_message_queue;\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_service& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& ec, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& ec, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& ec, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& ec, size_t bytes_transferred);\n\n    boost::asio::io_service& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost { namespace asio { using namespace std::placeholders; } }\n\nstruct chat_message {\n    enum { header = 20, body = 512 };\n    unsigned int length;\n    char data[body];\n};\n\ntypedef std::queue<chat_message> chat_message_queue;\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& error, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& error, size_t bytes_transferred);\n\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n};",
      "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <queue>\n#include <string>\n\nnamespace boost {\nnamespace asio {\ntypedef ip::tcp::socket socket;\ntypedef ip::tcp::resolver resolver;\n}\n}\n\nstruct chat_message {\n    enum { header = 20, body = 1024 };\n    std::string data;\n    int length;\n};\n\ntypedef std::queue<chat_message> chat_message_queue;\n\nclass chat_client : public boost::enable_shared_from_this<chat_client> {\npublic:\n    chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void write(const chat_message& msg);\n    void close();\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints);\n    void do_read_header();\n    void do_read_body();\n    void do_write();\n    void handle_connect(const boost::system::error_code& error, const boost::asio::ip::tcp::resolver::results_type::iterator endpoint_iter);\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred);\n    void handle_write(const boost::system::error_code& error, size_t bytes_transferred);\n\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    chat_message_queue write_msgs_;\n    boost::asio::ip::tcp::resolver resolver_;\n};"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  }
]