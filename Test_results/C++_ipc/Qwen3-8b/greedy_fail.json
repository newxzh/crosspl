[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "#include <string>\n#include <nlohmann/json.hpp>\n#include <httplib.h>\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, nlohmann::json* request_data, nlohmann::json* response_data) {\n    httplib::Client client(location);\n    std::string body;\n    if (method == \"PUT\" || method == \"POST\") {\n        if (request_data) {\n            body = request_data->dump();\n        }\n    }\n    auto res = client.request(method, URI, body);\n    long status = res->status;\n    if (status >= 200 && status < 300) {\n        if (response_data) {\n            *response_data = nlohmann::json::parse(res->body);\n        }\n    }\n    return status;\n}"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a C++ class that handles HTTP communication over TCP and UDP protocols, including sending requests and receiving responses from a server.\n\nClass Description: The LinHttpHandler class provides functionality for sending HTTP requests and receiving responses using both TCP (for standard HTTP communication) and UDP (for multicast communication). It includes error handling and resource management through RAII.\n\nAttributes:\n\nSocketCloser: [Nested Class] - A helper class that ensures sockets are properly closed when they go out of scope.\n\nMethods:\n\nsend: [Name](const std::string& msg, const std::string& adr, int port) -> std::string - Sends an HTTP message to the specified address and port using TCP and returns the server's response. Throws system_error on failure.\n\nsendMulticast: [Name](const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) -> std::vector<std::string> - Sends a multicast message using UDP and collects responses within the specified timeout period. Returns a vector of response strings. Throws system_error on failure.\n\nSocketCloser: [Name](int sockFd) -> None - Constructor that takes a socket file descriptor. The destructor automatically closes the socket.",
    "Canonical_solution": "#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <stdexcept>\n#include <system_error>\n#include <vector>\n\nnamespace hueplusplus\n{\nclass LinHttpHandler\n{\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) const\n    {\n        int socketFD = socket(AF_INET, SOCK_STREAM, 0);\n\n        SocketCloser closeMySocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to open socket\"));\n        }\n\n        hostent* server = gethostbyname(adr.c_str());\n        if (server == NULL)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: gethostbyname\"));\n        }\n\n        sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        memcpy(&server_addr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n        if (connect(socketFD, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to connect socket\"));\n        }\n\n        size_t total = msg.length();\n        size_t sent = 0;\n        do\n        {\n            ssize_t bytes = write(socketFD, msg.c_str() + sent, total - sent);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to write message to socket\"));\n            }\n            sent += bytes;\n        } while (sent < total);\n\n        std::string response;\n        char buffer[128] = {};\n        do\n        {\n            ssize_t bytes = read(socketFD, buffer, 127);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to read response from socket\"));\n            }\n            response.append(buffer, bytes);\n        } while (true);\n\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(\n        const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) const\n    {\n        hostent* server;\n        sockaddr_in server_addr;\n\n        memset((char*)&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n\n        server = gethostbyname(adr.c_str());\n        if (!server)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to obtain address of host\"));\n        }\n\n        memcpy((void*)&server_addr.sin_addr, server->h_addr_list[0], server->h_length);\n\n        int socketFD = socket(AF_INET, SOCK_DGRAM, 0);\n        SocketCloser closeMySendSocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to open socket\"));\n        }\n\n        if (sendto(socketFD, msg.c_str(), strlen(msg.c_str()), 0, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to send message\"));\n        }\n\n        std::string response;\n        char buffer[2048] = {};\n\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout)\n        {\n            ssize_t bytesReceived = recv(socketFD, &buffer, 2048, MSG_DONTWAIT);\n            if (bytesReceived < 0 && errno != EAGAIN && errno != EWOULDBLOCK)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to read response from socket\"));\n            }\n            if (bytesReceived > 0)\n            {\n                response.append(buffer, bytesReceived);\n            }\n        }\n\n        std::vector<std::string> returnString;\n        size_t pos = response.find(\"\\r\\n\\r\\n\");\n        size_t prevpos = 0;\n        while (pos != std::string::npos)\n        {\n            returnString.push_back(response.substr(prevpos, pos - prevpos));\n            pos += 4;\n            prevpos = pos;\n            pos = response.find(\"\\r\\n\\r\\n\", pos);\n        }\n        return returnString;\n    }\n\nprivate:\n    class SocketCloser\n    {\n    public:\n        explicit SocketCloser(int sockFd) : s(sockFd) {}\n        ~SocketCloser() { close(s); }\n\n    private:\n        int s;\n    };\n};\n} // namespace hueplusplus",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "wrong_result": "class LinHttpHandler {\npublic:\n    class SocketCloser {\n    public:\n        explicit SocketCloser(int sockFd) : sockFd_(sockFd) {}\n        ~SocketCloser() {\n            if (sockFd_ != -1) {\n                close(sockFd_);\n            }\n        }\n    private:\n        int sockFd_;\n    };\n\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        struct addrinfo hints, *res;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_INET;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n\n        int status = getaddrinfo(adr.c_str(), std::to_string(port).c_str(), &hints, &res);\n        if (status != 0) {\n            throw std::system_error(errno, std::generic_category(), \"getaddrinfo failed\");\n        }\n\n        int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n        if (sockfd == -1) {\n            throw std::system_error(errno, std::generic_category(), \"socket failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        if (connect(sockfd, res->ai_addr, res->ai_addrlen) == -1) {\n            throw std::system_error(errno, std::generic_category(), \"connect failed\");\n        }\n\n        ssize_t bytesSent = send(sockfd, msg.c_str(), msg.size(), 0);\n        if (bytesSent != static_cast<ssize_t>(msg.size())) {\n            throw std::system_error(errno, std::generic_category(), \"send failed\");\n        }\n\n        std::string response;\n        char buffer[1024];\n        while (true) {\n            ssize_t bytesRecv = recv(sockfd, buffer, sizeof(buffer) - 1, 0);\n            if (bytesRecv <= 0) {\n                break;\n            }\n            response.append(buffer, bytesRecv);\n        }\n\n        freeaddrinfo(res);\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        struct addrinfo hints, *res;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_INET;\n        hints.ai_socktype = SOCK_DGRAM;\n        hints.ai_protocol = IPPROTO_UDP;\n\n        int status = getaddrinfo(adr.c_str(), std::to_string(port).c_str(), &hints, &res);\n        if (status != 0) {\n            throw std::system_error(errno, std::generic_category(), \"getaddrinfo failed\");\n        }\n\n        int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n        if (sockfd == -1) {\n            throw std::system_error(errno, std::generic_category(), \"socket failed\");\n        }\n\n        SocketCloser closer(sockfd);\n\n        struct ip_mreq mreq;\n        mreq.imr_multiaddr.s_addr = inet_addr(adr.c_str());\n        mreq.imr_interface.s_addr = INADDR_ANY;\n\n        if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == -1) {\n            throw std::system_error(errno, std::generic_category(), \"setsockopt failed\");\n        }\n\n        int ttl = 1;\n        if (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl)) == -1) {\n            throw std::system_error(errno, std::generic_category(), \"setsockopt failed\");\n        }\n\n        ssize_t bytesSent = sendto(sockfd, msg.c_str(), msg.size(), 0, res->ai_addr, res->ai_addrlen);\n        if (bytesSent != static_cast<ssize_t>(msg.size())) {\n            throw std::system_error(errno, std::generic_category(), \"sendto failed\");\n        }\n\n        std::vector<std::string> responses;\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n\n        while (std::chrono::steady_clock::now() - start < timeout) {\n            char buffer[1024];\n            struct sockaddr_in from;\n            socklen_t fromLen = sizeof(from);\n\n            ssize_t bytesRecv = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0, (struct sockaddr*)&from, &fromLen);\n            if (bytesRecv <= 0) {\n                std::this_thread::sleep_for(std::chrono::milliseconds(100));\n                continue;\n            }\n\n            responses.emplace_back(std::string(buffer, bytesRecv));\n        }\n\n        freeaddrinfo(res);\n        return responses;\n    }\n};"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends a single character, receives a response, and then closes the connection.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server address and port, sends a predefined character ('A') to the server, reads the server's response, prints the received character, and finally closes the socket. This demonstrates basic TCP client functionality using BSD sockets.\n\nInput: None (The server address and port are hardcoded as 127.0.0.1:9736 in the function)\n\nOutput: \n- Returns 0 on successful execution\n- Prints the received character from the server\n- Exits with error code 1 if connection fails",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint tcp_client_communication()\n{\n    int sockfd = -1;\n    int len = 0;\n    struct sockaddr_in address;\n    int result;\n    char ch = 'A';\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    address.sin_port = htons(9736);\n    len = sizeof(address);\n    \n    result = connect(sockfd, (struct sockaddr*)&address, len);\n\n    if(result == -1)\n    {\n        perror(\"ops:client\\n\");\n        exit(1);\n    }\n    \n    write(sockfd, &ch, 1);\n    read(sockfd, &ch, 1);\n    printf(\"char form server = %c\\n\", ch);\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "wrong_result": "int tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return 1;\n    }\n\n    char send_char = 'A';\n    if (write(sockfd, &send_char, 1) < 0) {\n        std::cerr << \"Send failed\" << std::endl;\n        close(sockfd);\n        return 1;\n    }\n\n    char recv_char;\n    if (read(sockfd, &recv_char, 1) < 0) {\n        std::cerr << \"Receive failed\" << std::endl;\n        close(sockfd);\n        return 1;\n    }\n\n    std::cout << \"Received: \" << recv_char << std::endl;\n\n    close(sockfd);\n    return 0;\n}"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 8888, respectively, within the function.)\n\nOutput: None (The function prints received messages from the server to the console but does not return any value.)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "wrong_result": "#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\nvoid tcp_client_communication() {\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n        throw std::runtime_error(\"WSAStartup failed.\");\n    }\n\n    SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (clientSocket == INVALID_SOCKET) {\n        throw std::runtime_error(\"Socket creation failed.\");\n    }\n\n    sockaddr_in serverAddr;\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &serverAddr.sin_addr);\n\n    if (connect(clientSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {\n        closesocket(clientSocket);\n        WSACleanup();\n        throw std::runtime_error(\"Connection failed.\");\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message: \";\n        std::string input;\n        std::getline(std::cin, input);\n\n        if (input == \"exit\") {\n            break;\n        }\n\n        int bytesSent = send(clientSocket, input.c_str(), input.size(), 0);\n        if (bytesSent == SOCKET_ERROR) {\n            std::cerr << \"Send failed.\" << std::endl;\n            break;\n        }\n\n        char response[1024];\n        int bytesReceived = recv(clientSocket, response, sizeof(response) - 1, 0);\n        if (bytesReceived <= 0) {\n            std::cerr << \"Server closed connection.\" << std::endl;\n            break;\n        }\n\n        response[bytesReceived] = '\\0';\n        std::cout << \"Server: \" << response << std::endl;\n    }\n\n    closesocket(clientSocket);\n    WSACleanup();\n}"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests and handling responses, including JSON parsing capabilities.\n\nClass Description: The CurlHttpClient class provides methods for performing HTTP GET requests and downloading web pages, with support for custom headers and request bodies. It includes JSON response handling and memory management for received data.\n\nAttributes:\nMemoryStruct: [struct] - A helper structure for storing received data in memory during curl operations\n  - memory: [char*] - Pointer to the allocated memory buffer\n  - size: [size_t] - Size of the allocated memory buffer\n\nMethods:\nWriteMemoryCallback: [static](void* contents, size_t size, size_t nmemb, void* userp) -> size_t - A static callback function for libcurl to write received data into memory\n  - contents: [void*] - Pointer to the received data\n  - size: [size_t] - Size of each data element\n  - nmemb: [size_t] - Number of data elements\n  - userp: [void*] - Pointer to user-provided memory structure\n  - Returns: The number of bytes actually written\n\ndownloadPage: [](const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) -> long - Downloads a web page and returns the HTTP status code\n  - url: [const std::string&] - The URL to request\n  - res: [std::string&] - Reference to store the response body\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response\n\ngetRequest: [](const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) -> long - Performs a GET request and parses the JSON response\n  - url: [const std::string&] - The URL to request\n  - res: [json&] - Reference to store the parsed JSON response\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <vector>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::ordered_json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n        if (ptr == NULL) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl_handle;\n        MemoryStruct chunk;\n        struct curl_slist* list = NULL;\n        long status_code;\n\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_global_init(CURL_GLOBAL_ALL);\n        curl_handle = curl_easy_init();\n        curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());\n        if (!headers.empty()) {\n            for (auto& h : headers) {\n                list = curl_slist_append(list, h.c_str());\n            }\n            curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, list);\n        }\n        if (body != \"\") {\n            curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"HamletDuFromage\");\n\n        curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);\n        curl_easy_perform(curl_handle);\n        curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &status_code);\n        curl_easy_cleanup(curl_handle);\n        res = std::string(chunk.memory);\n        free(chunk.memory);\n\n        curl_global_cleanup();\n        return status_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string request;\n        long status_code = downloadPage(url, request, headers, body);\n\n        if (json::accept(request))\n            res = json::parse(request);\n        else\n            res = json::object();\n\n        return status_code;\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "wrong_result": "struct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nclass CurlHttpClient {\npublic:\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        if (mem->memory == nullptr || mem->size < realsize) {\n            free(mem->memory);\n            mem->memory = (char*)malloc(realsize);\n            if (mem->memory == nullptr) return 0;\n            mem->size = realsize;\n        } else {\n            mem->memory = (char*)realloc(mem->memory, realsize);\n            if (mem->memory == nullptr) return 0;\n            mem->size = realsize;\n        }\n\n        memcpy(mem->memory, contents, realsize);\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl;\n        CURLcode res_code;\n        MemoryStruct chunk = {nullptr, 0};\n\n        curl = curl_easy_init();\n        if (!curl) return CURLE_FAILED_INIT;\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);\n\n        struct curl_slist* header_list = nullptr;\n        for (const auto& header : headers) {\n            header_list = curl_slist_append(header_list, header.c_str());\n        }\n        if (header_list) {\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n        }\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        res_code = curl_easy_perform(curl);\n        if (res_code != CURLE_OK) {\n            curl_easy_cleanup(curl);\n            curl_slist_free_all(header_list);\n            return res_code;\n        }\n\n        res.assign(chunk.memory, chunk.size);\n        curl_easy_cleanup(curl);\n        curl_slist_free_all(header_list);\n\n        free(chunk.memory);\n        long status_code;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &status_code);\n        return status_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string response;\n        long status_code = downloadPage(url, response, headers, body);\n        if (status_code != CURLE_OK) return status_code;\n\n        try {\n            res = nlohmann::json::parse(response);\n        } catch (...) {\n            return CURLE_ABORTED_BY_CALLBACK;\n        }\n        return status_code;\n    }\n};"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input to the server, and prints the server's response. The function should handle basic error cases and properly close the connection when done.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and displays the server's response. The loop continues until an error occurs or the connection is closed by the server. The function handles socket creation, connection, data transmission, and cleanup.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 1234 respectively in the function)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(1234);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "wrong_result": "#include <iostream>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\nvoid tcp_client_communication() {\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n        std::cerr << \"WSAStartup failed.\\n\";\n        return;\n    }\n\n    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == INVALID_SOCKET) {\n        std::cerr << \"Socket creation failed.\\n\";\n        WSACleanup();\n        return;\n    }\n\n    sockaddr_in serverAddr;\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &serverAddr.sin_addr);\n\n    if (connect(sock, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {\n        std::cerr << \"Connection failed.\\n\";\n        closesocket(sock);\n        WSACleanup();\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cout << \"> \";\n        if (!std::cin) {\n            std::cerr << \"Input error.\\n\";\n            break;\n        }\n        std::string input;\n        std::getline(std::cin, input);\n        if (input.empty()) break;\n\n        int bytesSent = send(sock, input.c_str(), input.size(), 0);\n        if (bytesSent == SOCKET_ERROR) {\n            std::cerr << \"Send failed.\\n\";\n            break;\n        }\n\n        int bytesRecv = recv(sock, buffer, sizeof(buffer) - 1, 0);\n        if (bytesRecv == SOCKET_ERROR) {\n            std::cerr << \"Receive failed.\\n\";\n            break;\n        } else if (bytesRecv == 0) {\n            std::cout << \"Server closed connection.\\n\";\n            break;\n        }\n\n        buffer[bytesRecv] = '\\0';\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    closesocket(sock);\n    WSACleanup();\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <iostream>\n#include <vector>\n#include <mutex>\n#include <thread>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <sys/select.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\nclass NetworkClientInfo {\n    // Assume this is defined elsewhere\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<RGBController *>& control);\n    ~NetworkServer();\n    void StartServer();\n    void StopServer();\n    void ConnectionThreadFunction(int socket_idx);\n    int accept_select(int sockfd);\n    unsigned short GetPort();\n    void ClientInfoChanged();\n    void ServerListeningChanged();\n    void ListenThreadFunction(NetworkClientInfo * client_info);\n\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n};\n\nNetworkServer::NetworkServer(std::vector<RGBController *>& control) {\n    // Initialize members\n    server_online = false;\n    server_listening = false;\n    socket_count = 0;\n}\n\nNetworkServer::~NetworkServer() {\n    StopServer();\n}\n\nvoid NetworkServer::StartServer() {\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n        std::cerr << \"WSAStartup failed.\\n\";\n        return;\n    }\n\n    for (int i = 0; i < MAXSOCK; ++i) {\n        server_sock[i] = socket(AF_INET6, SOCK_STREAM, 0);\n        if (server_sock[i] == INVALID_SOCKET) {\n            std::cerr << \"Socket creation failed for IPv6.\\n\";\n            continue;\n        }\n\n        int opt = 1;\n        if (setsockopt(server_sock[i], SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt)) == SOCKET_ERROR) {\n            std::cerr << \"Setsockopt failed.\\n\";\n            closesocket(server_sock[i]);\n            continue;\n        }\n\n        sockaddr_in6 addr;\n        addr.sin6_family = AF_INET6;\n        addr.sin6_port = htons(port_num);\n        addr.sin6_addr = in6addr_any;\n\n        if (bind(server_sock[i], (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {\n            std::cerr << \"Bind failed for IPv6.\\n\";\n            closesocket(server_sock[i]);\n            continue;\n        }\n\n        if (listen(server_sock[i], SOMAXCONN) == SOCKET_ERROR) {\n            std::cerr << \"Listen failed for IPv6.\\n\";\n            closesocket(server_sock[i]);\n            continue;\n        }\n\n        socket_count++;\n        ConnectionThread[i] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, i);\n    }\n\n    server_online = true;\n    server_listening = true;\n}\n\nvoid NetworkServer::StopServer() {\n    server_online = false;\n    server_listening = false;\n\n    for (int i = 0; i < MAXSOCK; ++i) {\n        if (server_sock[i] != INVALID_SOCKET) {\n            closesocket(server_sock[i]);\n        }\n    }\n\n    for (int i = 0; i < MAXSOCK; ++i) {\n        if (ConnectionThread[i] != nullptr) {\n            if (ConnectionThread[i]->joinable()) {\n                ConnectionThread[i]->join();\n            }\n            delete ConnectionThread[i];\n        }\n    }\n\n    std::lock_guard<std::mutex> lock(ServerClientsMutex);\n    for (auto client : ServerClients) {\n        delete client;\n    }\n    ServerClients.clear();\n}\n\nvoid NetworkServer::ConnectionThreadFunction(int socket_idx) {\n    while (server_listening) {\n        int conn_sock = accept_select(server_sock[socket_idx]);\n        if (conn_sock != -1) {\n            NetworkClientInfo *client_info = new NetworkClientInfo();\n            client_info->socket = conn_sock;\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n            ClientInfoChanged();\n            std::thread listen_thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            listen_thread.detach();\n        }\n    }\n}\n\nint NetworkServer::accept_select(int sockfd) {\n    fd_set readfds;\n    struct timeval tv;\n    int conn_sock;\n\n    FD_ZERO(&readfds);\n    FD_SET(sockfd, &readfds);\n\n    tv.tv_sec = 5;\n    tv.tv_usec = 0;\n\n    int sel = select(sockfd + 1, &readfds, NULL, NULL, &tv);\n    if (sel == -1) {\n        return -1;\n    } else if (sel == 0) {\n        return -1;\n    }\n\n    if (FD_ISSET(sockfd, &readfds)) {\n        sockaddr_in6 client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        conn_sock = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n        if (conn_sock == -1) {\n            return -1;\n        }\n        return conn_sock;\n    }\n    return -1;\n}\n\nunsigned short NetworkServer::GetPort() {\n    return port_num;\n}\n\nvoid NetworkServer::ClientInfoChanged() {\n    // Placeholder for client info change callback\n}\n\nvoid NetworkServer::ServerListeningChanged() {\n    // Placeholder for server listening state change callback\n}\n\nvoid NetworkServer::ListenThreadFunction(NetworkClientInfo * client_info) {\n    // Placeholder for client communication handling\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Implement a UDP server using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nFunction Description: The function `udp_server` creates a UDP server that listens on port 13 (daytime protocol port). When it receives any datagram from a client, it responds with the current time in string format. The server runs indefinitely until an exception occurs.\n\nInput: None\n\nOutput: None (The function runs indefinitely and sends responses to clients, but doesn't return any value)",
    "Canonical_solution": "#include <array>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n  using namespace std;\n  time_t now = time(0);\n  return ctime(&now);\n}\n\nvoid udp_server()\n{\n  try\n  {\n    boost::asio::io_context io_context;\n\n    udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n    for (;;)\n    {\n      std::array<char, 1> recv_buf;\n      udp::endpoint remote_endpoint;\n      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);\n\n      std::string message = make_daytime_string();\n\n      boost::system::error_code ignored_error;\n      socket.send_to(boost::asio::buffer(message),\n          remote_endpoint, 0, ignored_error);\n    }\n  }\n  catch (std::exception& e)\n  {\n    std::cerr << e.what() << std::endl;\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "#include <boost/asio.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include <iostream>\n\nvoid udp_server() {\n    try {\n        boost::asio::io_service io_service;\n        boost::asio::ip::udp::socket socket(io_service, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 13));\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        char recv_buffer[1024];\n\n        void handle_receive(const boost::system::error_code& error, size_t bytes_received) {\n            if (!error) {\n                boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n                std::string time_str = boost::posix_time::to_simple_string(now);\n                socket.send_to(boost::asio::buffer(time_str), remote_endpoint);\n                socket.async_receive_from(\n                    boost::asio::buffer(recv_buffer, sizeof(recv_buffer)),\n                    remote_endpoint,\n                    handle_receive\n                );\n            } else {\n                std::cerr << \"Error: \" << error.message() << \"\\n\";\n            }\n        }\n\n        socket.async_receive_from(\n            boost::asio::buffer(recv_buffer, sizeof(recv_buffer)),\n            remote_endpoint,\n            handle_receive\n        );\n\n        io_service.run();\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << \"\\n\";\n    }\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a UDP client communication function using Boost.Asio to send a message to a specified host and port, and receive a response.\n\nFunction Description: The function establishes a UDP client connection, sends a message to a specified server, and waits to receive a response. It uses Boost.Asio for asynchronous UDP operations.\n\nInput:\n- host: [std::string] - The hostname or IP address of the UDP server to connect to\n- port: [std::string] - The port number of the UDP server\n- message: [std::string] - The message to be sent to the server\n\nOutput: None (The function receives a reply from the server but doesn't return it. In a real implementation, you might want to return the reply or process it further.)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client_communication(const std::string& host, const std::string& port, const std::string& message)\n{\n    boost::asio::io_context io_context;\n    udp::socket s(io_context, udp::endpoint(udp::v4(), 0));\n    udp::resolver resolver(io_context);\n    udp::resolver::results_type endpoints = resolver.resolve(udp::v4(), host, port);\n\n    size_t request_length = message.length();\n    s.send_to(boost::asio::buffer(message, request_length), *endpoints.begin());\n\n    char reply[max_length];\n    udp::endpoint sender_endpoint;\n    size_t reply_length = s.receive_from(boost::asio::buffer(reply, max_length), sender_endpoint);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "#include <boost/asio.hpp>\n#include <boost/array.hpp>\n#include <string>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::resolver resolver(io_context);\n        boost::asio::ip::udp::endpoint endpoint = *resolver.resolve(host, port).begin();\n\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::v4());\n        socket.connect(endpoint);\n\n        boost::asio::streambuf request;\n        std::ostream request_stream(&request);\n        request_stream << message;\n\n        boost::asio::async_write(socket, request, [&](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n            if (!ec) {\n                boost::array<char, 1024> reply;\n                boost::asio::async_read(socket, boost::asio::buffer(reply), [&](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n                    if (!ec && bytes_transferred > 0) {\n                        std::cout << \"Received: \" << std::string(reply.data(), bytes_transferred) << std::endl;\n                    }\n                });\n            }\n        });\n\n        io_context.run();\n    } catch (std::exception& e) {\n        std::cerr << e.what() << std::endl;\n    }\n}"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a UDP client function using Boost.Asio that sends a request to a UDP server and receives a response.\n\nFunction Description: The function establishes a UDP connection to a specified host, sends a minimal request packet, waits for a response, and prints the received data to standard output. It uses Boost.Asio for asynchronous UDP operations.\n\nInput: \n- host: std::string - The hostname or IP address of the UDP server to connect to\n\nOutput: \n- None (void function), but prints the received data to standard output\n\nNote: The function uses a fixed service name \"daytime\" (port 13) for demonstration purposes. In a real application, this would typically be configurable. The function handles both IPv4 and UDP protocol operations.",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client(const std::string& host)\n{\n    boost::asio::io_context io_context;\n\n    udp::resolver resolver(io_context);\n    udp::endpoint receiver_endpoint =\n      *resolver.resolve(udp::v4(), host, \"daytime\").begin();\n\n    udp::socket socket(io_context);\n    socket.open(udp::v4());\n\n    std::array<char, 1> send_buf  = {{ 0 }};\n    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n\n    std::array<char, 128> recv_buf;\n    udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(\n        boost::asio::buffer(recv_buf), sender_endpoint);\n\n    std::cout.write(recv_buf.data(), len);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "#include <boost/asio.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n#include <string>\n\nvoid udp_client(const std::string& host) {\n    try {\n        boost::asio::io_service io_service;\n\n        boost::asio::ip::udp::resolver resolver(io_service);\n        boost::asio::ip::udp::resolver::query query(host, \"daytime\");\n        boost::asio::ip::udp::endpoint remote_endpoint = *resolver.resolve(query).begin();\n\n        boost::asio::ip::udp::socket socket(io_service);\n        socket.open(remote_endpoint.protocol());\n\n        boost::asio::ip::udp::endpoint local_endpoint = boost::asio::ip::udp::endpoint(boost::asio::ip::address::from_string(\"0.0.0.0\"), 0);\n        socket.bind(local_endpoint);\n\n        std::string request = \"request\";\n        boost::asio::async_write(socket, boost::asio::buffer(request), [&](boost::system::error_code ec, std::size_t bytes_transferred) {\n            if (!ec) {\n                boost::array<char, 128> recv_buffer;\n                boost::asio::ip::udp::endpoint sender_endpoint;\n                socket.async_receive_from(boost::asio::buffer(recv_buffer), sender_endpoint, [&](boost::system::error_code ec, std::size_t bytes_received) {\n                    if (!ec) {\n                        std::cout.write(recv_buffer.data(), bytes_received);\n                        std::cout << std::endl;\n                        io_service.stop();\n                    } else {\n                        std::cerr << \"Receive error: \" << ec.message() << std::endl;\n                        io_service.stop();\n                    }\n                });\n            } else {\n                std::cerr << \"Send error: \" << ec.message() << std::endl;\n                io_service.stop();\n            }\n        });\n\n        io_service.run();\n    } catch (std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Implement a server class that handles both TCP and UDP communications using Boost.Asio, managing client subscriptions and broadcasting data frames to subscribed clients.\n\nClass Description: The `server` class manages network communications using both TCP and UDP protocols. It accepts TCP connections for control messages, maintains a set of subscribed UDP endpoints, and periodically broadcasts data frames to all subscribed clients via UDP.\n\nAttributes:\n- acceptor_: [tcp::acceptor] - Handles incoming TCP connections\n- timer_: [boost::asio::steady_timer] - Manages periodic operations\n- udp_socket_: [udp::socket] - Handles UDP communications\n- next_frame_number_: [unsigned long] - Tracks the sequence number for frames\n- subscribers_: [std::set<udp::endpoint>] - Stores subscribed client endpoints\n\nMethods:\n- server([boost::asio::io_context&] io_context, [unsigned short] port) -> [void] - Constructor that initializes the server with IO context and port\n- handle_accept([const boost::system::error_code&] ec, [tcp_socket_ptr] socket) -> [void] - Handles new TCP connection acceptances\n- handle_control_request([const boost::system::error_code&] ec, [tcp_socket_ptr] socket, [control_request_ptr] request) -> [void] - Processes control requests from clients\n- handle_control_request_timer([tcp_socket_ptr] socket, [control_request_ptr] request, [timer_ptr] delay_timer) -> [void] - Handles delayed processing of control requests\n- handle_timer() -> [void] - Periodically broadcasts data frames to subscribed clients",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <set>\n#include <memory>\n#include \"protocol.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef std::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef std::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef std::shared_ptr<control_request> control_request_ptr;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, unsigned short port)\n    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n      timer_(io_context),\n      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n      next_frame_number_(1)\n  {\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\n  void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n  {\n    if (!ec)\n    {\n      control_request_ptr request(new control_request);\n      boost::asio::async_read(*socket, request->to_buffers(),\n          std::bind(&server::handle_control_request, this,\n            boost::asio::placeholders::error, socket, request));\n    }\n\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n  }\n\n  void handle_control_request(const boost::system::error_code& ec,\n      tcp_socket_ptr socket, control_request_ptr request)\n  {\n    if (!ec)\n    {\n      timer_ptr delay_timer(\n          new boost::asio::steady_timer(acceptor_.get_executor()));\n      delay_timer->expires_after(boost::asio::chrono::seconds(2));\n      delay_timer->async_wait(\n          std::bind(&server::handle_control_request_timer, this,\n            socket, request, delay_timer));\n    }\n  }\n\n  void handle_control_request_timer(tcp_socket_ptr socket,\n      control_request_ptr request, timer_ptr /*delay_timer*/)\n  {\n    boost::system::error_code ec;\n    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);\n    if (!ec)\n    {\n      if (unsigned short old_port = request->old_port())\n      {\n        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);\n        subscribers_.erase(old_endpoint);\n      }\n\n      if (unsigned short new_port = request->new_port())\n      {\n        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);\n        subscribers_.insert(new_endpoint);\n      }\n    }\n\n    boost::asio::async_read(*socket, request->to_buffers(),\n        std::bind(&server::handle_control_request, this,\n          boost::asio::placeholders::error, socket, request));\n  }\n\n  void handle_timer()\n  {\n    double x = next_frame_number_ * 0.2;\n    double y = std::sin(x);\n    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));\n    std::string payload;\n    for (int i = 0; i < frame::payload_size; ++i)\n      payload += (i == char_index ? '*' : '.');\n\n    frame f(next_frame_number_++, payload);\n\n    std::set<udp::endpoint>::iterator j;\n    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)\n    {\n      boost::system::error_code ec;\n      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);\n    }\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\nprivate:\n  tcp::acceptor acceptor_;\n  boost::asio::steady_timer timer_;\n  udp::socket udp_socket_;\n  unsigned long next_frame_number_;\n  std::set<udp::endpoint> subscribers_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "wrong_result": "class server {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port) : acceptor_(io_context), timer_(io_context), udp_socket_(io_context), next_frame_number_(0) {\n        acceptor_.open(tcp::v4());\n        acceptor_.bind(tcp::endpoint(tcp::v4(), port));\n        acceptor_.listen();\n        timer_.expires_from_now(boost::asio::chrono::seconds(1));\n        timer_.async_wait(boost::asio::bind_executor(io_context, &server::handle_timer, this));\n        udp_socket_.open(udp::v4());\n        udp_socket_.bind(udp::endpoint(udp::v4(), port));\n        acceptor_.async_accept(socket_, boost::asio::bind_executor(io_context, &server::handle_accept, this));\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp::socket* socket) {\n        if (!ec) {\n            boost::asio::streambuf request_buffer;\n            boost::asio::async_read(*socket, request_buffer, boost::asio::transfer_all(), \n                boost::asio::bind_executor(io_context_, \n                    [this, socket, request_buffer](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n                        handle_control_request(ec, socket, request_buffer.data(), bytes_transferred);\n                    }));\n        }\n        acceptor_.async_accept(socket_, boost::asio::bind_executor(io_context_, &server::handle_accept, this));\n    }\n\n    void handle_control_request(const boost::system::error_code& ec, tcp::socket* socket, const char* data, std::size_t bytes_transferred) {\n        if (!ec) {\n            std::string request(data, bytes_transferred);\n            if (request.find(\"subscribe\") != std::string::npos) {\n                std::istringstream iss(request);\n                std::string command;\n                iss >> command;\n                if (command == \"subscribe\") {\n                    std::string ip;\n                    unsigned short port;\n                    iss >> ip >> port;\n                    udp::endpoint endpoint(boost::asio::ip::address::from_string(ip), port);\n                    subscribers_.insert(endpoint);\n                    std::string response = \"Subscribed\";\n                    boost::asio::write(*socket, boost::asio::buffer(response));\n                }\n            }\n        }\n    }\n\n    void handle_control_request_timer(tcp::socket* socket, control_request_ptr request, timer_ptr delay_timer) {\n        // Implementation for delayed processing\n    }\n\n    void handle_timer() {\n        std::string frame_data = \"Frame \" + std::to_string(next_frame_number_);\n        next_frame_number_++;\n        for (const auto& endpoint : subscribers_) {\n            boost::asio::ip::udp::endpoint target_endpoint = endpoint;\n            boost::asio::write(udp_socket_, boost::asio::buffer(frame_data), boost::asio::transfer_all());\n        }\n        timer_.expires_from_now(boost::asio::chrono::seconds(1));\n        timer_.async_wait(boost::asio::bind_executor(io_context_, &server::handle_timer, this));\n    }\n\nprivate:\n    tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<udp::endpoint> subscribers_;\n    tcp::socket* socket_;\n};"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, process incoming messages, and echo messages back to clients. The server should also support stopping the listening process upon receiving a specific command.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, managing connection handling, message processing, and server lifecycle operations.\n\nAttributes:\n- service_: [asio::io_service&] - Reference to the ASIO I/O service used for network operations\n- port_: [int] - The port number on which the server listens for connections\n- ws_server_: [ws_echo_server] - The WebSocket++ server instance\n\nMethods:\n- Constructor: [WebSocketServer]([asio::io_service& service, int port]) -> [void] - Initializes the WebSocket++ server, sets up logging, message handling, and starts listening on the specified port\n- on_message: [on_message]([websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg]) -> [void] - Callback function that processes incoming messages, echoes them back to clients, and handles the stop-listening command\n- run: [run]() -> [void] - Starts the server's event loop to handle connections and messages",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) \n        : service_(service), port_(port) {\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        if (msg->get_payload() == \"stop-listening\") {\n            ws_server_.stop_listening();\n            return;\n        }\n\n        try {\n            ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "class WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port);\n    void run();\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    std::shared_ptr<websocketpp::server<websocketpp::config::asio>> ws_server_;\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg);\n};\n\nWebSocketServer::WebSocketServer(asio::io_service& service, int port) : service_(service), port_(port) {\n    ws_server_ = std::make_shared<websocketpp::server<websocketpp::config::asio>>();\n    ws_server_->init_asio();\n    ws_server_->set_message_handler(std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    ws_server_->listen(port_);\n    ws_server_->start_accept();\n}\n\nvoid WebSocketServer::run() {\n    service_.run();\n}\n\nvoid WebSocketServer::on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n    std::string payload = msg->get_payload();\n    if (payload == \"STOP\") {\n        ws_server_->stop();\n    } else {\n        ws_server_->send(hdl, payload, websocketpp::frame::opcode::text);\n    }\n}"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication\n- m_connections: [con_list (std::set<connection_hdl>)] - A set of active client connections\n\nMethods:\n- broadcast_server() - [Constructor] -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events\n- on_open(connection_hdl hdl) -> [void] - Handles new client connections by adding them to the connection set\n- on_close(connection_hdl hdl) -> [void] - Handles client disconnections by removing them from the connection set\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by broadcasting them to all connected clients\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <set>\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.run();\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_server;\n    std::set<websocketpp::connection_hdl> m_connections;\n\n    void on_open(websocketpp::connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::server<websocketpp::config::asio>::message_ptr msg) {\n        for (auto& conn : m_connections) {\n            m_server.send(conn, msg->get_payload(), msg->get_opcode());\n        }\n    }\n};"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <stdexcept>\n#include <iostream>\n\nusing namespace websocketpp::lib;\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&print_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&print_server::on_message, this, _1, _2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        int session_id = m_next_sessionid++;\n        connection_data data = {session_id, \"\"};\n        m_connections[hdl] = data;\n        std::cout << \"Client connected, session ID: \" << session_id << std::endl;\n    }\n\n    void on_close(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it != m_connections.end()) {\n            std::cout << \"Client disconnected, session ID: \" << it->second.session_id << std::endl;\n            m_connections.erase(it);\n        }\n    }\n\n    void on_message(connection_hdl hdl, websocketpp::message_ptr msg) {\n        if (msg->get_type() == websocketpp::message::type::text) {\n            std::string payload = msg->get_payload();\n            if (payload.find(\"name:\") == 0) {\n                std::string name = payload.substr(5);\n                connection_data& data = get_data_from_hdl(hdl);\n                data.name = name;\n                std::cout << \"Client name set to: \" << name << std::endl;\n            } else {\n                std::cout << \"Received message: \" << payload << std::endl;\n                m_server.send(hdl, payload, websocketpp::frame::opcode::text);\n            }\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n        if (it == m_connections.end()) {\n            throw std::out_of_range(\"Connection not found\");\n        }\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    websocketpp::server<websocketpp::config::asio> m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n\n    struct connection_data {\n        int session_id;\n        std::string name;\n    };\n};"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication.\n- m_connections: [con_list] - A set of active connection handles to keep track of connected clients.\n\nMethods:\n- broadcast_server(): [Constructor]() -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events (open, close, message).\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handler for new client connections; adds the connection handle to the active connections set.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handler for client disconnections; removes the connection handle from the active connections set.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Handler for incoming messages; broadcasts the received message to all connected clients.\n- run: [void]([uint16_t port]) -> [void] - Starts the server, begins listening on the specified port, and enters the event loop to handle connections and messages.",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n                \n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n    \n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <set>\n#include <string>\n\nclass broadcast_server {\npublic:\n    broadcast_server();\n    ~broadcast_server();\n    void on_open(websocketpp::connection_hdl hdl);\n    void on_close(websocketpp::connection_hdl hdl);\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::server<websocketpp::config::asio>::message_ptr msg);\n    void run(uint16_t port);\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_server;\n    std::set<websocketpp::connection_hdl> m_connections;\n};\n\nbroadcast_server::broadcast_server() {\n    m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, std::placeholders::_1));\n    m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, std::placeholders::_1));\n    m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, std::placeholders::_1, std::placeholders::_2));\n}\n\nvoid broadcast_server::on_open(websocketpp::connection_hdl hdl) {\n    m_connections.insert(hdl);\n}\n\nvoid broadcast_server::on_close(websocketpp::connection_hdl hdl) {\n    m_connections.erase(hdl);\n}\n\nvoid broadcast_server::on_message(websocketpp::connection_hdl hdl, websocketpp::server<websocketpp::config::asio>::message_ptr msg) {\n    std::string payload = msg->get_payload();\n    for (auto& conn : m_connections) {\n        m_server.send(conn, payload, websocketpp::frame::opcode::text);\n    }\n}\n\nvoid broadcast_server::run(uint16_t port) {\n    m_server.init_asio();\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections and echo back received messages.\n\nClass Description: The utility_server class encapsulates a WebSocket server that listens for incoming connections, receives messages from clients, and echoes them back. It uses WebSocket++ with ASIO for network handling.\n\nAttributes:\n- m_endpoint: [server] - The WebSocket++ server instance that manages connections and message handling.\n\nMethods:\n- utility_server() - [Constructor] -> [void] - Initializes the server with logging settings, ASIO, and sets up the message handler.\n- echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by echoing them back to the client.\n- run() -> [void] - Starts the server, begins listening on port 9002, and runs the ASIO event loop.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <functional>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\n\nclass utility_server {\npublic:\n    utility_server() {\n         // Set logging settings\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all ^ websocketpp::log::alevel::frame_payload);\n\n        // Initialize Asio\n        m_endpoint.init_asio();\n\n        // Set the default message handler to the echo handler\n        m_endpoint.set_message_handler(std::bind(\n            &utility_server::echo_handler, this,\n            std::placeholders::_1, std::placeholders::_2\n        ));\n    }\n\n    void echo_handler(websocketpp::connection_hdl hdl, server::message_ptr msg) {\n        // write a new message\n        m_endpoint.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void run() {\n        // Listen on port 9002\n        m_endpoint.listen(9002);\n\n        // Queues a connection accept operation\n        m_endpoint.start_accept();\n\n        // Start the Asio io_service run loop\n        m_endpoint.run();\n    }\nprivate:\n    server m_endpoint;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <string>\n\nclass utility_server {\npublic:\n    utility_server() {\n        m_endpoint.set_access_channels(websocketpp::log::alevel::all);\n        m_endpoint.set_error_channels(websocketpp::log::elevel::all);\n        m_endpoint.set_message_handler(std::bind(&utility_server::echo_handler, this, _1, _2));\n    }\n\n    void run() {\n        m_endpoint.listen(9002);\n        m_endpoint.start_accept();\n        m_endpoint.run();\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio> m_endpoint;\n\n    void echo_handler(websocketpp::connection_hdl hdl, websocketpp::server<>::message_ptr msg) {\n        std::string payload = msg->get();\n        m_endpoint.send(hdl, payload, websocketpp::frame::opcode::text);\n    }\n};"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Implement a WebSocket broadcast server in C++ using the WebSocket++ library that can handle multiple client connections, manage subscriptions, and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and can broadcast messages to all connected clients. It handles connection events (open/close) and message events using a thread-safe action queue system.\n\nAttributes:\n- m_server: [server] - WebSocket++ server instance configured with ASIO\n- m_connections: [con_list] - Set of active WebSocket connection handles\n- m_actions: [std::queue<action>] - Queue of pending actions to process\n- m_action_lock: [mutex] - Mutex for protecting access to the action queue\n- m_connection_lock: [mutex] - Mutex for protecting access to the connections set\n- m_action_cond: [condition_variable] - Condition variable for action queue notification\n\nMethods:\n- broadcast_server() -> [constructor] - Initializes the WebSocket server and sets up event handlers\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_open(connection_hdl hdl) -> [void] - Handler for new WebSocket connections (adds SUBSCRIBE action)\n- on_close(connection_hdl hdl) -> [void] - Handler for closed WebSocket connections (adds UNSUBSCRIBE action)\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handler for incoming messages (adds MESSAGE action)\n- process_messages() -> [void] - Processes actions from the queue (manages subscriptions and broadcasts messages)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/thread.hpp>\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\nusing websocketpp::lib::thread;\nusing websocketpp::lib::mutex;\nusing websocketpp::lib::lock_guard;\nusing websocketpp::lib::unique_lock;\nusing websocketpp::lib::condition_variable;\n\nenum action_type {\n    SUBSCRIBE,\n    UNSUBSCRIBE,\n    MESSAGE\n};\n\nstruct action {\n    action(action_type t, connection_hdl h) : type(t), hdl(h) {}\n    action(action_type t, connection_hdl h, server::message_ptr m)\n      : type(t), hdl(h), msg(m) {}\n\n    action_type type;\n    websocketpp::connection_hdl hdl;\n    server::message_ptr msg;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        try {\n            m_server.run();\n        } catch (const std::exception & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\n    void on_open(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(SUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(UNSUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(MESSAGE,hdl,msg));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while(1) {\n            unique_lock<mutex> lock(m_action_lock);\n            while(m_actions.empty()) {\n                m_action_cond.wait(lock);\n            }\n\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.type == SUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.type == UNSUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.type == MESSAGE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                con_list::iterator it;\n                for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n                    m_server.send(*it,a.msg);\n                }\n            }\n        }\n    }\n\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl> > con_list;\n    server m_server;\n    con_list m_connections;\n    std::queue<action> m_actions;\n    mutex m_action_lock;\n    mutex m_connection_lock;\n    condition_variable m_action_cond;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <string>\n#include <memory>\n#include <thread>\n\nusing namespace websocketpp::lib;\nusing websocketpp::server;\nusing websocketpp::connection_hdl;\nusing websocketpp::message_ptr;\n\nstruct action {\n    enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n    type t;\n    connection_hdl hdl;\n    std::string payload;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() : m_server(), m_connections(), m_actions(), m_action_lock(), m_connection_lock(), m_action_cond() {\n        m_server.set_connection_handler(bind(&broadcast_server::on_open, this, _1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close, this, _1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        std::thread t(&broadcast_server::process_messages, this);\n        m_server.run();\n        t.join();\n    }\n\nprivate:\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push({action::SUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push({action::UNSUBSCRIBE, hdl, \"\"});\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        std::lock_guard<std::mutex> lock(m_action_lock);\n        m_actions.push({action::MESSAGE, hdl, msg->get_payload()});\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            m_action_cond.wait(lock, [this] { return !m_actions.empty(); });\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            switch (a.t) {\n                case action::SUBSCRIBE:\n                    {\n                        std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                        m_connections.insert(a.hdl);\n                    }\n                    break;\n                case action::UNSUBSCRIBE:\n                    {\n                        std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                        m_connections.erase(a.hdl);\n                    }\n                    break;\n                case action::MESSAGE:\n                    {\n                        std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                        for (auto& hdl : m_connections) {\n                            try {\n                                m_server.send(hdl, a.payload, websocketpp::frame::opcode::text);\n                            } catch (...) {\n                                // Handle error, maybe log\n                            }\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    server m_server;\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::mutex m_connection_lock;\n    std::condition_variable m_action_cond;\n};"
  }
]