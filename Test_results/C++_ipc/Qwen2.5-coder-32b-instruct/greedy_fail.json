[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "#include <httplib.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client cli(location);\n    httplib::Result res;\n\n    if (method == \"GET\") {\n        res = cli.Get(URI.c_str());\n    } else if (method == \"POST\" && request_data != nullptr) {\n        res = cli.Post(URI.c_str(), request_data->dump(), \"application/json\");\n    } else if (method == \"PUT\" && request_data != nullptr) {\n        res = cli.Put(URI.c_str(), request_data->dump(), \"application/json\");\n    } else if (method == \"DELETE\") {\n        res = cli.Delete(URI.c_str());\n    }\n\n    if (res && res->status >= 200 && res->status < 300 && response_data != nullptr) {\n        *response_data = json::parse(res->body);\n    }\n\n    return res ? res->status : -1;\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <cstring>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\n#define MAXSOCK 100\n\nstruct NetworkClientInfo {\n    SOCKET client_sock;\n    sockaddr_storage addr;\n    socklen_t addr_len;\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(const std::string& host, unsigned short port_num)\n        : host(host), port_num(port_num), server_online(false), server_listening(false), socket_count(0) {\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n            ConnectionThread[i] = nullptr;\n        }\n    }\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            std::cerr << \"WSAStartup failed\\n\";\n            return;\n        }\n\n        struct addrinfo hints, *result = nullptr, *ptr = nullptr;\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &result) != 0) {\n            std::cerr << \"getaddrinfo failed\\n\";\n            WSACleanup();\n            return;\n        }\n\n        for (ptr = result; ptr != nullptr; ptr = ptr->ai_next) {\n            server_sock[socket_count] = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET) {\n                continue;\n            }\n\n            if (bind(server_sock[socket_count], ptr->ai_addr, (int)ptr->ai_addrlen) == SOCKET_ERROR) {\n                closesocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            break;\n        }\n\n        freeaddrinfo(result);\n\n        if (ptr == nullptr) {\n            std::cerr << \"Unable to initialize socket\\n\";\n            WSACleanup();\n            return;\n        }\n\n        if (listen(server_sock[socket_count], SOMAXCONN) == SOCKET_ERROR) {\n            closesocket(server_sock[socket_count]);\n            WSACleanup();\n            return;\n        }\n\n        server_online = true;\n        server_listening = true;\n\n        ConnectionThread[socket_count] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, socket_count);\n        ++socket_count;\n    }\n\n    void StopServer() {\n        server_online = false;\n        server_listening = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                shutdown(server_sock[i], SD_SEND);\n                closesocket(server_sock[i]);\n            }\n            if (ConnectionThread[i] && ConnectionThread[i]->joinable()) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n            }\n        }\n\n        WSACleanup();\n    }\n\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            SOCKET client_sock = accept(server_sock[socket_idx], nullptr, nullptr);\n            if (client_sock == INVALID_SOCKET) {\n                if (!server_online) break;\n                continue;\n            }\n\n            NetworkClientInfo* client_info = new NetworkClientInfo{ client_sock };\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n\n            std::thread* client_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_thread->detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n        timeval timeout = { 5, 0 };\n\n        int ret = select(sockfd + 1, &readfds, nullptr, nullptr, &timeout);\n        if (ret > 0) {\n            return accept(sockfd, nullptr, nullptr);\n        } else if (ret == 0) {\n            std::cout << \"Timeout occurred! No data after 5 seconds.\\n\";\n        } else {\n            std::cerr << \"select failed\\n\";\n        }\n        return INVALID_SOCKET;\n    }\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char recvbuf[512];\n        int iResult;\n\n        do {\n            iResult = recv(client_info->client_sock, recvbuf, 512, 0);\n            if (iResult > 0) {\n                // Process received data here\n            } else if (iResult == 0) {\n                std::cout << \"Connection closing...\\n\";\n            } else {\n                std::cerr << \"recv failed\\n\";\n            }\n        } while (iResult > 0);\n\n        closesocket(client_info->client_sock);\n\n        std::lock_guard<std::mutex> lock(ServerClientsMutex);\n        auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n        if (it != ServerClients.end()) {\n            ServerClients.erase(it);\n        }\n        delete client_info;\n    }\n};"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Implement a TCP server in C++ that listens for incoming connections, handles client requests in separate child processes, and responds to clients after processing their data.\n\nFunction Description: The function `tcp_server_communication` creates a TCP server that binds to a specified port, listens for incoming connections, and forks child processes to handle each client connection. Each child process reads a character from the client, increments it after a delay, and sends it back before terminating.\n\nInput: None (The function uses predefined constants: port number 9736 and INADDR_ANY for binding to all available network interfaces)\n\nOutput: None (The function runs indefinitely, servicing client requests and doesn't return any value)\n\nNote: The function includes signal handling to prevent zombie processes from terminated child processes. Each client connection is handled in a separate child process while the parent process continues to accept new connections.",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <signal.h>\n\nvoid tcp_server_communication()\n{\n    int server_sockfd = -1;\n    int client_sockfd = -1;\n    int client_len = 0;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n    \n    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(9736);\n    \n    bind(server_sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(server_sockfd, 5);\n    signal(SIGCHLD, SIG_IGN);\n\n    while(1)\n    {\n        char ch = '\\0';\n        client_len = sizeof(client_addr);\n        client_sockfd = accept(server_sockfd, (struct sockaddr*)&client_addr,\n                               (socklen_t *)&client_len);\n\n        if(fork() == 0)\n        {\n            read(client_sockfd, &ch, 1);\n            sleep(5);\n            ch++;\n            write(client_sockfd, &ch, 1);\n            close(client_sockfd);\n            exit(0);\n        }\n        else\n        {\n            close(client_sockfd);\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\nconst int PORT = 9736;\nconst int BACKLOG = 10;\n\nvoid handle_client(int client_socket) {\n    char buffer[2];\n    if (read(client_socket, buffer, 1) <= 0) {\n        close(client_socket);\n        exit(0);\n    }\n    sleep(1); // Simulate processing delay\n    buffer[0]++;\n    write(client_socket, buffer, 1);\n    close(client_socket);\n    exit(0);\n}\n\nvoid tcp_server_communication() {\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (server_socket < 0) {\n        std::cerr << \"Error opening socket\";\n        exit(1);\n    }\n\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(PORT);\n\n    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Error on binding\";\n        close(server_socket);\n        exit(1);\n    }\n\n    listen(server_socket, BACKLOG);\n    signal(SIGCHLD, SIG_IGN);\n\n    while (true) {\n        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_len);\n        if (client_socket < 0) {\n            std::cerr << \"Error on accept\";\n            continue;\n        }\n\n        pid_t pid = fork();\n        if (pid == 0) {\n            close(server_socket);\n            handle_client(client_socket);\n        } else if (pid > 0) {\n            close(client_socket);\n        } else {\n            std::cerr << \"Error on fork\";\n            close(client_socket);\n        }\n    }\n\n    close(server_socket);\n}"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests to a specified base URL.\n\nClass Description: The HTTPClient class provides a simple interface for making HTTP GET requests to a given base URL. It handles libcurl initialization, request configuration, execution, and cleanup, while providing a method to append endpoints to the base URL and make requests.\n\nAttributes:\nbaseURL: std::string - The base URL to which endpoints will be appended for HTTP requests\n\nMethods:\nmakeRequest: makeRequest(const std::string& endpoint) -> std::string - Makes an HTTP GET request to the base URL plus the specified endpoint, returning the response as a string\nwrite_to_string: write_to_string(void* ptr, size_t size, size_t count, void* stream) -> size_t - Static callback function for libcurl to write response data into a string",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <sstream>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string URL = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, URL.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_perform(curl);\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, 0, size*count);\n        return size*count;\n    }\n\n    std::string baseURL;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "wrong_result": "#include <iostream>\n#include <string>\n#include <curl/curl.h>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& url) : baseURL(url) {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl = curl_easy_init();\n    }\n\n    ~HTTPClient() {\n        if(curl) {\n            curl_easy_cleanup(curl);\n        }\n        curl_global_cleanup();\n    }\n\n    std::string makeRequest(const std::string& endpoint) {\n        if(!curl) {\n            return \"\";\n        }\n\n        std::string fullURL = baseURL + endpoint;\n        curl_easy_setopt(curl, CURLOPT_URL, fullURL.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if(res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n            return \"\";\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* str = static_cast<std::string*>(stream);\n        str->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    CURL* curl;\n    std::string baseURL;\n    std::string response;\n};"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "#include <boost/beast/core.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/spawn.hpp>\n#include <boost/asio/steady_timer.hpp>\n#include <boost/asio/connect.hpp>\n#include <boost/asio/write.hpp>\n#include <boost/asio/read.hpp>\n#include <boost/asio/buffer.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl/stream.hpp>\n#include <boost/asio/io_context.hpp>\n#include <boost/asio/spawn.hpp>\n#include <memory>\n#include <string>\n#include <optional>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nusing tcp = net::ip::tcp;\nnamespace ssl = net::ssl;\n\nstruct Device {\n    std::string host;\n    std::string port;\n    bool use_ssl;\n};\n\nclass Logging {\npublic:\n    void log(const std::string& message) {\n        // Logging implementation\n    }\n};\n\nclass WebOsClient {\npublic:\n    class Impl {\n    public:\n        Impl(net::io_context& ioc, ssl::context& ctx, Device& device_settings, std::shared_ptr<Logging> log)\n            : ioc_(ioc), ctx_(ctx), device_settings_(device_settings), log_(log), resolver_(ioc_) {}\n\n        void run() {\n            host_ = device_settings_.host + \":\" + device_settings_.port;\n            resolver_.async_resolve(host_, device_settings_.use_ssl ? \"wss\" : \"ws\",\n                [this](beast::error_code ec, tcp::resolver::results_type results) {\n                    onResolve(ec, results);\n                });\n        }\n\n        void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n            if (ec) return onError(ec, \"resolve\");\n            if (device_settings_.use_ssl) {\n                beast::get_lowest_layer(*ws_).async_connect(results,\n                    [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                        onConnect(ec, ep);\n                    });\n            } else {\n                beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                    [this](beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n                        onConnect(ec, ep);\n                    });\n            }\n        }\n\n        void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n            if (ec) return onError(ec, \"connect\");\n            if (device_settings_.use_ssl) {\n                ws_->next_layer().async_handshake(ssl::stream_base::client,\n                    [this](beast::error_code ec) {\n                        onSSLhandshake(ec);\n                    });\n            } else {\n                ws_tcp_->async_handshake(host_, \"/\",\n                    [this](beast::error_code ec) {\n                        onWinsockHandshake(ec);\n                    });\n            }\n        }\n\n        void onSSLhandshake(beast::error_code ec) {\n            if (ec) return onError(ec, \"ssl handshake\");\n            ws_->async_handshake(host_, \"/\",\n                [this](beast::error_code ec) {\n                    onWinsockHandshake(ec);\n                });\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) return onError(ec, \"handshake\");\n            socket_status_ = 2; // connected\n            read();\n        }\n\n        void send(std::string text, std::string type) {\n            if (device_settings_.use_ssl) {\n                ws_->async_write(net::buffer(text),\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            } else {\n                ws_tcp_->async_write(net::buffer(text),\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onWrite(ec, bytes_transferred);\n                    });\n            }\n        }\n\n        void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n            if (ec) return onError(ec, \"write\");\n            // Handle write completion\n        }\n\n        void read() {\n            if (device_settings_.use_ssl) {\n                ws_->async_read(buffer_,\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onRead(ec, bytes_transferred);\n                    });\n            } else {\n                ws_tcp_->async_read(buffer_,\n                    [this](beast::error_code ec, std::size_t bytes_transferred) {\n                        onRead(ec, bytes_transferred);\n                    });\n            }\n        }\n\n        void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n            if (ec) return onError(ec, \"read\");\n            // Process received message\n            read(); // Continue reading\n        }\n\n        void onError(beast::error_code& ec, std::string where) {\n            log_->log(\"Error in \" + where + \": \" + ec.message());\n            close();\n        }\n\n        void enqueueWork(Work& work) {\n            // Add work to processing queue\n        }\n\n        void close() {\n            if (device_settings_.use_ssl) {\n                ws_->async_close(websocket::close_code::normal,\n                    [this](beast::error_code ec) {\n                        if (ec) onError(ec, \"close\");\n                    });\n            } else {\n                ws_tcp_->async_close(websocket::close_code::normal,\n                    [this](beast::error_code ec) {\n                        if (ec) onError(ec, \"close\");\n                    });\n            }\n        }\n\n    private:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device& device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_ = 0; // disconnected\n    };\n};"
  }
]