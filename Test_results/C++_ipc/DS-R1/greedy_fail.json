[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "#include <cpp-httplib/httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\ntemplate<typename ClientType>\nstd::shared_ptr<httplib::Response> SendRequestHelper(ClientType& cli, const std::string& method, const std::string& uri, const httplib::Headers& headers, const std::string& body, const std::string& content_type) {\n    if (method == \"GET\") return cli.Get(uri.c_str(), headers);\n    else if (method == \"POST\") return cli.Post(uri.c_str(), headers, body, content_type.c_str());\n    else if (method == \"PUT\") return cli.Put(uri.c_str(), headers, body, content_type.c_str());\n    else if (method == \"DELETE\") return cli.Delete(uri.c_str(), headers, body, content_type.c_str());\n    return nullptr;\n}\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, const json* request_data, json* response_data) {\n    std::string protocol = \"http\";\n    std::string host = location;\n    int port = 80;\n\n    if (location.find(\"https://\") == 0) {\n        protocol = \"https\";\n        host = location.substr(8);\n        port = 443;\n    }\n    else if (location.find(\"http://\") == 0) {\n        host = location.substr(7);\n    }\n\n    size_t colon_pos = host.find(':');\n    if (colon_pos != std::string::npos) {\n        try { port = std::stoi(host.substr(colon_pos + 1)); }\n        catch (...) { return 0; }\n        host = host.substr(0, colon_pos);\n    }\n\n    httplib::Headers headers;\n    std::string body, content_type = \"application/json\";\n    if (request_data && (method == \"POST\" || method == \"PUT\" || method == \"DELETE\")) {\n        body = request_data->dump();\n        headers.emplace(\"Content-Type\", content_type);\n    }\n\n    std::shared_ptr<httplib::Response> res;\n    if (protocol == \"https\") {\n        httplib::SSLClient cli(host.c_str(), port);\n        cli.set_connection_timeout(30);\n        res = SendRequestHelper(cli, method, URI, headers, body, content_type);\n    }\n    else {\n        httplib::Client cli(host.c_str(), port);\n        cli.set_connection_timeout(30);\n        res = SendRequestHelper(cli, method, URI, headers, body, content_type);\n    }\n\n    if (res) {\n        long status = res->status;\n        if (status >= 200 && status < 300 && response_data && !res->body.empty()) {\n            try { *response_data = json::parse(res->body); }\n            catch (...) {}\n        }\n        return status;\n    }\n    return 0;\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <vector>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <poll.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <sys/select.h>\n#define SOCKET int\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#endif\n\n#define MAXSOCK 2\n#define MAX_CONN 10\n#define ACCEPT_TIMEOUT 1\n\nclass NetworkClientInfo {\npublic:\n    SOCKET sock;\n    sockaddr_storage addr;\n    std::thread* listen_thread;\n};\n\nclass RGBController;\n\nclass NetworkServer {\nprivate:\n    std::vector<RGBController*>& controllers;\n    std::string host;\n    unsigned short port_num;\n    std::atomic<bool> server_online{false};\n    std::atomic<bool> server_listening{false};\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count = 0;\n    std::thread* ConnectionThread[MAXSOCK];\n\n    void CloseSocket(SOCKET s) {\n#ifdef _WIN32\n        closesocket(s);\n#else\n        close(s);\n#endif\n    }\n\npublic:\n    NetworkServer(std::vector<RGBController*>& control) : controllers(control) {\n        memset(server_sock, INVALID_SOCKET, sizeof(server_sock));\n    }\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        if (server_online) return;\n\n        server_online = true;\n        struct addrinfo hints, *res, *p;\n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n\n        if (getaddrinfo(host.c_str(), std::to_string(port_num).c_str(), &hints, &res) != 0) {\n            server_online = false;\n            return;\n        }\n\n        for (p = res, socket_count = 0; p != nullptr && socket_count < MAXSOCK; p = p->ai_next) {\n            server_sock[socket_count] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET) continue;\n\n            int opt = 1;\n#ifdef _WIN32\n            setsockopt(server_sock[socket_count], SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));\n#else\n            setsockopt(server_sock[socket_count], SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n#endif\n\n            if (p->ai_family == AF_INET6) {\n                int ipv6only = 0;\n                setsockopt(server_sock[socket_count], IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&ipv6only, sizeof(ipv6only));\n            }\n\n            if (bind(server_sock[socket_count], p->ai_addr, p->ai_addrlen) == SOCKET_ERROR) {\n                CloseSocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            if (listen(server_sock[socket_count], MAX_CONN) == SOCKET_ERROR) {\n                CloseSocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            ConnectionThread[socket_count] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, socket_count);\n            socket_count++;\n        }\n\n        freeaddrinfo(res);\n        if (socket_count == 0) {\n            server_online = false;\n            return;\n        }\n\n        server_listening = true;\n    }\n\n    void StopServer() {\n        if (!server_online) return;\n        server_online = false;\n        server_listening = false;\n\n        for (int i = 0; i < socket_count; i++) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                CloseSocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n            if (ConnectionThread[i]) {\n                if (ConnectionThread[i]->joinable()) {\n                    ConnectionThread[i]->join();\n                }\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        std::lock_guard<std::mutex> lock(ServerClientsMutex);\n        for (auto client : ServerClients) {\n            CloseSocket(client->sock);\n            if (client->listen_thread && client->listen_thread->joinable()) {\n                client->listen_thread->join();\n                delete client->listen_thread;\n            }\n            delete client;\n        }\n        ServerClients.clear();\n    }\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            int new_sock = accept_select(server_sock[socket_idx]);\n            if (new_sock == INVALID_SOCKET) continue;\n\n            NetworkClientInfo* client_info = new NetworkClientInfo;\n            client_info->sock = new_sock;\n            client_info->listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            ServerClients.push_back(client_info);\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set set;\n        struct timeval timeout;\n        FD_ZERO(&set);\n        FD_SET(sockfd, &set);\n        timeout.tv_sec = ACCEPT_TIMEOUT;\n        timeout.tv_usec = 0;\n\n        int rv = select(sockfd + 1, &set, nullptr, nullptr, &timeout);\n        if (rv == SOCKET_ERROR) return INVALID_SOCKET;\n        if (rv == 0) return INVALID_SOCKET;\n\n        struct sockaddr_storage client_addr;\n        socklen_t addr_size = sizeof(client_addr);\n        SOCKET new_sock = accept(sockfd, (struct sockaddr*)&client_addr, &addr_size);\n        if (new_sock == INVALID_SOCKET) return INVALID_SOCKET;\n\n        return new_sock;\n    }\n\n    unsigned short GetPort() { return port_num; }\n    void ClientInfoChanged() {}\n    void ServerListeningChanged() {}\n    void ListenThreadFunction(NetworkClientInfo* client_info) {}\n};"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "class WebOsClient::Impl {\npublic:\n    Impl(net::io_context& ioc, ssl::context& ctx, Device& device, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(device),\n          log_(std::make_shared<Logging>(log)), resolver_(net::make_strand(ioc)) {\n        host_ = device_settings_.host + \":\" + std::to_string(device_settings_.port);\n        socket_status_ = 0;\n    }\n\n    void run() {\n        socket_status_ = 1;\n        resolver_.async_resolve(device_settings_.host, std::to_string(device_settings_.port),\n            beast::bind_front_handler(&Impl::onResolve, this));\n    }\n\n    void send(std::string data, std::string) {\n        if(socket_status_ != 2) return;\n        auto shared_msg = std::make_shared<std::string>(std::move(data));\n        if(ws_) {\n            ws_->async_write(net::buffer(*shared_msg),\n                [this, shared_msg](beast::error_code ec, size_t) { onWrite(ec); });\n        } else {\n            ws_tcp_->async_write(net::buffer(*shared_msg),\n                [this, shared_msg](beast::error_code ec, size_t) { onWrite(ec); });\n        }\n    }\n\n    void close() {\n        if(socket_status_ == 0) return;\n        socket_status_ = 0;\n        auto shutdown = [this](beast::error_code ec) { if(ec) onError(ec, \"close\"); };\n        if(ws_) ws_->async_close(websocket::close_code::none, shutdown);\n        if(ws_tcp_) ws_tcp_->async_close(websocket::close_code::none, shutdown);\n    }\n\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if(ec) return onError(ec, \"resolve\");\n        if(device_settings_.use_ssl) {\n            ws_.emplace(net::make_strand(ioc_), ctx_);\n            SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.host.c_str());\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, this));\n        } else {\n            ws_tcp_.emplace(net::make_strand(ioc_));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, this));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type) {\n        if(ec) return onError(ec, \"connect\");\n        if(device_settings_.use_ssl) {\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, this));\n        } else {\n            ws_tcp_->async_handshake(host_, device_settings_.path,\n                beast::bind_front_handler(&Impl::onWinsockHandshake, this));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if(ec) return onError(ec, \"ssl_handshake\");\n        ws_->async_handshake(host_, device_settings_.path,\n            beast::bind_front_handler(&Impl::onWinsockHandshake, this));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if(ec) return onError(ec, \"ws_handshake\");\n        socket_status_ = 2;\n        read();\n    }\n\n    void read() {\n        auto read_handler = [this](beast::error_code ec, size_t) { onRead(ec); };\n        if(ws_) ws_->async_read(buffer_, read_handler);\n        else ws_tcp_->async_read(buffer_, read_handler);\n    }\n\n    void onRead(beast::error_code ec) {\n        if(ec) return onError(ec, \"read\");\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onWrite(beast::error_code ec) {\n        if(ec) onError(ec, \"write\");\n    }\n\n    void onError(beast::error_code ec, std::string where) {\n        log_->error(where + \": \" + ec.message());\n        close();\n    }\n\n    void enqueueWork(Work&) {}\n};"
  }
]