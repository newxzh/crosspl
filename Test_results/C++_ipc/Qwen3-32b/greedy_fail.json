[
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "```cpp\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <thread>\n#include <vector>\n#include <mutex>\n#include <string>\n#include <stdexcept>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\n#define MAXSOCK 10\n\nclass NetworkClientInfo {\npublic:\n    SOCKET socket;\n    NetworkClientInfo(SOCKET sock) : socket(sock) {}\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<RGBController*>& control) \n        : host(\"0.0.0.0\"), port_num(0), server_online(false), server_listening(false), socket_count(0) {\n        for (int i = 0; i < MAXSOCK; ++i) {\n            server_sock[i] = INVALID_SOCKET;\n            ConnectionThread[i] = nullptr;\n        }\n    }\n\n    ~NetworkServer() {\n        StopServer();\n    }\n\n    void StartServer() {\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            throw std::runtime_error(\"WSAStartup failed\");\n        }\n\n        server_online = true;\n        server_listening = true;\n\n        struct addrinfo hints, *res, *rp;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n        hints.ai_protocol = 0;\n\n        std::string port_str = std::to_string(port_num);\n        int s = getaddrinfo(host.empty() ? nullptr : host.c_str(), port_str.c_str(), &hints, &res);\n        if (s != 0) {\n            WSACleanup();\n            throw std::runtime_error(\"getaddrinfo failed\");\n        }\n\n        socket_count = 0;\n        for (rp = res; rp != nullptr && socket_count < MAXSOCK; rp = rp->ai_next) {\n            server_sock[socket_count] = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET) {\n                continue;\n            }\n\n            int optval = 1;\n            setsockopt(server_sock[socket_count], SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof(optval));\n\n            if (bind(server_sock[socket_count], rp->ai_addr, (int)rp->ai_addrlen) == SOCKET_ERROR) {\n                closesocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            if (listen(server_sock[socket_count], SOMAXCONN) == SOCKET_ERROR) {\n                closesocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            ConnectionThread[socket_count] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, socket_count);\n            socket_count++;\n        }\n\n        freeaddrinfo(res);\n\n        if (socket_count == 0) {\n            StopServer();\n            throw std::runtime_error(\"Failed to create any server sockets\");\n        }\n\n        ServerListeningChanged();\n    }\n\n    void StopServer() {\n        server_online = false;\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (ConnectionThread[i]) {\n                ConnectionThread[i]->join();\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n        }\n\n        for (int i = 0; i < socket_count; ++i) {\n            if (server_sock[i] != INVALID_SOCKET) {\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            for (auto client : ServerClients) {\n                delete client;\n            }\n            ServerClients.clear();\n        }\n\n        WSACleanup();\n\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    unsigned short GetPort() const {\n        return port_num;\n    }\n\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread* ConnectionThread[MAXSOCK];\n\n    void ConnectionThreadFunction(int socket_idx) {\n        while (server_online) {\n            SOCKET client_sock = accept_select(server_sock[socket_idx]);\n            if (client_sock == INVALID_SOCKET) {\n                if (!server_online) {\n                    break;\n                }\n                continue;\n            }\n\n            NetworkClientInfo* client_info = new NetworkClientInfo(client_sock);\n            {\n                std::lock_guard<std::mutex> lock(ServerClientsMutex);\n                ServerClients.push_back(client_info);\n            }\n            ClientInfoChanged();\n\n            std::thread listen_thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            listen_thread.detach();\n        }\n    }\n\n    int accept_select(int sockfd) {\n        fd_set readfds;\n        FD_ZERO(&readfds);\n        FD_SET(sockfd, &readfds);\n\n        timeval timeout;\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int ret = select(0, &readfds, nullptr, nullptr, &timeout);\n        if (ret == SOCKET_ERROR) {\n            return INVALID_SOCKET;\n        }\n\n        if (ret == 0) {\n            return INVALID_SOCKET;\n        }\n\n        sockaddr_in client_addr;\n        int client_len = sizeof(client_addr);\n        SOCKET client_sock = accept(sockfd, (sockaddr*)&client_addr, &client_len);\n        if (client_sock == INVALID_SOCKET) {\n            return INVALID_SOCKET;\n        }\n\n        return client_sock;\n    }\n\n    void ClientInfoChanged() {}\n\n    void ServerListeningChanged() {}\n\n    void ListenThreadFunction(NetworkClientInfo* client_info) {\n        char buffer[1024];\n        int bytes_received;\n\n        while (server_online) {\n            bytes_received = recv(client_info->socket, buffer, sizeof(buffer), 0);\n            if (bytes_received <= 0) {\n                break;\n            }\n\n            send(client_info->socket, buffer, bytes_received, 0);\n        }\n\n        {\n            std::lock_guard<std::mutex> lock(ServerClientsMutex);\n            auto it = std::find(ServerClients.begin(), ServerClients.end(), client_info);\n            if (it != ServerClients.end()) {\n                ServerClients.erase(it);\n            }\n        }\n        delete client_info;\n        ClientInfoChanged();\n    }\n};\n```"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a UDP receiver class in C++ that listens for incoming UDP packets on a specified port, processes them, and forwards them to a network handling component. The class should handle socket creation, binding, and packet reception in a non-blocking manner using polling.\n\nClass Description: The `UDPRecv` class is responsible for setting up a UDP socket server that listens for incoming messages on a specified port. It uses polling to check for incoming data without blocking, and forwards received messages to a network handling component (`DFNetWork`). The class manages the socket lifecycle and provides methods to initialize, start, and stop the receiver.\n\nAttributes:\n- m_poDFNetWork: [DFNetWork*] - Pointer to the network handling component that processes received messages\n- m_iSockFD: [int] - File descriptor for the UDP socket\n- m_bIsEnd: [bool] - Flag indicating whether the receiver should stop running\n- m_bIsStarted: [bool] - Flag indicating whether the receiver has started\n\nMethods:\n- UDPRecv(DFNetWork* poDFNetWork) -> [void] - Constructor that initializes the receiver with a network handling component\n- ~UDPRecv() -> [void] - Destructor that closes the socket if it's open\n- Stop() -> [void] - Signals the receiver to stop and waits for it to finish\n- Init(int iPort) -> [int] - Initializes the UDP socket and binds it to the specified port (returns 0 on success, -1 on failure)\n- run() -> [void] - Main execution loop that polls for incoming messages and processes them (runs in a separate thread)",
    "Canonical_solution": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include \"dfnetwork.h\"\n\nnamespace phxpaxos {\n\nclass UDPRecv\n{\npublic:\n    UDPRecv(DFNetWork * poDFNetWork);\n    ~UDPRecv();\n\n    void Stop();\n    int Init(const int iPort);\n    void run();\n\nprivate:\n    DFNetWork * m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n};\n\nUDPRecv::UDPRecv(DFNetWork * poDFNetWork) \n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false)\n{\n}\n\nUDPRecv::~UDPRecv()\n{\n    if (m_iSockFD != -1)\n    {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n    }\n}\n\nvoid UDPRecv::Stop()\n{\n    if (m_bIsStarted)\n    {\n        m_bIsEnd = true;\n        join();\n    }\n}\n\nint UDPRecv::Init(const int iPort)\n{\n    if ((m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0)) < 0) \n    {\n        return -1;\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(iPort);\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    int enable = 1;\n    setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int));\n\n    if (bind(m_iSockFD, (struct sockaddr *)&addr, sizeof(addr)) < 0) \n    {\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid UDPRecv::run()\n{\n    m_bIsStarted = true;\n\n    char sBuffer[65536] = {0};\n\n    struct sockaddr_in addr;\n    socklen_t addr_len = sizeof(struct sockaddr_in);\n    memset(&addr, 0, sizeof(addr));\n\n    while(true)\n    {\n        if (m_bIsEnd)\n        {\n            return;\n        }\n\n        struct pollfd fd;\n        int ret;\n\n        fd.fd = m_iSockFD;\n        fd.events = POLLIN;\n        ret = poll(&fd, 1, 500);\n\n        if (ret == 0 || ret == -1)\n        {\n            continue;\n        }\n        \n        int iRecvLen = recvfrom(m_iSockFD, sBuffer, sizeof(sBuffer), 0,\n                (struct sockaddr *)&addr, &addr_len);\n\n        if (iRecvLen > 0)\n        {\n            m_poDFNetWork->OnReceiveMessage(sBuffer, iRecvLen);\n        }\n    }\n}\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 152,
    "wrong_result": "#include <iostream>\n#include <thread>\n#include <poll.h>\n#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nclass DFNetWork; // Forward declaration\n\nclass UDPRecv {\npublic:\n    UDPRecv(DFNetWork* poDFNetWork);\n    ~UDPRecv();\n    void Stop();\n    int Init(int iPort);\n    void run();\n\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n    std::thread m_thread;\n};\n\nUDPRecv::UDPRecv(DFNetWork* poDFNetWork)\n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false) {}\n\nUDPRecv::~UDPRecv() {\n    Stop();\n    if (m_iSockFD != -1) {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n    }\n}\n\nvoid UDPRecv::Stop() {\n    m_bIsEnd = true;\n    if (m_thread.joinable()) {\n        m_thread.join();\n    }\n    m_bIsStarted = false;\n}\n\nint UDPRecv::Init(int iPort) {\n    m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n    if (m_iSockFD < 0) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    struct sockaddr_in servAddr;\n    memset(&servAddr, 0, sizeof(servAddr));\n    servAddr.sin_family = AF_INET;\n    servAddr.sin_port = htons(iPort);\n    servAddr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(m_iSockFD, (struct sockaddr*)&servAddr, sizeof(servAddr)) < 0) {\n        perror(\"bind\");\n        close(m_iSockFD);\n        return -1;\n    }\n\n    m_bIsStarted = true;\n    m_thread = std::thread(&UDPRecv::run, this);\n    return 0;\n}\n\nvoid UDPRecv::run() {\n    const int BUFFER_SIZE = 65535;\n    char buffer[BUFFER_SIZE];\n    struct pollfd fds[1];\n    fds[0].fd = m_iSockFD;\n    fds[0].events = POLLIN;\n\n    while (!m_bIsEnd) {\n        int pollResult = poll(fds, 1, 1000);\n        if (pollResult == -1) {\n            perror(\"poll\");\n            break;\n        } else if (pollResult > 0) {\n            if (fds[0].revents & POLLIN) {\n                struct sockaddr_in cliAddr;\n                socklen_t cliAddrLen = sizeof(cliAddr);\n                ssize_t recvLen = recvfrom(m_iSockFD, buffer, BUFFER_SIZE, 0,\n                                           (struct sockaddr*)&cliAddr, &cliAddrLen);\n                if (recvLen > 0) {\n                    m_poDFNetWork->process(buffer, recvLen);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, process incoming messages, and echo messages back to clients. The server should also support stopping the listening process upon receiving a specific command.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, managing connection handling, message processing, and server lifecycle operations.\n\nAttributes:\n- service_: [asio::io_service&] - Reference to the ASIO I/O service used for network operations\n- port_: [int] - The port number on which the server listens for connections\n- ws_server_: [ws_echo_server] - The WebSocket++ server instance\n\nMethods:\n- Constructor: [WebSocketServer]([asio::io_service& service, int port]) -> [void] - Initializes the WebSocket++ server, sets up logging, message handling, and starts listening on the specified port\n- on_message: [on_message]([websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg]) -> [void] - Callback function that processes incoming messages, echoes them back to clients, and handles the stop-listening command\n- run: [run]() -> [void] - Starts the server's event loop to handle connections and messages",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port) \n        : service_(service), port_(port) {\n        ws_server_.set_access_channels(websocketpp::log::alevel::all);\n        ws_server_.clear_access_channels(websocketpp::log::alevel::frame_payload);\n        ws_server_.init_asio(&service_);\n        ws_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        if (msg->get_payload() == \"stop-listening\") {\n            ws_server_.stop_listening();\n            return;\n        }\n\n        try {\n            ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void run() {\n        service_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\ntypedef websocketpp::server<websocketpp::config::asio> ws_echo_server;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(asio::io_service& service, int port)\n        : service_(service), port_(port), ws_server_() {\n        ws_server_.set_message_handler(\n            boost::bind(&WebSocketServer::on_message, this, _1, _2)\n        );\n        ws_server_.init_asio();\n        ws_server_.listen(port_);\n        ws_server_.start_accept();\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, ws_echo_server::message_ptr msg) {\n        ws_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n        if (msg->get_payload() == \"stop\") {\n            ws_server_.stop();\n        }\n    }\n\n    void run() {\n        ws_server_.run();\n    }\n\nprivate:\n    asio::io_service& service_;\n    int port_;\n    ws_echo_server ws_server_;\n};"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication\n- m_connections: [con_list (std::set<connection_hdl>)] - A set of active client connections\n\nMethods:\n- broadcast_server() - [Constructor] -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events\n- on_open(connection_hdl hdl) -> [void] - Handles new client connections by adding them to the connection set\n- on_close(connection_hdl hdl) -> [void] - Handles client disconnections by removing them from the connection set\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by broadcasting them to all connected clients\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <set>\n#include <functional>\n#include <memory>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, std::placeholders::_1, std::placeholders::_2));\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, std::placeholders::_1));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto const& conn : m_connections) {\n            m_server.send(conn, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    std::set<connection_hdl> m_connections;\n};"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections, process incoming messages, and support configurable threading for concurrent operations.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server implementation, providing methods to initialize, configure, and run the server with customizable port and threading settings.\n\nAttributes:\n- testee_server_: [server] - The WebSocket++ server instance that manages connections and message handling\n- port_: [short] - The port number on which the server listens for incoming connections\n- num_threads_: [size_t] - The number of threads to use for handling connections (1 for single-threaded mode)\n\nMethods:\n- WebSocketServer([short port = 9002], [size_t num_threads = 1]) -> [void] - Constructor that initializes the server with specified port and thread count (defaults to port 9002 and single-threaded)\n- run() -> [void] - Starts the WebSocket server, sets up message handlers, begins listening on the specified port, and manages the server's event loop(s)\n- on_message([websocketpp::connection_hdl hdl], [message_ptr msg]) -> [void] - Message handler that echoes received messages back to the client (private method)\n- on_socket_init([websocketpp::connection_hdl hdl], [boost::asio::ip::tcp::socket & s]) -> [void] - Socket initialization handler that enables TCP_NODELAY for reduced latency (private method)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/extensions/permessage_deflate/enabled.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <websocketpp/common/thread.hpp>\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::message_ptr message_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) \n        : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        try {\n            testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n            testee_server_.clear_error_channels(websocketpp::log::alevel::all);\n\n            testee_server_.init_asio();\n            testee_server_.set_reuse_addr(true);\n\n            testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n            testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, ::_1, ::_2));\n\n            testee_server_.set_listen_backlog(8192);\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n\n            if (num_threads_ == 1) {\n                testee_server_.run();\n            } else {\n                std::vector<websocketpp::lib::shared_ptr<websocketpp::lib::thread>> ts;\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts.push_back(websocketpp::lib::make_shared<websocketpp::lib::thread>(&server::run, &testee_server_));\n                }\n\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts[i]->join();\n                }\n            }\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket & s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <thread>\n#include <memory>\n#include <vector>\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) \n        : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        testee_server_.set_message_handler(\n            std::bind(&WebSocketServer::on_message, this, std::placeholders::_1, std::placeholders::_2)\n        );\n        testee_server_.set_socket_init_handler(\n            std::bind(&WebSocketServer::on_socket_init, this, std::placeholders::_1, std::placeholders::_2)\n        );\n\n        testee_server_.listen(port_);\n        testee_server_.start_accept();\n\n        if (num_threads_ == 1) {\n            testee_server_.run();\n        } else {\n            std::vector<std::thread> threads;\n            for (size_t i = 0; i < num_threads_; ++i) {\n                threads.emplace_back(&server::run, &testee_server_);\n            }\n            for (auto& t : threads) {\n                t.join();\n            }\n        }\n    }\n\nprivate:\n    using server = websocketpp::server<websocketpp::config::asio>;\n    using message_ptr = typename server::message_ptr;\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket& s) {\n        s.set_option(boost::asio::ip::tcp::no_delay(true));\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <map>\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <functional>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::connection_hdl connection_hdl;\n\nclass print_server {\npublic:\n    print_server();\n    void on_open(connection_hdl hdl);\n    void on_close(connection_hdl hdl);\n    void on_message(connection_hdl hdl, server::message_ptr msg);\n    connection_data& get_data_from_hdl(connection_hdl hdl);\n    void run(uint16_t port);\nprivate:\n    int m_next_sessionid;\n    server m_server;\n    std::map<connection_hdl, connection_data, std::owner_less<connection_hdl>> m_connections;\n    struct connection_data {\n        int session_id;\n        std::string name;\n    };\n};\n\nprint_server::print_server() : m_next_sessionid(1) {\n    m_server.set_message_handler(std::bind(&print_server::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    m_server.set_open_handler(std::bind(&print_server::on_open, this, std::placeholders::_1));\n    m_server.set_close_handler(std::bind(&print_server::on_close, this, std::placeholders::_1));\n}\n\nvoid print_server::on_open(connection_hdl hdl) {\n    int session_id = m_next_sessionid++;\n    m_connections[hdl] = { session_id, \"\" };\n    std::cout << \"New connection. Session ID: \" << session_id << \", Handle: \" << hdl.lock().get() << std::endl;\n}\n\nvoid print_server::on_close(connection_hdl hdl) {\n    m_connections.erase(hdl);\n    std::cout << \"Connection closed. Handle: \" << hdl.lock().get() << std::endl;\n}\n\nvoid print_server::on_message(connection_hdl hdl, server::message_ptr msg) {\n    connection_data& data = get_data_from_hdl(hdl);\n    if (data.name.empty()) {\n        data.name = msg->get_payload();\n        std::cout << \"Set client name to \" << data.name << \" (Session ID: \" << data.session_id << \")\" << std::endl;\n    } else {\n        std::cout << \"Message from \" << data.name << \" (Session ID: \" << data.session_id << \"): \" << msg->get_payload() << std::endl;\n    }\n}\n\nprint_server::connection_data& print_server::get_data_from_hdl(connection_hdl hdl) {\n    auto it = m_connections.find(hdl);\n    if (it == m_connections.end()) {\n        throw std::runtime_error(\"Connection not found\");\n    }\n    return it->second;\n}\n\nvoid print_server::run(uint16_t port) {\n    m_server.init_asio();\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication.\n- m_connections: [con_list] - A set of active connection handles to keep track of connected clients.\n\nMethods:\n- broadcast_server(): [Constructor]() -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events (open, close, message).\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handler for new client connections; adds the connection handle to the active connections set.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handler for client disconnections; removes the connection handle from the active connections set.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Handler for incoming messages; broadcasts the received message to all connected clients.\n- run: [void]([uint16_t port]) -> [void] - Starts the server, begins listening on the specified port, and enters the event loop to handle connections and messages.",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n                \n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n    \n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <set>\n#include <mutex>\n\nusing namespace websocketpp;\n\nclass broadcast_server {\npublic:\n    typedef server<config::asio> server;\n    typedef server::connection_hdl connection_hdl;\n    typedef std::set<connection_hdl> con_list;\n\n    broadcast_server() {\n        m_server.set_open_handler(std::bind(&broadcast_server::on_open, this, std::placeholders::_1));\n        m_server.set_close_handler(std::bind(&broadcast_server::on_close, this, std::placeholders::_1));\n        m_server.set_message_handler(std::bind(&broadcast_server::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connections_mutex);\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        std::lock_guard<std::mutex> lock(m_connections_mutex);\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        con_list connections;\n        {\n            std::lock_guard<std::mutex> lock(m_connections_mutex);\n            connections = m_connections;\n        }\n\n        for (auto const& conn : connections) {\n            m_server.send(conn, msg->get_payload(), msg->get_opcode());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    server m_server;\n    con_list m_connections;\n    std::mutex m_connections_mutex;\n};"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ that supports both plain and TLS (SSL) connections using the WebSocket++ library. The server should handle incoming messages, echo them back to clients, and manage secure connections with proper TLS initialization.\n\nClass Description: The WebSocketServer class encapsulates functionality for creating and managing both plain and TLS WebSocket servers. It initializes server endpoints, sets up message handlers, manages TLS contexts, and runs the server's event loop.\n\nAttributes:\n- ios_: boost::asio::io_service - ASIO I/O service for handling network operations\n- endpoint_plain_: server_plain - WebSocket++ server instance for plain (non-secure) connections\n- endpoint_tls_: server_tls - WebSocket++ server instance for TLS (secure) connections\n\nMethods:\n- init() -> void - Initializes both plain and TLS server endpoints, sets message handlers, TLS initialization handler, and starts listening on ports 80 (plain) and 443 (TLS)\n- run() -> void - Starts the server's event loop to handle connections and messages\n- on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) -> void - Template method that handles incoming messages from clients and echoes them back\n- get_password() -> std::string - Returns the password used for TLS private key encryption\n- on_tls_init(websocketpp::connection_hdl hdl) -> context_ptr - Initializes and configures the TLS context for secure connections",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(), endpoint_tls_() {}\n\n    void init() {\n        endpoint_plain_.init_asio(&ios_);\n        endpoint_plain_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, ::_1, ::_2));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.init_asio(&ios_);\n        endpoint_tls_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, ::_1, ::_2));\n        endpoint_tls_.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, ::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\nprivate:\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl,\n        typename EndpointType::message_ptr msg)\n    {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                << \" and message: \" << msg->get_payload()\n                << std::endl;\n\n        try {\n            s->send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                    << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        std::cout << \"on_tls_init called with hdl: \" << hdl.lock().get() << std::endl;\n        context_ptr ctx(new boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                            boost::asio::ssl::context::no_sslv2 |\n                            boost::asio::ssl::context::no_sslv3 |\n                            boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <string>\n#include <iostream>\n\nnamespace websocketpp = websocketpp;\nnamespace asio = boost::asio;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        endpoint_plain_.set_io_service(&ios_);\n        endpoint_tls_.set_io_service(&ios_);\n    }\n\n    void init() {\n        endpoint_plain_.set_message_handler(\n            std::bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, std::placeholders::_1, std::placeholders::_2)\n        );\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.set_tls_init_handler(\n            std::bind(&WebSocketServer::on_tls_init, this, std::placeholders::_1)\n        );\n        endpoint_tls_.set_message_handler(\n            std::bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, std::placeholders::_1, std::placeholders::_2)\n        );\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* endpoint, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        endpoint->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return \"password\";\n    }\n\n    typename server_tls::context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);\n        ctx->set_options(\n            asio::ssl::context::default_workarounds |\n            asio::ssl::context::no_sslv2 |\n            asio::ssl::context::single_dh_use\n        );\n        ctx->use_certificate_chain_file(\"server.crt\");\n        ctx->use_private_key_file(\"server.key\", asio::ssl::context::pem);\n        ctx->set_password_callback(std::bind(&WebSocketServer::get_password, this));\n        return ctx;\n    }\n\nprivate:\n    asio::io_service ios_;\n    typedef websocketpp::server<websocketpp::config::asio> server_plain;\n    typedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/asio/ssl.hpp>\n#include <memory>\n#include <optional>\n#include <string>\n#include <functional>\n\nnamespace net = boost::asio;\nnamespace beast = boost::beast;\nnamespace websocket = boost::beast::websocket;\nusing tcp = boost::asio::ip::tcp;\nusing ssl = boost::asio::ssl;\n\nclass WebOsClient {\npublic:\n    class Impl;\n};\n\nclass WebOsClient::Impl {\npublic:\n    Impl(net::io_context& ioc, ssl::context& ctx, Device& device_settings, std::shared_ptr<Logging> log)\n        : ioc_(ioc)\n        , ctx_(ctx)\n        , device_settings_(device_settings)\n        , log_(log)\n        , resolver_(ioc)\n        , host_(device_settings.host + \":\" + device_settings.port)\n        , socket_status_(0)\n    {\n    }\n\n    void run() {\n        resolver_.async_resolve(host_, device_settings.port,\n            [this](beast::error_code ec, tcp::resolver::results_type results) {\n                onResolve(ec, results);\n            });\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) {\n            onError(ec, \"Resolve failed\");\n            return;\n        }\n\n        socket_ = std::make_unique<tcp::socket>(ioc_);\n        beast::get_lowest_layer(*socket_).expires_after(std::chrono::seconds(30));\n        beast::get_lowest_layer(*socket_).async_connect(*results.begin(),\n            [this](beast::error_code ec) {\n                onConnect(ec);\n            });\n    }\n\n    void onConnect(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"Connect failed\");\n            return;\n        }\n\n        if (device_settings.use_ssl) {\n            auto ssl_stream = std::make_unique<beast::ssl_stream<beast::tcp_stream>>(std::move(*socket_), ctx_);\n            ws_.emplace(std::move(ssl_stream));\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                [this](beast::error_code ec) {\n                    onSSLhandshake(ec);\n                });\n        } else {\n            auto tcp_stream = std::make_unique<websocket::stream<beast::tcp_stream>>(std::move(*socket_));\n            ws_tcp_.emplace(std::move(tcp_stream));\n            ws_tcp_->async_handshake(host_, \"/\",\n                [this](beast::error_code ec) {\n                    onWinsockHandshake(ec);\n                });\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"SSL handshake failed\");\n            return;\n        }\n\n        ws_->async_handshake(host_, \"/\",\n            [this](beast::error_code ec) {\n                onWinsockHandshake(ec);\n            });\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) {\n            onError(ec, \"WebSocket handshake failed\");\n            return;\n        }\n\n        read();\n    }\n\n    void send(std::string message_type, std::string payload) {\n        std::string msg = message_type + payload;\n        if (device_settings.use_ssl) {\n            ws_->async_write(net::buffer(msg),\n                [this](beast::error_code ec, std::size_t) {\n                    onWrite(ec, 0);\n                });\n        } else {\n            ws_tcp_->async_write(net::buffer(msg),\n                [this](beast::error_code ec, std::size_t) {\n                    onWrite(ec, 0);\n                });\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t) {\n        if (ec) {\n            onError(ec, \"Write failed\");\n        }\n    }\n\n    void read() {\n        if (device_settings.use_ssl) {\n            ws_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t) {\n                    onRead(ec, 0);\n                });\n        } else {\n            ws_tcp_->async_read(buffer_,\n                [this](beast::error_code ec, std::size_t) {\n                    onRead(ec, 0);\n                });\n        }\n    }\n\n    void onRead(beast::error_code ec, std::size_t) {\n        if (ec) {\n            if (ec == websocket::error::closed) {\n                onError(ec, \"WebSocket closed\");\n            } else {\n                onError(ec, \"Read failed\");\n            }\n            return;\n        }\n\n        std::string msg = beast::buffers_to_string(buffer_.data());\n        buffer_.consume(buffer_.size());\n        enqueueWork(Work{msg});\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string message) {\n        log_->log(\"Error: \" + message + \" - \" + ec.message());\n        close();\n    }\n\n    void enqueueWork(Work& work) {\n        // Process work\n    }\n\n    void close() {\n        beast::error_code ec;\n        if (ws_) {\n            ws_->close(websocket::close_code::normal, ec);\n        } else if (ws_tcp_) {\n            ws_tcp_->close(websocket::close_code::normal, ec);\n        }\n        if (ec) {\n            log_->log(\"Close failed: \" + ec.message());\n        }\n    }\n\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::unique_ptr<tcp::socket> socket_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n};"
  }
]