[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send messages, and receive responses.\n\nFunction Description: The code consists of two functions that together implement a basic TCP client. The first function creates and connects the socket, while the second handles the communication loop with the server.\n\nInput:\n- create_tcp_client:\n  - server_ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n- tcp_client_communication:\n  - sockfd: int - The socket file descriptor returned by create_tcp_client\n\nOutput:\n- create_tcp_client:\n  - Returns: int - The socket file descriptor if successful, -1 if failed\n- tcp_client_communication:\n  - No return value (void), but prints server responses and error messages to console",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(server_ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    while(true){\n        char buf[1024];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Error creating socket\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n\n    if (inet_aton(server_ip, &server_addr.sin_addr) == 0) {\n        std::cerr << \"Invalid IP address\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Error connecting to server\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (or 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        if (send(sockfd, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Error sending message\" << std::endl;\n            continue;\n        }\n\n        int bytes_received = recv(sockfd, buffer, sizeof(buffer), 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Error receiving response\" << std::endl;\n            continue;\n        }\n\n        if (bytes_received == 0) {\n            std::cerr << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send messages, and receive responses.\n\nFunction Description: The code consists of two main functions for creating and managing a TCP client connection. The first function creates and connects a TCP socket to a specified server, while the second function handles the communication loop for sending and receiving messages.\n\nInput:\n- createAndConnectTCPSocket:\n  - ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n\n- tcpClientCommunication:\n  - sockfd: int - The socket file descriptor returned by createAndConnectTCPSocket\n\nOutput:\n- createAndConnectTCPSocket:\n  - Returns: int - The socket file descriptor if successful, -1 if failed\n\n- tcpClientCommunication:\n  - No return value (void), but performs I/O operations until connection is terminated",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint createAndConnectTCPSocket(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/hostname\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcpClientCommunication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (or 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        int bytes_received = recv(sockfd, buffer, sizeof(buffer), 0);\n        if (bytes_received > 0) {\n            std::cout << \"Server response: \" << buffer << std::endl;\n        } else {\n            std::cerr << \"No response from server or connection closed\" << std::endl;\n            break;\n        }\n    }\n\n    close(sockfd);\n}"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server (localhost on port 8888 in this case), and enters a loop where it reads user input from stdin, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed by either side.\n\nInput: None (The server IP and port are hardcoded as 127.0.0.1 and 8888 respectively in the current implementation, but could be parameterized)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)\n\nNote: The function handles socket creation, connection establishment, data transmission, and proper cleanup (socket closing) in case of errors or normal termination.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_socket < 0) {\n        std::cerr << \"Error creating socket\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(client_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Error connecting to server\" << std::endl;\n        close(client_socket);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (or 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        if (send(client_socket, buffer, strlen(buffer), 0) < 0) {\n            std::cerr << \"Error sending message\" << std::endl;\n            break;\n        }\n\n        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Error receiving response\" << std::endl;\n            break;\n        } else if (bytes_received == 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        } else {\n            std::cout << \"Server response: \" << buffer << std::endl;\n        }\n    }\n\n    close(client_socket);\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a TCP client function in C++ that establishes a connection to a server, sends and receives messages, and maintains the connection until terminated by the user.\n\nFunction Description: The function `create_tcp_client` initializes a TCP client that connects to a specified server IP address. It creates a socket, establishes a connection, and provides interactive communication where the user can send messages to the server and receive responses. The function handles basic error cases and properly closes the connection when done.\n\nInput: \n- `server_ip`: [const char*] - The IP address of the server to connect to in string format (e.g., \"127.0.0.1\")\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any error occurs during socket creation or connection establishment. The function runs indefinitely until manually terminated by the user.\n\nNote: The function uses a default port 6666 for the connection. Error messages are printed to stderr using `perror` for debugging purposes. The communication loop continues until the program is interrupted, allowing continuous message exchange between client and server.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n\n#define DEFAULT_PORT 6666\n\nint create_tcp_client(const char* server_ip) {\n    int connfd = 0;\n    struct sockaddr_in client;\n    \n    client.sin_family = AF_INET;\n    client.sin_port = htons(DEFAULT_PORT);\n    client.sin_addr.s_addr = inet_addr(server_ip);\n    \n    connfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(connfd < 0){\n        perror(\"socket\");\n        return -1;\n    }\n    \n    if(connect(connfd, (struct sockaddr *)&client, sizeof(client)) < 0){\n        perror(\"connect\");\n        close(connfd);\n        return -1;\n    }\n    \n    char buff[1024];\n    bzero(buff, sizeof(buff));\n    recv(connfd, buff, 1024, 0);\n    printf(\"recv : %s \\n\", buff);\n    \n    bzero(buff, sizeof(buff));\n    strcpy(buff, \"this is client \\n\");\n    send(connfd, buff, 1024, 0);\n    \n    while(1){\n        bzero(buff, sizeof(buff));\n        scanf(\"%s\", buff);\n        int p = strlen(buff);\n        buff[p] = '\\0';\n        send(connfd, buff, 1024, 0);\n        printf(\"i have send buff \\n\");\n    }\n    \n    close(connfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cerrno>\n\nint create_tcp_client(const char* server_ip) {\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_socket == -1) {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(6666);\n\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        perror(\"Invalid address/hostname\");\n        close(client_socket);\n        return -1;\n    }\n\n    if (connect(client_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Connection failed\");\n        close(client_socket);\n        return -1;\n    }\n\n    std::cout << \"Connected to server. Type messages to send (type 'exit' to quit):\" << std::endl;\n\n    char buffer[1024];\n    while (true) {\n        std::cin.getline(buffer, sizeof(buffer));\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n        send(client_socket, buffer, strlen(buffer), 0);\n        recv(client_socket, buffer, sizeof(buffer), 0);\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n\n    close(client_socket);\n    return 0;\n}"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Create a C++ class that handles HTTP communication over TCP and UDP protocols, including sending requests and receiving responses from a server.\n\nClass Description: The LinHttpHandler class provides functionality for sending HTTP requests and receiving responses using both TCP (for standard HTTP communication) and UDP (for multicast communication). It includes error handling and resource management through RAII.\n\nAttributes:\n\nSocketCloser: [Nested Class] - A helper class that ensures sockets are properly closed when they go out of scope.\n\nMethods:\n\nsend: [Name](const std::string& msg, const std::string& adr, int port) -> std::string - Sends an HTTP message to the specified address and port using TCP and returns the server's response. Throws system_error on failure.\n\nsendMulticast: [Name](const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) -> std::vector<std::string> - Sends a multicast message using UDP and collects responses within the specified timeout period. Returns a vector of response strings. Throws system_error on failure.\n\nSocketCloser: [Name](int sockFd) -> None - Constructor that takes a socket file descriptor. The destructor automatically closes the socket.",
    "Canonical_solution": "#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <stdexcept>\n#include <system_error>\n#include <vector>\n\nnamespace hueplusplus\n{\nclass LinHttpHandler\n{\npublic:\n    std::string send(const std::string& msg, const std::string& adr, int port) const\n    {\n        int socketFD = socket(AF_INET, SOCK_STREAM, 0);\n\n        SocketCloser closeMySocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to open socket\"));\n        }\n\n        hostent* server = gethostbyname(adr.c_str());\n        if (server == NULL)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: gethostbyname\"));\n        }\n\n        sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        memcpy(&server_addr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n        if (connect(socketFD, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to connect socket\"));\n        }\n\n        size_t total = msg.length();\n        size_t sent = 0;\n        do\n        {\n            ssize_t bytes = write(socketFD, msg.c_str() + sent, total - sent);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to write message to socket\"));\n            }\n            sent += bytes;\n        } while (sent < total);\n\n        std::string response;\n        char buffer[128] = {};\n        do\n        {\n            ssize_t bytes = read(socketFD, buffer, 127);\n            if (bytes < 0)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: Failed to read response from socket\"));\n            }\n            response.append(buffer, bytes);\n        } while (true);\n\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(\n        const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) const\n    {\n        hostent* server;\n        sockaddr_in server_addr;\n\n        memset((char*)&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n\n        server = gethostbyname(adr.c_str());\n        if (!server)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to obtain address of host\"));\n        }\n\n        memcpy((void*)&server_addr.sin_addr, server->h_addr_list[0], server->h_length);\n\n        int socketFD = socket(AF_INET, SOCK_DGRAM, 0);\n        SocketCloser closeMySendSocket(socketFD);\n        if (socketFD < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to open socket\"));\n        }\n\n        if (sendto(socketFD, msg.c_str(), strlen(msg.c_str()), 0, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)\n        {\n            int errCode = errno;\n            throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to send message\"));\n        }\n\n        std::string response;\n        char buffer[2048] = {};\n\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n        while (std::chrono::steady_clock::now() - start < timeout)\n        {\n            ssize_t bytesReceived = recv(socketFD, &buffer, 2048, MSG_DONTWAIT);\n            if (bytesReceived < 0 && errno != EAGAIN && errno != EWOULDBLOCK)\n            {\n                int errCode = errno;\n                throw(std::system_error(errCode, std::generic_category(), \"LinHttpHandler: sendMulticast: Failed to read response from socket\"));\n            }\n            if (bytesReceived > 0)\n            {\n                response.append(buffer, bytesReceived);\n            }\n        }\n\n        std::vector<std::string> returnString;\n        size_t pos = response.find(\"\\r\\n\\r\\n\");\n        size_t prevpos = 0;\n        while (pos != std::string::npos)\n        {\n            returnString.push_back(response.substr(prevpos, pos - prevpos));\n            pos += 4;\n            prevpos = pos;\n            pos = response.find(\"\\r\\n\\r\\n\", pos);\n        }\n        return returnString;\n    }\n\nprivate:\n    class SocketCloser\n    {\n    public:\n        explicit SocketCloser(int sockFd) : s(sockFd) {}\n        ~SocketCloser() { close(s); }\n\n    private:\n        int s;\n    };\n};\n} // namespace hueplusplus",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <chrono>\n#include <thread>\n#include <cstring>\n\nclass LinHttpHandler {\npublic:\n    class SocketCloser {\n    private:\n        int sockFd;\n    public:\n        SocketCloser(int sockFd) : sockFd(sockFd) {}\n        ~SocketCloser() {\n            if (sockFd != -1) {\n                close(sockFd);\n            }\n        }\n    };\n\n    std::string send(const std::string& msg, const std::string& adr, int port) {\n        int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n        if (sockfd == -1) {\n            throw std::system_error(errno, std::system_category(), \"Failed to create socket\");\n        }\n\n        struct sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr);\n\n        if (connect(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {\n            close(sockfd);\n            throw std::system_error(errno, std::system_category(), \"Connection failed\");\n        }\n\n        if (send(sockfd, msg.c_str(), msg.size(), 0) == -1) {\n            close(sockfd);\n            throw std::system_error(errno, std::system_category(), \"Send failed\");\n        }\n\n        char buffer[1024];\n        std::string response;\n        while (true) {\n            int bytesReceived = recv(sockfd, buffer, sizeof(buffer), 0);\n            if (bytesReceived <= 0) {\n                break;\n            }\n            response += std::string(buffer, bytesReceived);\n        }\n\n        close(sockfd);\n        return response;\n    }\n\n    std::vector<std::string> sendMulticast(const std::string& msg, const std::string& adr, int port, std::chrono::steady_clock::duration timeout) {\n        int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n        if (sockfd == -1) {\n            throw std::system_error(errno, std::system_category(), \"Failed to create socket\");\n        }\n\n        struct sockaddr_in serverAddr;\n        memset(&serverAddr, 0, sizeof(serverAddr));\n        serverAddr.sin_family = AF_INET;\n        serverAddr.sin_port = htons(port);\n        inet_pton(AF_INET, adr.c_str(), &serverAddr.sin_addr);\n\n        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) < 0) {\n            close(sockfd);\n            throw std::system_error(errno, std::system_category(), \"Setsockopt failed\");\n        }\n\n        if (bind(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n            close(sockfd);\n            throw std::system_error(errno, std::system_category(), \"Bind failed\");\n        }\n\n        std::vector<std::string> responses;\n        char buffer[1024];\n        struct sockaddr_in fromAddr;\n        socklen_t fromLen = sizeof(fromAddr);\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n\n        while (true) {\n            int bytesReceived = recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr*)&fromAddr, &fromLen);\n            if (bytesReceived <= 0) {\n                break;\n            }\n            responses.push_back(std::string(buffer, bytesReceived));\n\n            if (std::chrono::steady_clock::now() - start > timeout) {\n                break;\n            }\n        }\n\n        close(sockfd);\n        return responses;\n    }\n};"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends a single character, receives a response, and then closes the connection.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server address and port, sends a predefined character ('A') to the server, reads the server's response, prints the received character, and finally closes the socket. This demonstrates basic TCP client functionality using BSD sockets.\n\nInput: None (The server address and port are hardcoded as 127.0.0.1:9736 in the function)\n\nOutput: \n- Returns 0 on successful execution\n- Prints the received character from the server\n- Exits with error code 1 if connection fails",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint tcp_client_communication()\n{\n    int sockfd = -1;\n    int len = 0;\n    struct sockaddr_in address;\n    int result;\n    char ch = 'A';\n    \n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    address.sin_port = htons(9736);\n    len = sizeof(address);\n    \n    result = connect(sockfd, (struct sockaddr*)&address, len);\n\n    if(result == -1)\n    {\n        perror(\"ops:client\\n\");\n        exit(1);\n    }\n    \n    write(sockfd, &ch, 1);\n    read(sockfd, &ch, 1);\n    printf(\"char form server = %c\\n\", ch);\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <iostream>\n\nint tcp_client_communication() {\n    int client_fd;\n    struct sockaddr_in server_addr;\n    char buffer[1];\n    int bytes_received;\n\n    // Create socket\n    if ((client_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Error creating socket\" << std::endl;\n        return 1;\n    }\n\n    // Set server address\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9736);\n    if (inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/hostname\" << std::endl;\n        close(client_fd);\n        return 1;\n    }\n\n    // Connect to server\n    if (connect(client_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(client_fd);\n        return 1;\n    }\n\n    // Send character 'A'\n    if (send(client_fd, \"A\", 1, 0) < 0) {\n        std::cerr << \"Send failed\" << std::endl;\n        close(client_fd);\n        return 1;\n    }\n\n    // Receive response\n    if ((bytes_received = recv(client_fd, buffer, 1, 0)) < 0) {\n        std::cerr << \"Receive failed\" << std::endl;\n        close(client_fd);\n        return 1;\n    }\n\n    // Print received character\n    std::cout << \"Received: \" << buffer[0] << std::endl;\n\n    // Close connection\n    close(client_fd);\n\n    return 0;\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Implement a TCP client in C++ that can establish a connection to a server, send data, and receive responses.\n\nFunction Description: The code consists of two main functions for creating and communicating with a TCP client. The first function creates and connects a TCP socket to a specified server, while the second function handles the communication loop for sending and receiving data.\n\nInput:\n- create_tcp_client:\n  - server_ip: const char* - The IP address of the server to connect to\n  - port: int - The port number of the server to connect to\n- tcp_client_communication:\n  - sockfd: int - The socket file descriptor returned by create_tcp_client\n\nOutput:\n- create_tcp_client:\n  - Returns: int - The socket file descriptor on success, -1 on failure\n- tcp_client_communication:\n  - No return value (void), but performs continuous communication until connection is terminated",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(server_ip);\n    serv_addr.sin_port = htons(port);\n\n    if(connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n    \n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            printf(\"socket already disconnected, can't write any more!\\n\");\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            printf(\"server socket disconnected!\\n\");\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_client(const char* server_ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {\n        std::cerr << \"Invalid address/hostname\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sockfd);\n        return -1;\n    }\n\n    return sockfd;\n}\n\nvoid tcp_client_communication(int sockfd) {\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (or 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        send(sockfd, buffer, strlen(buffer), 0);\n\n        int bytes_received = recv(sockfd, buffer, sizeof(buffer), 0);\n        if (bytes_received > 0) {\n            std::cout << \"Server response: \" << buffer << std::endl;\n        } else {\n            std::cerr << \"No response from server or connection closed\" << std::endl;\n            break;\n        }\n    }\n\n    close(sockfd);\n}"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 8888, respectively, within the function.)\n\nOutput: None (The function prints received messages from the server to the console but does not return any value.)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int client_fd;\n    struct sockaddr_in server_addr;\n\n    // Create socket\n    client_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_fd < 0) {\n        std::cerr << \"Error creating socket\" << std::endl;\n        return;\n    }\n\n    // Set server address\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    // Connect to server\n    if (connect(client_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Error connecting to server\" << std::endl;\n        close(client_fd);\n        return;\n    }\n\n    char buffer[1024];\n    std::string input;\n\n    while (true) {\n        std::cout << \"Enter message to send (or 'exit' to quit): \";\n        std::getline(std::cin, input);\n\n        if (input == \"exit\") {\n            break;\n        }\n\n        // Send message to server\n        if (send(client_fd, input.c_str(), input.length(), 0) < 0) {\n            std::cerr << \"Error sending message\" << std::endl;\n            break;\n        }\n\n        // Receive response from server\n        int bytes_received = recv(client_fd, buffer, sizeof(buffer), 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Error receiving response\" << std::endl;\n            break;\n        } else if (bytes_received == 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        }\n\n        buffer[bytes_received] = '\\0';\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    // Close connection\n    close(client_fd);\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a TCP client class that can establish a connection to a server, send and receive data, and handle timeouts for non-blocking operations.\n\nClass Description: The TCPClient class provides functionality for TCP socket communication with a remote server. It supports both blocking and non-blocking operations with timeout capabilities, and handles cross-platform compatibility between Windows and Unix-like systems.\n\nAttributes:\n- address: std::string - The IP address or hostname of the server to connect to\n- port: u16 - The port number of the server to connect to\n- main_socket: SocketHolder (int) - The socket file descriptor for the connection\n- connected: bool - Flag indicating whether the client is currently connected to the server\n\nMethods:\n- Connect() -> bool - Establishes a connection to the server. Returns true if successful.\n- Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Reads data from the server into the buffer. Returns true if all requested bytes were read.\n- Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Writes data from the buffer to the server. Returns true if all bytes were written.\n- Disconnect() -> void - Closes the connection to the server.\n- SetNonBlock(SocketHolder sockFD, bool nonBlocking) -> bool - Sets the blocking mode of the socket. Returns true if successful.\n- ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) -> bool - Attempts to connect with a timeout. Returns true if successful.",
    "Canonical_solution": "#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <cerrno>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <string>\n\n#ifdef _WIN32\n#define WSAEAGAIN WSAEWOULDBLOCK\n#define WSAEMULTIHOP -1\n#define ERRNO(x) WSA##x\n#define GET_ERRNO WSAGetLastError()\n#define poll(x, y, z) WSAPoll(x, y, z);\n#define SHUT_RD SD_RECEIVE\n#define SHUT_WR SD_SEND\n#define SHUT_RDWR SD_BOTH\n#else\n#define ERRNO(x) x\n#define GET_ERRNO errno\n#define closesocket(x) close(x)\n#endif\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n\n    TCPClient(const std::string& address, u16 port) : address(address), port(port) {}\n\n    bool Connect() {\n        if (connected)\n            return true;\n\n        struct addrinfo hints, *addrinfo;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_family = AF_INET;\n\n        if (getaddrinfo(address.data(), NULL, &hints, &addrinfo) != 0) {\n            return false;\n        }\n\n        main_socket = ::socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == static_cast<SocketHolder>(-1)) {\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, true)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        struct sockaddr_in servaddr = {0};\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_addr.s_addr = ((struct sockaddr_in*)(addrinfo->ai_addr))->sin_addr.s_addr;\n        servaddr.sin_port = htons(port);\n        freeaddrinfo(addrinfo);\n\n        if (!ConnectWithTimeout(main_socket, &servaddr, sizeof(servaddr), 10)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t read_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (read_bytes != size) {\n            int new_read = ::recv(main_socket, (char*)((uintptr_t)buffer + read_bytes), \n                (int)(size - read_bytes), 0);\n            if (new_read < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                read_bytes = 0;\n                break;\n            }\n            read_bytes += new_read;\n        }\n        return read_bytes == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t write_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (write_bytes != size) {\n            int new_written = ::send(main_socket, (const char*)((uintptr_t)buffer + write_bytes),\n                                    (int)(size - write_bytes), 0);\n            if (new_written < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                write_bytes = 0;\n                break;\n            }\n            write_bytes += new_written;\n        }\n        return write_bytes == size;\n    }\n\n    void Disconnect() {\n        if (connected) {\n            shutdown(main_socket, SHUT_RDWR);\n            closesocket(main_socket);\n            connected = false;\n        }\n    }\n\nprivate:\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        bool blocking = !nonBlocking;\n#ifdef _WIN32\n        unsigned long nonblocking = (blocking) ? 0 : 1;\n        int ret = ioctlsocket(sockFD, FIONBIO, &nonblocking);\n        if (ret == -1) {\n            return false;\n        }\n#else\n        int flags = ::fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) {\n            return false;\n        }\n\n        flags &= ~O_NONBLOCK;\n        if (!blocking) {\n            flags |= O_NONBLOCK;\n        }\n\n        const int ret = ::fcntl(sockFD, F_SETFL, flags);\n        if (ret == -1) {\n            return false;\n        }\n#endif\n        return true;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len,\n                           int timeout_seconds) {\n        int res = ::connect(sockFD, (struct sockaddr*)server_addr, static_cast<int>(server_addr_len));\n        if (res == -1 && ((GET_ERRNO == ERRNO(EINPROGRESS) || GET_ERRNO == ERRNO(EWOULDBLOCK))) {\n            struct timeval tv;\n            fd_set fdset;\n            FD_ZERO(&fdset);\n            FD_SET(sockFD, &fdset);\n\n            tv.tv_sec = timeout_seconds;\n            tv.tv_usec = 0;\n            int select_res = ::select(static_cast<int>(sockFD + 1), NULL, &fdset, NULL, &tv);\n#ifdef _WIN32\n            if (select_res == 0) {\n                return false;\n            }\n#else\n            bool select_good = false;\n            if (select_res == 1) {\n                int so_error;\n                socklen_t len = sizeof so_error;\n\n                getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n                if (so_error == 0) {\n                    select_good = true;\n                }\n            }\n            if (!select_good) {\n                return false;\n            }\n#endif\n        } else if (res == -1) {\n            return false;\n        }\n        return true;\n    }\n\n    std::string address;\n    u16 port;\n    SocketHolder main_socket = -1;\n    bool connected = false;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <string>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <chrono>\n#include <thread>\n#include <cstring>\n\nclass TCPClient {\npublic:\n    std::string address;\n    u16 port;\n    int main_socket;\n    bool connected;\n\n    TCPClient(const std::string& addr, u16 port) : address(addr), port(port), main_socket(-1), connected(false) {}\n\n    bool Connect() {\n        main_socket = socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == -1) {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return false;\n        }\n\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n\n        if (inet_pton(AF_INET, address.c_str(), &server_addr.sin_addr) <= 0) {\n            std::cerr << \"Invalid address/hostname\" << std::endl;\n            close(main_socket);\n            return false;\n        }\n\n        if (connect(main_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n            std::cerr << \"Connection failed\" << std::endl;\n            close(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        auto start = std::chrono::steady_clock::now();\n        while (true) {\n            fd_set read_fds;\n            FD_ZERO(&read_fds);\n            FD_SET(main_socket, &read_fds);\n\n            struct timeval tv;\n            tv.tv_sec = timeout.count() / 1e9;\n            tv.tv_usec = (timeout.count() % 1e9) / 1000;\n\n            int result = select(main_socket + 1, &read_fds, nullptr, nullptr, &tv);\n            if (result == -1) {\n                std::cerr << \"Select error\" << std::endl;\n                return false;\n            }\n\n            if (result > 0 && FD_ISSET(main_socket, &read_fds)) {\n                ssize_t bytes_read = recv(main_socket, static_cast<char*>(buffer), size, 0);\n                if (bytes_read > 0) {\n                    return true;\n                } else if (bytes_read == 0) {\n                    Disconnect();\n                    return false;\n                } else {\n                    std::cerr << \"Read error\" << std::endl;\n                    return false;\n                }\n            } else if (result == 0) {\n                std::cerr << \"Timeout occurred\" << std::endl;\n                return false;\n            } else {\n                std::this_thread::sleep_for(std::chrono::milliseconds(100));\n            }\n        }\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected || main_socket == -1) return false;\n\n        auto start = std::chrono::steady_clock::now();\n        while (true) {\n            fd_set write_fds;\n            FD_ZERO(&write_fds);\n            FD_SET(main_socket, &write_fds);\n\n            struct timeval tv;\n            tv.tv_sec = timeout.count() / 1e9;\n            tv.tv_usec = (timeout.count() % 1e9) / 1000;\n\n            int result = select(main_socket + 1, nullptr, &write_fds, nullptr, &tv);\n            if (result == -1) {\n                std::cerr << \"Select error\" << std::endl;\n                return false;\n            }\n\n            if (result > 0 && FD_ISSET(main_socket, &write_fds)) {\n                ssize_t bytes_written = send(main_socket, static_cast<const char*>(buffer), size, 0);\n                if (bytes_written > 0) {\n                    return true;\n                } else if (bytes_written == 0) {\n                    Disconnect();\n                    return false;\n                } else {\n                    std::cerr << \"Write error\" << std::endl;\n                    return false;\n                }\n            } else if (result == 0) {\n                std::cerr << \"Timeout occurred\" << std::endl;\n                return false;\n            } else {\n                std::this_thread::sleep_for(std::chrono::milliseconds(100));\n            }\n        }\n    }\n\n    void Disconnect() {\n        if (connected) {\n            close(main_socket);\n            connected = false;\n        }\n    }\n\n    bool SetNonBlock(int sockFD, bool nonBlocking) {\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n\n        if (nonBlocking) {\n            flags |= O_NONBLOCK;\n        } else {\n            flags &= ~O_NONBLOCK;\n        }\n\n        if (fcntl(sockFD, F_SETFL, flags) == -1) {\n            std::cerr << \"Failed to set non-blocking mode\" << std::endl;\n            return false;\n        }\n\n        return true;\n    }\n\n    bool ConnectWithTimeout(int sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        struct sockaddr_in* addr = static_cast<struct sockaddr_in*>(server_addr);\n        int retry = 0;\n        while (retry < 3) {\n            if (connect(sockFD, (struct sockaddr*)addr, server_addr_len) >= 0) {\n                return true;\n            } else {\n                std::cerr << \"Connection attempt failed, retrying...\" << std::endl;\n                retry++;\n                std::this_thread::sleep_for(std::chrono::seconds(1));\n            }\n        }\n        return false;\n    }\n};"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests and handling responses, including JSON parsing capabilities.\n\nClass Description: The CurlHttpClient class provides methods for performing HTTP GET requests and downloading web pages, with support for custom headers and request bodies. It includes JSON response handling and memory management for received data.\n\nAttributes:\nMemoryStruct: [struct] - A helper structure for storing received data in memory during curl operations\n  - memory: [char*] - Pointer to the allocated memory buffer\n  - size: [size_t] - Size of the allocated memory buffer\n\nMethods:\nWriteMemoryCallback: [static](void* contents, size_t size, size_t nmemb, void* userp) -> size_t - A static callback function for libcurl to write received data into memory\n  - contents: [void*] - Pointer to the received data\n  - size: [size_t] - Size of each data element\n  - nmemb: [size_t] - Number of data elements\n  - userp: [void*] - Pointer to user-provided memory structure\n  - Returns: The number of bytes actually written\n\ndownloadPage: [](const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) -> long - Downloads a web page and returns the HTTP status code\n  - url: [const std::string&] - The URL to request\n  - res: [std::string&] - Reference to store the response body\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response\n\ngetRequest: [](const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) -> long - Performs a GET request and parses the JSON response\n  - url: [const std::string&] - The URL to request\n  - res: [json&] - Reference to store the parsed JSON response\n  - headers: [const std::vector<std::string>&] - Vector of header strings to include in the request\n  - body: [const std::string&] - Request body content\n  - Returns: HTTP status code of the response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <vector>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::ordered_json;\n\nclass CurlHttpClient {\npublic:\n    struct MemoryStruct {\n        char* memory;\n        size_t size;\n    };\n\n    static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        MemoryStruct* mem = (MemoryStruct*)userp;\n\n        char* ptr = static_cast<char*>(realloc(mem->memory, mem->size + realsize + 1));\n        if (ptr == NULL) {\n            return 0;\n        }\n\n        mem->memory = ptr;\n        memcpy(&(mem->memory[mem->size]), contents, realsize);\n        mem->size += realsize;\n        mem->memory[mem->size] = 0;\n\n        return realsize;\n    }\n\n    long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl_handle;\n        MemoryStruct chunk;\n        struct curl_slist* list = NULL;\n        long status_code;\n\n        chunk.memory = static_cast<char*>(malloc(1));\n        chunk.size = 0;\n\n        curl_global_init(CURL_GLOBAL_ALL);\n        curl_handle = curl_easy_init();\n        curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());\n        if (!headers.empty()) {\n            for (auto& h : headers) {\n                list = curl_slist_append(list, h.c_str());\n            }\n            curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, list);\n        }\n        if (body != \"\") {\n            curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);\n        curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"HamletDuFromage\");\n\n        curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);\n        curl_easy_perform(curl_handle);\n        curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &status_code);\n        curl_easy_cleanup(curl_handle);\n        res = std::string(chunk.memory);\n        free(chunk.memory);\n\n        curl_global_cleanup();\n        return status_code;\n    }\n\n    long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string request;\n        long status_code = downloadPage(url, request, headers, body);\n\n        if (json::accept(request))\n            res = json::parse(request);\n        else\n            res = json::object();\n\n        return status_code;\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "#include <curl/curl.h>\n#include <string>\n#include <vector>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstruct MemoryStruct {\n    char* memory;\n    size_t size;\n};\n\nstatic size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    size_t realsize = size * nmemb;\n    struct MemoryStruct* mem = (struct MemoryStruct*)userp;\n    mem->memory = (char*)realloc(mem->memory, mem->size + realsize);\n    if (mem->memory == nullptr) return 0;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    return realsize;\n}\n\nclass CurlHttpClient {\npublic:\n    static long downloadPage(const std::string& url, std::string& res, const std::vector<std::string>& headers, const std::string& body) {\n        CURL* curl = curl_easy_init();\n        if (!curl) return -1;\n\n        struct MemoryStruct memory = {nullptr, 0};\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&memory);\n\n        for (const auto& header : headers) {\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, curl_slist_append(nullptr, header.c_str()));\n        }\n\n        if (!body.empty()) {\n            curl_easy_setopt(curl, CURLOPT_POST, 1L);\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n        }\n\n        long status = 0;\n        curl_easy_setopt(curl, CURLOPT_HTTPCODE, &status);\n\n        CURLcode result = curl_easy_perform(curl);\n        if (result != CURLE_OK) {\n            std::cerr << \"CURL error: \" << curl_easy_strerror(result) << std::endl;\n            curl_easy_cleanup(curl);\n            return -1;\n        }\n\n        res.assign(memory.memory, memory.size);\n        curl_easy_cleanup(curl);\n        free(memory.memory);\n        return status;\n    }\n\n    static long getRequest(const std::string& url, json& res, const std::vector<std::string>& headers, const std::string& body) {\n        std::string response;\n        long status = downloadPage(url, response, headers, body);\n        if (status != 200) return status;\n\n        try {\n            res = json::parse(response);\n        } catch (const json::parse_error& e) {\n            std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n            return -1;\n        }\n\n        return status;\n    }\n};"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Implement a TCP client function that establishes a connection to a server, sends data, and reads the server's response in a continuous loop, handling connection errors and reconnection attempts.\n\nFunction Description: The function `readwrite_routine` implements a TCP client that continuously attempts to connect to a specified server endpoint. Once connected, it sends a fixed message and reads the server's response. If the connection fails or is lost, it automatically attempts to reconnect. The function handles connection states and errors appropriately, including non-blocking connection scenarios.\n\nInput: \n- `arg` (void pointer): A pointer to a `stEndPoint` structure containing:\n  - `ip` (char pointer): The IP address of the server to connect to (can be NULL or special values for default behavior)\n  - `port` (unsigned short int): The port number of the server to connect to\n\nOutput: \n- Returns NULL (void pointer) when the loop exits (though the provided implementation has an infinite loop)\n- No explicit return value, but performs I/O operations through the socket\n\nNote: The function runs in an infinite loop and should typically be executed in a separate thread. It manages its own socket lifecycle, creating and closing sockets as needed during connection attempts and communication.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nstruct stEndPoint\n{\n    char *ip;\n    unsigned short int port;\n};\n\nstatic void SetAddr(const char *pszIP, const unsigned short shPort, struct sockaddr_in &addr)\n{\n    bzero(&addr, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(shPort);\n    int nIP = 0;\n    if(!pszIP || '\\0' == *pszIP   \n            || 0 == strcmp(pszIP,\"0\") || 0 == strcmp(pszIP,\"0.0.0.0\") \n            || 0 == strcmp(pszIP,\"*\") \n      )\n    {\n        nIP = htonl(INADDR_ANY);\n    }\n    else\n    {\n        nIP = inet_addr(pszIP);\n    }\n    addr.sin_addr.s_addr = nIP;\n}\n\nstatic void *readwrite_routine(void *arg)\n{\n    stEndPoint *endpoint = (stEndPoint *)arg;\n    char str[8] = \"sarlmol\";\n    char buf[1024 * 16];\n    int fd = -1;\n    int ret = 0;\n    \n    for(;;)\n    {\n        if(fd < 0)\n        {\n            fd = socket(PF_INET, SOCK_STREAM, 0);\n            struct sockaddr_in addr;\n            SetAddr(endpoint->ip, endpoint->port, addr);\n            ret = connect(fd, (struct sockaddr*)&addr, sizeof(addr));\n            \n            if(errno == EALREADY || errno == EINPROGRESS)\n            {       \n                struct pollfd pf = {0};\n                pf.fd = fd;\n                pf.events = (POLLOUT|POLLERR|POLLHUP);\n                co_poll(co_get_epoll_ct(), &pf, 1, 200);\n                \n                int error = 0;\n                uint32_t socklen = sizeof(error);\n                errno = 0;\n                ret = getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *)&error, &socklen);\n                if(ret == -1)\n                {       \n                    close(fd);\n                    fd = -1;\n                    continue;\n                }       \n                if(error)\n                {       \n                    errno = error;\n                    close(fd);\n                    fd = -1;\n                    continue;\n                }       \n            }\n        }\n        \n        ret = write(fd, str, 8);\n        if(ret > 0)\n        {\n            ret = read(fd, buf, sizeof(buf));\n            if(ret <= 0)\n            {\n                close(fd);\n                fd = -1;\n            }\n        }\n        else\n        {\n            close(fd);\n            fd = -1;\n        }\n    }\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n\ntypedef struct {\n    char *ip;\n    unsigned short port;\n} stEndPoint;\n\nvoid* readwrite_routine(void* arg) {\n    stEndPoint *endPoint = (stEndPoint*)arg;\n    int sock = -1;\n    const char *message = \"Hello from client\";\n    char buffer[1024];\n    int bytes_received;\n\n    while (1) {\n        // Create socket\n        sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (sock == -1) {\n            perror(\"Socket creation failed\");\n            continue;\n        }\n\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(endPoint->port);\n\n        // Resolve IP address\n        if (endPoint->ip != NULL && strcmp(endPoint->ip, \"0.0.0.0\") != 0) {\n            if (inet_aton(endPoint->ip, &server_addr.sin_addr) == 0) {\n                fprintf(stderr, \"Invalid IP address: %s\\n\", endPoint->ip);\n                close(sock);\n                continue;\n            }\n        } else {\n            // Default to localhost\n            server_addr.sin_addr.s_addr = INADDR_LOOPBACK;\n        }\n\n        // Connect to server\n        if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n            perror(\"Connection failed\");\n            close(sock);\n            sleep(2); // Wait before retrying\n            continue;\n        }\n\n        printf(\"Connected to server\\n\");\n\n        // Send message\n        int bytes_sent = send(sock, message, strlen(message), 0);\n        if (bytes_sent == -1) {\n            perror(\"Send failed\");\n            close(sock);\n            continue;\n        }\n\n        // Read response\n        while ((bytes_received = recv(sock, buffer, sizeof(buffer), 0)) > 0) {\n            buffer[bytes_received] = '\\0';\n            printf(\"Server response: %s\\n\", buffer);\n        }\n\n        if (bytes_received == -1) {\n            perror(\"Receive failed\");\n        }\n\n        close(sock);\n        printf(\"Disconnected from server\\n\");\n        sleep(2); // Wait before reconnecting\n    }\n\n    return NULL;\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input messages, and receives responses from the server until the connection is terminated.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server (localhost on port 8888 in this case), and enters a loop where it reads user input from stdin, sends it to the server, and prints the server's response. The communication continues until an error occurs or the connection is closed by either side.\n\nInput: None (The server IP and port are hardcoded as 127.0.0.1 and 8888 respectively in the function. User input is collected interactively during execution.)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value. All communication results are handled via side effects.)\n\nNote: The function handles its own socket cleanup by closing the connection before exiting.",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(8888);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nvoid tcp_client_communication() {\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_socket < 0) {\n        std::cerr << \"Error creating socket\" << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(client_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        std::cerr << \"Error connecting to server\" << std::endl;\n        close(client_socket);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (or 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        send(client_socket, buffer, strlen(buffer), 0);\n\n        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n        if (bytes_received < 0) {\n            std::cerr << \"Error receiving data\" << std::endl;\n            break;\n        } else if (bytes_received == 0) {\n            std::cout << \"Server disconnected\" << std::endl;\n            break;\n        } else {\n            buffer[bytes_received] = '\\0';\n            std::cout << \"Server response: \" << buffer << std::endl;\n        }\n    }\n\n    close(client_socket);\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a TCP client function in C++ that establishes a connection to a server, sends user input to the server, and prints the server's response. The function should handle basic error cases and properly close the connection when done.\n\nFunction Description: The function `tcp_client_communication` creates a TCP socket, connects to a specified server, and enters a loop where it reads user input, sends it to the server, and displays the server's response. The loop continues until an error occurs or the connection is closed by the server. The function handles socket creation, connection, data transmission, and cleanup.\n\nInput: None (The server IP address and port are hardcoded as \"127.0.0.1\" and 1234 respectively in the function)\n\nOutput: None (The function prints server responses to stdout but doesn't return any value)",
    "Canonical_solution": "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BUFFER_SIZE 1024\n\nvoid tcp_client_communication() {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serv_addr.sin_port = htons(1234);\n\n    connect(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr));\n    \n    while(true){\n        char buf[BUFFER_SIZE];\n        bzero(&buf, sizeof(buf));\n        scanf(\"%s\", buf);\n        ssize_t write_bytes = write(sockfd, buf, sizeof(buf));\n        if(write_bytes == -1){\n            break;\n        }\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from server: %s\\n\", buf);\n        }else if(read_bytes == 0){\n            break;\n        }else if(read_bytes == -1){\n            close(sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 149,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <cerrno>\n\nvoid tcp_client_communication() {\n    int client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (client_socket == -1) {\n        std::cerr << \"Error creating socket: \" << strerror(errno) << std::endl;\n        return;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(1234);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(client_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Error connecting to server: \" << strerror(errno) << std::endl;\n        close(client_socket);\n        return;\n    }\n\n    char buffer[1024];\n    while (true) {\n        std::cout << \"Enter message to send (or 'exit' to quit): \";\n        std::cin.getline(buffer, sizeof(buffer));\n\n        if (std::strcmp(buffer, \"exit\") == 0) {\n            break;\n        }\n\n        if (send(client_socket, buffer, strlen(buffer), 0) == -1) {\n            std::cerr << \"Error sending message: \" << strerror(errno) << std::endl;\n            break;\n        }\n\n        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n        if (bytes_received == -1) {\n            std::cerr << \"Error receiving response: \" << strerror(errno) << std::endl;\n            break;\n        } else if (bytes_received == 0) {\n            std::cout << \"Server closed connection.\" << std::endl;\n            break;\n        } else {\n            buffer[bytes_received] = '\\0';\n            std::cout << \"Server response: \" << buffer << std::endl;\n        }\n    }\n\n    close(client_socket);\n}"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a TCP server in C++ that listens for incoming connections, receives data from clients, and echoes the data back to the clients. The server should handle one client at a time and properly clean up resources when the connection is terminated.\n\nFunction Description: The function `create_tcp_server` establishes a TCP server that binds to a specified IP address and port, listens for incoming connections, and handles client communication. It reads data from the client and sends the same data back (echo). The server runs until the client disconnects or an error occurs.\n\nInput: \n- `ip`: [const char*] - The IP address the server should bind to (e.g., \"127.0.0.1\" for localhost).\n- `port`: [int] - The port number the server should listen on (e.g., 8080).\n\nOutput: \n- [int] - Returns 0 on successful execution and -1 if any step fails (socket creation, binding, listening, or accepting connections).",
    "Canonical_solution": "#include <stdio.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <unistd.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) return -1;\n\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = inet_addr(ip);\n    serv_addr.sin_port = htons(port);\n\n    if(bind(sockfd, (sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    if(listen(sockfd, SOMAXCONN) == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    bzero(&clnt_addr, sizeof(clnt_addr));\n\n    int clnt_sockfd = accept(sockfd, (sockaddr*)&clnt_addr, &clnt_addr_len);\n    if(clnt_sockfd == -1) {\n        close(sockfd);\n        return -1;\n    }\n\n    printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sockfd, inet_ntoa(clnt_addr.sin_addr), ntohs(clnt_addr.sin_port));\n    \n    char buf[1024];\n    while (true) {\n        bzero(&buf, sizeof(buf));\n        ssize_t read_bytes = read(clnt_sockfd, buf, sizeof(buf));\n        if(read_bytes > 0){\n            printf(\"message from client fd %d: %s\\n\", clnt_sockfd, buf);\n            write(clnt_sockfd, buf, sizeof(buf));\n        } else if(read_bytes == 0){\n            printf(\"client fd %d disconnected\\n\", clnt_sockfd);\n            close(clnt_sockfd);\n            break;\n        } else if(read_bytes == -1){\n            close(clnt_sockfd);\n            break;\n        }\n    }\n    close(sockfd);\n    return 0;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "right_result": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n\nint create_tcp_server(const char* ip, int port) {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    int val = 1;\n\n    // Create socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return -1;\n    }\n\n    // Set SO_REUSEADDR option\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &val, sizeof(val)) < 0) {\n        std::cerr << \"Error setting SO_REUSEADDR\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    // Bind the socket\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = inet_addr(ip);\n    address.sin_port = htons(port);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        std::cerr << \"Failed to bind socket\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Failed to listen on socket\" << std::endl;\n        close(server_fd);\n        return -1;\n    }\n\n    std::cout << \"Server is listening on \" << ip << \":\" << port << std::endl;\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Failed to accept connection\" << std::endl;\n            close(server_fd);\n            close(new_socket);\n            return -1;\n        }\n\n        std::cout << \"Client connected\" << std::endl;\n\n        while (true) {\n            int valread = read(new_socket, buffer, 1024);\n            if (valread <= 0) {\n                std::cout << \"Client disconnected\" << std::endl;\n                break;\n            }\n            std::cout << \"Received: \" << buffer << std::endl;\n            send(new_socket, buffer, valread, 0);\n        }\n\n        close(new_socket);\n    }\n\n    close(server_fd);\n    return 0;\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Implement a TCP server in C++ that listens for incoming connections, handles client requests in separate child processes, and responds to clients after processing their data.\n\nFunction Description: The function `tcp_server_communication` creates a TCP server that binds to a specified port, listens for incoming connections, and forks child processes to handle each client connection. Each child process reads a character from the client, increments it after a delay, and sends it back before terminating.\n\nInput: None (The function uses predefined constants: port number 9736 and INADDR_ANY for binding to all available network interfaces)\n\nOutput: None (The function runs indefinitely, servicing client requests and doesn't return any value)\n\nNote: The function includes signal handling to prevent zombie processes from terminated child processes. Each client connection is handled in a separate child process while the parent process continues to accept new connections.",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <signal.h>\n\nvoid tcp_server_communication()\n{\n    int server_sockfd = -1;\n    int client_sockfd = -1;\n    int client_len = 0;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n    \n    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(9736);\n    \n    bind(server_sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(server_sockfd, 5);\n    signal(SIGCHLD, SIG_IGN);\n\n    while(1)\n    {\n        char ch = '\\0';\n        client_len = sizeof(client_addr);\n        client_sockfd = accept(server_sockfd, (struct sockaddr*)&client_addr,\n                               (socklen_t *)&client_len);\n\n        if(fork() == 0)\n        {\n            read(client_sockfd, &ch, 1);\n            sleep(5);\n            ch++;\n            write(client_sockfd, &ch, 1);\n            close(client_sockfd);\n            exit(0);\n        }\n        else\n        {\n            close(client_sockfd);\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "right_result": "#include <iostream>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <wait.h>\n\nvoid tcp_server_communication() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    int opt = 1;\n    char buffer[1024] = {0};\n    pid_t pid;\n\n    // Create socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return;\n    }\n\n    // Set socket options\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        std::cerr << \"Failed to set socket options\" << std::endl;\n        close(server_fd);\n        return;\n    }\n\n    // Bind the socket\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(9736);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        std::cerr << \"Failed to bind socket\" << std::endl;\n        close(server_fd);\n        return;\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        std::cerr << \"Failed to listen on socket\" << std::endl;\n        close(server_fd);\n        return;\n    }\n\n    // Signal handler for zombie processes\n    signal(SIGCHLD, SIG_IGN);\n\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            std::cerr << \"Failed to accept connection\" << std::endl;\n            continue;\n        }\n\n        // Fork child process\n        pid = fork();\n\n        if (pid == 0) {\n            // Child process\n            close(server_fd); // Close server socket in child\n\n            // Read character from client\n            int bytes_read = read(new_socket, buffer, 1);\n            if (bytes_read <= 0) {\n                std::cerr << \"No data received from client\" << std::endl;\n                close(new_socket);\n                exit(0);\n            }\n\n            // Increment character and delay\n            char c = buffer[0] + 1;\n            usleep(100000); // 100 milliseconds delay\n\n            // Send response back to client\n            write(new_socket, &c, 1);\n\n            close(new_socket);\n            exit(0);\n        } else {\n            // Parent process\n            close(new_socket);\n        }\n    }\n}"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a UDP receiver class in C++ that listens for incoming UDP packets on a specified port, processes them, and forwards them to a network handling component. The class should handle socket creation, binding, and packet reception in a non-blocking manner using polling.\n\nClass Description: The `UDPRecv` class is responsible for setting up a UDP socket server that listens for incoming messages on a specified port. It uses polling to check for incoming data without blocking, and forwards received messages to a network handling component (`DFNetWork`). The class manages the socket lifecycle and provides methods to initialize, start, and stop the receiver.\n\nAttributes:\n- m_poDFNetWork: [DFNetWork*] - Pointer to the network handling component that processes received messages\n- m_iSockFD: [int] - File descriptor for the UDP socket\n- m_bIsEnd: [bool] - Flag indicating whether the receiver should stop running\n- m_bIsStarted: [bool] - Flag indicating whether the receiver has started\n\nMethods:\n- UDPRecv(DFNetWork* poDFNetWork) -> [void] - Constructor that initializes the receiver with a network handling component\n- ~UDPRecv() -> [void] - Destructor that closes the socket if it's open\n- Stop() -> [void] - Signals the receiver to stop and waits for it to finish\n- Init(int iPort) -> [int] - Initializes the UDP socket and binds it to the specified port (returns 0 on success, -1 on failure)\n- run() -> [void] - Main execution loop that polls for incoming messages and processes them (runs in a separate thread)",
    "Canonical_solution": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include \"dfnetwork.h\"\n\nnamespace phxpaxos {\n\nclass UDPRecv\n{\npublic:\n    UDPRecv(DFNetWork * poDFNetWork);\n    ~UDPRecv();\n\n    void Stop();\n    int Init(const int iPort);\n    void run();\n\nprivate:\n    DFNetWork * m_poDFNetWork;\n    int m_iSockFD;\n    bool m_bIsEnd;\n    bool m_bIsStarted;\n};\n\nUDPRecv::UDPRecv(DFNetWork * poDFNetWork) \n    : m_poDFNetWork(poDFNetWork), m_iSockFD(-1), m_bIsEnd(false), m_bIsStarted(false)\n{\n}\n\nUDPRecv::~UDPRecv()\n{\n    if (m_iSockFD != -1)\n    {\n        close(m_iSockFD);\n        m_iSockFD = -1;\n    }\n}\n\nvoid UDPRecv::Stop()\n{\n    if (m_bIsStarted)\n    {\n        m_bIsEnd = true;\n        join();\n    }\n}\n\nint UDPRecv::Init(const int iPort)\n{\n    if ((m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0)) < 0) \n    {\n        return -1;\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(iPort);\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    int enable = 1;\n    setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int));\n\n    if (bind(m_iSockFD, (struct sockaddr *)&addr, sizeof(addr)) < 0) \n    {\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid UDPRecv::run()\n{\n    m_bIsStarted = true;\n\n    char sBuffer[65536] = {0};\n\n    struct sockaddr_in addr;\n    socklen_t addr_len = sizeof(struct sockaddr_in);\n    memset(&addr, 0, sizeof(addr));\n\n    while(true)\n    {\n        if (m_bIsEnd)\n        {\n            return;\n        }\n\n        struct pollfd fd;\n        int ret;\n\n        fd.fd = m_iSockFD;\n        fd.events = POLLIN;\n        ret = poll(&fd, 1, 500);\n\n        if (ret == 0 || ret == -1)\n        {\n            continue;\n        }\n        \n        int iRecvLen = recvfrom(m_iSockFD, sBuffer, sizeof(sBuffer), 0,\n                (struct sockaddr *)&addr, &addr_len);\n\n        if (iRecvLen > 0)\n        {\n            m_poDFNetWork->OnReceiveMessage(sBuffer, iRecvLen);\n        }\n    }\n}\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 152,
    "right_result": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <poll.h>\n#include <cstring>\n#include <thread>\n#include <atomic>\n\nclass DFNetWork {\npublic:\n    virtual void ProcessMessage(const char* data, size_t length) = 0;\n};\n\nclass UDPRecv {\npublic:\n    UDPRecv(DFNetWork* poDFNetWork) : m_poDFNetWork(poDFNetWork), m_bIsEnd(false), m_bIsStarted(false) {}\n\n    ~UDPRecv() {\n        if (m_iSockFD >= 0) {\n            close(m_iSockFD);\n        }\n    }\n\n    void Stop() {\n        m_bIsEnd = true;\n        if (m_bIsStarted) {\n            std::thread t([this]() {\n                while (!m_bIsEnd) {\n                    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n                }\n            });\n            t.join();\n        }\n    }\n\n    int Init(int iPort) {\n        m_iSockFD = socket(AF_INET, SOCK_DGRAM, 0);\n        if (m_iSockFD < 0) {\n            return -1;\n        }\n\n        struct sockaddr_in server_addr;\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(iPort);\n        server_addr.sin_addr.s_addr = INADDR_ANY;\n\n        if (bind(m_iSockFD, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n            close(m_iSockFD);\n            m_iSockFD = -1;\n            return -1;\n        }\n\n        m_bIsStarted = true;\n        return 0;\n    }\n\n    void run() {\n        while (!m_bIsEnd) {\n            struct pollfd fds[1];\n            fds[0].fd = m_iSockFD;\n            fds[0].events = POLLIN;\n\n            int ret = poll(fds, 1, 100);\n            if (ret > 0 && fds[0].revents & POLLIN) {\n                char buffer[4096];\n                struct sockaddr_in client_addr;\n                socklen_t client_len = sizeof(client_addr);\n                int len = recvfrom(m_iSockFD, buffer, sizeof(buffer), 0, (struct sockaddr*)&client_addr, &client_len);\n                if (len > 0) {\n                    m_poDFNetWork->ProcessMessage(buffer, len);\n                }\n            }\n        }\n    }\n\nprivate:\n    DFNetWork* m_poDFNetWork;\n    int m_iSockFD;\n    std::atomic<bool> m_bIsEnd;\n    std::atomic<bool> m_bIsStarted;\n};"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create a UDP server class using Boost.Asio that asynchronously receives datagrams and sends responses.\n\nClass Description: The udp_server class implements a UDP server that listens for incoming datagrams on a specified port and responds with a daytime string. It uses Boost.Asio for asynchronous network operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received message\n- recv_buffer_: [std::array<char, 1>] - Buffer for receiving incoming datagrams\n\nMethods:\n- udp_server([boost::asio::io_context&] io_context) -> [void] - Constructor that initializes the UDP socket and starts listening\n- start_receive() -> [void] - Begins asynchronous reception of UDP datagrams\n- handle_receive([const boost::system::error_code&] error) -> [void] - Callback for handling received datagrams and sending responses\n- handle_send([std::shared_ptr<std::string>] message) -> [void] - Callback for handling completed send operations",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error));\n  }\n\n  void handle_receive(const boost::system::error_code& error)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/)\n  {\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/array.hpp>\n#include <memory>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context) : socket_(io_context), recv_buffer_(1) {\n        socket_.open(boost::asio::ip::udp::v4());\n        socket_.bind(boost::asio::ip::udp::endpoint(boost::asio::ip::tcp::v4(), 12345));\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            [&](const boost::system::error_code& error) {\n                if (!error) {\n                    handle_receive(std::string(recv_buffer_));\n                } else {\n                    // Handle error\n                }\n            });\n    }\n\n    void handle_receive(const std::string& message) {\n        // Send response with current time\n        std::string response = \"Daytime: \" + std::to_string(std::time(0));\n        socket_.async_send_to(boost::asio::buffer(response), remote_endpoint_,\n            [&](const boost::system::error_code& error) {\n                if (!error) {\n                    handle_send(response);\n                } else {\n                    // Handle error\n                }\n            });\n    }\n\n    void handle_send(const std::string& message) {\n        // Handle successful send\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    boost::array<char, 1> recv_buffer_;\n};"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nClass Description: The `udp_server` class implements a UDP server that listens on a specified port (13 in this case) for incoming datagrams. When a datagram is received, it responds with the current daytime string. The class uses asynchronous operations for receiving and sending data.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- remote_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last received datagram\n- recv_buffer_: [std::array<char, 1>] - Buffer for storing received data\n\nMethods:\n- Constructor: [udp_server]([boost::asio::io_context& io_context]) -> [void] - Initializes the UDP socket and starts listening for incoming datagrams\n- start_receive: [start_receive]() -> [void] - Begins an asynchronous receive operation on the socket\n- handle_receive: [handle_receive]([const boost::system::error_code& error, std::size_t bytes_transferred]) -> [void] - Handles the completion of a receive operation and initiates a response\n- handle_send: [handle_send]([std::shared_ptr<std::string> message, const boost::system::error_code& error, std::size_t bytes_transferred]) -> [void] - Handles the completion of a send operation\n- make_daytime_string: [make_daytime_string]() -> [std::string] - Generates and returns the current daytime string",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <memory>\n#include <string>\n#include <array>\n\nusing boost::asio::ip::udp;\n\nclass udp_server\n{\npublic:\n  udp_server(boost::asio::io_context& io_context)\n    : socket_(io_context, udp::endpoint(udp::v4(), 13))\n  {\n    start_receive();\n  }\n\nprivate:\n  void start_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(recv_buffer_), remote_endpoint_,\n        std::bind(&udp_server::handle_receive, this,\n          boost::asio::placeholders::error,\n          boost::asio::placeholders::bytes_transferred));\n  }\n\n  void handle_receive(const boost::system::error_code& error,\n      std::size_t /*bytes_transferred*/)\n  {\n    if (!error)\n    {\n      std::shared_ptr<std::string> message(\n          new std::string(make_daytime_string()));\n\n      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,\n          std::bind(&udp_server::handle_send, this, message,\n            boost::asio::placeholders::error,\n            boost::asio::placeholders::bytes_transferred));\n\n      start_receive();\n    }\n  }\n\n  void handle_send(std::shared_ptr<std::string> /*message*/,\n      const boost::system::error_code& /*error*/,\n      std::size_t /*bytes_transferred*/)\n  {\n  }\n\n  std::string make_daytime_string()\n  {\n    using namespace std;\n    time_t now = time(0);\n    return ctime(&now);\n  }\n\n  udp::socket socket_;\n  udp::endpoint remote_endpoint_;\n  std::array<char, 1> recv_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/array.hpp>\n#include <ctime>\n#include <string>\n\nclass udp_server {\npublic:\n    udp_server(boost::asio::io_context& io_context)\n        : socket_(io_context), remote_endpoint_(), recv_buffer_() {\n        socket_.open(boost::asio::ip::udp::v4());\n        socket_.bind(boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 13));\n        start_receive();\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(boost::asio::buffer(recv_buffer_), remote_endpoint_,\n            boost::bind(&udp_server::handle_receive, this,\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_receive(const boost::system::error_code& error,\n        std::size_t bytes_transferred) {\n        if (!error) {\n            std::string message = make_daytime_string();\n            socket_.async_send_to(boost::asio::buffer(message),\n                remote_endpoint_,\n                boost::bind(&udp_server::handle_send, this,\n                    boost::shared_ptr<std::string>(&message, nullptr),\n                    boost::asio::placeholders::error,\n                    boost::asio::placeholders::bytes_transferred));\n        } else {\n            // Handle error\n        }\n    }\n\n    void handle_send(std::shared_ptr<std::string> message,\n        const boost::system::error_code& error,\n        std::size_t bytes_transferred) {\n        if (!error) {\n            // Successfully sent the message\n        } else {\n            // Handle error\n        }\n    }\n\nprivate:\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint remote_endpoint_;\n    boost::array<char, 1> recv_buffer_;\n\n    std::string make_daytime_string() {\n        time_t now = time(0);\n        char buffer[64];\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", localtime(&now));\n        return std::string(buffer);\n    }\n};"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a C++ class that implements HTTP client functionality using libcurl for making HTTP requests to a specified base URL.\n\nClass Description: The HTTPClient class provides a simple interface for making HTTP GET requests to a given base URL. It handles libcurl initialization, request configuration, execution, and cleanup, while providing a method to append endpoints to the base URL and make requests.\n\nAttributes:\nbaseURL: std::string - The base URL to which endpoints will be appended for HTTP requests\n\nMethods:\nmakeRequest: makeRequest(const std::string& endpoint) -> std::string - Makes an HTTP GET request to the base URL plus the specified endpoint, returning the response as a string\nwrite_to_string: write_to_string(void* ptr, size_t size, size_t count, void* stream) -> size_t - Static callback function for libcurl to write response data into a string",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <sstream>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseUrl) : baseURL(baseUrl) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        CURL* curl = curl_easy_init();\n        std::string response;\n\n        if (curl) {\n            std::string URL = baseURL + endpoint;\n            curl_easy_setopt(curl, CURLOPT_URL, URL.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n            curl_easy_perform(curl);\n            curl_easy_cleanup(curl);\n        }\n\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        ((std::string*)stream)->append((char*)ptr, 0, size*count);\n        return size*count;\n    }\n\n    std::string baseURL;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "#include <curl/curl.h>\n#include <string>\n#include <vector>\n\nclass HTTPClient {\npublic:\n    HTTPClient(const std::string& baseURL) : baseURL_(baseURL) {}\n\n    std::string makeRequest(const std::string& endpoint) {\n        std::string url = baseURL_ + endpoint;\n        std::string response;\n\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            return \"\";\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_string);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            curl_easy_cleanup(curl);\n            return \"Error: \" + std::string(curl_easy_strerror(res));\n        }\n\n        curl_easy_cleanup(curl);\n        return response;\n    }\n\nprivate:\n    static size_t write_to_string(void* ptr, size_t size, size_t count, void* stream) {\n        std::string* data = static_cast<std::string*>(stream);\n        data->append(static_cast<char*>(ptr), size * count);\n        return size * count;\n    }\n\n    std::string baseURL_;\n};"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that can asynchronously receive and send datagrams.\n\nClass Description: The `server` class represents a UDP server that listens on a specified port, receives incoming datagrams asynchronously, and sends responses back to the sender. It utilizes Boost.Asio for asynchronous I/O operations.\n\nAttributes:\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for communication\n- sender_endpoint_: [boost::asio::ip::udp::endpoint] - Stores the endpoint of the last sender\n- max_length: [enum] - Maximum size of the receive buffer (1024 bytes)\n- data_: [char[max_length]] - Buffer for storing received data\n\nMethods:\n- server: [constructor](boost::asio::io_context& io_context, short port) -> void - Initializes the UDP socket and starts the receive operation\n- do_receive: [method]() -> void - Asynchronously receives data from clients and triggers do_send if data is received\n- do_send: [method](std::size_t length) -> void - Asynchronously sends the received data back to the sender",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n\nusing boost::asio::ip::udp;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, short port)\n    : socket_(io_context, udp::endpoint(udp::v4(), port))\n  {\n    do_receive();\n  }\n\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_, max_length), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t bytes_recvd)\n        {\n          if (!ec && bytes_recvd > 0)\n          {\n            do_send(bytes_recvd);\n          }\n          else\n          {\n            do_receive();\n          }\n        });\n  }\n\n  void do_send(std::size_t length)\n  {\n    socket_.async_send_to(\n        boost::asio::buffer(data_, length), sender_endpoint_,\n        [this](boost::system::error_code /*ec*/, std::size_t /*bytes_sent*/)\n        {\n          do_receive();\n        });\n  }\n\nprivate:\n  udp::socket socket_;\n  udp::endpoint sender_endpoint_;\n  enum { max_length = 1024 };\n  char data_[max_length];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nclass server {\npublic:\n    server(boost::asio::io_context& io_context, short port)\n        : io_context_(io_context), socket_(io_context),\n          sender_endpoint_(), max_length_(1024), data_() {\n        boost::asio::ip::udp::endpoint endpoint(\n            boost::asio::ip::tcp::v4(), port);\n        socket_.bind(endpoint);\n\n        do_receive();\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    enum { max_length_ = 1024 };\n    char data_[max_length_];\n\n    void do_receive() {\n        socket_.async_receive_from(\n            boost::asio::buffer(data_, max_length_),\n            sender_endpoint_,\n            boost::bind(&server::do_receive_handler, this,\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n\n    void do_receive_handler(const boost::system::error_code& error,\n        std::size_t bytes_recvd) {\n        if (!error && bytes_recvd > 0) {\n            do_send(bytes_recvd);\n        } else {\n            std::cerr << \"Receive failed: \" << error.message() << std::endl;\n            do_receive();\n        }\n    }\n\n    void do_send(std::size_t length) {\n        socket_.async_send_to(\n            boost::asio::buffer(data_, length),\n            sender_endpoint_,\n            boost::bind(&server::do_send_handler, this,\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n\n    void do_send_handler(const boost::system::error_code& error,\n        std::size_t bytes_sent) {\n        if (error) {\n            std::cerr << \"Send failed: \" << error.message() << std::endl;\n        } else {\n            std::cout << \"Sent \" << bytes_sent << \" bytes\" << std::endl;\n        }\n        do_receive();\n    }\n};"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Implement a UDP server using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nFunction Description: The function `udp_server` creates a UDP server that listens on port 13 (daytime protocol port). When it receives any datagram from a client, it responds with the current time in string format. The server runs indefinitely until an exception occurs.\n\nInput: None\n\nOutput: None (The function runs indefinitely and sends responses to clients, but doesn't return any value)",
    "Canonical_solution": "#include <array>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n  using namespace std;\n  time_t now = time(0);\n  return ctime(&now);\n}\n\nvoid udp_server()\n{\n  try\n  {\n    boost::asio::io_context io_context;\n\n    udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n    for (;;)\n    {\n      std::array<char, 1> recv_buf;\n      udp::endpoint remote_endpoint;\n      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);\n\n      std::string message = make_daytime_string();\n\n      boost::system::error_code ignored_error;\n      socket.send_to(boost::asio::buffer(message),\n          remote_endpoint, 0, ignored_error);\n    }\n  }\n  catch (std::exception& e)\n  {\n    std::cerr << e.what() << std::endl;\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <ctime>\n\nvoid udp_server() {\n    boost::asio::io_context io_context;\n\n    boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::udp::v4(), 13);\n\n    boost::asio::ip::udp::socket socket(io_context, endpoint.protocol());\n    socket.bind(endpoint);\n\n    for (;;) {\n        boost::array<char, 1024> buffer;\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        size_t length = socket.receive_from(boost::asio::buffer(buffer), sender_endpoint);\n\n        std::time_t now = std::time(nullptr);\n        char response[1024];\n        std::strftime(response, sizeof(response), \"%Y-%m-%d %H:%M:%S\", std::localtime(&now));\n\n        socket.send_to(boost::asio::buffer(response, std::strlen(response)), sender_endpoint);\n    }\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a UDP multicast sender class using Boost.Asio that periodically sends messages to a specified multicast address.\n\nClass Description: The `sender` class encapsulates functionality for sending UDP multicast messages at regular intervals. It uses Boost.Asio for asynchronous network operations and timer management.\n\nAttributes:\n- endpoint_: [boost::asio::ip::udp::endpoint] - The multicast endpoint (address + port) to send messages to\n- socket_: [boost::asio::ip::udp::socket] - The UDP socket used for sending messages\n- timer_: [boost::asio::steady_timer] - Timer used to schedule message sends\n- message_count_: [int] - Counter tracking the number of messages sent\n- message_: [std::string] - The current message content to be sent\n\nMethods:\n- sender([boost::asio::io_context&] io_context, [const boost::asio::ip::address&] multicast_address) -> [void] - Constructor that initializes the sender with IO context and multicast address\n- do_send() -> [void] - Asynchronously sends the current message to the multicast endpoint\n- do_timeout() -> [void] - Sets up a timer to schedule the next message send after a delay",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <string>\n#include <chrono>\n\nclass sender\n{\npublic:\n  sender(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& multicast_address)\n    : endpoint_(multicast_address, multicast_port),\n      socket_(io_context, endpoint_.protocol()),\n      timer_(io_context),\n      message_count_(0)\n  {\n    do_send();\n  }\n\nprivate:\n  void do_send()\n  {\n    std::ostringstream os;\n    os << \"Message \" << message_count_++;\n    message_ = os.str();\n\n    socket_.async_send_to(\n        boost::asio::buffer(message_), endpoint_,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && message_count_ < max_message_count)\n            do_timeout();\n        });\n  }\n\n  void do_timeout()\n  {\n    timer_.expires_after(std::chrono::seconds(1));\n    timer_.async_wait(\n        [this](boost::system::error_code ec)\n        {\n          if (!ec)\n            do_send();\n        });\n  }\n\nprivate:\n  boost::asio::ip::udp::endpoint endpoint_;\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::steady_timer timer_;\n  int message_count_;\n  std::string message_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <string>\n\nclass sender {\npublic:\n    sender(boost::asio::io_context& io_context, const boost::asio::ip::address& multicast_address)\n        : endpoint_(boost::asio::ip::udp::endpoint(multicast_address, 5000)),\n          socket_(io_context),\n          timer_(io_context),\n          message_count_(0),\n          message_(\"Hello, world!\")\n    {\n        socket_.open(endpoint_.protocol());\n        socket_.set_option(boost::asio::ip::multicast::enable_all_multicast(true));\n        socket_.set_option(boost::asio::ip::multicast::join_group(endpoint_));\n    }\n\n    void do_send() {\n        socket_.send_to(boost::asio::buffer(message_), endpoint_);\n        ++message_count_;\n    }\n\n    void do_timeout() {\n        timer_.expires_after(1s);\n        timer_.async_wait(boost::bind(&sender::do_send, this));\n    }\n\nprivate:\n    boost::asio::ip::udp::endpoint endpoint_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::steady_timer timer_;\n    int message_count_;\n    std::string message_;\n};"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a UDP client communication function using Boost.Asio to send a message to a specified host and port, and receive a response.\n\nFunction Description: The function establishes a UDP client connection, sends a message to a specified server, and waits to receive a response. It uses Boost.Asio for asynchronous UDP operations.\n\nInput:\n- host: [std::string] - The hostname or IP address of the UDP server to connect to\n- port: [std::string] - The port number of the UDP server\n- message: [std::string] - The message to be sent to the server\n\nOutput: None (The function receives a reply from the server but doesn't return it. In a real implementation, you might want to return the reply or process it further.)",
    "Canonical_solution": "#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client_communication(const std::string& host, const std::string& port, const std::string& message)\n{\n    boost::asio::io_context io_context;\n    udp::socket s(io_context, udp::endpoint(udp::v4(), 0));\n    udp::resolver resolver(io_context);\n    udp::resolver::results_type endpoints = resolver.resolve(udp::v4(), host, port);\n\n    size_t request_length = message.length();\n    s.send_to(boost::asio::buffer(message, request_length), *endpoints.begin());\n\n    char reply[max_length];\n    udp::endpoint sender_endpoint;\n    size_t reply_length = s.receive_from(boost::asio::buffer(reply, max_length), sender_endpoint);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n\nvoid send_udp_message(const std::string& host, const std::string& port, const std::string& message) {\n    try {\n        boost::asio::io_context io_context;\n\n        boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::address::from_string(host), std::stoi(port));\n\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::socket::type::datagram);\n        socket.open(boost::asio::ip::udp::socket::type::datagram);\n\n        boost::asio::ip::udp::endpoint receiver_endpoint = endpoint;\n\n        boost::system::error_code ec;\n        socket.send_to(boost::asio::buffer(message), receiver_endpoint, 0, ec);\n        if (ec) {\n            std::cerr << \"Send failed: \" << ec.message() << std::endl;\n            return;\n        }\n\n        char buffer[1024];\n        boost::asio::ip::udp::endpoint sender_endpoint;\n        std::size_t len = socket.receive_from(boost::asio::buffer(buffer, sizeof(buffer)), sender_endpoint, 0, ec);\n        if (ec) {\n            std::cerr << \"Receive failed: \" << ec.message() << std::endl;\n            return;\n        }\n\n        std::cout << \"Received: \" << std::string(buffer, len) << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a UDP server class using Boost.Asio that handles incoming UDP packets, processes them, and sends replies back to clients. The server should run asynchronously in a separate thread and provide a callback mechanism for handling incoming requests.\n\nClass Description: UDPServer::Impl is an implementation class for a UDP server that listens for incoming packets, validates them, and forwards valid packets to a callback function. It also provides functionality to send replies back to clients.\n\nAttributes:\n- worker_thread: std::thread - Thread that runs the IO context for asynchronous operations\n- io_context: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket: boost::asio::ip::udp::socket - UDP socket for communication\n- request_buffer: std::array<u8, MAX_PACKET_SIZE> - Buffer for storing incoming UDP packets\n- remote_endpoint: boost::asio::ip::udp::endpoint - Stores the endpoint of the last received packet\n- new_request_callback: std::function<void(std::unique_ptr<Packet>)> - Callback function for handling new valid packets\n\nMethods:\n- Impl(std::function<void(std::unique_ptr<Packet>)>) -> None - Constructor that initializes the UDP socket and starts the receive loop\n- ~Impl() -> None - Destructor that stops the IO context and joins the worker thread\n- StartReceive() -> None - Starts an asynchronous receive operation on the UDP socket\n- HandleReceive(const boost::system::error_code&, std::size_t) -> None - Handles received data, validates packets, and triggers the callback for valid packets\n- SendReply(boost::asio::ip::udp::endpoint, Packet&) -> None - Sends a reply packet back to the specified endpoint",
    "Canonical_solution": "#include <thread>\n#include <boost/asio.hpp>\n#include <functional>\n#include <memory>\n#include <array>\n#include \"common/common_types.h\"\n#include \"common/logging/log.h\"\n#include \"core/rpc/packet.h\"\n\nnamespace Core::RPC {\n\nclass UDPServer::Impl {\npublic:\n    explicit Impl(std::function<void(std::unique_ptr<Packet>)> new_request_callback)\n        : socket(io_context, boost::asio::ip::udp::endpoint(boost::asio::ip::udp::v4(), 45987)),\n          new_request_callback(std::move(new_request_callback)) {\n\n        StartReceive();\n        worker_thread = std::thread([this] { io_context.run(); });\n    }\n\n    ~Impl() {\n        io_context.stop();\n        worker_thread.join();\n    }\n\nprivate:\n    void StartReceive() {\n        socket.async_receive_from(boost::asio::buffer(request_buffer), remote_endpoint,\n                                  [this](const boost::system::error_code& error, std::size_t size) {\n                                      HandleReceive(error, size);\n                                  });\n    }\n\n    void HandleReceive(const boost::system::error_code& error, std::size_t size) {\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to receive data on UDP socket: {}\", error.message());\n        } else if (size >= MIN_PACKET_SIZE && size <= MAX_PACKET_SIZE) {\n            PacketHeader header;\n            std::memcpy(&header, request_buffer.data(), sizeof(header));\n            if ((size - MIN_PACKET_SIZE) == header.packet_size) {\n                u8* data = request_buffer.data() + MIN_PACKET_SIZE;\n                std::function<void(Packet&)> send_reply_callback =\n                    std::bind(&Impl::SendReply, this, remote_endpoint, std::placeholders::_1);\n                std::unique_ptr<Packet> new_packet =\n                    std::make_unique<Packet>(header, data, send_reply_callback);\n\n                new_request_callback(std::move(new_packet));\n            }\n        } else {\n            LOG_WARNING(RPC_Server, \"Received message with wrong size: {}\", size);\n        }\n        StartReceive();\n    }\n\n    void SendReply(boost::asio::ip::udp::endpoint endpoint, Packet& reply_packet) {\n        std::vector<u8> reply_buffer(MIN_PACKET_SIZE + reply_packet.GetPacketDataSize());\n        auto reply_header = reply_packet.GetHeader();\n\n        std::memcpy(reply_buffer.data(), &reply_header, sizeof(reply_header));\n        std::memcpy(reply_buffer.data() + (4 * sizeof(u32)), reply_packet.GetPacketData().data(),\n                    reply_packet.GetPacketDataSize());\n\n        boost::system::error_code error;\n        socket.send_to(boost::asio::buffer(reply_buffer), endpoint, 0, error);\n\n        if (error) {\n            LOG_WARNING(RPC_Server, \"Failed to send reply: {}\", error.message());\n        } else {\n            LOG_INFO(RPC_Server, \"Sent reply version({}) id=({}) type=({}) size=({})\",\n                     reply_packet.GetVersion(), reply_packet.GetId(), reply_packet.GetPacketType(),\n                     reply_packet.GetPacketDataSize());\n        }\n    }\n\n    std::thread worker_thread;\n    boost::asio::io_context io_context;\n    boost::asio::ip::udp::socket socket;\n    std::array<u8, MAX_PACKET_SIZE> request_buffer;\n    boost::asio::ip::udp::endpoint remote_endpoint;\n    std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n};\n\n} // namespace Core::RPC",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/function.hpp>\n#include <array>\n#include <memory>\n\nclass Packet {\npublic:\n    std::string data;\n};\n\nclass UDPServer {\npublic:\n    class Impl {\n    public:\n        Impl(std::function<void(std::unique_ptr<Packet>)> callback);\n        ~Impl();\n\n        void StartReceive();\n        void HandleReceive(const boost::system::error_code&, std::size_t);\n        void SendReply(const boost::asio::ip::udp::endpoint& endpoint, Packet& packet);\n\n    private:\n        std::thread worker_thread;\n        boost::asio::io_context io_context;\n        boost::asio::ip::udp::socket socket;\n        std::array<unsigned char, 1024> request_buffer;\n        boost::asio::ip::udp::endpoint remote_endpoint;\n        std::function<void(std::unique_ptr<Packet>)> new_request_callback;\n    };\n\n    UDPServer(std::function<void(std::unique_ptr<Packet>)> callback);\n    ~UDPServer();\n\nprivate:\n    UDPServer::Impl* impl;\n    void Start();\n};\n\nUDPServer::Impl::Impl(std::function<void(std::unique_ptr<Packet>)> callback) \n    : new_request_callback(callback), socket(io_context), remote_endpoint() {\n    try {\n        boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);\n        socket.open(endpoint.protocol());\n        socket.bind(endpoint);\n    } catch (const boost::system::system_error& e) {\n        // Handle error\n    }\n}\n\nUDPServer::Impl::~Impl() {\n    io_context.stop();\n    worker_thread.join();\n}\n\nvoid UDPServer::Impl::StartReceive() {\n    socket.async_receive_from(\n        boost::asio::buffer(request_buffer), remote_endpoint,\n        [&](const boost::system::error_code& ec, std::size_t bytes_received) {\n            if (!ec && bytes_received > 0) {\n                HandleReceive(ec, bytes_received);\n            }\n            StartReceive();\n        }\n    );\n}\n\nvoid UDPServer::Impl::HandleReceive(const boost::system::error_code& ec, std::size_t bytes_received) {\n    if (ec) {\n        // Handle error\n        return;\n    }\n\n    std::unique_ptr<Packet> packet(new Packet());\n    packet->data = std::string(reinterpret_cast<char*>(request_buffer.data()), bytes_received);\n    new_request_callback(packet);\n}\n\nvoid UDPServer::Impl::SendReply(const boost::asio::ip::udp::endpoint& endpoint, Packet& packet) {\n    boost::asio::write(socket, boost::asio::buffer(packet.data), boost::asio::transfer_all());\n}\n\nUDPServer::UDPServer(std::function<void(std::unique_ptr<Packet>)> callback) \n    : impl(new UDPServer::Impl(callback)) {\n    impl->worker_thread = std::thread([this]() { io_context.run(); });\n    impl->StartReceive();\n}\n\nUDPServer::~UDPServer() {\n    if (impl) {\n        impl->~Impl();\n        delete impl;\n    }\n}"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create a UDP multicast receiver class using Boost.Asio that listens for incoming datagrams on a specified multicast address and port, and prints received messages to the console.\n\nClass Description: The `receiver` class encapsulates functionality for receiving UDP multicast messages. It initializes a UDP socket, joins a multicast group, and asynchronously receives datagrams, printing their contents to standard output.\n\nAttributes:\n- socket_: boost::asio::ip::udp::socket - The UDP socket used for communication\n- sender_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint of the sender of the last received message\n- data_: std::array<char, 1024> - Buffer for storing received data\n\nMethods:\n- receiver(boost::asio::io_context&, const boost::asio::ip::address&, const boost::asio::ip::address&) -> None - Constructor that initializes the socket, binds it to the listening address and port, joins the multicast group, and starts receiving\n- do_receive() -> None - Private method that asynchronously receives data and prints it to console, then continues listening for more data",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nconstexpr short multicast_port = 30001;\n\nclass receiver\n{\npublic:\n  receiver(boost::asio::io_context& io_context,\n      const boost::asio::ip::address& listen_address,\n      const boost::asio::ip::address& multicast_address)\n    : socket_(io_context)\n  {\n    // Create the socket so that multiple may be bound to the same address.\n    boost::asio::ip::udp::endpoint listen_endpoint(\n        listen_address, multicast_port);\n    socket_.open(listen_endpoint.protocol());\n    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));\n    socket_.bind(listen_endpoint);\n\n    // Join the multicast group.\n    socket_.set_option(\n        boost::asio::ip::multicast::join_group(multicast_address));\n\n    do_receive();\n  }\n\nprivate:\n  void do_receive()\n  {\n    socket_.async_receive_from(\n        boost::asio::buffer(data_), sender_endpoint_,\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            std::cout.write(data_.data(), length);\n            std::cout << std::endl;\n\n            do_receive();\n          }\n        });\n  }\n\n  boost::asio::ip::udp::socket socket_;\n  boost::asio::ip::udp::endpoint sender_endpoint_;\n  std::array<char, 1024> data_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <iostream>\n#include <array>\n\nclass receiver {\npublic:\n    receiver(boost::asio::io_context& io_context, const boost::asio::ip::address& listen_address, const boost::asio::ip::address& multicast_address)\n        : socket_(io_context), sender_endpoint_(), data_() {\n        // Bind the socket to the listening address and port\n        boost::asio::ip::udp::endpoint listen_endpoint(listen_address, 12345);\n        socket_.bind(listen_endpoint);\n\n        // Join the multicast group\n        boost::asio::ip::multicast_options options;\n        options.set_multicast_loop(true);\n        socket_.set_option(options);\n\n        // Start receiving data\n        do_receive();\n    }\n\nprivate:\n    void do_receive() {\n        socket_.async_receive_from(boost::asio::buffer(data_), sender_endpoint_,\n            [&](boost::system::error_code ec, std::size_t bytes_recvd) {\n                if (!ec && bytes_recvd > 0) {\n                    std::cout << \"Received: \" << std::string(data_, bytes_recvd) << std::endl;\n                }\n                if (!ec) {\n                    do_receive();\n                }\n            });\n    }\n\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> data_;\n};"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a UDP client function using Boost.Asio that sends a request to a UDP server and receives a response.\n\nFunction Description: The function establishes a UDP connection to a specified host, sends a minimal request packet, waits for a response, and prints the received data to standard output. It uses Boost.Asio for asynchronous UDP operations.\n\nInput: \n- host: std::string - The hostname or IP address of the UDP server to connect to\n\nOutput: \n- None (void function), but prints the received data to standard output\n\nNote: The function uses a fixed service name \"daytime\" (port 13) for demonstration purposes. In a real application, this would typically be configurable. The function handles both IPv4 and UDP protocol operations.",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client(const std::string& host)\n{\n    boost::asio::io_context io_context;\n\n    udp::resolver resolver(io_context);\n    udp::endpoint receiver_endpoint =\n      *resolver.resolve(udp::v4(), host, \"daytime\").begin();\n\n    udp::socket socket(io_context);\n    socket.open(udp::v4());\n\n    std::array<char, 1> send_buf  = {{ 0 }};\n    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n\n    std::array<char, 128> recv_buf;\n    udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(\n        boost::asio::buffer(recv_buf), sender_endpoint);\n\n    std::cout.write(recv_buf.data(), len);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <iostream>\n\nvoid send_udp_request(const std::string& host) {\n    try {\n        boost::asio::io_context io_context;\n\n        // Create a UDP socket\n        boost::asio::ip::udp::socket socket(io_context, boost::asio::ip::udp::v4());\n\n        // Resolve the server address and port\n        boost::asio::ip::udp::endpoint endpoint = boost::asio::ip::resolve_query(\n            host, \"daytime\", boost::asio::ip::udp::v4()\n        );\n\n        // Send the request\n        std::string request = \"HELLO\";\n        socket.send_to(boost::asio::buffer(request), endpoint);\n\n        // Receive the response\n        std::array<char, 1024> buffer;\n        boost::system::error_code ec;\n        size_t bytes_received = socket.receive_from(boost::asio::buffer(buffer), endpoint, ec);\n\n        if (ec) {\n            std::cerr << \"Error receiving response: \" << ec.message() << std::endl;\n            return;\n        }\n\n        // Print the received data\n        std::cout << \"Received response: \" << std::string(buffer.begin(), buffer.begin() + bytes_received) << std::endl;\n    }\n    catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a UDP-based client-server communication system using Boost.Asio in C++ that demonstrates asynchronous sending and receiving of datagrams.\n\nClass Description: The `udp_communicator` class provides asynchronous UDP communication capabilities for both sending and receiving datagrams. It manages socket operations, IO context, and buffers for network communication.\n\nAttributes:\n- io_context_: boost::asio::io_context - Manages asynchronous operations for Boost.Asio\n- socket_: boost::asio::ip::udp::socket - Represents the UDP socket for communication\n- receiver_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint information for receiving data\n- sender_endpoint_: boost::asio::ip::udp::endpoint - Stores the endpoint information of the sender\n- receive_buffer_: std::array<char, 1024> - Buffer for storing received data\n- send_buffer_: std::string - Buffer for storing data to be sent\n\nMethods:\n- constructor(io_context, port) -> void - Initializes the UDP socket and binds it to the specified port\n- start_receive() -> void - Begins asynchronous reception of UDP datagrams\n- handle_receive(error_code, bytes_transferred) -> void - Callback for handling received data\n- send_to(message, endpoint) -> void - Asynchronously sends a message to the specified endpoint\n- handle_send(error_code, bytes_transferred) -> void - Callback for handling send completion\n- get_socket() -> boost::asio::ip::udp::socket& - Returns a reference to the UDP socket\n- get_io_context() -> boost::asio::io_context& - Returns a reference to the IO context",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <istream>\n#include <ostream>\n#include \"icmp_header.hpp\"\n#include \"ipv4_header.hpp\"\n\nusing boost::asio::ip::icmp;\nusing boost::asio::steady_timer;\nnamespace chrono = boost::asio::chrono;\n\nclass pinger\n{\npublic:\n  pinger(boost::asio::io_context& io_context, const char* destination)\n    : resolver_(io_context), socket_(io_context, icmp::v4()),\n      timer_(io_context), sequence_number_(0), num_replies_(0)\n  {\n    destination_ = *resolver_.resolve(icmp::v4(), destination, \"\").begin();\n\n    start_send();\n    start_receive();\n  }\n\nprivate:\n  void start_send()\n  {\n    std::string body(\"\\\"Hello!\\\" from Asio ping.\");\n\n    icmp_header echo_request;\n    echo_request.type(icmp_header::echo_request);\n    echo_request.code(0);\n    echo_request.identifier(get_identifier());\n    echo_request.sequence_number(++sequence_number_);\n    compute_checksum(echo_request, body.begin(), body.end());\n\n    boost::asio::streambuf request_buffer;\n    std::ostream os(&request_buffer);\n    os << echo_request << body;\n\n    time_sent_ = steady_timer::clock_type::now();\n    socket_.send_to(request_buffer.data(), destination_);\n\n    num_replies_ = 0;\n    timer_.expires_at(time_sent_ + chrono::seconds(5));\n    timer_.async_wait(std::bind(&pinger::handle_timeout, this));\n  }\n\n  void handle_timeout()\n  {\n    if (num_replies_ == 0)\n      std::cout << \"Request timed out\" << std::endl;\n\n    timer_.expires_at(time_sent_ + chrono::seconds(1));\n    timer_.async_wait(std::bind(&pinger::start_send, this));\n  }\n\n  void start_receive()\n  {\n    reply_buffer_.consume(reply_buffer_.size());\n\n    socket_.async_receive(reply_buffer_.prepare(65536),\n        std::bind(&pinger::handle_receive, this, std::placeholders::_2));\n  }\n\n  void handle_receive(std::size_t length)\n  {\n    reply_buffer_.commit(length);\n\n    std::istream is(&reply_buffer_);\n    ipv4_header ipv4_hdr;\n    icmp_header icmp_hdr;\n    is >> ipv4_hdr >> icmp_hdr;\n\n    if (is && icmp_hdr.type() == icmp_header::echo_reply\n          && icmp_hdr.identifier() == get_identifier()\n          && icmp_hdr.sequence_number() == sequence_number_)\n    {\n      if (num_replies_++ == 0)\n        timer_.cancel();\n\n      chrono::steady_clock::time_point now = chrono::steady_clock::now();\n      chrono::steady_clock::duration elapsed = now - time_sent_;\n      std::cout << length - ipv4_hdr.header_length()\n        << \" bytes from \" << ipv4_hdr.source_address()\n        << \": icmp_seq=\" << icmp_hdr.sequence_number()\n        << \", ttl=\" << ipv4_hdr.time_to_live()\n        << \", time=\"\n        << chrono::duration_cast<chrono::milliseconds>(elapsed).count()\n        << std::endl;\n    }\n\n    start_receive();\n  }\n\n  static unsigned short get_identifier()\n  {\n#if defined(BOOST_ASIO_WINDOWS)\n    return static_cast<unsigned short>(::GetCurrentProcessId());\n#else\n    return static_cast<unsigned short>(::getpid());\n#endif\n  }\n\n  icmp::resolver resolver_;\n  icmp::endpoint destination_;\n  icmp::socket socket_;\n  steady_timer timer_;\n  unsigned short sequence_number_;\n  chrono::steady_clock::time_point time_sent_;\n  boost::asio::streambuf reply_buffer_;\n  std::size_t num_replies_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <array>\n#include <string>\n\nclass udp_communicator {\npublic:\n    udp_communicator(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context), socket_(io_context_), receiver_endpoint_(), sender_endpoint_(), receive_buffer_(), send_buffer_() {\n        boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::host_address::any(), port);\n        socket_.bind(endpoint);\n    }\n\n    void start_receive() {\n        socket_.async_receive_from(boost::asio::buffer(receive_buffer_), receiver_endpoint_,\n            [&](boost::system::error_code ec, std::size_t bytes_transferred) {\n                if (!ec) {\n                    send_buffer_ = std::string(receive_buffer_, bytes_transferred);\n                    handle_receive(ec, bytes_transferred);\n                } else {\n                    handle_receive(ec, 0);\n                }\n            });\n    }\n\n    void handle_receive(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            // Process received data\n            // For example, echo back the received message\n            send_to(send_buffer_, receiver_endpoint_);\n        }\n    }\n\n    void send_to(const std::string& message, const boost::asio::ip::udp::endpoint& endpoint) {\n        boost::asio::write(socket_, boost::asio::buffer(message));\n    }\n\n    void handle_send(boost::system::error_code ec, std::size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            // Handle successful send\n        }\n    }\n\n    boost::asio::ip::udp::socket& get_socket() {\n        return socket_;\n    }\n\n    boost::asio::io_context& get_io_context() {\n        return io_context_;\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::udp::socket socket_;\n    boost::asio::ip::udp::endpoint receiver_endpoint_;\n    boost::asio::ip::udp::endpoint sender_endpoint_;\n    std::array<char, 1024> receive_buffer_;\n    std::string send_buffer_;\n};"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Implement a server class that handles both TCP and UDP communications using Boost.Asio, managing client subscriptions and broadcasting data frames to subscribed clients.\n\nClass Description: The `server` class manages network communications using both TCP and UDP protocols. It accepts TCP connections for control messages, maintains a set of subscribed UDP endpoints, and periodically broadcasts data frames to all subscribed clients via UDP.\n\nAttributes:\n- acceptor_: [tcp::acceptor] - Handles incoming TCP connections\n- timer_: [boost::asio::steady_timer] - Manages periodic operations\n- udp_socket_: [udp::socket] - Handles UDP communications\n- next_frame_number_: [unsigned long] - Tracks the sequence number for frames\n- subscribers_: [std::set<udp::endpoint>] - Stores subscribed client endpoints\n\nMethods:\n- server([boost::asio::io_context&] io_context, [unsigned short] port) -> [void] - Constructor that initializes the server with IO context and port\n- handle_accept([const boost::system::error_code&] ec, [tcp_socket_ptr] socket) -> [void] - Handles new TCP connection acceptances\n- handle_control_request([const boost::system::error_code&] ec, [tcp_socket_ptr] socket, [control_request_ptr] request) -> [void] - Processes control requests from clients\n- handle_control_request_timer([tcp_socket_ptr] socket, [control_request_ptr] request, [timer_ptr] delay_timer) -> [void] - Handles delayed processing of control requests\n- handle_timer() -> [void] - Periodically broadcasts data frames to subscribed clients",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <set>\n#include <memory>\n#include \"protocol.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef std::shared_ptr<tcp::socket> tcp_socket_ptr;\ntypedef std::shared_ptr<boost::asio::steady_timer> timer_ptr;\ntypedef std::shared_ptr<control_request> control_request_ptr;\n\nclass server\n{\npublic:\n  server(boost::asio::io_context& io_context, unsigned short port)\n    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),\n      timer_(io_context),\n      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),\n      next_frame_number_(1)\n  {\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\n  void handle_accept(const boost::system::error_code& ec, tcp_socket_ptr socket)\n  {\n    if (!ec)\n    {\n      control_request_ptr request(new control_request);\n      boost::asio::async_read(*socket, request->to_buffers(),\n          std::bind(&server::handle_control_request, this,\n            boost::asio::placeholders::error, socket, request));\n    }\n\n    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));\n    acceptor_.async_accept(*new_socket,\n        std::bind(&server::handle_accept, this,\n          boost::asio::placeholders::error, new_socket));\n  }\n\n  void handle_control_request(const boost::system::error_code& ec,\n      tcp_socket_ptr socket, control_request_ptr request)\n  {\n    if (!ec)\n    {\n      timer_ptr delay_timer(\n          new boost::asio::steady_timer(acceptor_.get_executor()));\n      delay_timer->expires_after(boost::asio::chrono::seconds(2));\n      delay_timer->async_wait(\n          std::bind(&server::handle_control_request_timer, this,\n            socket, request, delay_timer));\n    }\n  }\n\n  void handle_control_request_timer(tcp_socket_ptr socket,\n      control_request_ptr request, timer_ptr /*delay_timer*/)\n  {\n    boost::system::error_code ec;\n    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);\n    if (!ec)\n    {\n      if (unsigned short old_port = request->old_port())\n      {\n        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);\n        subscribers_.erase(old_endpoint);\n      }\n\n      if (unsigned short new_port = request->new_port())\n      {\n        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);\n        subscribers_.insert(new_endpoint);\n      }\n    }\n\n    boost::asio::async_read(*socket, request->to_buffers(),\n        std::bind(&server::handle_control_request, this,\n          boost::asio::placeholders::error, socket, request));\n  }\n\n  void handle_timer()\n  {\n    double x = next_frame_number_ * 0.2;\n    double y = std::sin(x);\n    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));\n    std::string payload;\n    for (int i = 0; i < frame::payload_size; ++i)\n      payload += (i == char_index ? '*' : '.');\n\n    frame f(next_frame_number_++, payload);\n\n    std::set<udp::endpoint>::iterator j;\n    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)\n    {\n      boost::system::error_code ec;\n      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);\n    }\n\n    timer_.expires_after(boost::asio::chrono::milliseconds(100));\n    timer_.async_wait(std::bind(&server::handle_timer, this));\n  }\n\nprivate:\n  tcp::acceptor acceptor_;\n  boost::asio::steady_timer timer_;\n  udp::socket udp_socket_;\n  unsigned long next_frame_number_;\n  std::set<udp::endpoint> subscribers_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 153,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <set>\n#include <memory>\n#include <iostream>\n\nclass server {\npublic:\n    server(boost::asio::io_context& io_context, unsigned short port)\n        : io_context_(io_context),\n          acceptor_(io_context_, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)),\n          timer_(io_context_),\n          udp_socket_(io_context_),\n          next_frame_number_(0),\n          subscribers_() {\n        start_accept();\n        start_timer();\n    }\n\nprivate:\n    void start_accept() {\n        tcp::socket socket(io_context_);\n        acceptor_.accept(socket);\n        handle_accept(boost::system::error_code(), socket);\n    }\n\n    void handle_accept(const boost::system::error_code& ec, tcp::socket socket) {\n        if (!ec) {\n            // Handle TCP connection\n            std::make_shared<tcp::socket>(std::move(socket))->async_read_some(boost::asio::buffer(data_, 1024), \n                boost::bind(&server::handle_control_request, this, \n                    boost::asio::placeholders::error, \n                    boost::asio::placeholders::socket, \n                    boost::asio::placeholders::bytes_transferred));\n        }\n        start_accept();\n    }\n\n    void handle_control_request(const boost::system::error_code& ec, tcp::socket socket, size_t bytes_transferred) {\n        if (!ec && bytes_transferred > 0) {\n            // Process control request\n            std::string request(data_, bytes_transferred);\n            // Example: Check for subscription request\n            if (request == \"subscribe\") {\n                // Add subscriber endpoint (example logic)\n                subscribers_.insert(udp::endpoint(boost::asio::ip::address_v4::from_string(\"127.0.0.1\"), 5000));\n            } else if (request == \"unsubscribe\") {\n                // Remove subscriber endpoint (example logic)\n                subscribers_.erase(udp::endpoint(boost::asio::ip::address_v4::from_string(\"127.0.0.1\"), 5000));\n            }\n        }\n        handle_control_request_timer(socket, request, timer_);\n    }\n\n    void handle_control_request_timer(tcp::socket socket, std::string request, boost::asio::steady_timer& delay_timer) {\n        // Example delayed processing\n        delay_timer.expires_after(boost::chrono::seconds(1));\n        delay_timer.async_wait(boost::bind(&server::handle_control_request, this, \n            boost::asio::placeholders::error, \n            socket, \n            boost::asio::placeholders::bytes_transferred));\n    }\n\n    void start_timer() {\n        timer_.expires_after(boost::chrono::seconds(1));\n        timer_.async_wait(boost::bind(&server::handle_timer, this));\n    }\n\n    void handle_timer() {\n        // Broadcast data frame to all subscribers\n        std::string frame = \"Frame \" + std::to_string(next_frame_number_++);\n        for (auto& endpoint : subscribers_) {\n            udp_socket_.send_to(boost::asio::buffer(frame), endpoint);\n        }\n        timer_.async_wait(boost::bind(&server::handle_timer, this));\n    }\n\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::acceptor acceptor_;\n    boost::asio::steady_timer timer_;\n    boost::asio::ip::udp::socket udp_socket_;\n    unsigned long next_frame_number_;\n    std::set<boost::asio::ip::udp::endpoint> subscribers_;\n    char data_[1024];\n};"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Implement a class for handling HTTP file downloads using libcurl in C++. The class should support URL downloading with retries, temporary file handling, and proper resource management.\n\nClass Description: The DownloadTask class provides functionality to download files from HTTP URLs using libcurl. It handles initialization/cleanup of libcurl, manages download retries, writes data to temporary files, and performs final file operations upon successful download.\n\nAttributes:\n- m_url: [std::string] - Primary URL for file download\n- m_urlBackup: [std::string] - Backup URL if primary fails\n- m_output: [std::string] - Final output file path\n- m_outputTmp: [std::string] - Temporary file path during download\n- m_default: [std::string] - Default file path if download fails\n- m_mtime: [time_t] - Modification time to set on downloaded file\n- m_retries: [unsigned int] - Number of download attempts made\n- m_name: [std::string] - Name identifier for the download task\n- m_userAgent: [std::string] - User agent string for HTTP requests\n- m_error: [std::string] - Last error message encountered\n\nMethods:\n- initialize(): [static void]() -> void - Initializes libcurl global state\n- uninitialize(): [static void]() -> void - Cleans up libcurl global state\n- DownloadTask(): [constructor](const std::string&, const std::string&, const std::string&, time_t, const std::string&) -> DownloadTask - Constructs a download task with URL, output path, default file, modification time, and optional name\n- run(): [bool]() -> bool - Executes the download task and returns success status\n- getRetries(): [unsigned int]() -> unsigned int - Returns number of retry attempts\n- writeData(): [size_t](void*, size_t, size_t) -> size_t - Callback for writing received data\n- downloadFile(): [bool](const std::string&) -> bool - Internal method to perform the actual file download",
    "Canonical_solution": "#include <curl/curl.h>\n#include <vector>\n#include <string>\n#include <utility>\n\nclass DownloadTask\n{\npublic:\n    DownloadTask(const std::string &url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\");\n    \n    static void initialize();\n    static void uninitialize();\n    \n    bool run();\n    unsigned int getRetries() const;\n    size_t writeData(void *buffer, size_t size, size_t nmemb);\n    \nprivate:\n    bool downloadFile(const std::string& url);\n    \n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n};\n\nsize_t writeTaskHttpData(void *buffer, size_t size, size_t nmemb, void *user_p)\n{\n    DownloadTask *task = reinterpret_cast<DownloadTask *>(user_p);\n    if (NULL != task)\n    {\n        return task->writeData(buffer, size, nmemb);\n    }\n    \n    return 0;\n}\n\nvoid DownloadTask::initialize()\n{\n    curl_global_init(CURL_GLOBAL_ALL);\n}\n\nvoid DownloadTask::uninitialize()\n{\n    curl_global_cleanup();\n}\n\nbool DownloadTask::downloadFile(const std::string& url)\n{\n    ++m_retries;\n    \n    m_outputTmp = m_output + \".tmp\";\n    deleteFile(m_outputTmp);\n\n    CURLcode res = CURLE_OK;\n    CURL *curl = NULL;\n    \n    std::string userAgent = m_userAgent.empty() ? \"WeChat/7.0.15.33 CFNetwork/978.0.7 Darwin/18.6.0\" : m_userAgent;\n    \n    curl = curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_USERAGENT, userAgent.c_str());\n    curl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1L);\n    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 60);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &::writeTaskHttpData);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, this);\n    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, true);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0);\n\n    long httpStatus = 0;\n    res = curl_easy_perform(curl);\n    if (res != CURLE_OK)\n    {\n        m_error = \"Failed \" + m_name + \"\\r\\n\";\n        m_error += curl_easy_strerror(res);\n    }\n    else\n    {\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n    }\n    curl_easy_cleanup(curl);\n    \n    if (res == CURLE_OK && httpStatus == 200)\n    {\n        ::moveFile(m_outputTmp, m_output);\n        if (m_mtime > 0)\n        {\n            updateFileTime(m_output, m_mtime);\n        }\n        return true;\n    }\n\n    if (m_error.empty())\n    {\n        m_error = \"HTTP Status:\" + std::to_string(httpStatus);\n    }\n    return false;\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "#include <curl/curl.h>\n#include <string>\n#include <ctime>\n\nclass DownloadTask {\npublic:\n    std::string m_url;\n    std::string m_urlBackup;\n    std::string m_output;\n    std::string m_outputTmp;\n    std::string m_default;\n    time_t m_mtime;\n    unsigned int m_retries;\n    std::string m_name;\n    std::string m_userAgent;\n    std::string m_error;\n\n    static void initialize() {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n    }\n\n    static void uninitialize() {\n        curl_global_cleanup();\n    }\n\n    DownloadTask(const std::string& url, const std::string& output, const std::string& defaultFile, time_t mtime, const std::string& name = \"\") \n        : m_url(url), m_output(output), m_default(defaultFile), m_mtime(mtime), m_name(name) {\n        m_outputTmp = m_output + \".tmp\";\n        m_urlBackup = m_url;\n        m_retries = 0;\n        m_error.clear();\n        m_userAgent = \"DownloadTask/1.0\";\n    }\n\n    bool run() {\n        while (m_retries < 3) {\n            if (downloadFile(m_url)) {\n                return true;\n            }\n            m_retries++;\n            if (m_retries < 3) {\n                m_url = m_urlBackup;\n            }\n        }\n        return false;\n    }\n\n    unsigned int getRetries() {\n        return m_retries;\n    }\n\n    size_t writeData(void* contents, size_t size, size_t nmemb, void* userp) {\n        size_t realsize = size * nmemb;\n        std::string* ptr = static_cast<std::string*>(userp);\n        ptr->append(static_cast<char*>(contents), realsize);\n        return realsize;\n    }\n\n    bool downloadFile(const std::string& url) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            m_error = \"Failed to initialize CURL\";\n            return false;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &m_outputTmp);\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, m_userAgent.c_str());\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n        CURLcode res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            m_error = \"CURL error: \" + std::string(curl_easy_strerror(res));\n            curl_easy_cleanup(curl);\n            return false;\n        }\n\n        curl_easy_cleanup(curl);\n\n        if (rename(m_outputTmp.c_str(), m_output.c_str()) == 0) {\n            struct tm* tm_info = gmtime(&m_mtime);\n            if (tm_info) {\n                char buffer[80];\n                strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", tm_info);\n                if (chown(m_output.c_str(), -1, -1) == -1) {\n                    m_error = \"Failed to set modification time on file\";\n                    return false;\n                }\n                if (utimensat(AT_FDCWD, m_output.c_str(), &m_mtime, 0) == -1) {\n                    m_error = \"Failed to set modification time on file\";\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            m_error = \"Failed to rename temporary file to final output file\";\n            return false;\n        }\n    }\n};"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Implement a function that demonstrates inter-process communication between a parent and child process using pipes in C++. The function should create a pipe, fork a child process, and have the parent process write data to the pipe while the child process reads and displays the data.\n\nFunction Description: The function `pipe_communication` sets up a pipe for communication between a parent and child process. The parent process writes a string to the pipe, and the child process reads and prints the data. The function handles pipe creation, process forking, and proper cleanup of file descriptors.\n\nInput: None\n\nOutput: None (The function prints messages to stdout indicating the progress and results of the pipe communication:\n- \"pipe create error\" if pipe creation fails\n- \"Read data from the pipe is [data]\" from the child process\n- \"Write data [data]\" and \"Parent write over\" from the parent process\n- \"parent close fd[1] over\" when parent completes cleanup)",
    "Canonical_solution": "#include <unistd.h>\n#include <stdio.h>\n#include <cstring>\n#include <cstdlib>\n\nvoid pipe_communication() {\n    int pipe_fd[2];\n    pid_t pid;\n\n    char r_buf[4];\n    char w_buf[100];\n    memset(r_buf,0,sizeof(r_buf));\n    memset(w_buf,0,sizeof(w_buf));\n    int r_num;\n\n    if(pipe(pipe_fd)<0) {\n        printf(\"pipe create error\\n\");\n        return;\n    }\n\n    if((pid=fork())==0) {\n        printf(\"\\n\");\n        close(pipe_fd[1]);\n        sleep(5);\n        while((r_num=read(pipe_fd[0],r_buf,4))!=0)\n            printf(\"Read data from the pipe is %s\\n\", r_buf);\n\n        close(pipe_fd[0]);\n        exit(0);\n    }\n    else if(pid>0) {\n        close(pipe_fd[0]);\n        const char* content = \"1111222233334444\";\n        strncpy(w_buf, content, strlen(content));\n        if(write(pipe_fd[1],w_buf, strlen(content))!=-1) {\n            printf(\"Write data %s\\n\", w_buf);\n            printf(\"Parent write over\\n\");\n        }\n        close(pipe_fd[1]);\n        printf(\"parent close fd[1] over\\n\");\n        wait(&pid);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 155,
    "right_result": "#include <iostream>\n#include <unistd.h>\n#include <string>\n#include <cstring>\n#include <cerrno>\n\nvoid pipe_communication() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        std::cerr << \"pipe create error\" << std::endl;\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        std::cerr << \"fork failed\" << std::endl;\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return;\n    }\n\n    if (pid == 0) { // Child process\n        close(pipefd[1]); // Close write end\n        char buffer[1024];\n        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));\n        if (bytes_read > 0) {\n            std::cout << \"Read data from the pipe is \" << std::string(buffer, bytes_read) << std::endl;\n        }\n        close(pipefd[0]);\n    } else { // Parent process\n        close(pipefd[0]); // Close read end\n        const std::string data = \"Hello from parent!\";\n        std::cout << \"Write data \" << data << std::endl;\n        ssize_t bytes_written = write(pipefd[1], data.c_str(), data.size());\n        if (bytes_written != static_cast<ssize_t>(data.size())) {\n            std::cerr << \"Write failed\" << std::endl;\n        }\n        std::cout << \"Parent write over\" << std::endl;\n        close(pipefd[1]);\n        std::cout << \"parent close fd[1] over\" << std::endl;\n    }\n}"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Implement a multi-threaded HTTP download manager using libcurl in C++ that can handle multiple download tasks concurrently, avoid duplicate downloads, and manage resources efficiently.\n\nClass Description: The DownloadPool class manages a pool of worker threads that process download tasks. Each task downloads a file from a given URL and saves it to a specified output path. The class ensures thread safety and prevents duplicate downloads.\n\nAttributes:\n- m_threads: std::vector<std::thread> - Collection of worker threads\n- m_queue: std::queue<Task> - Queue of pending download tasks\n- m_urls: std::unordered_set<std::string> - Set of unique task identifiers to prevent duplicates\n- m_mtx: std::mutex - Mutex for thread synchronization\n- m_noMoreTask: bool - Flag indicating no more tasks will be added\n\nMethods:\n- DownloadPool() -> void - Constructor initializes libcurl and creates worker threads\n- ~DownloadPool() -> void - Destructor cleans up libcurl resources\n- addTask(const std::string& url, const std::string& output) -> void - Adds a new download task if not already present\n- setNoMoreTask() -> void - Signals that no more tasks will be added\n- finishAndWaitForExit() -> void - Waits for all threads to complete current tasks\n- run() -> void - Worker thread function that processes tasks from the queue\n\nTask Class Description: The Task class represents an individual download task with URL and output file path.\n\nAttributes:\n- m_url: std::string - URL to download from\n- m_output: std::string - Local file path to save to\n\nMethods:\n- run() -> void - Executes the download task using libcurl\n- writeData(void* buffer, size_t size, size_t nmemb) -> size_t - Callback function for writing received data to file",
    "Canonical_solution": "#include <curl/curl.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <queue>\n#include <unordered_set>\n\nclass Task\n{\npublic:\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n    \n    void run()\n    {\n        std::ofstream output(m_output, std::fstream::in | std::fstream::out | std::fstream::trunc);\n        output.close();\n        \n        CURL *curl_handler = curl_easy_init();\n        curl_easy_setopt(curl_handler, CURLOPT_URL, m_url.c_str());\n        curl_easy_setopt(curl_handler, CURLOPT_TIMEOUT, 60);\n        curl_easy_setopt(curl_handler, CURLOPT_WRITEFUNCTION, &Task::writeData);\n        curl_easy_setopt(curl_handler, CURLOPT_WRITEDATA, this);\n\n        curl_easy_perform(curl_handler);\n        \n        curl_easy_cleanup(curl_handler);\n    }\n\n    size_t writeData(void *buffer, size_t size, size_t nmemb)\n    {\n        std::ofstream file;\n        file.open(m_output, std::fstream::in | std::fstream::out | std::fstream::app | std::fstream::binary);\n        size_t bytesToWrite = size * nmemb;\n        file.write(reinterpret_cast<const char *>(buffer), bytesToWrite);\n        file.close();\n        \n        return bytesToWrite;\n    }\n\nprivate:\n    std::string m_url;\n    std::string m_output;\n};\n\nclass DownloadPool\n{\npublic:\n    DownloadPool()\n    {\n        m_noMoreTask = false;\n        curl_global_init(CURL_GLOBAL_ALL);\n        \n        for (int idx = 0; idx < 4; idx++)\n        {\n            m_threads.push_back(std::thread(&DownloadPool::run, this));\n        }\n    }\n\n    ~DownloadPool()\n    {\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string &url, const std::string& output)\n    {\n        std::string uid = url + output;\n        bool existed = false;\n        Task task(url, output);\n        m_mtx.lock();\n        if (!(existed = (m_urls.find(uid) != m_urls.cend())))\n        {\n            m_urls.insert(uid);\n            m_queue.push(task);\n        }\n        m_mtx.unlock();\n    }\n\n    void setNoMoreTask()\n    {\n        m_mtx.lock();\n        m_noMoreTask = true;\n        m_mtx.unlock();\n    }\n\n    void finishAndWaitForExit()\n    {\n        setNoMoreTask();\n        for (auto& thread : m_threads)\n        {\n            thread.join();\n        }\n    }\n\nprivate:\n    void run()\n    {\n        while(true)\n        {\n            bool found = false;\n            Task task;\n            \n            m_mtx.lock();\n            if (!m_queue.empty())\n            {\n                task = m_queue.front();\n                m_queue.pop();\n                found = true;\n            }\n            bool noMoreTask = m_noMoreTask;\n            m_mtx.unlock();\n            \n            if (found)\n            {\n                task.run();\n                continue;\n            }\n            if (noMoreTask)\n            {\n                break;\n            }\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    }\n\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    bool m_noMoreTask;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "right_result": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <mutex>\n#include <unordered_set>\n#include <thread>\n#include <curl/curl.h>\n\nclass Task {\npublic:\n    std::string m_url;\n    std::string m_output;\n\n    Task(const std::string& url, const std::string& output) : m_url(url), m_output(output) {}\n\n    void run() {\n        CURL* curl = curl_easy_init();\n        if (curl) {\n            std::ofstream file(m_output, std::ios::binary);\n            if (file.is_open()) {\n                curl_easy_setopt(curl, CURLOPT_URL, m_url.c_str());\n                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeData);\n                curl_easy_setopt(curl, CURLOPT_WRITEDATA, &file);\n                curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n                curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);\n\n                CURLcode res = curl_easy_perform(curl);\n                if (res != CURLE_OK) {\n                    std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n                }\n\n                file.close();\n            } else {\n                std::cerr << \"Failed to open output file: \" << m_output << std::endl;\n            }\n\n            curl_easy_cleanup(curl);\n        }\n    }\n\nprivate:\n    static size_t writeData(void* buffer, size_t size, size_t nmemb, std::ofstream* file) {\n        size_t realsize = size * nmemb;\n        file->write(static_cast<char*>(buffer), realsize);\n        return realsize;\n    }\n};\n\nclass DownloadPool {\npublic:\n    DownloadPool() {\n        m_threads.resize(4); // Default number of worker threads\n        for (auto& thread : m_threads) {\n            thread = std::thread(&DownloadPool::run, this);\n        }\n    }\n\n    ~DownloadPool() {\n        setNoMoreTask();\n        for (auto& thread : m_threads) {\n            if (thread.joinable()) {\n                thread.join();\n            }\n        }\n        curl_global_cleanup();\n    }\n\n    void addTask(const std::string& url, const std::string& output) {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        if (m_urls.find(url) == m_urls.end()) {\n            m_urls.insert(url);\n            m_queue.push(Task(url, output));\n        }\n    }\n\n    void setNoMoreTask() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        m_noMoreTask = true;\n    }\n\n    void finishAndWaitForExit() {\n        std::lock_guard<std::mutex> lock(m_mtx);\n        while (!m_queue.empty() || !m_noMoreTask) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n    }\n\n    void run() {\n        while (true) {\n            std::lock_guard<std::mutex> lock(m_mtx);\n            if (m_noMoreTask && m_queue.empty()) {\n                break;\n            }\n            if (!m_queue.empty()) {\n                Task task = m_queue.front();\n                m_queue.pop();\n                task.run();\n            }\n        }\n    }\n\nprivate:\n    std::vector<std::thread> m_threads;\n    std::queue<Task> m_queue;\n    std::unordered_set<std::string> m_urls;\n    std::mutex m_mtx;\n    bool m_noMoreTask = false;\n};"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a TCP client class using Boost.Asio that handles asynchronous communication with a chat server, including reading from standard input and writing to standard output.\n\nClass Description: The posix_chat_client class implements an asynchronous TCP client for a chat application. It manages socket connections, handles message reading/writing, and processes user input/output asynchronously using Boost.Asio.\n\nAttributes:\n- socket_: [tcp::socket] - The TCP socket for communication with the server\n- input_: [posix::stream_descriptor] - Handles asynchronous reading from standard input\n- output_: [posix::stream_descriptor] - Handles asynchronous writing to standard output\n- read_msg_: [chat_message] - Stores the message being read from the server\n- write_msg_: [chat_message] - Stores the message to be written to the server\n- input_buffer_: [boost::asio::streambuf] - Buffer for storing input data\n\nMethods:\n- Constructor: [posix_chat_client]([boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints]) -> [void] - Initializes the client with IO context and server endpoints\n- do_connect: [do_connect]([const tcp::resolver::results_type& endpoints]) -> [void] - Asynchronously connects to the server endpoints\n- do_read_header: [do_read_header]() -> [void] - Asynchronously reads the message header from the server\n- do_read_body: [do_read_body]() -> [void] - Asynchronously reads the message body from the server after header is processed\n- do_write_output: [do_write_output]() -> [void] - Asynchronously writes received messages to standard output\n- do_read_input: [do_read_input]() -> [void] - Asynchronously reads input from standard input\n- do_write_message: [do_write_message]() -> [void] - Asynchronously writes the composed message to the server\n- close: [close]() -> [void] - Closes all connections and cleans up resources",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\n#include \"chat_message.hpp\"\nusing boost::asio::ip::tcp;\nnamespace posix = boost::asio::posix;\n\nclass posix_chat_client\n{\npublic:\n  posix_chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : socket_(io_context),\n      input_(io_context, ::dup(STDIN_FILENO)),\n      output_(io_context, ::dup(STDOUT_FILENO)),\n      input_buffer_(chat_message::max_body_length)\n  {\n    do_connect(endpoints);\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n            do_read_input();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_write_output();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_output()\n  {\n    static char eol[] = { '\\n' };\n    std::array<boost::asio::const_buffer, 2> buffers = {{\n      boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n      boost::asio::buffer(eol) }};\n    boost::asio::async_write(output_, buffers,\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_read_input()\n  {\n    boost::asio::async_read_until(input_, input_buffer_, '\\n',\n        [this](boost::system::error_code ec, std::size_t length)\n        {\n          if (!ec)\n          {\n            write_msg_.body_length(length - 1);\n            input_buffer_.sgetn(write_msg_.body(), length - 1);\n            input_buffer_.consume(1);\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else if (ec == boost::asio::error::not_found)\n          {\n            write_msg_.body_length(input_buffer_.size());\n            input_buffer_.sgetn(write_msg_.body(), input_buffer_.size());\n            write_msg_.encode_header();\n            do_write_message();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void do_write_message()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msg_.data(), write_msg_.length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            do_read_input();\n          }\n          else\n          {\n            close();\n          }\n        });\n  }\n\n  void close()\n  {\n    socket_.close();\n    input_.close();\n    output_.close();\n  }\n\nprivate:\n  tcp::socket socket_;\n  posix::stream_descriptor input_;\n  posix::stream_descriptor output_;\n  chat_message read_msg_;\n  chat_message write_msg_;\n  boost::asio::streambuf input_buffer_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <boost/system/error_code.hpp>\n#include <boost/array.hpp>\n#include <iostream>\n\nnamespace boost {\nnamespace asio {\nnamespace ip {\nclass tcp;\n} // namespace ip\n} // namespace asio\n} // namespace boost\n\nclass chat_message {\npublic:\n    chat_message() : length_(0), payload_() {}\n    size_t length() const { return length_; }\n    std::string payload() const { return payload_; }\n    void length(size_t len) { length_ = len; }\n    void payload(const std::string& payload) { payload_ = payload; }\n\nprivate:\n    size_t length_;\n    std::string payload_;\n};\n\nclass posix_chat_client {\npublic:\n    posix_chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : io_context_(io_context),\n          socket_(io_context),\n          input_(io_context),\n          output_(io_context),\n          read_msg_(),\n          write_msg_(),\n          input_buffer_() {\n        input_.read_some(boost::asio::buffer(input_buffer_), boost::bind(&posix_chat_client::do_read_input, this,\n            boost::asio::placeholders::error));\n        output_.write_some(boost::asio::buffer(\"Connected\\n\"), boost::bind(&posix_chat_client::do_write_output, this,\n            boost::asio::placeholders::error));\n        do_connect(endpoints);\n    }\n\n    ~posix_chat_client() {\n        close();\n    }\n\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        socket_.async_connect(endpoints,\n            boost::bind(&posix_chat_client::handle_connect, this,\n                boost::asio::placeholders::error));\n    }\n\n    void handle_connect(const boost::system::error_code& error) {\n        if (!error) {\n            do_read_header();\n        } else {\n            std::cerr << \"Connection failed: \" << error.message() << std::endl;\n            close();\n        }\n    }\n\n    void do_read_header() {\n        boost::array<char, 4> header;\n        socket_.async_read_some(boost::asio::buffer(header),\n            boost::bind(&posix_chat_client::handle_read_header, this,\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_read_header(const boost::system::error_code& error, size_t bytes_transferred) {\n        if (!error && bytes_transferred == 4) {\n            read_msg_.length(static_cast<size_t>(*(reinterpret_cast<const uint32_t*>(header.data()))));\n            do_read_body();\n        } else {\n            std::cerr << \"Read header failed: \" << error.message() << std::endl;\n            close();\n        }\n    }\n\n    void do_read_body() {\n        socket_.async_read_some(boost::asio::buffer(read_msg_.payload_, read_msg_.length()),\n            boost::bind(&posix_chat_client::handle_read_body, this,\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_read_body(const boost::system::error_code& error, size_t bytes_transferred) {\n        if (!error && bytes_transferred == read_msg_.length()) {\n            do_write_output();\n        } else {\n            std::cerr << \"Read body failed: \" << error.message() << std::endl;\n            close();\n        }\n    }\n\n    void do_write_output() {\n        output_.write_some(boost::asio::buffer(read_msg_.payload_, read_msg_.length()),\n            boost::bind(&posix_chat_client::handle_write_output, this,\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_write_output(const boost::system::error_code& error, size_t bytes_transferred) {\n        if (!error && bytes_transferred == read_msg_.length()) {\n            do_read_input();\n        } else {\n            std::cerr << \"Write output failed: \" << error.message() << std::endl;\n            close();\n        }\n    }\n\n    void do_read_input() {\n        input_.read_some(boost::asio::buffer(input_buffer_),\n            boost::bind(&posix_chat_client::handle_read_input, this,\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_read_input(const boost::system::error_code& error, size_t bytes_transferred) {\n        if (!error && bytes_transferred > 0) {\n            write_msg_.payload(input_buffer_.data(), bytes_transferred);\n            do_write_message();\n        } else {\n            std::cerr << \"Read input failed: \" << error.message() << std::endl;\n            close();\n        }\n    }\n\n    void do_write_message() {\n        socket_.write_some(boost::asio::buffer(write_msg_.payload_, write_msg_.length()),\n            boost::bind(&posix_chat_client::handle_write_message, this,\n                boost::asio::placeholders::error,\n                boost::asio::placeholders::bytes_transferred));\n    }\n\n    void handle_write_message(const boost::system::error_code& error, size_t bytes_transferred) {\n        if (!error && bytes_transferred == write_msg_.length()) {\n            do_read_header();\n        } else {\n            std::cerr << \"Write message failed: \" << error.message() << std::endl;\n            close();\n        }\n    }\n\n    void close() {\n        if (socket_.is_open()) {\n            socket_.close();\n        }\n        if (input_.is_open()) {\n            input_.close();\n        }\n        if (output_.is_open()) {\n            output_.close();\n        }\n    }\n\nprivate:\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::posix::stream_descriptor input_;\n    boost::asio::posix::stream_descriptor output_;\n    chat_message read_msg_;\n    chat_message write_msg_;\n    boost::asio::streambuf input_buffer_;\n};"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "right_result": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/system/error_code.hpp>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace webos {\nnamespace client {\n\nclass WebOsClient::Impl {\npublic:\n    Impl(boost::asio::io_context& ioc, boost::beast::ssl::context& ctx, Device& device, std::shared_ptr<Logging> log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(device), log_(log), socket_status_(0) {}\n\n    void run() {\n        resolver_.async_resolve(host_, 80, onResolve);\n    }\n\n    void onResolve(const boost::system::error_code& ec, tcp::resolver::results_type endpoints) {\n        if (ec) {\n            onError(ec, \"Failed to resolve host\");\n            return;\n        }\n        resolver_.async_connect(endpoints, onConnect);\n    }\n\n    void onConnect(const boost::system::error_code& ec, tcp::resolver::results_type::endpoint_type endpoint) {\n        if (ec) {\n            onError(ec, \"Failed to connect to server\");\n            return;\n        }\n        if (device_settings_.use_ssl()) {\n            ws_.emplace(boost::beast::ssl_stream<boost::beast::tcp_stream>(ioc_, ctx_));\n            ws_->next_layer().connect(endpoint);\n            ws_->next_layer().handshake(boost::beast::ssl::stream_base::client);\n            ws_->lowest_layer().async_handshake(boost::beast::websocket::stream<boost::beast::ssl_stream<boost::beast::tcp_stream>>(*ws_), onSSLhandshake);\n        } else {\n            ws_tcp_.emplace(boost::beast::websocket::stream<boost::beast::tcp_stream>(ioc_));\n            ws_tcp_->next_layer().connect(endpoint);\n            ws_tcp_->lowest_layer().async_handshake(boost::beast::websocket::stream<boost::beast::tcp_stream>(*ws_tcp_), onWinsockHandshake);\n        }\n    }\n\n    void onSSLhandshake(const boost::system::error_code& ec) {\n        if (ec) {\n            onError(ec, \"SSL handshake failed\");\n            return;\n        }\n        ws_->async_handshake(*ws_, onWinsockHandshake);\n    }\n\n    void onWinsockHandshake(const boost::system::error_code& ec) {\n        if (ec) {\n            onError(ec, \"WebSocket handshake failed\");\n            return;\n        }\n        socket_status_ = 1;\n        read();\n    }\n\n    void send(const std::string& message, const std::string& type) {\n        if (device_settings_.use_ssl()) {\n            ws_->async_write(boost::beast::flat_buffer(), boost::beast::websocket::message_type::text, message, onWrite);\n        } else {\n            ws_tcp_->async_write(boost::beast::flat_buffer(), boost::beast::websocket::message_type::text, message, onWrite);\n        }\n    }\n\n    void onWrite(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n        if (ec) {\n            onError(ec, \"Write operation failed\");\n            return;\n        }\n        enqueueWork(Work{WorkType::Send, \"\"});\n    }\n\n    void read() {\n        buffer_.reset();\n        if (device_settings_.use_ssl()) {\n            ws_->async_read(buffer_, onRead);\n        } else {\n            ws_tcp_->async_read(buffer_, onRead);\n        }\n    }\n\n    void onRead(const boost::system::error_code& ec, std::size_t bytes_transferred) {\n        if (ec) {\n            onError(ec, \"Read operation failed\");\n            return;\n        }\n        if (bytes_transferred > 0) {\n            std::string data(buffer_.data(), bytes_transferred);\n            log_->log(\"Received: \" + data);\n            enqueueWork(Work{WorkType::Receive, data});\n        }\n        read();\n    }\n\n    void onError(const boost::system::error_code& ec, const std::string& message) {\n        log_->log(\"Error: \" + message);\n        if (ec) {\n            socket_status_ = 0;\n            close();\n        }\n    }\n\n    void enqueueWork(Work& work) {\n        // Implementation for enqueuing work\n    }\n\n    void close() {\n        if (device_settings_.use_ssl()) {\n            ws_.reset();\n        } else {\n            ws_tcp_.reset();\n        }\n        socket_status_ = 0;\n    }\n\nprivate:\n    boost::asio::io_context& ioc_;\n    boost::beast::ssl::context& ctx_;\n    Device& device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n};\n\n}  // namespace client\n}  // namespace webos"
  }
]