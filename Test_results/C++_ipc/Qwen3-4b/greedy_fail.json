[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "#include <httplib/httplib.h>\n#include <nlohmann/json.hpp>\n#include <sstream>\n\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data, json* response_data) {\n    std::string base_url = \"http://\" + location;\n    auto client = httplib::Client(base_url);\n\n    std::string data;\n    if (request_data != nullptr && (method == \"POST\" || method == \"PUT\")) {\n        std::ostringstream oss;\n        json::to_json(oss, *request_data);\n        data = oss.str();\n    }\n\n    auto res = client.request(method, URI, data);\n\n    long status = res.status;\n\n    if (status / 100 == 2) {\n        if (response_data != nullptr) {\n            *response_data = json::parse(res.body);\n        }\n    }\n\n    return status;\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <winsock2.h>\n#include <thread>\n#include <mutex>\n#include <vector>\n#include <string>\n\nclass NetworkClientInfo {\n    // Assume this class is defined elsewhere\n};\n\nclass NetworkServer {\npublic:\n    NetworkServer(std::vector<RGBController *>& control);\n    ~NetworkServer();\n\n    void StartServer();\n    void StopServer();\n\n    void ConnectionThreadFunction(int socket_idx);\n    int accept_select(int sockfd);\n\n    unsigned short GetPort();\n\n    void ClientInfoChanged();\n    void ServerListeningChanged();\n\n    void ListenThreadFunction(NetworkClientInfo * client_info);\n\nprivate:\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n    SOCKET listen_sock;\n};\n\nNetworkServer::NetworkServer(std::vector<RGBController *>& control) {\n    server_online = false;\n    server_listening = false;\n    socket_count = 0;\n    listen_sock = INVALID_SOCKET;\n}\n\nNetworkServer::~NetworkServer() {\n    StopServer();\n}\n\nvoid NetworkServer::StartServer() {\n    listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (listen_sock == INVALID_SOCKET) return;\n\n    sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(port_num);\n    inet_pton(AF_INET, host.c_str(), &addr.sin_addr);\n\n    if (bind(listen_sock, (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) return;\n    if (listen(listen_sock, MAXSOCK) == SOCKET_ERROR) return;\n\n    server_listening = true;\n    server_online = true;\n\n    std::thread listener_thread([](NetworkServer *server) {\n        while (server->server_listening) {\n            int client_socket = server->accept_select(server->listen_sock);\n            if (client_socket != -1) {\n                server->server_sock[server->socket_count] = client_socket;\n                server->ConnectionThread[server->socket_count] = new std::thread(&NetworkServer::ConnectionThreadFunction, server, server->socket_count);\n                server->socket_count++;\n            }\n        }\n    }, this);\n    listener_thread.detach();\n}\n\nvoid NetworkServer::StopServer() {\n    server_listening = false;\n    server_online = false;\n\n    for (int i = 0; i < socket_count; ++i) {\n        if (server_sock[i] != INVALID_SOCKET) closesocket(server_sock[i]);\n    }\n\n    for (int i = 0; i < socket_count; ++i) {\n        if (ConnectionThread[i]) {\n            ConnectionThread[i]->join();\n            delete ConnectionThread[i];\n        }\n    }\n\n    if (listen_sock != INVALID_SOCKET) closesocket(listen_sock);\n}\n\nint NetworkServer::accept_select(int sockfd) {\n    fd_set read_fds;\n    FD_ZERO(&read_fds);\n    FD_SET(sockfd, &read_fds);\n\n    struct timeval timeout = {1, 0};\n    int result = select(sockfd + 1, &read_fds, NULL, NULL, &timeout);\n    if (result == SOCKET_ERROR) return -1;\n    if (result == 0) return -1;\n\n    if (FD_ISSET(sockfd, &read_fds)) {\n        sockaddr_in client_addr;\n        socklen_t addr_len = sizeof(client_addr);\n        SOCKET client_socket = accept(sockfd, (sockaddr*)&client_addr, &addr_len);\n        if (client_socket == INVALID_SOCKET) return -1;\n        return client_socket;\n    }\n    return -1;\n}\n\nunsigned short NetworkServer::GetPort() {\n    return port_num;\n}\n\nvoid NetworkServer::ClientInfoChanged() {}\n\nvoid NetworkServer::ServerListeningChanged() {}\n\nvoid NetworkServer::ListenThreadFunction(NetworkClientInfo * client_info) {}\n\nvoid NetworkServer::ConnectionThreadFunction(int socket_idx) {\n    SOCKET client_socket = server_sock[socket_idx];\n    if (client_socket == INVALID_SOCKET) return;\n\n    char buffer[1024];\n    while (true) {\n        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n        if (bytes_received > 0) {\n            send(client_socket, buffer, bytes_received, 0);\n        } else if (bytes_received == 0) break;\n        else break;\n    }\n\n    closesocket(client_socket);\n}"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Implement a UDP client function using Boost.Asio that sends a request to a UDP server and receives a response.\n\nFunction Description: The function establishes a UDP connection to a specified host, sends a minimal request packet, waits for a response, and prints the received data to standard output. It uses Boost.Asio for asynchronous UDP operations.\n\nInput: \n- host: std::string - The hostname or IP address of the UDP server to connect to\n\nOutput: \n- None (void function), but prints the received data to standard output\n\nNote: The function uses a fixed service name \"daytime\" (port 13) for demonstration purposes. In a real application, this would typically be configurable. The function handles both IPv4 and UDP protocol operations.",
    "Canonical_solution": "#include <array>\n#include <boost/asio.hpp>\nusing boost::asio::ip::udp;\n\nvoid udp_client(const std::string& host)\n{\n    boost::asio::io_context io_context;\n\n    udp::resolver resolver(io_context);\n    udp::endpoint receiver_endpoint =\n      *resolver.resolve(udp::v4(), host, \"daytime\").begin();\n\n    udp::socket socket(io_context);\n    socket.open(udp::v4());\n\n    std::array<char, 1> send_buf  = {{ 0 }};\n    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);\n\n    std::array<char, 128> recv_buf;\n    udp::endpoint sender_endpoint;\n    size_t len = socket.receive_from(\n        boost::asio::buffer(recv_buf), sender_endpoint);\n\n    std::cout.write(recv_buf.data(), len);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "#include <boost/asio.hpp>\n#include <iostream>\n#include <string>\n#include <array>\n\nvoid send_udp_request(const std::string& host) {\n    boost::asio::io_service io_service;\n\n    // Resolve the host and port 13 (daytime service)\n    boost::asio::ip::tcp::resolver resolver(io_service);\n    boost::asio::ip::tcp::endpoint endpoint = resolver.resolve(host, \"daytime\");\n\n    // Create UDP socket\n    boost::asio::ip::udp::socket socket(io_service, boost::asio::ip::udp::socket::lowest_protocol());\n\n    // Bind to a local endpoint (any available port)\n    boost::asio::ip::udp::endpoint local_endpoint(boost::asio::ip::udp::v4(), 0);\n    socket.bind(local_endpoint);\n\n    // Prepare the request message\n    std::string request = \"HELLO\";\n    std::array<char, 1024> buffer;\n    std::copy(request.begin(), request.end(), buffer.begin(), buffer.begin() + request.size());\n\n    // Asynchronous send\n    socket.async_send_to(boost::asio::buffer(buffer), endpoint,\n        [&](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n            if (!ec) {\n                // Now receive the response\n                socket.async_receive_from(boost::asio::buffer(buffer), endpoint,\n                    [&](const boost::system::error_code& ec, std::size_t bytes_received) {\n                        if (!ec) {\n                            std::cout << \"Received: \" << std::string(buffer.begin(), buffer.begin() + bytes_received) << std::endl;\n                        } else {\n                            std::cerr << \"Receive error: \" << ec.message() << std::endl;\n                        }\n                        io_service.stop();\n                    });\n            } else {\n                std::cerr << \"Send error: \" << ec.message() << std::endl;\n                io_service.stop();\n            }\n        });\n\n    // Run the io_service to process asynchronous operations\n    io_service.run();\n}"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication\n- m_connections: [con_list (std::set<connection_hdl>)] - A set of active client connections\n\nMethods:\n- broadcast_server() - [Constructor] -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events\n- on_open(connection_hdl hdl) -> [void] - Handles new client connections by adding them to the connection set\n- on_close(connection_hdl hdl) -> [void] - Handles client disconnections by removing them from the connection set\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handles incoming messages by broadcasting them to all connected clients\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <boost/bind.hpp>\n#include <set>\n#include <string>\n\nnamespace websocketpp {\nnamespace server {\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server = std::make_shared<server>();\n        m_server->set_open_handler(boost::bind(&broadcast_server::on_open, this, _1));\n        m_server->set_close_handler(boost::bind(&broadcast_server::on_close, this, _1));\n        m_server->set_message_handler(boost::bind(&broadcast_server::on_message, this, _1, _2));\n    }\n\n    void run(uint16_t port) {\n        m_server->run(port);\n    }\n\nprivate:\n    std::shared_ptr<server> m_server;\n    std::set<connection_hdl> m_connections;\n\n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        std::string payload = msg->get_payload();\n        for (auto& conn_hdl : m_connections) {\n            m_server->send(conn_hdl, payload, frame::text);\n        }\n    }\n};\n}  // namespace server\n}  // namespace websocketpp"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections, process incoming messages, and support configurable threading for concurrent operations.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server implementation, providing methods to initialize, configure, and run the server with customizable port and threading settings.\n\nAttributes:\n- testee_server_: [server] - The WebSocket++ server instance that manages connections and message handling\n- port_: [short] - The port number on which the server listens for incoming connections\n- num_threads_: [size_t] - The number of threads to use for handling connections (1 for single-threaded mode)\n\nMethods:\n- WebSocketServer([short port = 9002], [size_t num_threads = 1]) -> [void] - Constructor that initializes the server with specified port and thread count (defaults to port 9002 and single-threaded)\n- run() -> [void] - Starts the WebSocket server, sets up message handlers, begins listening on the specified port, and manages the server's event loop(s)\n- on_message([websocketpp::connection_hdl hdl], [message_ptr msg]) -> [void] - Message handler that echoes received messages back to the client (private method)\n- on_socket_init([websocketpp::connection_hdl hdl], [boost::asio::ip::tcp::socket & s]) -> [void] - Socket initialization handler that enables TCP_NODELAY for reduced latency (private method)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/extensions/permessage_deflate/enabled.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <websocketpp/common/thread.hpp>\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::server<websocketpp::config::asio> server;\ntypedef server::message_ptr message_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) \n        : port_(port), num_threads_(num_threads) {}\n\n    void run() {\n        try {\n            testee_server_.clear_access_channels(websocketpp::log::alevel::all);\n            testee_server_.clear_error_channels(websocketpp::log::alevel::all);\n\n            testee_server_.init_asio();\n            testee_server_.set_reuse_addr(true);\n\n            testee_server_.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n            testee_server_.set_socket_init_handler(bind(&WebSocketServer::on_socket_init, this, ::_1, ::_2));\n\n            testee_server_.set_listen_backlog(8192);\n            testee_server_.listen(port_);\n            testee_server_.start_accept();\n\n            if (num_threads_ == 1) {\n                testee_server_.run();\n            } else {\n                std::vector<websocketpp::lib::shared_ptr<websocketpp::lib::thread>> ts;\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts.push_back(websocketpp::lib::make_shared<websocketpp::lib::thread>(&server::run, &testee_server_));\n                }\n\n                for (size_t i = 0; i < num_threads_; i++) {\n                    ts[i]->join();\n                }\n            }\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"exception: \" << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        testee_server_.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket & s) {\n        boost::asio::ip::tcp::no_delay option(true);\n        s.set_option(option);\n    }\n\n    server testee_server_;\n    short port_;\n    size_t num_threads_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <memory>\n\nnamespace websocketpp {\n    template class server;\n}\n\nclass WebSocketServer {\npublic:\n    WebSocketServer(short port = 9002, size_t num_threads = 1) : port_(port), num_threads_(num_threads) {\n        testee_server_ = std::make_shared<websocketpp::server<websocketpp::lib::asio::io_service>>();\n        testee_server_->get_endpoint().set_port(port_);\n        testee_server_->get_endpoint().set_thread_pool_size(num_threads_);\n        testee_server_->set_on_message([this](const websocketpp::connection_hdl& hdl, const websocketpp::message::message_ptr& msg) {\n            this->on_message(hdl, msg);\n        });\n        testee_server_->set_on_socket_init([this](const websocketpp::connection_hdl& hdl, boost::asio::ip::tcp::socket& s) {\n            this->on_socket_init(hdl, s);\n        });\n    }\n\n    void run() {\n        testee_server_->start_listening();\n        testee_server_->get_io_service().run();\n    }\n\nprivate:\n    std::shared_ptr<websocketpp::server<websocketpp::lib::asio::io_service>> testee_server_;\n    short port_;\n    size_t num_threads_;\n\n    void on_message(const websocketpp::connection_hdl& hdl, const websocketpp::message::message_ptr& msg) {\n        testee_server_->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_socket_init(const websocketpp::connection_hdl& hdl, boost::asio::ip::tcp::socket& s) {\n        s.set_option(boost::asio::ip::tcp::socket::tcp_nodelay(true));\n    }\n};"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage sessions, and process incoming messages.\n\nClass Description: The `print_server` class implements a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: int - Tracks the next available session ID to assign to new connections.\n- m_server: server - The WebSocket++ server instance configured with custom connection data.\n\nMethods:\n- print_server() - Constructor - Initializes the server with ASIO, sets up handlers for connection open, close, and message events.\n- on_open(connection_hdl hdl) -> void - Handler for new connections. Assigns a session ID to the new connection.\n- on_close(connection_hdl hdl) -> void - Handler for connection closures. Logs the connection's name and session ID.\n- on_message(connection_hdl hdl, server::message_ptr msg) -> void - Handler for incoming messages. Sets the connection name if not set, otherwise logs the message along with the connection's name and session ID.\n- run(uint16_t port) -> void - Starts the server listening on the specified port, begins accepting connections, and runs the event loop.",
    "Canonical_solution": "#include <iostream>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nstruct custom_config : public websocketpp::config::asio {\n    typedef websocketpp::config::asio core;\n    typedef core::concurrency_type concurrency_type;\n    typedef core::request_type request_type;\n    typedef core::response_type response_type;\n    typedef core::message_type message_type;\n    typedef core::con_msg_manager_type con_msg_manager_type;\n    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;\n    typedef core::alog_type alog_type;\n    typedef core::elog_type elog_type;\n    typedef core::rng_type rng_type;\n    typedef core::transport_type transport_type;\n    typedef core::endpoint_base endpoint_base;\n    typedef connection_data connection_base;\n};\n\ntypedef websocketpp::server<custom_config> server;\ntypedef server::connection_ptr connection_ptr;\n\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->sessionid = m_next_sessionid++;\n    }\n    \n    void on_close(connection_hdl hdl) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Closing connection \" << con->name \n                  << \" with sessionid \" << con->sessionid << std::endl;\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_ptr con = m_server.get_con_from_hdl(hdl);\n        \n        if (con->name.empty()) {\n            con->name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \" \n                      << con->sessionid << \" to \" << con->name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << con->name \n                      << \" with sessionid \" << con->sessionid << std::endl;\n        }\n    }\n    \n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    int m_next_sessionid;\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <asio.hpp>\n#include <boost/bind.hpp>\n#include <iostream>\n#include <string>\n#include <memory>\n\nnamespace websocketpp {\n    typedef server<asio::asio_impl> server_type;\n}\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(0) {\n        m_server = websocketpp::server_type();\n        m_server.init_asio();\n        m_server.set_message_handler(boost::bind(&print_server::on_message, this, _1, _2));\n        m_server.set_open_handler(boost::bind(&print_server::on_open, this, _1));\n        m_server.set_close_handler(boost::bind(&print_server::on_close, this, _1));\n    }\n\n    void run(uint16_t port) {\n        m_server.set_port(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    int m_next_sessionid;\n    websocketpp::server_type m_server;\n\n    void on_open(websocketpp::connection_hdl hdl) {\n        auto data = std::make_shared<connection_data>();\n        data->session_id = m_next_sessionid++;\n        m_server.get_concrete(hdl).set_data(data);\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        auto data = m_server.get_concrete(hdl).get_data<connection_data>();\n        std::cout << \"Connection closed. Session ID: \" << data->session_id << \", Name: \" << (data->name.empty() ? \"N/A\" : data->name) << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::server::message_ptr msg) {\n        auto data = m_server.get_concrete(hdl).get_data<connection_data>();\n        if (data->name.empty()) {\n            data->name = msg->get_payload();\n        } else {\n            std::cout << \"Message from \" << data->name << \" (session \" << data->session_id << \"): \" << msg->get_payload() << std::endl;\n        }\n    }\n\n    struct connection_data {\n        int session_id;\n        std::string name;\n    };\n};"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library to handle client connections, manage session data, and process incoming messages.\n\nClass Description: The `print_server` class encapsulates a WebSocket server that tracks client connections with session IDs and names, and logs connection events and messages.\n\nAttributes:\n- m_next_sessionid: [int] - Tracks the next available session ID to assign to new connections.\n- m_server: [websocketpp::server<websocketpp::config::asio>] - The WebSocket++ server instance.\n- m_connections: [std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>>] - Maps connection handles to their associated session data.\n\nMethods:\n- print_server(): [Constructor]() -> [void] - Initializes the server and sets up handlers for connection events.\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handles new WebSocket connections by assigning a session ID and storing connection data.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handles connection closures by logging the event and removing the connection from tracking.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Processes incoming messages, either setting the client's name or logging received messages.\n- get_data_from_hdl: [connection_data&]([connection_hdl hdl]) -> [connection_data&] - Retrieves connection data for a given handle, throwing an exception if not found.\n- run: [void]([uint16_t port]) -> [void] - Starts the server listening on the specified port and begins accepting connections.",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <map>\n#include <exception>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nstruct connection_data {\n    int sessionid;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server() : m_next_sessionid(1) {\n        m_server.init_asio();\n\n        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));\n    }\n\n    void on_open(connection_hdl hdl) {\n        connection_data data;\n\n        data.sessionid = m_next_sessionid++;\n        data.name.clear();\n\n        m_connections[hdl] = data;\n    }\n\n    void on_close(connection_hdl hdl) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        std::cout << \"Closing connection \" << data.name\n                  << \" with sessionid \" << data.sessionid << std::endl;\n\n        m_connections.erase(hdl);\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        connection_data& data = get_data_from_hdl(hdl);\n\n        if (data.name.empty()) {\n            data.name = msg->get_payload();\n            std::cout << \"Setting name of connection with sessionid \"\n                      << data.sessionid << \" to \" << data.name << std::endl;\n        } else {\n            std::cout << \"Got a message from connection \" << data.name\n                      << \" with sessionid \" << data.sessionid << std::endl;\n        }\n    }\n\n    connection_data& get_data_from_hdl(connection_hdl hdl) {\n        auto it = m_connections.find(hdl);\n\n        if (it == m_connections.end()) {\n            throw std::invalid_argument(\"No data available for session\");\n        }\n\n        return it->second;\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\nprivate:\n    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;\n\n    int m_next_sessionid;\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <map>\n#include <string>\n#include <iostream>\n#include <stdexcept>\n\nnamespace websocketpp {\n    namespace server {\n        class server<config::asio>;\n    }\n}\n\nstruct connection_data {\n    int session_id;\n    std::string name;\n};\n\nclass print_server {\npublic:\n    print_server();\n    void on_open(websocketpp::connection_hdl hdl);\n    void on_close(websocketpp::connection_hdl hdl);\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::server::message_ptr msg);\n    connection_data& get_data_from_hdl(websocketpp::connection_hdl hdl);\n    void run(uint16_t port);\n\nprivate:\n    int m_next_sessionid;\n    websocketpp::server<websocketpp::config::asio> m_server;\n    std::map<websocketpp::connection_hdl, connection_data, std::owner_less<websocketpp::connection_hdl>> m_connections;\n};\n\nprint_server::print_server() : m_next_sessionid(1) {\n    m_server.init();\n    m_server.set_mask(false);\n    m_server.set_on_open([this](websocketpp::connection_hdl hdl) { this->on_open(hdl); });\n    m_server.set_on_close([this](websocketpp::connection_hdl hdl) { this->on_close(hdl); });\n    m_server.set_on_message([this](websocketpp::connection_hdl hdl, websocketpp::server::message_ptr msg) { this->on_message(hdl, msg); });\n}\n\nvoid print_server::on_open(websocketpp::connection_hdl hdl) {\n    connection_data data;\n    data.session_id = m_next_sessionid++;\n    data.name = \"\";\n    m_connections[hdl] = data;\n    std::cout << \"New connection, session ID: \" << data.session_id << std::endl;\n}\n\nvoid print_server::on_close(websocketpp::connection_hdl hdl) {\n    try {\n        connection_data& data = get_data_from_hdl(hdl);\n        std::cout << \"Connection closed, session ID: \" << data.session_id << \", name: \" << data.name << std::endl;\n    } catch (const std::out_of_range& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}\n\nvoid print_server::on_message(websocketpp::connection_hdl hdl, websocketpp::server::message_ptr msg) {\n    if (msg->get_type() == websocketpp::server::message_type::text) {\n        try {\n            connection_data& data = get_data_from_hdl(hdl);\n            if (data.name.empty()) {\n                data.name = msg->get_payload();\n                std::cout << \"Client named \" << data.name << \" connected.\" << std::endl;\n            } else {\n                std::cout << \"Message from \" << data.name << \": \" << msg->get_payload() << std::endl;\n            }\n        } catch (const std::out_of_range& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n        }\n    }\n}\n\nconnection_data& print_server::get_data_from_hdl(websocketpp::connection_hdl hdl) {\n    auto it = m_connections.find(hdl);\n    if (it == m_connections.end()) {\n        throw std::out_of_range(\"Connection handle not found\");\n    }\n    return it->second;\n}\n\nvoid print_server::run(uint16_t port) {\n    m_server.listen(port);\n    m_server.start_accept();\n    m_server.run();\n}"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that can handle multiple client connections and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and broadcasts incoming messages to all connected clients.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that handles network communication.\n- m_connections: [con_list] - A set of active connection handles to keep track of connected clients.\n\nMethods:\n- broadcast_server(): [Constructor]() -> [void] - Initializes the WebSocket++ server and sets up handlers for connection events (open, close, message).\n- on_open: [void]([connection_hdl hdl]) -> [void] - Handler for new client connections; adds the connection handle to the active connections set.\n- on_close: [void]([connection_hdl hdl]) -> [void] - Handler for client disconnections; removes the connection handle from the active connections set.\n- on_message: [void]([connection_hdl hdl, server::message_ptr msg]) -> [void] - Handler for incoming messages; broadcasts the received message to all connected clients.\n- run: [void]([uint16_t port]) -> [void] - Starts the server, begins listening on the specified port, and enters the event loop to handle connections and messages.",
    "Canonical_solution": "#include <set>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n                \n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n    \n    void on_open(connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n    \n    void on_close(connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n    \n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        for (auto it : m_connections) {\n            m_server.send(it,msg);\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;\n\n    server m_server;\n    con_list m_connections;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocket++/library.hpp>\n#include <websocket++/server.hpp>\n#include <set>\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.set_on_open(std::bind(&broadcast_server::on_open, this, std::placeholders::_1));\n        m_server.set_on_close(std::bind(&broadcast_server::on_close, this, std::placeholders::_1));\n        m_server.set_on_message(std::bind(&broadcast_server::on_message, this, std::placeholders::_1, std::placeholders::_2));\n    }\n\n    void on_open(websocket::connection_hdl hdl) {\n        m_connections.insert(hdl);\n    }\n\n    void on_close(websocket::connection_hdl hdl) {\n        m_connections.erase(hdl);\n    }\n\n    void on_message(websocket::connection_hdl hdl, websocket::server::message_ptr msg) {\n        for (auto& conn_hdl : m_connections) {\n            m_server.get_connection(conn_hdl)->send(msg->get_payload());\n        }\n    }\n\n    void run(uint16_t port) {\n        m_server.set_port(port);\n        m_server.run();\n    }\n\nprivate:\n    websocket::server m_server;\n    std::set<websocket::connection_hdl> m_connections;\n};"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ using the WebSocket++ library to handle client connections, process incoming messages, and manage server events.\n\nClass Description: The WebSocketServer class encapsulates a WebSocket++ server instance, providing methods to initialize, configure, and run the server. It handles WebSocket connections, processes messages, and manages various server events like HTTP requests, connection failures, and closures.\n\nAttributes:\n- m_server: [websocketpp::server<websocketpp::config::debug_asio>] - The main WebSocket++ server instance that manages connections and events.\n\nMethods:\n- WebSocketServer() -> [Constructor] - Initializes the server with default settings, configures logging, sets up ASIO, and registers event handlers.\n- run(int port) -> [void] - Starts the server on the specified port, begins accepting connections, and runs the event loop.\n- validate(websocketpp::connection_hdl hdl) -> [bool] - Validates incoming connections (always returns true in this implementation).\n- on_http(websocketpp::connection_hdl hdl) -> [void] - Handles HTTP requests received by the server.\n- on_fail(websocketpp::connection_hdl hdl) -> [void] - Handles connection failure events.\n- on_close(websocketpp::connection_hdl hdl) -> [void] - Handles connection closure events.\n- on_message(websocketpp::connection_hdl hdl, message_ptr msg) -> [void] - Processes incoming WebSocket messages and echoes them back to the client.",
    "Canonical_solution": "#include <websocketpp/config/debug_asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/logger/syslog.hpp>\n#include <iostream>\n\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\n\nclass WebSocketServer {\npublic:\n    typedef websocketpp::server<websocketpp::config::debug_asio> server;\n    typedef server::message_ptr message_ptr;\n\n    WebSocketServer() {\n        // Set logging settings\n        m_server.set_access_channels(websocketpp::log::alevel::all);\n        m_server.clear_access_channels(websocketpp::log::alevel::frame_payload);\n\n        // Initialize ASIO\n        m_server.init_asio();\n        m_server.set_reuse_addr(true);\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_fail_handler(bind(&WebSocketServer::on_fail, this, ::_1));\n        m_server.set_close_handler(bind(&WebSocketServer::on_close, this, ::_1));\n        m_server.set_validate_handler(bind(&WebSocketServer::validate, this, ::_1));\n    }\n\n    void run(int port) {\n        try {\n            // Listen on specified port\n            m_server.listen(port);\n\n            // Start the server accept loop\n            m_server.start_accept();\n\n            // Start the ASIO io_service run loop\n            m_server.run();\n        } catch (websocketpp::exception const & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\nprivate:\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::string res = con->get_request_body();\n        std::stringstream ss;\n        ss << \"got HTTP request with \" << res.size() << \" bytes of body data.\";\n        con->set_body(ss.str());\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        std::cout << \"Fail handler: \" << con->get_ec() << \" \" << con->get_ec().message() << std::endl;\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Close handler\" << std::endl;\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \" \n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <iostream>\n#include <boost/bind.hpp>\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server() {\n        m_server.set_log_level(websocketpp::log::level::debug);\n        m_server.set_log_handler([](const websocketpp::log::message& msg) {\n            std::cout << msg;\n        });\n\n        m_server.set_on_message(boost::bind(&WebSocketServer::on_message, this, _1, _2));\n        m_server.set_on_http(boost::bind(&WebSocketServer::on_http, this, _1));\n        m_server.set_on_fail(boost::bind(&WebSocketServer::on_fail, this, _1));\n        m_server.set_on_close(boost::bind(&WebSocketServer::on_close, this, _1));\n        m_server.set_validate_connection(boost::bind(&WebSocketServer::validate, this, _1));\n    }\n\n    void run(int port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    bool validate(websocketpp::connection_hdl hdl) {\n        return true;\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        std::cout << \"HTTP request received.\\n\";\n    }\n\n    void on_fail(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection failed.\\n\";\n    }\n\n    void on_close(websocketpp::connection_hdl hdl) {\n        std::cout << \"Connection closed.\\n\";\n    }\n\n    void on_message(websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n        std::cout << \"Received: \" << msg->get_payload() << \"\\n\";\n        m_server.send(hdl, msg->get_payload(), websocketpp::frame::opcode::binary);\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::debug_asio> m_server;\n};"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Implement a WebSocket server in C++ using the WebSocket++ library that supports secure TLS connections and handles both WebSocket and HTTP requests.\n\nClass Description: The WebSocketServer class encapsulates a secure WebSocket server implementation using WebSocket++ with ASIO and TLS support. It handles incoming connections, processes messages, and manages secure communication settings.\n\nAttributes:\n- m_server: [server] - The WebSocket++ server instance that manages connections and communication\n- tls_mode: [enum] - Enumeration defining TLS security modes (MOZILLA_INTERMEDIATE, MOZILLA_MODERN)\n\nMethods:\n- WebSocketServer() -> [constructor] - Initializes the server, sets up ASIO, and registers handler functions\n- run([int port]) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_message([websocketpp::connection_hdl hdl, message_ptr msg]) -> [void] - Handles incoming WebSocket messages by echoing them back to the client\n- on_http([websocketpp::connection_hdl hdl]) -> [void] - Handles HTTP requests by returning a simple \"Hello World!\" response\n- get_password() -> [std::string] - Returns the password used for TLS certificate encryption\n- on_tls_init([tls_mode mode, websocketpp::connection_hdl hdl]) -> [context_ptr] - Initializes and configures TLS/SSL context with appropriate security settings based on the specified mode",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/lib/asio.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio_tls> server;\ntypedef websocketpp::config::asio::message_type::ptr message_ptr;\ntypedef websocketpp::lib::shared_ptr<websocketpp::lib::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() {\n        // Initialize ASIO\n        m_server.init_asio();\n\n        // Register handlers\n        m_server.set_message_handler(bind(&WebSocketServer::on_message, this, ::_1, ::_2));\n        m_server.set_http_handler(bind(&WebSocketServer::on_http, this, ::_1));\n        m_server.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, MOZILLA_INTERMEDIATE, ::_1));\n    }\n\n    void run(int port) {\n        // Listen on specified port\n        m_server.listen(port);\n\n        // Start the server accept loop\n        m_server.start_accept();\n\n        // Start the ASIO io_service run loop\n        m_server.run();\n    }\n\nprivate:\n    enum tls_mode {\n        MOZILLA_INTERMEDIATE = 1,\n        MOZILLA_MODERN = 2\n    };\n\n    void on_message(websocketpp::connection_hdl hdl, message_ptr msg) {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                  << \" and message: \" << msg->get_payload()\n                  << std::endl;\n\n        try {\n            m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                      << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    void on_http(websocketpp::connection_hdl hdl) {\n        server::connection_ptr con = m_server.get_con_from_hdl(hdl);\n        con->set_body(\"Hello World!\");\n        con->set_status(websocketpp::http::status_code::ok);\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(tls_mode mode, websocketpp::connection_hdl hdl) {\n        namespace asio = websocketpp::lib::asio;\n\n        context_ptr ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);\n\n        try {\n            if (mode == MOZILLA_MODERN) {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::no_tlsv1 |\n                                 asio::ssl::context::single_dh_use);\n            } else {\n                ctx->set_options(asio::ssl::context::default_workarounds |\n                                 asio::ssl::context::no_sslv2 |\n                                 asio::ssl::context::no_sslv3 |\n                                 asio::ssl::context::single_dh_use);\n            }\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", asio::ssl::context::pem);\n            ctx->use_tmp_dh_file(\"dh.pem\");\n            \n            std::string ciphers = (mode == MOZILLA_MODERN) ? \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\" : \n                \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256...\";\n            \n            if (SSL_CTX_set_cipher_list(ctx->native_handle(), ciphers.c_str()) != 1) {\n                std::cout << \"Error setting cipher list\" << std::endl;\n            }\n        } catch (std::exception& e) {\n            std::cout << \"Exception: \" << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    server m_server;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/extensions/echo.hpp>\n#include <openssl/ssl.h>\n#include <string>\n\nnamespace websocketpp {\n    enum class tls_mode { MOZILLA_INTERMEDIATE, MOZILLA_MODERN };\n}\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : m_server(), tls_mode_(websocketpp::tls_mode::MOZILLA_INTERMEDIATE) {\n        m_server.set_mask(true);\n        m_server.set_origin_check(false);\n        m_server.set_max_message_size(1024 * 1024);\n        m_server.set_message_handler([this](connection_hdl hdl, message_ptr msg) {\n            on_message(hdl, msg);\n        });\n        m_server.set_http_handler([this](connection_hdl hdl) {\n            on_http(hdl);\n        });\n    }\n\n    void run(int port) {\n        m_server.init_asio();\n        m_server.listen(port);\n        m_server.start_accept();\n        m_server.run();\n    }\n\n    void on_message(connection_hdl hdl, message_ptr msg) {\n        m_server.send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    void on_http(connection_hdl hdl) {\n        m_server.send(hdl, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello World!\", 0);\n    }\n\n    std::string get_password() {\n        return \"securepassword\";\n    }\n\n    websocketpp::context_ptr on_tls_init(websocketpp::tls_mode mode, connection_hdl hdl) {\n        tls_mode_ = mode;\n        SSL_CTX* ctx = SSL_CTX_new(TLS_method());\n        if (!ctx) {\n            throw std::runtime_error(\"Failed to create SSL context\");\n        }\n\n        switch (mode) {\n            case websocketpp::tls_mode::MOZILLA_INTERMEDIATE:\n                SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1);\n                break;\n            case websocketpp::tls_mode::MOZILLA_MODERN:\n                SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2);\n                break;\n        }\n\n        const char* cert_file = \"server.pem\";\n        const char* key_file = \"server.key\";\n        const char* password = get_password().c_str();\n\n        if (SSL_CTX_use_certificate_file(ctx, cert_file, SSL_FILETYPE_PEM) <= 0) {\n            throw std::runtime_error(\"Failed to load certificate\");\n        }\n\n        if (SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0) {\n            throw std::runtime_error(\"Failed to load private key\");\n        }\n\n        if (SSL_CTX_set_default_passwd_cb(ctx, (SSLPasswordCallback)std::bind(&WebSocketServer::get_password, this)) <= 0) {\n            throw std::runtime_error(\"Failed to set password callback\");\n        }\n\n        return websocketpp::context_ptr(new websocketpp::context(ctx));\n    }\n\nprivate:\n    websocketpp::server<websocketpp::config::asio_no_tls> m_server;\n    websocketpp::tls_mode tls_mode_;\n};"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Implement a WebSocket broadcast server in C++ using the WebSocket++ library that can handle multiple client connections, manage subscriptions, and broadcast messages to all connected clients.\n\nClass Description: The `broadcast_server` class implements a WebSocket server that maintains a set of active connections and can broadcast messages to all connected clients. It handles connection events (open/close) and message events using a thread-safe action queue system.\n\nAttributes:\n- m_server: [server] - WebSocket++ server instance configured with ASIO\n- m_connections: [con_list] - Set of active WebSocket connection handles\n- m_actions: [std::queue<action>] - Queue of pending actions to process\n- m_action_lock: [mutex] - Mutex for protecting access to the action queue\n- m_connection_lock: [mutex] - Mutex for protecting access to the connections set\n- m_action_cond: [condition_variable] - Condition variable for action queue notification\n\nMethods:\n- broadcast_server() -> [constructor] - Initializes the WebSocket server and sets up event handlers\n- run(uint16_t port) -> [void] - Starts the server listening on the specified port and begins accepting connections\n- on_open(connection_hdl hdl) -> [void] - Handler for new WebSocket connections (adds SUBSCRIBE action)\n- on_close(connection_hdl hdl) -> [void] - Handler for closed WebSocket connections (adds UNSUBSCRIBE action)\n- on_message(connection_hdl hdl, server::message_ptr msg) -> [void] - Handler for incoming messages (adds MESSAGE action)\n- process_messages() -> [void] - Processes actions from the queue (manages subscriptions and broadcasts messages)",
    "Canonical_solution": "#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <websocketpp/common/thread.hpp>\n#include <iostream>\n#include <set>\n\ntypedef websocketpp::server<websocketpp::config::asio> server;\nusing websocketpp::connection_hdl;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\nusing websocketpp::lib::thread;\nusing websocketpp::lib::mutex;\nusing websocketpp::lib::lock_guard;\nusing websocketpp::lib::unique_lock;\nusing websocketpp::lib::condition_variable;\n\nenum action_type {\n    SUBSCRIBE,\n    UNSUBSCRIBE,\n    MESSAGE\n};\n\nstruct action {\n    action(action_type t, connection_hdl h) : type(t), hdl(h) {}\n    action(action_type t, connection_hdl h, server::message_ptr m)\n      : type(t), hdl(h), msg(m) {}\n\n    action_type type;\n    websocketpp::connection_hdl hdl;\n    server::message_ptr msg;\n};\n\nclass broadcast_server {\npublic:\n    broadcast_server() {\n        m_server.init_asio();\n        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));\n        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));\n        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));\n    }\n\n    void run(uint16_t port) {\n        m_server.listen(port);\n        m_server.start_accept();\n        try {\n            m_server.run();\n        } catch (const std::exception & e) {\n            std::cout << e.what() << std::endl;\n        }\n    }\n\n    void on_open(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(SUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_close(connection_hdl hdl) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(UNSUBSCRIBE,hdl));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void on_message(connection_hdl hdl, server::message_ptr msg) {\n        {\n            lock_guard<mutex> guard(m_action_lock);\n            m_actions.push(action(MESSAGE,hdl,msg));\n        }\n        m_action_cond.notify_one();\n    }\n\n    void process_messages() {\n        while(1) {\n            unique_lock<mutex> lock(m_action_lock);\n            while(m_actions.empty()) {\n                m_action_cond.wait(lock);\n            }\n\n            action a = m_actions.front();\n            m_actions.pop();\n            lock.unlock();\n\n            if (a.type == SUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.insert(a.hdl);\n            } else if (a.type == UNSUBSCRIBE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                m_connections.erase(a.hdl);\n            } else if (a.type == MESSAGE) {\n                lock_guard<mutex> guard(m_connection_lock);\n                con_list::iterator it;\n                for (it = m_connections.begin(); it != m_connections.end(); ++it) {\n                    m_server.send(*it,a.msg);\n                }\n            }\n        }\n    }\n\nprivate:\n    typedef std::set<connection_hdl,std::owner_less<connection_hdl> > con_list;\n    server m_server;\n    con_list m_connections;\n    std::queue<action> m_actions;\n    mutex m_action_lock;\n    mutex m_connection_lock;\n    condition_variable m_action_cond;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n#include <set>\n#include <string>\n#include <thread>\n\nnamespace websocketpp {\nnamespace server {\nclass broadcast_server : public server<config::asio> {\npublic:\n    broadcast_server() {\n        this->set_message_handler([this](connection_hdl hdl, server::message_ptr msg) {\n            action act;\n            act.t = action::MESSAGE;\n            act.data = msg->get_payload();\n            std::lock_guard<std::mutex> lock(m_action_lock);\n            m_actions.push(act);\n            m_action_cond.notify_one();\n        });\n        this->set_open_handler([this](connection_hdl hdl) {\n            action act;\n            act.t = action::SUBSCRIBE;\n            act.data = hdl;\n            std::lock_guard<std::mutex> lock(m_action_lock);\n            m_actions.push(act);\n            m_action_cond.notify_one();\n        });\n        this->set_close_handler([this](connection_hdl hdl) {\n            action act;\n            act.t = action::UNSUBSCRIBE;\n            act.data = hdl;\n            std::lock_guard<std::mutex> lock(m_action_lock);\n            m_actions.push(act);\n            m_action_cond.notify_one();\n        });\n    }\n\n    void run(uint16_t port) {\n        this->init_asio();\n        this->start_accept();\n        this->run();\n        std::thread t(&broadcast_server::process_messages, this);\n        t.detach();\n    }\n\nprivate:\n    struct action {\n        enum type { SUBSCRIBE, UNSUBSCRIBE, MESSAGE };\n        type t;\n        std::variant<connection_hdl, std::string> data;\n    };\n\n    std::set<connection_hdl> m_connections;\n    std::queue<action> m_actions;\n    std::mutex m_action_lock;\n    std::condition_variable m_action_cond;\n    std::mutex m_connection_lock;\n\n    void process_messages() {\n        while (true) {\n            std::unique_lock<std::mutex> lock(m_action_lock);\n            while (m_actions.empty()) {\n                m_action_cond.wait(lock);\n            }\n            action act = m_actions.front();\n            m_actions.pop();\n\n            lock.unlock();\n\n            switch (act.t) {\n                case action::SUBSCRIBE:\n                    {\n                        std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                        m_connections.insert(std::move(act.data.as<connection_hdl>()));\n                    }\n                    break;\n                case action::UNSUBSCRIBE:\n                    {\n                        std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                        m_connections.erase(std::move(act.data.as<connection_hdl>()));\n                    }\n                    break;\n                case action::MESSAGE:\n                    {\n                        std::lock_guard<std::mutex> conn_lock(m_connection_lock);\n                        for (auto& conn : m_connections) {\n                            conn->send(act.data.as<std::string>());\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n};\n}\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Implement a C++ class that provides HTTP request functionality using libcurl, supporting both file and network resource retrieval.\n\nClass Description: HttpWebRequest is a class that encapsulates HTTP request functionality, allowing users to make GET requests to either network resources (via HTTP) or local files (via file:// protocol). It handles request configuration, execution, and response processing.\n\nAttributes:\n- uri_: std::string - The target URI for the HTTP request\n- method_: std::string - The HTTP method to use (defaults to GET)\n- header_: std::map<std::string, std::string> - HTTP headers to include in the request\n- is_: std::iostream - Internal stream used for request processing\n\nMethods:\n- HttpWebRequest(std::string &uri) -> void - Constructor that initializes the request with a target URI\n- callback(void *buffer, size_t size, size_t nmemb, void *data) -> static size_t - Static callback function for libcurl to write response data\n- GetFileResponse(const char *uri) -> HttpWebResponse* - Handles file:// protocol requests and returns the file content as a response\n- GetNetResponse(const char *uri) -> HttpWebResponse* - Performs HTTP network requests using libcurl and returns the response\n- GetResponse() -> HttpWebResponse* - Main method that determines request type (file or network) and returns the appropriate response",
    "Canonical_solution": "#include <curl/curl.h>\n#include <string>\n#include <map>\n#include <sstream>\n#include <fstream>\n\nnamespace System {\nnamespace Net {\n\nclass HttpWebRequest {\npublic:\n    HttpWebRequest(std::string &uri)\n        : is_(std::ios_base::in | std::ios_base::out | std::ios_base::binary) {\n        uri_ = uri;\n        method_ = HttpWebRequest::Method::GET;\n    }\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        HttpWebResponse *resp = (HttpWebResponse *) data;\n        std::stringstream &ss = resp->GetResponseStream();\n        ss.write((char *) buffer, size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse *GetFileResponse(const char *uri) {\n        assert(strlen(uri) > 6);\n        HttpWebResponse *resp = new HttpWebResponse();\n        const char *filename = uri + 6;\n\n        std::ifstream file;\n        file.open(filename);\n        if (file.is_open()) {\n            resp->os_ << file.rdbuf();\n            file.close();\n        }\n\n        return resp;\n    }\n\n    HttpWebResponse *GetNetResponse(const char *uri) {\n        HttpWebResponse *resp = new HttpWebResponse();\n\n        CURL *curl = curl_easy_init();\n\n        curl_easy_setopt(curl, CURLOPT_URL, uri);\n\n        curl_slist *http_headers = NULL;\n        for (std::map<std::string, std::string>::iterator it = header_.begin();\n             it != header_.end(); it++) {\n            http_headers = curl_slist_append(http_headers,\n                                             (it->first + \":\" + it->second).c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, http_headers);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) resp);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 2);\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 2);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\n        curl_easy_perform(curl);\n\n        long retcode = 0;\n        CURLcode code = curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &retcode);\n        if (code == CURLE_OK && retcode == 200) {\n            resp->status_.SetCode(200);\n\n            char *ctype = NULL;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &ctype);\n            std::string type(ctype);\n            resp->header_.Put(HttpHeader::ContentType, type);\n\n            double length = 0;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &length);\n            std::ostringstream os;\n            os << (long) length;\n            resp->header_.Put(HttpHeader::ContentLength, os.str());\n        }\n\n        curl_slist_free_all(http_headers);\n        curl_easy_cleanup(curl);\n\n        return resp;\n    }\n\n    HttpWebResponse *GetResponse() {\n        const char *uri = uri_.c_str();\n        if (strncmp(uri, \"file://\", 7) == 0) {\n            return GetFileResponse(uri);\n        }\n        return GetNetResponse(uri);\n    }\n\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n};\n\n}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 146,
    "wrong_result": "#include <iostream>\n#include <map>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <curl/curl.h>\n\nclass HttpWebResponse {\npublic:\n    HttpWebResponse(std::iostream& stream) : stream_(stream) {}\n    std::iostream& stream() { return stream_; }\nprivate:\n    std::iostream stream_;\n};\n\nclass HttpWebRequest {\npublic:\n    HttpWebRequest(std::string &uri) : uri_(uri), method_(\"GET\") {\n        curl_global_init(CURL_GLOBAL_DEFAULT);\n        curl_ = curl_easy_init();\n    }\n\n    ~HttpWebRequest() {\n        if (curl_) {\n            curl_easy_cleanup(curl_);\n            curl_global_cleanup();\n        }\n    }\n\n    static size_t callback(void *buffer, size_t size, size_t nmemb, void *data) {\n        HttpWebRequest* req = static_cast<HttpWebRequest*>(data);\n        req->is_.write(static_cast<char*>(buffer), size * nmemb);\n        return size * nmemb;\n    }\n\n    HttpWebResponse* GetFileResponse(const char *uri) {\n        std::string uri_str(uri);\n        if (uri_str.find(\"file://\") == 0) {\n            std::string path = uri_str.substr(8);\n            std::ifstream file(path, std::ios::binary);\n            if (!file.is_open()) {\n                return nullptr;\n            }\n            file >> std::noskipws;\n            std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n            is_ << content;\n            return new HttpWebResponse(is_);\n        }\n        return nullptr;\n    }\n\n    HttpWebResponse* GetNetResponse(const char *uri) {\n        if (!curl_) {\n            return nullptr;\n        }\n        curl_easy_setopt(curl_, CURLOPT_URL, uri);\n        curl_easy_setopt(curl_, CURLOPT_WRITEFUNCTION, &HttpWebRequest::callback);\n        curl_easy_setopt(curl_, CURLOPT_WRITEDATA, this);\n        curl_easy_setopt(curl_, CURLOPT_HTTPGET, 1);\n        curl_easy_setopt(curl_, CURLOPT_FOLLOWLOCATION, 1L);\n        for (const auto& [key, value] : header_) {\n            curl_easy_setopt(curl_, CURLOPT_HTTPHEADER, curl_slist_append(nullptr, (key + \": \" + value).c_str()));\n        }\n        CURLcode res = curl_easy_perform(curl_);\n        if (res != CURLE_OK) {\n            return nullptr;\n        }\n        return new HttpWebResponse(is_);\n    }\n\n    HttpWebResponse* GetResponse() {\n        if (uri_.find(\"file://\") == 0) {\n            return GetFileResponse(uri_.c_str());\n        } else {\n            return GetNetResponse(uri_.c_str());\n        }\n    }\n\nprivate:\n    std::string uri_;\n    std::string method_;\n    std::map<std::string, std::string> header_;\n    std::iostream is_;\n    CURL* curl_;\n};"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a WebSocket server class in C++ that supports both plain and TLS (SSL) connections using the WebSocket++ library. The server should handle incoming messages, echo them back to clients, and manage secure connections with proper TLS initialization.\n\nClass Description: The WebSocketServer class encapsulates functionality for creating and managing both plain and TLS WebSocket servers. It initializes server endpoints, sets up message handlers, manages TLS contexts, and runs the server's event loop.\n\nAttributes:\n- ios_: boost::asio::io_service - ASIO I/O service for handling network operations\n- endpoint_plain_: server_plain - WebSocket++ server instance for plain (non-secure) connections\n- endpoint_tls_: server_tls - WebSocket++ server instance for TLS (secure) connections\n\nMethods:\n- init() -> void - Initializes both plain and TLS server endpoints, sets message handlers, TLS initialization handler, and starts listening on ports 80 (plain) and 443 (TLS)\n- run() -> void - Starts the server's event loop to handle connections and messages\n- on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) -> void - Template method that handles incoming messages from clients and echoes them back\n- get_password() -> std::string - Returns the password used for TLS private key encryption\n- on_tls_init(websocketpp::connection_hdl hdl) -> context_ptr - Initializes and configures the TLS context for secure connections",
    "Canonical_solution": "#include <websocketpp/config/asio.hpp>\n#include <websocketpp/server.hpp>\n#include <boost/asio/ssl.hpp>\n#include <iostream>\n\ntypedef websocketpp::server<websocketpp::config::asio> server_plain;\ntypedef websocketpp::server<websocketpp::config::asio_tls> server_tls;\nusing websocketpp::lib::placeholders::_1;\nusing websocketpp::lib::placeholders::_2;\nusing websocketpp::lib::bind;\ntypedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : ios_(), endpoint_plain_(), endpoint_tls_() {}\n\n    void init() {\n        endpoint_plain_.init_asio(&ios_);\n        endpoint_plain_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_plain>, this, &endpoint_plain_, ::_1, ::_2));\n        endpoint_plain_.listen(80);\n        endpoint_plain_.start_accept();\n\n        endpoint_tls_.init_asio(&ios_);\n        endpoint_tls_.set_message_handler(\n            bind(&WebSocketServer::on_message<server_tls>, this, &endpoint_tls_, ::_1, ::_2));\n        endpoint_tls_.set_tls_init_handler(bind(&WebSocketServer::on_tls_init, this, ::_1));\n        endpoint_tls_.listen(443);\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\nprivate:\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl,\n        typename EndpointType::message_ptr msg)\n    {\n        std::cout << \"on_message called with hdl: \" << hdl.lock().get()\n                << \" and message: \" << msg->get_payload()\n                << std::endl;\n\n        try {\n            s->send(hdl, msg->get_payload(), msg->get_opcode());\n        } catch (websocketpp::exception const & e) {\n            std::cout << \"Echo failed because: \"\n                    << \"(\" << e.what() << \")\" << std::endl;\n        }\n    }\n\n    std::string get_password() {\n        return \"test\";\n    }\n\n    context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        std::cout << \"on_tls_init called with hdl: \" << hdl.lock().get() << std::endl;\n        context_ptr ctx(new boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));\n\n        try {\n            ctx->set_options(boost::asio::ssl::context::default_workarounds |\n                            boost::asio::ssl::context::no_sslv2 |\n                            boost::asio::ssl::context::no_sslv3 |\n                            boost::asio::ssl::context::single_dh_use);\n            ctx->set_password_callback(bind(&WebSocketServer::get_password, this));\n            ctx->use_certificate_chain_file(\"server.pem\");\n            ctx->use_private_key_file(\"server.pem\", boost::asio::ssl::context::pem);\n        } catch (std::exception& e) {\n            std::cout << e.what() << std::endl;\n        }\n        return ctx;\n    }\n\n    boost::asio::io_service ios_;\n    server_plain endpoint_plain_;\n    server_tls endpoint_tls_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 154,
    "wrong_result": "#include <websocketpp/server.hpp>\n#include <boost/asio/io_service.hpp>\n#include <openssl/ssl.h>\n#include <string>\n\nnamespace websocketpp {\n    class server_plain;\n    class server_tls;\n}\n\nclass WebSocketServer {\npublic:\n    WebSocketServer() : password_(\"your_password\") {}\n\n    void init() {\n        // Initialize plain server\n        endpoint_plain_.set_mask(true);\n        endpoint_plain_.set_port(80);\n        endpoint_plain_.set_message_handler([](websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n            on_message(&endpoint_plain_, hdl, msg);\n        });\n        endpoint_plain_.start_accept();\n\n        // Initialize TLS server\n        endpoint_tls_.set_mask(true);\n        endpoint_tls_.set_port(443);\n        endpoint_tls_.set_message_handler([](websocketpp::connection_hdl hdl, websocketpp::message_ptr msg) {\n            on_message(&endpoint_tls_, hdl, msg);\n        });\n        endpoint_tls_.set_tls_init_handler([this](websocketpp::connection_hdl hdl) {\n            return on_tls_init(hdl);\n        });\n        endpoint_tls_.start_accept();\n    }\n\n    void run() {\n        ios_.run();\n    }\n\n    template <typename EndpointType>\n    void on_message(EndpointType* s, websocketpp::connection_hdl hdl, typename EndpointType::message_ptr msg) {\n        s->send(hdl, msg->get_payload(), msg->get_opcode());\n    }\n\n    std::string get_password() {\n        return password_;\n    }\n\n    websocketpp::ssl::context_ptr on_tls_init(websocketpp::connection_hdl hdl) {\n        auto ctx = std::make_shared<websocketpp::ssl::context>(websocketpp::ssl::protocol::tls_v1_2);\n        ctx->set_password(password_.c_str());\n        ctx->set_cipher_list(\"HIGH:!aNULL:!MD5\");\n        return ctx;\n    }\n\nprivate:\n    boost::asio::io_service ios_;\n    websocketpp::server_plain endpoint_plain_;\n    websocketpp::server_tls endpoint_tls_;\n    std::string password_;\n};"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "#include <boost/asio/io_context.hpp>\n#include <boost/asio/ip/tcp.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/ssl.hpp>\n#include <memory>\n#include <string>\n\nnamespace WebOsClient {\n    class Impl {\n    public:\n        net::io_context& ioc_;\n        ssl::context& ctx_;\n        Device device_settings_;\n        std::shared_ptr<Logging> log_;\n        tcp::resolver resolver_;\n        std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>> ws_;\n        std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n        beast::flat_buffer buffer_;\n        std::string host_;\n        int socket_status_;\n\n        Impl(net::io_context& ioc, ssl::context& ctx, Device& dev, Logging& log)\n            : ioc_(ioc), ctx_(ctx), device_settings_(dev), log_(std::make_shared<Logging>(log)), resolver_(ioc_), host_(\"\"), socket_status_(0) {}\n\n        void run() {\n            resolver_.async_resolve(device_settings_.host, device_settings_.port, onResolve);\n        }\n\n        void onResolve(beast::error_code ec, tcp::resolver::results_type endpoints) {\n            if (ec) {\n                onError(ec, \"Resolution failed\");\n                return;\n            }\n            ws_.reset();\n            ws_tcp_.reset();\n            socket_status_ = 1;\n            ioc_.post([this, endpoints]() {\n                if (device_settings_.use_ssl) {\n                    auto stream = beast::ssl_stream<beast::tcp_stream>(ioc_);\n                    stream.next_layer().set_verify_mode(ssl::verify_none);\n                    stream.next_layer().set_alpn_protocols({\"websocket\"});\n                    stream.next_layer().set_options(ssl::stream_base::allow_unordered);\n                    stream.socket().connect(endpoints);\n                    stream.next_layer().handshake(ssl::client);\n                    stream.next_layer().async_handshake(ssl::client, onSSLHandshake);\n                } else {\n                    auto stream = beast::tcp_stream(ioc_);\n                    stream.socket().connect(endpoints);\n                    stream.async_handshake(beast::websocket::client, onWinsockHandshake);\n                }\n            });\n        }\n\n        void onSSLHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"SSL handshake failed\");\n                return;\n            }\n            async_handshake(beast::websocket::client, onWinsockHandshake);\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"WebSocket handshake failed\");\n                return;\n            }\n            async_read(buffer_, ws_->next_layer(), onRead);\n        }\n\n        void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n            if (ec) {\n                onError(ec, \"Write failed\");\n                return;\n            }\n            if (bytes_transferred > 0) {\n                send(\"\", \"\");\n            }\n        }\n\n        void read() {\n            async_read(buffer_, ws_->next_layer(), onRead);\n        }\n\n        void onRead(beast::error_code ec, std::size_t bytes_transmitted) {\n            if (ec) {\n                onError(ec, \"Read failed\");\n                return;\n            }\n            if (bytes_transmitted > 0) {\n                log_->log(\"Received: \" + std::string(buffer_.data(), buffer_.size());\n                buffer_.clear();\n            }\n        }\n\n        void onError(beast::error_code ec, const std::string& msg) {\n            log_->log(\"Error: \" + msg);\n            if (ec) {\n                close();\n            }\n        }\n\n        void enqueueWork(Work& work) {\n            // Implementation placeholder\n        }\n\n        void close() {\n            if (ws_) {\n                ws_->close(beast::websocket::close::normal, \"Closing\");\n            }\n            if (ws_tcp_) {\n                ws_tcp_->close(beast::websocket::close::normal, \"Closing\");\n            }\n            socket_status_ = 0;\n        }\n\n        void send(const std::string& data, const std::string& type) {\n            if (socket_status_ != 2) {\n                return;\n            }\n            if (type == \"text\") {\n                ws_->write(buffer_, beast::websocket::message<beast::websocket::text>();\n            } else if (type == \"binary\") {\n                ws_->write(buffer_, beast::websocket::message<beast::websocket::binary>());\n            }\n            buffer_.clear();\n            ioc_.post([this, data]() {\n                ws_->text(data);\n                onWrite(beast::error_code(), data.size());\n            });\n        }\n\n        void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type endpoint) {\n            if (ec) {\n                onError(ec, \"Connection failed\");\n                return;\n            }\n            if (device_settings_.use_ssl) {\n                auto stream = beast::ssl_stream<beast::tcp_stream>(ioc_);\n                stream.next_layer().set_verify_mode(ssl::verify_none);\n                stream.next_layer().set_alpn_protocols({\"websocket\"});\n                stream.next_layer().set_options(ssl::stream_base::allow_unordered);\n                stream.socket().connect(endpoint);\n                stream.next_layer().handshake(ssl::client, onSSLHandshake);\n            } else {\n                auto stream = beast::tcp_stream(ioc_);\n                stream.socket().connect(endpoint);\n                stream.async_handshake(beast::websocket::client, onWinsockHandshake);\n            }\n        }\n\n        void onSSLhandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"SSL handshake failed\");\n                return;\n            }\n            async_handshake(beast::websocket::client, onWinsockHandshake);\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"WebSocket handshake failed\");\n                return;\n            }\n            async_read(buffer_, ws_->next_layer(), onRead);\n        }\n\n        void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n            if (ec) {\n                onError(ec, \"Write failed\");\n                return;\n            }\n            if (bytes_transferred > 0) {\n                send(\"\", \"\");\n            }\n        }\n\n        void read() {\n            async_read(buffer_, ws_->next_layer(), onRead);\n        }\n\n        void onRead(beast::error_code ec, std::size_t bytes_transmitted) {\n            if (ec) {\n                onError(ec, \"Read failed\");\n                return;\n            }\n            if (bytes_transmitted > 0) {\n                log_->log(\"Received: \" + std::string(buffer_.data(), buffer_.size());\n                buffer_.clear();\n            }\n        }\n\n        void onError(beast::error_code ec, const std::string& msg) {\n            log_->log(\"Error: \" + msg);\n            if (ec) {\n                close();\n            }\n        }\n\n        void enqueueWork(Work& work) {\n            // Implementation placeholder\n        }\n\n        void close() {\n            if (ws_) {\n                ws_->close(beast::websocket::close::normal, \"Closing\");\n            }\n            if (ws_tcp_) {\n                ws_tcp_->close(beast::websocket::close::normal, \"Closing\");\n            }\n            socket_status_ = 0;\n        }\n\n        void onResolve(beast::error_code ec, tcp::resolver::results_type endpoints) {\n            if (ec) {\n                onError(ec, \"Resolution failed\");\n                return;\n            }\n            ws_.reset();\n            ws_tcp_.reset();\n            socket_status_ = 1;\n            ioc_.post([this, endpoints]() {\n                if (device_settings_.use_ssl) {\n                    auto stream = beast::ssl_stream<beast::tcp_stream>(ioc_);\n                    stream.next_layer().set_verify_mode(ssl::verify_none);\n                    stream.next_layer().set_alpn_protocols({\"websocket\"});\n                    stream.next_layer().set_options(ssl::stream_base::allow_unordered);\n                    stream.socket().connect(endpoints);\n                    stream.next_layer().handshake(ssl::client, onSSLHandshake);\n                } else {\n                    auto stream = beast::tcp_stream(ioc_);\n                    stream.socket().connect(endpoints);\n                    stream.async_handshake(beast::websocket::client, onWinsockHandshake);\n                }\n            });\n        }\n\n        void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type endpoint) {\n            if (ec) {\n                onError(ec, \"Connection failed\");\n                return;\n            }\n            if (device_settings_.use_ssl) {\n                auto stream = beast::ssl_stream<beast::tcp_stream>(ioc_);\n                stream.next_layer().set_verify_mode(ssl::verify_none);\n                stream.next_layer().set_alpn_protocols({\"websocket\"});\n                stream.next_layer().set_options(ssl::stream_base::allow_unordered);\n                stream.socket().connect(endpoint);\n                stream.next_layer().handshake(ssl::client, onSSLHandshake);\n            } else {\n                auto stream = beast::tcp_stream(ioc_);\n                stream.socket().connect(endpoint);\n                stream.async_handshake(beast::websocket::client, onWinsockHandshake);\n            }\n        }\n\n        void onSSLhandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"SSL handshake failed\");\n                return;\n            }\n            async_handshake(beast::websocket::client, onWinsockHandshake);\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"WebSocket handshake failed\");\n                return;\n            }\n            async_read(buffer_, ws_->next_layer(), onRead);\n        }\n\n        void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n            if (ec) {\n                onError(ec, \"Write failed\");\n                return;\n            }\n            if (bytes_transferred > 0) {\n                send(\"\", \"\");\n            }\n        }\n\n        void read() {\n            async_read(buffer_, ws_->next_layer(), onRead);\n        }\n\n        void onRead(beast::error_code ec, std::size_t bytes_transmitted) {\n            if (ec) {\n                onError(ec, \"Read failed\");\n                return;\n            }\n            if (bytes_transmitted > 0) {\n                log_->log(\"Received: \" + std::string(buffer_.data(), buffer_.size());\n                buffer_.clear();\n            }\n        }\n\n        void onError(beast::error_code ec, const std::string& msg) {\n            log_->log(\"Error: \" + msg);\n            if (ec) {\n                close();\n            }\n        }\n\n        void enqueueWork(Work& work) {\n            // Implementation placeholder\n        }\n\n        void close() {\n            if (ws_) {\n                ws_->close(beast::websocket::close::normal, \"Closing\");\n            }\n            if (ws_tcp_) {\n                ws_tcp_->close(beast::websocket::close::normal, \"Closing\");\n            }\n            socket_status_ = 0;\n        }\n\n        void run() {\n            resolver_.async_resolve(device_settings_.host, device_settings_.port, onResolve);\n        }\n\n        void onResolve(beast::error_code ec, tcp::resolver::results_type endpoints) {\n            if (ec) {\n                onError(ec, \"Resolution failed\");\n                return;\n            }\n            ws_.reset();\n            ws_tcp_.reset();\n            socket_status_ = 1;\n            ioc_.post([this, endpoints]() {\n                if (device_settings_.use_ssl) {\n                    auto stream = beast::ssl_stream<beast::tcp_stream>(ioc_);\n                    stream.next_layer().set_verify_mode(ssl::verify_none);\n                    stream.next_layer().set_alpn_protocols({\"websocket\"});\n                    stream.next_layer().set_options(ssl::stream_base::allow_unordered);\n                    stream.socket().connect(endpoints);\n                    stream.next_layer().handshake(ssl::client, onSSLHandshake);\n                } else {\n                    auto stream = beast::tcp_stream(ioc_);\n                    stream.socket().connect(endpoints);\n                    stream.async_handshake(beast::websocket::client, onWinsockHandshake);\n                }\n            });\n        }\n\n        void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type endpoint) {\n            if (ec) {\n                onError(ec, \"Connection failed\");\n                return;\n            }\n            if (device_settings_.use_ssl) {\n                auto stream = beast::ssl_stream<beast::tcp_stream>(ioc_);\n                stream.next_layer().set_verify_mode(ssl::verify_none);\n                stream.next_layer().set_alpn_protocols({\"websocket\"});\n                stream.next_layer().set_options(ssl::stream_base::allow_unordered);\n                stream.socket().connect(endpoint);\n                stream.next_layer().handshake(ssl::client, onSSLHandshake);\n            } else {\n                auto stream = beast::tcp_stream(ioc_);\n                stream.socket().connect(endpoint);\n                stream.async_handshake(beast::websocket::client, onWinsockHandshake);\n            }\n        }\n\n        void onSSLhandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"SSL handshake failed\");\n                return;\n            }\n            async_handshake(beast::websocket::client, onWinsockHandshake);\n        }\n\n        void onWinsockHandshake(beast::error_code ec) {\n            if (ec) {\n                onError(ec, \"WebSocket handshake failed\");\n                return;\n            }\n            async_read(buffer_, ws_->next_layer(), onRead);\n        }\n\n        void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n            if (ec) {\n                onError(ec, \"Write failed\");\n                return;\n            }\n            if (bytes_transferred > 0) {\n                send(\"\", \"\");\n            }\n        }\n\n        void read() {\n            async_read(buffer_, ws_->next_layer(), onRead);\n        }\n\n        void onRead(beast::error_code ec, std::size_t bytes_transmitted) {\n            if (ec) {\n                onError(ec, \"Read failed\");\n                return;\n            }\n            if (bytes_transmitted > 0) {\n                log_->log(\"Received: \" + std::string(buffer_.data(), buffer_.size());\n                buffer_.clear();\n            }\n        }\n\n        void onError(beast::error_code ec, const std::string& msg) {\n            log_->log(\"Error: \" + msg);\n            if (ec) {\n                close();\n            }\n        }\n\n        void enqueueWork(Work& work) {\n            // Implementation placeholder\n        }\n\n        void close() {\n            if (ws_) {\n                ws_->close(beast::websocket::close::normal, \"Closing\");\n            }\n            if (ws_tcp_) {\n                ws_tcp_->close(beast::websocket::close::normal, \"Closing\");\n            }\n            socket_status_ = 0;\n        }\n    };\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Implement a TCP client using Boost.Asio for asynchronous network communication, capable of connecting to a server, sending messages, and receiving responses.\n\nClass Description: The `chat_client` class encapsulates a TCP client that manages asynchronous network operations including connection establishment, message reading, and message writing.\n\nAttributes:\n- io_context_: boost::asio::io_context& - Reference to the I/O execution context for asynchronous operations.\n- socket_: tcp::socket - TCP socket for communication with the server.\n- read_msg_: chat_message - Buffer for storing the currently read message.\n- write_msgs_: chat_message_queue - Queue of messages waiting to be sent to the server.\n\nMethods:\n- Constructor: chat_client(boost::asio::io_context& io_context, const tcp::resolver::results_type& endpoints) -> None - Initializes the client with I/O context and server endpoints, then starts the connection process.\n- write: write(const chat_message& msg) -> None - Enqueues a message for asynchronous sending to the server.\n- close: close() -> None - Initiates socket closure to terminate the connection cleanly.\n- do_connect: do_connect(const tcp::resolver::results_type& endpoints) -> None - Asynchronously connects to the server using the provided endpoints.\n- do_read_header: do_read_header() -> None - Asynchronously reads the message header from the server.\n- do_read_body: do_read_body() -> None - Asynchronously reads the message body from the server after header is processed.\n- do_write: do_write() -> None - Asynchronously writes the next queued message to the server.",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <deque>\n#include \"chat_message.hpp\"\n\nusing boost::asio::ip::tcp;\ntypedef std::deque<chat_message> chat_message_queue;\n\nclass chat_client\n{\npublic:\n  chat_client(boost::asio::io_context& io_context,\n      const tcp::resolver::results_type& endpoints)\n    : io_context_(io_context),\n      socket_(io_context)\n  {\n    do_connect(endpoints);\n  }\n\n  void write(const chat_message& msg)\n  {\n    boost::asio::post(io_context_,\n        [this, msg]()\n        {\n          bool write_in_progress = !write_msgs_.empty();\n          write_msgs_.push_back(msg);\n          if (!write_in_progress)\n          {\n            do_write();\n          }\n        });\n  }\n\n  void close()\n  {\n    boost::asio::post(io_context_, [this]() { socket_.close(); });\n  }\n\nprivate:\n  void do_connect(const tcp::resolver::results_type& endpoints)\n  {\n    boost::asio::async_connect(socket_, endpoints,\n        [this](boost::system::error_code ec, tcp::endpoint)\n        {\n          if (!ec)\n          {\n            do_read_header();\n          }\n        });\n  }\n\n  void do_read_header()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.data(), chat_message::header_length),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec && read_msg_.decode_header())\n          {\n            do_read_body();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_read_body()\n  {\n    boost::asio::async_read(socket_,\n        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            std::cout.write(read_msg_.body(), read_msg_.body_length());\n            std::cout << \"\\n\";\n            do_read_header();\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\n  void do_write()\n  {\n    boost::asio::async_write(socket_,\n        boost::asio::buffer(write_msgs_.front().data(),\n          write_msgs_.front().length()),\n        [this](boost::system::error_code ec, std::size_t /*length*/)\n        {\n          if (!ec)\n          {\n            write_msgs_.pop_front();\n            if (!write_msgs_.empty())\n            {\n              do_write();\n            }\n          }\n          else\n          {\n            socket_.close();\n          }\n        });\n  }\n\nprivate:\n  boost::asio::io_context& io_context_;\n  tcp::socket socket_;\n  chat_message read_msg_;\n  chat_message_queue write_msgs_;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <queue>\n#include <vector>\n\nstruct chat_message {\n    uint32_t length;\n    std::vector<char> data;\n};\n\nclass chat_client {\npublic:\n    chat_client(boost::asio::io_context& io_context, const boost::asio::ip::tcp::resolver::results_type& endpoints)\n        : io_context_(io_context), socket_(io_context_), read_msg_(), write_msgs_() {\n        do_connect(endpoints);\n    }\n\n    void write(const chat_message& msg) {\n        write_msgs_.push(msg);\n        do_write();\n    }\n\n    void close() {\n        socket_.close();\n    }\n\nprivate:\n    void do_connect(const boost::asio::ip::tcp::resolver::results_type& endpoints) {\n        socket_.async_connect(endpoints, [this](boost::system::error_code ec) {\n            if (!ec) {\n                do_read_header();\n                do_write();\n            } else {\n                // Handle error\n            }\n        });\n    }\n\n    void do_read_header() {\n        boost::asio::mutable_buffer buf(reinterpret_cast<char*>(&read_msg_.length), sizeof(read_msg_.length));\n        socket_.async_read_some(buf, [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n            if (!ec && bytes_transferred == sizeof(read_msg_.length)) {\n                do_read_body();\n            } else {\n                // Handle error\n            }\n        });\n    }\n\n    void do_read_body() {\n        boost::asio::mutable_buffer buf(reinterpret_cast<char*>(read_msg_.data.data()), read_msg_.length);\n        socket_.async_read_some(buf, [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n            if (!ec && bytes_transferred == read_msg_.length) {\n                // Process received message\n                // Then read next header\n                do_read_header();\n            } else {\n                // Handle error\n            }\n        });\n    }\n\n    void do_write() {\n        if (!write_msgs_.empty() && socket_.is_connected()) {\n            chat_message msg = write_msgs_.front();\n            write_msgs_.pop();\n            boost::asio::mutable_buffer buf(reinterpret_cast<char*>(msg.data.data()), msg.length);\n            socket_.async_write_some(buf, [this](boost::system::error_code ec, std::size_t bytes_transferred) {\n                if (!ec && bytes_transferred == msg.length) {\n                    do_read_header();\n                } else {\n                    // Handle error\n                }\n            });\n        }\n    }\n\n    boost::asio::io_context& io_context_;\n    boost::asio::ip::tcp::socket socket_;\n    chat_message read_msg_;\n    std::queue<chat_message> write_msgs_;\n};"
  }
]