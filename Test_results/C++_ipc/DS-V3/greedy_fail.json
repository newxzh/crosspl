[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that performs HTTP requests using the cpp-httplib library, supporting multiple HTTP methods (GET, PUT, DELETE, POST) and handling JSON request/response data.\n\nFunction Description: The function `APIRequest` performs HTTP requests to a specified URL using the given HTTP method. It supports sending JSON data in the request and parsing JSON data from the response. The function checks the HTTP status code and only processes the response body if the status indicates success (2xx).\n\nInput:\n- `method` (std::string): The HTTP method to use (e.g., \"GET\", \"PUT\", \"DELETE\", \"POST\").\n- `location` (std::string): The server address (e.g., \"example.com\").\n- `URI` (std::string): The URI path for the request (e.g., \"/api/data\").\n- `request_data` (json*, optional): Pointer to a JSON object containing the data to send with the request (used for PUT requests).\n- `response_data` (json*, optional): Pointer to a JSON object where the response data will be stored if the request is successful.\n\nOutput:\n- Returns a `long` value representing the HTTP status code of the response.\n- If the request is successful (status code 2xx) and `response_data` is provided, the response body is parsed into the `response_data` JSON object.",
    "Canonical_solution": "#include \"httplib.h\"\n#include <string>\n#include \"json.hpp\"\nusing json = nlohmann::json;\n\nlong APIRequest(std::string method, std::string location, std::string URI, json* request_data = nullptr, json* response_data = nullptr)\n{\n    const std::string url(\"http://\" + location);\n    httplib::Client client(url.c_str());\n    int             status  = 0;\n    std::string     body    = \"\";\n\n    if(method == \"GET\")\n    {\n        httplib::Result result = client.Get(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"PUT\")\n    {\n        if(request_data)\n        {\n            httplib::Result result = client.Put(URI.c_str(), request_data->dump(), \"application/json\");\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n        else\n        {\n            httplib::Result result = client.Put(URI.c_str());\n            if(httplib::Error::Success == result.error())\n            {\n                status  = result->status;\n                body    = result->body;\n            }\n        }\n    }\n    else if(method == \"DELETE\")\n    {\n        httplib::Result result = client.Delete(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n    else if(method == \"POST\")\n    {\n        httplib::Result result = client.Post(URI.c_str());\n        if(httplib::Error::Success == result.error())\n        {\n            status  = result->status;\n            body    = result->body;\n        }\n    }\n\n    if((status / 100) == 2)\n    {\n        if(response_data)\n        {\n            *response_data = json::parse(body);\n        }\n    }\n\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 147,
    "wrong_result": "#include <httplib.h>\n#include <nlohmann/json.hpp>\n#include <string>\n\nusing json = nlohmann::json;\n\nlong APIRequest(const std::string& method, const std::string& location, const std::string& URI, const json* request_data = nullptr, json* response_data = nullptr) {\n    httplib::Client client(location);\n    httplib::Headers headers = {{\"Content-Type\", \"application/json\"}};\n    std::string request_body = request_data ? request_data->dump() : \"\";\n    httplib::Result response;\n\n    if (method == \"GET\") {\n        response = client.Get(URI.c_str(), headers);\n    } else if (method == \"PUT\") {\n        response = client.Put(URI.c_str(), headers, request_body, \"application/json\");\n    } else if (method == \"DELETE\") {\n        response = client.Delete(URI.c_str(), headers, request_body, \"application/json\");\n    } else if (method == \"POST\") {\n        response = client.Post(URI.c_str(), headers, request_body, \"application/json\");\n    } else {\n        return -1;\n    }\n\n    if (!response) {\n        return -1;\n    }\n\n    long status_code = response->status;\n    if (status_code >= 200 && status_code < 300 && response_data && !response->body.empty()) {\n        try {\n            *response_data = json::parse(response->body);\n        } catch (...) {\n            return -1;\n        }\n    }\n\n    return status_code;\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a TCP client class that can establish a connection to a server, send and receive data, and handle timeouts for non-blocking operations.\n\nClass Description: The TCPClient class provides functionality for TCP socket communication with a remote server. It supports both blocking and non-blocking operations with timeout capabilities, and handles cross-platform compatibility between Windows and Unix-like systems.\n\nAttributes:\n- address: std::string - The IP address or hostname of the server to connect to\n- port: u16 - The port number of the server to connect to\n- main_socket: SocketHolder (int) - The socket file descriptor for the connection\n- connected: bool - Flag indicating whether the client is currently connected to the server\n\nMethods:\n- Connect() -> bool - Establishes a connection to the server. Returns true if successful.\n- Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Reads data from the server into the buffer. Returns true if all requested bytes were read.\n- Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) -> bool - Writes data from the buffer to the server. Returns true if all bytes were written.\n- Disconnect() -> void - Closes the connection to the server.\n- SetNonBlock(SocketHolder sockFD, bool nonBlocking) -> bool - Sets the blocking mode of the socket. Returns true if successful.\n- ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) -> bool - Attempts to connect with a timeout. Returns true if successful.",
    "Canonical_solution": "#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <cerrno>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <chrono>\n#include <memory>\n#include <string>\n\n#ifdef _WIN32\n#define WSAEAGAIN WSAEWOULDBLOCK\n#define WSAEMULTIHOP -1\n#define ERRNO(x) WSA##x\n#define GET_ERRNO WSAGetLastError()\n#define poll(x, y, z) WSAPoll(x, y, z);\n#define SHUT_RD SD_RECEIVE\n#define SHUT_WR SD_SEND\n#define SHUT_RDWR SD_BOTH\n#else\n#define ERRNO(x) x\n#define GET_ERRNO errno\n#define closesocket(x) close(x)\n#endif\n\nclass TCPClient {\npublic:\n    using SocketHolder = int;\n\n    TCPClient(const std::string& address, u16 port) : address(address), port(port) {}\n\n    bool Connect() {\n        if (connected)\n            return true;\n\n        struct addrinfo hints, *addrinfo;\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_family = AF_INET;\n\n        if (getaddrinfo(address.data(), NULL, &hints, &addrinfo) != 0) {\n            return false;\n        }\n\n        main_socket = ::socket(AF_INET, SOCK_STREAM, 0);\n        if (main_socket == static_cast<SocketHolder>(-1)) {\n            return false;\n        }\n\n        if (!SetNonBlock(main_socket, true)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        struct sockaddr_in servaddr = {0};\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_addr.s_addr = ((struct sockaddr_in*)(addrinfo->ai_addr))->sin_addr.s_addr;\n        servaddr.sin_port = htons(port);\n        freeaddrinfo(addrinfo);\n\n        if (!ConnectWithTimeout(main_socket, &servaddr, sizeof(servaddr), 10)) {\n            closesocket(main_socket);\n            return false;\n        }\n\n        connected = true;\n        return true;\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t read_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (read_bytes != size) {\n            int new_read = ::recv(main_socket, (char*)((uintptr_t)buffer + read_bytes), \n                (int)(size - read_bytes), 0);\n            if (new_read < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                read_bytes = 0;\n                break;\n            }\n            read_bytes += new_read;\n        }\n        return read_bytes == size;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        size_t write_bytes = 0;\n        auto before = std::chrono::steady_clock::now();\n        while (write_bytes != size) {\n            int new_written = ::send(main_socket, (const char*)((uintptr_t)buffer + write_bytes),\n                                    (int)(size - write_bytes), 0);\n            if (new_written < 0) {\n                if (GET_ERRNO == ERRNO(EWOULDBLOCK) &&\n                    (timeout == std::chrono::nanoseconds(0) ||\n                     std::chrono::steady_clock::now() - before < timeout)) {\n                    continue;\n                }\n                write_bytes = 0;\n                break;\n            }\n            write_bytes += new_written;\n        }\n        return write_bytes == size;\n    }\n\n    void Disconnect() {\n        if (connected) {\n            shutdown(main_socket, SHUT_RDWR);\n            closesocket(main_socket);\n            connected = false;\n        }\n    }\n\nprivate:\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n        bool blocking = !nonBlocking;\n#ifdef _WIN32\n        unsigned long nonblocking = (blocking) ? 0 : 1;\n        int ret = ioctlsocket(sockFD, FIONBIO, &nonblocking);\n        if (ret == -1) {\n            return false;\n        }\n#else\n        int flags = ::fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) {\n            return false;\n        }\n\n        flags &= ~O_NONBLOCK;\n        if (!blocking) {\n            flags |= O_NONBLOCK;\n        }\n\n        const int ret = ::fcntl(sockFD, F_SETFL, flags);\n        if (ret == -1) {\n            return false;\n        }\n#endif\n        return true;\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len,\n                           int timeout_seconds) {\n        int res = ::connect(sockFD, (struct sockaddr*)server_addr, static_cast<int>(server_addr_len));\n        if (res == -1 && ((GET_ERRNO == ERRNO(EINPROGRESS) || GET_ERRNO == ERRNO(EWOULDBLOCK))) {\n            struct timeval tv;\n            fd_set fdset;\n            FD_ZERO(&fdset);\n            FD_SET(sockFD, &fdset);\n\n            tv.tv_sec = timeout_seconds;\n            tv.tv_usec = 0;\n            int select_res = ::select(static_cast<int>(sockFD + 1), NULL, &fdset, NULL, &tv);\n#ifdef _WIN32\n            if (select_res == 0) {\n                return false;\n            }\n#else\n            bool select_good = false;\n            if (select_res == 1) {\n                int so_error;\n                socklen_t len = sizeof so_error;\n\n                getsockopt(sockFD, SOL_SOCKET, SO_ERROR, &so_error, &len);\n\n                if (so_error == 0) {\n                    select_good = true;\n                }\n            }\n            if (!select_good) {\n                return false;\n            }\n#endif\n        } else if (res == -1) {\n            return false;\n        }\n        return true;\n    }\n\n    std::string address;\n    u16 port;\n    SocketHolder main_socket = -1;\n    bool connected = false;\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 149,
    "wrong_result": "#include <string>\n#include <chrono>\n#include <cstdint>\n#include <stdexcept>\n#include <system_error>\n#include <cstring>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef SOCKET SocketHolder;\nconstexpr SocketHolder INVALID_SOCKET_HOLDER = INVALID_SOCKET;\n#else\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <poll.h>\ntypedef int SocketHolder;\nconstexpr SocketHolder INVALID_SOCKET_HOLDER = -1;\n#endif\n\nclass TCPClient {\nprivate:\n    std::string address;\n    uint16_t port;\n    SocketHolder main_socket;\n    bool connected;\n\n    void InitializeSocket() {\n#ifdef _WIN32\n        WSADATA wsaData;\n        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n            throw std::system_error(WSAGetLastError(), std::system_category(), \"WSAStartup failed\");\n        }\n#endif\n        main_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n        if (main_socket == INVALID_SOCKET_HOLDER) {\n            throw std::system_error(GetLastSocketError(), std::system_category(), \"Socket creation failed\");\n        }\n    }\n\n    int GetLastSocketError() const {\n#ifdef _WIN32\n        return WSAGetLastError();\n#else\n        return errno;\n#endif\n    }\n\n    void CloseSocket(SocketHolder sock) {\n        if (sock != INVALID_SOCKET_HOLDER) {\n#ifdef _WIN32\n            closesocket(sock);\n#else\n            close(sock);\n#endif\n        }\n    }\n\npublic:\n    TCPClient(const std::string& addr, uint16_t p) : address(addr), port(p), main_socket(INVALID_SOCKET_HOLDER), connected(false) {\n        InitializeSocket();\n    }\n\n    ~TCPClient() {\n        Disconnect();\n#ifdef _WIN32\n        WSACleanup();\n#endif\n    }\n\n    bool Connect() {\n        if (connected) return true;\n\n        struct addrinfo hints = {}, *result = nullptr;\n        hints.ai_family = AF_INET;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n\n        if (getaddrinfo(address.c_str(), std::to_string(port).c_str(), &hints, &result) != 0) {\n            return false;\n        }\n\n        for (auto ptr = result; ptr != nullptr; ptr = ptr->ai_next) {\n            if (connect(main_socket, ptr->ai_addr, static_cast<int>(ptr->ai_addrlen)) == 0) {\n                connected = true;\n                break;\n            }\n        }\n\n        freeaddrinfo(result);\n        return connected;\n    }\n\n    bool SetNonBlock(SocketHolder sockFD, bool nonBlocking) {\n#ifdef _WIN32\n        u_long mode = nonBlocking ? 1 : 0;\n        return ioctlsocket(sockFD, FIONBIO, &mode) == 0;\n#else\n        int flags = fcntl(sockFD, F_GETFL, 0);\n        if (flags == -1) return false;\n        flags = nonBlocking ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK);\n        return fcntl(sockFD, F_SETFL, flags) != -1;\n#endif\n    }\n\n    bool ConnectWithTimeout(SocketHolder sockFD, void* server_addr, size_t server_addr_len, int timeout_seconds) {\n        if (!SetNonBlock(sockFD, true)) {\n            return false;\n        }\n\n        int result = connect(sockFD, static_cast<sockaddr*>(server_addr), static_cast<int>(server_addr_len));\n#ifdef _WIN32\n        if (result == SOCKET_ERROR && WSAGetLastError() != WSAEWOULDBLOCK) {\n            return false;\n        }\n#else\n        if (result == -1 && errno != EINPROGRESS) {\n            return false;\n        }\n#endif\n\n        fd_set set;\n        FD_ZERO(&set);\n        FD_SET(sockFD, &set);\n\n        timeval timeout;\n        timeout.tv_sec = timeout_seconds;\n        timeout.tv_usec = 0;\n\n        result = select(static_cast<int>(sockFD + 1), nullptr, &set, nullptr, &timeout);\n        if (result <= 0) {\n            return false;\n        }\n\n        int error = 0;\n        socklen_t len = sizeof(error);\n        if (getsockopt(sockFD, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&error), &len) != 0 || error != 0) {\n            return false;\n        }\n\n        return SetNonBlock(sockFD, false);\n    }\n\n    bool Read(void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected) return false;\n\n        auto timeout_ms = std::chrono::duration_cast<std::chrono::milliseconds>(timeout).count();\n        if (timeout_ms < 0) timeout_ms = 0;\n\n#ifdef _WIN32\n        fd_set set;\n        FD_ZERO(&set);\n        FD_SET(main_socket, &set);\n\n        timeval tv;\n        tv.tv_sec = static_cast<long>(timeout_ms / 1000);\n        tv.tv_usec = static_cast<long>((timeout_ms % 1000) * 1000);\n\n        int result = select(0, &set, nullptr, nullptr, &tv);\n        if (result <= 0) return false;\n#else\n        pollfd pfd;\n        pfd.fd = main_socket;\n        pfd.events = POLLIN;\n\n        int result = poll(&pfd, 1, static_cast<int>(timeout_ms));\n        if (result <= 0) return false;\n#endif\n\n        size_t totalRead = 0;\n        while (totalRead < size) {\n            int bytesRead = recv(main_socket, static_cast<char*>(buffer) + totalRead, static_cast<int>(size - totalRead), 0);\n            if (bytesRead <= 0) {\n                Disconnect();\n                return false;\n            }\n            totalRead += static_cast<size_t>(bytesRead);\n        }\n\n        return true;\n    }\n\n    bool Write(const void* buffer, size_t size, const std::chrono::nanoseconds& timeout) {\n        if (!connected) return false;\n\n        auto timeout_ms = std::chrono::duration_cast<std::chrono::milliseconds>(timeout).count();\n        if (timeout_ms < 0) timeout_ms = 0;\n\n#ifdef _WIN32\n        fd_set set;\n        FD_ZERO(&set);\n        FD_SET(main_socket, &set);\n\n        timeval tv;\n        tv.tv_sec = static_cast<long>(timeout_ms / 1000);\n        tv.tv_usec = static_cast<long>((timeout_ms % 1000) * 1000);\n\n        int result = select(0, nullptr, &set, nullptr, &tv);\n        if (result <= 0) return false;\n#else\n        pollfd pfd;\n        pfd.fd = main_socket;\n        pfd.events = POLLOUT;\n\n        int result = poll(&pfd, 1, static_cast<int>(timeout_ms));\n        if (result <= 0) return false;\n#endif\n\n        size_t totalSent = 0;\n        while (totalSent < size) {\n            int bytesSent = send(main_socket, static_cast<const char*>(buffer) + totalSent, static_cast<int>(size - totalSent), 0);\n            if (bytesSent <= 0) {\n                Disconnect();\n                return false;\n            }\n            totalSent += static_cast<size_t>(bytesSent);\n        }\n\n        return true;\n    }\n\n    void Disconnect() {\n        if (connected) {\n            CloseSocket(main_socket);\n            main_socket = INVALID_SOCKET_HOLDER;\n            connected = false;\n        }\n    }\n};"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections, manages network communication, and provides thread-safe operations for client management.\n\nClass Description: The NetworkServer class implements a TCP server that listens for incoming connections, manages connected clients, and handles network communication through separate threads. It supports both IPv4 and IPv6 addresses and includes error handling for socket operations.\n\nAttributes:\n- host: std::string - The host address to bind the server to\n- port_num: unsigned short - The port number to listen on\n- server_online: bool - Flag indicating if the server is running\n- server_listening: bool - Flag indicating if the server is actively listening for connections\n- ServerClients: std::vector<NetworkClientInfo *> - List of connected client information\n- ServerClientsMutex: std::mutex - Mutex for thread-safe access to client list\n- server_sock: SOCKET[MAXSOCK] - Array of server socket descriptors\n- socket_count: int - Number of active server sockets\n- ConnectionThread: std::thread *[MAXSOCK] - Array of connection handler threads\n\nMethods:\n- NetworkServer(std::vector<RGBController *>& control) -> None - Constructor that initializes the server with controller references\n- ~NetworkServer() -> None - Destructor that stops the server and cleans up resources\n- StartServer() -> None - Starts the server, creates sockets, binds to address, and begins listening for connections\n- StopServer() -> None - Stops the server, closes all connections, and cleans up threads\n- ConnectionThreadFunction(int socket_idx) -> None - Thread function that handles incoming connections for a specific socket\n- accept_select(int sockfd) -> int - Helper function that implements timeout-based socket acceptance\n- GetPort() -> unsigned short - Returns the current port number (implied but not shown in code)\n- ClientInfoChanged() -> None - Callback for client list changes (implied but not shown in code)\n- ServerListeningChanged() -> None - Callback for server listening state changes (implied but not shown in code)\n- ListenThreadFunction(NetworkClientInfo * client_info) -> None - Thread function that handles communication with a specific client (implied but not shown in code)",
    "Canonical_solution": "#include <cstring>\n#include <memory.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#ifndef WIN32\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#else\n#include <ws2tcpip.h>\n#endif\n\nconst char yes = 1;\n\nclass NetworkServer\n{\npublic:\n    NetworkServer(std::vector<RGBController *>& control) : controllers(control)\n    {\n        host             = OPENRGB_SDK_HOST;\n        port_num         = OPENRGB_SDK_PORT;\n        server_online    = false;\n        server_listening = false;\n        for(int i = 0; i < MAXSOCK; i++)\n        {\n            ConnectionThread[i] = nullptr;\n        }\n        profile_manager  = nullptr;\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        int err;\n        struct addrinfo hints, *res, *result;\n\n        char port_str[6];\n        snprintf(port_str, 6, \"%d\", port_num);\n\n        socket_count = 0;\n\n#ifdef WIN32\n        if(WSAStartup(MAKEWORD(2, 2), &wsa) != NO_ERROR)\n        {\n            WSACleanup();\n            return;\n        }\n#endif\n\n        memset(&hints, 0, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_PASSIVE;\n        err = getaddrinfo(host.c_str(), port_str, &hints, &result);\n\n        if(err)\n        {\n            LOG_ERROR(\"NetworkServer: Unable to get address.\");\n            WSACleanup();\n            return;\n        }\n\n        for(res = result; res && socket_count < MAXSOCK; res = res->ai_next)\n        {\n            server_sock[socket_count] = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n            if(server_sock[socket_count] == INVALID_SOCKET)\n            {\n                LOG_ERROR(\"NetworkServer: Network socket could not be created.\");\n                WSACleanup();\n                return;\n            }\n\n            if(bind(server_sock[socket_count], res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)\n            {\n                if(errno == EADDRINUSE)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Is port %hu already being used?\", GetPort());\n                }\n                else if(errno == EACCES)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. Access to socket was denied.\");\n                }\n                else if(errno == EBADF)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. sockfd is not a valid file descriptor.\");\n                }\n                else if(errno == EINVAL)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The socket is already bound to an address, or addrlen is wrong, or addr is not a valid address for this socket's domain.\");\n                }\n                else if(errno == ENOTSOCK)\n                {\n                    LOG_ERROR(\"NetworkServer: Could not bind network socket. The file descriptor sockfd does not refer to a socket.\");\n                }\n                else\n                {\n                    LOG_ERROR(\"NetworkManager: Could not bind network socket. Error code: %d.\", errno);\n                }\n\n                WSACleanup();\n                return;\n            }\n\n            setsockopt(server_sock[socket_count], IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            socket_count += 1;\n        }\n\n        freeaddrinfo(result);\n        server_online = true;\n\n        for(int curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            ConnectionThread[curr_socket] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, curr_socket);\n            ConnectionThread[curr_socket]->detach();\n        }\n    }\n\n    void StopServer()\n    {\n        int curr_socket;\n        server_online = false;\n\n        ServerClientsMutex.lock();\n\n        for(unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            delete ServerClients[client_idx];\n        }\n\n        ServerClients.clear();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            shutdown(server_sock[curr_socket], SD_RECEIVE);\n            closesocket(server_sock[curr_socket]);\n        }\n\n        ServerClientsMutex.unlock();\n\n        for(curr_socket = 0; curr_socket < socket_count; curr_socket++)\n        {\n            if(ConnectionThread[curr_socket])\n            {\n                delete ConnectionThread[curr_socket];\n                ConnectionThread[curr_socket] = nullptr;\n            }\n        }\n\n        socket_count = 0;\n        ClientInfoChanged();\n    }\n\nprivate:\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        LOG_INFO(\"NetworkServer: Network connection thread started on port %hu\", GetPort());\n\n        while(server_online == true)\n        {\n            NetworkClientInfo * client_info = new NetworkClientInfo();\n\n            if(listen(server_sock[socket_idx], 10) < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                return;\n            }\n\n            server_listening = true;\n            ServerListeningChanged();\n\n            client_info->client_sock = accept_select((int)server_sock[socket_idx]);\n\n            if(client_info->client_sock < 0)\n            {\n                LOG_INFO(\"NetworkServer: Connection thread closed\");\n                server_online = false;\n                server_listening = false;\n                ServerListeningChanged();\n                return;\n            }\n\n            u_long arg = 0;\n            ioctlsocket(client_info->client_sock, FIONBIO, &arg);\n            setsockopt(client_info->client_sock, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));\n\n            struct sockaddr_storage tmp_addr;\n            char ipstr[INET6_ADDRSTRLEN];\n            socklen_t len;\n            len = sizeof(tmp_addr);\n            getpeername(client_info->client_sock, (struct sockaddr*)&tmp_addr, &len);\n\n            if(tmp_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in *s_4 = (struct sockaddr_in *)&tmp_addr;\n                inet_ntop(AF_INET, &s_4->sin_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n            else\n            {\n                struct sockaddr_in6 *s_6 = (struct sockaddr_in6 *)&tmp_addr;\n                inet_ntop(AF_INET6, &s_6->sin6_addr, ipstr, sizeof(ipstr));\n                client_info->client_ip = ipstr;\n            }\n\n            ServerClientsMutex.lock();\n            client_info->client_listen_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, client_info);\n            client_info->client_listen_thread->detach();\n            ServerClients.push_back(client_info);\n            ServerClientsMutex.unlock();\n            ClientInfoChanged();\n        }\n\n        LOG_INFO(\"NetworkServer: Connection thread closed\");\n        server_online = false;\n        server_listening = false;\n        ServerListeningChanged();\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set              set;\n        struct timeval      timeout;\n\n        while(1)\n        {\n            timeout.tv_sec          = TCP_TIMEOUT_SECONDS;\n            timeout.tv_usec         = 0;\n\n            FD_ZERO(&set);\n            FD_SET(sockfd, &set);\n\n            int rv = select(sockfd + 1, &set, NULL, NULL, &timeout);\n\n            if(rv == SOCKET_ERROR || server_online == false)\n            {\n                return -1;\n            }\n            else if(rv == 0)\n            {\n                continue;\n            }\n            else\n            {\n                return(accept((int)sockfd, NULL, NULL));\n            }\n        }\n    }\n\n    std::string host;\n    unsigned short port_num;\n    bool server_online;\n    bool server_listening;\n    std::vector<NetworkClientInfo *> ServerClients;\n    std::mutex ServerClientsMutex;\n    SOCKET server_sock[MAXSOCK];\n    int socket_count;\n    std::thread *ConnectionThread[MAXSOCK];\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <vector>\n#include <string>\n#include <mutex>\n#include <thread>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n\n#define MAXSOCK 2\n#define MAX_CLIENTS 10\n\nstruct NetworkClientInfo\n{\n    SOCKET          client_sock;\n    std::string     client_ip;\n    unsigned short  client_port;\n    std::thread*    client_thread;\n    bool            thread_run;\n};\n\nclass NetworkServer\n{\nprivate:\n    std::string                     host;\n    unsigned short                  port_num;\n    bool                            server_online;\n    bool                            server_listening;\n    std::vector<NetworkClientInfo*> ServerClients;\n    std::mutex                      ServerClientsMutex;\n    SOCKET                          server_sock[MAXSOCK];\n    int                             socket_count;\n    std::thread*                    ConnectionThread[MAXSOCK];\n    std::vector<class RGBController*> controllers;\n\npublic:\n    NetworkServer(std::vector<class RGBController*>& control) : controllers(control)\n    {\n        host = \"0.0.0.0\";\n        port_num = 0;\n        server_online = false;\n        server_listening = false;\n        socket_count = 0;\n\n        for (int i = 0; i < MAXSOCK; i++)\n        {\n            server_sock[i] = INVALID_SOCKET;\n            ConnectionThread[i] = nullptr;\n        }\n    }\n\n    ~NetworkServer()\n    {\n        StopServer();\n    }\n\n    void StartServer()\n    {\n        if (server_online)\n        {\n            return;\n        }\n\n        WSADATA wsa_data;\n        if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0)\n        {\n            return;\n        }\n\n        struct addrinfo hints;\n        struct addrinfo* result = NULL;\n        struct addrinfo* ptr = NULL;\n\n        ZeroMemory(&hints, sizeof(hints));\n        hints.ai_family = AF_UNSPEC;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_protocol = IPPROTO_TCP;\n        hints.ai_flags = AI_PASSIVE;\n\n        std::string port_str = std::to_string(port_num);\n        if (getaddrinfo(host.c_str(), port_str.c_str(), &hints, &result) != 0)\n        {\n            WSACleanup();\n            return;\n        }\n\n        for (ptr = result, socket_count = 0; ptr != NULL && socket_count < MAXSOCK; ptr = ptr->ai_next)\n        {\n            server_sock[socket_count] = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);\n            if (server_sock[socket_count] == INVALID_SOCKET)\n            {\n                continue;\n            }\n\n            if (bind(server_sock[socket_count], ptr->ai_addr, (int)ptr->ai_addrlen) == SOCKET_ERROR)\n            {\n                closesocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            if (listen(server_sock[socket_count], SOMAXCONN) == SOCKET_ERROR)\n            {\n                closesocket(server_sock[socket_count]);\n                server_sock[socket_count] = INVALID_SOCKET;\n                continue;\n            }\n\n            int addrlen = sizeof(struct sockaddr_storage);\n            struct sockaddr_storage addr;\n            getsockname(server_sock[socket_count], (struct sockaddr*)&addr, &addrlen);\n            if (addr.ss_family == AF_INET)\n            {\n                port_num = ntohs(((struct sockaddr_in*)&addr)->sin_port);\n            }\n            else if (addr.ss_family == AF_INET6)\n            {\n                port_num = ntohs(((struct sockaddr_in6*)&addr)->sin6_port);\n            }\n\n            ConnectionThread[socket_count] = new std::thread(&NetworkServer::ConnectionThreadFunction, this, socket_count);\n            socket_count++;\n        }\n\n        freeaddrinfo(result);\n\n        if (socket_count == 0)\n        {\n            WSACleanup();\n            return;\n        }\n\n        server_online = true;\n        server_listening = true;\n    }\n\n    void StopServer()\n    {\n        if (!server_online)\n        {\n            return;\n        }\n\n        server_listening = false;\n\n        for (int i = 0; i < socket_count; i++)\n        {\n            if (ConnectionThread[i] != nullptr)\n            {\n                if (ConnectionThread[i]->joinable())\n                {\n                    ConnectionThread[i]->join();\n                }\n                delete ConnectionThread[i];\n                ConnectionThread[i] = nullptr;\n            }\n\n            if (server_sock[i] != INVALID_SOCKET)\n            {\n                closesocket(server_sock[i]);\n                server_sock[i] = INVALID_SOCKET;\n            }\n        }\n\n        socket_count = 0;\n\n        ServerClientsMutex.lock();\n        for (unsigned int client_idx = 0; client_idx < ServerClients.size(); client_idx++)\n        {\n            if (ServerClients[client_idx]->client_thread != nullptr)\n            {\n                ServerClients[client_idx]->thread_run = false;\n                if (ServerClients[client_idx]->client_thread->joinable())\n                {\n                    ServerClients[client_idx]->client_thread->join();\n                }\n                delete ServerClients[client_idx]->client_thread;\n                ServerClients[client_idx]->client_thread = nullptr;\n            }\n\n            if (ServerClients[client_idx]->client_sock != INVALID_SOCKET)\n            {\n                closesocket(ServerClients[client_idx]->client_sock);\n                ServerClients[client_idx]->client_sock = INVALID_SOCKET;\n            }\n\n            delete ServerClients[client_idx];\n        }\n        ServerClients.clear();\n        ServerClientsMutex.unlock();\n\n        WSACleanup();\n        server_online = false;\n    }\n\n    void ConnectionThreadFunction(int socket_idx)\n    {\n        while (server_listening)\n        {\n            int client_sock = accept_select(server_sock[socket_idx]);\n\n            if (client_sock == INVALID_SOCKET)\n            {\n                continue;\n            }\n\n            struct sockaddr_storage client_addr;\n            socklen_t addr_len = sizeof(client_addr);\n            getpeername(client_sock, (struct sockaddr*)&client_addr, &addr_len);\n\n            char client_ip[INET6_ADDRSTRLEN];\n            unsigned short client_port = 0;\n\n            if (client_addr.ss_family == AF_INET)\n            {\n                struct sockaddr_in* s = (struct sockaddr_in*)&client_addr;\n                inet_ntop(AF_INET, &s->sin_addr, client_ip, sizeof(client_ip));\n                client_port = ntohs(s->sin_port);\n            }\n            else\n            {\n                struct sockaddr_in6* s = (struct sockaddr_in6*)&client_addr;\n                inet_ntop(AF_INET6, &s->sin6_addr, client_ip, sizeof(client_ip));\n                client_port = ntohs(s->sin6_port);\n            }\n\n            ServerClientsMutex.lock();\n            if (ServerClients.size() >= MAX_CLIENTS)\n            {\n                closesocket(client_sock);\n                ServerClientsMutex.unlock();\n                continue;\n            }\n\n            NetworkClientInfo* new_client = new NetworkClientInfo;\n            new_client->client_sock = client_sock;\n            new_client->client_ip = client_ip;\n            new_client->client_port = client_port;\n            new_client->thread_run = true;\n            new_client->client_thread = new std::thread(&NetworkServer::ListenThreadFunction, this, new_client);\n\n            ServerClients.push_back(new_client);\n            ServerClientsMutex.unlock();\n        }\n    }\n\n    int accept_select(int sockfd)\n    {\n        fd_set set;\n        struct timeval timeout;\n\n        FD_ZERO(&set);\n        FD_SET(sockfd, &set);\n\n        timeout.tv_sec = 1;\n        timeout.tv_usec = 0;\n\n        int rv = select(0, &set, NULL, NULL, &timeout);\n        if (rv == SOCKET_ERROR)\n        {\n            return INVALID_SOCKET;\n        }\n        else if (rv == 0)\n        {\n            return INVALID_SOCKET;\n        }\n\n        return accept(sockfd, NULL, NULL);\n    }\n\n    unsigned short GetPort()\n    {\n        return port_num;\n    }\n};"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Implement a TCP server in C++ that listens for incoming connections, handles client requests in separate child processes, and responds to clients after processing their data.\n\nFunction Description: The function `tcp_server_communication` creates a TCP server that binds to a specified port, listens for incoming connections, and forks child processes to handle each client connection. Each child process reads a character from the client, increments it after a delay, and sends it back before terminating.\n\nInput: None (The function uses predefined constants: port number 9736 and INADDR_ANY for binding to all available network interfaces)\n\nOutput: None (The function runs indefinitely, servicing client requests and doesn't return any value)\n\nNote: The function includes signal handling to prevent zombie processes from terminated child processes. Each client connection is handled in a separate child process while the parent process continues to accept new connections.",
    "Canonical_solution": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <signal.h>\n\nvoid tcp_server_communication()\n{\n    int server_sockfd = -1;\n    int client_sockfd = -1;\n    int client_len = 0;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n    \n    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(9736);\n    \n    bind(server_sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(server_sockfd, 5);\n    signal(SIGCHLD, SIG_IGN);\n\n    while(1)\n    {\n        char ch = '\\0';\n        client_len = sizeof(client_addr);\n        client_sockfd = accept(server_sockfd, (struct sockaddr*)&client_addr,\n                               (socklen_t *)&client_len);\n\n        if(fork() == 0)\n        {\n            read(client_sockfd, &ch, 1);\n            sleep(5);\n            ch++;\n            write(client_sockfd, &ch, 1);\n            close(client_sockfd);\n            exit(0);\n        }\n        else\n        {\n            close(client_sockfd);\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 148,
    "wrong_result": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <iostream>\n#include <cstring>\n\nvoid handle_client(int client_socket) {\n    char client_data;\n    if (read(client_socket, &client_data, sizeof(client_data)) < 0) {\n        perror(\"read\");\n        close(client_socket);\n        exit(1);\n    }\n\n    sleep(1);\n    client_data++;\n\n    if (write(client_socket, &client_data, sizeof(client_data)) < 0) {\n        perror(\"write\");\n        close(client_socket);\n        exit(1);\n    }\n\n    close(client_socket);\n    exit(0);\n}\n\nvoid sigchld_handler(int sig) {\n    while (waitpid(-1, NULL, WNOHANG) > 0);\n}\n\nvoid tcp_server_communication() {\n    int server_socket, client_socket;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    pid_t child_pid;\n\n    signal(SIGCHLD, sigchld_handler);\n\n    server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket < 0) {\n        perror(\"socket\");\n        exit(1);\n    }\n\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(9736);\n\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"bind\");\n        exit(1);\n    }\n\n    if (listen(server_socket, 5) < 0) {\n        perror(\"listen\");\n        exit(1);\n    }\n\n    while (true) {\n        client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);\n        if (client_socket < 0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        child_pid = fork();\n        if (child_pid < 0) {\n            perror(\"fork\");\n            close(client_socket);\n            continue;\n        }\n\n        if (child_pid == 0) {\n            close(server_socket);\n            handle_client(client_socket);\n        } else {\n            close(client_socket);\n        }\n    }\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Implement a UDP server using Boost.Asio that listens for incoming datagrams and responds with the current daytime string.\n\nFunction Description: The function `udp_server` creates a UDP server that listens on port 13 (daytime protocol port). When it receives any datagram from a client, it responds with the current time in string format. The server runs indefinitely until an exception occurs.\n\nInput: None\n\nOutput: None (The function runs indefinitely and sends responses to clients, but doesn't return any value)",
    "Canonical_solution": "#include <array>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string()\n{\n  using namespace std;\n  time_t now = time(0);\n  return ctime(&now);\n}\n\nvoid udp_server()\n{\n  try\n  {\n    boost::asio::io_context io_context;\n\n    udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));\n\n    for (;;)\n    {\n      std::array<char, 1> recv_buf;\n      udp::endpoint remote_endpoint;\n      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);\n\n      std::string message = make_daytime_string();\n\n      boost::system::error_code ignored_error;\n      socket.send_to(boost::asio::buffer(message),\n          remote_endpoint, 0, ignored_error);\n    }\n  }\n  catch (std::exception& e)\n  {\n    std::cerr << e.what() << std::endl;\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 153,
    "wrong_result": "#include <ctime>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\nstd::string make_daytime_string() {\n    std::time_t now = std::time(0);\n    return std::ctime(&now);\n}\n\nvoid udp_server() {\n    try {\n        boost::asio::io_service io_service;\n        udp::socket socket(io_service, udp::endpoint(udp::v4(), 13));\n        for (;;) {\n            char recv_buf[1];\n            udp::endpoint remote_endpoint;\n            socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);\n            std::string message = make_daytime_string();\n            socket.send_to(boost::asio::buffer(message), remote_endpoint);\n        }\n    } catch (std::exception& e) {\n    }\n}"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Implement a WebSocket client class for webOS devices that supports both SSL and non-SSL connections using Boost.Asio and Boost.Beast libraries. The client should handle asynchronous connection, message sending/receiving, and error handling.\n\nClass Description: WebOsClient::Impl is an implementation class for a webOS WebSocket client that manages TCP/SSL WebSocket connections to a webOS device. It handles connection lifecycle, message exchange, and error recovery.\n\nAttributes:\n- ioc_: [net::io_context&] - Reference to Boost.Asio I/O context for asynchronous operations\n- ctx_: [ssl::context&] - Reference to SSL context for secure connections\n- device_settings_: [Device] - Configuration settings for the target device\n- log_: [std::shared_ptr<Logging>] - Shared pointer to logging utility\n- resolver_: [tcp::resolver] - TCP resolver for hostname resolution\n- ws_: [std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>>] - Optional SSL WebSocket stream\n- ws_tcp_: [std::optional<websocket::stream<beast::tcp_stream>>] - Optional non-SSL WebSocket stream\n- buffer_: [beast::flat_buffer] - Buffer for incoming messages\n- host_: [std::string] - Target host address with port\n- socket_status_: [int] - Current connection status (disconnected/connecting/connected)\n\nMethods:\n- run(): [void]() - Initiates the connection process by resolving the hostname\n- onResolve(): [void](beast::error_code, tcp::resolver::results_type) - Callback for hostname resolution completion\n- onConnect(): [void](beast::error_code, tcp::resolver::results_type::endpoint_type) - Callback for TCP connection completion\n- onSSLhandshake(): [void](beast::error_code) - Callback for SSL handshake completion\n- onWinsockHandshake(): [void](beast::error_code) - Callback for WebSocket handshake completion\n- send(): [void](std::string, std::string) - Sends data through the WebSocket connection\n- onWrite(): [void](beast::error_code, std::size_t) - Callback for write operation completion\n- read(): [void]() - Initiates an asynchronous read operation\n- onRead(): [void](beast::error_code, std::size_t) - Callback for read operation completion\n- onError(): [void](beast::error_code&, std::string) - Handles connection errors\n- enqueueWork(): [void](Work&) - Adds work to the processing queue\n- close(): [void]() - Initiates connection shutdown\n- Impl(): [Constructor](net::io_context&, ssl::context&, Device&, Logging&) - Constructor initializing core components",
    "Canonical_solution": "#include <boost/asio.hpp>\n#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <nlohmann/json.hpp>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\nusing udp = boost::asio::ip::udp;\nusing json = nlohmann::json;\n\nclass WebOsClient::Impl : public std::enable_shared_from_this<WebOsClient::Impl> {\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_ = SOCKET_DISCONNECTED;\n\n    void run() {\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl)\n            ws_.emplace(resolver_.get_executor(), ctx_);\n        else\n            ws_tcp_.emplace(resolver_.get_executor());\n        host_ = device_settings_.ip;\n        resolver_.async_resolve(host_.c_str(), device_settings_.ssl ? PORT_SSL : PORT,\n            beast::bind_front_handler(&Impl::onResolve, shared_from_this()));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"onResolve\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, shared_from_this()));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"onConnect\");\n        socket_status_ = SOCKET_CONNECTING;\n        if(device_settings_.ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.ip.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"Failed to set SNI hostname\");\n            }\n            host_ += ':' + std::to_string(ep.port());\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, shared_from_this()));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::milliseconds(TIMER_ASYNC_TIMEOUT));\n            ws_tcp_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n            ws_tcp_->set_option(websocket::stream_base::decorator(\n                [](websocket::request_type& req) {\n                    req.set(http::field::user_agent,\n                        std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async\");\n                }));\n            host_ += ':' + std::to_string(ep.port());\n            ws_tcp_->async_handshake(host_, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onSSLhandshake\");\n        socket_status_ = SOCKET_CONNECTING;\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->set_option(websocket::stream_base::timeout::suggested(beast::role_type::client));\n        ws_->set_option(websocket::stream_base::decorator(\n            [](websocket::request_type& req) {\n                req.set(http::field::user_agent,\n                    std::string(BOOST_BEAST_VERSION_STRING) + \" websocket-client-async-ssl\");\n            }));\n        ws_->async_handshake(host_, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, shared_from_this()));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"onWinsockHandshake\");\n        socket_status_ = SOCKET_CONNECTED;\n        send(webos_handshake_, \"webOS handshake\");\n    }\n\n    void send(std::string data, std::string log_message = \"\") {\n        if(device_settings_.ssl) {\n            ws_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        } else {\n            ws_tcp_->async_write(net::buffer(data),\n                beast::bind_front_handler(&Impl::onWrite, shared_from_this()));\n        }\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onWrite\");\n        read();\n    }\n\n    void read() {\n        if(device_settings_.ssl)\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n        else\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, shared_from_this()));\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        boost::ignore_unused(bytes_transferred);\n        if (ec) return onError(ec, \"onRead\");\n        socket_status_ = SOCKET_CONNECTED;\n        // Process received data here\n        buffer_.consume(buffer_.size());\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string err) {\n        DEBUG(\"%1% (%2%)\", ec.message(), err);\n        socket_status_ = SOCKET_DISCONNECTED;\n    }\n\npublic:\n    explicit Impl(net::io_context& ioc, ssl::context& ctx, Device& settings, Logging& log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(settings), log_(std::make_shared<Logging>(log)),\n          resolver_(net::make_strand(ioc)) {}\n\n    void enqueueWork(Work& work) {\n        net::dispatch(resolver_.get_executor(),\n            [unit = work, self = shared_from_this()]() mutable {\n                self->workQueue_.emplace_back(std::move(unit));\n                self->startNextWork();\n            });\n    }\n\n    void close() {\n        net::dispatch(resolver_.get_executor(),\n            beast::bind_front_handler(&Impl::doClose, shared_from_this()));\n    }\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 151,
    "wrong_result": "#include <boost/beast/core.hpp>\n#include <boost/beast/ssl.hpp>\n#include <boost/beast/websocket.hpp>\n#include <boost/beast/websocket/ssl.hpp>\n#include <boost/asio/strand.hpp>\n#include <memory>\n#include <optional>\n#include <string>\n\nnamespace beast = boost::beast;\nnamespace http = beast::http;\nnamespace websocket = beast::websocket;\nnamespace net = boost::asio;\nnamespace ssl = boost::asio::ssl;\nusing tcp = boost::asio::ip::tcp;\n\nstruct Device {\n    std::string host;\n    std::string port;\n    bool use_ssl;\n};\n\nstruct Logging {\n    void log(const std::string&) {}\n};\n\nstruct Work {\n    std::string data;\n    std::string type;\n};\n\nclass WebOsClient::Impl {\npublic:\n    Impl(net::io_context& ioc, ssl::context& ctx, Device& device_settings, std::shared_ptr<Logging> log)\n        : ioc_(ioc), ctx_(ctx), device_settings_(device_settings), log_(log), resolver_(net::make_strand(ioc)) {\n        host_ = device_settings.host + \":\" + device_settings.port;\n        socket_status_ = 0;\n    }\n\n    void run() {\n        resolver_.async_resolve(device_settings_.host, device_settings_.port,\n            beast::bind_front_handler(&Impl::onResolve, this));\n    }\n\n    void onResolve(beast::error_code ec, tcp::resolver::results_type results) {\n        if (ec) return onError(ec, \"resolve\");\n        if (device_settings_.use_ssl) {\n            ws_.emplace(net::make_strand(ioc_), ctx_);\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::seconds(30));\n            beast::get_lowest_layer(*ws_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, this));\n        } else {\n            ws_tcp_.emplace(net::make_strand(ioc_));\n            beast::get_lowest_layer(*ws_tcp_).expires_after(std::chrono::seconds(30));\n            beast::get_lowest_layer(*ws_tcp_).async_connect(results,\n                beast::bind_front_handler(&Impl::onConnect, this));\n        }\n    }\n\n    void onConnect(beast::error_code ec, tcp::resolver::results_type::endpoint_type ep) {\n        if (ec) return onError(ec, \"connect\");\n        if (device_settings_.use_ssl) {\n            beast::get_lowest_layer(*ws_).expires_after(std::chrono::seconds(30));\n            if (!SSL_set_tlsext_host_name(ws_->next_layer().native_handle(), device_settings_.host.c_str())) {\n                ec = beast::error_code(static_cast<int>(::ERR_get_error()), net::error::get_ssl_category());\n                return onError(ec, \"SSL_set_tlsext_host_name\");\n            }\n            ws_->next_layer().async_handshake(ssl::stream_base::client,\n                beast::bind_front_handler(&Impl::onSSLhandshake, this));\n        } else {\n            beast::get_lowest_layer(*ws_tcp_).expires_never();\n            ws_tcp_->async_handshake(device_settings_.host, \"/\",\n                beast::bind_front_handler(&Impl::onWinsockHandshake, this));\n        }\n    }\n\n    void onSSLhandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"SSL handshake\");\n        beast::get_lowest_layer(*ws_).expires_never();\n        ws_->async_handshake(device_settings_.host, \"/\",\n            beast::bind_front_handler(&Impl::onWinsockHandshake, this));\n    }\n\n    void onWinsockHandshake(beast::error_code ec) {\n        if (ec) return onError(ec, \"WebSocket handshake\");\n        socket_status_ = 1;\n        read();\n    }\n\n    void send(std::string data, std::string type) {\n        Work work{data, type};\n        enqueueWork(work);\n    }\n\n    void onWrite(beast::error_code ec, std::size_t bytes_transferred) {\n        if (ec) return onError(ec, \"write\");\n    }\n\n    void read() {\n        if (device_settings_.use_ssl) {\n            ws_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, this));\n        } else {\n            ws_tcp_->async_read(buffer_,\n                beast::bind_front_handler(&Impl::onRead, this));\n        }\n    }\n\n    void onRead(beast::error_code ec, std::size_t bytes_transferred) {\n        if (ec) return onError(ec, \"read\");\n        buffer_.consume(bytes_transferred);\n        read();\n    }\n\n    void onError(beast::error_code& ec, std::string what) {\n        log_->log(\"WebSocket error: \" + what + \": \" + ec.message());\n        close();\n    }\n\n    void enqueueWork(Work& work) {\n        net::post(ioc_, [this, work]() {\n            if (device_settings_.use_ssl) {\n                ws_->async_write(net::buffer(work.data),\n                    beast::bind_front_handler(&Impl::onWrite, this));\n            } else {\n                ws_tcp_->async_write(net::buffer(work.data),\n                    beast::bind_front_handler(&Impl::onWrite, this));\n            }\n        });\n    }\n\n    void close() {\n        socket_status_ = 0;\n        beast::error_code ec;\n        if (device_settings_.use_ssl) {\n            ws_->close(websocket::close_code::normal, ec);\n        } else {\n            ws_tcp_->close(websocket::close_code::normal, ec);\n        }\n        if (ec) onError(ec, \"close\");\n    }\n\nprivate:\n    net::io_context& ioc_;\n    ssl::context& ctx_;\n    Device device_settings_;\n    std::shared_ptr<Logging> log_;\n    tcp::resolver resolver_;\n    std::optional<websocket::stream<beast::ssl_stream<beast::tcp_stream>>> ws_;\n    std::optional<websocket::stream<beast::tcp_stream>> ws_tcp_;\n    beast::flat_buffer buffer_;\n    std::string host_;\n    int socket_status_;\n};"
  }
]