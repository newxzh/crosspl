[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that makes an HTTP request using the 'request' module in JavaScript and handles the response via a callback.\n\nFunction Description: The function 'makeHttpRequest' is designed to simplify making HTTP requests by wrapping the 'request' module's functionality. It takes an options object and a callback function, makes the HTTP request, and invokes the callback with the response body if the request is successful (status code 200 and no errors).\n\nInput:  \n- options: [Object] - Configuration object for the HTTP request, including properties like URL, headers, and data.  \n- callback: [Function] - A function to be called with the response body upon successful request completion.  \n\nOutput:  \n- None (The result is handled asynchronously via the callback function).",
    "Canonical_solution": "var request = require('request');\n\nfunction makeHttpRequest(options, callback) {\n    request(options, function(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            callback(body);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "matched_results": [
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(body);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(body);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}",
      "const request = require('request');\nfunction makeHttpRequest(options, callback) {\n  request(options, (error, response, body) => {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport hashlib\nimport hmac\nimport requests\nimport time\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        timestamp = int(time.time())\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['currency'] = self.currency\n        params['pair'] = self.pair\n        params['name'] = self.name\n        params['timestamp'] = timestamp\n        params['sign'] = self.generate_sign(params)\n        url = f'https://api.exmo.com/v2/{method}'\n        response = requests.post(url, data=params)\n        callback(response.json(), None)\n\n    def generate_sign(self, params):\n        sorted_params = sorted(params.items())\n        query_string = '&'.join(f\"{key}={value}\" for key, value in sorted_params)\n        sign = hmac.new(self.secret.encode(), query_string.encode(), hashlib.sha512).hexdigest()\n        return sign\n```",
      "```python\nimport hashlib\nimport hmac\nimport requests\nimport time\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['pair'] = self.pair\n        params['name'] = self.name\n        params['currency'] = self.currency\n        params['asset'] = self.asset\n        params['signature'] = self.generate_signature(params)\n        response = requests.post('https://api.exmo.com/v2', data=params)\n        callback(response.json())\n    \n    def generate_signature(self, params):\n        sorted_params = sorted(params.items())\n        query_string = '&'.join(f\"{key}={value}\" for key, value in sorted_params)\n        signature = hmac.new(self.secret.encode(), query_string.encode(), hashlib.sha512).hexdigest()\n        return signature\n```",
      "```python\nimport hashlib\nimport hmac\nimport json\nimport requests\nimport time\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        timestamp = int(time.time())\n        params.update({\n            'method': method,\n            'nonce': self.nonce,\n            'key': self.key,\n            'timestamp': timestamp\n        })\n        params['signature'] = self.generate_signature(params)\n        response = requests.post('https://api.exmo.com/v2', data=params)\n        callback(response.json(), None)\n\n    def generate_signature(self, params):\n        sorted_params = sorted(params.items())\n        query_string = '&'.join(f'{k}={v}' for k, v in sorted_params)\n        signature = hmac.new(self.secret.encode(), query_string.encode(), hashlib.sha512).hexdigest()\n        return signature\n```",
      "```python\nimport hashlib\nimport hmac\nimport requests\nimport time\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['pair'] = self.pair\n        params['name'] = self.name\n        params['currency'] = self.currency\n        params['asset'] = self.asset\n        params['signature'] = self.generate_signature(params)\n        response = requests.post('https://api.exmo.com/v2', data=params)\n        callback(response.json())\n        \n    def generate_signature(self, params):\n        sorted_params = sorted(params.items())\n        query_string = '&'.join(f\"{key}={value}\" for key, value in sorted_params)\n        signature = hmac.new(self.secret.encode(), query_string.encode(), hashlib.sha512).hexdigest()\n        return signature\n```",
      "```python\nimport hashlib\nimport hmac\nimport requests\nimport time\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        timestamp = int(time.time())\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['currency'] = self.currency\n        params['pair'] = self.pair\n        params['name'] = self.name\n        params['timestamp'] = timestamp\n        params['sign'] = self.generate_sign(params)\n        url = f\"https://api.exmo.com/v2/{method}\"\n        response = requests.post(url, data=params)\n        callback(response.json(), None)\n\n    def generate_sign(self, params):\n        sorted_params = sorted(params.items())\n        query_string = '&'.join(f\"{key}={value}\" for key, value in sorted_params)\n        sign = hmac.new(self.secret.encode(), query_string.encode(), hashlib.sha512).hexdigest()\n        return sign\n```",
      "```python\nimport hashlib\nimport hmac\nimport requests\nimport time\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['pair'] = self.pair\n        params['name'] = self.name\n        params['currency'] = self.currency\n        params['asset'] = self.asset\n        params['request'] = params\n        params['sign'] = self.sign(params)\n        response = requests.post('https://api.exmo.com/v2', data=params)\n        callback(response.json())\n        \n    def sign(self, params):\n        params_str = '&'.join(f'{k}={params[k]}' for k in sorted(params))\n        return hmac.new(self.secret.encode(), params_str.encode(), hashlib.sha512).hexdigest()\n```",
      "```python\nimport hashlib\nimport hmac\nimport requests\nimport time\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['pair'] = self.pair\n        params['name'] = self.name\n        params['currency'] = self.currency\n        params['asset'] = self.asset\n        params['request'] = params\n        params['signature'] = self.sign(params)\n        response = requests.post('https://api.exmo.com/v2/', data=params)\n        callback(response.json(), None)\n\n    def sign(self, params):\n        params_str = '&'.join(f'{k}={params[k]}' for k in sorted(params))\n        return hmac.new(self.secret.encode(), params_str.encode(), hashlib.sha512).hexdigest()\n```",
      "```python\nimport hashlib\nimport hmac\nimport requests\nimport time\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['pair'] = self.pair\n        params['name'] = self.name\n        params['currency'] = self.currency\n        params['asset'] = self.asset\n        params['signature'] = self.generate_signature(params)\n        response = requests.post('https://api.exmo.com/v2', data=params)\n        callback(response.json())\n        \n    def generate_signature(self, params):\n        sorted_params = sorted(params.items())\n        query_string = '&'.join(f\"{key}={value}\" for key, value in sorted_params)\n        signature = hmac.new(self.secret.encode(), query_string.encode(), hashlib.sha512).hexdigest()\n        return signature\n```",
      "```python\nimport hashlib\nimport hmac\nimport time\nimport requests\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        timestamp = int(time.time())\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['currency'] = self.currency\n        params['pair'] = self.pair\n        params['name'] = self.name\n        params['timestamp'] = timestamp\n        params['sign'] = self.generate_sign(params)\n        url = f\"https://{self.name}.com/api/v2/{method}\"\n        response = requests.post(url, data=params)\n        callback(response.json(), None)\n\n    def generate_sign(self, params):\n        sorted_params = sorted(params.items())\n        query_string = '&'.join(f\"{key}={value}\" for key, value in sorted_params)\n        signature = hmac.new(self.secret.encode(), query_string.encode(), hashlib.sha512).hexdigest()\n        return signature\n```",
      "```python\nimport hashlib\nimport hmac\nimport requests\nimport time\nimport json\n\nclass Trader:\n    def __init__(self, config):\n        self.key = config['key']\n        self.secret = config['secret']\n        self.currency = config['currency']\n        self.asset = config['asset']\n        self.pair = f\"{self.asset}_{self.currency}\"\n        self.name = 'EXMO'\n        self.nonce = 0\n\n    def api_query(self, method, params, callback):\n        self.nonce += 1\n        timestamp = int(time.time())\n        params['nonce'] = self.nonce\n        params['key'] = self.key\n        params['method'] = method\n        params['timestamp'] = timestamp\n        params['pair'] = self.pair\n        params['name'] = self.name\n\n        params['signature'] = self.sign(params)\n        url = 'https://api.exmo.com/v2/'\n        response = requests.post(url, data=params)\n        callback(None, json.loads(response.text))\n        return\n\n    def sign(self, params):\n        params_str = '&'.join(f'{k}={params[k]}' for k in sorted(params))\n        signature = hmac.new(self.secret.encode(), params_str.encode(), hashlib.sha512).hexdigest()\n        return signature\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create a function that sets up an Express server with various route handlers for handling HTTP requests related to email functionality, including authentication, sending test emails, and managing email server configurations.\n\nFunction Description: The function `setupExpressServer` initializes an Express server with middleware for parsing request bodies and cookies. It defines several route handlers for different HTTP methods (GET, POST) that handle email-related operations such as authentication, sending test emails, and saving email server configurations. The server listens on a specified port.\n\nInput: None (The function uses module-level variables like `processInfo.port` for configuration)\n\nOutput: None (The function starts a server that listens on the specified port and handles incoming HTTP requests)\n\nNote: The function relies on several external modules and variables that should be available in the scope:\n- `express`: The Express framework\n- `connect`: Middleware for Express\n- `fs`: File system module\n- `nodemailer`: For sending emails\n- `lcrypto`: For encryption\n- `lutil`: For file operations\n- `auth`: A variable storing authentication details\n- `processInfo`: An object containing server configuration (like port number)\n- `locker`: An object containing base URL for locker service\n- `request`: For making HTTP requests",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var connect = require('connect');\n    var app = express.createServer(connect.bodyParser(), connect.cookieParser());\n    \n    app.set('views', __dirname);\n    \n    app.get('/', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!auth || req.param(\"change\")) return res.end(fs.readFileSync(__dirname + '/auth.html'));\n        res.write(\"<p>Using \"+auth.host+\":\"+auth.port+\" \");\n        if(auth.ssl) res.write(\"(ssl)\");\n        if(auth.user) res.write(\"authenticating as \"+auth.user);\n        res.write(\"<br><a href='?change=1'>change</a> or <a href='javascript:window.location=\\\"test?to=\\\"+window.prompt(\\\"recipient email address\\\")'>send test message</a>\");\n        res.end();\n    });\n    \n    app.post('/save', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!req.body || !req.body.host || !req.body.port) return res.end(\"missing minimum required host/port :(\");\n        nodemailer.SMTP = auth = {host:req.body.host, port:req.body.port, ssl:false};\n        if(req.body.ssl) auth.ssl = true;\n        if(req.body.user && req.body.pass) {\n            auth.use_authentication = true;\n            auth.user = req.body.user;\n            auth.pass = lcrypto.encrypt(req.body.pass);\n        }\n        lutil.atomicWriteFileSync(\"auth.json\", JSON.stringify(auth, null, 4));\n        if(auth.pass) auth.pass = req.body.pass;\n        res.end(\"saved! <a href='./'>continue</a>\");\n    });\n    \n    app.get('/state', function (req, res) {\n        var ready = (auth) ? 1 : 0;\n        res.send({ready:ready});\n    });\n    \n    app.get('/test', function (req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!req.param(\"to\") || req.param(\"to\").indexOf(\"@\") <= 0) return res.end(\"invalid recipient\")\n        var message = {\n            sender: 'Testificate <42@awesome.com>',\n            to: req.param(\"to\"),\n            subject: 'test message  âœ”',\n            body: 'Hello to you!',\n            html:'<p>it <b>WORKED</b></p>',\n            debug: true\n        };\n        request.post({url:locker.lockerBase + \"/Me/smtp/send\", json:message}, function(err, r, body){\n            if(err || !body) return res.end(\"failed \"+err);\n            return res.end(\"sent!\");\n        });\n    });\n    \n    app.post('/send', function (req, res) {\n        if(!auth) return res.send(false);\n        if (!req.body || !req.body.to) return res.send(false);\n        console.error(\"DEBUG SMTP: \"+JSON.stringify(req.body));\n        var sent = false;\n        nodemailer.send_mail(req.body, function(err, ok){\n            if(sent) return;\n            sent=true;\n            if(err || !ok){\n                console.error('Error occured: '+err);\n                return res.send(false);\n            }\n            res.send(true);\n        })\n    });\n    \n    app.listen(processInfo.port,function() {\n        var returnedInfo = {};\n        console.log(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst crypto = require('crypto');\nconst util = require('util');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\napp.get('/email/auth', (req, res) => {\n  const token = req.cookies.authToken;\n  if (token && auth.validateToken(token)) {\n    res.send('Authenticated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.post('/email/test', (req, res) => {\n  const transporter = nodemailer.createTransport({\n    host: processInfo.emailConfig.host,\n    port: processInfo.emailConfig.port,\n    secure: processInfo.emailConfig.secure,\n    auth: {\n      user: processInfo.emailConfig.user,\n      pass: processInfo.emailConfig.pass\n    }\n  });\n\n  const mailOptions = {\n    from: processInfo.emailConfig.user,\n    to: req.body.to,\n    subject: 'Test Email',\n    text: 'This is a test email sent from the server.'\n  };\n\n  transporter.sendMail(mailOptions, (error, info) => {\n    if (error) {\n      res.status(500).send(error);\n    } else {\n      res.send('Test email sent: ' + info.response);\n    }\n  });\n});\n\napp.post('/email/config', (req, res) => {\n  const config = req.body;\n  fs.writeFileSync('emailConfig.json', JSON.stringify(config));\n  res.send('Email configuration saved');\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "```javascript\nconst express = require('express');\nconst connect = require('connect');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst lcrypto = require('crypto');\nconst lutil = require('lutil');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/email/auth', (req, res) => {\n  // Authentication logic\n});\n\napp.post('/email/test', (req, res) => {\n  // Test email sending logic\n});\n\napp.post('/email/config', (req, res) => {\n  // Email server configuration logic\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});\n```",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst lcrypto = require('crypto');\nconst lutil = require('lutil');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\napp.get('/authenticate', (req, res) => {\n  const token = req.cookies.authToken;\n  if (token && auth.validateToken(token)) {\n    res.status(200).send('Authenticated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.post('/sendTestEmail', (req, res) => {\n  const transporter = nodemailer.createTransport({\n    host: processInfo.emailConfig.host,\n    port: processInfo.emailConfig.port,\n    secure: processInfo.emailConfig.secure,\n    auth: {\n      user: processInfo.emailConfig.user,\n      pass: processInfo.emailConfig.pass\n    }\n  });\n\n  const mailOptions = {\n    from: processInfo.emailConfig.user,\n    to: req.body.to,\n    subject: 'Test Email',\n    text: 'This is a test email sent from the server.'\n  };\n\n  transporter.sendMail(mailOptions, (error, info) => {\n    if (error) {\n      return res.status(500).send(error);\n    }\n    res.status(200).send('Test email sent: ' + info.response);\n  });\n});\n\napp.post('/saveEmailConfig', (req, res) => {\n  const config = req.body;\n  fs.writeFileSync('emailConfig.json', JSON.stringify(config, null, 2));\n  res.status(200).send('Email configuration saved');\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst crypto = require('crypto');\nconst util = require('util');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\napp.get('/email/auth', (req, res) => {\n  const token = req.cookies.authToken;\n  if (auth.validateToken(token)) {\n    res.send('Authenticated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.post('/email/test', (req, res) => {\n  const transporter = nodemailer.createTransport({\n    host: processInfo.emailConfig.host,\n    port: processInfo.emailConfig.port,\n    secure: processInfo.emailConfig.secure,\n    auth: {\n      user: processInfo.emailConfig.user,\n      pass: processInfo.emailConfig.pass\n    }\n  });\n\n  const mailOptions = {\n    from: processInfo.emailConfig.user,\n    to: req.body.to,\n    subject: 'Test Email',\n    text: 'This is a test email sent from the server.'\n  };\n\n  transporter.sendMail(mailOptions, (error, info) => {\n    if (error) {\n      res.status(500).send(error);\n    } else {\n      res.send('Test email sent: ' + info.response);\n    }\n  });\n});\n\napp.post('/email/config', (req, res) => {\n  const config = req.body;\n  fs.writeFileSync('emailConfig.json', JSON.stringify(config, null, 2));\n  res.send('Email configuration saved');\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst crypto = require('crypto');\nconst util = require('util');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\napp.get('/email/auth', (req, res) => {\n  const token = req.cookies.authToken;\n  if (auth.validateToken(token)) {\n    res.send('Authenticated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.post('/email/test', (req, res) => {\n  const transporter = nodemailer.createTransport({\n    host: processInfo.emailConfig.host,\n    port: processInfo.emailConfig.port,\n    secure: processInfo.emailConfig.secure,\n    auth: {\n      user: processInfo.emailConfig.user,\n      pass: processInfo.emailConfig.pass\n    }\n  });\n\n  const mailOptions = {\n    from: processInfo.emailConfig.user,\n    to: req.body.to,\n    subject: 'Test Email',\n    text: 'This is a test email.'\n  };\n\n  transporter.sendMail(mailOptions, (error, info) => {\n    if (error) {\n      res.status(500).send(error);\n    } else {\n      res.send('Test email sent: ' + info.response);\n    }\n  });\n});\n\napp.post('/email/config', (req, res) => {\n  const config = req.body;\n  fs.writeFileSync('emailConfig.json', JSON.stringify(config));\n  res.send('Email configuration saved');\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst lcrypto = require('crypto');\nconst lutil = require('lutil');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\napp.get('/email/auth', (req, res) => {\n  const token = req.cookies.authToken;\n  if (token && auth.validateToken(token)) {\n    res.send('Authenticated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.post('/email/test', (req, res) => {\n  const transporter = nodemailer.createTransport({\n    host: processInfo.emailConfig.host,\n    port: processInfo.emailConfig.port,\n    secure: processInfo.emailConfig.secure,\n    auth: {\n      user: processInfo.emailConfig.user,\n      pass: processInfo.emailConfig.pass\n    }\n  });\n\n  const mailOptions = {\n    from: processInfo.emailConfig.user,\n    to: req.body.to,\n    subject: 'Test Email',\n    text: 'This is a test email sent from the server.'\n  };\n\n  transporter.sendMail(mailOptions, (error, info) => {\n    if (error) {\n      res.status(500).send(error);\n    } else {\n      res.send('Test email sent: ' + info.response);\n    }\n  });\n});\n\napp.post('/email/config', (req, res) => {\n  const config = req.body;\n  fs.writeFileSync('emailConfig.json', JSON.stringify(config));\n  res.send('Email configuration saved');\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst crypto = require('crypto');\nconst util = require('util');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\napp.get('/email/auth', (req, res) => {\n  const token = req.cookies.authToken;\n  if (auth.validateToken(token)) {\n    res.send('Authentication successful');\n  } else {\n    res.status(401).send('Authentication failed');\n  }\n});\n\napp.post('/email/test', (req, res) => {\n  const transporter = nodemailer.createTransport({\n    host: processInfo.emailConfig.host,\n    port: processInfo.emailConfig.port,\n    secure: processInfo.emailConfig.secure,\n    auth: {\n      user: processInfo.emailConfig.user,\n      pass: processInfo.emailConfig.pass\n    }\n  });\n\n  const mailOptions = {\n    from: processInfo.emailConfig.user,\n    to: req.body.to,\n    subject: 'Test Email',\n    text: 'This is a test email'\n  };\n\n  transporter.sendMail(mailOptions, (error, info) => {\n    if (error) {\n      res.status(500).send(error);\n    } else {\n      res.send('Test email sent: ' + info.response);\n    }\n  });\n});\n\napp.post('/email/config', (req, res) => {\n  const config = req.body;\n  fs.writeFileSync('emailConfig.json', JSON.stringify(config));\n  res.send('Email configuration saved');\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst crypto = require('crypto');\nconst util = require('util');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\napp.get('/email/auth', (req, res) => {\n  const token = req.cookies.authToken;\n  if (token && auth.validateToken(token)) {\n    res.send('Authenticated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.post('/email/test', (req, res) => {\n  const transporter = nodemailer.createTransport({\n    host: processInfo.emailConfig.host,\n    port: processInfo.emailConfig.port,\n    secure: processInfo.emailConfig.secure,\n    auth: {\n      user: processInfo.emailConfig.user,\n      pass: processInfo.emailConfig.pass\n    }\n  });\n\n  const mailOptions = {\n    from: processInfo.emailConfig.user,\n    to: processInfo.emailConfig.testRecipient,\n    subject: 'Test Email',\n    text: 'This is a test email sent from the server.'\n  };\n\n  transporter.sendMail(mailOptions, (error, info) => {\n    if (error) {\n      res.status(500).send(error);\n    } else {\n      res.send('Test email sent: ' + info.response);\n    }\n  });\n});\n\napp.post('/email/config', (req, res) => {\n  const newConfig = req.body;\n  fs.writeFileSync('emailConfig.json', JSON.stringify(newConfig, null, 2));\n  res.send('Email configuration saved');\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "```javascript\nconst express = require('express');\nconst connect = require('connect');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst lcrypto = require('crypto');\nconst lutil = require('lutil');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/email/auth', (req, res) => {\n  // Authentication logic\n});\n\napp.post('/email/test', (req, res) => {\n  // Test email sending logic\n});\n\napp.post('/email/config', (req, res) => {\n  // Email server configuration logic\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});\n```",
      "const express = require('express');\nconst connect = require('connect');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\nconst lcrypto = require('lcrypto');\nconst lutil = require('lutil');\nconst auth = require('./auth');\nconst processInfo = require('./processInfo');\nconst locker = require('./locker');\nconst request = require('request');\n\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/email/auth', (req, res) => {\n  // Authentication logic\n});\n\napp.post('/email/test', (req, res) => {\n  // Test email sending logic\n});\n\napp.post('/email/config', (req, res) => {\n  // Email server configuration logic\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a class that implements an Express HTTP server with middleware configuration, route definitions, and server startup functionality.\n\nClass Description: The ExpressServer class encapsulates the creation and management of an Express.js web server. It handles server configuration, middleware setup, route definitions, and server startup. The class is designed to be modular, allowing for easy extension of middleware and routes.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number on which the server will listen, either from environment variables or defaulting to 3000\n\nMethods:\n- constructor() -> [void] - Initializes the Express application and sets the default port\n- configureMiddleware() -> [void] - Configures essential middleware including static file serving and body parsing\n- defineRoutes() -> [void] - Defines route handlers for various HTTP methods and paths including GET and POST requests\n- startServer() -> [void] - Starts the HTTP server and begins listening on the specified port\n\nMethods Details:\n- configureMiddleware(): \n  - Adds express.static middleware to serve static files from the 'public' directory\n  - Adds body-parser middleware for parsing request bodies\n  - No input parameters\n  - No return value\n\n- defineRoutes():\n  - Defines a GET route for the home page ('/')\n  - Defines a GET route for the about page ('/about') with dynamic content\n  - Defines a POST route for newsletter signup ('/newsletter') with validation logic\n  - No input parameters\n  - No return value\n\n- startServer():\n  - Starts the server listening on the configured port\n  - Logs server startup information to the console\n  - No input parameters\n  - No return value",
    "Canonical_solution": "var express = require('express');\n\nclass ExpressServer {\n    constructor() {\n        this.app = express();\n        this.port = process.env.PORT || 3000;\n    }\n\n    configureMiddleware() {\n        this.app.use(express.static(__dirname + '/public'));\n        this.app.use(require('body-parser')());\n    }\n\n    defineRoutes() {\n        this.app.get('/', function(req, res) {\n            res.render('home');\n        });\n        \n        this.app.get('/about', function(req,res){\n            res.render('about', { \n                fortune: fortune.getFortune(),\n                pageTestScript: '/qa/tests-about.js' \n            });\n        });\n\n        this.app.post('/newsletter', function(req, res){\n            var name = req.body.name || '', email = req.body.email || '';\n            if(!email.match(VALID_EMAIL_REGEX)) {\n                if(req.xhr) return res.json({ error: 'Invalid name email address.' });\n                req.session.flash = {\n                    type: 'danger',\n                    intro: 'Validation error!',\n                    message: 'The email address you entered was  not valid.',\n                };\n                return res.redirect(303, '/newsletter/archive');\n            }\n            new NewsletterSignup({ name: name, email: email }).save(function(err){\n                if(err) {\n                    if(req.xhr) return res.json({ error: 'Database error.' });\n                    req.session.flash = {\n                        type: 'danger',\n                        intro: 'Database error!',\n                        message: 'There was a database error; please try again later.',\n                    };\n                    return res.redirect(303, '/newsletter/archive');\n                }\n                if(req.xhr) return res.json({ success: true });\n                req.session.flash = {\n                    type: 'success',\n                    intro: 'Thank you!',\n                    message: 'You have now been signed up for the newsletter.',\n                };\n                return res.redirect(303, '/newsletter/archive');\n            });\n        });\n    }\n\n    startServer() {\n        this.app.listen(this.port, function(){\n            console.log('Express started on http://localhost:' + this.port + '; press Ctrl-C to terminate.');\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Invalid email');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Email is required');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Invalid email');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Email is required');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Email is required');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on http://localhost:${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Email is required');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Email is required');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Email is required');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Email is required');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nclass ExpressServer {\n  constructor() {\n    this.app = express();\n    this.port = process.env.PORT || 3000;\n  }\n\n  configureMiddleware() {\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n  }\n\n  defineRoutes() {\n    this.app.get('/', (req, res) => {\n      res.send('Home Page');\n    });\n\n    this.app.get('/about', (req, res) => {\n      res.send('About Page');\n    });\n\n    this.app.post('/newsletter', (req, res) => {\n      const { email } = req.body;\n      if (email) {\n        res.send('Newsletter signed up');\n      } else {\n        res.status(400).send('Invalid email');\n      }\n    });\n  }\n\n  startServer() {\n    this.app.listen(this.port, () => {\n      console.log(`Server is running on http://localhost:${this.port}`);\n    });\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create a function that sets up an Express server with specific route handlers and middleware to demonstrate various aspects of request handling, error processing, and route termination in Express.js.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures middleware and route handlers to illustrate different scenarios in HTTP request processing including:\n- Basic middleware execution\n- Route termination\n- Error handling middleware\n- Unhandled routes\nThe server listens on port 3000 and logs various events to the console during operation.\n\nInput: None\n\nOutput: None (The function's effect is creating and starting an Express server that listens on port 3000)",
    "Canonical_solution": "function setupExpressServer() {\n    var app = require('express')();\n\n    app.use(function(req, res, next){ \n        console.log('\\n\\nALLWAYS');\n        next(); \n    });\n\n    app.get('/a', function(req, res){ \n        console.log('/a: route terminated'); \n        res.send('a'); \n    });\n    app.get('/a', function(req, res){ \n        console.log('/a: never called'); \n    });\n    app.get('/b', function(req, res, next){ \n        console.log('/b: route not terminated');\n        next();\n    });\n    app.use(function(req, res, next){\n        console.log('SOMETIMES');\n        next();\n    });\n    app.get('/b', function(req, res, next){\n        console.log('/b (part 2): error thrown' );\n        throw new Error('b failed');\n    });\n    app.use('/b', function(err, req, res, next){\n        console.log('/b error detected and passed on');\n        next(err);\n    });\n    app.get('/c', function(err, req){\n        console.log('/c: error thrown');\n        throw new Error('c failed');\n    });\n    app.use('/c', function(err, req, res, next){\n        console.log('/c: error deteccted but not passed on');\n        next();\n    });\n\n    app.use(function(err, req, res, next){\n        console.log('unhandled error detected: ' + err.message);\n        res.send('500 - server error');\n    });\n\n    app.use(function(req, res){\n        console.log('route not handled');\n        res.send('404 - not found');\n    });\n\n    app.listen(3000, function(){ \n        console.log('listening on 3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test');\n  res.send('Test route');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Route termination middleware');\n  res.status(204).end();\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware:', err);\n  res.status(500).send('Internal Server Error');\n});\n\napp.use((req, res, next) => {\n  console.log('Unhandled route');\n  res.status(404).send('Not Found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test executed');\n  res.send('Test route');\n  next();\n});\n\napp.get('/test', (req, res) => {\n  console.log('Route termination in /test handler');\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware executed');\n  res.status(500).send('Internal Server Error');\n});\n\napp.use((req, res, next) => {\n  console.log('Unhandled route');\n  res.status(404).send('Not Found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test');\n  res.send('Test route');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Second middleware executed');\n  res.status(404).send('Route not found');\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware:', err);\n  res.status(500).send('Internal Server Error');\n});\n\napp.get('*', (req, res, next) => {\n  console.log('Unhandled route');\n  res.status(404).send('Page not found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test');\n  res.send('Test route');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Route termination middleware executed');\n  res.status(204).end();\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware executed');\n  res.status(500).send('Internal Server Error');\n});\n\napp.use((req, res, next) => {\n  console.log('Unhandled route middleware executed');\n  res.status(404).send('Not Found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test');\n  res.send('Test route');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Second middleware executed');\n  res.status(404).send('Route not found');\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware:', err);\n  res.status(500).send('Internal Server Error');\n});\n\napp.get('*', (req, res, next) => {\n  console.log('Unhandled route');\n  res.status(404).send('Page not found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test executed');\n  res.send('Test route');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Second middleware executed');\n  res.status(404).send('Route not found');\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware executed');\n  res.status(500).send('Internal Server Error');\n});\n\napp.get('*', (req, res, next) => {\n  console.log('Unhandled route handler executed');\n  res.status(404).send('Page not found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test');\n  res.send('Test route');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Route termination middleware executed');\n  res.status(204).end();\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware executed');\n  res.status(500).send('Internal Server Error');\n});\n\napp.use((req, res, next) => {\n  console.log('Unhandled route middleware executed');\n  res.status(404).send('Not Found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test');\n  res.send('Test route');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Route termination middleware executed');\n  res.status(204).end();\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware executed');\n  res.status(500).send('Internal Server Error');\n});\n\napp.use((req, res, next) => {\n  console.log('Unhandled route middleware executed');\n  res.status(404).send('Not Found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test');\n  res.send('Test route');\n  next();\n});\n\napp.get('/test', (req, res) => {\n  console.log('Route termination in /test');\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware:', err);\n  res.status(500).send('Something broke!');\n});\n\napp.use((req, res, next) => {\n  console.log('Unhandled route');\n  res.status(404).send('Route not found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('Basic middleware executed');\n  next();\n});\n\napp.get('/test', (req, res, next) => {\n  console.log('Route handler for /test executed');\n  res.send('Test route');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Second middleware executed');\n  res.status(404).send('Route not found');\n});\n\napp.use((err, req, res, next) => {\n  console.error('Error handling middleware executed');\n  res.status(500).send('Internal Server Error');\n});\n\napp.get('*', (req, res, next) => {\n  console.log('Unhandled route handler executed');\n  res.status(404).send('Page not found');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Implement a function to set up an Express server that demonstrates different methods of file handling (streaming vs non-streaming) for serving large files, with performance monitoring capabilities.\n\nFunction Description: The function `setupExpressServer` creates an Express.js server that serves a large image file through four different endpoints, comparing streaming and non-streaming approaches. It includes response time monitoring middleware to measure performance. The server listens on port 3000 by default.\n\nInput: None (The function takes no parameters. All paths and configurations are internally defined.)\n\nOutput: None (The function doesn't return anything but starts an Express server that continues running until manually stopped.)\n\nNote: The function internally uses:\n1. Express framework for HTTP server\n2. Node.js filesystem module for file operations\n3. Path module for file path resolution\n4. response-time middleware for performance monitoring\n5. Predefined port (3000) and image path (CapitalOne_Digital_Skills_Infographic_BW.jpg in same directory)",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var fs = require('fs');\n    var path = require('path');\n    var port = 3000;\n    var app = express();\n    var responseTime = require('response-time');\n    var largeImagePath = path.join(__dirname,'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\n    app.use(responseTime());\n\n    app.get('/non-stream', function(req, res) {\n        var file = fs.readFile(largeImagePath, function(error, data){\n            res.end(data);\n        });\n    });\n\n    app.get('/non-stream2', function(req, res) {\n        var file = fs.readFileSync(largeImagePath);\n        res.end(file);\n    });\n\n    app.get('/stream', function(req, res) {\n        var stream = fs.createReadStream(largeImagePath);\n        stream.pipe(res);\n    });\n\n    app.get('/stream2', function(req, res) {\n        var stream = fs.createReadStream(largeImagePath);\n        stream.on('data', function(data) {\n            res.write(data);\n        });\n        stream.on('end', function() {\n            res.end();\n        });\n    });\n\n    app.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\nconst app = express();\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/stream', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  fileStream.pipe(res);\n});\n\napp.get('/buffer', (req, res) => {\n  fs.readFile(imagePath, (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading file');\n      return;\n    }\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(data);\n  });\n});\n\napp.get('/buffer-array', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  let chunks = [];\n  fileStream.on('data', (chunk) => {\n    chunks.push(chunk);\n  });\n  fileStream.on('end', () => {\n    const data = Buffer.concat(chunks);\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(data);\n  });\n});\n\napp.get('/stream-array', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  let chunks = [];\n  fileStream.on('data', (chunk) => {\n    chunks.push(chunk);\n  });\n  fileStream.on('end', () => {\n    const data = Buffer.concat(chunks);\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(data);\n  });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\n\nconst app = express();\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/stream', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  stream.pipe(res);\n});\n\napp.get('/non-stream', (req, res) => {\n  const file = fs.readFileSync(imagePath);\n  res.send(file);\n});\n\napp.get('/stream-arraybuffer', (req, res) => {\n  fs.readFile(imagePath, (err, data) => {\n    if (err) {\n      res.status(500).send(err);\n      return;\n    }\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(data);\n  });\n});\n\napp.get('/stream-buffer', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  let chunks = [];\n\n  fileStream.on('data', (chunk) => {\n    chunks.push(chunk);\n  });\n\n  fileStream.on('end', () => {\n    let buffer = Buffer.concat(chunks);\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(buffer);\n  });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\n\nconst app = express();\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/stream', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  stream.pipe(res);\n});\n\napp.get('/non-stream', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  res.send(fileData);\n});\n\napp.get('/stream-arraybuffer', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  const chunks = [];\n  stream.on('data', chunk => chunks.push(chunk));\n  stream.on('end', () => {\n    const buffer = Buffer.concat(chunks);\n    res.send(buffer);\n  });\n});\n\napp.get('/stream-arraybuffer-async', async (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  const chunks = [];\n  for await (const chunk of stream) {\n    chunks.push(chunk);\n  }\n  const buffer = Buffer.concat(chunks);\n  res.send(buffer);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\n\nconst app = express();\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/stream', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  stream.pipe(res);\n});\n\napp.get('/buffer', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  res.send(fileData);\n});\n\napp.get('/stream-arraybuffer', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  const chunks = [];\n  stream.on('data', (chunk) => chunks.push(chunk));\n  stream.on('end', () => {\n    const buffer = Buffer.concat(chunks);\n    res.send(buffer);\n  });\n});\n\napp.get('/buffer-arraybuffer', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  res.send(fileData);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\nconst app = express();\n\napp.use(responseTime());\n\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.get('/stream', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  fileStream.pipe(res);\n});\n\napp.get('/buffer', (req, res) => {\n  fs.readFile(imagePath, (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading file');\n      return;\n    }\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(data);\n  });\n});\n\napp.get('/bufferedStream', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  fileStream.on('data', (chunk) => {\n    res.write(chunk);\n  });\n  fileStream.on('end', () => {\n    res.end();\n  });\n});\n\napp.get('/streamedBuffer', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  let chunks = [];\n  fileStream.on('data', (chunk) => {\n    chunks.push(chunk);\n  });\n  fileStream.on('end', () => {\n    let data = Buffer.concat(chunks);\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(data);\n  });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\n\nconst app = express();\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/stream', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  stream.pipe(res);\n});\n\napp.get('/buffer', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  res.send(fileData);\n});\n\napp.get('/stream-arraybuffer', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  const chunks = [];\n  stream.on('data', (chunk) => chunks.push(chunk));\n  stream.on('end', () => {\n    const buffer = Buffer.concat(chunks);\n    res.send(buffer);\n  });\n});\n\napp.get('/buffer-arraybuffer', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  res.send(fileData);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\nconst app = express();\nconst PORT = 3000;\nconst filePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/stream', (req, res) => {\n  const stream = fs.createReadStream(filePath);\n  stream.pipe(res);\n});\n\napp.get('/buffer', (req, res) => {\n  const fileData = fs.readFileSync(filePath);\n  res.send(fileData);\n});\n\napp.get('/stream-arraybuffer', (req, res) => {\n  const stream = fs.createReadStream(filePath);\n  const chunks = [];\n  stream.on('data', (chunk) => {\n    chunks.push(chunk);\n  });\n  stream.on('end', () => {\n    const buffer = Buffer.concat(chunks);\n    res.send(buffer);\n  });\n});\n\napp.get('/buffer-arraybuffer', (req, res) => {\n  const fileData = fs.readFileSync(filePath);\n  res.send(fileData);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\n\nconst app = express();\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/stream', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  stream.pipe(res);\n});\n\napp.get('/buffer', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  res.setHeader('Content-Type', 'image/jpeg');\n  res.send(fileData);\n});\n\napp.get('/stream-arraybuffer', (req, res) => {\n  const stream = fs.createReadStream(imagePath);\n  const chunks = [];\n  stream.on('data', (chunk) => {\n    chunks.push(chunk);\n  });\n  stream.on('end', () => {\n    const buffer = Buffer.concat(chunks);\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(buffer);\n  });\n});\n\napp.get('/buffer-arraybuffer', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  const buffer = Buffer.from(fileData);\n  res.setHeader('Content-Type', 'image/jpeg');\n  res.send(buffer);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\nconst app = express();\n\napp.use(responseTime());\n\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.get('/stream', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  fileStream.pipe(res);\n});\n\napp.get('/non-stream', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  res.setHeader('Content-Type', 'image/jpeg');\n  res.send(fileData);\n});\n\napp.get('/stream-arraybuffer', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  let chunks = [];\n  fileStream.on('data', (chunk) => {\n    chunks.push(chunk);\n  });\n  fileStream.on('end', () => {\n    const fileData = Buffer.concat(chunks);\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(fileData);\n  });\n});\n\napp.get('/stream-arraybuffer-async', async (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  let chunks = [];\n  for await (const chunk of fileStream) {\n    chunks.push(chunk);\n  }\n  const fileData = Buffer.concat(chunks);\n  res.setHeader('Content-Type', 'image/jpeg');\n  res.send(fileData);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst responseTime = require('response-time');\n\nconst app = express();\nconst PORT = 3000;\nconst imagePath = path.join(__dirname, 'CapitalOne_Digital_Skills_Infographic_BW.jpg');\n\napp.use(responseTime());\n\napp.get('/stream', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  fileStream.pipe(res);\n});\n\napp.get('/non-stream', (req, res) => {\n  const fileData = fs.readFileSync(imagePath);\n  res.setHeader('Content-Type', 'image/jpeg');\n  res.send(fileData);\n});\n\napp.get('/stream-arraybuffer', (req, res) => {\n  fs.readFile(imagePath, (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading file');\n      return;\n    }\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(data);\n  });\n});\n\napp.get('/stream-memory', (req, res) => {\n  const fileStream = fs.createReadStream(imagePath);\n  let chunks = [];\n  fileStream.on('data', (chunk) => {\n    chunks.push(chunk);\n  });\n  fileStream.on('end', () => {\n    const fileData = Buffer.concat(chunks);\n    res.setHeader('Content-Type', 'image/jpeg');\n    res.send(fileData);\n  });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a function that sets up an Express server to serve static files and handle API requests for product data.\n\nFunction Description: The function sets up an Express server that serves static files from the current directory and provides two API endpoints: one to retrieve all products and another to retrieve a specific product by ID. The server listens on port 3000.\n\nInput: None\n\nOutput: None (The function starts a server that listens on port 3000 and does not return any value)",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var app = express();\n\n    app.use(\"/\", express.static(__dirname));\n\n    var products = [\n        {id: 0, title: 'Paint pots', description: 'Pots full of paint', price: 3.95},\n        {id: 1, title: 'Polka dots', description: 'Dots with that polka groove', price: 12.95},\n        {id: 2, title: 'Pebbles', description: 'Just little rocks, really', price: 6.95}\n    ];\n\n    app.get('/products', function(req, res) {\n        res.send(products);\n    });\n\n    app.get('/products/:id', function(req, res) {\n        res.send(products[req.params.id]);\n    });\n\n    app.listen(3000);\n    console.log('Listening on port 3000');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Logic to retrieve all products\n});\n\napp.get('/products/:id', (req, res) => {\n  // Logic to retrieve a specific product by ID\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Logic to retrieve all products\n});\n\napp.get('/products/:id', (req, res) => {\n  // Logic to retrieve a specific product by ID\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Fetch all products from database\n  res.json(products);\n});\n\napp.get('/products/:id', (req, res) => {\n  // Fetch a specific product by ID from database\n  res.json(product);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Logic to retrieve all products\n});\n\napp.get('/products/:id', (req, res) => {\n  // Logic to retrieve a specific product by ID\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Retrieve all products\n});\napp.get('/products/:id', (req, res) => {\n  // Retrieve a specific product by ID\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Logic to retrieve all products\n});\n\napp.get('/products/:id', (req, res) => {\n  // Logic to retrieve a specific product by ID\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Fetch all products from database\n  res.json(products);\n});\n\napp.get('/products/:id', (req, res) => {\n  // Fetch product by ID from database\n  res.json(product);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Retrieve all products\n});\n\napp.get('/products/:id', (req, res) => {\n  // Retrieve a specific product by ID\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static('.'));\napp.get('/products', (req, res) => {\n  // Retrieve all products\n});\napp.get('/products/:id', (req, res) => {\n  // Retrieve a specific product by ID\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.static(__dirname));\n\napp.get('/products', (req, res) => {\n  // Fetch all products from database\n  res.json(products);\n});\n\napp.get('/products/:id', (req, res) => {\n  // Fetch a specific product by ID from database\n  res.json(product);\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a function that sets up an Express server with Socket.IO for real-time communication, including CORS support, route handling, and socket event management for chat room functionality.\n\nFunction Description: The function `setupServer` initializes an Express application with HTTP and WebSocket support. It configures CORS middleware, handles socket connections for chat room operations (joining, messaging, disconnecting), and starts the server on a specified port. The function integrates Express routing and Socket.IO events to manage real-time communication between clients in different rooms.\n\nInput: None (The function uses environment variables for port configuration, with a default fallback to port 5000)\n\nOutput: None (The function starts a server process that listens for incoming HTTP and WebSocket connections, but doesn't return any value)",
    "Canonical_solution": "function setupServer() {\n    const http = require('http');\n    const express = require('express');\n    const socketio = require('socket.io');\n    const cors = require('cors');\n    \n    const app = express();\n    const server = http.createServer(app);\n    const io = socketio(server);\n    \n    app.use(cors());\n    app.use(router);\n    \n    io.on('connect', (socket) => {\n        socket.on('join', ({ name, room }, callback) => {\n            const { error, user } = addUser({ id: socket.id, name, room });\n            if(error) return callback(error);\n            socket.join(user.room);\n            socket.emit('message', { user: 'admin', text: `${user.name}, welcome to room ${user.room}.`});\n            socket.broadcast.to(user.room).emit('message', { user: 'admin', text: `${user.name} has joined!` });\n            io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room) });\n            callback();\n        });\n        \n        socket.on('sendMessage', (message, callback) => {\n            const user = getUser(socket.id);\n            io.to(user.room).emit('message', { user: user.name, text: message });\n            callback();\n        });\n        \n        socket.on('disconnect', () => {\n            const user = removeUser(socket.id);\n            if(user) {\n                io.to(user.room).emit('message', { user: 'Admin', text: `${user.name} has left.` });\n                io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room)});\n            }\n        });\n    });\n    \n    server.listen(process.env.PORT || 5000, () => console.log(`Server has started.`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [],
    "unmatched_results": [
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.username = username;\n    io.to(roomId).emit('userJoined', { username });\n  });\n\n  socket.on('chatMessage', (message) => {\n    io.to(message.roomId).emit('message', { message, username: socket.username });\n  });\n\n  socket.on('disconnect', () => {\n    io.emit('userDisconnected', { username: socket.username });\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.emit('message', { message: `Welcome ${username}!` });\n  });\n\n  socket.on('chatMessage', (message) => {\n    socket.broadcast.to(message.roomId).emit('message', message);\n  });\n\n  socket.on('disconnect', () => {\n    console.log('User disconnected');\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.username = username;\n    socket.roomId = roomId;\n    io.to(roomId).emit('userJoined', { username });\n  });\n\n  socket.on('chatMessage', (message) => {\n    io.to(socket.roomId).emit('message', { username: socket.username, message });\n  });\n\n  socket.on('disconnect', () => {\n    io.to(socket.roomId).emit('userLeft', { username: socket.username });\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.username = username;\n    socket.roomId = roomId;\n    io.to(roomId).emit('userJoined', { username });\n  });\n\n  socket.on('chatMessage', (message) => {\n    io.to(socket.roomId).emit('message', { username: socket.username, message });\n  });\n\n  socket.on('disconnect', () => {\n    io.to(socket.roomId).emit('userDisconnected', { username: socket.username });\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.emit('message', { message: `Welcome ${username}!` });\n  });\n\n  socket.on('chatMessage', (message) => {\n    io.to(message.roomId).emit('message', message);\n  });\n\n  socket.on('disconnect', () => {\n    console.log('User disconnected');\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => console.log(`Server running on port ${PORT}`));\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.username = username;\n    socket.roomId = roomId;\n    io.to(roomId).emit('userJoined', { username });\n  });\n\n  socket.on('chatMessage', (message) => {\n    io.to(socket.roomId).emit('message', { message, username: socket.username });\n  });\n\n  socket.on('disconnect', () => {\n    if (socket.username && socket.roomId) {\n      io.to(socket.roomId).emit('userLeft', { username: socket.username });\n    }\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => console.log(`Server running on port ${PORT}`));\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.username = username;\n    socket.roomId = roomId;\n    io.to(roomId).emit('userJoined', { username });\n  });\n\n  socket.on('chatMessage', (message) => {\n    io.to(socket.roomId).emit('message', { username: socket.username, message });\n  });\n\n  socket.on('disconnect', () => {\n    io.to(socket.roomId).emit('userLeft', { username: socket.username });\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => console.log(`Server running on port ${PORT}`));\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.emit('message', { message: `Welcome ${username} to the room ${roomId}` });\n  });\n\n  socket.on('chatMessage', (message) => {\n    io.to(message.roomId).emit('message', message);\n  });\n\n  socket.on('disconnect', () => {\n    console.log('User disconnected');\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.username = username;\n    socket.roomId = roomId;\n    io.to(roomId).emit('userJoined', { username });\n  });\n\n  socket.on('sendMessage', (message) => {\n    io.to(socket.roomId).emit('message', { message, username: socket.username });\n  });\n\n  socket.on('disconnect', () => {\n    if (socket.username && socket.roomId) {\n      io.to(socket.roomId).emit('userLeft', { username: socket.username });\n    }\n  });\n});\n\nconst port = process.env.PORT || 5000;\nserver.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(cors());\n\nio.on('connection', (socket) => {\n  socket.on('joinRoom', ({ roomId, username }) => {\n    socket.join(roomId);\n    socket.username = username;\n    socket.roomId = roomId;\n    io.to(roomId).emit('userJoined', { username });\n  });\n\n  socket.on('chatMessage', (message) => {\n    io.to(socket.roomId).emit('message', { username: socket.username, message });\n  });\n\n  socket.on('disconnect', () => {\n    if (socket.username && socket.roomId) {\n      io.to(socket.roomId).emit('userLeft', { username: socket.username });\n    }\n  });\n});\n\nconst PORT = process.env.PORT || 5000;\nserver.listen(PORT, () => console.log(`Server running on port ${PORT}`));\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a specified target URL.\n\nFunction Description: The function `createProxyServer` initializes an Express application, configures a proxy middleware to forward requests to a specified target URL (in this case, 'http://jsonplaceholder.typicode.com/users'), and starts the server on port 3000. It also handles graceful shutdown on receiving SIGINT or SIGTERM signals.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts a server and logs messages to the console.)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('../../dist');\n    \n    const jsonPlaceholderProxy = createProxyMiddleware({\n        target: 'http://jsonplaceholder.typicode.com/users',\n        changeOrigin: true,\n        logger: console,\n    });\n\n    const app = express();\n    app.use('/users', jsonPlaceholderProxy);\n    \n    const server = app.listen(3000);\n    console.log('[DEMO] Server: listening on port 3000');\n    console.log('[DEMO] Opening: http://localhost:3000/users');\n    \n    require('open')('http://localhost:3000/users');\n    \n    process.on('SIGINT', () => server.close());\n    process.on('SIGTERM', () => server.close());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server listening at http://localhost:${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server running on port ${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server running on port ${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users',\n  changeOrigin: true,\n  logLevel: 'debug'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server running on port ${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server running on port ${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server running on port ${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com',\n  changeOrigin: true,\n  logLevel: 'debug'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server listening at http://localhost:${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit(0);\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server running on port ${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server running on port ${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit();\n});",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\nconst port = 3000;\n\napp.use(httpProxy('/users', {\n  target: 'http://jsonplaceholder.typicode.com/users'\n}));\n\napp.listen(port, () => {\n  console.log(`Proxy server listening at http://localhost:${port}`);\n});\n\nprocess.on('SIGINT', () => {\n  console.log('Shutting down server...');\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('Shutting down server...');\n  process.exit(0);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server with WebSocket support using Express and Socket.IO, implementing a particle simulation system with cluster and client event handling.\n\nFunction Description: The function `startServer` initializes an Express application, sets up static file serving, integrates Socket.IO for real-time communication, and configures a particle simulation system with collision detection and cluster management. It handles particle movement, boundary collisions, and client interactions through defined event handlers.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function starts a server listening on port 3000 but doesn't return any value)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    const server = require('http').Server(app);\n    const io = require('socket.io')(server);\n    const swip = require('../../../src/server/index.js');\n\n    app.use(express.static(__dirname + './../static'));\n\n    swip(io, {\n        cluster: {\n            events: {\n                update: (cluster) => {\n                    const blobs = cluster.data.blobs;\n                    const clients = cluster.clients;\n\n                    const updatedBlobs = blobs.map((blob) => {\n                        const boundaryOffset = blob.size;\n                        const client = clients.find((c) => isParticleInClient(blob, c));\n\n                        let nextPosX = blob.x + blob.speedX;\n                        let nextPosY = blob.y + blob.speedY;\n                        let nextSpeedX = blob.speedX;\n                        let nextSpeedY = blob.speedY;\n\n                        if (client) {\n                            if (((blob.speedX < 0) &&\n                                ((nextPosX - boundaryOffset) < client.transform.x)\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.left, nextPosY))) {\n                                nextPosX = client.transform.x + boundaryOffset;\n                                nextSpeedX = blob.speedX * -1;\n                            } else if (((blob.speedX > 0) &&\n                                ((nextPosX + boundaryOffset) > (client.transform.x + client.size.width))\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.right, nextPosY))) {\n                                nextPosX = client.transform.x + (client.size.width - boundaryOffset);\n                                nextSpeedX = blob.speedX * -1;\n                            }\n\n                            if (((blob.speedY < 0) &&\n                                ((nextPosY - boundaryOffset) < client.transform.y\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.top, nextPosX)))) {\n                                nextPosY = client.transform.y + boundaryOffset;\n                                nextSpeedY = blob.speedY * -1;\n                            } else if (((blob.speedY > 0) &&\n                                ((nextPosY + boundaryOffset) > (client.transform.y + client.size.height))\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.bottom, nextPosX))\n                            ) {\n                                nextPosY = client.transform.y + (client.size.height - boundaryOffset);\n                                nextSpeedY = blob.speedY * -1;\n                            }\n                        } else {\n                            const firstClient = clients[0];\n                            nextPosX = firstClient.transform.x + (firstClient.size.width / 2);\n                            nextPosY = firstClient.transform.y + (firstClient.size.height / 2);\n                            nextSpeedX = 0;\n                            nextSpeedY = 0;\n                        }\n\n                        blob.x = nextPosX;\n                        blob.y = nextPosY;\n                        blob.speedX = nextSpeedX;\n                        blob.speedY = nextSpeedY;\n\n                        return blob;\n                    });\n\n                    return {\n                        blobs: { $set: updatedBlobs },\n                    };\n                },\n                merge: (cluster1, cluster2, transform) => ({\n                    blobs: { $set: getNewParticleDist(cluster1, cluster2, transform) },\n                    backgroundColor: { $set: cluster1.data.backgroundColor },\n                }),\n            },\n            init: () => ({ blobs: [], backgroundColor: getRandomColor() }),\n        },\n\n        client: {\n            init: () => ({}),\n            events: {\n                addBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $push: blobs } },\n                        },\n                    };\n                },\n                updateBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $set: blobs } },\n                        },\n                    };\n                },\n            },\n        },\n    });\n\n    server.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [],
    "unmatched_results": [
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nconst numCPUs = os.cpus().length;\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(express.static('public'));\n\nio.on('connection', (socket) => {\n  // Particle simulation and event handling code here\n});\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n} else {\n  server.listen(3000, () => {\n    console.log(`Server running on port 3000`);\n  });\n}",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIo(server);\n\n  app.use(express.static('public'));\n\n  let particles = [];\n\n  io.on('connection', (socket) => {\n    socket.on('newParticle', (data) => {\n      particles.push(data);\n      io.emit('updateParticles', particles);\n    });\n\n    socket.on('disconnect', () => {\n      particles = particles.filter(p => p.id !== socket.id);\n      io.emit('updateParticles', particles);\n    });\n  });\n\n  const updateParticles = () => {\n    particles.forEach(particle => {\n      // Update particle position and handle collisions\n    });\n    io.emit('updateParticles', particles);\n  };\n\n  setInterval(updateParticles, 1000 / 60);\n\n  server.listen(3000, () => {\n    console.log(`Server running on port 3000`);\n  });\n}\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIo(server);\n\n  app.use(express.static('public'));\n\n  let particles = [];\n\n  io.on('connection', (socket) => {\n    socket.on('joinSimulation', () => {\n      particles.push({ x: 0, y: 0, velocityX: 1, velocityY: 1 });\n      socket.emit('updateParticles', particles);\n    });\n\n    socket.on('moveParticle', (data) => {\n      const particle = particles.find(p => p.id === data.id);\n      if (particle) {\n        particle.x += particle.velocityX;\n        particle.y += particle.velocityY;\n        if (particle.x < 0 || particle.x > 100) particle.velocityX *= -1;\n        if (particle.y < 0 || particle.y > 100) particle.velocityY *= -1;\n        socket.broadcast.emit('updateParticles', particles);\n      }\n    });\n\n    socket.on('disconnect', () => {\n      particles = particles.filter(p => p.id !== socket.id);\n      socket.broadcast.emit('updateParticles', particles);\n    });\n  });\n\n  server.listen(3000, () => {\n    console.log('Listening on port 3000');\n  });\n}\n```",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\nconst path = require('path');\n\nconst numCPUs = os.cpus().length;\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(express.static(path.join(__dirname, 'public')));\n\nio.on('connection', (socket) => {\n  // Particle simulation and event handling code here\n});\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  server.listen(3000, () => {\n    console.log(`Server running on port 3000`);\n  });\n}",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\nconst path = require('path');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIo(server);\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  let particles = [];\n\n  io.on('connection', (socket) => {\n    socket.on('initialize', () => {\n      socket.emit('particles', particles);\n    });\n\n    socket.on('moveParticle', (data) => {\n      const particle = particles.find(p => p.id === data.id);\n      if (particle) {\n        particle.x = data.x;\n        particle.y = data.y;\n      }\n    });\n\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  function checkCollisions() {\n    for (let i = 0; i < particles.length; i++) {\n      for (let j = i + 1; j < particles.length; j++) {\n        const dx = particles[i].x - particles[j].x;\n        const dy = particles[i].y - particles[j].y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance < particles[i].radius + particles[j].radius) {\n          // Handle collision\n        }\n      }\n    }\n  }\n\n  function checkBoundaries() {\n    particles.forEach(particle => {\n      if (particle.x < 0 || particle.x > 100) particle.x = 100 - particle.x;\n      if (particle.y < 0 || particle.y > 100) particle.y = 100 - particle.y;\n    });\n  }\n\n  function simulate() {\n    checkCollisions();\n    checkBoundaries();\n    io.emit('updateParticles', particles);\n  }\n\n  setInterval(simulate, 1000 / 60);\n\n  server.listen(3000, () => {\n    console.log(`Server running on port 3000`);\n  });\n}\n```",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nconst numCPUs = os.cpus().length;\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(express.static('public'));\n\nio.on('connection', (socket) => {\n  // Particle simulation and event handling code here\n});\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  server.listen(3000, () => {\n    console.log(`Server running on port 3000`);\n  });\n}",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\nconst path = require('path');\n\nconst numCPUs = os.cpus().length;\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(express.static(path.join(__dirname, 'public')));\n\nio.on('connection', (socket) => {\n  console.log('a user connected');\n\n  socket.on('disconnect', () => {\n    console.log('user disconnected');\n  });\n\n  socket.on('moveParticle', (data) => {\n    // Handle particle movement\n  });\n\n  socket.on('boundaryCollision', (data) => {\n    // Handle boundary collisions\n  });\n\n  socket.on('clusterUpdate', (data) => {\n    // Handle cluster updates\n  });\n});\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  server.listen(3000, () => {\n    console.log(`Server running on port 3000`);\n  });\n}",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nconst numCPUs = os.cpus().length;\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\napp.use(express.static('public'));\n\nio.on('connection', (socket) => {\n  socket.on('moveParticle', (data) => {\n    // Handle particle movement\n  });\n\n  socket.on('boundaryCollision', (data) => {\n    // Handle boundary collision\n  });\n\n  socket.on('disconnect', () => {\n    // Handle client disconnection\n  });\n});\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n} else {\n  server.listen(3000, () => {\n    console.log(`Server running on port 3000`);\n  });\n}",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIo(server);\n\n  app.use(express.static('public'));\n\n  let particles = [];\n\n  io.on('connection', (socket) => {\n    console.log('a user connected');\n\n    socket.on('disconnect', () => {\n      console.log('user disconnected');\n    });\n\n    socket.on('updateParticles', (data) => {\n      particles = data;\n      io.emit('updateParticles', particles);\n    });\n  });\n\n  const updateParticles = () => {\n    particles.forEach((particle) => {\n      // Update particle position\n      // Handle boundary collisions\n      // Handle cluster management\n    });\n    io.emit('updateParticles', particles);\n  };\n\n  const interval = setInterval(updateParticles, 1000 / 60);\n\n  server.listen(3000, () => {\n    console.log(`Server running on port 3000`);\n  });\n}\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIo(server);\n\n  app.use(express.static('public'));\n\n  let particles = [];\n\n  io.on('connection', (socket) => {\n    socket.on('newParticle', (data) => {\n      particles.push(data);\n    });\n\n    socket.on('moveParticles', () => {\n      particles.forEach((particle) => {\n        // Move particle logic\n      });\n    });\n\n    socket.on('clusterParticles', (data) => {\n      // Cluster management logic\n    });\n\n    socket.on('disconnect', () => {\n      // Handle client disconnection\n    });\n  });\n\n  server.listen(3000, () => {\n    console.log('Listening on port 3000');\n  });\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server using the Express framework, defines a route to handle GET requests for user data, and renders a view with the user data.\n\nFunction Description: The function `startServer` sets up an Express application, configures a route to respond to GET requests at the '/users' endpoint, and starts the server on port 3000. When the '/users' route is accessed, it sends a response containing a list of user objects to be rendered in a view.\n\nInput: None\n\nOutput: None (The function starts a server that listens on port 3000 and logs a message to the console when the server is running.)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    \n    app.get('/users', function (req, res) {\n        const users = [\n            { name: 'Suissa' },\n            { name: 'Itacir' },\n            { name: 'Caio' }\n        ];\n        res.render('users/views/list', {users});\n    });\n\n    app.listen(3000, function () {\n        console.log('Servidor rodando em localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' }\n  ];\n  res.render('users', { users });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' }\n  ];\n  res.render('users', { users });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [{name: 'Alice', age: 25}, {name: 'Bob', age: 30}];\n  res.render('users', {users});\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' }\n  ];\n  res.render('users', { users });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' }\n  ];\n  res.render('users', { users });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' }\n  ];\n  res.render('users', { users });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' }\n  ];\n  res.render('users', { users });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  res.render('users', { users: getUsers() });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\nfunction getUsers() {\n  // Dummy data for demonstration purposes\n  return [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' }\n  ];\n}",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [\n    { id: 1, name: 'Alice' },\n    { id: 2, name: 'Bob' },\n    { id: 3, name: 'Charlie' }\n  ];\n  res.render('users', { users });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.get('/users', (req, res) => {\n  const users = [{name: 'Alice', age: 25}, {name: 'Bob', age: 30}];\n  res.render('users', {users});\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a function that sets up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates with Next.js for server-side rendering, and sets up basic route handling. It prepares the Next.js application, configures middleware, and starts the server on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption)\n\nOutput: Returns a Promise that resolves to the configured Express server instance when the Next.js app is prepared and the server is listening on the specified port.",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  return app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n\n    return server;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: dev },\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n});\n```",
      "const express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions',\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n\n  return server;\n}).catch((err) => {\n  console.error(err);\n  process.exit(1);\n});",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: dev },\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n});\n```",
      "const express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst mongoStore = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: mongoStore,\n    cookie: { secure: dev }\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n}).catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n\nmodule.exports = server;",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst PORT = process.env.PORT || 8000;\nconst SESSION_NAME = process.env.SESSION_NAME || 'nextjs-session';\nconst SESSION_SECRET = process.env.SESSION_SECRET || 'your-secret-key';\nconst MONGO_URL = process.env.MONGO_URL_TEST;\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: MONGO_URL,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: SESSION_NAME,\n    secret: SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: dev },\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(PORT, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${PORT}`);\n  });\n\n  return server;\n});\n```",
      "const express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst nextApp = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = nextApp.getRequestHandler();\n\nconst app = express();\n\nnextApp.prepare().then(() => {\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  store.on('connected', () => {\n    store.client.on('error', (err) => {\n      console.error('MongoDB session store error:', err);\n    });\n  });\n\n  app.use(\n    session({\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      resave: false,\n      saveUninitialized: true,\n      store: store,\n    })\n  );\n\n  app.get('/about', (req, res) => {\n    return nextApp.render(req, res, '/about');\n  });\n\n  app.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  app.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`Server ready on http://localhost:${port}`);\n  });\n}).catch((err) => {\n  console.error('Error starting server:', err);\n  process.exit(1);\n});\n\nmodule.exports = app;",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: dev },\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n\n  return server;\n});\n```",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst nextApp = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = nextApp.getRequestHandler();\n\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nnextApp.prepare().then(() => {\n  app.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store\n  }));\n\n  app.get('/about', (req, res) => {\n    return nextApp.render(req, res, '/about');\n  });\n\n  app.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const PORT = process.env.PORT || 8000;\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}).catch(ex => {\n  console.error(ex);\n  process.exit(1);\n});\n\nmodule.exports = app;",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions',\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n\n  return server;\n});\n```",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\nconst passportLocalMongoose = require('passport-local-mongoose');\nconst User = require('./models/User');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nstore.on('connected', () => {\n  console.log('Connected to MongoDB session store');\n});\n\nstore.on('error', (error) => {\n  console.error('MongoDB session store error:', error);\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  passport.use(User.createStrategy());\n  passport.serializeUser(User.serializeUser());\n  passport.deserializeUser(User.deserializeUser());\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n}).catch((ex) => {\n  console.error('An error occurred, unable to start the server:', ex);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5 or url in seen:\n            callback(args)\n            return\n        seen[url] = True\n        domain = url.split('/')[2]\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def isgd(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def googl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def generic(self, args, callback):\n        url = args['url']\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback(args)\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback(args)\n            return\n        if url in seen:\n            callback(args)\n            return\n        seen[url] = True\n        domain = self.get_domain(url)\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def get_domain(self, url):\n        return url.split('/')[2]\n\n    def isgd(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('is.gd/', '')\n        response = requests.get(f'https://is.gd/{expanded_url}', timeout=self.timeout)\n        if response.status_code == 200:\n            args['url'] = response.url\n            callback(args)\n        else:\n            self.generic(args, callback)\n\n    def googl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('goo.gl/', '')\n        response = requests.get(f'https://goo.gl/{expanded_url}', timeout=self.timeout)\n        if response.status_code == 200:\n            args['url'] = response.url\n            callback(args)\n        else:\n            self.generic(args, callback)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('budurl.com/', '')\n        response = requests.get(f'https://budurl.com/{expanded_url}', timeout=self.timeout)\n        if response.status_code == 200:\n            args['url'] = response.url\n            callback(args)\n        else:\n            self.generic(args, callback)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('snipurl.com/', '')\n        response = requests.get(f'https://snipurl.com/{expanded_url}', timeout=self.timeout)\n        if response.status_code == 200:\n            args['url'] = response.url\n            callback(args)\n        else:\n            self.generic(args, callback)\n\n    def generic(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0) + 1\n        headers = {'Connection': 'close'}\n        response = requests.head(url, headers=headers, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            args['url'] = response.headers['Location']\n            args['depth'] = depth\n            callback(args)\n        else:\n            callback(args)\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5 or url in seen:\n            callback(args)\n            return\n        seen[url] = True\n        domain = url.split('/')[2]\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def isgd(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            expanded_url = response.url\n            args['url'] = expanded_url\n            callback(args)\n        else:\n            self.generic(args, callback)\n\n    def googl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            expanded_url = response.url\n            args['url'] = expanded_url\n            callback(args)\n        else:\n            self.generic(args, callback)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            expanded_url = response.url\n            args['url'] = expanded_url\n            callback(args)\n        else:\n            self.generic(args, callback)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            expanded_url = response.url\n            args['url'] = expanded_url\n            callback(args)\n        else:\n            self.generic(args, callback)\n\n    def generic(self, args, callback):\n        url = args['url']\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            expanded_url = response.headers['Location']\n            args['url'] = expanded_url\n            callback(args)\n        else:\n            callback(args)\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback(args)\n            return\n        if url in seen:\n            callback(args)\n            return\n        seen[url] = True\n        domain = url.split('/')[2]\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def isgd(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def googl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def generic(self, args, callback):\n        url = args['url']\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback(args)\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 10:  # Prevent infinite loops\n            return callback({'url': url, 'expanded': False})\n        if url in seen:\n            return callback({'url': url, 'expanded': False})\n        seen[url] = True\n        domain = self._get_domain(url)\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def _get_domain(self, url):\n        return url.split('/')[2]\n\n    def isgd(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('is.gd/', '')\n        args['url'] = expanded_url\n        self._make_request(args, callback)\n\n    def googl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('goo.gl/', '')\n        args['url'] = expanded_url\n        self._make_request(args, callback)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('budurl.com/', '')\n        args['url'] = expanded_url\n        self._make_request(args, callback)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('snipurl.com/', '')\n        args['url'] = expanded_url\n        self._make_request(args, callback)\n\n    def generic(self, args, callback):\n        url = args['url']\n        headers = {'Connection': 'close'}\n        try:\n            response = requests.head(url, headers=headers, timeout=self.timeout)\n            if response.status_code == 301 or response.status_code == 302:\n                args['url'] = response.headers['Location']\n                self.expand(args, callback)\n            else:\n                callback({'url': url, 'expanded': False})\n        except requests.RequestException as e:\n            callback({'url': url, 'expanded': False})\n\n    def _make_request(self, args, callback):\n        url = args['url']\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.status_code == 200:\n                args['url'] = response.url\n                self.expand(args, callback)\n            else:\n                callback({'url': url, 'expanded': False})\n        except requests.RequestException as e:\n            callback({'url': url, 'expanded': False})\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5 or url in seen:\n            callback(args)\n            return\n        seen[url] = True\n        domain = self.get_domain(url)\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def get_domain(self, url):\n        return url.split('/')[2]\n\n    def isgd(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('is.gd/', '')\n        args['url'] = expanded_url\n        callback(args)\n\n    def googl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('goo.gl/', '')\n        args['url'] = expanded_url\n        callback(args)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('budurl.com/', '')\n        args['url'] = expanded_url\n        callback(args)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('snipurl.com/', '')\n        args['url'] = expanded_url\n        callback(args)\n\n    def generic(self, args, callback):\n        url = args['url']\n        try:\n            response = requests.head(url, timeout=self.timeout)\n            if response.status_code == 301 or response.status_code == 302:\n                args['url'] = response.headers['Location']\n                self.expand(args, callback)\n            else:\n                callback(args)\n        except requests.RequestException as e:\n            callback(args)\n\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 10:  # Prevent infinite loops\n            callback({'url': url, 'expanded': False})\n            return\n        if url in seen:\n            callback({'url': url, 'expanded': False})\n            return\n        seen[url] = True\n        domain = url.split('/')[2]\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def isgd(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback({'url': response.url, 'expanded': True})\n        else:\n            callback({'url': url, 'expanded': False})\n\n    def googl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback({'url': response.url, 'expanded': True})\n        else:\n            callback({'url': url, 'expanded': False})\n\n    def budurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback({'url': response.url, 'expanded': True})\n        else:\n            callback({'url': url, 'expanded': False})\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback({'url': response.url, 'expanded': True})\n        else:\n            callback({'url': url, 'expanded': False})\n\n    def generic(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0) + 1\n        seen = args.get('seen', {})\n        try:\n            response = requests.head(url, timeout=self.timeout)\n            if response.status_code == 301 or response.status_code == 302:\n                expanded_url = response.headers['Location']\n                if expanded_url not in seen:\n                    args['url'] = expanded_url\n                    args['depth'] = depth\n                    args['seen'] = seen\n                    self.expand(args, callback)\n                else:\n                    callback({'url': url, 'expanded': False})\n            else:\n                callback({'url': url, 'expanded': False})\n        except requests.RequestException:\n            callback({'url': url, 'expanded': False})\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5 or url in seen:\n            callback(args)\n            return\n        seen[url] = True\n        domain = self.get_domain(url)\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def get_domain(self, url):\n        return url.split('/')[2]\n\n    def isgd(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('is.gd/', '')\n        args['url'] = expanded_url\n        callback(args)\n\n    def googl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('goo.gl/', '')\n        args['url'] = expanded_url\n        callback(args)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('budurl.com/', '')\n        args['url'] = expanded_url\n        callback(args)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        expanded_url = url.replace('snipurl.com/', '')\n        args['url'] = expanded_url\n        callback(args)\n\n    def generic(self, args, callback):\n        url = args['url']\n        try:\n            response = requests.head(url, timeout=self.timeout)\n            if response.status_code == 301 or response.status_code == 302:\n                args['url'] = response.headers['Location']\n                self.expand(args, callback)\n            else:\n                callback(args)\n        except requests.RequestException:\n            callback(args)\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback(args)\n            return\n        if url in seen:\n            callback(args)\n            return\n        seen[url] = True\n        domain = self.get_domain(url)\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def get_domain(self, url):\n        return url.split('/')[2]\n\n    def isgd(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback({'url': response.url, 'depth': args['depth'] + 1, 'seen': args['seen']})\n        else:\n            callback(args)\n\n    def googl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback({'url': response.url, 'depth': args['depth'] + 1, 'seen': args['seen']})\n        else:\n            callback(args)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback({'url': response.url, 'depth': args['depth'] + 1, 'seen': args['seen']})\n        else:\n            callback(args)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback({'url': response.url, 'depth': args['depth'] + 1, 'seen': args['seen']})\n        else:\n            callback(args)\n\n    def generic(self, args, callback):\n        url = args['url']\n        headers = {'Connection': 'close'}\n        response = requests.head(url, headers=headers, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            redirect_url = response.headers['Location']\n            args['url'] = redirect_url\n            self.expand(args, callback)\n        else:\n            callback(args)\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': self.isgd,\n            'goo.gl': self.googl,\n            'budurl.com': self.budurl,\n            'snipurl.com': self.snipurl\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5 or url in seen:\n            callback(args)\n            return\n        seen[url] = True\n        domain = self.get_domain(url)\n        if domain in self.map:\n            self.map[domain](args, callback)\n        else:\n            self.generic(args, callback)\n\n    def get_domain(self, url):\n        return url.split('/')[2]\n\n    def isgd(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def googl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def budurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def snipurl(self, args, callback):\n        url = args['url']\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(args)\n        else:\n            args['url'] = response.url\n            self.expand(args, callback)\n\n    def generic(self, args, callback):\n        url = args['url']\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback(args)\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create a function to set up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB as the session store. It integrates Next.js for server-side rendering and sets up a catch-all route handler. The server listens on a specified port and connects to MongoDB using environment variables for configuration.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that:\n- Listens on the specified port\n- Outputs the server URL to console when ready\n- Maintains persistent connections to MongoDB for session storage)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  mongoose.connect(MONGO_URL);\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  const server = express();\n\n  const sessionOptions = {\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    store: mongoSessionStore.create({\n      mongoUrl: MONGO_URL,\n      ttl: 14 * 24 * 60 * 60,\n    }),\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      httpOnly: true,\n      maxAge: 14 * 24 * 60 * 60 * 1000,\n      domain: 'localhost',\n    },\n  };\n\n  const sessionMiddleware = session(sessionOptions);\n  server.use(sessionMiddleware);\n\n  server.get('*', (req, res) => handle(req, res));\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on ${ROOT_URL}`);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nstore.on('connected', () => {\n  console.log('MongoDB session store is connected');\n});\n\nstore.on('error', error => {\n  console.error('MongoDB session store error', error);\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, err => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nstore.on('connected', () => {\n  console.log('Connected to MongoDB session store');\n});\n\nstore.on('error', error => {\n  console.error('MongoDB session store error', error);\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(cookieParser());\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, err => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: process.env.NODE_ENV === 'production' }\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, () => {\n    console.log(`Server ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store,\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nstore.on('connected', () => {\n  console.log('Connected to MongoDB session store');\n});\n\nstore.on('error', (error) => {\n  console.error('MongoDB session store error', error);\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(cookieParser());\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, err => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: dev, maxAge: 24 * 60 * 60 * 1000 },\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n});\n```",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = app.getRequestHandler();\n\nconst mongoStore = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: mongoStore,\n    cookie: { secure: process.env.NODE_ENV === 'production' }\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const PORT = process.env.PORT || 8000;\n  server.listen(PORT, () => {\n    console.log(`Server ready on http://localhost:${PORT}`);\n  });\n\n  mongoStore.on('connected', () => {\n    console.log('Connected to MongoDB for session storage');\n  });\n\n  mongoStore.on('error', error => {\n    console.error('MongoDB session store error:', error);\n  });\n}).catch(ex => {\n  console.error('An error occurred, unable to start the server:', ex);\n});",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, err => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a function that sets up an Express server with rate limiting, CORS support, and route handlers for querying webpage elements and retrieving full HTML content using Chrome DevTools Protocol.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js server with middleware configuration and defines three routes:\n1. `/query` - Extracts specified elements' innerText and href attributes from a given URL\n2. `/fullHtml` - Retrieves the complete HTML of a given URL\n3. `/` - Serves a static index.html file\n\nThe function implements rate limiting, CORS, and proper error handling while using Chrome DevTools Protocol to interact with web pages programmatically.\n\nInput: None (The function doesn't take any parameters. Configuration is loaded from external files.)\n\nOutput: None (The function's output is the running Express server listening on the specified port, which defaults to 3000 if not provided via environment variables.)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const rateLimit = require('express-rate-limit');\n    const config = require('./config');\n\n    const app = express();\n    app.enable('trust proxy');\n    const limiter = rateLimit(config.rateLimit);\n    app.use('/fullHtml', limiter);\n    app.use('/query', limiter);\n    app.use(cors());\n    app.set('json replacer', null);\n    app.set('json spaces', 2);\n\n    app.get('/query', async (req, res) => {\n        const { url, selectors } = req.query;\n        if (!url || typeof url !== 'string' || !url.startsWith('http')) {\n            res.status(400).send('must provide a url');\n            throw new Error('throwing as url not valid');\n        }\n        if (!selectors) {\n            res.status(400).send('must provide selectors');\n            throw new Error('throwing as selectors not valid');\n        }\n        const selectorArr = selectors.split(',');\n        await launchChrome({\n            flags: ['--window-size=1280,1696', '--hide-scrollbars'],\n        });\n        let client;\n        try {\n            client = await CDP();\n            const { Network, Page, Runtime } = client;\n            await Network.enable();\n            await Page.enable();\n            await Network.setCacheDisabled({ cacheDisabled: true });\n            await Page.navigate({ url });\n            const requestCounterMinWaitMs = 1500;\n            const requestCounterMaxWaitMs = 20000;\n            let numSent = 0;\n            let numReceived = 0;\n            const startTime = new Date().getTime();\n            function minWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMinWaitMs;\n            }\n            function maxWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMaxWaitMs;\n            }\n            Network.requestWillBeSent((params) => {\n                if (params.type === 'XHR') {\n                    ++numSent;\n                }\n            });\n            Network.responseReceived((params) => {\n                if (params.type === 'XHR') {\n                    ++numReceived;\n                }\n            });\n            await new Promise((resolve, reject) => {\n                Page.loadEventFired(() => {\n                    const ajaxDoneInterval = setInterval(() => {\n                        if (numSent === numReceived && minWaitTimeExceeded()) {\n                            clearInterval(ajaxDoneInterval);\n                            resolve();\n                        } else if (maxWaitTimeExceeded()) {\n                            reject(new Error('ajax timeout after 20 seconds'));\n                        }\n                    }, 300);\n                });\n            });\n            const promiseArr = selectorArr.map(async (selector) => {\n                const innerTextRes = await Runtime.evaluate({\n                    expression: `document.querySelector('${selector}').innerText`,\n                });\n                const hrefRes = await Runtime.evaluate({\n                    expression: `document.querySelector('${selector}').href`,\n                });\n                return {\n                    innerText: innerTextRes.result.value,\n                    href: hrefRes.result.value,\n                };\n            });\n            const queryRes = await Promise.all(promiseArr.map(p => p.catch(e => e.message)));\n            res.json({\n                url,\n                selectors,\n                contents: queryRes,\n            });\n        } catch (err) {\n            res.status(503).send({\n                msg: 'request error',\n                emsg: err.message,\n            });\n        } finally {\n            if (client) {\n                await client.close();\n            }\n        }\n    });\n\n    app.get('/fullHtml', async (req, res) => {\n        const { url } = req.query;\n        if (!url || typeof url !== 'string' || !url.startsWith('http')) {\n            res.status(400).send('must provide a url');\n            throw new Error('throwing as url not valid');\n        }\n        await launchChrome({\n            flags: ['--window-size=1280,1696', '--hide-scrollbars'],\n        });\n        let client;\n        try {\n            client = await CDP();\n            const { Network, Page, Runtime } = client;\n            await Network.enable();\n            await Page.enable();\n            await Network.setCacheDisabled({ cacheDisabled: true });\n            await Page.navigate({ url });\n            const requestCounterMinWaitMs = 1500;\n            const requestCounterMaxWaitMs = 20000;\n            let numSent = 0;\n            let numReceived = 0;\n            const startTime = new Date().getTime();\n            function minWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMinWaitMs;\n            }\n            function maxWaitTimeExceeded() {\n                return new Date().getTime() - startTime > requestCounterMaxWaitMs;\n            }\n            Network.requestWillBeSent((params) => {\n                if (params.type === 'XHR') {\n                    ++numSent;\n                }\n            });\n            Network.responseReceived((params) => {\n                if (params.type === 'XHR') {\n                    ++numReceived;\n                }\n            });\n            await new Promise((resolve, reject) => {\n                Page.loadEventFired(() => {\n                    const ajaxDoneInterval = setInterval(() => {\n                        if (numSent === numReceived && minWaitTimeExceeded()) {\n                            clearInterval(ajaxDoneInterval);\n                            resolve();\n                        } else if (maxWaitTimeExceeded()) {\n                            reject(new Error('ajax timeout after 20 seconds'));\n                        }\n                    }, 300);\n                });\n            });\n            const result = await Runtime.evaluate({\n                expression: 'document.documentElement.outerHTML',\n            });\n            const html = result.result.value;\n            res.send({\n                url,\n                html,\n            });\n        } catch (err) {\n            res.status(503).send({\n                msg: 'request error',\n                emsg: err.message,\n            });\n        } finally {\n            if (client) {\n                await client.close();\n            }\n        }\n    });\n\n    app.get('/', function(req, res) {\n        res.sendFile(path.join(__dirname, '../public/index.html'));\n    });\n\n    const { PORT = 3000 } = process.env;\n    app.listen(PORT);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(cors());\napp.use(limiter);\n\napp.get('/query', async (req, res) => {\n  try {\n    const { url, selector } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const element = await page.$(selector);\n    const innerText = await element.evaluate(node => node.innerText);\n    const href = await element.evaluate(node => node.href);\n    await browser.close();\n    res.json({ innerText, href });\n  } catch (error) {\n    res.status(500).send('Error querying element');\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  try {\n    const { url } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).send('Error retrieving HTML');\n  }\n});\n\napp.use(express.static(path.join(__dirname, 'public')));\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(limiter);\napp.use(cors());\n\napp.get('/query', async (req, res) => {\n  try {\n    const { url, selector } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const elements = await page.evaluate(selector => {\n      const elements = document.querySelectorAll(selector);\n      return Array.from(elements).map(el => {\n        return {\n          innerText: el.innerText,\n          href: el.href\n        };\n      });\n    }, selector);\n    await browser.close();\n    res.json(elements);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  try {\n    const { url } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(cors());\napp.use(limiter);\n\napp.get('/query', async (req, res) => {\n  const { url, selector } = req.query;\n  if (!url || !selector) {\n    return res.status(400).send('URL and selector are required');\n  }\n  try {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const element = await page.$(selector);\n    if (!element) {\n      return res.status(404).send('Element not found');\n    }\n    const innerText = await element.evaluate(node => node.innerText);\n    const href = await element.evaluate(node => node.href);\n    await browser.close();\n    res.json({ innerText, href });\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  const { url } = req.query;\n  if (!url) {\n    return res.status(400).send('URL is required');\n  }\n  try {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(cors());\napp.use(limiter);\n\napp.get('/query', async (req, res) => {\n  const { url, selector } = req.query;\n  if (!url || !selector) {\n    return res.status(400).send('URL and selector are required');\n  }\n\n  try {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const element = await page.$(selector);\n    const innerText = await element.evaluate(node => node.innerText);\n    const href = await element.evaluate(node => node.href);\n    await browser.close();\n    res.json({ innerText, href });\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  const { url } = req.query;\n  if (!url) {\n    return res.status(400).send('URL is required');\n  }\n\n  try {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(limiter);\napp.use(cors());\n\napp.get('/query', async (req, res) => {\n  try {\n    const { url, selector } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const element = await page.$(selector);\n    const innerText = await element.evaluate(node => node.innerText);\n    const href = await element.evaluate(node => node.href);\n    await browser.close();\n    res.json({ innerText, href });\n  } catch (error) {\n    res.status(500).send('Error querying element');\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  try {\n    const { url } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).send('Error retrieving HTML');\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(limiter);\napp.use(cors());\n\napp.get('/query', async (req, res) => {\n  try {\n    const { url, selector } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url);\n    const element = await page.$(selector);\n    const innerText = await element.evaluate(node => node.innerText);\n    const href = await element.evaluate(node => node.href);\n    await browser.close();\n    res.json({ innerText, href });\n  } catch (error) {\n    res.status(500).send('Error querying element');\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  try {\n    const { url } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url);\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).send('Error retrieving HTML');\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(limiter);\napp.use(cors());\n\napp.get('/query', async (req, res) => {\n  try {\n    const { url, selector } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const elements = await page.evaluate(selector => {\n      const elements = document.querySelectorAll(selector);\n      return Array.from(elements).map(el => {\n        return {\n          innerText: el.innerText,\n          href: el.href\n        };\n      });\n    }, selector);\n    await browser.close();\n    res.json(elements);\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  try {\n    const { url } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(limiter);\napp.use(cors());\n\napp.get('/query', async (req, res) => {\n  try {\n    const { url, selector } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const element = await page.$(selector);\n    const innerText = await element.evaluate(node => node.innerText);\n    const href = await element.evaluate(node => node.href);\n    await browser.close();\n    res.json({ innerText, href });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  try {\n    const { url } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(cors());\napp.use(limiter);\napp.use(express.json());\n\napp.get('/query', async (req, res) => {\n  const { url, selector } = req.query;\n  if (!url || !selector) {\n    return res.status(400).send('URL and selector are required');\n  }\n  try {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const elements = await page.evaluate(selector => {\n      const elements = document.querySelectorAll(selector);\n      return Array.from(elements).map(el => {\n        return {\n          innerText: el.innerText,\n          href: el.href\n        };\n      });\n    }, selector);\n    await browser.close();\n    res.json(elements);\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  const { url } = req.query;\n  if (!url) {\n    return res.status(400).send('URL is required');\n  }\n  try {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).send(error.message);\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst cors = require('cors');\nconst puppeteer = require('puppeteer');\nconst path = require('path');\n\nconst app = express();\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use(cors());\napp.use(limiter);\n\napp.get('/query', async (req, res) => {\n  try {\n    const { url, elements } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const results = await page.evaluate((elements) => {\n      return elements.map((element) => {\n        const el = document.querySelector(element);\n        return {\n          innerText: el ? el.innerText : '',\n          href: el ? el.href : ''\n        };\n      });\n    }, elements.split(','));\n    await browser.close();\n    res.json(results);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.get('/fullHtml', async (req, res) => {\n  try {\n    const { url } = req.query;\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(url, { waitUntil: 'networkidle2' });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a JavaScript function that initializes and configures an Express server with middleware, route handling, and environment-specific settings, then starts the server on a specified port.\n\nFunction Description: The function `createAndConfigureServer` initializes an Express server, configures middleware for request processing, sets up view engines, defines route handlers, and applies environment-specific configurations. The function `startServer` takes the configured server instance and starts it on the specified port.\n\nInput: \n- `port` (Number) - The port number on which the server should listen.\n\nOutput: \n- `app` (Object) - The configured Express server instance (returned by `createAndConfigureServer`).\n- Server startup log message (output by `startServer`).\n\nMethods:\n- `createAndConfigureServer()` -> Object - Creates and configures an Express server with middleware, routes, and environment settings.\n- `startServer(app, port)` -> undefined - Starts the Express server on the specified port and logs the server status.",
    "Canonical_solution": "var express = require('express');\nvar routes = require('./routes');\n\nfunction createAndConfigureServer() {\n    var app = express.createServer();\n    \n    app.configure(function(){\n        app.set('views', __dirname + '/views');\n        app.set('view engine', 'jade');\n        app.use(express.bodyParser());\n        app.use(express.methodOverride());\n        app.use(app.router);\n        app.use(express.static(__dirname + '/public'));\n    });\n\n    app.configure('development', function(){\n        app.use(express.errorHandler({ dumpExceptions: true, showStack: true })); \n    });\n\n    app.configure('production', function(){\n        app.use(express.errorHandler()); \n    });\n\n    app.get('/', routes.index);\n    \n    return app;\n}\n\nfunction startServer(app, port) {\n    app.listen(port);\n    console.log(\"Express server listening on port %d in %s mode\", app.address().port, app.settings.env);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\napp.get('/', (req, res) => {\n  res.render('index');\n});\n\napp.listen(process.env.PORT || 3000, () => {\n  console.log(`Server is running on port ${process.env.PORT || 3000}`);\n});\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\napp.get('/', (req, res) => {\n  res.render('index');\n});\n\napp.post('/data', (req, res) => {\n  res.send('Data received');\n});\n\nconst createAndConfigureServer = () => {\n  return app;\n};\n\nconst startServer = (app, port) => {\n  app.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n};\n\nmodule.exports = { createAndConfigureServer, startServer };\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\nconst routes = require('./routes');\napp.use('/', routes);\n\nconst PORT = process.env.PORT || 3000;\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\nconst routes = require('./routes');\napp.use('/', routes);\n\nconst PORT = process.env.PORT || 3000;\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\nconst routes = require('./routes');\napp.use('/', routes);\n\nconst PORT = process.env.PORT || 3000;\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\nconst routes = require('./routes');\napp.use('/', routes);\n\nconst PORT = process.env.PORT || 3000;\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\nconst routes = require('./routes');\napp.use('/', routes);\n\nconst PORT = process.env.PORT || 3000;\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\nconst routes = require('./routes');\napp.use('/', routes);\n\nconst PORT = process.env.PORT || 3000;\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\nconst routes = require('./routes');\napp.use('/', routes);\n\nconst PORT = process.env.PORT || 3000;\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\n\nconst routes = require('./routes');\napp.use('/', routes);\n\nconst PORT = process.env.PORT || 3000;\n\nfunction createAndConfigureServer() {\n  return app;\n}\n\nfunction startServer(app, port) {\n  app.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nmodule.exports = { createAndConfigureServer, startServer };\n```"
    ],
    "match_count": 2,
    "pass@3": 0.5333333333333333,
    "pass@5": 0.7777777777777778
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a function to set up an Express.js server with middleware configuration, route handling, and database synchronization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with CORS support, request body parsing, and database synchronization. It configures middleware, defines basic routes, and starts the server on a specified port. The server integrates authentication and user management routes from external modules.\n\nInput: None (The function takes no parameters as it's self-contained for server setup)\n\nOutput: None (The function doesn't return anything but starts a server process that listens on the specified port)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const bodyParser = require(\"body-parser\");\n    const cors = require(\"cors\");\n\n    const app = express();\n\n    var corsOptions = {\n        origin: \"http://localhost:8081\"\n    };\n\n    app.use(cors(corsOptions));\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: true }));\n\n    const db = require(\"./app/models\");\n    const Role = db.role;\n\n    db.sequelize.sync();\n\n    app.get(\"/\", (req, res) => {\n        res.json({ message: \"Welcome to bezkoder application.\" });\n    });\n\n    require('./app/routes/auth.routes')(app);\n    require('./app/routes/user.routes')(app);\n\n    const PORT = process.env.PORT || 8080;\n    app.listen(PORT, () => {\n        console.log(`Server is running on port ${PORT}.`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [],
    "unmatched_results": [
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./authRoutes');\nconst userRoutes = require('./userRoutes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./routes/auth');\nconst userRoutes = require('./routes/user');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./authRoutes');\nconst userRoutes = require('./userRoutes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./routes/auth');\nconst userRoutes = require('./routes/user');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./authRoutes');\nconst userRoutes = require('./userRoutes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst dbSync = require('./databaseSync');\nconst authRoutes = require('./authRoutes');\nconst userRoutes = require('./userRoutes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\ndbSync.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./authRoutes');\nconst userRoutes = require('./userRoutes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./authRoutes');\nconst userRoutes = require('./userRoutes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./routes/auth');\nconst userRoutes = require('./routes/user');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./database');\nconst authRoutes = require('./authRoutes');\nconst userRoutes = require('./userRoutes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\ndb.sync();\n\napp.use('/auth', authRoutes);\napp.use('/user', userRoutes);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server using the Express framework in JavaScript, with middleware configurations for request processing and static file serving.\n\nFunction Description: The function `createServer` initializes an Express application, configures various middleware for logging, request parsing, and static file serving, and starts an HTTP server listening on a specified port. It also includes environment-specific error handling for development mode.\n\nInput: None (The function does not take any parameters; it uses environment variables like `process.env.PORT` for configuration.)\n\nOutput: None (The function does not return any value; it starts an HTTP server that listens on the specified port and logs a message upon successful startup.)",
    "Canonical_solution": "function createServer() {\n    var express = require('express');\n    var http = require('http');\n    var path = require('path');\n\n    var app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.favicon());\n    app.use(express.logger('dev'));\n    app.use(express.json());\n    app.use(express.urlencoded());\n    app.use(express.methodOverride());\n    app.use(express.static(path.join(__dirname, '/public')));\n    app.use(express.static(path.join(__dirname, '/tests')));\n\n    if ('development' == app.get('env')) {\n        app.use(express.errorHandler());\n    }\n\n    http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express server listening on port ' + app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [],
    "unmatched_results": [
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(err.stack);\n  }\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(err.stack);\n  }\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(err.stack);\n  }\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(err.stack);\n  }\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(err.stack);\n  }\n  res.status(500).send('Something broke!');\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(err.stack);\n  }\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(err.stack);\n  }\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.error(err.stack);\n  }\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with essential middleware (CORS, static file serving, JSON body parsing), configures route handlers, and starts listening on a specified port. It handles both API routes and serves static HTML files.\n\nInput: None (The function uses imported modules and configuration from './src/config' and './src/routes')\n\nOutput: None (The function's side effect is starting an HTTP server that listens on the configured port)",
    "Canonical_solution": "function setupExpressServer() {\n    const bodyParser = require('body-parser');\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const config = require('./src/config');\n    const routes = require('./src/routes');\n\n    const app = express();\n\n    app.enable('trust proxy');\n    app.use(cors());\n    app.use(express.static(path.join(__dirname, 'www')));\n    app.use(bodyParser.json());\n\n    app.get('/v2', (req, res) => res.sendFile(path.join(__dirname, 'www/index.html')));\n    app.use(routes);\n\n    app.listen(config.PORT, err => {\n        if (err) console.error(err);\n        console.log('Server started on ' + config.PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [],
    "unmatched_results": [
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', routes);\n\napp.listen(config.port, () => {\n  console.log(`Server is running on port ${config.port}`);\n});"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a target API while modifying request and response headers.\n\nFunction Description: The function `createProxyServer` initializes an Express application that acts as a proxy server. It configures middleware to forward all incoming requests to a specified target API (https://api.openai.com in this case), removes certain headers from outgoing requests, and adds CORS headers to responses. The server listens on port 9000 by default.\n\nInput: None (The function takes no parameters as all configurations are hardcoded)\n\nOutput: None (The function doesn't return anything but starts a server process that continues running)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('http-proxy-middleware');\n    const app = express();\n    const port = 9000;\n\n    app.use('/', createProxyMiddleware({\n        target: 'https://api.openai.com',\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('x-forwarded-for');\n            proxyReq.removeHeader('x-real-ip');\n        },\n        onProxyRes: function (proxyRes, req, res) {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n        }\n    }));\n\n    app.listen(port, () => {\n        console.log(`Example app listening at http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\napp.use(httpProxy('/api', {\n  target: 'https://api.openai.com',\n  changeOrigin: true,\n  onProxyReq: (proxyReq, req, res) => {\n    proxyReq.removeHeader('Host');\n    proxyReq.removeHeader('Cookie');\n  },\n  onProxyRes: (proxyRes, req, res) => {\n    proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n  }\n}));\n\napp.listen(9000);",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\napp.use(httpProxy({\n  target: 'https://api.openai.com',\n  changeOrigin: true,\n  onProxyReq: (proxyReq, req, res) => {\n    proxyReq.removeHeader('Host');\n    proxyReq.removeHeader('Cookie');\n  },\n  onProxyRes: (proxyRes, req, res) => {\n    proxyRes.on('header', (name, value) => {\n      if (name.toLowerCase() === 'content-type') {\n        res.setHeader(name, value);\n      }\n    });\n    res.setHeader('Access-Control-Allow-Origin', '*');\n  }\n}));\n\napp.listen(9000);",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\napp.use(httpProxy('/api', {\n  target: 'https://api.openai.com',\n  changeOrigin: true,\n  onProxyReq: (proxyReq, req, res) => {\n    proxyReq.removeHeader('Host');\n    proxyReq.removeHeader('Cookie');\n  },\n  onProxyRes: (proxyRes, req, res) => {\n    proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n  }\n}));\n\napp.listen(9000);",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\napp.use(httpProxy({\n  target: 'https://api.openai.com',\n  changeOrigin: true,\n  onProxyReq: (proxyReq, req, res) => {\n    proxyReq.removeHeader('Host');\n    proxyReq.removeHeader('Cookie');\n  },\n  onProxyRes: (proxyRes, req, res) => {\n    proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n  }\n}));\n\napp.listen(9000);",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\napp.use(httpProxy('/api', {\n  target: 'https://api.openai.com',\n  changeOrigin: true,\n  onProxyReq: (proxyReq, req, res) => {\n    proxyReq.removeHeader('Host');\n    proxyReq.removeHeader('Cookie');\n  },\n  onProxyRes: (proxyRes, req, res) => {\n    proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n  }\n}));\n\napp.listen(9000);"
    ],
    "unmatched_results": [
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\nconst createProxyServer = () => {\n  const proxy = httpProxy({\n    target: 'https://api.openai.com',\n    changeOrigin: true,\n    onProxyReq: (proxyReq, req, res) => {\n      proxyReq.removeHeader('Host');\n      proxyReq.removeHeader('Cookie');\n    },\n    onProxyRes: (proxyRes, req, res) => {\n      proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n    }\n  });\n\n  app.use('/proxy', proxy);\n  app.listen(9000);\n};\n\ncreateProxyServer();",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\nconst createProxyServer = () => {\n  const apiProxy = httpProxy({\n    target: 'https://api.openai.com',\n    changeOrigin: true,\n    onProxyReq: (proxyReq, req, res) => {\n      proxyReq.removeHeader('Host');\n      proxyReq.removeHeader('Cookie');\n    },\n    onProxyRes: (proxyRes, req, res) => {\n      proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n    }\n  });\n\n  app.use('/proxy', apiProxy);\n  app.listen(9000);\n};\n\ncreateProxyServer();",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\nconst createProxyServer = () => {\n  const proxy = httpProxy({\n    target: 'https://api.openai.com',\n    changeOrigin: true,\n    onProxyReq: (proxyReq, req, res) => {\n      proxyReq.removeHeader('Host');\n      proxyReq.removeHeader('Cookie');\n    },\n    onProxyRes: (proxyRes, req, res) => {\n      proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n    }\n  });\n\n  app.use('/proxy', proxy);\n  app.listen(9000);\n};\n\ncreateProxyServer();",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\nconst createProxyServer = () => {\n  const proxy = httpProxy({\n    target: 'https://api.openai.com',\n    changeOrigin: true,\n    onProxyReq: (proxyReq, req, res) => {\n      proxyReq.removeHeader('Host');\n      proxyReq.removeHeader('Cookie');\n    },\n    onProxyRes: (proxyRes, req, res) => {\n      proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n    }\n  });\n\n  app.use('/proxy', proxy);\n  app.listen(9000);\n};\n\ncreateProxyServer();",
      "const express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst app = express();\n\nconst createProxyServer = () => {\n  const apiProxy = httpProxy({\n    target: 'https://api.openai.com',\n    changeOrigin: true,\n    onProxyReq: (proxyReq, req, res) => {\n      proxyReq.removeHeader('Host');\n      proxyReq.removeHeader('Cookie');\n    },\n    onProxyRes: (proxyRes, req, res) => {\n      proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n    }\n  });\n\n  app.use('/api', apiProxy);\n  app.listen(9000);\n};\n\ncreateProxyServer();"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a function to set up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with static file serving, request body parsing middleware, and route handlers for GET and POST requests. It starts the server on a specified port and logs the server's startup information.\n\nInput: None (The function doesn't take any explicit parameters. Port configuration would typically be set via `app.set('port', ...)` before calling this function.)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that listens on the specified port.)",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var app = express();\n\n    // Configure middleware\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    // Define routes\n    app.get('/', function(req, res) {\n        res.render('home');\n    });\n\n    app.post('/process', function(req, res) {\n        if(req.xhr || req.accepts('json,html')==='json'){\n            res.send({ success: true });\n        } else {\n            res.redirect(303, '/thank-you');\n        }\n    });\n\n    // Start server\n    app.listen(app.get('port'), function() {\n        console.log('Express started on http://localhost:' + app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/data', (req, res) => {\n  res.json(req.body);\n});\n\nconst port = process.env.PORT || 3000;\napp.set('port', port);\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.post('/', (req, res) => res.send('POST request to the homepage'));\nconst port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Server running on port ${port}`));",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/data', (req, res) => {\n  res.send('Data received');\n});\n\nconst port = process.env.PORT || 3000;\napp.set('port', port);\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.post('/', (req, res) => res.send('POST request to the homepage'));\nconst port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Server running on port ${port}`));",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.post('/', (req, res) => res.send('POST request to the homepage'));\nconst port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Server running on port ${port}`));",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.post('/', (req, res) => res.send('POST request to the homepage'));\nconst port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Server running on port ${port}`));",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.post('/', (req, res) => res.send('POST request to the homepage'));\nconst port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Server running on port ${port}`));",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.post('/', (req, res) => res.send('POST request to the homepage'));\nconst port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Server running on port ${port}`));",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.post('/', (req, res) => res.send('POST request to the homepage'));\nconst port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Server running on port ${port}`));",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.post('/', (req, res) => {\n  res.send('POST request to the homepage');\n});\n\nconst port = process.env.PORT || 3000;\napp.set('port', port);\n\napp.listen(port, () => {\n  console.log(`Server is running on http://localhost:${port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a function that starts an HTTP server using Express to serve static files and provide JSON data, while also opening the default browser to the server's URL.\n\nFunction Description: The function `startServer` initializes an Express application, configures middleware for serving static files, sets up route handlers for the root path and a data endpoint, and starts the server on a specified port. It also opens the server URL in the default browser and logs status messages to the console.\n\nInput:\n- `data`: [Object] - The JSON data to be served at the '/getstats' endpoint\n- `port`: [Number] - The port number on which the server should listen\n- `update`: [Function] - (Optional) A callback function to be executed when the server starts\n\nOutput:\n- None (The function starts a server process and does not return a value)",
    "Canonical_solution": "function startServer(data, port, update) {\n    const express = require('express');\n    const path = require('path');\n    const opener = require('opener');\n    const colors = require('colors');\n\n    const app = express();\n    const url = `http://localhost:${port}/`;\n    const options = {\n        root: path.join(__dirname, '..', 'build')\n    };\n\n    app.use(express.static(options.root));\n    app.use('/css', express.static(path.join(__dirname, '..', 'build', 'css')));\n\n    app.get('/', (req, res) => {\n        res.sendFile('index.html', options);\n    });\n\n    app.get('/getstats', (req, res) => {\n        res.json(data);\n    });\n\n    app.listen(port, () => {\n        opener(url);\n        console.log(\n            colors.bold('\\nWebpack-Monitor'),\n            `is running on port ${port}!`\n        );\n        console.log(colors.italic.red('Press ctrl C to exit'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\nconst http = require('http');\nconst open = require('open');\n\nfunction startServer(data, port, update) {\n  const app = express();\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/', (req, res) => {\n    res.send('Welcome to the server!');\n  });\n\n  app.get('/getstats', (req, res) => {\n    res.json(data);\n  });\n\n  const server = http.createServer(app);\n  server.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n    if (update) {\n      update();\n    }\n    open(`http://localhost:${port}`);\n  });\n}",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst open = require('open');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n  open(`http://localhost:${port}`);\n  if (update) update();\n});\n```",
      "const express = require('express');\nconst path = require('path');\nconst open = require('open');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n  open(`http://localhost:${port}`);\n  if (update) update();\n});",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst open = require('open');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n  if (update) update();\n  open(`http://localhost:${port}`);\n});\n```",
      "const express = require('express');\nconst path = require('path');\nconst open = require('open');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n  if (update) update();\n  open(`http://localhost:${port}`);\n});",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst open = require('open');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n  open(`http://localhost:${port}`);\n  if (typeof update === 'function') {\n    update();\n  }\n});\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst open = require('open');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n  open(`http://localhost:${port}`);\n  if (update) update();\n});\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst open = require('open');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n  open(`http://localhost:${port}`);\n  if (typeof update === 'function') {\n    update();\n  }\n});\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst open = require('open');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n  if (update) update();\n  open(`http://localhost:${port}`);\n});\n```",
      "const express = require('express');\nconst path = require('path');\nconst http = require('http');\nconst open = require('open');\n\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the server!');\n});\n\napp.get('/getstats', (req, res) => {\n  res.json(data);\n});\n\nconst server = http.createServer(app);\n\nserver.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n  if (update) {\n    update();\n  }\n  open(`http://localhost:${port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a function to set up an Express server that handles HTTP requests for Wikipedia summaries, including CORS configuration and route handling.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures CORS middleware with specific options, defines a route handler for GET requests to '/wikipedia_summaries', and starts the server on a specified port. The route handler retrieves Wikipedia links based on a keyword, fetches summaries and categories for those links, and returns them as JSON.\n\nInput: None (The function does not take any direct input parameters, but the route handler within the function processes query parameters from the HTTP request.)\n\nOutput: None (The function does not return a value, but it starts an HTTP server that listens on the specified port and responds to requests with JSON data.)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const cors = require('cors');\n    const axios = require('axios');\n    \n    const app = express();\n    \n    const corsOptions = {\n        origin: ['https://neurite.network', 'http://localhost:8080'],\n        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n        credentials: true,\n        optionsSuccessStatus: 204\n    };\n    \n    app.use(cors(corsOptions));\n    \n    app.get('/wikipedia_summaries', async (req, res) => {\n        const keyword = req.query.keyword;\n        const topNLinks = parseInt(req.query.top_n_links) || 2;\n        const srwhat = req.query.srwhat || null;\n        const srsort = req.query.srsort || 'relevance';\n        const exsentences = parseInt(req.query.exsentences) || 3;\n        const topExsentences = parseInt(req.query.top_exsentences) || 6;\n        const topNCategories = parseInt(req.query.top_n_categories) || 5;\n        \n        const topLinks = await getWikipediaLinks(keyword, topNLinks, srwhat, srsort);\n        const selectedLinks = topLinks.slice(0, topNLinks);\n        \n        const summaries = await Promise.all(\n            selectedLinks.map(async (link, i) => {\n                const summaryExsentences = i === 0 ? topExsentences : exsentences;\n                const summary = await getWikipediaSummary(link, summaryExsentences);\n                const cleanSummary = removeHtmlTags(summary);\n                const categories = await getWikipediaCategories(link, keyword, topNCategories);\n                return { title: link, summary: cleanSummary, categories };\n            })\n        );\n        \n        res.json(summaries);\n    });\n    \n    const port = process.env.PORT || 5000;\n    app.listen(port, () => {\n        console.log(`Server is running on port ${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\n\nconst app = express();\napp.use(cors({ origin: 'http://localhost:3000' }));\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n  const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=extracts|pageimages&format=json&exintro&explaintext&piprop=original&pipropinfo=thumbnail|original&titles=${encodeURIComponent(keyword)}`);\n  const data = await response.json();\n  const pages = data.query.pages;\n  const summaries = {};\n  for (const pageId in pages) {\n    const page = pages[pageId];\n    summaries[pageId] = {\n      summary: page.extract,\n      categories: page.categories ? page.categories.map(category => category.title) : []\n    };\n  }\n  res.json(summaries);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\n\nconst app = express();\napp.use(cors({ origin: 'http://localhost:3000' }));\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n  const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=extracts|pageimages&format=json&exintro=1&explaintext=1&piprop=original&pipropwidth=200&pithumbsize=200&titles=${encodeURIComponent(keyword)}`);\n  const data = await response.json();\n  const pages = data.query.pages;\n  const summaries = {};\n  for (const pageId in pages) {\n    const page = pages[pageId];\n    summaries[pageId] = {\n      summary: page.extract,\n      categories: page.categories ? page.categories.map(category => category.title) : []\n    };\n  }\n  res.json(summaries);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\n\nconst app = express();\napp.use(cors({ origin: 'http://localhost:3000' }));\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n  const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=extracts|pageimages&format=json&exintro=1&explaintext=1&piprop=original&pipropwidth=200&pithumbsize=200&titles=${encodeURIComponent(keyword)}`);\n  const data = await response.json();\n  const pages = data.query.pages;\n  const summaries = {};\n  for (const pageId in pages) {\n    const page = pages[pageId];\n    summaries[pageId] = {\n      summary: page.extract,\n      categories: page.categories ? page.categories.map(category => category.title) : []\n    };\n  }\n  res.json(summaries);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\n\nconst app = express();\napp.use(cors({ origin: 'http://localhost:3000' }));\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n  try {\n    const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=extracts|pageimages|categories&format=json&exintro=1&exsentences=3&exlimit=1&piprop=thumbnail&pithumbsize=100&titles=${encodeURIComponent(keyword)}`);\n    const data = await response.json();\n    const pages = data.query.pages;\n    const summaries = Object.values(pages).map(page => ({\n      title: page.title,\n      summary: page.extract,\n      categories: page.categories ? page.categories.map(category => category.title) : []\n    }));\n    res.json(summaries);\n  } catch (error) {\n    res.status(500).json({ error: 'Error fetching Wikipedia data' });\n  }\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\nconst app = express();\n\napp.use(cors({ origin: 'http://localhost:3000' }));\n\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n\n  const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=extracts|pageimages&format=json&exintro=1&explaintext=1&piprop=original&pipropwidth=200&pithumbsize=200&titles=${encodeURIComponent(keyword)}`);\n  const data = await response.json();\n  const pages = data.query.pages;\n\n  const summaries = Object.keys(pages).map(pageId => {\n    const page = pages[pageId];\n    return {\n      title: page.title,\n      summary: page.extract,\n      image: page.thumbnail ? page.thumbnail.source : null\n    };\n  });\n\n  res.json(summaries);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\nconst app = express();\n\napp.use(cors({\n  origin: 'http://localhost:3000',\n  optionsSuccessStatus: 200\n}));\n\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n\n  const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&format=json&prop=extracts|pageimages|pageprops&exintro&explaintext&redirects=1&titles=${encodeURIComponent(keyword)}`);\n  const data = await response.json();\n  const pages = data.query.pages;\n\n  const summaries = Object.values(pages).map(page => ({\n    title: page.title,\n    summary: page.extract,\n    categories: page.categories ? page.categories.map(category => category.title) : []\n  }));\n\n  res.json(summaries);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\n\nconst app = express();\napp.use(cors({ origin: 'http://localhost:3000' }));\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n  try {\n    const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=extracts|pageimages|categories&format=json&exintro=1&exsentences=3&exlimit=1&piprop=thumbnail&pithumbsize=100&titles=${encodeURIComponent(keyword)}`);\n    const data = await response.json();\n    const pages = data.query.pages;\n    const summaries = Object.values(pages).map(page => ({\n      title: page.title,\n      summary: page.extract,\n      categories: page.categories ? page.categories.map(category => category.title) : []\n    }));\n    res.json(summaries);\n  } catch (error) {\n    res.status(500).json({ error: 'Error fetching Wikipedia data' });\n  }\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\nconst app = express();\n\napp.use(cors({ origin: 'http://localhost:3000' }));\n\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n\n  try {\n    const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&format=json&prop=extracts|pageimages|categories&exintro=true&explaintext=true&redirects=1&titles=${encodeURIComponent(keyword)}`);\n    const data = await response.json();\n    const pages = data.query.pages;\n\n    const summaries = Object.values(pages).map(page => ({\n      title: page.title,\n      summary: page.extract,\n      categories: page.categories ? page.categories.map(category => category.title) : []\n    }));\n\n    res.json(summaries);\n  } catch (error) {\n    res.status(500).json({ error: 'Error fetching Wikipedia data' });\n  }\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\n\nconst app = express();\nconst port = 3000;\n\napp.use(cors({ origin: 'http://localhost:3000' }));\n\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n\n  try {\n    const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=extracts|pageimages&format=json&exintro&piprop=thumbnail&pithumbsize=200&titles=${encodeURIComponent(keyword)}`);\n    const data = await response.json();\n    const pages = data.query.pages;\n    const summaries = Object.values(pages).map(page => ({\n      title: page.title,\n      summary: page.extract,\n      image: page.thumbnail ? page.thumbnail.source : null\n    }));\n    res.json(summaries);\n  } catch (error) {\n    res.status(500).json({ error: 'Error fetching Wikipedia data' });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "const express = require('express');\nconst cors = require('cors');\nconst fetch = require('node-fetch');\n\nconst app = express();\napp.use(cors({ origin: 'http://localhost:3000' }));\napp.get('/wikipedia_summaries', async (req, res) => {\n  const keyword = req.query.keyword;\n  if (!keyword) {\n    return res.status(400).json({ error: 'Keyword is required' });\n  }\n  const response = await fetch(`https://en.wikipedia.org/w/api.php?action=query&prop=extracts|pageimages&format=json&exintro=true&explaintext=true&piprop=original&pipropwidth=200&pithumbsize=200&titles=${encodeURIComponent(keyword)}`);\n  const data = await response.json();\n  const pages = data.query.pages;\n  const summaries = {};\n  for (const pageId in pages) {\n    const page = pages[pageId];\n    summaries[pageId] = {\n      summary: page.extract,\n      categories: page.categories ? page.categories.map(category => category.title) : []\n    };\n  }\n  res.json(summaries);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```typescript\nclass TSClient {\n    search: any;\n    id: string;\n    new_since_id: string;\n\n    constructor(query: string, cb: Function) {\n        this.id = this._generateId(query);\n        this.search = {\n            q: query,\n            since_id: null,\n            rcount: 0\n        };\n        this._loadState();\n        cb(this);\n    }\n\n    syncSearch(callback: Function): void {\n        this._walker({\n            ts: this,\n            search: this.search,\n            cb: callback,\n            page: 1,\n            results: [],\n            new_since_id: null\n        });\n    }\n\n    set(search: any): void {\n        this.search = search;\n        this._saveState();\n    }\n\n    _walker(s: any): void {\n        const { ts, search, cb, page, results, new_since_id } = s;\n        const url = `https://api.twitter.com/1.1/search/tweets.json?q=${search.q}&since_id=${new_since_id}&count=100&page=${page}`;\n        fetch(url)\n            .then(response => response.json())\n            .then(data => {\n                const newResults = data.statuses;\n                const newSinceId = newResults[newResults.length - 1].id_str;\n                results.push(...newResults);\n                if (data.search_metadata.next_results) {\n                    const nextPage = parseInt(data.search_metadata.next_results.match(/page=(\\d+)/)[1]);\n                    ts.new_since_id = newSinceId;\n                    s.page = nextPage;\n                    s.new_since_id = newSinceId;\n                    s.results = results;\n                    ts._walker(s);\n                } else {\n                    cb(results);\n                }\n            })\n            .catch(error => {\n                console.error('Error during search:', error);\n                cb([]);\n            });\n    }\n\n    _generateId(query: string): string {\n        return crypto.createHash('md5').update(query).digest('hex');\n    }\n\n    _loadState(): void {\n        const state = localStorage.getItem(this.id);\n        if (state) {\n            this.search = JSON.parse(state);\n        }\n    }\n\n    _saveState(): void {\n        localStorage.setItem(this.id, JSON.stringify(this.search));\n    }\n}\n```",
      "```typescript\nclass TSClient {\n  search: any;\n  id: string;\n  new_since_id: string;\n\n  constructor(query: string, cb: Function) {\n    this.id = this._generateId(query);\n    this.search = {\n      q: query,\n      since_id: null,\n      rcount: 0,\n      search_id: this.id\n    };\n    this._loadState();\n    cb(this);\n  }\n\n  syncSearch(callback: Function): void {\n    this._walker({\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: null\n    });\n  }\n\n  set(search: any): void {\n    this.search = search;\n    this._saveState();\n  }\n\n  _walker(s: any): void {\n    const { ts, search, cb, page, results, new_since_id } = s;\n    const url = `https://api.twitter.com/1.1/search/tweets.json?q=${search.q}&count=100&since_id=${new_since_id}&page=${page}`;\n    fetch(url)\n      .then(response => response.json())\n      .then(data => {\n        if (data.search_metadata.next_results) {\n          const next_page = data.search_metadata.next_results.match(/page=\\d+/)[0].split('=')[1];\n          s.page = parseInt(next_page);\n          s.new_since_id = data.search_metadata.new_since_id;\n          s.results = results.concat(data.statuses);\n          ts.set({\n            ...search,\n            since_id: data.search_metadata.new_since_id,\n            rcount: search.rcount + data.statuses.length\n          });\n          ts._walker(s);\n        } else {\n          cb(results);\n        }\n      })\n      .catch(error => {\n        console.error('Error during search:', error);\n        cb([]);\n      });\n  }\n\n  _generateId(query: string): string {\n    return crypto.createHash('md5').update(query).digest('hex');\n  }\n\n  _loadState(): void {\n    try {\n      const data = fs.readFileSync(`./state/${this.id}.json`, 'utf8');\n      this.search = JSON.parse(data);\n    } catch (error) {\n      console.error('Failed to load state:', error);\n    }\n  }\n\n  _saveState(): void {\n    try {\n      fs.writeFileSync(`./state/${this.id}.json`, JSON.stringify(this.search), 'utf8');\n    } catch (error) {\n      console.error('Failed to save state:', error);\n    }\n  }\n}\n```",
      "```typescript\nclass TSClient {\n    search: any;\n    id: string;\n    new_since_id: string;\n\n    constructor(query: string, cb: Function) {\n        this.id = this._generateId(query);\n        this.search = this._loadState();\n        this.search.query = query;\n        this.search.rcount = 0;\n        cb(this);\n    }\n\n    syncSearch(callback: Function): void {\n        this._walker({\n            ts: this,\n            search: this.search,\n            cb: callback,\n            page: 1,\n            results: [],\n            new_since_id: null\n        });\n    }\n\n    set(search: any): void {\n        this.search = search;\n        this._saveState(this.search);\n    }\n\n    _walker(s: any): void {\n        const { ts, search, cb, page, results, new_since_id } = s;\n        const url = `https://api.twitter.com/1.1/search/tweets.json?q=${search.query}&count=100&since_id=${new_since_id}&page=${page}`;\n        fetch(url)\n            .then(response => response.json())\n            .then(data => {\n                results.push(...data.statuses);\n                search.rcount += data.statuses.length;\n                if (data.statuses.length === 100) {\n                    s.page++;\n                    s.new_since_id = data.statuses[data.statuses.length - 1].id_str;\n                    ts._walker(s);\n                } else {\n                    cb(results);\n                }\n            })\n            .catch(error => {\n                console.error('Error during search:', error);\n                cb([]);\n            });\n    }\n\n    _generateId(query: string): string {\n        return crypto.createHash('md5').update(query).digest('hex');\n    }\n\n    _loadState(): any {\n        const id = this.id;\n        const state = fs.readFileSync(`./${id}.json`, 'utf8');\n        return JSON.parse(state);\n    }\n\n    _saveState(state: any): void {\n        const id = this.id;\n        fs.writeFileSync(`./${id}.json`, JSON.stringify(state), 'utf8');\n    }\n}\n```",
      "```typescript\nclass TSClient {\n  search: any;\n  id: string;\n  new_since_id: string;\n\n  constructor(query: string, cb: Function) {\n    this.id = this._generateId(query);\n    this.search = {\n      q: query,\n      since_id: null,\n      rcount: 0,\n    };\n    this._loadState();\n    cb(this);\n  }\n\n  syncSearch(callback: Function): void {\n    this._walker({\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: null,\n    });\n  }\n\n  set(search: any): void {\n    this.search = search;\n    this._saveState();\n  }\n\n  _walker(s: any): void {\n    const { ts, search, cb, page, results, new_since_id } = s;\n    const url = `https://api.twitter.com/1.1/search/tweets.json?q=${search.q}&since_id=${new_since_id}&count=100&page=${page}`;\n    fetch(url)\n      .then(response => response.json())\n      .then(data => {\n        results.push(...data.statuses);\n        if (data.search_metadata.next_results) {\n          const next_page = parseInt(data.search_metadata.next_results.match(/page=(\\d+)/)[1]);\n          s.page = next_page;\n          s.new_since_id = data.search_metadata.new_since_id;\n          ts._walker(s);\n        } else {\n          cb(results);\n        }\n      })\n      .catch(error => {\n        console.error('Error during search:', error);\n        cb([]);\n      });\n  }\n\n  _generateId(query: string): string {\n    return crypto.createHash('md5').update(query).digest('hex');\n  }\n\n  _loadState(): void {\n    const state = localStorage.getItem(this.id);\n    if (state) {\n      this.search = JSON.parse(state);\n    }\n  }\n\n  _saveState(): void {\n    localStorage.setItem(this.id, JSON.stringify(this.search));\n  }\n}\n```",
      "```typescript\nclass TSClient {\n  search: any;\n  id: string;\n  new_since_id: string;\n\n  constructor(query: string, cb: Function) {\n    this.id = this._generateId(query);\n    this.search = this._loadState();\n    this.search.query = query;\n    this.search.rcount = 0;\n    this.new_since_id = '';\n    cb(this);\n  }\n\n  syncSearch(callback: Function): void {\n    this._walker({\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: ''\n    });\n  }\n\n  set(search: any): void {\n    this.search = search;\n    this._saveState(this.search);\n  }\n\n  _walker(s: any): void {\n    const { ts, search, cb, page, results, new_since_id } = s;\n    const url = `https://api.twitter.com/1.1/search/tweets.json?q=${search.query}&count=100&since_id=${new_since_id}&page=${page}`;\n    // Fetch and process the results\n    // ...\n    // If there are more results, call _walker with updated parameters\n    // ...\n    // Otherwise, call the callback with the accumulated results\n    cb(results);\n  }\n\n  _generateId(query: string): string {\n    return crypto.createHash('md5').update(query).digest('hex');\n  }\n\n  _loadState(): any {\n    // Load the previous state from local storage or file system\n    // ...\n    return {};\n  }\n\n  _saveState(search: any): void {\n    // Save the search state to local storage or file system\n    // ...\n  }\n}\n```",
      "```typescript\nclass TSClient {\n    search: any;\n    id: string;\n    new_since_id: string;\n\n    constructor(query: string, cb: Function) {\n        this.search = {\n            query: query,\n            since_id: null,\n            rcount: 0,\n            search_id: null\n        };\n        this.id = this._generateId(query);\n        this.new_since_id = null;\n        this._loadState();\n        cb(this);\n    }\n\n    syncSearch(callback: Function): void {\n        this._walker({\n            ts: this,\n            search: this.search,\n            cb: callback,\n            page: 1,\n            results: [],\n            new_since_id: this.new_since_id\n        });\n    }\n\n    set(search: any): void {\n        this.search = search;\n        this._saveState();\n    }\n\n    _walker(s: any): void {\n        // Implementation of _walker method\n    }\n\n    _generateId(query: string): string {\n        // Implementation of _generateId method\n    }\n\n    _loadState(): void {\n        // Implementation of _loadState method\n    }\n\n    _saveState(): void {\n        // Implementation of _saveState method\n    }\n}\n```",
      "```typescript\nclass TSClient {\n  search: any;\n  id: string;\n  new_since_id: string;\n\n  constructor(query: string, cb: Function) {\n    this.id = this._generateId(query);\n    this.search = {\n      query: query,\n      since_id: null,\n      rcount: 0\n    };\n    this._loadState();\n    cb(this);\n  }\n\n  syncSearch(callback: Function): void {\n    this._walker({\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: null\n    });\n  }\n\n  set(search: any): void {\n    this.search = search;\n    this._saveState();\n  }\n\n  _walker(s: any): void {\n    const { ts, search, cb, page, results, new_since_id } = s;\n    const url = `https://api.twitter.com/1.1/search/tweets.json?q=${search.query}&count=100&since_id=${new_since_id}&page=${page}`;\n    fetch(url)\n      .then(response => response.json())\n      .then(data => {\n        const newResults = data.statuses;\n        const newSinceId = newResults[newResults.length - 1].id_str;\n        results.push(...newResults);\n        if (data.search_metadata.next_results) {\n          const nextPage = parseInt(data.search_metadata.next_results.match(/page=(\\d+)/)[1]);\n          ts.new_since_id = newSinceId;\n          s.page = nextPage;\n          s.new_since_id = newSinceId;\n          s.results = results;\n          ts._walker(s);\n        } else {\n          cb(results);\n        }\n      })\n      .catch(error => {\n        console.error('Error during search:', error);\n        cb([]);\n      });\n  }\n\n  _generateId(query: string): string {\n    return crypto.createHash('md5').update(query).digest('hex');\n  }\n\n  _loadState(): void {\n    try {\n      const data = fs.readFileSync(`./${this.id}.json`, 'utf8');\n      this.search = JSON.parse(data);\n    } catch (error) {\n      console.error('Failed to load state:', error);\n    }\n  }\n\n  _saveState(): void {\n    try {\n      fs.writeFileSync(`./${this.id}.json`, JSON.stringify(this.search), 'utf8');\n    } catch (error) {\n      console.error('Failed to save state:', error);\n    }\n  }\n}\n```",
      "```typescript\nclass TSClient {\n  search: any;\n  id: string;\n  new_since_id: string;\n\n  constructor(query: string, cb: Function) {\n    this.id = this._generateId(query);\n    this.search = {\n      q: query,\n      since_id: null,\n      rcount: 0\n    };\n    this._loadState();\n    cb(this);\n  }\n\n  syncSearch(callback: Function): void {\n    this._walker({\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: null\n    });\n  }\n\n  set(search: any): void {\n    this.search = search;\n    this._saveState();\n  }\n\n  _walker(s: any): void {\n    const { ts, search, cb, page, results, new_since_id } = s;\n    const url = `https://api.twitter.com/1.1/search/tweets.json?q=${search.q}&count=100&since_id=${new_since_id || search.since_id}&page=${page}`;\n    fetch(url)\n      .then(response => response.json())\n      .then(data => {\n        results.push(...data.statuses);\n        if (data.search_metadata.next_results) {\n          const next_page = data.search_metadata.next_results.match(/page=\\d+/)[0].split('=')[1];\n          s.page = parseInt(next_page);\n          s.new_since_id = data.search_metadata.new_since_id;\n          ts._walker(s);\n        } else {\n          cb(results);\n        }\n      })\n      .catch(error => {\n        console.error('Error during search:', error);\n        cb([]);\n      });\n  }\n\n  _generateId(query: string): string {\n    return crypto.createHash('md5').update(query).digest('hex');\n  }\n\n  _loadState(): void {\n    try {\n      const data = fs.readFileSync(`./${this.id}.json`, 'utf8');\n      const state = JSON.parse(data);\n      this.search = state.search;\n    } catch (error) {\n      console.error('Failed to load state:', error);\n    }\n  }\n\n  _saveState(): void {\n    try {\n      fs.writeFileSync(`./${this.id}.json`, JSON.stringify({ search: this.search }), 'utf8');\n    } catch (error) {\n      console.error('Failed to save state:', error);\n    }\n  }\n}\n```",
      "```typescript\nclass TSClient {\n    search: any;\n    id: string;\n    new_since_id: string;\n\n    constructor(query: string, cb: Function) {\n        this.id = this._generateId(query);\n        this.search = this._loadState();\n        this.search.query = query;\n        this.search.rcount = 0;\n        cb(this);\n    }\n\n    syncSearch(callback: Function): void {\n        this._walker({\n            ts: this,\n            search: this.search,\n            cb: callback,\n            page: 1,\n            results: [],\n            new_since_id: null\n        });\n    }\n\n    set(search: any): void {\n        this.search = search;\n        this._saveState();\n    }\n\n    _walker(s: any): void {\n        const { ts, search, cb, page, results, new_since_id } = s;\n        const url = `https://api.twitter.com/1.1/search/tweets.json?q=${search.query}&count=100&since_id=${new_since_id || 0}&page=${page}`;\n        // Fetch and process results\n        // ...\n        // If there are more results, call _walker with incremented page\n        // If no more results, call callback with results\n    }\n\n    _generateId(query: string): string {\n        return require('crypto').createHash('md5').update(query).digest('hex');\n    }\n\n    _loadState(): any {\n        // Load state from local storage\n        // ...\n        return {};\n    }\n\n    _saveState(): void {\n        // Save state to local storage\n        // ...\n    }\n}\n```",
      "```typescript\nclass TSClient {\n  search: any;\n  id: string;\n  new_since_id: string;\n\n  constructor(query: string, cb: Function) {\n    this.search = {\n      query: query,\n      since_id: null,\n      rcount: 0,\n      search_id: null\n    };\n    this.id = this._generateId(query);\n    this.new_since_id = null;\n    this._loadState();\n    cb(this);\n  }\n\n  syncSearch(callback: Function): void {\n    this._walker({\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: this.new_since_id\n    });\n  }\n\n  set(search: any): void {\n    this.search = search;\n    this._saveState();\n  }\n\n  _walker(s: any): void {\n    // Implementation of the _walker method\n  }\n\n  _generateId(query: string): string {\n    // Implementation of the _generateId method\n  }\n\n  _loadState(): void {\n    // Implementation of the _loadState method\n  }\n\n  _saveState(): void {\n    // Implementation of the _saveState method\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\n\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```",
      "const express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on http://localhost:${port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on http://localhost:${port}`);\n});",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\n\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\nconst server = app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = server;\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\n\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\nconst server = app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = server;\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\n\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\nconst server = app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = server;\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\n\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\nconst server = app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = server;\n```",
      "const express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additionalRoutes');\n\nconst app = express();\n\napp.use(express.static(path.join(__dirname, '..')));\n\nadditionalRoutes(app);\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server using Express.js, which serves a predefined list of spells and handles CORS (Cross-Origin Resource Sharing) to allow requests from different origins.\n\nFunction Description: The function `startServer` sets up an Express.js server that listens on port 1234. It configures CORS middleware to enable cross-origin requests and defines a single route (`/spell`) that returns a JSON array of spell names. The server starts listening once all configurations are complete.\n\nInput: None. The function does not take any input parameters.\n\nOutput: None. The function does not return any value but starts an HTTP server that logs a message to the console when it begins listening on the specified port.",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const cors = require('cors');\n    \n    const spells = [\n        'Avada Kedavra',\n        'Crucio',\n        'Vulnera Sanentur',\n        'Vingardium Leviosa',\n        'Alohomora'\n    ];\n    \n    const app = express();\n    app.use(cors());\n    app.options('*', cors());\n    \n    app.get('/spell', (req, res) => {\n        res.json(spells);\n    });\n    \n    app.listen(1234, () => {\n        console.log('Listening on port 1234');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst spells = ['Fireball', 'Ice Bolt', 'Heal', 'Teleport'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is running on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\nconst spells = ['Fireball', 'Ice Bolt', 'Heal', 'Teleport'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is running on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\nconst spells = ['Fireball', 'Ice Bolt', 'Heal', 'Teleport'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is listening on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst spells = ['Expelliarmus', 'Lumos', 'Stupefy', 'Avada Kedavra'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is listening on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\nconst spells = ['Expelliarmus', 'Lumos', 'Stupefy', 'Leviosa'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is listening on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst spells = ['Fireball', 'Ice Bolt', 'Heal', 'Teleport'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is running on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\nconst spells = ['Fireball', 'Ice Bolt', 'Heal', 'Teleport'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is running on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\nconst spells = ['Alohomora', 'Expelliarmus', 'Lumos', 'Leviosa'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is running on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst spells = ['Fireball', 'Ice Bolt', 'Heal', 'Teleport'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is running on port 1234');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst app = express();\nconst spells = ['Fireball', 'Ice Bolt', 'Heal', 'Teleport'];\n\napp.use(cors());\napp.get('/spell', (req, res) => {\n  res.json(spells);\n});\n\napp.listen(1234, () => {\n  console.log('Server is running on port 1234');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to efficiently handle large files.\n\nFunction Description: The function `uploadFileViaPipe` streams a file from the local filesystem to an HTTP server using Node.js's built-in `fs` and `http` modules. It utilizes the pipe mechanism to efficiently transfer data without loading the entire file into memory, making it suitable for large files. The function assumes a predefined server port and file path.\n\nInput: \n- None (The function uses hardcoded values for demonstration purposes. In a real implementation, these would typically be parameters.)\n\nOutput: \n- None (The function performs a side effect of uploading a file. Success or failure would typically be handled via callbacks or events in a production implementation.)",
    "Canonical_solution": "function uploadFileViaPipe() {\n    var http = require('http');\n    var fs = require('fs');\n    var path = require('path');\n    \n    var testFilePath = path.join(__dirname, '../fixture/file/binaryfile.tar.gz');\n    var port = common.port;\n\n    var request = http.request({\n        port: port,\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    });\n\n    fs.createReadStream(testFilePath).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "matched_results": [
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nconst serverPort = 8080;\nconst filePath = 'path/to/large/file';\n\nfunction uploadFileViaPipe() {\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n\nuploadFileViaPipe();\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nconst serverPort = 3000;\nconst filePath = 'path/to/large/file';\n\nfunction uploadFileViaPipe() {\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n\nuploadFileViaPipe();\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nconst serverPort = 8080;\nconst filePath = 'path/to/large/file';\n\nfunction uploadFileViaPipe() {\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n\nuploadFileViaPipe();\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nconst serverPort = 8080;\nconst filePath = 'path/to/large/file';\n\nfunction uploadFileViaPipe() {\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n\nuploadFileViaPipe();\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction uploadFileViaPipe() {\n  const filePath = 'path/to/large/file';\n  const serverPort = 3000;\n  const serverUrl = `http://localhost:${serverPort}`;\n\n  const fileStream = fs.createReadStream(filePath);\n  const req = http.request(serverUrl, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nconst serverPort = 3000;\nconst filePath = 'path/to/large/file';\n\nfunction uploadFileViaPipe() {\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n\nuploadFileViaPipe();\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nconst serverPort = 8080;\nconst filePath = 'path/to/large/file';\n\nfunction uploadFileViaPipe() {\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n\nuploadFileViaPipe();\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nconst serverPort = 8080;\nconst filePath = 'path/to/large/file';\n\nfunction uploadFileViaPipe() {\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n\nuploadFileViaPipe();\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nconst serverPort = 8080;\nconst filePath = 'path/to/large/file.txt';\n\nfunction uploadFileViaPipe() {\n  const fileStream = fs.createReadStream(filePath);\n  const req = http.request({\n    hostname: 'localhost',\n    port: serverPort,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  }, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req, { end: true });\n}\n\nuploadFileViaPipe();\n```",
      "const fs = require('fs');\nconst http = require('http');\n\nconst uploadFileViaPipe = () => {\n  const filePath = 'path/to/large/file';\n  const serverPort = 8080;\n  const serverUrl = `http://localhost:${serverPort}`;\n\n  const fileStream = fs.createReadStream(filePath);\n  const req = http.request(serverUrl, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n};"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function uploads a specified file to a server using Node.js's filesystem and HTTP modules. It streams the file content directly to the HTTP request using pipe(), avoiding loading the entire file into memory. The function sets appropriate headers including content-type (multipart/form-data) and content-length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart form data\n\nOutput: None (The function makes an HTTP request but doesn't return any value. The actual upload result would be handled by the server's response, which isn't captured in this function.)",
    "Canonical_solution": "function uploadFile() {\n  const fs = require('fs');\n  const http = require('http');\n  \n  const stat = fs.statSync(FIXTURE);\n  const request = http.request({\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'content-length': stat.size,\n    },\n  });\n  \n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "matched_results": [
      "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const fileStream = fs.createReadStream(FIXTURE);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(FIXTURE).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\nconst path = require('path');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const filePath = path.resolve(FIXTURE);\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(filePath).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\nconst path = require('path');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const filePath = path.resolve(FIXTURE);\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(filePath).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const fileStream = fs.createReadStream(FIXTURE);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(FIXTURE).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const fileStream = fs.createReadStream(FIXTURE);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(FIXTURE).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const fileStream = fs.createReadStream(FIXTURE);\n  const req = http.request({\n    hostname: 'localhost',\n    port: TEST_PORT,\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(FIXTURE).size\n    }\n  }, res => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', chunk => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', e => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const fileStream = fs.createReadStream(FIXTURE);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(FIXTURE).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\nconst path = require('path');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const filePath = path.resolve(FIXTURE);\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(filePath).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const fileStream = fs.createReadStream(FIXTURE);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(FIXTURE).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n\n  fileStream.pipe(req, { end: true });\n}",
      "const fs = require('fs');\nconst http = require('http');\nconst path = require('path');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const filePath = path.resolve(FIXTURE);\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fs.statSync(filePath).size\n    }\n  };\n\n  const req = http.request(`http://localhost:${TEST_PORT}`, options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n\n  fileStream.pipe(req, { end: true });\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Implement a function to upload a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function should create a readable stream from a specified file and pipe it directly to an HTTP POST request. This approach avoids loading the entire file into memory, making it suitable for large files. The function should set appropriate headers including content type (multipart/form-data) and content length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart/form-data content type\n\nOutput: None (The function streams the file directly to the HTTP request without returning any value)",
    "Canonical_solution": "function uploadFile() {\n  var fs = require('fs'),\n      http = require('http'),\n      stat = fs.statSync(FIXTURE),\n      request = http.request({\n        port: TEST_PORT,\n        path: '/',\n        method: 'POST',\n        headers: {\n          'content-type': 'multipart/form-data; boundary='+BOUNDARY,\n          'content-length': stat.size,\n        },\n      });\n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nfrom requests_toolbelt.multipart.encoder import MultipartEncoder\n\ndef upload_file(FIXTURE, TEST_PORT, BOUNDARY):\n    with open(FIXTURE, 'rb') as file:\n        fields = {'file': (FIXTURE, file, 'application/octet-stream')}\n        multipart_encoder = MultipartEncoder(fields=fields, boundary=BOUNDARY)\n        response = requests.post(f'http://localhost:{TEST_PORT}', data=multipart_encoder, headers={'Content-Type': multipart_encoder.content_type})\n```",
      "```python\nimport http.client\nimport os\nimport shutil\nfrom urllib.parse import quote_plus\n\ndef upload_file(fixture, test_port, boundary):\n    client = http.client.HTTPConnection('localhost', test_port)\n    client.request('POST', '/upload', body=generate_multipart_body(fixture, boundary), headers={'Content-Type': f'multipart/form-data; boundary={boundary}'})\n    response = client.getresponse()\n    client.close()\n\ndef generate_multipart_body(file_path, boundary):\n    file_name = os.path.basename(file_path)\n    file_size = os.path.getsize(file_path)\n    file_content_type = 'application/octet-stream'\n    file_content_disposition = f'form-data; name=\"file\"; filename=\"{quote_plus(file_name)}\"'\n    \n    body = f'--{boundary}\\r\\n'\n    body += f'Content-Disposition: {file_content_disposition}\\r\\n'\n    body += f'Content-Type: {file_content_type}\\r\\n\\r\\n'\n    \n    with open(file_path, 'rb') as file:\n        body += file.read()\n    \n    body += f'\\r\\n--{boundary}--\\r\\n'\n    return body\n```",
      "```python\nimport requests\nfrom requests_toolbelt.multipart.encoder import MultipartEncoder\n\ndef upload_file(FIXTURE, TEST_PORT, BOUNDARY):\n    with open(FIXTURE, 'rb') as f:\n        files = {'file': (FIXTURE, f, 'application/octet-stream')}\n        response = requests.post(f'http://localhost:{TEST_PORT}', files=files)\n```",
      "```python\nimport requests\nfrom requests_toolbelt.multipart.encoder import MultipartEncoder\nimport os\n\ndef upload_file(FIXTURE, TEST_PORT, BOUNDARY):\n    with open(FIXTURE, 'rb') as f:\n        files = {'file': ('filename', f, 'application/octet-stream')}\n        response = requests.post(f'http://localhost:{TEST_PORT}', files=files)\n```",
      "```python\nimport http.client\nimport os\nimport shutil\nfrom urllib.parse import quote_plus\n\ndef upload_file(fixture, test_port, boundary):\n    client = http.client.HTTPConnection('localhost', test_port)\n    with open(fixture, 'rb') as file:\n        headers = {\n            'Content-Type': f'multipart/form-data; boundary={boundary}',\n            'Content-Length': os.path.getsize(fixture)\n        }\n        client.request('POST', '/upload', body=file, headers=headers)\n    client.getresponse()\n    client.close()\n```",
      "```python\nimport http.client\nimport os\nimport urllib.parse\n\ndef upload_file(fixture, test_port, boundary):\n    client = http.client.HTTPConnection('localhost', test_port)\n    file_size = os.path.getsize(fixture)\n    file_name = os.path.basename(fixture)\n    file_path = urllib.parse.quote_plus(file_name)\n    headers = {\n        'Content-Type': f'multipart/form-data; boundary={boundary}',\n        'Content-Length': file_size\n    }\n    with open(fixture, 'rb') as file:\n        client.request('POST', f'/upload?file={file_path}', body=file, headers=headers)\n    client.getresponse()\n    client.close()\n```",
      "```python\nimport http.client\nimport os\nfrom urllib.parse import quote_plus\nfrom streamlit.report_html import report_html\n\ndef upload_file(fixture, test_port, boundary):\n    client = http.client.HTTPConnection(f'localhost:{test_port}')\n    file_path = fixture\n    file_name = os.path.basename(file_path)\n    file_size = os.path.getsize(file_path)\n    content_type = 'multipart/form-data; boundary=' + boundary\n\n    with open(file_path, 'rb') as file:\n        headers = {\n            'Content-Type': content_type,\n            'Content-Length': file_size\n        }\n        client.request('POST', '/upload', body=file, headers=headers)\n    client.close()\n```",
      "```python\nimport http.client\nimport os\nimport mimetypes\nimport shutil\n\ndef upload_file(FIXTURE, TEST_PORT, BOUNDARY):\n    client = http.client.HTTPConnection('localhost', TEST_PORT)\n    client.request('POST', '/upload', body=generate_multipart_data(FIXTURE, BOUNDARY), headers={'Content-Type': f'multipart/form-data; boundary={BOUNDARY}'})\n    response = client.getresponse()\n    client.close()\n\ndef generate_multipart_data(file_path, boundary):\n    file_name = os.path.basename(file_path)\n    file_type, _ = mimetypes.guess_type(file_name)\n    file_type = file_type or 'application/octet-stream'\n    file_size = os.path.getsize(file_path)\n    file_stream = open(file_path, 'rb')\n    file_data = file_stream.read()\n    file_stream.close()\n\n    body = f'--{boundary}\\r\\n'\n    body += f'Content-Disposition: form-data; name=\"file\"; filename=\"{file_name}\"\\r\\n'\n    body += f'Content-Type: {file_type}\\r\\n'\n    body += f'Content-Transfer-Encoding: binary\\r\\n'\n    body += f'Content-Length: {file_size}\\r\\n\\r\\n'\n    body += file_data\n    body += f'\\r\\n--{boundary}--\\r\\n'\n    return body\n```",
      "```python\nimport http.client\nimport os\nimport mimetypes\n\ndef upload_file(fixture, test_port, boundary):\n    client = http.client.HTTPConnection('localhost', test_port)\n    client.request('POST', '/upload', body=generate_multipart_body(fixture, boundary), headers={'Content-Type': f'multipart/form-data; boundary={boundary}'})\n    response = client.getresponse()\n    client.close()\n\ndef generate_multipart_body(file_path, boundary):\n    file_name = os.path.basename(file_path)\n    file_type, _ = mimetypes.guess_type(file_name)\n    file_type = file_type if file_type else 'application/octet-stream'\n    file_size = os.path.getsize(file_path)\n    body = f'--{boundary}\\r\\n'\n    body += f'Content-Disposition: form-data; name=\"file\"; filename=\"{file_name}\"\\r\\n'\n    body += f'Content-Type: {file_type}\\r\\n'\n    body += f'Content-Transfer-Encoding: binary\\r\\n'\n    body += f'Content-Length: {file_size}\\r\\n\\r\\n'\n    with open(file_path, 'rb') as file:\n        body += file.read()\n    body += f'\\r\\n--{boundary}--\\r\\n'\n    return body\n```",
      "```python\nimport http.client\nimport os\nimport shutil\nimport urllib.parse\n\ndef upload_file(fixture, test_port, boundary):\n    client = http.client.HTTPConnection('localhost', test_port)\n    file_size = os.path.getsize(fixture)\n    with open(fixture, 'rb') as file:\n        headers = {\n            'Content-Type': f'multipart/form-data; boundary={boundary}',\n            'Content-Length': file_size\n        }\n        client.request('POST', '/upload', body=file, headers=headers)\n    client.getresponse()\n    client.close()\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a function that sends a file over HTTP using a readable stream and pipes it to an HTTP request.\n\nFunction Description: The function `sendFileViaHTTP` is designed to stream a file from the local filesystem and send it as binary data via an HTTP POST request. It uses Node.js's `fs` module to create a readable stream from the file and pipes this stream directly to an HTTP request created with the `http` module. This approach is efficient for handling large files as it avoids loading the entire file into memory.\n\nInput: \n- `testFilePath` (string): The path to the file to be sent. Defaults to a predefined path in the fixture directory.\n- `port` (number): The port number on which the HTTP server is listening. Defaults to a common port defined elsewhere in the code.\n\nOutput: None. The function sends the file via HTTP but does not return any value. The result of the HTTP request (success or failure) would typically be handled via event listeners on the request object, which are not shown in this basic example.",
    "Canonical_solution": "function sendFileViaHTTP() {\n    var fs = require('fs');\n    var http = require('http');\n    var path = require('path');\n    \n    var testFilePath = path.join(__dirname, '../fixture/file/binaryfile.tar.gz');\n    var port = common.port;\n\n    var request = http.request({\n        port: port,\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    });\n\n    fs.createReadStream(testFilePath).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "matched_results": [
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`HTTP/1.1 ${res.statusCode}`);\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`STATUS: ${res.statusCode}`);\n    console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 3000) {\n  const filePath = path.resolve(__dirname, testFilePath);\n  const fileStream = fs.createReadStream(filePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`HTTP/1.1 ${res.statusCode}`);\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n  req.on('error', (e) => {\n    // Handle request error if needed\n  });\n  fileStream.pipe(req);\n}\n```",
      "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = 'path/to/default/file', port = 8080) {\n  const fileStream = fs.createReadStream(testFilePath);\n  const options = {\n    hostname: 'localhost',\n    port: port,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/octet-stream'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`HTTP/1.1 ${res.statusCode}`);\n    res.on('data', (chunk) => {\n      // Handle response data if needed\n    });\n    res.on('end', () => {\n      // Handle end of response if needed\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  fileStream.pipe(req);\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and handle file uploads, using Node.js's `fs` and `http` modules. The server should log connection details and save request data to files.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. It handles requests by piping the socket data to a file stream and provides a simple HTML form for file uploads. Each connection is assigned a unique filename for logging purposes.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but creates a running HTTP server that logs to the console and writes to files)",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\"></form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFileName = `upload_${Date.now()}.txt`;\n      const filePath = path.join(__dirname, uniqueFileName);\n      const fileStream = fs.createWriteStream(filePath);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close();\n        console.log(`File saved to ${filePath}`);\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFileName = path.join(__dirname, `upload_${Date.now()}.txt`);\n      const fileStream = fs.createWriteStream(uniqueFileName);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close();\n        console.log(`File uploaded to ${uniqueFileName}`);\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server listening on port 3000');\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFileName = path.basename(req.headers['file-name']);\n      const fileStream = fs.createWriteStream(`uploads/${uniqueFileName}`);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close();\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server running at http://localhost:3000/');\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFileName = path.basename(req.headers['file-name']);\n      const fileStream = fs.createWriteStream(`uploads/${uniqueFileName}`);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close();\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server running at http://localhost:3000/');\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'GET') {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n  } else if (req.method === 'POST' && req.url === '/upload') {\n    const uniqueFileName = path.join(__dirname, 'uploads', `upload_${Date.now()}.txt`);\n    const fileStream = fs.createWriteStream(uniqueFileName);\n    req.pipe(fileStream);\n    fileStream.on('finish', () => {\n      fileStream.close();\n      console.log(`File uploaded: ${uniqueFileName}`);\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('File uploaded successfully');\n    });\n  } else {\n    res.writeHead(404, { 'Content-Type': 'text/plain' });\n    res.end('Not Found');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFileName = path.basename(req.headers['file-name']);\n      const fileStream = fs.createWriteStream(`uploads/${uniqueFileName}`);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close();\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server listening on port 3000');\n  });\n}\n\ncreateServer();\n```",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\"></form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFilename = path.join(__dirname, `upload_${Date.now()}.txt`);\n      const fileStream = fs.createWriteStream(uniqueFilename);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close();\n        console.log(`File saved to ${uniqueFilename}`);\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n  });\n}\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\"></form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFileName = path.join(__dirname, `upload_${Date.now()}.txt`);\n      const fileStream = fs.createWriteStream(uniqueFileName);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close(() => {\n          console.log(`File uploaded to ${uniqueFileName}`);\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          res.end('File uploaded successfully');\n        });\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server is listening on port 3000');\n  });\n}\n\ncreateServer();",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFileName = `upload_${Date.now()}.txt`;\n      const filePath = path.join(__dirname, uniqueFileName);\n      const fileStream = fs.createWriteStream(filePath);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close();\n        console.log(`Connection from ${req.socket.remoteAddress} saved to ${uniqueFileName}`);\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully.');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server running on port 3000');\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const uniqueFileName = path.basename(req.headers['file-name']);\n      const fileStream = fs.createWriteStream(`uploads/${uniqueFileName}`);\n      req.pipe(fileStream);\n      fileStream.on('finish', () => {\n        fileStream.close();\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(3000, () => {\n    console.log('Server running at http://localhost:3000/');\n  });\n}\n\ncreateServer();\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle incoming requests and pipe the request data directly back as the response.\n\nFunction Description: The function `setupServer` creates an HTTP server that listens on an available port. When a request is received, the server responds with a 202 status code and pipes the incoming request data directly back to the response. The server's URL is stored in the `url` property of the server instance once it starts listening.\n\nInput: None\n\nOutput: Returns an HTTP server instance that is actively listening for requests. The server instance has a `url` property containing the server's address (e.g., 'http://localhost:PORT') once the server starts listening.",
    "Canonical_solution": "function setupServer() {\n  var http = require('http');\n  var server = http.createServer();\n  server.on('request', function (req, res) {\n    res.writeHead(202);\n    req.pipe(res);\n  });\n  server.listen(0, function () {\n    server.url = 'http://localhost:' + this.address().port;\n  });\n  return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\n\nclass Server {\n  constructor() {\n    this.url = '';\n  }\n\n  setupServer() {\n    const server = http.createServer((req, res) => {\n      res.writeHead(202);\n      req.pipe(res);\n    });\n\n    server.listen(() => {\n      this.url = server.address().protocol + '://' + server.address().hostname + ':' + server.address().port;\n    });\n\n    return server;\n  }\n}\n\nmodule.exports = Server;\n```"
    ],
    "unmatched_results": [
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\nclass HTTPServerWithURL(socketserver.TCPServer):\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.url = f\"http://{self.server_address[0]}:{self.server_address[1]}\"\n\ndef setupServer():\n    server_address = ('', 0)\n    httpd = HTTPServerWithURL(server_address, CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\nclass CustomHTTPServer(socketserver.TCPServer):\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.url = f\"http://{self.server_address[0]}:{self.server_address[1]}\"\n\ndef setupServer():\n    server_address = ('', 0)\n    httpd = CustomHTTPServer(server_address, CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\nclass HTTPServerWithURL(socketserver.TCPServer):\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.url = f\"http://{self.server_address[0]}:{self.server_address[1]}\"\n\ndef setupServer():\n    server_address = ('', 0)\n    httpd = HTTPServerWithURL(server_address, CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\nclass CustomHTTPServer(socketserver.TCPServer):\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.url = f\"http://{self.server_address[0]}:{self.server_address[1]}\"\n\ndef setupServer():\n    server_address = ('', 0)\n    httpd = CustomHTTPServer(server_address, CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\ndef setupServer():\n    port = 0\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', port))\n        s.listen()\n        port = s.getsockname()[1]\n    handler = CustomHTTPRequestHandler\n    httpd = socketserver.TCPServer((\"\", port), handler)\n    httpd.url = f\"http://localhost:{port}\"\n    httpd.serve_forever()\n    return httpd\n```",
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\nclass HTTPServerWithURL(socketserver.TCPServer):\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.url = f\"http://{self.server_address[0]}:{self.server_address[1]}\"\n\ndef setupServer():\n    server_address = ('', 0)\n    httpd = HTTPServerWithURL(server_address, CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\nclass Server:\n    def __init__(self):\n        self.url = None\n\n    def setupServer(self):\n        port = 0\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.bind(('', port))\n            s.listen()\n            self.url = f'http://localhost:{s.getsockname()[1]}'\n        with socketserver.TCPServer((\"\", port), CustomHTTPRequestHandler) as httpd:\n            self.url = f'http://localhost:{s.getsockname()[1]}'\n            httpd.serve_forever()\n\n        return self\n```",
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\nclass HTTPServerWithURL(socketserver.TCPServer):\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.url = f\"http://{self.server_address[0]}:{self.server_address[1]}\"\n\ndef setupServer():\n    server_address = ('', 0)\n    httpd = HTTPServerWithURL(server_address, CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport socket\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(202)\n        self.end_headers()\n        self.copyfile(self.rfile, self.wfile)\n\ndef setupServer():\n    port = 0\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', port))\n        s.listen()\n        port = s.getsockname()[1]\n    handler = CustomHTTPRequestHandler\n    httpd = socketserver.TCPServer((\"\", port), handler)\n    httpd.url = f\"http://localhost:{port}\"\n    httpd.serve_forever()\n    return httpd\n```"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle incoming requests, pipe the request data to individual files, and manage client connections. The server should record each connection's data to a separate file and provide a simple HTML upload form for root requests.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens for incoming connections. Each connection's request data is piped to a uniquely named file. For non-root requests, it returns request metadata in JSON format. For root requests (`/`), it serves an HTML upload form. The function tracks connection counts and logs connection/disconnection events.\n\nInput: None (The function takes no parameters but uses `process.env.PORT` environment variable as a fallback port)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that persists until stopped)",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nlet connectionCount = 0;\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const decoder = new StringDecoder('utf-8');\n    let buffer = '';\n    let filePath = '';\n\n    req.on('data', (chunk) => {\n      buffer += decoder.write(chunk);\n    });\n\n    req.on('end', () => {\n      buffer += decoder.end();\n\n      const uniqueFileName = `connection-${connectionCount++}.txt`;\n      const fileStream = fs.createWriteStream(uniqueFileName);\n      fileStream.write(buffer);\n      fileStream.end();\n\n      if (req.url === '/') {\n        filePath = path.join(__dirname, 'uploadForm.html');\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        fs.createReadStream(filePath).pipe(res);\n      } else {\n        const response = {\n          method: req.method,\n          url: req.url,\n          headers: req.headers\n        };\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify(response));\n      }\n    });\n  });\n\n  server.listen(process.env.PORT || 3000, () => {\n    console.log(`Server is running on port ${process.env.PORT || 3000}`);\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nlet connectionCount = 0;\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const decoder = new StringDecoder('utf-8');\n    let buffer = '';\n    let filePath = '';\n\n    req.on('data', (chunk) => {\n      buffer += decoder.write(chunk);\n    });\n\n    req.on('end', () => {\n      buffer += decoder.end();\n\n      if (req.url === '/') {\n        filePath = path.join(__dirname, 'upload.html');\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        fs.createReadStream(filePath).pipe(res);\n      } else {\n        const uniqueFileName = `connection_${connectionCount}.txt`;\n        fs.createWriteStream(uniqueFileName).write(buffer);\n        connectionCount++;\n\n        const response = {\n          method: req.method,\n          url: req.url,\n          headers: req.headers\n        };\n\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify(response));\n      }\n    });\n  });\n\n  server.listen(process.env.PORT || 3000, () => {\n    console.log(`Server is running on port ${process.env.PORT || 3000}`);\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nlet connectionCount = 0;\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const decoder = new StringDecoder('utf-8');\n    let buffer = '';\n    let filePath = '';\n\n    req.on('data', (data) => {\n      buffer += decoder.write(data);\n    });\n\n    req.on('end', () => {\n      buffer += decoder.end();\n\n      const uniqueFileName = `connection-${connectionCount++}.txt`;\n      const fileStream = fs.createWriteStream(path.join(__dirname, uniqueFileName));\n      fileStream.write(buffer);\n      fileStream.end();\n\n      if (req.url === '/') {\n        filePath = path.join(__dirname, 'uploadForm.html');\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        fs.createReadStream(filePath).pipe(res);\n      } else {\n        const response = {\n          method: req.method,\n          url: req.url,\n          headers: req.headers\n        };\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify(response));\n      }\n    });\n  });\n\n  server.listen(process.env.PORT || 3000, () => {\n    console.log(`Server is running on port ${process.env.PORT || 3000}`);\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nlet connectionCount = 0;\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const decoder = new StringDecoder('utf-8');\n    let buffer = '';\n    let filePath = '';\n\n    req.on('data', (chunk) => {\n      buffer += decoder.write(chunk);\n    });\n\n    req.on('end', () => {\n      buffer += decoder.end();\n\n      const uniqueFileName = `connection-${connectionCount++}.txt`;\n      const fileStream = fs.createWriteStream(uniqueFileName);\n      fileStream.write(buffer);\n      fileStream.end();\n\n      if (req.url === '/') {\n        filePath = path.join(__dirname, 'uploadForm.html');\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        fs.createReadStream(filePath).pipe(res);\n      } else {\n        const response = {\n          method: req.method,\n          url: req.url,\n          headers: req.headers\n        };\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify(response));\n      }\n    });\n  });\n\n  server.listen(process.env.PORT || 3000, () => {\n    console.log(`Server is running on port ${process.env.PORT || 3000}`);\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nlet connectionCount = 0;\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const decoder = new StringDecoder('utf-8');\n    let buffer = '';\n    let filePath = '';\n\n    req.on('data', (data) => {\n      buffer += decoder.write(data);\n    });\n\n    req.on('end', () => {\n      buffer += decoder.end();\n\n      if (req.url === '/') {\n        filePath = path.join(__dirname, 'upload.html');\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        fs.createReadStream(filePath).pipe(res);\n      } else {\n        const uniqueFileName = `connection-${connectionCount++}.txt`;\n        const writeStream = fs.createWriteStream(uniqueFileName);\n        writeStream.write(buffer);\n        writeStream.end();\n\n        const response = {\n          method: req.method,\n          url: req.url,\n          headers: req.headers\n        };\n\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify(response));\n      }\n    });\n\n    req.on('close', () => {\n      console.log(`Connection ${connectionCount - 1} closed`);\n    });\n  });\n\n  server.listen(process.env.PORT || 3000, () => {\n    console.log(`Server is running on port ${process.env.PORT || 3000}`);\n  });\n}\n\ncreateServer();\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'uploads', `${Date.now()}.txt`);\n  const fileStream = fs.createWriteStream(filePath);\n  const decoder = new StringDecoder('utf-8');\n  let data = '';\n\n  req.on('data', (chunk) => {\n    data += decoder.write(chunk);\n    fileStream.write(chunk);\n  });\n\n  req.on('end', () => {\n    data += decoder.end();\n    fileStream.end();\n    const metadata = {\n      method: req.method,\n      url: req.url,\n      headers: req.headers,\n      length: data.length\n    };\n\n    if (req.url === '/') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\"></form>');\n    } else {\n      res.writeHead(200, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify(metadata));\n    }\n  });\n\n  req.on('close', () => {\n    console.log('Connection closed');\n  });\n\n  req.on('error', (err) => {\n    console.error('Error:', err);\n  });\n});\n\nlet connectionCount = 0;\n\nserver.on('connection', () => {\n  connectionCount++;\n  console.log(`Connection ${connectionCount} established`);\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n\nserver.listen(process.env.PORT || 3000);\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'uploads', `${Date.now()}.txt`);\n  const fileStream = fs.createWriteStream(filePath);\n  const decoder = new StringDecoder('utf-8');\n  let data = '';\n\n  req.on('data', (chunk) => {\n    data += decoder.write(chunk);\n    fileStream.write(chunk);\n  });\n\n  req.on('end', () => {\n    data += decoder.end();\n    fileStream.end();\n    const metadata = {\n      method: req.method,\n      url: req.url,\n      headers: req.headers,\n      ip: req.socket.remoteAddress,\n      port: req.socket.remotePort\n    };\n    if (req.url === '/') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\"></form>');\n    } else {\n      res.writeHead(200, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify(metadata));\n    }\n  });\n\n  req.on('close', () => {\n    console.log(`Connection closed for ${req.url}`);\n  });\n\n  req.on('error', (err) => {\n    console.error(`Error handling request: ${err}`);\n  });\n});\n\nlet connectionCount = 0;\nserver.on('connection', () => {\n  connectionCount++;\n  console.log(`Connection ${connectionCount} established`);\n});\n\nserver.on('close', () => {\n  console.log(`Server closed`);\n});\n\nserver.listen(process.env.PORT || 3000);\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nconst server = http.createServer((req, res) => {\n  const decoder = new StringDecoder('utf-8');\n  let buffer = '';\n  req.on('data', (data) => {\n    buffer += decoder.write(data);\n  });\n  req.on('end', () => {\n    buffer += decoder.end();\n    const filename = path.join(__dirname, `logs/${Date.now()}.txt`);\n    fs.writeFile(filename, buffer, (err) => {\n      if (err) {\n        console.error(err);\n        res.writeHead(500, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'Error writing to file' }));\n        return;\n      }\n      if (req.url === '/') {\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n      } else {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({\n          method: req.method,\n          url: req.url,\n          headers: req.headers\n        }));\n      }\n    });\n  });\n});\n\nserver.listen(process.env.PORT || 3000, () => {\n  console.log('Server is running on port 3000');\n});\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nlet connectionCount = 0;\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    connectionCount++;\n    const filePath = path.join(__dirname, `connection_${connectionCount}.txt`);\n    const fileStream = fs.createWriteStream(filePath);\n    const decoder = new StringDecoder('utf-8');\n    let data = '';\n\n    req.on('data', (chunk) => {\n      data += decoder.write(chunk);\n      fileStream.write(chunk);\n    });\n\n    req.on('end', () => {\n      data += decoder.end();\n      fileStream.end();\n\n      if (req.url === '/') {\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form>');\n      } else {\n        const response = {\n          method: req.method,\n          url: req.url,\n          headers: req.headers\n        };\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify(response));\n      }\n    });\n\n    req.on('close', () => {\n      console.log(`Connection ${connectionCount} closed`);\n      connectionCount--;\n    });\n  });\n\n  server.listen(process.env.PORT || 3000);\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nconst server = http.createServer((req, res) => {\n  const decoder = new StringDecoder('utf-8');\n  let buffer = '';\n  req.on('data', (data) => {\n    buffer += decoder.write(data);\n  });\n  req.on('end', () => {\n    buffer += decoder.end();\n    const filename = `connection_${Date.now()}.txt`;\n    const filepath = path.join(__dirname, filename);\n    fs.writeFileSync(filepath, buffer);\n\n    if (req.url === '/') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end('<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\"></form>');\n    } else {\n      const response = {\n        method: req.method,\n        url: req.url,\n        headers: req.headers\n      };\n      res.writeHead(200, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify(response));\n    }\n  });\n});\n\nserver.listen(process.env.PORT || 3000, () => {\n  console.log('Server is running on port 3000');\n});\n```"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for POST requests. When a POST request is received, it pipes the request data through a transformation stream that converts the data to uppercase, then pipes the transformed data back to the response. The server listens on a port specified by the user or defaults to 0 if not provided.\n\nInput: \n- `process.argv[2]` (optional): [Number] - The port number on which the server should listen. If not provided, defaults to 0.\n\nOutput: \n- None (The function sets up a server that runs indefinitely, listening for requests and sending responses.)",
    "Canonical_solution": "function createServer() {\n    require('http').createServer(function (req, res) {\n        if (req.method !== 'POST') {\n            return res.end('POST only!\\n')\n        }\n        req.pipe(require('through2-map')(function (chunk) {\n            return chunk.toString().toUpperCase()\n        })).pipe(res)\n    }).listen(process.argv[2] | 0)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const transform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(transform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}\n\ncreateServer(parseInt(process.argv[2]) || 0);",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const transformer = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(transformer).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}\n\ncreateServer(process.argv[2] ? parseInt(process.argv[2]) : 0);",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}\n\ncreateServer(parseInt(process.argv[2]) || 0);",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}\n\ncreateServer(parseInt(process.argv[2]) || 0);",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}\n\ncreateServer(parseInt(process.argv[2]) || 0);"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "const request = require('request');\nconst url = 'http://example.com/api/resource';\nconst headers = {\n  'Content-Type': 'application/json'\n};\nconst data = JSON.stringify({ key: 'value' });\n\nfunction makeHttpRequest() {\n  request.post({ url: url, headers: headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n\nmakeHttpRequest();",
      "const request = require('request');\nconst url = 'http://example.com/api';\nconst headers = {\n  'Content-Type': 'application/json'\n};\nconst data = JSON.stringify({ key: 'value' });\n\nfunction makeHttpRequest() {\n  request.post({ url: url, headers: headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n\nmakeHttpRequest();",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer your-token-here'\n  };\n  const data = JSON.stringify({ key: 'value' });\n\n  request.post({ url, headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer your-token-here'\n  };\n  const data = JSON.stringify({ key: 'value' });\n\n  request.post({ url: url, headers: headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer your-token-here'\n  };\n  const data = JSON.stringify({ key: 'value' });\n\n  request.post({ url: url, headers: headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer your-token-here'\n  };\n  const data = {\n    key: 'value'\n  };\n\n  request.post({ url: url, headers: headers, json: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com/api/resource';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer your-token-here'\n  };\n  const data = JSON.stringify({ key: 'value' });\n\n  request.post({ url: url, headers: headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json'\n  };\n  const data = JSON.stringify({ key: 'value' });\n\n  request.post({ url: url, headers: headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer your-token-here'\n  };\n  const data = JSON.stringify({ key: 'value' });\n\n  request.post({ url, headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com/api';\n  const headers = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer your-token-here'\n  };\n  const data = JSON.stringify({ key: 'value' });\n\n  request.post({ url: url, headers: headers, body: data }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve a static HTML file by piping the file's content directly to the response stream.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. When a request is received, it reads the specified HTML file (`index.html`) and pipes its content to the response object, efficiently streaming the file to the client.\n\nInput: None\n\nOutput: None (The function starts an HTTP server that continues to run and serve requests indefinitely.)",
    "Canonical_solution": "function createServer() {\n    var http = require(\"http\");\n    var fs = require(\"fs\");\n\n    http.createServer(function (req, res) {\n        fs.createReadStream(\"index.html\").pipe(res);\n    }).listen(8080);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      fs.createReadStream('index.html').pipe(res);\n    }\n  });\n\n  server.listen(8080);\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      fs.createReadStream('index.html').pipe(res);\n    }\n  });\n\n  server.listen(8080);\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      fs.createReadStream('index.html').pipe(res);\n    }\n  });\n\n  server.listen(8080);\n}\n```"
    ],
    "unmatched_results": [
      "```python\nimport http.server\nimport socketserver\nimport os\n\nclass MyHttpRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.path = 'index.html'\n        super().do_GET()\n\ndef createServer():\n    PORT = 8080\n    handler = MyHttpRequestHandler\n    with socketserver.TCPServer((\"\", PORT), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\n\nclass HTMLFileHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.path = 'index.html'\n        super().do_GET()\n\ndef createServer():\n    port = 8080\n    handler = HTMLFileHandler\n    with socketserver.TCPServer((\"\", port), handler) as httpd:\n        print(f\"Serving at port {port}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.path = 'index.html'\n        super().do_GET()\n\ndef createServer():\n    port = 8080\n    handler = MyHTTPRequestHandler\n    with socketserver.TCPServer((\"\", port), handler) as httpd:\n        print(f\"Serving at port {port}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.path = 'index.html'\n        super().do_GET()\n\ndef createServer():\n    port = 8080\n    handler = MyHTTPRequestHandler\n    with socketserver.TCPServer((\"\", port), handler) as httpd:\n        print(f\"Serving at port {port}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.path = 'index.html'\n        super().do_GET()\n\ndef createServer():\n    PORT = 8080\n    handler = MyHTTPRequestHandler\n    with socketserver.TCPServer((\"\", PORT), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.path = 'index.html'\n        super().do_GET()\n\ndef createServer():\n    PORT = 8080\n    handler = MyHTTPRequestHandler\n    with socketserver.TCPServer((\"\", PORT), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\n\nclass MyHttpRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.path = 'index.html'\n        super().do_GET()\n\ndef createServer():\n    PORT = 8080\n    handler = MyHttpRequestHandler\n    with socketserver.TCPServer((\"\", PORT), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n```"
    ],
    "match_count": 3,
    "pass@3": 0.7083333333333333,
    "pass@5": 0.9166666666666666
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createPipeServer` creates an HTTP server that listens on a specified port. It handles incoming POST requests by piping the request data through a transformation stream that converts the data to uppercase, and then pipes the transformed data back to the response. Non-POST requests are responded to with a message indicating that a POST request is required.\n\nInput:  \n- `port` (Number): The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up the server but does not return any value).",
    "Canonical_solution": "const http = require('http');\nconst map = require('through2-map');\n\nfunction createPipeServer(port) {\n    const server = http.createServer(function (req, res) {\n        if (req.method !== 'POST') {\n            return res.end('send me a POST\\n');\n        }\n        req.pipe(map(function (chunk) {\n            return chunk.toString().toUpperCase();\n        })).pipe(res);\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const upperCaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(upperCaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed: POST requests are required');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed. Please use POST.');\n    }\n  });\n\n  server.listen(port);\n}",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const transformer = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(transformer).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Only POST requests are allowed');\n    }\n  });\n\n  server.listen(port);\n}\n```",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed. Please use POST.');\n    }\n  });\n\n  server.listen(port);\n}",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed. Please use POST.');\n    }\n  });\n\n  server.listen(port);\n}\n```",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed. Please use POST.');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed. Please use POST.');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed. Please use POST.');\n    }\n  });\n\n  server.listen(port);\n}",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const transformStream = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(transformStream).pipe(res);\n    } else {\n      res.writeHead(400, { 'Content-Type': 'text/plain' });\n      res.end('POST request required');\n    }\n  });\n\n  server.listen(port);\n}\n```",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseStream = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseStream).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed. Please use POST.');\n    }\n  });\n\n  server.listen(port);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and requests, piping the request data to individual files for each connection.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. For each connection, it creates a unique file to store the raw HTTP request data. The server handles regular requests by responding with connection information and provides an HTML upload form for the root path. The server tracks active connections and logs connection/disconnection events.\n\nInput: None (The function takes no parameters but uses environment variable `PORT` for configuration)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that writes to files)\n\nNote: The function maintains internal state including:\n- A connection counter\n- An active HTTP server instance\n- File streams for each connection\n- Logging of connection events to console",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nfrom urllib.parse import urlparse, parse_qs\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    server_version = \"CustomServer/0.1\"\n\n    def do_GET(self):\n        parsed_path = urlparse(self.path)\n        if parsed_path.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<html><body><form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form></body></html>')\n        else:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b\"Received data\")\n\n    def log_message(self, format, *args):\n        pass\n\ndef createServer():\n    PORT = os.getenv('PORT', '8000')\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", int(PORT)), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    createServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport hashlib\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<html><body><form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form></body></html>')\n        else:\n            self.send_response(404)\n            self.end_headers()\n\n    def do_POST(self):\n        if self.path == '/upload':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'File uploaded successfully.')\n            self.server.log_connection(self.client_address, post_data)\n        else:\n            self.send_response(404)\n            self.end_headers()\n\n    def log_message(self, format, *args):\n        self.server.log_connection(self.client_address, None)\n\nclass Server:\n    def __init__(self):\n        self.connection_counter = 0\n        self.server = None\n        self.file_streams = {}\n        self.lock = threading.Lock()\n\n    def log_connection(self, client_address, data):\n        print(f'Connection from {client_address} - {data if data else \"No data\"}')\n\n    def run(self):\n        self.server = socketserver.TCPServer((\"\", int(os.environ['PORT'])), CustomHTTPRequestHandler)\n        self.server.serve_forever()\n\n    def start(self):\n        threading.Thread(target=self.run).start()\n\ndef createServer():\n    server = Server()\n    server.start()\n\nif __name__ == '__main__':\n    createServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    server_version = \"CustomHTTP/0.1\"\n\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<html><body><form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form></body></html>')\n        else:\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(f'Connected from {self.client_address[0]} on port {self.client_address[1]}\\n'.encode())\n\n    def do_POST(self):\n        if self.path == '/upload':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            connection_id = self.server.get_connection_id()\n            with open(f'connection_{connection_id}.txt', 'wb') as f:\n                f.write(post_data)\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'File uploaded successfully.')\n\nclass CustomHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.connection_counter = 0\n        self.active_connections = []\n\n    def get_connection_id(self):\n        self.connection_counter += 1\n        return self.connection_counter\n\n    def log_message(self, format, *args):\n        print(time.strftime('%Y-%m-%d %H:%M:%S') + ' - ' + format % args)\n\ndef createServer():\n    port = os.environ.get('PORT', 8000)\n    httpd = CustomHTTPServer(('', int(port)), CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport urllib.parse\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    connection_counter = 0\n    server_instance = None\n    file_streams = {}\n    log_lock = threading.Lock()\n\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form>')\n        else:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def do_POST(self):\n        if self.path == '/upload':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            self.handle_post_data(post_data)\n        else:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def handle_post_data(self, post_data):\n        with self.log_lock:\n            self.connection_counter += 1\n            file_name = f'connection_{self.connection_counter}.txt'\n            file_stream = open(file_name, 'w')\n            self.file_streams[file_name] = file_stream\n            print(f\"Connection {self.connection_counter} established.\")\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'File uploaded successfully.')\n        file_stream.write(post_data.decode())\n\n    def log_message(self, format, *args):\n        with self.log_lock:\n            print(time.strftime('%a, %d %b %Y %H:%M:%S') + ' - [' + self.address_string() + '] ' + format % args)\n\n    def log_error(self, format, *args):\n        with self.log_lock:\n            print(time.strftime('%a, %d %b %Y %H:%M:%S') + ' - [' + self.address_string() + '] ' + format % args)\n\n    def log_message(self, format, *args):\n        with self.log_lock:\n            print(time.strftime('%a, %d %b %Y %H:%M:%S') + ' - [' + self.address_string() + '] ' + format % args)\n\n    def log_error(self, format, *args):\n        with self.log_lock:\n            print(time.strftime('%a, %d %b %Y %H:%M:%S') + ' - [' + self.address_string() + '] ' + format % args)\n\n    def handle(self):\n        with self.log_lock:\n            self.connection_counter += 1\n            file_name = f'connection_{self.connection_counter}.txt'\n            file_stream = open(file_name, 'w')\n            self.file_streams[file_name] = file_stream\n            print(f\"Connection {self.connection_counter} established.\")\n        self.handle_one_request()\n\n    def handle_one_request(self):\n        try:\n            self.handle_request()\n        finally:\n            with self.log_lock:\n                file_name = f'connection_{self.connection_counter}.txt'\n                if file_name in self.file_streams:\n                    file_stream = self.file_streams[file_name]\n                    file_stream.close()\n                    del self.file_streams[file_name]\n                self.connection_counter -= 1\n                print(f\"Connection {self.connection_counter} closed.\")\n\ndef createServer():\n    CustomHTTPRequestHandler.server_instance = socketserver.TCPServer((\"\", int(os.environ.get('PORT', 8000))), CustomHTTPRequestHandler)\n    CustomHTTPRequestHandler.server_instance.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport uuid\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form>')\n        else:\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(f'Connected from {self.client_address[0]} on port {self.client_address[1]}\\n'.encode())\n\n    def do_POST(self):\n        if self.path == '/upload':\n            self.handle_file_upload()\n        else:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def handle_file_upload(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/plain')\n        self.end_headers()\n        self.wfile.write(b'File uploaded successfully.')\n        file_name = f\"{uuid.uuid4()}.txt\"\n        file_path = os.path.join('uploads', file_name)\n        with open(file_path, 'wb') as f:\n            length = int(self.headers['Content-Length'])\n            data = self.rfile.read(length)\n            f.write(data)\n\ndef createServer():\n    PORT = os.getenv('PORT', 8000)\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", PORT), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    createServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport uuid\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form>')\n        else:\n            self.send_error(404)\n\n    def do_POST(self):\n        if self.path == '/upload':\n            self.handle_file_upload()\n        else:\n            self.send_error(404)\n\n    def handle_file_upload(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b'File uploaded successfully.')\n        file_info = self.rfile.info()\n        file_name = file_info.get('filename')\n        file_stream = open(f\"{uuid.uuid4()}.txt\", 'wb')\n        file_stream.write(self.rfile.read())\n        file_stream.close()\n\ndef createServer():\n    PORT = os.environ.get('PORT', 8000)\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", PORT), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\ncreateServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    connection_counter = 0\n    server = None\n    file_streams = {}\n    log_lock = threading.Lock()\n\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form>')\n        else:\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(f'Connected from {self.client_address[0]}:{self.client_address[1]}\\n'.encode())\n\n    def do_POST(self):\n        if self.path == '/upload':\n            self.handle_file_upload()\n        else:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def handle_file_upload(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/plain')\n        self.end_headers()\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        connection_id = self.client_address[0] + ':' + str(self.client_address[1])\n        file_name = f'connection_{CustomHTTPRequestHandler.connection_counter}.txt'\n        with open(file_name, 'wb') as f:\n            f.write(post_data)\n        with CustomHTTPRequestHandler.log_lock:\n            print(f'Uploaded file {file_name} from {connection_id}')\n        CustomHTTPRequestHandler.connection_counter += 1\n        self.wfile.write(b'File uploaded successfully.')\n\n    def log_message(self, format, *args):\n        with CustomHTTPRequestHandler.log_lock:\n            print(time.strftime('%a, %d %b %Y %H:%M:%S') + ' - [' + self.address_string() + '] ' + format % args)\n\ndef createServer():\n    port = os.environ.get('PORT', 8000)\n    CustomHTTPRequestHandler.server = socketserver.TCPServer((\"\", port), CustomHTTPRequestHandler)\n    CustomHTTPRequestHandler.server.serve_forever()\n\nif __name__ == \"__main__\":\n    createServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    server_version = \"CustomHTTP/0.1\"\n\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<html><body><form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form></body></html>')\n        else:\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(f'Connected from {self.client_address[0]} on port {self.client_address[1]}\\n'.encode())\n\n    def do_POST(self):\n        if self.path == '/upload':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            connection_id = self.server.connection_counter\n            self.server.connection_counter += 1\n            file_path = f'connection_{connection_id}.txt'\n            with open(file_path, 'wb') as file:\n                file.write(post_data)\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(f'File uploaded to {file_path}\\n'.encode())\n\nclass CustomHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):\n    connection_counter = 0\n    active_connections = []\n\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.server_version = \"CustomHTTP/0.1\"\n\n    def handle(self):\n        conn = self.request\n        self.active_connections.append(conn)\n        try:\n            super().handle()\n        finally:\n            self.active_connections.remove(conn)\n            print(f'Connection from {conn.getpeername()} closed')\n\ndef createServer():\n    port = os.getenv('PORT', '8000')\n    httpd = CustomHTTPServer(('', int(port)), CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    connection_counter = 0\n    server_instance = None\n    file_streams = {}\n    log_lock = threading.Lock()\n\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<html><body><form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form></body></html>')\n        else:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def do_POST(self):\n        if self.path == '/upload':\n            self.handle_file_upload()\n        else:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def handle_file_upload(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        connection_id = self.client_address[1]\n        with self.log_lock:\n            self.connection_counter += 1\n            file_name = f\"connection_{self.connection_counter}.txt\"\n            file_stream = open(file_name, 'wb')\n            self.file_streams[connection_id] = file_stream\n            file_stream.write(post_data)\n            file_stream.flush()\n            os.fsync(file_stream.fileno())\n            print(f\"Connection {connection_id} uploaded file.\")\n        self.wfile.write(b\"File uploaded successfully.\")\n\n    def log_message(self, format, *args):\n        with self.log_lock:\n            print(time.strftime(\"%a, %d %b %Y %H:%M:%S\", time.localtime()), self.address_string(), format % args)\n\ndef createServer():\n    port = os.getenv('PORT', '8000')\n    CustomHTTPRequestHandler.server_instance = socketserver.TCPServer((\"\", int(port)), CustomHTTPRequestHandler)\n    thread = threading.Thread(target=CustomHTTPRequestHandler.server_instance.serve_forever)\n    thread.daemon = True\n    thread.start()\n\nif __name__ == \"__main__\":\n    createServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    server_version = \"CustomHTTP/0.1\"\n\n    def do_GET(self):\n        if self.path == '/':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'<html><body><form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form></body></html>')\n        else:\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(f'Connected from {self.client_address[0]} on port {self.client_address[1]}\\n'.encode())\n\n    def do_POST(self):\n        if self.path == '/upload':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            connection_id = self.server.get_connection_id()\n            with open(f'connection_{connection_id}.txt', 'wb') as f:\n                f.write(post_data)\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'File uploaded successfully.')\n\nclass CustomHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):\n    connection_counter = 0\n\n    def __init__(self, server_address, RequestHandlerClass):\n        super().__init__(server_address, RequestHandlerClass)\n        self.active_connections = []\n\n    def get_connection_id(self):\n        self.connection_counter += 1\n        return self.connection_counter\n\n    def log_message(self, format, *args):\n        print(f\"{time.strftime('%Y-%m-%d %H:%M:%S')} - {format%args}\")\n\ndef createServer():\n    port = os.getenv('PORT', '8000')\n    server_address = ('', int(port))\n    httpd = CustomHTTPServer(server_address, CustomHTTPRequestHandler)\n    httpd.serve_forever()\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 133,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to stream video content to clients using Node.js.\n\nFunction Description: The function `createVideoServer` initializes an HTTP server that streams a specified video file to clients when they connect. It uses Node.js's built-in `http` and `fs` modules to handle HTTP requests and read the video file, respectively. The video content is piped directly from the file system to the HTTP response, enabling efficient streaming.\n\nInput: None (The function does not take any parameters. The video file path is hardcoded as 'assets/NASA.mp4'.)\n\nOutput: None (The function does not return any value. It starts an HTTP server listening on port 3000 and the localhost address '127.0.0.1'.)",
    "Canonical_solution": "function createVideoServer() {\n    const http = require('http');\n    const fs = require('fs');\n    \n    let app = http.createServer((req, res) => {\n        res.writeHead(200, { 'Content-Type': 'video/mp4' });\n        let vidstream = fs.createReadStream('assets/NASA.mp4');\n        vidstream.pipe(res);\n    });\n    \n    app.listen(3000, '127.0.0.1');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n    const videoStream = fs.createReadStream(videoPath);\n\n    videoStream.pipe(res);\n  }\n});\n\nserver.listen(3000, '127.0.0.1');",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n    const videoStream = fs.createReadStream(videoPath);\n\n    videoStream.pipe(res);\n  }\n});\n\nserver.listen(3000, '127.0.0.1');",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n    const videoStream = fs.createReadStream(videoPath);\n    videoStream.pipe(res);\n  }\n});\n\nserver.listen(3000, '127.0.0.1');",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createVideoServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n      const videoStream = fs.createReadStream(videoPath);\n      videoStream.pipe(res);\n    }\n  });\n\n  server.listen(3000, '127.0.0.1');\n};",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createVideoServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n      const videoStream = fs.createReadStream(videoPath);\n      videoStream.pipe(res);\n    }\n  });\n\n  server.listen(3000, '127.0.0.1');\n};",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createVideoServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n      const videoStream = fs.createReadStream(videoPath);\n      videoStream.pipe(res);\n    }\n  });\n\n  server.listen(3000, '127.0.0.1');\n};",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createVideoServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n      const videoStream = fs.createReadStream(videoPath);\n      videoStream.pipe(res);\n    }\n  });\n\n  server.listen(3000, '127.0.0.1');\n};",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createVideoServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n      const videoStream = fs.createReadStream(videoPath);\n      videoStream.pipe(res);\n    }\n  });\n\n  server.listen(3000, '127.0.0.1');\n};",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createVideoServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n      const videoStream = fs.createReadStream(videoPath);\n      videoStream.pipe(res);\n    }\n  });\n\n  server.listen(3000, '127.0.0.1');\n};",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const videoPath = path.join(__dirname, 'assets', 'NASA.mp4');\n    const videoStream = fs.createReadStream(videoPath);\n    videoStream.pipe(res);\n  }\n});\n\nserver.listen(3000, '127.0.0.1');"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 134,
    "Instruction": "Task Description: Create a function that sets up a simple HTTP server to pipe the contents of a file as a response to incoming requests.\n\nFunction Description: The function creates an HTTP server that listens on a specified port. When a request is received, it responds by streaming the contents of a specified file to the client using the `pipe()` method. This is useful for efficiently serving file contents without loading the entire file into memory.\n\nInput: \n- port: [number] - The port number on which the HTTP server should listen. This is passed as the first command-line argument (process.argv[2]).\n- filePath: [string] - The path to the file whose contents should be piped to the response. This is passed as the second command-line argument (process.argv[3]).\n\nOutput: \n- None (The function does not return a value but starts an HTTP server that runs indefinitely.)",
    "Canonical_solution": "function createPipeServer() {\n    require('http').createServer(function (req, res) {\n        res.writeHead(200, 'content-type: text/plain');\n        require('fs').createReadStream(process.argv[3]).pipe(res);\n    }).listen(process.argv[2] | 0);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst port = parseInt(process.argv[2], 10);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst port = parseInt(process.argv[2]);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst port = parseInt(process.argv[2]);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst port = parseInt(process.argv[2]);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst port = parseInt(process.argv[2]);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst port = parseInt(process.argv[2]);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst port = parseInt(process.argv[2]);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    fs.createReadStream(filePath).pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst port = parseInt(process.argv[2]);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst port = parseInt(process.argv[2]);\nconst filePath = process.argv[3];\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  }\n});\n\nserver.listen(port, () => {\n  console.log(`Server listening on port ${port}`);\n});"
    ],
    "unmatched_results": [
      "const http = require('http');\nconst fs = require('fs');\nconst { StringDecoder } = require('string_decoder');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'GET') {\n    const filePath = process.argv[3];\n    const fileStream = fs.createReadStream(filePath);\n    const decoder = new StringDecoder('utf-8');\n\n    fileStream.on('data', (chunk) => {\n      res.write(decoder.write(chunk));\n    });\n\n    fileStream.on('end', () => {\n      res.end(decoder.end());\n    });\n\n    fileStream.on('error', (err) => {\n      res.writeHead(500);\n      res.end('Server Error');\n    });\n  }\n});\n\nconst port = process.argv[2];\nserver.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to generate PDFs from HTML templates and serve them as streams.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. It serves PDF files generated from an HTML template, replacing placeholders with actual image paths, and streams the PDF output to the client. The server handles incoming requests, checks for favicon requests, and responds with either a 404 error or the generated PDF.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 8080 and logs the server address to the console.)",
    "Canonical_solution": "function createServer() {\n    const fs = require('fs');\n    const http = require('http');\n    const pdf = require('../../');\n    const tmpl = fs.readFileSync(require.resolve('../businesscard/businesscard.html'), 'utf8');\n\n    const server = http.createServer(function (req, res) {\n        if (req.url === '/favicon.ico') return res.end('404');\n        const html = tmpl.replace('{{image}}', `file://${require.resolve('../businesscard/image.png')}`);\n        pdf.create(html, {width: '50mm', height: '90mm'}).toStream((err, stream) => {\n            if (err) return res.end(err.stack);\n            res.setHeader('Content-type', 'application/pdf');\n            stream.pipe(res);\n        });\n    });\n\n    server.listen(8080, function (err) {\n        if (err) throw err;\n        console.log('Listening on http://localhost:%s', server.address().port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst { createWriteStream } = require('fs');\nconst { PDFDocument } = require('pdf-lib');\nconst { JSDOM } = require('jsdom');\nconst { DOMParser } = new JSDOM().window;\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\n\nconst server = http.createServer(async (req, res) => {\n  if (req.url === '/favicon.ico') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  const htmlPath = path.join(__dirname, 'template.html');\n  const htmlContent = await readFileAsync(htmlPath, 'utf8');\n  const dom = new DOMParser().parseFromString(htmlContent, 'text/html');\n  const imagePath = 'path/to/image.jpg'; // Replace with actual image path\n  const imageElement = dom.querySelector('img');\n  imageElement.setAttribute('src', imagePath);\n\n  const pdfDoc = await PDFDocument.create();\n  const page = pdfDoc.addPage();\n  const canvas = page.getCanvas();\n  const image = await PDFDocument.load(imagePath);\n  const pdfImage = await image.scale(1);\n  canvas.drawImage(pdfImage, 100, 100);\n\n  const pdfBytes = await pdfDoc.save();\n  const pdfStream = createWriteStream('output.pdf');\n  pdfStream.write(pdfBytes);\n  pdfStream.end();\n\n  res.writeHead(200, { 'Content-Type': 'application/pdf' });\n  pdfStream.pipe(res);\n});\n\nserver.listen(8080, () => {\n  console.log(`Server running at http://localhost:8080/`);\n});\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst { createWriteStream } = require('fs');\nconst { PDFDocument } = require('pdf-lib');\nconst { JSDOM } = require('jsdom');\nconst { DOMParser } = new JSDOM().window;\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\n\nconst server = http.createServer(async (req, res) => {\n  if (req.url === '/favicon.ico') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  const htmlPath = path.join(__dirname, 'template.html');\n  const htmlContent = await readFileAsync(htmlPath, 'utf8');\n  const dom = new DOMParser().parseFromString(htmlContent, 'text/html');\n  const imagePath = 'path/to/image.jpg'; // Replace with actual image path\n  const imageElement = dom.querySelector('img');\n  imageElement.setAttribute('src', imagePath);\n\n  const pdf = await PDFDocument.create();\n  const page = pdf.addPage();\n  const canvas = page.getCanvas();\n  const image = await PDFDocument.load(imagePath);\n  const pdfImage = await image.scale(1);\n  canvas.drawImage(pdfImage, 100, 100);\n\n  const pdfPath = path.join(__dirname, 'output.pdf');\n  const pdfFile = createWriteStream(pdfPath);\n  const pdfBytes = await pdf.save();\n  pdfFile.write(pdfBytes);\n  pdfFile.end();\n\n  res.writeHead(200, { 'Content-Type': 'application/pdf' });\n  pdfFile.pipe(res);\n});\n\nserver.listen(8080, () => {\n  console.log(`Server running at http://localhost:8080/`);\n});\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst { createPdfFromHtml } = require('pdfkit');\nconst readFileAsync = promisify(fs.readFile);\n\nconst server = http.createServer(async (req, res) => {\n  const filePath = path.join(__dirname, 'templates', req.url);\n  const isFavicon = req.url === '/favicon.ico';\n\n  if (isFavicon) {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  try {\n    const html = await readFileAsync(filePath, 'utf8');\n    const pdf = createPdfFromHtml(html);\n    pdf.pipe(res);\n    pdf.end();\n  } catch (error) {\n    res.writeHead(404);\n    res.end('Not Found');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on http://localhost:8080');\n});\n```",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst { PDFDocument } = require('pdf-lib');\nconst { JSDOM } = require('jsdom');\nconst { Readable } = require('stream');\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\n\nconst server = http.createServer(async (req, res) => {\n  if (req.url === '/favicon.ico') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  const htmlPath = path.join(__dirname, 'template.html');\n  const pdfPath = path.join(__dirname, 'output.pdf');\n\n  try {\n    const html = await readFileAsync(htmlPath, 'utf8');\n    const dom = new JSDOM(html);\n    const { window } = dom;\n\n    const pdfDoc = await PDFDocument.create();\n    const { pages } = pdfDoc;\n\n    const canvas = window.document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n\n    const [width, height] = pages[0].getSize();\n    canvas.width = width;\n    canvas.height = height;\n\n    const image = await PDFDocument.loadImage({\n      data: await readFileAsync(path.resolve(window.location.pathname)),\n    });\n    pdfDoc.addImage(image, {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n    });\n\n    await writeFileAsync(pdfPath, await pdfDoc.save());\n\n    const readStream = fs.createReadStream(pdfPath);\n    res.writeHead(200, { 'Content-Type': 'application/pdf' });\n    readStream.pipe(res);\n  } catch (error) {\n    res.writeHead(404);\n    res.end();\n  }\n});\n\nserver.listen(8080, () => {\n  console.log(`Server running at http://localhost:8080/`);\n});"
    ],
    "unmatched_results": [
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { PDFDocument } = require('pdf-lib');\nconst ejs = require('ejs');\n\nconst server = http.createServer(async (req, res) => {\n  if (req.url === '/favicon.ico') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  const filePath = path.join(__dirname, 'templates', req.url + '.html');\n  if (!fs.existsSync(filePath)) {\n    res.writeHead(404);\n    res.end('Not Found');\n    return;\n  }\n\n  const html = fs.readFileSync(filePath, 'utf8');\n  const template = ejs.compile(html);\n  const pdf = await PDFDocument.create();\n  const htmlPdf = template({ imagePath: 'path/to/image.jpg' });\n  const pdfBytes = await pdf.addHTML(htmlPdf);\n  res.setHeader('Content-Type', 'application/pdf');\n  res.setHeader('Content-Length', pdfBytes.length);\n  res.end(pdfBytes);\n});\n\nserver.listen(8080, () => {\n  console.log(`Server running at http://localhost:8080/`);\n});",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { PDFDocument } = require('pdf-lib');\nconst ejs = require('ejs');\n\nconst server = http.createServer(async (req, res) => {\n  if (req.url === '/favicon.ico') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  const htmlPath = path.join(__dirname, 'template.html');\n  const html = fs.readFileSync(htmlPath, 'utf8');\n  const pdfPath = path.join(__dirname, 'output.pdf');\n\n  const pdfDoc = await PDFDocument.create();\n  const htmlPdf = await pdfDoc.addNewPage();\n  const canvas = htmlPdf.getCanvas();\n  const context = canvas.getContext('2d');\n\n  const image = await PDFDocument.load(fs.readFileSync(path.join(__dirname, 'placeholder.png')));\n  const img = await image.getImage();\n  await pdfDoc.addImage(img, {\n    x: 100,\n    y: 100,\n    width: 100,\n    height: 100,\n  });\n\n  const renderedPdf = await pdfDoc.saveAsBuffer();\n  fs.writeFileSync(pdfPath, renderedPdf);\n\n  res.writeHead(200, { 'Content-Type': 'application/pdf' });\n  res.end(renderedPdf);\n});\n\nserver.listen(8080, () => {\n  console.log(`Server running at http://localhost:8080/`);\n});\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst { createWriteStream } = require('fs');\nconst { PDFDocument } = require('pdf-lib');\nconst { JSDOM } = require('jsdom');\nconst { DOMParser } = new JSDOM().window;\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\n\nconst server = http.createServer(async (req, res) => {\n  if (req.url === '/favicon.ico') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  const htmlPath = path.join(__dirname, 'template.html');\n  const htmlContent = await readFileAsync(htmlPath, 'utf8');\n  const dom = new DOMParser().parseFromString(htmlContent, 'text/html');\n  const imagePath = 'path/to/image.jpg'; // Replace with actual image path\n  const imageElement = dom.querySelector('img');\n  imageElement.setAttribute('src', imagePath);\n\n  const pdf = await PDFDocument.create();\n  const page = pdf.addPage();\n  const canvas = page.getCanvas();\n  const image = await PDFDocument.load(imagePath);\n  const pdfImage = await image.scale(1);\n  canvas.drawImage(pdfImage, 100, 100);\n\n  const pdfPath = path.join(__dirname, 'output.pdf');\n  const pdfFile = createWriteStream(pdfPath);\n  await pdf.save(pdfFile);\n\n  res.writeHead(200, { 'Content-Type': 'application/pdf' });\n  const pdfData = await readFileAsync(pdfPath);\n  res.end(pdfData);\n});\n\nserver.listen(8080, () => {\n  console.log(`Server running at http://localhost:8080/`);\n});\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { createPdfFromHtml } = require('./pdfGenerator');\nconst express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  const htmlTemplate = fs.readFileSync(path.join(__dirname, 'template.html'), 'utf8');\n  const pdfStream = createPdfFromHtml(htmlTemplate);\n  pdfStream.pipe(res);\n});\n\napp.get('/favicon.ico', (req, res) => {\n  res.status(404).end();\n});\n\nconst server = app.listen(8080, () => {\n  console.log(`Server running at http://localhost:8080/`);\n});\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { createWriteStream } = require('fs');\nconst { PDFDocument } = require('pdf-lib');\nconst ejs = require('ejs');\n\nconst PORT = 8080;\n\nconst server = http.createServer(async (req, res) => {\n  if (req.url === '/favicon.ico') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  const filePath = path.join(__dirname, 'templates', req.url + '.html');\n  const fileContent = fs.readFileSync(filePath, 'utf8');\n  const renderedHtml = ejs.render(fileContent, { imagePath: 'path/to/image' });\n\n  const pdfDoc = await PDFDocument.create();\n  const pdfWriteStream = createWriteStream(path.join(__dirname, 'output', req.url + '.pdf'));\n  const pdfPages = await pdfDoc.addPagesFromHTML(renderedHtml);\n\n  pdfDoc.write(pdfWriteStream);\n  pdfWriteStream.on('finish', () => {\n    pdfWriteStream.close();\n    res.writeHead(200, { 'Content-Type': 'application/pdf' });\n    res.end();\n  });\n});\n\nserver.listen(PORT, () => {\n  console.log(`Server running at http://localhost:${PORT}/`);\n});\n```",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst stream = require('stream');\nconst { PDFDocument } = require('pdf-lib');\nconst { JSDOM } = require('jsdom');\nconst { Readable } = stream;\n\nconst readFileAsync = promisify(fs.readFile);\nconst writeFileAsync = promisify(fs.writeFile);\n\nconst server = http.createServer(async (req, res) => {\n  const url = new URL(req.url, 'http://localhost:8080');\n  const filePath = url.pathname;\n\n  if (filePath === '/favicon.ico') {\n    res.writeHead(404);\n    res.end();\n    return;\n  }\n\n  try {\n    const html = await readFileAsync(path.join(__dirname, 'templates', `${filePath}.html`), 'utf8');\n    const dom = new JSDOM(html);\n    const pdfDoc = await PDFDocument.create();\n    const [page] = await pdfDoc.addPages(1);\n    const canvas = page.getCanvas();\n    const htmlString = dom.window.document.body.innerHTML;\n    const htmlStream = new Readable();\n    htmlStream.push(htmlString);\n    htmlStream.push(null);\n\n    const pdfCanvas = canvas.createPdfCanvasFromHtml(htmlStream);\n    await pdfCanvas.render();\n\n    const pdfBytes = await pdfDoc.save();\n    res.writeHead(200, { 'Content-Type': 'application/pdf' });\n    res.end(pdfBytes);\n  } catch (error) {\n    res.writeHead(404);\n    res.end();\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://localhost:8080/');\n});"
    ],
    "match_count": 4,
    "pass@3": 0.8333333333333334,
    "pass@5": 0.9761904761904762
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a JavaScript function that sets up an HTTP server to serve an HTML file using Node.js's built-in modules (http and fs). The function should handle incoming requests by piping the file content directly to the response.\n\nFunction Description: The function creates an HTTP server that listens for incoming requests. When a request is received, it reads an HTML file from the specified path and pipes its content to the response object, setting the appropriate content-type header.\n\nInput: \n- __dirname (string): The directory path where the HTML file is located.\n- '/index.html' (string): The path to the HTML file to be served, relative to __dirname.\n\nOutput: \n- An HTTP server instance that serves the specified HTML file for all incoming requests. The server does not explicitly return a value but starts listening on a default port (typically 80 or a specified port).",
    "Canonical_solution": "var server = require('http').createServer(function incoming(req, res) {\n  res.setHeader('Content-Type', 'text/html');\n  require('fs').createReadStream(__dirname + '/index.html').pipe(res);\n});",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const filePath = path.join(__dirname, 'index.html');\n    fs.createReadStream(filePath).pipe(res);\n  }\n});\n\nserver.listen();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const filePath = path.join(__dirname, 'index.html');\n    fs.createReadStream(filePath).pipe(res);\n  }\n});\n\nserver.listen();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const filePath = path.join(__dirname, 'index.html');\n    fs.createReadStream(filePath).pipe(res);\n  }\n});\n\nserver.listen();",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction serveHtmlFile() {\n  http.createServer((req, res) => {\n    if (req.url === '/index.html') {\n      fs.createReadStream(__dirname + '/index.html')\n        .pipe(res)\n        .on('error', (err) => {\n          res.writeHead(500);\n          res.end('Error serving file');\n        });\n    } else {\n      res.writeHead(404);\n      res.end('File not found');\n    }\n  }).listen();\n}",
      "const http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    fs.createReadStream(`${__dirname}/index.html`).pipe(res);\n  }\n});\n\nserver.listen();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const filePath = path.join(__dirname, 'index.html');\n    fs.createReadStream(filePath).pipe(res);\n  }\n});\n\nserver.listen();",
      "const http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    fs.createReadStream(__dirname + '/index.html').pipe(res);\n  }\n});\n\nserver.listen();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const filePath = path.join(__dirname, 'index.html');\n    fs.createReadStream(filePath).pipe(res);\n  }\n});\n\nserver.listen();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const filePath = path.join(__dirname, 'index.html');\n    fs.createReadStream(filePath).pipe(res);\n  }\n});\n\nserver.listen();"
    ],
    "unmatched_results": [
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/') {\n    const filePath = path.join(__dirname, 'index.html');\n    fs.readFile(filePath, (err, data) => {\n      if (err) {\n        res.writeHead(500);\n        res.end('Error loading the HTML file');\n      } else {\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(data);\n      }\n    });\n  }\n});\n\nserver.listen();"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a JavaScript class that implements a server capable of handling HTTP requests and piping data to responses, with support for live reload functionality and error handling.\n\nClass Description: The `Server` class is designed to create an HTTP server that can handle incoming requests, pipe data to responses (particularly for live reload functionality), and manage server lifecycle events. It supports both standalone operation and integration with existing Express-like applications.\n\nAttributes:\n- options: [Object] - Configuration options for the server including livereload file path and port number.\n- clients: [Object] - Storage for connected clients (used for live reload functionality).\n- server: [http.Server] - The underlying HTTP server instance.\n- app: [Object] - Optional Express-like application instance for integration.\n- port: [Number] - The port number the server is listening on.\n\nMethods:\n- constructor(options) -> [Server] - Initializes the server with given options, setting defaults for livereload path and port.\n- configure(app) -> [Server] - Configures the server to work with an existing Express-like application.\n- handler(req, res, next) -> [Server] - Handles incoming HTTP requests, supporting both middleware and direct handling modes.\n- livereload(req, res) -> [void] - Pipes the livereload JavaScript file to the response.\n- listen(port, fn) -> [void] - Starts the server listening on the specified port.\n- close(req, res) -> [void] - Closes the server and optionally ends a response.\n- error(e) -> [void] - Handles and logs server errors.\n\nNote: The class demonstrates inter-process communication through HTTP and file system operations, particularly in the `livereload` method where it pipes file contents directly to HTTP responses.",
    "Canonical_solution": "var fs = require('fs');\nvar http = require('http');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.options.livereload = this.options.livereload || path.join(__dirname, 'public/livereload.js');\n    this.options.port = parseInt(this.options.port || 35729, 10);\n    this.clients = {};\n    this.configure(this.options.app);\n  }\n\n  configure(app) {\n    if(!app) {\n      this.server = http.createServer(this.handler.bind(this));\n      this.server.on('error', this.error.bind(this));\n      return this;\n    }\n\n    var self = this;\n    this.app = app;\n\n    this.app.listen = function(port, done) {\n      done = done || function() {};\n      var srv = self.server = http.createServer(app);\n      srv.on('error', self.error.bind(self));\n      srv.on('close', self.close.bind(self));\n      return srv.listen(port, done);\n    };\n\n    return this;\n  }\n\n  handler(req, res, next) {\n    var middleware = typeof next === 'function';\n    if(middleware) {\n      this.handle(req, res, next);\n      return this;\n    }\n\n    req\n      .on('end', this.handle.bind(this, req, res))\n      .on('data', function(chunk) {\n        req.data = req.data || '';\n        req.data += chunk;\n      });\n\n    return this;\n  }\n\n  livereload(req, res) {\n    fs.createReadStream(this.options.livereload).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port;\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if(res) res.end();\n    if(this.server._handle) this.server.close();\n  }\n\n  error(e) {\n    console.error('Error:', e.message);\n    console.error(e.stack);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath || '.', 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) {\n        res.end();\n      }\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath, 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      if (fn) fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) res.end();\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath || '.', 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) {\n        res.end();\n      }\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath, 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) {\n        res.end();\n      }\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath, 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      if (fn) fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) res.end();\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const livereloadPath = this.options.livereloadPath || 'livereload.js';\n    fs.createReadStream(livereloadPath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) {\n        res.end();\n      }\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath, 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) {\n        res.end();\n      }\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath, 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) {\n        res.end();\n      }\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath, 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) {\n        res.end();\n      }\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = this.options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else {\n      next();\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = path.join(this.options.livereloadPath || '.', 'livereload.js');\n    fs.createReadStream(filePath).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.server.listen(port, () => {\n      this.port = port;\n      fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) {\n        res.end();\n      }\n    });\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and requests, piping the request data to individual files for each connection.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. Each connection's request data is piped to a unique file. The server handles different request types, including file uploads via a simple HTML form, and returns appropriate responses. The server also logs connection activities.\n\nInput: None (The function uses environment variables or defaults for configuration, specifically the `PORT` environment variable or defaults to 8080.)\n\nOutput: None (The function creates and starts an HTTP server that runs indefinitely, logging activities to the console and writing request data to files.)\n\nNote: The function does not explicitly return any value but has side effects of creating a running server and writing files to the filesystem.",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport os\nimport http.server\nimport socketserver\nimport threading\nimport time\nfrom urllib.parse import urlparse, parse_qs\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.handle_request()\n\n    def do_POST(self):\n        self.handle_request()\n\n    def handle_request(self):\n        parsed_path = urlparse(self.path)\n        query_components = parse_qs(parsed_path.query)\n        connection_id = query_components.get('connection_id', [self.client_address[0] + str(time.time())])[0]\n        file_path = f\"{connection_id}.txt\"\n        with open(file_path, 'w') as file:\n            file.write(self.rfile.read().decode())\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b\"Request data recorded.\")\n\ndef createServer():\n    PORT = os.getenv('PORT', '8080')\n    handler = CustomHTTPRequestHandler\n    with socketserver.ThreadingTCPServer((\"\", int(PORT)), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport urllib.parse\n\nclass ThreadedHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.handle_request()\n\n    def do_POST(self):\n        self.handle_request()\n\n    def handle_request(self):\n        connection_id = self.client_address[0] + str(time.time())\n        request_path = urllib.parse.urlparse(self.path).path\n        file_name = f\"{connection_id}.txt\"\n        file_path = os.path.join(\"logs\", file_name)\n\n        with open(file_path, 'w') as file:\n            file.write(f\"Connection from {self.client_address}\\n\")\n            file.write(f\"Request path: {request_path}\\n\")\n            file.write(f\"Request headers: {self.headers}\\n\")\n\n        if self.command == 'POST':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            with open(file_path, 'a') as file:\n                file.write(f\"POST data: {post_data}\\n\")\n\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b\"Request received\")\n\ndef createServer():\n    PORT = os.getenv('PORT', 8080)\n    os.makedirs('logs', exist_ok=True)\n    server_address = ('', PORT)\n    httpd = ThreadedHTTPServer(server_address, RequestHandler)\n    print(f\"Starting httpd server on port {PORT}\")\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nfrom urllib.parse import urlparse, parse_qs\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.handle_request()\n\n    def do_POST(self):\n        self.handle_request()\n\n    def handle_request(self):\n        parsed_path = urlparse(self.path)\n        query_components = parse_qs(parsed_path.query)\n        connection_id = query_components.get('connection_id', [self.client_address[0] + str(time.time())])[0]\n        file_path = f\"{connection_id}.txt\"\n        with open(file_path, 'w') as file:\n            file.write(self.rfile.read().decode())\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b\"Request data saved to file.\")\n\ndef createServer():\n    PORT = os.getenv('PORT', '8080')\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", int(PORT)), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport mimetypes\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b\"<html><body><form method='POST' enctype='multipart/form-data'>\"\n                         b\"<input type='file' name='file'><input type='submit'>\"\n                         b\"</form></body></html>\")\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        connection_id = self.client_address[0] + '-' + str(time.time())\n        file_path = f\"{connection_id}.txt\"\n        with open(file_path, 'wb') as file:\n            file.write(post_data)\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b\"File uploaded successfully.\")\n\ndef createServer():\n    PORT = os.getenv('PORT', '8080')\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", int(PORT)), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\ncreateServer()\n```",
      "```python\nimport os\nimport http.server\nimport socketserver\nimport threading\nfrom urllib.parse import urlparse, parse_qs\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.handle_request()\n\n    def do_POST(self):\n        self.handle_request()\n\n    def handle_request(self):\n        parsed_path = urlparse(self.path)\n        query_components = parse_qs(parsed_path.query)\n        connection_id = query_components.get('connection_id', [self.client_address[0] + ':' + str(self.client_port)])[0]\n        file_path = os.path.join('logs', f\"{connection_id}.txt\")\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        with open(file_path, 'a') as file:\n            file.write(f\"Connection from {self.client_address} at {self.command} {self.path}\\n\")\n            file.write(f\"Headers: {self.headers}\\n\")\n            file.write(f\"Body: {self.rfile.read().decode()}\\n\")\n            file.write(f\"Query: {query_components}\\n\")\n            file.write(\"-\" * 40 + \"\\n\")\n        if self.command == 'POST':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b\"Data received and logged.\")\n        else:\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b\"Request received and logged.\")\n\ndef createServer():\n    PORT = os.getenv('PORT', '8080')\n    handler = CustomHTTPRequestHandler\n    with socketserver.ThreadingTCPServer((\"\", int(PORT)), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\ncreateServer()\n```",
      "```python\nimport os\nimport socketserver\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport threading\nimport time\n\nclass RequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b\"<html><body><form method='POST' enctype='multipart/form-data' action='/upload'>\"\n                        b\"<input type='file' name='file'><input type='submit'>\"\n                        b\"</form></body></html>\")\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        connection_id = self.client_address[0]\n        timestamp = time.strftime(\"%Y%m%d-%H%M%S\")\n        filename = f\"{timestamp}-{connection_id}.txt\"\n        with open(filename, 'wb') as f:\n            f.write(post_data)\n        self.send_response(200)\n        self.send_header('Content-type', 'text/plain')\n        self.end_headers()\n        self.wfile.write(b\"File uploaded successfully.\")\n\ndef createServer():\n    PORT = os.getenv('PORT', 8080)\n    with HTTPServer(('', PORT), RequestHandler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    threading.Thread(target=createServer).start()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport urllib.parse\n\nclass ThreadedHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.handle_request()\n\n    def do_POST(self):\n        self.handle_request()\n\n    def handle_request(self):\n        self.log_connection()\n        if self.path == \"/upload\":\n            self.handle_file_upload()\n        else:\n            self.handle_file_request()\n\n    def log_connection(self):\n        print(f\"Connection from {self.client_address} at {time.strftime('%Y-%m-%d %H:%M:%S')}\")\n\n    def handle_file_upload(self):\n        self.send_response(200)\n        self.end_headers()\n        file, filename = self.handle_file_upload_form()\n        self.wfile.write(f\"File {filename} uploaded successfully.\".encode())\n\n    def handle_file_upload_form(self):\n        content_length = int(self.headers['Content-Length'])\n        form_data = self.rfile.read(content_length)\n        form_data = urllib.parse.parse_qs(form_data.decode())\n        file = form_data.get('file', [None])[0]\n        filename = form_data.get('filename', [None])[0]\n        if file and filename:\n            with open(filename, 'wb') as f:\n                f.write(file)\n        return file, filename\n\n    def handle_file_request(self):\n        try:\n            self.send_response(200)\n            self.end_headers()\n            with open(self.path[1:], 'rb') as f:\n                self.wfile.write(f.read())\n        except FileNotFoundError:\n            self.send_error(404, \"File not found.\")\n\ndef createServer():\n    port = os.getenv('PORT', '8080')\n    handler = RequestHandler\n    with ThreadedHTTPServer(('', int(port)), handler) as httpd:\n        print(f\"Serving at port {port}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport mimetypes\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b'<html><body><form method=\"POST\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\">Upload</form></body></html>')\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        connection_id = self.client_address[0] + '-' + str(time.time())\n        file_path = f'uploads/{connection_id}.txt'\n        with open(file_path, 'wb') as file:\n            file.write(post_data)\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b'File uploaded successfully.')\n\ndef createServer():\n    PORT = os.getenv('PORT', '8080')\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", int(PORT)), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\ncreateServer()\n```",
      "```python\nimport os\nimport http.server\nimport socketserver\nimport threading\nimport time\nfrom urllib.parse import urlparse, parse_qs\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.handle_request()\n\n    def do_POST(self):\n        self.handle_request()\n\n    def handle_request(self):\n        parsed_path = urlparse(self.path)\n        query_components = parse_qs(parsed_path.query)\n        connection_id = query_components.get('connection_id', [self.client_address[0] + str(time.time())])[0]\n        file_path = f\"{connection_id}.txt\"\n        with open(file_path, 'w') as file:\n            file.write(self.rfile.read().decode())\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b\"Request data recorded.\")\n\ndef createServer():\n    PORT = os.getenv('PORT', '8080')\n    handler = CustomHTTPRequestHandler\n    with socketserver.ThreadingTCPServer((\"\", int(PORT)), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport threading\nimport time\nimport mimetypes\n\nclass ThreadedHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"\n\nclass RequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b\"<html><body><h1>Welcome to the server</h1></body></html>\")\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length)\n        connection_id = self.client_address[0] + '_' + str(time.time())\n        file_path = f'./requests/{connection_id}.txt'\n        with open(file_path, 'wb') as file:\n            file.write(post_data)\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(b\"<html><body><h1>Request recorded</h1></body></html>\")\n\ndef createServer():\n    PORT = os.getenv('PORT', '8080')\n    handler = RequestHandler\n    with ThreadedHTTPServer(('', int(PORT)), handler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\nif __name__ == '__main__':\n    createServer()\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files with specific Content Security Policy (CSP) rules, using pipe to stream file contents to the response.\n\nFunction Description: The function `createServer` creates and returns an HTTP server instance that serves static files from the root directory. It handles incoming requests by resolving the file path, applying CSP headers for security, and piping the file content to the response. If the request URL is '/', it defaults to serving 'index.html'.\n\nInput: None\n\nOutput: Returns an instance of `http.Server` configured to serve static files with CSP headers.",
    "Canonical_solution": "function createServer() {\n  const http = require('http');\n  const send = require('send');\n  const path = require('path');\n  const root = require('rootrequire');\n\n  return http.createServer(function (req, res) {\n    const url = req.url === '/' ? '/index.html' : req.url;\n    const file = path.resolve(root, url.slice(1));\n\n    const cspRules = [\n      `default-src 'self' https://cdnjs.cloudflare.com`,\n      `img-src * data: blob:`,\n      `media-src * data: blob:`,\n      `font-src https://fonts.googleapis.com https://fonts.gstatic.com`,\n      `style-src 'self' 'unsafe-inline' https://fonts.googleapis.com`,\n      `script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com`,\n      `worker-src 'self' blob:`\n    ];\n\n    res.setHeader('content-security-policy', cspRules.join('; '));\n\n    send(req, file).pipe(res);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = req.url === '/' ? 'index.html' : req.url;\n    filePath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {\n          'Content-Type': getContentType(filePath),\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n        });\n        fs.createReadStream(filePath).pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath);\n  switch (ext) {\n    case '.html':\n      return 'text/html';\n    case '.css':\n      return 'text/css';\n    case '.js':\n      return 'application/javascript';\n    case '.png':\n      return 'image/png';\n    case '.jpg':\n      return 'image/jpeg';\n    case '.jpeg':\n      return 'image/jpeg';\n    case '.gif':\n      return 'image/gif';\n    case '.svg':\n      return 'image/svg+xml';\n    default:\n      return 'application/octet-stream';\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = req.url === '/' ? 'index.html' : req.url;\n    filePath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {\n          'Content-Type': 'text/html',\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n        });\n\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = req.url === '/' ? 'index.html' : req.url;\n    filePath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {\n          'Content-Type': getContentType(filePath),\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n        });\n        fs.createReadStream(filePath).pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath);\n  switch (ext) {\n    case '.html':\n      return 'text/html';\n    case '.css':\n      return 'text/css';\n    case '.js':\n      return 'application/javascript';\n    case '.png':\n      return 'image/png';\n    case '.jpg':\n      return 'image/jpeg';\n    case '.jpeg':\n      return 'image/jpeg';\n    case '.gif':\n      return 'image/gif';\n    case '.svg':\n      return 'image/svg+xml';\n    default:\n      return 'application/octet-stream';\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = req.url === '/' ? 'index.html' : req.url;\n    filePath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {\n          'Content-Type': getContentType(filePath),\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';\"\n        });\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath);\n  switch (ext) {\n    case '.html':\n      return 'text/html';\n    case '.css':\n      return 'text/css';\n    case '.js':\n      return 'application/javascript';\n    case '.png':\n      return 'image/png';\n    case '.jpg':\n      return 'image/jpeg';\n    case '.jpeg':\n      return 'image/jpeg';\n    case '.gif':\n      return 'image/gif';\n    case '.svg':\n      return 'image/svg+xml';\n    default:\n      return 'application/octet-stream';\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = req.url === '/' ? 'index.html' : req.url;\n    filePath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {\n          'Content-Type': 'text/html',\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n        });\n        fs.createReadStream(filePath).pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = req.url === '/' ? 'index.html' : req.url;\n    const fullPath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(fullPath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n\n      if (stats.isFile()) {\n        res.writeHead(200, {\n          'Content-Type': 'text/html',\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n        });\n\n        const fileStream = fs.createReadStream(fullPath);\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = req.url === '/' ? 'index.html' : req.url;\n    const fullPath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(fullPath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {\n          'Content-Type': 'text/html',\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n        });\n        fs.createReadStream(fullPath).pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = req.url === '/' ? 'index.html' : req.url;\n    filePath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {\n          'Content-Type': 'text/html',\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n        });\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = req.url === '/' ? 'index.html' : req.url;\n    const fullPath = path.join(__dirname, 'root', filePath);\n\n    fs.stat(fullPath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n\n      if (stats.isFile()) {\n        res.writeHead(200, {\n          'Content-Type': 'application/octet-stream',\n          'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n        });\n\n        const fileStream = fs.createReadStream(fullPath);\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  return server;\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = req.url === '/' ? 'index.html' : req.url;\n    filePath = path.join(__dirname, 'root', filePath);\n\n    fs.readFile(filePath, (err, content) => {\n      if (err) {\n        res.writeHead(404);\n        res.end('File not found');\n        return;\n      }\n\n      res.writeHead(200, {\n        'Content-Type': 'text/html',\n        'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline';\"\n      });\n\n      res.end(content);\n    });\n  });\n\n  return server;\n}\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Retrieve and process TV channel information from multiple providers via HTTP requests, then extract and deduplicate channel details.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers array and automatically determines the current date)\n\nOutput: Array of objects containing unique TV channel information with the following structure:\n[\n    {\n        lang: string,       // Language code ('it' for Italian)\n        name: string,       // Channel name\n        site_id: string     // Unique identifier combining channel number and slug\n    },\n    ...\n]",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.guida.tv/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'Italy',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 1429,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'it',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [
      "const axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'http://provider1.com/tv-guide', post_data: { date: new Date().toISOString() } },\n    { url: 'http://provider2.com/tv-guide', post_data: { date: new Date().toISOString() } }\n];\n\nasync function getUniqueChannels() {\n    const channelInfo = [];\n    for (const provider of providers) {\n        try {\n            const response = await axios.post(provider.url, provider.post_data);\n            const $ = cheerio.load(response.data);\n            const channels = $('div.channel').map((i, channel) => {\n                const lang = $(channel).attr('data-lang');\n                const name = $(channel).find('span.channel-name').text();\n                const site_id = $(channel).attr('data-site-id');\n                return { lang, name, site_id };\n            }).get();\n            channelInfo.push(...channels);\n        } catch (error) {\n            console.error(`Error fetching channels from ${provider.url}:`, error);\n        }\n    }\n    return _.uniqBy(channelInfo, 'site_id');\n}",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'http://provider1.com/tv-guide', slug: 'provider1' },\n    { url: 'http://provider2.com/tv-guide', slug: 'provider2' },\n    // Add more providers as needed\n];\n\nasync function getChannels() {\n    const today = new Date().toISOString().split('T')[0];\n    const channels = [];\n\n    for (const provider of providers) {\n        try {\n            const response = await axios.post(provider.url, { date: today });\n            const $ = cheerio.load(response.data);\n            const channelList = $('.channel').map((i, el) => {\n                const lang = $(el).attr('data-lang');\n                const name = $(el).text();\n                const site_id = `${provider.slug}-${$(el).attr('data-channel-number')}-${$(el).attr('data-slug')}`;\n                return { lang, name, site_id };\n            }).get();\n\n            channels.push(...channelList);\n        } catch (error) {\n            console.error(`Error fetching channels from ${provider.url}:`, error);\n        }\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'http://provider1.com/tv-guide', slug: 'provider1' },\n    { url: 'http://provider2.com/tv-guide', slug: 'provider2' },\n    // Add more providers as needed\n];\n\nasync function getUniqueChannels() {\n    const channels = [];\n    const currentDate = new Date().toISOString().split('T')[0];\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, { date: currentDate });\n        const $ = cheerio.load(response.data);\n        const channelList = $('div.channel').map((i, el) => {\n            const lang = $(el).attr('data-lang');\n            const name = $(el).find('span.channel-name').text();\n            const site_id = `${provider.slug}-${$(el).attr('data-channel-number')}-${$(el).attr('data-slug')}`;\n            return { lang, name, site_id };\n        }).get();\n\n        channels.push(...channelList);\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'https://provider1.com/tv-guide', postBody: { date: new Date().toISOString() } },\n    { url: 'https://provider2.com/tv-guide', postBody: { date: new Date().toISOString() } }\n];\n\nasync function fetchChannels() {\n    const channelPromises = providers.map(provider => axios.post(provider.url, provider.postBody));\n    const channelResponses = await Promise.all(channelPromises);\n    const channels = channelResponses.map(response => cheerio.load(response.data)('.channel').map((index, element) => ({\n        lang: $(element).attr('data-lang'),\n        name: $(element).text(),\n        site_id: `${$(element).attr('data-channel-number')}-${$(element).attr('data-slug')}`\n    }))).flat();\n\n    return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'http://provider1.com/tv-guide', slug: 'provider1' },\n    { url: 'http://provider2.com/tv-guide', slug: 'provider2' },\n    // Add more providers as needed\n];\n\nasync function getUniqueChannels() {\n    const channels = [];\n    const currentDate = new Date().toISOString().slice(0, 10);\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, { date: currentDate });\n        const $ = cheerio.load(response.data);\n        const channelList = $('div.channel').map((i, el) => {\n            const lang = $(el).attr('data-lang');\n            const name = $(el).find('h3').text();\n            const site_id = `${provider.slug}-${$(el).attr('data-channel-number')}-${$(el).attr('data-slug')}`;\n            return { lang, name, site_id };\n        }).get();\n\n        channels.push(...channelList);\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'https://provider1.com/tv-guide', slug: 'provider1' },\n    { url: 'https://provider2.com/tv-guide', slug: 'provider2' },\n    // Add more providers as needed\n];\n\nasync function getUniqueChannels() {\n    const channels = [];\n    const currentDate = new Date().toISOString().split('T')[0];\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, { date: currentDate });\n        const $ = cheerio.load(response.data);\n        const channelList = $('div.channel').map((i, el) => {\n            const lang = $(el).attr('data-lang');\n            const name = $(el).text();\n            const site_id = `${provider.slug}-${$(el).attr('data-channel-number')}-${$(el).attr('data-slug')}`;\n            return { lang, name, site_id };\n        }).get();\n\n        channels.push(...channelList);\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'http://provider1.com/tv-guide', slug: 'provider1' },\n    { url: 'http://provider2.com/tv-guide', slug: 'provider2' },\n    // Add more providers as needed\n];\n\nasync function getUniqueChannels() {\n    const channels = [];\n    const currentDate = new Date().toISOString().split('T')[0];\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, { date: currentDate });\n        const $ = cheerio.load(response.data);\n        const channelList = $('div.channel').map((i, el) => {\n            const lang = $(el).attr('data-lang');\n            const name = $(el).find('span.channel-name').text();\n            const site_id = `${provider.slug}-${$(el).attr('data-channel-number')}-${$(el).attr('data-slug')}`;\n            return { lang, name, site_id };\n        }).get();\n\n        channels.push(...channelList);\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'http://provider1.com/tv-guide', slug: 'provider1' },\n    { url: 'http://provider2.com/tv-guide', slug: 'provider2' },\n    // Add more providers as needed\n];\n\nasync function fetchChannels() {\n    const channels = [];\n    const currentDate = new Date().toISOString().slice(0, 10);\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, { date: currentDate });\n        const $ = cheerio.load(response.data);\n        const channelList = $('div.channel').map((i, el) => {\n            const lang = $(el).attr('data-lang');\n            const name = $(el).find('span.channel-name').text();\n            const site_id = `${provider.slug}-${$(el).attr('data-channel-number')}-${$(el).attr('data-slug')}`;\n            return { lang, name, site_id };\n        }).get();\n\n        channels.push(...channelList);\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n```",
      "const axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'https://provider1.com/tv-guide', postBody: { date: new Date().toISOString() } },\n    { url: 'https://provider2.com/tv-guide', postBody: { date: new Date().toISOString() } },\n    // Add more providers as needed\n];\n\nasync function getUniqueChannels() {\n    const channelInfo = [];\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, provider.postBody);\n        const $ = cheerio.load(response.data);\n        const channels = $('div.channel').map((i, el) => {\n            return {\n                lang: $(el).attr('data-lang'),\n                name: $(el).text(),\n                site_id: $(el).attr('data-channel-number') + '-' + $(el).attr('data-slug')\n            };\n        }).get();\n        channelInfo.push(...channels);\n    }\n    return _.uniqBy(channelInfo, 'site_id');\n}",
      "const axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nconst providers = [\n    { url: 'http://provider1.com/tv-guide', slug: 'provider1' },\n    { url: 'http://provider2.com/tv-guide', slug: 'provider2' },\n    // Add more providers as needed\n];\n\nconst getCurrentDate = () => {\n    const now = new Date();\n    return now.toISOString().split('T')[0];\n};\n\nconst fetchChannels = async () => {\n    const currentDate = getCurrentDate();\n    const channels = [];\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, {\n            date: currentDate\n        });\n\n        const $ = cheerio.load(response.data);\n        const channelElements = $('div.channel');\n\n        channelElements.each((index, element) => {\n            const lang = $(element).attr('data-lang');\n            const name = $(element).find('h2.channel-name').text();\n            const site_id = `${provider.slug}-${$(element).attr('data-channel-id')}`;\n\n            channels.push({ lang, name, site_id });\n        });\n    }\n\n    return _.uniqBy(channels, 'site_id');\n};"
    ],
    "match_count": 2,
    "pass@3": 0.5333333333333333,
    "pass@5": 0.7777777777777778
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files, using Node.js's built-in `http` and `fs` modules. The server should handle different MIME types and pipe file contents to the response stream.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens on port 5000. It serves static files from the local file system, automatically determining the appropriate MIME type based on the file extension. If a requested file doesn't exist, it logs a warning. The function uses streaming to efficiently pipe file contents to the HTTP response.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server)",
    "Canonical_solution": "function createServer() {\n  var http = require('http'), fs = require('fs'), mimeTypes = {\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpg'\n  };\n\n  http.createServer(function (req, res) {\n    var file = (req.url === '/') ? 'index.html' : \".\" + req.url;\n    var ext = require('path').extname(file),\n      type = (mimeTypes[ext] ? mimeTypes[ext] : '');\n\n    fs.exists(file, function (exists) {\n      if (exists) {\n        res.writeHead(200, {'Content-Type': type});\n        fs.createReadStream(file).pipe(res);\n      } else {\n        console.warn(file, ' does not exit');\n      }\n    });\n  }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst mimeTypes = {\n  '.html': 'text/html',\n  '.js': 'application/javascript',\n  '.css': 'text/css',\n  '.json': 'application/json',\n  '.png': 'image/png',\n  '.jpg': 'image/jpeg',\n  '.jpeg': 'image/jpeg',\n  '.gif': 'image/gif',\n  '.svg': 'image/svg+xml',\n  '.txt': 'text/plain'\n};\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, req.url);\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        console.warn(`Warning: ${req.url} not found.`);\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n      if (stats.isFile()) {\n        const mimeType = mimeTypes[path.extname(filePath)] || 'application/octet-stream';\n        res.writeHead(200, { 'Content-Type': mimeType });\n        fs.createReadStream(filePath).pipe(res);\n      }\n    });\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n}\n\ncreateServer();\n```",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mime = require('mime');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      console.warn(`File not found: ${req.url}`);\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n      return;\n    }\n    if (stats.isFile()) {\n      const mimeType = mime.getType(filePath);\n      res.writeHead(200, { 'Content-Type': mimeType });\n      fs.createReadStream(filePath).pipe(res);\n    }\n  });\n});\n\nserver.listen(5000, () => {\n  console.log('Server running on port 5000');\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mimeTypes = {\n    '.html': 'text/html',\n    '.css': 'text/css',\n    '.js': 'application/javascript',\n    '.png': 'image/png',\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.gif': 'image/gif',\n    '.svg': 'image/svg+xml',\n    '.json': 'application/json',\n    '.txt': 'text/plain'\n};\n\nfunction createServer() {\n    const server = http.createServer((req, res) => {\n        const filePath = path.join(__dirname, 'public', req.url);\n        const fileExt = path.extname(filePath);\n        const contentType = mimeTypes[fileExt] || 'application/octet-stream';\n\n        fs.stat(filePath, (err, stats) => {\n            if (err) {\n                console.warn(`File ${req.url} not found.`);\n                res.writeHead(404, { 'Content-Type': 'text/plain' });\n                res.end('404 Not Found');\n                return;\n            }\n\n            if (!stats.isFile()) {\n                console.warn(`File ${req.url} is not a file.`);\n                res.writeHead(403, { 'Content-Type': 'text/plain' });\n                res.end('403 Forbidden');\n                return;\n            }\n\n            res.writeHead(200, { 'Content-Type': contentType });\n            const fileStream = fs.createReadStream(filePath);\n            fileStream.pipe(res);\n        });\n    });\n\n    server.listen(5000, () => {\n        console.log('Server is running on port 5000');\n    });\n}\n\ncreateServer();",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst mimeTypes = {\n  '.html': 'text/html',\n  '.css': 'text/css',\n  '.js': 'application/javascript',\n  '.json': 'application/json',\n  '.png': 'image/png',\n  '.jpg': 'image/jpeg',\n  '.jpeg': 'image/jpeg',\n  '.gif': 'image/gif',\n  '.svg': 'image/svg+xml',\n  '.txt': 'text/plain'\n};\n\nfunction getMimeType(filename) {\n  return mimeTypes[path.extname(filename)] || 'application/octet-stream';\n}\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, req.url);\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        console.warn(`File not found: ${req.url}`);\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n      if (stats.isFile()) {\n        const mimeType = getMimeType(filePath);\n        res.writeHead(200, { 'Content-Type': mimeType });\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on http://localhost:5000');\n  });\n}\n\ncreateServer();\n```",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mime = require('mime');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'public', req.url);\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      console.warn(`Warning: ${req.url} not found.`);\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n      return;\n    }\n    if (stats.isFile()) {\n      const mimeType = mime.getType(filePath);\n      res.writeHead(200, { 'Content-Type': mimeType });\n      fs.createReadStream(filePath).pipe(res);\n    }\n  });\n});\n\nserver.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mime = require('mime');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'public', req.url);\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      console.warn(`Warning: ${req.url} not found.`);\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n      return;\n    }\n    if (stats.isFile()) {\n      const mimeType = mime.getType(filePath);\n      res.writeHead(200, { 'Content-Type': mimeType });\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    }\n  });\n});\n\nserver.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mime = require('mime');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'public', req.url);\n  const fileExt = path.extname(filePath);\n  const contentType = mime.getType(fileExt);\n\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      console.warn(`File not found: ${req.url}`);\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n    } else if (stats.isFile()) {\n      res.writeHead(200, { 'Content-Type': contentType });\n      fs.createReadStream(filePath).pipe(res);\n    }\n  });\n});\n\nserver.listen(5000, () => {\n  console.log('Server running on port 5000');\n});",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mime = require('mime');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, req.url);\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        console.warn(`File not found: ${req.url}`);\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n      if (stats.isFile()) {\n        const mimeType = mime.getType(filePath);\n        res.writeHead(200, { 'Content-Type': mimeType });\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n}\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mime = require('mime');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, req.url);\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        console.warn(`Warning: ${req.url} not found.`);\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n      if (stats.isFile()) {\n        const mimeType = mime.getType(filePath);\n        res.writeHead(200, { 'Content-Type': mimeType });\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n}\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mime = require('mime');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, 'public', req.url);\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      console.warn(`File not found: ${req.url}`);\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n      return;\n    }\n    if (stats.isFile()) {\n      const mimeType = mime.getType(filePath);\n      res.writeHead(200, { 'Content-Type': mimeType });\n      fs.createReadStream(filePath).pipe(res);\n    }\n  });\n});\n\nserver.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for POST requests on a specified port. When a POST request is received, it pipes the request data through a transformation stream that converts the data to uppercase, then pipes the transformed data back to the response. For non-POST requests, it simply ends the response.\n\nInput:  \n- `port` (Number) - The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up the server but does not return any value).",
    "Canonical_solution": "const http = require('http');\nconst through = require('through2');\n\nfunction createServer(port) {\n  const server = http.createServer(function (req, res) {\n    if (req.method === 'POST') {\n      req.pipe(through(function (buf, _, next) {\n        this.push(buf.toString().toUpperCase());\n        next();\n      })).pipe(res);\n    } else res.end();\n  });\n  server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve a ReDoc documentation interface, including handling requests for the ReDoc JavaScript file and rendering the documentation page with the provided specification.\n\nFunction Description: The function creates an HTTP server that serves two main routes: (1) '/redoc.standalone.js' which streams the ReDoc JavaScript file to the client, and (2) '/' which renders a complete HTML page with the ReDoc interface hydrated with the provided OpenAPI specification. The server handles other routes with a 404 response.\n\nInput:\n- port: [number] - The port number on which the HTTP server should listen\n- filePath: [string] - The file path to the 'redoc.standalone.js' file to be served\n- specPath: [string] - The file path to the OpenAPI specification file (YAML format)\n\nOutput: None (The function starts an HTTP server that continues running until manually stopped)\n\nNote: The function assumes the availability of certain external dependencies (yaml, fs, http, React, ServerStyleSheet, Redoc) which should be imported/required in the actual implementation. The function also uses async/await for handling asynchronous operations related to the Redoc store creation.",
    "Canonical_solution": "const http = require('http');\nconst fs = require('fs');\n\nfunction createServer(port, filePath, specPath) {\n    const server = http.createServer(async (request, response) => {\n        if (request.url === '/redoc.standalone.js') {\n            fs.createReadStream(filePath, 'utf8').pipe(response);\n        } else if (request.url === '/') {\n            const spec = yaml.load(readFileSync(resolve(__dirname, specPath), 'utf-8'));\n            const store = await createStore(spec, 'path/to/spec.yaml');\n\n            const sheet = new ServerStyleSheet();\n            const html = renderToString(sheet.collectStyles(React.createElement(Redoc, { store })));\n            const css = sheet.getStyleTags();\n\n            const res = `<html>\n            <head>\n                <meta charset=\"utf8\" />\n                <title>ReDoc</title>\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                <style>\n                    body {\n                        padding: 0;\n                        margin: 0;\n                    }\n                </style>\n                <script src=\"redoc.standalone.js\"></script>\n                <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n                ${css}\n            </head>\n            <body>\n            <script>\n                document.addEventListener('DOMContentLoaded', function() {\n                    const state = ${JSON.stringify(await store.toJS())};\n                    Redoc.hydrate(state, document.getElementById('redoc'));\n                });\n                </script>\n                <div id=\"redoc\">${html}</div>\n            </body>\n            </html>`;\n            response.writeHead(200, { 'Content-Length': res.length });\n            response.write(res);\n            response.end();\n        } else {\n            response.writeHead(404);\n            response.write('Not found');\n            response.end();\n        }\n    });\n\n    server.listen(port, () => console.log(`Server started: http://127.0.0.1:${port}`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { renderToStaticMarkup } = require('react-dom/server');\nconst ServerStyleSheet = require('styled-components/lib/models/ServerStyleSheet');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    } else if (req.url === '/') {\n      const sheet = new ServerStyleSheet();\n      const spec = YAML.parse(fs.readFileSync(specPath, 'utf8'));\n      const doc = await Redoc.render(spec, {\n        theme: 'dark',\n        showMenu: true,\n        showDownload: true,\n        showExpandButton: true,\n        showSidebar: true,\n        sidebarPosition: 'left',\n        scrollable: true,\n        scrollPosition: 'auto',\n        scrollOffset: 0,\n        showLinter: true,\n        showCopyButton: true,\n        showAboutButton: true,\n        showVersion: true,\n        showFooter: true,\n        showUnsavedChangesWarning: true,\n        showExpandButton: true,\n        showExpandableSection: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableRequestHeaders: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples: true,\n        showExpandableSchema: true,\n        showExpandableExternalDocs: true,\n        showExpandableSecurity: true,\n        showExpandableServer: true,\n        showExpandableHeaders: true,\n        showExpandableOperations: true,\n        showExpandableParameters: true,\n        showExpandableResponseHeaders: true,\n        showExpandableExamples",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc');\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      fs.createReadStream(filePath).pipe(res);\n    } else if (req.url === '/') {\n      try {\n        const spec = await yaml.load(fs.readFileSync(specPath, 'utf8'));\n        const sheet = new ServerStyleSheet();\n        const { renderToStaticMarkup } = require('react-dom/server');\n        const html = renderToStaticMarkup(sheet.collectStyles(<Redoc spec={spec} theme={{}}\n                                                                 components={{}}\n                                                                 path={req.url}\n                                                                 additionalProps={{ className: sheet.getStyleElement().map(el => el.props.style).join(' ') }}\n                                                                 onReady={doc => res.writeHead(200, { 'Content-Type': 'text/html' });\n                                                                 res.end(`<html><head>${sheet.getStyleElement()}</head><body>${doc}</body></html>`);\n                                                                 sheet.seal(); })());\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(`<html><head>${sheet.getStyleElement()}</head><body>${html}</body></html>`);\n      } catch (error) {\n        res.writeHead(500);\n        res.end('Internal Server Error');\n      }\n    } else {\n      res.writeHead(404);\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n  });\n}\n\nsetupRedocServer(3000, 'path/to/redoc.standalone.js', 'path/to/openapi.yaml');\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    } else if (req.url === '/') {\n      try {\n        const spec = await yaml.safeLoad(fs.readFileSync(specPath, 'utf8'));\n        const sheet = new ServerStyleSheet();\n        const { renderToStaticMarkup } = require('react-dom/server');\n        const markup = renderToStaticMarkup(sheet.collectStyles(<Redoc spec={spec} theme={{}}\n          scriptComponents={{ RedocDownloadButton: () => null }} />));\n        const styleTags = sheet.getStyleElement();\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(`<!DOCTYPE html><html><head>${styleTags}</head><body>${markup}</body></html>`);\n      } catch (error) {\n        res.writeHead(404);\n        res.end('Not Found');\n      }\n    } else {\n      res.writeHead(404);\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nsetupRedocServer(3000, 'path/to/redoc.standalone.js', 'path/to/openapi.yaml');\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      fs.createReadStream(filePath).pipe(res);\n    } else if (req.url === '/') {\n      const spec = await yaml.safeLoad(fs.readFileSync(specPath, 'utf8'));\n      const sheet = new ServerStyleSheet();\n      const html = sheet.collectStyles(\n        <Redoc spec={spec} scriptUrl=\"/redoc.standalone.js\" serverUrl=\"/\"></Redoc>\n      );\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(`<!DOCTYPE html><html><head>${sheet.getStyleElement()}</head><body>${html}</body></html>`);\n    } else {\n      res.writeHead(404);\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nsetupRedocServer(port, filePath, specPath);\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      fs.createReadStream(filePath).pipe(res);\n    } else if (req.url === '/') {\n      const spec = await yaml.safeLoad(fs.readFileSync(specPath, 'utf8'));\n      const sheet = new ServerStyleSheet();\n      const { renderToStaticMarkup } = require('react-dom/server');\n      const html = renderToStaticMarkup(sheet.collectStyles(<Redoc spec={spec} theme={{} />)));\n      sheet.seal();\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(`<!DOCTYPE html><html><head>${sheet.getStyleElement()}</head><body>${html}</body></html>`);\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nsetupRedocServer(3000, 'path/to/redoc.standalone.js', 'path/to/openapi.yaml');\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    } else if (req.url === '/') {\n      const spec = await yaml.safeLoad(fs.readFileSync(specPath, 'utf8'));\n      const sheet = new ServerStyleSheet();\n      const html = sheet.collectStyles(\n        <Redoc spec={spec} scriptUrl=\"/redoc.standalone.js\" serverUrl={''} />\n      ).toString();\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(html);\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nsetupRedocServer(3000, 'path/to/redoc.standalone.js', 'path/to/openapi.yaml');\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    } else if (req.url === '/') {\n      try {\n        const spec = await yaml.safeLoad(fs.readFileSync(specPath, 'utf8'));\n        const sheet = new ServerStyleSheet();\n        const html = sheet.collectStyles(\n          <Redoc spec={spec} scriptUrl=\"/redoc.standalone.js\" serverUrl={req.url} />\n        ).toString();\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(html);\n      } catch (error) {\n        res.writeHead(404);\n        res.end('Not Found');\n      }\n    } else {\n      res.writeHead(404);\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nsetupRedocServer(3000, 'path/to/redoc.standalone.js', 'path/to/openapi.yaml');\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    } else if (req.url === '/') {\n      try {\n        const spec = await yaml.safeLoad(fs.readFileSync(specPath, 'utf8'));\n        const sheet = new ServerStyleSheet();\n        const html = Redoc.render(spec, {\n          theme: 'dark',\n          showMenu: true,\n          requireConfig: true,\n          requireRedoc: false,\n          loading: 'Loading...',\n          noAutoRender: true,\n          stylesheets: [sheet.getStyleElement()],\n        });\n        const styleTags = sheet.getStyleTags();\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(`<!DOCTYPE html><html><head>${styleTags}</head><body>${html}</body></html>`);\n      } catch (error) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error serving ReDoc');\n      }\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nsetupRedocServer(3000, 'path/to/redoc.standalone.js', 'path/to/openapi.yaml');\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    } else if (req.url === '/') {\n      try {\n        const spec = await yaml.safeLoad(fs.readFileSync(specPath, 'utf8'));\n        const sheet = new ServerStyleSheet();\n        const html = sheet.collectStyles(\n          <Redoc spec={spec} scriptUrl=\"/redoc.standalone.js\" serverUrl={req.headers.host} />\n        ).toString();\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(html);\n      } catch (error) {\n        res.writeHead(404);\n        res.end('Not Found');\n      }\n    } else {\n      res.writeHead(404);\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nsetupRedocServer(3000, 'path/to/redoc.standalone.js', 'path/to/openapi.yaml');\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('yaml');\nconst React = require('react');\nconst ServerStyleSheet = require('styled-components/server');\nconst Redoc = require('redoc').Redoc;\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    } else if (req.url === '/') {\n      try {\n        const spec = await yaml.safeLoad(fs.readFileSync(specPath, 'utf8'));\n        const sheet = new ServerStyleSheet();\n        const { renderToStaticMarkup } = require('react-dom/server');\n        const html = renderToStaticMarkup(sheet.collectStyles(<Redoc spec={spec} theme={{}}\n                                                                 scriptUrl=\"/redoc.standalone.js\"\n                                                                 showDownloadButton={false}\n                                                                 showOpenAPIIcon={false}\n                                                                 showLogo={false}\n                                                                 showVersion={false}\n                                                                 lazyLoad={false}\n                                                                 requireConfig={false}\n                                                                 requireRedocLib={false}\n                                                                 requireRedocStandalone={false}\n                                                                 requireRedocCDN={false}\n                                                                 requireRedocCDNMin={false}\n                                                                 requireRedocCDNVersion={false}\n                                                                 requireRedocCDNMinVersion={false}\n                                                                 requireRedocCDNMinBuild={false}\n                                                                 requireRedocCDNMinBuildVersion={false}\n                                                                 requireRedocCDNMinBuildHash={false}\n                                                                 requireRedocCDNMinBuildHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashVersion={false}\n                                                                 requireRedocCDNMinBuildHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHashHash"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle various routes and perform different operations based on the request method and URL, including piping data between requests.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming requests and routes them based on the URL path. It supports GET and PUT methods, proxies requests, and pipes data between different endpoints. The server responds differently depending on the route accessed, such as returning content, processing uploaded data, or proxying requests.\n\nInput: None\n\nOutput: Returns an HTTP server instance configured to handle specific routes and methods. The server responds to the following URLs:\n- `/get`: Handles GET requests and returns 'content'.\n- `/put`: Handles PUT requests, checks the uploaded data, and returns 'success' if the data matches 'content'.\n- `/proxy`: Proxies PUT requests to the `/put` endpoint and pipes the response back to the client.\n- `/test`: Chains requests by piping data from `/get` to `/proxy` and then to the client.\n- Any other URL results in an error.",
    "Canonical_solution": "var http = require('http');\nvar request = require('../index');\n\nfunction createServer() {\n    var server = http.createServer(function (req, resp) {\n        resp.statusCode = 200;\n        if (req.url === '/get') {\n            assert.equal(req.method, 'GET');\n            resp.write('content');\n            resp.end();\n            return;\n        }\n        if (req.url === '/put') {\n            var x = '';\n            assert.equal(req.method, 'PUT');\n            req.on('data', function (chunk) {\n                x += chunk;\n            });\n            req.on('end', function () {\n                assert.equal(x, 'content');\n                resp.write('success');\n                resp.end();\n            });\n            return;\n        }\n        if (req.url === '/proxy') {\n            assert.equal(req.method, 'PUT');\n            req.pipe(request(server.url + '/put')).pipe(resp);\n            return;\n        }\n        if (req.url === '/test') {\n            request(server.url + '/get').pipe(request.put(server.url + '/proxy')).pipe(resp);\n            return;\n        }\n        throw new Error('Unknown url', req.url);\n    });\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst { StringDecoder } = require('string_decoder');\n\nconst server = http.createServer((req, res) => {\n  const path = req.url;\n  const method = req.method;\n\n  if (path === '/get') {\n    if (method === 'GET') {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('content');\n    } else {\n      res.writeHead(405);\n      res.end();\n    }\n  } else if (path === '/put') {\n    if (method === 'PUT') {\n      let body = '';\n      const decoder = new StringDecoder('utf-8');\n      req.on('data', (chunk) => {\n        body += decoder.write(chunk);\n      });\n      req.on('end', () => {\n        body += decoder.end();\n        if (body === 'content') {\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          res.end('success');\n        } else {\n          res.writeHead(400);\n          res.end();\n        }\n      });\n    } else {\n      res.writeHead(405);\n      res.end();\n    }\n  } else if (path === '/proxy') {\n    if (method === 'PUT') {\n      const proxyReq = http.request({\n        hostname: 'localhost',\n        port: 3000,\n        path: '/put',\n        method: 'PUT'\n      }, (proxyRes) => {\n        let proxyBody = '';\n        proxyRes.on('data', (chunk) => {\n          proxyBody += chunk;\n        });\n        proxyRes.on('end', () => {\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          res.end(proxyBody);\n        });\n      });\n      proxyReq.on('error', (e) => {\n        res.writeHead(500);\n        res.end();\n      });\n      req.pipe(proxyReq);\n      proxyReq.end();\n    } else {\n      res.writeHead(405);\n      res.end();\n    }\n  } else if (path === '/test') {\n    const getReq = http.request({\n      hostname: 'localhost',\n      port: 3000,\n      path: '/get',\n      method: 'GET'\n    }, (getRes) => {\n      getRes.pipe(res);\n    });\n    getReq.on('error', (e) => {\n      res.writeHead(500);\n      res.end();\n    });\n    getReq.end();\n  } else {\n    res.writeHead(404);\n    res.end();\n  }\n});\n\nmodule.exports = server;\n```"
    ],
    "unmatched_results": [
      "```python\nimport http.server\nimport socketserver\nfrom urllib.parse import urlparse\nfrom io import BytesIO\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/get':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'content')\n\n    def do_PUT(self):\n        if self.path == '/put':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            if post_data == b'content':\n                self.send_response(200)\n                self.send_header('Content-type', 'text/plain')\n                self.end_headers()\n                self.wfile.write(b'success')\n            else:\n                self.send_error(400, 'Invalid data')\n        elif self.path == '/proxy':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'success')\n        else:\n            self.send_error(404, 'Not Found')\n\n    def do_POST(self):\n        if self.path == '/test':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'success')\n\ndef createServer():\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", 8000), handler) as httpd:\n        print(\"serving at port\", 8000)\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport urllib.request\nfrom http import HTTPStatus\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/get':\n            self.send_response(HTTPStatus.OK)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'content')\n        else:\n            self.send_error(HTTPStatus.NOT_FOUND, \"Not Found: %s\" % self.path)\n\n    def do_PUT(self):\n        if self.path == '/put':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            if post_data == b'content':\n                self.send_response(HTTPStatus.OK)\n                self.send_header('Content-type', 'text/plain')\n                self.end_headers()\n                self.wfile.write(b'success')\n            else:\n                self.send_error(HTTPStatus.BAD_REQUEST, \"Bad Request: Data does not match 'content'\")\n        elif self.path == '/proxy':\n            proxy_url = 'http://localhost:8000/put'\n            req = urllib.request.Request(proxy_url, data=self.rfile.read(), headers={'Content-Type': 'application/octet-stream'})\n            with urllib.request.urlopen(req) as response:\n                self.send_response(response.status)\n                self.send_header('Content-type', response.getheader('Content-Type'))\n                self.end_headers()\n                self.wfile.write(response.read())\n        elif self.path == '/test':\n            self.send_response(HTTPStatus.OK)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'content')\n            self.copyfile(urllib.request.urlopen('http://localhost:8000/proxy'), self.wfile)\n        else:\n            self.send_error(HTTPStatus.NOT_FOUND, \"Not Found: %s\" % self.path)\n\ndef createServer():\n    port = 8000\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", port), handler) as httpd:\n        print(\"serving at port\", port)\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport urllib.parse\nimport subprocess\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/get':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'content')\n        else:\n            self.send_error(404, \"Not Found: %s\" % self.path)\n\n    def do_PUT(self):\n        if self.path == '/put':\n            content_length = int(self.headers['Content-Length'])\n            content = self.rfile.read(content_length)\n            if content == b'content':\n                self.send_response(200)\n                self.send_header('Content-type', 'text/plain')\n                self.end_headers()\n                self.wfile.write(b'success')\n            else:\n                self.send_error(400, \"Invalid content\")\n        elif self.path == '/proxy':\n            self.proxy_request()\n        else:\n            self.send_error(404, \"Not Found: %s\" % self.path)\n\n    def proxy_request(self):\n        proxy_url = 'http://localhost:8000/put'\n        parsed_url = urllib.parse.urlparse(proxy_url)\n        proxy_path = parsed_url.path\n        proxy_port = parsed_url.port or 80\n        proxy_host = parsed_url.hostname\n\n        try:\n            with subprocess.Popen(['curl', '-X', 'PUT', '-d', 'content', proxy_url], stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:\n                stdout, stderr = proc.communicate()\n                if proc.returncode == 0:\n                    self.send_response(200)\n                    self.send_header('Content-type', 'text/plain')\n                    self.end_headers()\n                    self.wfile.write(stdout)\n                else:\n                    self.send_error(500, \"Proxy error: %s\" % stderr.decode())\n        except Exception as e:\n            self.send_error(500, \"Proxy error: %s\" % str(e))\n\n    def do_POST(self):\n        if self.path == '/test':\n            self.chain_requests()\n        else:\n            self.send_error(404, \"Not Found: %s\" % self.path)\n\n    def chain_requests(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/plain')\n        self.end_headers()\n\n        # Chain GET to proxy to client\n        self.proxy_request_to_client('http://localhost:8000/get')\n\n        # Chain proxy to client\n        self.proxy_request_to_client('http://localhost:8000/proxy')\n\n    def proxy_request_to_client(self, url):\n        parsed_url = urllib.parse.urlparse(url)\n        proxy_path = parsed_url.path\n        proxy_port = parsed_url.port or 80\n        proxy_host = parsed_url.hostname\n\n        try:\n            with subprocess.Popen(['curl', '-X', 'GET', url], stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:\n                stdout, stderr = proc.communicate()\n                if proc.returncode == 0:\n                    self.wfile.write(stdout)\n                else:\n                    self.send_error(500, \"Proxy error: %s\" % stderr.decode())\n        except Exception as e:\n            self.send_error(500, \"Proxy error: %s\" % str(e))\n\ndef createServer():\n    PORT = 8000\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", PORT), handler) as httpd:\n        print(\"serving at port\", PORT)\n        httpd.serve_forever()\n```",
      "```javascript\nconst http = require('http');\nconst { StringDecoder } = require('string_decoder');\n\nconst server = http.createServer((req, res) => {\n  const decoder = new StringDecoder('utf-8');\n  let buffer = '';\n  req.on('data', (data) => {\n    buffer += decoder.write(data);\n  });\n  req.on('end', () => {\n    buffer += decoder.end();\n    handleRequest(req, res, buffer);\n  });\n});\n\nfunction handleRequest(req, res, data) {\n  const url = req.url;\n  const method = req.method;\n\n  switch (url) {\n    case '/get':\n      if (method === 'GET') {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('content');\n      } else {\n        sendErrorResponse(res);\n      }\n      break;\n    case '/put':\n      if (method === 'PUT') {\n        if (data === 'content') {\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          res.end('success');\n        } else {\n          sendErrorResponse(res);\n        }\n      } else {\n        sendErrorResponse(res);\n      }\n      break;\n    case '/proxy':\n      if (method === 'PUT') {\n        const options = {\n          hostname: 'localhost',\n          port: 3000,\n          path: '/put',\n          method: 'PUT',\n          headers: {\n            'Content-Type': 'text/plain',\n          },\n        };\n        const proxyReq = http.request(options, (proxyRes) => {\n          let proxyBuffer = '';\n          proxyRes.on('data', (data) => {\n            proxyBuffer += data;\n          });\n          proxyRes.on('end', () => {\n            res.writeHead(200, { 'Content-Type': 'text/plain' });\n            res.end(proxyBuffer);\n          });\n        });\n        proxyReq.on('error', (e) => {\n          sendErrorResponse(res);\n        });\n        proxyReq.write(data);\n        proxyReq.end();\n      } else {\n        sendErrorResponse(res);\n      }\n      break;\n    case '/test':\n      if (method === 'GET') {\n        const getOptions = {\n          hostname: 'localhost',\n          port: 3000,\n          path: '/get',\n          method: 'GET',\n        };\n        const getReq = http.request(getOptions, (getRes) => {\n          let getBuffer = '';\n          getRes.on('data', (data) => {\n            getBuffer += data;\n          });\n          getRes.on('end', () => {\n            const proxyOptions = {\n              hostname: 'localhost',\n              port: 3000,\n              path: '/proxy',\n              method: 'PUT',\n              headers: {\n                'Content-Type': 'text/plain',\n              },\n            };\n            const proxyReq = http.request(proxyOptions, (proxyRes) => {\n              let proxyBuffer = '';\n              proxyRes.on('data', (data) => {\n                proxyBuffer += data;\n              });\n              proxyRes.on('end', () => {\n                res.writeHead(200, { 'Content-Type': 'text/plain' });\n                res.end(proxyBuffer);\n              });\n            });\n            proxyReq.on('error', (e) => {\n              sendErrorResponse(res);\n            });\n            proxyReq.write(getBuffer);\n            proxyReq.end();\n          });\n        });\n        getReq.on('error', (e) => {\n          sendErrorResponse(res);\n        });\n        getReq.end();\n      } else {\n        sendErrorResponse(res);\n      }\n      break;\n    default:\n      sendErrorResponse(res);\n  }\n}\n\nfunction sendErrorResponse(res) {\n  res.writeHead(404, { 'Content-Type': 'text/plain' });\n  res.end('Error: Not Found');\n}\n\nmodule.exports = server;\n```",
      "```javascript\nconst http = require('http');\nconst { StringDecoder } = require('string_decoder');\n\nfunction createServer() {\n    const server = http.createServer((req, res) => {\n        const decoder = new StringDecoder('utf-8');\n        let buffer = '';\n        req.on('data', (data) => {\n            buffer += decoder.write(data);\n        });\n        req.on('end', () => {\n            buffer += decoder.end();\n            handleRequest(req, res, buffer);\n        });\n    });\n\n    function handleRequest(req, res, data) {\n        const url = req.url;\n        const method = req.method;\n\n        switch (url) {\n            case '/get':\n                if (method === 'GET') {\n                    res.writeHead(200, { 'Content-Type': 'text/plain' });\n                    res.end('content');\n                } else {\n                    sendError(res, 405, 'Method Not Allowed');\n                }\n                break;\n            case '/put':\n                if (method === 'PUT') {\n                    if (data === 'content') {\n                        res.writeHead(200, { 'Content-Type': 'text/plain' });\n                        res.end('success');\n                    } else {\n                        sendError(res, 400, 'Bad Request');\n                    }\n                } else {\n                    sendError(res, 405, 'Method Not Allowed');\n                }\n                break;\n            case '/proxy':\n                if (method === 'PUT') {\n                    const options = {\n                        hostname: 'localhost',\n                        port: 3000,\n                        path: '/put',\n                        method: 'PUT',\n                        headers: {\n                            'Content-Type': 'text/plain',\n                        }\n                    };\n                    const proxyReq = http.request(options, (proxyRes) => {\n                        let proxyBuffer = '';\n                        proxyRes.on('data', (data) => {\n                            proxyBuffer += data;\n                        });\n                        proxyRes.on('end', () => {\n                            res.writeHead(200, { 'Content-Type': 'text/plain' });\n                            res.end(proxyBuffer);\n                        });\n                    });\n                    proxyReq.on('error', (e) => {\n                        sendError(res, 500, 'Internal Server Error');\n                    });\n                    proxyReq.write(data);\n                    proxyReq.end();\n                } else {\n                    sendError(res, 405, 'Method Not Allowed');\n                }\n                break;\n            case '/test':\n                if (method === 'GET') {\n                    const getOptions = {\n                        hostname: 'localhost',\n                        port: 3000,\n                        path: '/get',\n                        method: 'GET'\n                    };\n                    const getReq = http.request(getOptions, (getRes) => {\n                        let getBuffer = '';\n                        getRes.on('data', (data) => {\n                            getBuffer += data;\n                        });\n                        getRes.on('end', () => {\n                            const proxyOptions = {\n                                hostname: 'localhost',\n                                port: 3000,\n                                path: '/proxy',\n                                method: 'PUT',\n                                headers: {\n                                    'Content-Type': 'text/plain',\n                                }\n                            };\n                            const proxyReq = http.request(proxyOptions, (proxyRes) => {\n                                let proxyBuffer = '';\n                                proxyRes.on('data', (data) => {\n                                    proxyBuffer += data;\n                                });\n                                proxyRes.on('end', () => {\n                                    res.writeHead(200, { 'Content-Type': 'text/plain' });\n                                    res.end(proxyBuffer);\n                                });\n                            });\n                            proxyReq.on('error', (e) => {\n                                sendError(res, 500, 'Internal Server Error');\n                            });\n                            proxyReq.write(getBuffer);\n                            proxyReq.end();\n                        });\n                    });\n                    getReq.on('error', (e) => {\n                        sendError(res, 500, 'Internal Server Error');\n                    });\n                    getReq.end();\n                } else {\n                    sendError(res, 405, 'Method Not Allowed');\n                }\n                break;\n            default:\n                sendError(res, 404, 'Not Found');\n        }\n    }\n\n    function sendError(res, statusCode, message) {\n        res.writeHead(statusCode, { 'Content-Type': 'text/plain' });\n        res.end(message);\n    }\n\n    return server;\n}\n```",
      "```javascript\nconst http = require('http');\nconst { StringDecoder } = require('string_decoder');\n\nconst server = http.createServer((req, res) => {\n  const decoder = new StringDecoder('utf-8');\n  let buffer = '';\n\n  req.on('data', (data) => {\n    buffer += decoder.write(data);\n  });\n\n  req.on('end', () => {\n    buffer += decoder.end();\n\n    switch (req.method) {\n      case 'GET':\n        if (req.url === '/get') {\n          res.writeHead(200, { 'Content-Type': 'text/plain' });\n          res.end('content');\n        } else {\n          res.writeHead(404);\n          res.end('Not Found');\n        }\n        break;\n      case 'PUT':\n        if (req.url === '/put') {\n          if (buffer === 'content') {\n            res.writeHead(200, { 'Content-Type': 'text/plain' });\n            res.end('success');\n          } else {\n            res.writeHead(400);\n            res.end('Bad Request');\n          }\n        } else if (req.url === '/proxy') {\n          const options = {\n            hostname: 'localhost',\n            port: 3000,\n            path: '/put',\n            method: 'PUT',\n            headers: {\n              'Content-Type': 'text/plain',\n              'Content-Length': buffer.length\n            }\n          };\n\n          const proxyReq = http.request(options, (proxyRes) => {\n            let proxyBuffer = '';\n\n            proxyRes.on('data', (data) => {\n              proxyBuffer += decoder.write(data);\n            });\n\n            proxyRes.on('end', () => {\n              proxyBuffer += decoder.end();\n              res.writeHead(200, { 'Content-Type': 'text/plain' });\n              res.end(proxyBuffer);\n            });\n          });\n\n          proxyReq.on('error', (e) => {\n            res.writeHead(500);\n            res.end('Internal Server Error');\n          });\n\n          proxyReq.write(buffer);\n          proxyReq.end();\n        } else if (req.url === '/test') {\n          const options = {\n            hostname: 'localhost',\n            port: 3000,\n            path: '/get',\n            method: 'GET'\n          };\n\n          const getReq = http.request(options, (getRes) => {\n            let getBuffer = '';\n\n            getRes.on('data', (data) => {\n              getBuffer += decoder.write(data);\n            });\n\n            getRes.on('end', () => {\n              getBuffer += decoder.end();\n              const proxyOptions = {\n                hostname: 'localhost',\n                port: 3000,\n                path: '/proxy',\n                method: 'PUT',\n                headers: {\n                  'Content-Type': 'text/plain',\n                  'Content-Length': getBuffer.length\n                }\n              };\n\n              const proxyReq = http.request(proxyOptions, (proxyRes) => {\n                let proxyBuffer = '';\n\n                proxyRes.on('data', (data) => {\n                  proxyBuffer += decoder.write(data);\n                });\n\n                proxyRes.on('end', () => {\n                  proxyBuffer += decoder.end();\n                  res.writeHead(200, { 'Content-Type': 'text/plain' });\n                  res.end(proxyBuffer);\n                });\n              });\n\n              proxyReq.on('error', (e) => {\n                res.writeHead(500);\n                res.end('Internal Server Error');\n              });\n\n              proxyReq.write(getBuffer);\n              proxyReq.end();\n            });\n          });\n\n          getReq.on('error', (e) => {\n            res.writeHead(500);\n            res.end('Internal Server Error');\n          });\n\n          getReq.end();\n        } else {\n          res.writeHead(404);\n          res.end('Not Found');\n        }\n        break;\n      default:\n        res.writeHead(405);\n        res.end('Method Not Allowed');\n        break;\n    }\n  });\n});\n\nmodule.exports = server;\n```",
      "```python\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport urllib.parse\nimport subprocess\n\nclass RequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/get':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'content')\n        else:\n            self.send_error(404)\n\n    def do_PUT(self):\n        if self.path == '/put':\n            content_length = int(self.headers['Content-Length'])\n            content = self.rfile.read(content_length)\n            if content == b'content':\n                self.send_response(200)\n                self.send_header('Content-type', 'text/plain')\n                self.end_headers()\n                self.wfile.write(b'success')\n            else:\n                self.send_error(400)\n        elif self.path == '/proxy':\n            self.copy_file(self.rfile, self.wfile)\n        else:\n            self.send_error(404)\n\n    def do_POST(self):\n        if self.path == '/test':\n            self.copy_file(self.rfile, self.wfile)\n            self.copy_file(self.wfile, self.rfile)\n        else:\n            self.send_error(404)\n\n    def copy_file(self, source, target):\n        while True:\n            chunk = source.read(4096)\n            if not chunk:\n                break\n            target.write(chunk)\n\ndef createServer():\n    server_address = ('', 8000)\n    httpd = HTTPServer(server_address, RequestHandler)\n    httpd.serve_forever()\n```",
      "```javascript\nconst http = require('http');\nconst { StringDecoder } = require('string_decoder');\n\nfunction createServer() {\n    const server = http.createServer((req, res) => {\n        const decoder = new StringDecoder('utf-8');\n        let buffer = '';\n        req.on('data', (data) => {\n            buffer += decoder.write(data);\n        });\n        req.on('end', () => {\n            buffer += decoder.end();\n            handleRequest(req, res, buffer);\n        });\n    });\n\n    function handleRequest(req, res, data) {\n        const url = req.url;\n        const method = req.method;\n\n        switch (url) {\n            case '/get':\n                if (method === 'GET') {\n                    res.writeHead(200, { 'Content-Type': 'text/plain' });\n                    res.end('content');\n                } else {\n                    sendErrorResponse(res);\n                }\n                break;\n            case '/put':\n                if (method === 'PUT') {\n                    if (data === 'content') {\n                        res.writeHead(200, { 'Content-Type': 'text/plain' });\n                        res.end('success');\n                    } else {\n                        sendErrorResponse(res);\n                    }\n                } else {\n                    sendErrorResponse(res);\n                }\n                break;\n            case '/proxy':\n                if (method === 'PUT') {\n                    const options = {\n                        hostname: 'localhost',\n                        port: 3000,\n                        path: '/put',\n                        method: 'PUT',\n                        headers: {\n                            'Content-Type': 'text/plain'\n                        }\n                    };\n                    const proxyReq = http.request(options, (proxyRes) => {\n                        let proxyBuffer = '';\n                        proxyRes.on('data', (data) => {\n                            proxyBuffer += decoder.write(data);\n                        });\n                        proxyRes.on('end', () => {\n                            proxyBuffer += decoder.end();\n                            res.writeHead(200, { 'Content-Type': 'text/plain' });\n                            res.end(proxyBuffer);\n                        });\n                    });\n                    proxyReq.on('error', (e) => {\n                        sendErrorResponse(res);\n                    });\n                    proxyReq.write(data);\n                    proxyReq.end();\n                } else {\n                    sendErrorResponse(res);\n                }\n                break;\n            case '/test':\n                if (method === 'GET') {\n                    const getOptions = {\n                        hostname: 'localhost',\n                        port: 3000,\n                        path: '/get',\n                        method: 'GET'\n                    };\n                    const getReq = http.request(getOptions, (getRes) => {\n                        let getBuffer = '';\n                        getRes.on('data', (data) => {\n                            getBuffer += decoder.write(data);\n                        });\n                        getRes.on('end', () => {\n                            getBuffer += decoder.end();\n                            const proxyOptions = {\n                                hostname: 'localhost',\n                                port: 3000,\n                                path: '/proxy',\n                                method: 'PUT',\n                                headers: {\n                                    'Content-Type': 'text/plain'\n                                }\n                            };\n                            const proxyReq = http.request(proxyOptions, (proxyRes) => {\n                                let proxyBuffer = '';\n                                proxyRes.on('data', (data) => {\n                                    proxyBuffer += decoder.write(data);\n                                });\n                                proxyRes.on('end', () => {\n                                    proxyBuffer += decoder.end();\n                                    res.writeHead(200, { 'Content-Type': 'text/plain' });\n                                    res.end(proxyBuffer);\n                                });\n                            });\n                            proxyReq.on('error', (e) => {\n                                sendErrorResponse(res);\n                            });\n                            proxyReq.write(getBuffer);\n                            proxyReq.end();\n                        });\n                    });\n                    getReq.on('error', (e) => {\n                        sendErrorResponse(res);\n                    });\n                    getReq.end();\n                } else {\n                    sendErrorResponse(res);\n                }\n                break;\n            default:\n                sendErrorResponse(res);\n        }\n    }\n\n    function sendErrorResponse(res) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('Error: Not Found');\n    }\n\n    return server;\n}\n```",
      "```python\nimport http.server\nimport socketserver\nimport urllib.parse\nimport subprocess\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/get':\n            self.send_response(200)\n            self.send_header('Content-type', 'text/plain')\n            self.end_headers()\n            self.wfile.write(b'content')\n        else:\n            self.send_error(404, \"Not Found: %s\" % self.path)\n\n    def do_PUT(self):\n        if self.path == '/put':\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length)\n            if post_data == b'content':\n                self.send_response(200)\n                self.send_header('Content-type', 'text/plain')\n                self.end_headers()\n                self.wfile.write(b'success')\n            else:\n                self.send_error(400, \"Bad Request: Data does not match 'content'\")\n        elif self.path == '/proxy':\n            self.copyFile(self.rfile, self.wfile)\n            subprocess.run(['curl', '-X', 'PUT', '-d', '@-', '-H', 'Content-Type: text/plain', 'http://localhost:8000/put'], check=True)\n        elif self.path == '/test':\n            subprocess.run(['curl', '-X', 'GET', 'http://localhost:8000/get'], check=True)\n            subprocess.run(['curl', '-X', 'PUT', '-d', '@-', '-H', 'Content-Type: text/plain', 'http://localhost:8000/proxy'], check=True)\n        else:\n            self.send_error(404, \"Not Found: %s\" % self.path)\n\ndef createServer():\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", 8000), handler) as httpd:\n        print(\"serving at port\", 8000)\n        httpd.serve_forever()\n```"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to stream the contents of a file to the client using Node.js's `fs` and `http` modules. The server should handle file streaming efficiently using pipes and manage errors appropriately.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 5000. When a request is received, it reads a specified file (`big.txt`) as a stream and pipes the data directly to the response object. This approach is memory-efficient for large files. The function handles both successful file streaming and errors during the process.\n\nInput: None (The function does not take any input parameters; the file path is hardcoded as `./content/big.txt`.)\n\nOutput: None (The function does not return any value; it creates an HTTP server that runs indefinitely until stopped externally.)",
    "Canonical_solution": "function createServer() {\n    const http = require('http');\n    const fs = require('fs');\n\n    http.createServer(function (req, res) {\n        const fileStream = fs.createReadStream('./content/big.txt', 'utf8');\n        fileStream.on('open', () => {\n            fileStream.pipe(res);\n        });\n        fileStream.on('error', (err) => {\n            res.end(err);\n        });\n    }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const filePath = path.join(__dirname, 'content', 'big.txt');\n      const fileStream = fs.createReadStream(filePath);\n\n      fileStream.on('open', () => {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        fileStream.pipe(res);\n      });\n\n      fileStream.on('error', (err) => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end(`Error: ${err.message}`);\n      });\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n};\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\n\nconst createServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const fileStream = fs.createReadStream('./content/big.txt');\n      fileStream.pipe(res);\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n};\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\n\nconst createServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const fileStream = fs.createReadStream('./content/big.txt');\n      fileStream.pipe(res);\n      fileStream.on('error', (err) => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error streaming file');\n      });\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n};\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const fileStream = fs.createReadStream('./content/big.txt');\n      fileStream.pipe(res);\n      fileStream.on('error', (err) => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error serving file');\n      });\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n}\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const filePath = path.join(__dirname, 'content', 'big.txt');\n      const fileStream = fs.createReadStream(filePath);\n\n      fileStream.on('open', () => {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        fileStream.pipe(res);\n      });\n\n      fileStream.on('error', (err) => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end(`Error: ${err.message}`);\n      });\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n};\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const filePath = path.join(__dirname, 'content', 'big.txt');\n      const fileStream = fs.createReadStream(filePath);\n\n      fileStream.on('open', () => {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        fileStream.pipe(res);\n      });\n\n      fileStream.on('error', (err) => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end(`Error: ${err.message}`);\n      });\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n};\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const filePath = path.join(__dirname, 'content', 'big.txt');\n      const fileStream = fs.createReadStream(filePath);\n\n      fileStream.on('open', () => {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        fileStream.pipe(res);\n      });\n\n      fileStream.on('error', (err) => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error reading file');\n      });\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server running on port 5000');\n  });\n}\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\n\nconst createServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const fileStream = fs.createReadStream('./content/big.txt');\n      fileStream.pipe(res);\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n};\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const filePath = path.join(__dirname, 'content', 'big.txt');\n      const fileStream = fs.createReadStream(filePath);\n\n      fileStream.on('open', () => {\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        fileStream.pipe(res);\n      });\n\n      fileStream.on('error', (err) => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error reading file');\n      });\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server running on port 5000');\n  });\n};\n\ncreateServer();",
      "const http = require('http');\nconst fs = require('fs');\n\nconst createServer = () => {\n  const server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      const fileStream = fs.createReadStream('./content/big.txt');\n      fileStream.pipe(res);\n      fileStream.on('error', (err) => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error streaming file');\n      });\n    }\n  });\n\n  server.listen(5000, () => {\n    console.log('Server is running on port 5000');\n  });\n};\n\ncreateServer();"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transforming the incoming data to uppercase and sending it back as the response.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for POST requests on a specified port. When a POST request is received, it pipes the request data through a transformation stream that converts the data to uppercase, then pipes the result back to the response. For non-POST requests, it responds with a message prompting a POST request.\n\nInput:  \n- `port` [Number] - The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up a server that runs indefinitely, handling incoming requests.)",
    "Canonical_solution": "const http = require('http');\nconst through = require('through2');\n\nfunction createServer(port) {\n  const server = http.createServer(function (req, res) {\n    if (req.method === 'POST') {\n      req.pipe(through(function (buf, _, next) {\n        this.push(buf.toString().toUpperCase());\n        next();\n      })).pipe(res);\n    } else {\n      res.end('send me a POST\\n');\n    }\n  });\n  server.listen(parseInt(port));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const uppercaseTransform = new Transform({\n    transform(chunk, encoding, callback) {\n      this.push(chunk.toString().toUpperCase());\n      callback();\n    }\n  });\n\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request');\n    }\n  });\n\n  server.listen(port);\n}\n```",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request.');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseStream = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n      req.pipe(uppercaseStream).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request.');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request.');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request');\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request.');\n    }\n  });\n\n  server.listen(port);\n}",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const uppercaseTransform = new Transform({\n    transform(chunk, encoding, callback) {\n      this.push(chunk.toString().toUpperCase());\n      callback();\n    }\n  });\n\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request');\n    }\n  });\n\n  server.listen(port);\n}\n```",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createServer(port) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const uppercaseTransform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString().toUpperCase());\n          callback();\n        }\n      });\n\n      req.pipe(uppercaseTransform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please send a POST request');\n    }\n  });\n\n  server.listen(port);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a function that sets up a simple HTTP server to handle POST requests, piping the incoming request data to a response after converting it to a string.\n\nFunction Description: The function `createPipeServer` initializes an HTTP server that listens for POST requests. When a POST request is received, it pipes the request data through a transformation stream (converting chunks to strings) and then pipes the result back to the response. Non-POST requests are rejected with a message.\n\nInput:  \n- `port` (Number, optional): The port number on which the server will listen. If not provided or 0, the OS will assign an available port.\n\nOutput:  \n- None (The function starts an HTTP server that runs indefinitely, handling incoming requests.)",
    "Canonical_solution": "function createPipeServer(port) {\n  require('http').createServer(function (req, res) {\n    if (req.method !== 'POST') {\n      return res.end('POST only!\\n')\n    }\n    req.pipe(require('through2-map')(function (chunk) {\n      return chunk.toString()\n    })).pipe(res)\n  }).listen(port | 0)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n\n    const transform = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        this.push(chunk.toString());\n        callback();\n      }\n    });\n\n    req.pipe(transform).pipe(res);\n  });\n\n  server.listen(port);\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n    const transform = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        this.push(chunk.toString());\n        callback();\n      }\n    });\n    req.pipe(transform).pipe(res);\n  });\n  server.listen(port);\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const transform = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString());\n          callback();\n        }\n      });\n\n      req.pipe(transform).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n    }\n  });\n\n  server.listen(port);\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n\n    const transform = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        this.push(chunk.toString());\n        callback();\n      }\n    });\n\n    req.pipe(transform).pipe(res);\n  });\n\n  server.listen(port);\n}\n```",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n\n    const transform = new Transform({\n      readableObjectMode: true,\n      writableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        this.push(chunk.toString());\n        callback();\n      }\n    });\n\n    req.pipe(transform).pipe(res);\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n\n    const transform = new Transform({\n      readableObjectMode: true,\n      writableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        this.push(chunk.toString());\n        callback();\n      }\n    });\n\n    req.pipe(transform).pipe(res);\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n      const transformer = new Transform({\n        transform(chunk, encoding, callback) {\n          this.push(chunk.toString());\n          callback();\n        }\n      });\n\n      req.pipe(transformer).pipe(res);\n    } else {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n    }\n  });\n\n  server.listen(port);\n}",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n    const transform = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        this.push(chunk.toString());\n        callback();\n      }\n    });\n    req.pipe(transform).pipe(res);\n  });\n  server.listen(port);\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n    const transform = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        this.push(chunk.toString());\n        callback();\n      }\n    });\n    req.pipe(transform).pipe(res);\n  });\n  server.listen(port);\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Transform } = require('stream');\n\nfunction createPipeServer(port = 0) {\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n    const transform = new Transform({\n      readableObjectMode: true,\n      writableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        this.push(chunk.toString());\n        callback();\n      }\n    });\n    req.pipe(transform).pipe(res);\n  });\n  server.listen(port);\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 147,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to pipe the contents of a specified file to incoming HTTP responses.\n\nFunction Description: The function `createPipeServer` creates an HTTP server that listens on a specified port. When a request is received, it streams the contents of a specified file directly to the response object using the `pipe` method. This is useful for efficiently serving file contents without loading the entire file into memory.\n\nInput:\n- `port` (Number): The port number on which the HTTP server should listen.\n- `filePath` (String): The path to the file whose contents should be piped to the response.\n\nOutput: None. The function creates and starts an HTTP server that runs indefinitely until stopped externally.",
    "Canonical_solution": "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n    const server = http.createServer(function (req, res) {\n        res.writeHead(200, { 'content-type': 'text/plain' });\n        fs.createReadStream(filePath).pipe(res);\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    fs.createReadStream(filePath).pipe(res);\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    fs.createReadStream(filePath).pipe(res);\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    fs.createReadStream(filePath).pipe(res);\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(res);\n  });\n\n  server.listen(port);\n}",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    fs.createReadStream(filePath).pipe(res);\n  });\n\n  server.listen(port);\n}\n```",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    fs.createReadStream(filePath).pipe(res);\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      fs.createReadStream(filePath).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    fs.createReadStream(filePath).pipe(res);\n  });\n\n  server.listen(port);\n}",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    if (req.method === 'GET') {\n      fs.createReadStream(filePath).pipe(res);\n    }\n  });\n\n  server.listen(port);\n}\n```",
      "const http = require('http');\nconst fs = require('fs');\n\nfunction createPipeServer(port, filePath) {\n  const server = http.createServer((req, res) => {\n    fs.createReadStream(filePath).pipe(res);\n  });\n\n  server.listen(port);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Create a JavaScript class that implements an HTTP server capable of serving files from a specified directory, with additional features like directory listing and error handling.\n\nClass Description: The `Server` class represents an HTTP server that serves files from a specified directory path. It handles file requests, directory listings, and various error scenarios. The server can be started and stopped programmatically, and it maintains active connections for proper cleanup.\n\nAttributes:\n\n- config: [Object] - Configuration object containing server settings like port and path\n- _http: [http.Server] - Internal HTTP server instance\n- sockets: [Array] - Array to keep track of active socket connections\n- path: [String] - Base path from which files are served\n\nMethods:\n\n- constructor(config) -> [Server instance] - Initializes the server with given configuration\n- updateServer() -> [void] - Sets up server options and request handling logic\n- start(callback) -> [void] - Starts the HTTP server on the configured port\n- stop(callback) -> [void] - Stops the HTTP server and closes all active connections\n\nThe server handles these special cases:\n1. Automatic directory listing when index.html is not found\n2. Proper redirection for directory requests\n3. Error handling for missing files or directories\n4. Connection management for clean shutdowns\n\nThe implementation uses Node.js core modules (http, fs, path) along with third-party modules (send, marked) for enhanced functionality.",
    "Canonical_solution": "const http = require('http');\nconst send = require('send');\nconst marked = require('marked');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(config) {\n    this.config = config || {};\n    this._http = null;\n    this.sockets = [];\n    this.path = this.config.path || '';\n    \n    this.updateServer();\n  }\n\n  updateServer() {\n    marked.setOptions({\n      gfm: true,\n      tables: true,\n      breaks: false,\n      pedantic: false,\n      sanitize: true,\n      smartLists: true,\n      smartypants: false\n    });\n\n    const html = fs.readFileSync(path.join('lib', 'public', 'directory.html'));\n\n    this._http = http.createServer((req, res) => {\n      function redirect() {\n        res.statusCode = 301;\n        res.setHeader('Location', req.url + '/');\n        res.end('Redirecting to ' + req.url + '/');\n      }\n\n      function procError(err) {\n        if (err.message.indexOf('ENOENT') >= 0) {\n          const p = path.dirname(err.message.match(/'(.*?)'/)[1]) || '';\n          const bn = path.basename(err.message.match(/'(.*?)'/)[1]) || '';\n          \n          if (bn === 'index.html') {\n            fs.readdir(p, (err, files) => {\n              if (err) {\n                res.statusCode = 500;\n                res.end();\n                return;\n              }\n              \n              const dirs = files.filter(el => fs.statSync(path.join(p, el)).isDirectory())\n                .map(el => {\n                  const stat = fs.statSync(path.join(p, el));\n                  return `<tr class='dir'>\n                    <td><a href=\"./${el}/\">${el}</a></td>\n                    <td>&lt;Directory&gt;</td>\n                    <td>&lt;Directory&gt;</td>\n                    <td>${stat.mtime}</td>\n                  </tr>`;\n                });\n                \n              const filesList = files.filter(el => !fs.statSync(path.join(p, el)).isDirectory())\n                .map(el => {\n                  const stat = fs.statSync(path.join(p, el));\n                  const ext = path.extname(el).substr(1);\n                  return `<tr class='file'>\n                    <td><a href=\"./${el}\">${el}</a></td>\n                    <td>${ext.toUpperCase()} File</td>\n                    <td>${(stat.size/1024).toFixed(2)} KB</td>\n                    <td>${stat.mtime}</td>\n                  </tr>`;\n                });\n                \n              res.statusCode = 200;\n              res.end(html.toString().replace('<!-- BODY -->', dirs.join('') + filesList.join('')));\n            });\n            return;\n          }\n        }\n        \n        res.statusCode = err.status || 500;\n        res.end(err.message);\n      }\n\n      try {\n        send(req, require('url').parse(req.url).pathname)\n          .from(this.path)\n          .on('error', procError)\n          .on('directory', redirect)\n          .pipe(res);\n      } catch (e) {\n        procError(e);\n      }\n    });\n\n    this._http.on('connection', (socket) => {\n      this.sockets.push(socket);\n      socket.setTimeout(4000);\n      socket.on('close', () => {\n        this.sockets.splice(this.sockets.indexOf(socket), 1);\n      });\n    });\n  }\n\n  start(callback) {\n    this._http.listen(this.config.port, () => {\n      callback && callback();\n    });\n  }\n\n  stop(callback) {\n    this.sockets.forEach(socket => socket.destroy());\n    this._http.close(() => {\n      callback && callback();\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 100,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(err, req, res);\n        })\n        .pipe(res);\n    };\n\n    const handleDirectory = (req, res) => {\n      const filePath = path.join(this.path, req.url);\n      fs.stat(filePath, (err, stats) => {\n        if (err) {\n          this.handleError(err, req, res);\n        } else if (stats.isDirectory()) {\n          const indexHtmlPath = path.join(filePath, 'index.html');\n          fs.access(indexHtmlPath, (err) => {\n            if (err) {\n              this.handleDirectoryListing(req, res, filePath);\n            } else {\n              res.writeHead(301, { Location: '/' + req.url + '/index.html' });\n              res.end();\n            }\n          });\n        } else {\n          res.writeHead(404);\n          res.end('404 Not Found');\n        }\n      });\n    };\n\n    const handleError = (err, req, res) => {\n      if (err.code === 'ENOENT') {\n        res.writeHead(404);\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(500);\n        res.end('500 Internal Server Error');\n      }\n    };\n\n    const handleDirectoryListing = (req, res, directoryPath) => {\n      fs.readdir(directoryPath, (err, files) => {\n        if (err) {\n          this.handleError(err, req, res);\n        } else {\n          const html = files.map((file) => {\n            const filePath = path.join(directoryPath, file);\n            const stat = fs.statSync(filePath);\n            return stat.isDirectory()\n              ? `<a href=\"${req.url}/${file}/index.html\">${file}/</a>`\n              : `<a href=\"${req.url}/${file}\">${file}</a>`;\n          }).join('\\n');\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(`<html><body><ul>${html}</ul></body></html>`);\n        }\n      });\n    };\n\n    this._http = http.createServer((req, res) => {\n      if (req.method === 'GET') {\n        if (req.url === '/') {\n          res.writeHead(301, { Location: '/index.html' });\n          res.end();\n        } else if (path.basename(req.url) === 'index.html') {\n          handleDirectory(req, res);\n        } else {\n          serve(req, res);\n        }\n      } else {\n        res.writeHead(405);\n        res.end('405 Method Not Allowed');\n      }\n    });\n  }\n\n  start(callback) {\n    this._http.listen(this.config.port, () => {\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      callback();\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(err, req, res);\n        })\n        .pipe(res);\n    };\n\n    const handleDirectoryListing = (req, res) => {\n      const dirPath = path.join(this.path, req.url);\n      fs.readdir(dirPath, (err, files) => {\n        if (err) {\n          this.handleError(err, req, res);\n          return;\n        }\n        const indexHtml = files.find(file => file === 'index.html');\n        if (indexHtml) {\n          serve(req, res);\n        } else {\n          const html = `<html><body><ul>`;\n          files.forEach(file => {\n            html += `<li><a href=\"${req.url}/${file}\">${file}</a></li>`;\n          });\n          html += '</ul></body></html>';\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(html);\n        }\n      });\n    };\n\n    const handleError = (err, req, res) => {\n      if (err.code === 'ENOENT') {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('500 Internal Server Error');\n      }\n    };\n\n    this._http = http.createServer((req, res) => {\n      if (req.method === 'GET') {\n        const url = req.url;\n        if (url.endsWith('/')) {\n          handleDirectoryListing(req, res);\n        } else {\n          serve(req, res);\n        }\n      } else {\n        res.writeHead(405, { 'Content-Type': 'text/plain' });\n        res.end('405 Method Not Allowed');\n      }\n    });\n  }\n\n  start(callback) {\n    this.updateServer();\n    this._http.listen(this.config.port, () => {\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      this.sockets.forEach(socket => socket.end());\n      callback();\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(err, req, res);\n        })\n        .pipe(res);\n    };\n\n    const handleDirectoryListing = (req, res) => {\n      const dirPath = path.join(this.path, req.url);\n      fs.readdir(dirPath, (err, files) => {\n        if (err) {\n          this.handleError(err, req, res);\n          return;\n        }\n        const indexHtml = files.find(file => file === 'index.html');\n        if (indexHtml) {\n          serve(req, res);\n        } else {\n          const html = `<html><body><ul>`;\n          files.forEach(file => {\n            html += `<li><a href=\"${req.url}/${file}\">${file}</a></li>`;\n          });\n          html += '</ul></body></html>';\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(html);\n        }\n      });\n    };\n\n    const handleError = (err, req, res) => {\n      if (err.code === 'ENOENT') {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('500 Internal Server Error');\n      }\n    };\n\n    this._http = http.createServer((req, res) => {\n      if (req.method === 'GET') {\n        if (req.url === '/') {\n          res.writeHead(302, { Location: '/index.html' });\n          res.end();\n        } else if (path.basename(req.url) === '') {\n          handleDirectoryListing(req, res);\n        } else {\n          serve(req, res);\n        }\n      } else {\n        res.writeHead(405, { 'Content-Type': 'text/plain' });\n        res.end('405 Method Not Allowed');\n      }\n    });\n  }\n\n  start(callback) {\n    this.updateServer();\n    this._http.listen(this.config.port, () => {\n      this.sockets.push(this._http);\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      this.sockets = this.sockets.filter(socket => socket !== this._http);\n      callback();\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(err, req, res);\n        })\n        .pipe(res);\n    };\n\n    this._http = http.createServer((req, res) => {\n      if (req.method === 'GET') {\n        const filePath = path.join(this.path, req.url);\n        fs.stat(filePath, (err, stats) => {\n          if (err) {\n            this.handleError(err, req, res);\n          } else if (stats.isDirectory()) {\n            this.handleDirectory(req, res, filePath);\n          } else {\n            serve(req, res);\n          }\n        });\n      } else {\n        res.writeHead(405);\n        res.end('Method Not Allowed');\n      }\n    });\n  }\n\n  start(callback) {\n    this._http.listen(this.config.port, () => {\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      this.sockets.forEach((socket) => {\n        socket.destroy();\n      });\n      callback();\n    });\n  }\n\n  handleDirectory(req, res, filePath) {\n    const indexHtmlPath = path.join(filePath, 'index.html');\n    fs.access(indexHtmlPath, (err) => {\n      if (err) {\n        const dirListing = fs.readdirSync(filePath);\n        const html = `<html><body><ul>`;\n        dirListing.forEach((file) => {\n          html += `<li><a href=\"/${req.url}/${file}\">${file}</a></li>`;\n        });\n        html += '</ul></body></html>';\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(html);\n      } else {\n        res.writeHead(301, { Location: req.url + '/index.html' });\n        res.end();\n      }\n    });\n  }\n\n  handleError(err, req, res) {\n    if (err.code === 'ENOENT') {\n      res.writeHead(404);\n      res.end('File Not Found');\n    } else {\n      res.writeHead(500);\n      res.end('Internal Server Error');\n    }\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const self = this;\n    this._http = http.createServer((req, res) => {\n      const filePath = path.join(self.path, req.url);\n      send(req, filePath)\n        .on('error', (err) => {\n          self.handleError(err, req, res);\n        })\n        .on('directory', () => {\n          self.handleDirectory(req, res, filePath);\n        });\n    });\n  }\n\n  start(callback) {\n    this._http.listen(this.config.port, () => {\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      this.sockets.forEach((socket) => {\n        socket.destroy();\n      });\n      callback();\n    });\n  }\n\n  handleError(err, req, res) {\n    if (err.status === 404) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n    } else {\n      res.writeHead(500, { 'Content-Type': 'text/plain' });\n      res.end('500 Internal Server Error');\n    }\n  }\n\n  handleDirectory(req, res, filePath) {\n    const indexHtmlPath = path.join(filePath, 'index.html');\n    fs.access(indexHtmlPath, (err) => {\n      if (err) {\n        const dirPath = path.join(filePath, 'README.md');\n        fs.access(dirPath, (dirErr) => {\n          if (dirErr) {\n            this.handleError({ status: 404 }, req, res);\n          } else {\n            const markdownContent = fs.readFileSync(dirPath, 'utf8');\n            const htmlContent = marked(markdownContent);\n            res.writeHead(200, { 'Content-Type': 'text/html' });\n            res.end(htmlContent);\n          }\n        });\n      } else {\n        res.writeHead(301, { Location: '/' + path.basename(filePath) });\n        res.end();\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(req, res, err);\n        })\n        .on('directory', (dir) => {\n          this.handleDirectory(req, res, dir);\n        });\n    };\n\n    this._http = http.createServer((req, res) => {\n      serve(req, res);\n    });\n  }\n\n  start(callback) {\n    this._http.listen(this.config.port, () => {\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      this.sockets.forEach((socket) => {\n        socket.destroy();\n      });\n      callback();\n    });\n  }\n\n  handleError(req, res, err) {\n    if (err.status === 404) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n    } else {\n      res.writeHead(500, { 'Content-Type': 'text/plain' });\n      res.end('500 Internal Server Error');\n    }\n  }\n\n  handleDirectory(req, res, dir) {\n    const indexHtmlPath = path.join(dir, 'index.html');\n    fs.access(indexHtmlPath, (err) => {\n      if (err) {\n        const dirPath = path.join(dir, 'README.md');\n        fs.access(dirPath, (err) => {\n          if (err) {\n            this.handleError(req, res, { status: 404 });\n          } else {\n            send(req, dirPath)\n              .on('error', (err) => {\n                this.handleError(req, res, err);\n              })\n              .on('directory', (dir) => {\n                this.handleDirectory(req, res, dir);\n              });\n          }\n        });\n      } else {\n        send(req, indexHtmlPath)\n          .on('error', (err) => {\n            this.handleError(req, res, err);\n          })\n          .on('directory', (dir) => {\n            this.handleDirectory(req, res, dir);\n          });\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(err, req, res);\n        })\n        .pipe(res);\n    };\n\n    const handleDirectoryListing = (req, res) => {\n      const dirPath = path.join(this.path, req.url);\n      fs.readdir(dirPath, (err, files) => {\n        if (err) {\n          this.handleError(err, req, res);\n          return;\n        }\n        const indexHtml = files.find(file => file === 'index.html');\n        if (indexHtml) {\n          serve(req, res);\n        } else {\n          const html = `<html><body><ul>`;\n          files.forEach(file => {\n            html += `<li><a href=\"${req.url}/${file}\">${file}</a></li>`;\n          });\n          html += '</ul></body></html>';\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(html);\n        }\n      });\n    };\n\n    const handleError = (err, req, res) => {\n      if (err.code === 'ENOENT') {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('500 Internal Server Error');\n      }\n    };\n\n    this._http = http.createServer((req, res) => {\n      if (req.method === 'GET') {\n        const url = req.url;\n        if (url.endsWith('/')) {\n          handleDirectoryListing(req, res);\n        } else {\n          serve(req, res);\n        }\n      } else {\n        res.writeHead(405, { 'Content-Type': 'text/plain' });\n        res.end('405 Method Not Allowed');\n      }\n    });\n  }\n\n  start(callback) {\n    this._http.listen(this.config.port, () => {\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      callback();\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(err, req, res);\n        })\n        .pipe(res);\n    };\n\n    const handleDirectoryListing = (req, res) => {\n      const dirPath = path.join(this.path, req.url);\n      fs.readdir(dirPath, (err, files) => {\n        if (err) {\n          this.handleError(err, req, res);\n          return;\n        }\n        const indexHtml = files.find(file => file === 'index.html');\n        if (indexHtml) {\n          serve(req, res);\n        } else {\n          const html = `<html><body><ul>`;\n          files.forEach(file => {\n            html += `<li><a href=\"${req.url}/${file}\">${file}</a></li>`;\n          });\n          html += '</ul></body></html>';\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(html);\n        }\n      });\n    };\n\n    const handleError = (err, req, res) => {\n      if (err.code === 'ENOENT') {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('500 Internal Server Error');\n      }\n    };\n\n    this._http = http.createServer((req, res) => {\n      if (req.method === 'GET') {\n        if (req.url.endsWith('/')) {\n          handleDirectoryListing(req, res);\n        } else {\n          serve(req, res);\n        }\n      } else {\n        res.writeHead(405, { 'Content-Type': 'text/plain' });\n        res.end('405 Method Not Allowed');\n      }\n    });\n  }\n\n  start(callback) {\n    this.updateServer();\n    this._http.listen(this.config.port, () => {\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      this.sockets.forEach(socket => socket.end());\n      callback();\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(err, req, res);\n        })\n        .pipe(res);\n    };\n\n    const handleDirectoryListing = (req, res) => {\n      const dirPath = path.join(this.path, req.url);\n      fs.readdir(dirPath, (err, files) => {\n        if (err) {\n          this.handleError(err, req, res);\n          return;\n        }\n        const indexHtml = files.find(file => file === 'index.html');\n        if (indexHtml) {\n          serve(req, res);\n        } else {\n          const html = `<html><body><ul>`;\n          files.forEach(file => {\n            html += `<li><a href=\"${req.url}/${file}\">${file}</a></li>`;\n          });\n          html += '</ul></body></html>';\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(html);\n        }\n      });\n    };\n\n    const handleError = (err, req, res) => {\n      if (err.code === 'ENOENT') {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('500 Internal Server Error');\n      }\n    };\n\n    this._http = http.createServer((req, res) => {\n      if (req.method === 'GET') {\n        if (req.url === '/') {\n          res.writeHead(302, { Location: '/index.html' });\n          res.end();\n        } else if (path.basename(req.url) === '') {\n          handleDirectoryListing(req, res);\n        } else {\n          serve(req, res);\n        }\n      } else {\n        res.writeHead(405, { 'Content-Type': 'text/plain' });\n        res.end('405 Method Not Allowed');\n      }\n    });\n  }\n\n  start(callback) {\n    this.updateServer();\n    this._http.listen(this.config.port, () => {\n      this.sockets.push(this._http);\n      callback();\n    });\n  }\n\n  stop(callback) {\n    this._http.close(() => {\n      this.sockets = this.sockets.filter(socket => socket !== this._http);\n      callback();\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst send = require('send');\nconst marked = require('marked');\n\nclass Server {\n  constructor(config) {\n    this.config = config;\n    this._http = null;\n    this.sockets = [];\n    this.path = config.path;\n  }\n\n  updateServer() {\n    const serve = (req, res) => {\n      send(req, req.url, { root: this.path, index: 'index.html' })\n        .on('error', (err) => {\n          this.handleError(req, res, err);\n        })\n        .pipe(res);\n    };\n\n    this._http = http.createServer((req, res) => {\n      if (req.method === 'GET') {\n        const filePath = path.join(this.path, req.url);\n        fs.stat(filePath, (err, stats) => {\n          if (err) {\n            this.handleError(req, res, err);\n          } else if (stats.isDirectory()) {\n            this.handleDirectory(req, res, filePath);\n          } else {\n            serve(req, res);\n          }\n        });\n      } else {\n        res.writeHead(405);\n        res.end('Method Not Allowed');\n      }\n    });\n  }\n\n  start(callback) {\n    this._http.listen(this.config.port, callback);\n  }\n\n  stop(callback) {\n    this._http.close(callback);\n  }\n\n  handleDirectory(req, res, filePath) {\n    fs.readdir(filePath, (err, files) => {\n      if (err) {\n        this.handleError(req, res, err);\n      } else {\n        const indexHtml = path.join(filePath, 'index.html');\n        fs.stat(indexHtml, (err, stats) => {\n          if (err) {\n            const html = files.map(file => `<li><a href=\"/${req.url}/${file}\">${file}</a></li>`).join('');\n            res.writeHead(200, { 'Content-Type': 'text/html' });\n            res.end(`<html><body><ul>${html}</ul></body></html>`);\n          } else {\n            res.writeHead(301, { Location: '/' + req.url + '/index.html' });\n            res.end();\n          }\n        });\n      }\n    });\n  }\n\n  handleError(req, res, err) {\n    if (err.code === 'ENOENT') {\n      this.handleDirectory(req, res, this.path);\n    } else {\n      res.writeHead(500);\n      res.end('Internal Server Error');\n    }\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files and handle dynamic JavaScript file concatenation, with support for piping binary files.\n\nFunction Description: The `createServer` function initializes an HTTP server that serves static files from specified directories, handles dynamic concatenation of JavaScript files, and pipes binary files directly to the response. It supports virtual paths, content type detection, and redirection.\n\nInput: \n- Optional command line argument [string] - The port number to listen on (defaults to 90 if not provided)\n\nOutput: \n- None (directly creates and starts an HTTP server)\n- Console output indicating server startup and loaded files\n\nAttributes: (N/A - This is a function, not a class)\n\nMethods: (N/A - This is a function, not a class)\n\nAdditional Implementation Details:\n1. Reads and caches static files from '../src' and '../dist' directories at startup\n2. Handles binary files separately from text files\n3. Supports special handling for core JavaScript files and plugins\n4. Implements virtual path redirection\n5. Uses file extension to determine content type\n6. Provides fallback behavior for undefined routes\n7. Listens on localhost (127.0.0.1) only\n8. Outputs loaded file list to console at startup",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require(\"fs\");\n    var url = require(\"url\");\n\n    var BASE_URL=\"http://www.servicestack.net\", \n        VIRTUAL_PATH=\"/jqbuilder\"; \n\n    var getExt = function(path) {\n        return path.substring(path.lastIndexOf('.')+1);\n    };\n    String.prototype.startsWith = function (str){\n        return this.indexOf(str) === 0;\n    };\n\n    var contentTypes = { \"htm\": \"text/html\", \"js\": \"text/javascript\", \"gif\": \"image/gif\" };\n\n    var srcDir = '../src', targetDir = '../dist';\n    var webFiles = fs.readdirSync(targetDir);\n    var staticFiles = {}, binaryFiles = {};\n    fs.readdirSync(srcDir).forEach(function(file) { \n        var filePath = srcDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(targetDir).forEach(function(file) { \n        var filePath = targetDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(\"./\").forEach(function(file) {\n        var isText = (contentTypes[getExt(file)]||\"\").startsWith(\"text\");\n        if (isText)\n            staticFiles[\"/\" + file] = fs.readFileSync(file).toString('utf-8');\n        else \n            binaryFiles[\"/\" + file] = file;\n    });\n\n    staticFiles[\"/\"] = staticFiles[\"/default.htm\"];\n\n    console.log(\"loaded: \", Object.keys(staticFiles));\n\n    var isCore = { \"/jquip.js\": true, \"/jquip.min.js\": true };\n\n    var port = process.argv[2] || 90;\n\n    http.createServer(function (req, res) {\n        var reqUrl = url.parse(req.url), path = reqUrl.pathname.replace(VIRTUAL_PATH,'');\n        if (reqUrl.pathname == VIRTUAL_PATH){\n            res.writeHead(302,BASE_URL+VIRTUAL_PATH+\"/\");\n            res.end();\n            return;\n        }\n\n        var fileContents = staticFiles[path];\n\n        if (fileContents) {\n            var ext = path == \"/\" ? \"htm\" : getExt(path);\n            var contentType = contentTypes[ext];\n            res.writeHead(200, {'Content-Type': contentType });\n            var isPlugin = ext == \"js\" && path.startsWith(\"/jquip.\") && !isCore[path];\n            if (isPlugin) {\n                var coreJs = path.indexOf(\"min\") != -1 \n                    ? staticFiles[\"/jquip.min.js\"]\n                    : staticFiles[\"/jquip.js\"];\n                fileContents = coreJs + \";\" + fileContents;\n            }\n\n            res.end(fileContents);\n        }\n        else if (binaryFiles[path]) { \n            var filePath = binaryFiles[path]; \n            fs.createReadStream(filePath, {\n              'bufferSize': 4 * 1024\n            }).pipe(res);\n        }\n        else\n        {\n            var isDynamic = path.startsWith(\"/jquip.\");\n            if (isDynamic) {\n                var parts = path.substring(1).split('.');\n                var isMin = parts.indexOf(\"min\") >= 0;\n                var js = isMin ? staticFiles[\"/jquip.min.js\"] : staticFiles[\"/jquip.js\"];\t\t\t\n                parts.forEach(function(part){\n                    if (part == \"jquip\" || part == \"min\" || part == \"js\") return;\n                    var path = \"/jquip.\" + part + (isMin ? \".min.js\" : \".js\");\n                    var jsFile = staticFiles[path];\n                    if (jsFile)\n                        js += \";\" + jsFile;\n                });\n                res.writeHead(200, {'Content-Type': 'text/javascript' });\n                res.end(js);\t\t\n                return;\n            }\n\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            var sb = \"\";\n            for (var i in reqUrl) {\n                if (sb) sb += \"\\n\";\n                sb += i + \": \" + reqUrl[i];\n            }\n            res.end(\"Path not found:\\n\" + sb);\n        }\n    })\n    .listen(port, \"127.0.0.1\");\n    console.log('Server running at http://127.0.0.1:'+port+'/');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { Transform } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst SERVER_HOST = '127.0.0.1';\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, req.url);\n    const virtualPath = filePath.startsWith('../') ? filePath.replace('../', '') : filePath;\n\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n\n      if (stats.isDirectory()) {\n        res.writeHead(301, { Location: `${virtualPath}/index.html` });\n        res.end();\n        return;\n      }\n\n      const contentType = getContentType(filePath);\n      const fileStream = fs.createReadStream(filePath);\n\n      if (contentType.startsWith('text/')) {\n        fileStream.pipe(res, { end: false });\n        fileStream.on('end', () => {\n          res.end();\n        });\n      } else {\n        res.writeHead(200, { 'Content-Type': contentType });\n        fileStream.pipe(res);\n      }\n    });\n  });\n\n  server.listen(port, SERVER_HOST, () => {\n    console.log(`Server started on http://${SERVER_HOST}:${port}`);\n    console.log('Loaded files:');\n    console.log('src/index.html');\n    console.log('dist/main.js');\n    console.log('dist/plugins/plugin1.js');\n    console.log('dist/plugins/plugin2.js');\n  });\n\n  return server;\n}\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  const contentTypeMap = {\n    '.html': 'text/html',\n    '.js': 'application/javascript',\n    '.css': 'text/css',\n    '.json': 'application/json',\n    '.png': 'image/png',\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.gif': 'image/gif',\n    '.svg': 'image/svg+xml',\n    '.pdf': 'application/pdf',\n    '.txt': 'text/plain',\n    '.wav': 'audio/wav',\n    '.mp3': 'audio/mpeg',\n    '.mp4': 'video/mp4',\n  };\n  return contentTypeMap[ext] || 'application/octet-stream';\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { Transform } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst STATIC_DIRS = ['../src', '../dist'];\nconst JS_EXTENSIONS = ['.js'];\nconst BINARY_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.pdf', '.ico', '.webp', '.zip', '.tar', '.gz', '.7z', '.bin', '.exe', '.dll', '.dmg'];\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const url = req.url;\n    const filePath = url.startsWith('/') ? url.substring(1) : url;\n\n    if (filePath === 'concat.js') {\n      const files = req.headers.files ? req.headers.files.split(',') : [];\n      const transform = new ConcatenationTransform(files);\n      req.pipe(transform).pipe(res);\n      return;\n    }\n\n    const fullPath = path.join(__dirname, filePath);\n    const stat = fs.statSync(fullPath);\n\n    if (stat.isDirectory()) {\n      res.writeHead(301, { Location: `${filePath}/` });\n      res.end();\n      return;\n    }\n\n    if (JS_EXTENSIONS.includes(path.extname(filePath))) {\n      const content = fs.readFileSync(fullPath, 'utf8');\n      const concatenatedContent = files.map(file => fs.readFileSync(file, 'utf8')).join('\\n');\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end(concatenatedContent);\n      return;\n    }\n\n    if (BINARY_EXTENSIONS.includes(path.extname(filePath))) {\n      const fileStream = fs.createReadStream(fullPath);\n      fileStream.pipe(res);\n      return;\n    }\n\n    const contentType = getContentType(filePath);\n    const content = fs.readFileSync(fullPath);\n    res.writeHead(200, { 'Content-Type': contentType });\n    res.end(content);\n  });\n\n  server.listen(port, '127.0.0.1', () => {\n    console.log(`Server running at http://127.0.0.1:${port}/`);\n    console.log('Loaded files:');\n    STATIC_DIRS.forEach(dir => {\n      fs.readdirSync(dir).forEach(file => {\n        console.log(`${dir}/${file}`);\n      });\n    });\n  });\n}\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  switch (ext) {\n    case '.html':\n      return 'text/html';\n    case '.css':\n      return 'text/css';\n    case '.json':\n      return 'application/json';\n    case '.xml':\n      return 'application/xml';\n    case '.txt':\n      return 'text/plain';\n    default:\n      return 'application/octet-stream';\n  }\n}\n\nclass ConcatenationTransform extends Transform {\n  constructor(files) {\n    super({ readableObjectMode: true });\n    this.files = files;\n    this.currentFileIndex = 0;\n    this.concatenatedContent = '';\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (this.currentFileIndex < this.files.length) {\n      const file = this.files[this.currentFileIndex];\n      const content = fs.readFileSync(file, 'utf8');\n      this.concatenatedContent += content;\n      this.currentFileIndex++;\n    }\n    callback();\n  }\n\n  _flush(callback) {\n    this.push(this.concatenatedContent);\n    callback();\n  }\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { Transform } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst STATIC_DIRS = ['../src', '../dist'];\nconst JS_EXTENSIONS = ['.js'];\nconst BINARY_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.pdf', '.ico', '.webp', '.zip', '.tar', '.gz', '.7z', '.bin', '.exe', '.dll', '.dmg'];\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const url = req.url;\n    const filePath = url.startsWith('/') ? url.substring(1) : url;\n    const fullPath = path.join(__dirname, filePath);\n\n    if (filePath.startsWith('virtual/')) {\n      const redirectPath = filePath.substring(8);\n      res.writeHead(301, { Location: redirectPath });\n      res.end();\n      return;\n    }\n\n    if (STATIC_DIRS.some(dir => fullPath.startsWith(dir))) {\n      const fileExtension = path.extname(filePath);\n      const contentType = getContentType(fileExtension);\n\n      fs.readFile(fullPath, (err, data) => {\n        if (err) {\n          res.writeHead(404);\n          res.end('File not found');\n          return;\n        }\n\n        if (JS_EXTENSIONS.includes(fileExtension)) {\n          concatenateJSFiles(filePath, data, res, contentType);\n        } else if (BINARY_EXTENSIONS.includes(fileExtension)) {\n          res.writeHead(200, { 'Content-Type': contentType });\n          res.end(data);\n        } else {\n          res.writeHead(200, { 'Content-Type': contentType });\n          res.end(data.toString());\n        }\n      });\n    } else {\n      res.writeHead(404);\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running at http://127.0.0.1:${port}/`);\n    console.log('Loaded files:');\n    STATIC_DIRS.forEach(dir => {\n      fs.readdir(dir, (err, files) => {\n        if (err) {\n          console.error(`Error reading directory ${dir}: ${err}`);\n          return;\n        }\n        console.log(files.join(', '));\n      });\n    });\n  });\n}\n\nfunction getContentType(fileExtension) {\n  switch (fileExtension) {\n    case '.html': return 'text/html';\n    case '.css': return 'text/css';\n    case '.js': return 'application/javascript';\n    case '.json': return 'application/json';\n    case '.png': return 'image/png';\n    case '.jpg': return 'image/jpeg';\n    case '.jpeg': return 'image/jpeg';\n    case '.gif': return 'image/gif';\n    case '.svg': return 'image/svg+xml';\n    case '.pdf': return 'application/pdf';\n    case '.ico': return 'image/x-icon';\n    case '.webp': return 'image/webp';\n    case '.zip': return 'application/zip';\n    case '.tar': return 'application/x-tar';\n    case '.gz': return 'application/gzip';\n    case '.7z': return 'application/x-7z-compressed';\n    case '.bin': return 'application/octet-stream';\n    case '.exe': return 'application/octet-stream';\n    case '.dll': return 'application/octet-stream';\n    case '.dmg': return 'application/octet-stream';\n    default: return 'text/plain';\n  }\n}\n\nfunction concatenateJSFiles(filePath, data, res, contentType) {\n  const filesToConcatenate = getJSFilesToConcatenate(filePath);\n  const transform = new ConcatenatingTransform();\n\n  filesToConcatenate.forEach(file => {\n    fs.createReadStream(file).pipe(transform);\n  });\n\n  transform.on('finish', () => {\n    res.writeHead(200, { 'Content-Type': contentType });\n    res.end(transform.getBuffer());\n  });\n}\n\nfunction getJSFilesToConcatenate(filePath) {\n  const coreFiles = ['core.js', 'plugins.js'];\n  const pluginFiles = filePath.split('/').slice(2).map(part => `${part}.js`);\n  return [...coreFiles, ...pluginFiles];\n}\n\nclass ConcatenatingTransform extends Transform {\n  constructor(options) {\n    super(options);\n    this.buffer = '';\n  }\n\n  _transform(chunk, encoding, callback) {\n    this.buffer += chunk.toString();\n    callback();\n  }\n\n  _flush(callback) {\n    this.push(this.buffer);\n    callback();\n  }\n\n  getBuffer() {\n    return this.buffer;\n  }\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { Transform } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst SERVER_HOST = '127.0.0.1';\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, '../src', req.url || '../dist/index.html');\n    const virtualPath = filePath.startsWith('../src') ? filePath : filePath.replace('../dist/', '');\n    const fileExtension = path.extname(filePath).toLowerCase();\n\n    if (fileExtension === '.js') {\n      const files = virtualPath.split('/').slice(2);\n      const content = files.map(file => fs.readFileSync(path.join(__dirname, '../src', file), 'utf8')).join('\\n');\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end(content);\n    } else if (fileExtension === '.bin') {\n      const fileStream = fs.createReadStream(filePath);\n      fileStream.pipe(res);\n    } else {\n      fs.readFile(filePath, (err, data) => {\n        if (err) {\n          res.writeHead(404);\n          res.end('File not found');\n        } else {\n          res.writeHead(200, { 'Content-Type': getContentType(fileExtension) });\n          res.end(data);\n        }\n      });\n    }\n  });\n\n  server.listen(port, SERVER_HOST, () => {\n    console.log(`Server started on http://${SERVER_HOST}:${port}`);\n    console.log('Loaded files:');\n    console.log('src/index.html');\n    console.log('src/core.js');\n    console.log('src/plugin.js');\n    console.log('dist/index.html');\n  });\n\n  function getContentType(extension) {\n    const contentTypeMap = {\n      '.html': 'text/html',\n      '.css': 'text/css',\n      '.js': 'application/javascript',\n      '.json': 'application/json',\n      '.png': 'image/png',\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.gif': 'image/gif',\n      '.svg': 'image/svg+xml',\n      '.pdf': 'application/pdf',\n      '.txt': 'text/plain',\n      '.bin': 'application/octet-stream'\n    };\n    return contentTypeMap[extension] || 'application/octet-stream';\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { pipeline } = require('stream');\nconst { StringDecoder } = require('string_decoder');\n\nconst DEFAULT_PORT = 90;\n\nfunction createServer(port = DEFAULT_PORT) {\n  const staticFiles = new Map();\n  const binaryFiles = new Map();\n  const virtualPaths = new Map();\n\n  const server = http.createServer((req, res) => {\n    const url = req.url;\n    const filePath = url.startsWith('/') ? url.substring(1) : url;\n\n    if (virtualPaths.has(filePath)) {\n      filePath = virtualPaths.get(filePath);\n    }\n\n    if (staticFiles.has(filePath)) {\n      serveStaticFile(res, filePath);\n    } else if (binaryFiles.has(filePath)) {\n      serveBinaryFile(res, filePath);\n    } else {\n      handleDynamicConcatenation(req, res, filePath);\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running at http://localhost:${port}/`);\n    loadStaticFiles();\n  });\n\n  function loadStaticFiles() {\n    const directories = ['../src', '../dist'];\n    directories.forEach(dir => {\n      fs.readdir(dir, (err, files) => {\n        if (err) throw err;\n        files.forEach(file => {\n          const fullPath = path.join(dir, file);\n          fs.stat(fullPath, (err, stats) => {\n            if (err) throw err;\n            if (stats.isFile()) {\n              const ext = path.extname(file).toLowerCase();\n              if (ext === '.js') {\n                staticFiles.set(file, fs.readFileSync(fullPath));\n              } else if (ext === '.bin') {\n                binaryFiles.set(file, fs.readFileSync(fullPath));\n              }\n            }\n          });\n        });\n      });\n    });\n  }\n\n  function serveStaticFile(res, filePath) {\n    const content = staticFiles.get(filePath);\n    const ext = path.extname(filePath).toLowerCase();\n    const contentType = getContentType(ext);\n    res.setHeader('Content-Type', contentType);\n    res.end(content);\n  }\n\n  function serveBinaryFile(res, filePath) {\n    const content = binaryFiles.get(filePath);\n    res.setHeader('Content-Type', 'application/octet-stream');\n    pipeline(content, res, (err) => {\n      if (err) {\n        console.error('Pipeline failed', err);\n      }\n    });\n  }\n\n  function handleDynamicConcatenation(req, res, filePath) {\n    const coreFiles = ['core.js', 'plugin.js'];\n    const content = coreFiles.map(file => staticFiles.get(file) || '').join('');\n    const contentType = 'application/javascript';\n    res.setHeader('Content-Type', contentType);\n    res.end(content);\n  }\n\n  function getContentType(ext) {\n    const contentTypeMap = {\n      '.html': 'text/html',\n      '.css': 'text/css',\n      '.js': 'application/javascript',\n      '.json': 'application/json',\n      '.png': 'image/png',\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.gif': 'image/gif',\n      '.svg': 'image/svg+xml',\n      '.pdf': 'application/pdf',\n      '.txt': 'text/plain',\n      '.bin': 'application/octet-stream'\n    };\n    return contentTypeMap[ext] || 'application/octet-stream';\n  }\n\n  return server;\n}\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { Transform } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst STATIC_DIRS = ['../src', '../dist'];\nconst JS_EXTENSIONS = ['.js'];\nconst BINARY_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.pdf', '.ico', '.webp', '.zip', '.tar', '.gz', '.7z'];\nconst CORE_JS_FILES = ['core.js', 'plugin.js'];\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const url = req.url;\n    const filePath = url.startsWith('/') ? url.substring(1) : url;\n\n    if (filePath === 'concatenate.js') {\n      concatenateJSFiles(req, res);\n      return;\n    }\n\n    const fullPath = path.join(__dirname, filePath);\n    const stat = fs.statSync(fullPath);\n\n    if (stat.isDirectory()) {\n      res.writeHead(301, { Location: `${filePath}/` });\n      res.end();\n      return;\n    }\n\n    if (isBinaryFile(filePath)) {\n      serveBinaryFile(fullPath, req, res);\n      return;\n    }\n\n    serveStaticFile(fullPath, req, res);\n  });\n\n  server.listen(port, '127.0.0.1', () => {\n    console.log(`Server running at http://127.0.0.1:${port}/`);\n    loadStaticFiles();\n  });\n}\n\nfunction loadStaticFiles() {\n  console.log('Loading static files...');\n  STATIC_DIRS.forEach(dir => {\n    fs.readdirSync(dir).forEach(file => {\n      const fullPath = path.join(dir, file);\n      const stat = fs.statSync(fullPath);\n      if (stat.isFile()) {\n        console.log(`Loaded static file: ${file}`);\n      }\n    });\n  });\n}\n\nfunction isBinaryFile(filePath) {\n  return BINARY_EXTENSIONS.includes(path.extname(filePath).toLowerCase());\n}\n\nfunction serveBinaryFile(filePath, req, res) {\n  const fileStream = fs.createReadStream(filePath);\n  fileStream.pipe(res);\n}\n\nfunction serveStaticFile(filePath, req, res) {\n  const fileStream = fs.createReadStream(filePath);\n  const contentType = getContentType(filePath);\n  res.writeHead(200, { 'Content-Type': contentType });\n  fileStream.pipe(res);\n}\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  if (JS_EXTENSIONS.includes(ext)) {\n    return 'application/javascript';\n  }\n  if (BINARY_EXTENSIONS.includes(ext)) {\n    return getBinaryContentType(ext);\n  }\n  return 'text/plain';\n}\n\nfunction getBinaryContentType(ext) {\n  const contentTypeMap = {\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.png': 'image/png',\n    '.gif': 'image/gif',\n    '.svg': 'image/svg+xml',\n    '.pdf': 'application/pdf',\n    '.ico': 'image/x-icon',\n    '.webp': 'image/webp',\n    '.zip': 'application/zip',\n    '.tar': 'application/x-tar',\n    '.gz': 'application/gzip',\n    '.7z': 'application/x-7z-compressed'\n  };\n  return contentTypeMap[ext] || 'application/octet-stream';\n}\n\nfunction concatenateJSFiles(req, res) {\n  const files = CORE_JS_FILES.map(file => path.join(__dirname, 'js', file));\n  const fileStream = files.reduce((acc, file) => {\n    const readStream = fs.createReadStream(file);\n    if (acc) {\n      readStream.pipe(acc, { end: false });\n    }\n    return readStream;\n  }, null);\n\n  fileStream.on('end', () => {\n    res.writeHead(200, { 'Content-Type': 'application/javascript' });\n    fileStream.pipe(res);\n  });\n}\n\ncreateServer();\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { Transform } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst STATIC_DIRS = ['../src', '../dist'];\nconst JS_EXTENSIONS = ['.js'];\nconst BINARY_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.pdf', '.ico', '.webp', '.zip', '.tar', '.tar.gz', '.tar.bz2', '.tar.xz', '.exe', '.dll', '.dmg', '.msi'];\nconst CORE_JS_FILES = ['core.js', 'plugin.js'];\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const url = req.url;\n    const filePath = path.join(__dirname, url);\n\n    if (url.startsWith('/concatenate/')) {\n      const files = url.split('/').slice(2);\n      concatenateFiles(files, res);\n      return;\n    }\n\n    if (url.startsWith('/redirect/')) {\n      const target = url.split('/').slice(2).join('/');\n      res.writeHead(301, { Location: target });\n      res.end();\n      return;\n    }\n\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        res.writeHead(404);\n        res.end('File not found');\n        return;\n      }\n\n      if (stats.isDirectory()) {\n        res.writeHead(403);\n        res.end('Directory access is forbidden');\n        return;\n      }\n\n      const ext = path.extname(filePath);\n      const contentType = getContentType(ext);\n\n      if (BINARY_EXTENSIONS.includes(ext)) {\n        serveBinaryFile(filePath, contentType, res);\n      } else {\n        serveTextFile(filePath, contentType, res);\n      }\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server started on port ${port}`);\n    console.log('Loaded files:');\n    STATIC_DIRS.forEach(dir => {\n      fs.readdir(dir, (err, files) => {\n        if (err) {\n          console.error(`Error reading directory ${dir}: ${err}`);\n          return;\n        }\n        files.forEach(file => {\n          console.log(`${dir}/${file}`);\n        });\n      });\n    });\n  });\n}\n\nfunction concatenateFiles(files, res) {\n  const transform = new Transform({\n    transform(chunk, encoding, callback) {\n      this.push(chunk);\n      callback();\n    }\n  });\n\n  let first = true;\n  files.forEach(file => {\n    const filePath = path.join(__dirname, file);\n    const readStream = fs.createReadStream(filePath);\n    if (first) {\n      readStream.pipe(res);\n      first = false;\n    } else {\n      readStream.pipe(transform);\n      transform.pipe(res);\n    }\n  });\n\n  if (files.length === 0) {\n    res.end();\n  }\n}\n\nfunction serveBinaryFile(filePath, contentType, res) {\n  const fileStream = fs.createReadStream(filePath);\n  fileStream.pipe(res);\n  res.writeHead(200, { 'Content-Type': contentType });\n}\n\nfunction serveTextFile(filePath, contentType, res) {\n  const fileStream = fs.createReadStream(filePath);\n  fileStream.pipe(res);\n  res.writeHead(200, { 'Content-Type': contentType });\n}\n\nfunction getContentType(ext) {\n  switch (ext) {\n    case '.html':\n      return 'text/html';\n    case '.css':\n      return 'text/css';\n    case '.js':\n      return 'application/javascript';\n    case '.json':\n      return 'application/json';\n    case '.txt':\n      return 'text/plain';\n    case '.xml':\n      return 'application/xml';\n    case '.pdf':\n      return 'application/pdf';\n    case '.jpg':\n    case '.jpeg':\n    case '.png':\n    case '.gif':\n    case '.svg':\n    case '.ico':\n    case '.webp':\n      return 'image/' + ext.slice(1);\n    case '.zip':\n    case '.tar':\n    case '.tar.gz':\n    case '.tar.bz2':\n    case '.tar.xz':\n      return 'application/x-compressed';\n    case '.exe':\n    case '.dll':\n    case '.dmg':\n    case '.msi':\n      return 'application/octet-stream';\n    default:\n      return 'text/plain';\n  }\n}\n\nmodule.exports = createServer;\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { Transform } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst STATIC_DIRS = ['../src', '../dist'];\nconst JS_EXTENSIONS = ['.js'];\nconst BINARY_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.pdf', '.ico', '.webp', '.zip', '.tar', '.gz', '.7z', '.bin', '.exe', '.dll'];\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const url = req.url;\n    const filePath = path.join(__dirname, url);\n\n    if (url.startsWith('/concatenate/')) {\n      const files = url.split('/').slice(2);\n      concatenateFiles(files, res);\n    } else {\n      serveFile(filePath, req, res);\n    }\n  });\n\n  server.listen(port, '127.0.0.1', () => {\n    console.log(`Server running at http://127.0.0.1:${port}/`);\n    loadStaticFiles();\n  });\n\n  return server;\n}\n\nfunction loadStaticFiles() {\n  console.log('Loading static files...');\n  STATIC_DIRS.forEach(dir => {\n    fs.readdirSync(dir).forEach(file => {\n      const filePath = path.join(dir, file);\n      console.log(`Loaded static file: ${filePath}`);\n    });\n  });\n}\n\nfunction serveFile(filePath, req, res) {\n  if (!fs.existsSync(filePath)) {\n    res.writeHead(404, { 'Content-Type': 'text/plain' });\n    res.end('404 Not Found');\n    return;\n  }\n\n  const stats = fs.statSync(filePath);\n  if (stats.isDirectory()) {\n    res.writeHead(302, { 'Location': `${filePath}/` });\n    res.end();\n    return;\n  }\n\n  const contentType = getContentType(filePath);\n  res.writeHead(200, { 'Content-Type': contentType });\n  const fileStream = fs.createReadStream(filePath);\n  fileStream.pipe(res);\n}\n\nfunction concatenateFiles(files, res) {\n  const transform = new Transform({\n    transform(chunk, encoding, callback) {\n      this.push(chunk);\n      callback();\n    },\n    flush(callback) {\n      const concatenated = Buffer.concat(this._chunks).toString();\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end(concatenated);\n      callback();\n    }\n  });\n\n  transform._chunks = [];\n\n  files.forEach(file => {\n    const filePath = path.join(__dirname, file);\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.on('data', chunk => {\n      transform.push(chunk);\n    });\n    fileStream.on('end', () => {\n      transform.push(null);\n    });\n  });\n}\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  if (JS_EXTENSIONS.includes(ext)) {\n    return 'application/javascript';\n  } else if (BINARY_EXTENSIONS.includes(ext)) {\n    return 'application/octet-stream';\n  } else {\n    const mime = require('mime-types');\n    return mime.lookup(filePath) || 'text/plain';\n  }\n}\n\nmodule.exports = createServer;\n```",
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { pipeline } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst SERVER_HOST = '127.0.0.1';\n\nconst staticFiles = new Map();\nconst binaryExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.ico', '.webp', '.pdf', '.mp4', '.mp3', '.wav', '.avi', '.mov', '.flv', '.swf', '.zip', '.tar', '.gz', '.7z', '.bin', '.exe', '.dll', '.dmg', '.iso', '.jar', '.war', '.ear', '.sar', '.apk', '.msi', '.bat', '.sh', '.cmd', '.class', '.jar', '.war', '.ear', '.sar', '.apk', '.msi', '.bat', '.sh', '.cmd'];\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const url = req.url;\n    const filePath = path.join(__dirname, url);\n\n    if (url.startsWith('/static/')) {\n      const staticPath = url.substring(8);\n      const file = staticFiles.get(staticPath);\n      if (file) {\n        res.writeHead(200, { 'Content-Type': file.type });\n        pipeline(file.stream, res, (err) => {\n          if (err) {\n            console.error('Pipeline failed', err);\n          } else {\n            console.log(`Served static file: ${staticPath}`);\n          }\n        });\n        return;\n      }\n    }\n\n    if (url.startsWith('/concat/')) {\n      const concatPath = url.substring(8);\n      const files = concatPath.split(',');\n      const concatenatedStream = fs.createWriteStream(path.join(__dirname, 'concat.js'));\n      files.forEach((file) => {\n        const filePath = path.join(__dirname, file);\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(concatenatedStream, { end: false });\n      });\n      concatenatedStream.end();\n      concatenatedStream.on('finish', () => {\n        res.writeHead(200, { 'Content-Type': 'application/javascript' });\n        concatenatedStream.pipe(res);\n        console.log(`Concatenated files: ${files.join(', ')}`);\n      });\n      return;\n    }\n\n    if (url.startsWith('/binary/')) {\n      const binaryPath = url.substring(8);\n      const fileStream = fs.createReadStream(path.join(__dirname, binaryPath));\n      res.writeHead(200, { 'Content-Type': 'application/octet-stream' });\n      pipeline(fileStream, res, (err) => {\n        if (err) {\n          console.error('Pipeline failed', err);\n        } else {\n          console.log(`Served binary file: ${binaryPath}`);\n        }\n      });\n      return;\n    }\n\n    if (url.startsWith('/redirect/')) {\n      const redirectPath = url.substring(10);\n      res.writeHead(301, { Location: redirectPath });\n      res.end();\n      return;\n    }\n\n    const contentType = getContentType(filePath);\n    if (contentType) {\n      fs.readFile(filePath, (err, data) => {\n        if (err) {\n          res.writeHead(404);\n          res.end('File not found');\n        } else {\n          res.writeHead(200, { 'Content-Type': contentType });\n          res.end(data);\n        }\n      });\n    } else {\n      res.writeHead(404);\n      res.end('File not found');\n    }\n  });\n\n  server.listen(port, SERVER_HOST, () => {\n    console.log(`Server listening on http://${SERVER_HOST}:${port}`);\n    loadStaticFiles();\n  });\n\n  function loadStaticFiles() {\n    const srcDir = path.join(__dirname, '../src');\n    const distDir = path.join(__dirname, '../dist');\n    fs.readdir(srcDir, (err, files) => {\n      if (err) {\n        console.error('Error reading src directory', err);\n        return;\n      }\n      files.forEach((file) => {\n        const filePath = path.join(srcDir, file);\n        const contentType = getContentType(filePath);\n        const stream = fs.createReadStream(filePath);\n        staticFiles.set(file, { path: filePath, type: contentType, stream });\n        console.log(`Loaded static file: ${file}`);\n      });\n      fs.readdir(distDir, (err, files) => {\n        if (err) {\n          console.error('Error reading dist directory', err);\n          return;\n        }\n        files.forEach((file) => {\n          const filePath = path.join(distDir, file);\n          const contentType = getContentType(filePath);\n          const stream = fs.createReadStream(filePath);\n          staticFiles.set(file, { path: filePath, type: contentType, stream });\n          console.log(`Loaded static file: ${file}`);\n        });\n      });\n    });\n  }\n\n  function getContentType(filePath) {\n    const ext = path.extname(filePath).toLowerCase();\n    if (binaryExtensions.includes(ext)) {\n      return 'application/octet-stream';\n    }\n    switch (ext) {\n      case '.html':\n        return 'text/html';\n      case '.css':\n        return 'text/css';\n      case '.js':\n        return 'application/javascript';\n      case '.json':\n        return 'application/json';\n      case '.txt':\n        return 'text/plain';\n      case '.xml':\n        return 'application/xml';\n      case '.pdf':\n        return 'application/pdf';\n      case '.png':\n        return 'image/png';\n      case '.jpg':\n        return 'image/jpeg';\n      case '.jpeg':\n        return 'image/jpeg';\n      case '.gif':\n        return 'image/gif';\n      case '.svg':\n        return 'image/svg+xml';\n      default:\n        return null;\n    }\n  }\n}\n\ncreateServer(process.argv[2] ? parseInt(process.argv[2], 10) : DEFAULT_PORT);\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { Transform } = require('stream');\n\nconst DEFAULT_PORT = 90;\nconst STATIC_DIRS = ['../src', '../dist'];\nconst JS_EXTENSIONS = ['.js'];\nconst BINARY_EXTENSIONS = ['.jpg', '.png', '.gif', '.jpeg', '.svg', '.pdf', '.ico', '.webp'];\nconst CORE_JS_FILES = ['core.js', 'plugin.js'];\n\nfunction createServer(port = DEFAULT_PORT) {\n  const server = http.createServer((req, res) => {\n    const url = req.url;\n    const filePath = url.startsWith('/') ? url.substring(1) : url;\n\n    if (filePath === 'list') {\n      console.log('Loaded files:');\n      console.log(loadedFiles);\n      return;\n    }\n\n    const fullPath = path.join(__dirname, filePath);\n    const stats = fs.statSync(fullPath);\n\n    if (stats.isDirectory()) {\n      res.writeHead(302, { Location: `${filePath}/index.html` });\n      res.end();\n      return;\n    }\n\n    if (JS_EXTENSIONS.includes(path.extname(filePath))) {\n      handleJavaScriptFile(filePath, req, res);\n    } else if (BINARY_EXTENSIONS.includes(path.extname(filePath))) {\n      handleBinaryFile(filePath, req, res);\n    } else {\n      handleStaticFile(filePath, req, res);\n    }\n  });\n\n  server.listen(port, '127.0.0.1', () => {\n    console.log(`Server running at http://127.0.0.1:${port}/`);\n    loadStaticFiles();\n  });\n}\n\nfunction loadStaticFiles() {\n  loadedFiles = {};\n  STATIC_DIRS.forEach(dir => {\n    fs.readdirSync(dir).forEach(file => {\n      const filePath = path.join(dir, file);\n      loadedFiles[file] = fs.readFileSync(filePath);\n    });\n  });\n  console.log('Static files loaded.');\n}\n\nfunction handleJavaScriptFile(filePath, req, res) {\n  const content = loadedFiles[filePath];\n  if (CORE_JS_FILES.includes(filePath)) {\n    content = `// Core file: ${filePath}\\n${content}`;\n  }\n  res.writeHead(200, { 'Content-Type': 'application/javascript' });\n  res.end(content);\n}\n\nfunction handleBinaryFile(filePath, req, res) {\n  const content = loadedFiles[filePath];\n  res.writeHead(200, { 'Content-Type': getContentType(filePath) });\n  res.end(content);\n}\n\nfunction handleStaticFile(filePath, req, res) {\n  const content = loadedFiles[filePath];\n  res.writeHead(200, { 'Content-Type': getContentType(filePath) });\n  res.end(content);\n}\n\nfunction getContentType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  switch (ext) {\n    case '.html':\n      return 'text/html';\n    case '.css':\n      return 'text/css';\n    case '.js':\n      return 'application/javascript';\n    case '.json':\n      return 'application/json';\n    case '.txt':\n      return 'text/plain';\n    case '.xml':\n      return 'application/xml';\n    default:\n      return 'application/octet-stream';\n  }\n}\n\nlet loadedFiles = {};\n\ncreateServer();\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement an OAuth server class that handles GitHub OAuth authentication flow, including starting a server to receive the authorization code and exchanging it for an access token.\n\nClass Description: The OAuthServer class represents a server that facilitates GitHub OAuth authentication. It creates an Express server to handle the OAuth callback, exchanges the authorization code for an access token using GitHub's API, and provides methods to start and stop the server.\n\nAttributes:\n- options: [Object] - Configuration object containing client credentials and server settings\n- prompt: [Object] - Reference to an external prompt object used to signal completion of authentication\n- app: [Object] - Express application instance for handling HTTP requests\n- server: [Object] - HTTP server instance created by Express\n- token: [String|null] - Stores the obtained OAuth access token\n\nMethods:\n- constructor(options) -> [OAuthServer] - Initializes the OAuth server with configuration options and sets up the Express route for handling OAuth callbacks\n- start() -> [Promise] - Starts the HTTP server on the configured port and returns a promise that resolves when the server is ready or rejects on error\n- stop() -> [void] - Stops the HTTP server and cleans up resources",
    "Canonical_solution": "const express = require('express');\nconst axios = require('axios');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = this.options.prompt;\n    this.app = express();\n    this.app.get('/', (req, res) => {\n      const code = req.query.code;\n      axios\n        .post(\n          `https://github.com/login/oauth/access_token?client_secret=${\n            this.options.client_secret\n          }&client_id=${this.options.client_id}&code=${code}`,\n          {},\n          {\n            headers: {\n              Accept: 'application/json'\n            }\n          }\n        )\n        .then(response => {\n          const accessToken = response.data.access_token;\n          this.token = accessToken;\n          res.send('Enquirer: Github OAuth Server is up');\n          this.prompt.submit();\n        })\n        .catch(e => console.log('axios error', e));\n    });\n    this.token = null;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, err => {\n        if (err) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  stop() {\n    this.server.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    const params = new URLSearchParams({\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code: code,\n      redirect_uri: this.options.redirectUri\n    });\n\n    try {\n      const response = await axios.post('https://github.com/login/oauth/access_token', params);\n      this.token = response.data.access_token;\n      this.prompt.resolve();\n      res.send('Authentication successful');\n    } catch (error) {\n      res.status(500).send('Authentication failed');\n    }\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((error) => {\n          if (error) {\n            reject(error);\n          } else {\n            this.token = null;\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URL } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleAuthCallback.bind(this));\n  }\n\n  async handleAuthCallback(req, res) {\n    const { code } = req.query;\n    try {\n      const response = await axios.post('https://github.com/login/oauth/access_token', {\n        client_id: this.options.clientId,\n        client_secret: this.options.clientSecret,\n        code,\n      });\n      this.token = response.data.access_token;\n      this.prompt.resolve();\n      res.redirect(this.options.callbackUrl);\n    } catch (error) {\n      res.status(500).send('Authentication failed');\n    }\n  }\n\n  async start() {\n    this.server = this.app.listen(this.options.port, () => {\n      console.log(`Server is running on port ${this.options.port}`);\n    });\n    return new Promise((resolve, reject) => {\n      this.server.on('error', reject);\n      this.server.on('listening', resolve);\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (!this.server) {\n        reject(new Error('Server not running'));\n        return;\n      }\n      this.server.close(() => {\n        this.token = null;\n        resolve();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    const params = new URLSearchParams({\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code: code,\n      redirect_uri: this.options.redirectUri\n    });\n\n    try {\n      const response = await axios.post('https://github.com/login/oauth/access_token', params);\n      this.token = response.data.access_token;\n      this.prompt.resolve();\n      res.redirect(this.options.callbackUrl);\n    } catch (error) {\n      console.error('Error handling OAuth callback:', error);\n      res.status(500).send('An error occurred during OAuth authentication.');\n    }\n  }\n\n  async start() {\n    this.server = this.app.listen(this.options.port, () => {\n      console.log(`OAuth server running on port ${this.options.port}`);\n    });\n    return new Promise((resolve, reject) => {\n      this.server.on('error', reject);\n      this.server.on('listening', resolve);\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (!this.server) {\n        reject(new Error('Server not running'));\n        return;\n      }\n      this.server.close(() => {\n        this.token = null;\n        resolve();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    const params = new URLSearchParams({\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code: code,\n      redirect_uri: this.options.redirectUri\n    });\n\n    try {\n      const response = await axios.post('https://github.com/login/oauth/access_token', params);\n      this.token = response.data.access_token;\n      this.prompt.resolve();\n      res.redirect(this.options.callbackUrl);\n    } catch (error) {\n      console.error(error);\n      res.status(500).send('An error occurred during authentication');\n    }\n  }\n\n  async start() {\n    this.server = this.app.listen(this.options.port, () => {\n      console.log(`Server is running on port ${this.options.port}`);\n    });\n    return new Promise((resolve, reject) => {\n      this.server.on('error', reject);\n      this.server.on('listening', resolve);\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (!this.server) {\n        reject(new Error('Server not running'));\n        return;\n      }\n      this.server.close((error) => {\n        if (error) {\n          reject(error);\n        } else {\n          this.token = null;\n          resolve();\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    const params = new URLSearchParams({\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code: code,\n      redirect_uri: this.options.redirectUri,\n    });\n\n    try {\n      const response = await axios.post('https://github.com/login/oauth/access_token', params);\n      this.token = response.data.access_token;\n      this.prompt.resolve();\n      res.send('Authentication successful');\n    } catch (error) {\n      res.status(500).send('Authentication failed');\n    }\n  }\n\n  async start() {\n    this.server = this.app.listen(this.options.port, () => {\n      console.log(`Server is running on port ${this.options.port}`);\n    });\n    return new Promise((resolve, reject) => {\n      this.server.on('error', reject);\n      this.server.on('listening', resolve);\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (!this.server) {\n        reject(new Error('Server not running'));\n        return;\n      }\n      this.server.close(() => {\n        this.token = null;\n        resolve();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    const params = new URLSearchParams({\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code: code,\n      redirect_uri: this.options.redirectUri\n    });\n\n    try {\n      const response = await axios.post('https://github.com/login/oauth/access_token', params);\n      this.token = response.data.access_token;\n      this.prompt.resolve();\n      res.redirect(this.options.callbackUrl);\n    } catch (error) {\n      console.error('Error handling OAuth callback:', error);\n      res.status(500).send('Error handling OAuth callback');\n    }\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  stop() {\n    return new Promise((resolve) => {\n      if (this.server) {\n        this.server.close(resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    const params = new URLSearchParams({\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code,\n      redirect_uri: this.options.redirectUri\n    });\n\n    try {\n      const response = await axios.post('https://github.com/login/oauth/access_token', params);\n      this.token = response.data.access_token;\n      this.prompt.resolve();\n      res.send('Authentication successful');\n    } catch (error) {\n      res.status(500).send('Authentication failed');\n    }\n  }\n\n  async start() {\n    this.server = this.app.listen(this.options.port, () => {\n      console.log(`Server is running on port ${this.options.port}`);\n    });\n    return new Promise((resolve, reject) => {\n      this.server.on('error', reject);\n      this.server.on('listening', resolve);\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (!this.server) {\n        reject(new Error('Server not running'));\n        return;\n      }\n      this.server.close(() => {\n        this.token = null;\n        resolve();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    try {\n      const response = await axios.post('https://github.com/login/oauth/access_token', {\n        client_id: this.options.clientId,\n        client_secret: this.options.clientSecret,\n        code: code,\n      });\n      this.token = response.data.access_token;\n      this.prompt.resolve();\n      res.send('Authentication successful');\n    } catch (error) {\n      res.status(500).send('Authentication failed');\n    }\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((error) => {\n          if (error) {\n            reject(error);\n          } else {\n            this.token = null;\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    const response = await axios.post('https://github.com/login/oauth/access_token', {\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code: code,\n    });\n    this.token = response.data.access_token;\n    this.prompt.resolve();\n    res.redirect(this.options.callbackUrl);\n  }\n\n  async start() {\n    this.server = this.app.listen(this.options.port);\n    return new Promise((resolve, reject) => {\n      this.server.on('listening', resolve);\n      this.server.on('error', reject);\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (!this.server) {\n        reject(new Error('Server not running'));\n        return;\n      }\n      this.server.close((err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst axios = require('axios');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = null;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/auth/callback', this.handleCallback.bind(this));\n  }\n\n  async handleCallback(req, res) {\n    const { code } = req.query;\n    const tokenResponse = await axios.post('https://github.com/login/oauth/access_token', {\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code: code,\n    });\n    this.token = tokenResponse.data.access_token;\n    this.prompt.resolve(this.token);\n    res.redirect(this.options.callbackUrl);\n  }\n\n  async start() {\n    this.server = this.app.listen(this.options.port, () => {\n      console.log(`Server running on port ${this.options.port}`);\n    });\n    return new Promise((resolve, reject) => {\n      this.server.on('error', reject);\n      resolve();\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (!this.server) {\n        reject(new Error('Server not running'));\n      } else {\n        this.server.close(() => {\n          this.token = null;\n          resolve();\n        });\n      }\n    });\n  }\n}\n```"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport http.server\nimport socketserver\nimport os\nimport mimetypes\n\nPORT = 1338\nDIRECTORY = 'static'\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        try:\n            self.send_response(200)\n            self.send_header('Content-type', self.get_headers())\n            self.end_headers()\n            self.wfile.write(self.send_head())\n        except FileNotFoundError:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def get_headers(self):\n        mime_type, _ = mimetypes.guess_type(self.path)\n        return mime_type if mime_type else 'application/octet-stream'\n\ndef createFileServer():\n    with socketserver.TCPServer((\"\", PORT), CustomHTTPRequestHandler) as httpd:\n        print(\"serving at port\", PORT)\n        httpd.serve_forever()\n\ncreateFileServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nfrom urllib.parse import urlparse, unquote\nfrom mimetypes import guess_type\n\nPORT = 1338\nDIRECTORY = 'static'\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        parsed_path = urlparse(self.path)\n        path = unquote(parsed_path.path)\n        if path == '/' or path == '':\n            path = '/index.html'\n        self.path = path\n        super().do_GET()\n\n    def send_error(self, code, message=None):\n        self.send_response(code)\n        self.end_headers()\n        self.wfile.write(b'404 Not Found: ' + (message or b'').encode())\n\ndef createFileServer():\n    with socketserver.TCPServer((\"\", PORT), CustomHTTPRequestHandler) as httpd:\n        print(f\"Serving at port {PORT}\")\n        httpd.serve_forever()\n\ncreateFileServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nfrom urllib.parse import urlparse, parse_qs\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        parsed_path = urlparse(self.path)\n        query_components = parse_qs(parsed_path.query)\n        path = parsed_path.path\n        if path == \"/\":\n            path = \"/index.html\"\n        if not os.path.exists(path):\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n            return\n        self.send_response(200)\n        self.send_header(\"Content-type\", self.guess_type(path))\n        self.end_headers()\n        with open(path, 'rb') as file:\n            self.wfile.write(file.read())\n\ndef createFileServer(port=1338):\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", port), handler) as httpd:\n        print(\"serving at port\", port)\n        httpd.serve_forever()\n\ncreateFileServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport mimetypes\n\nPORT = 1338\nDIRECTORY = 'static'\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path.startswith('/'):\n            self.path = self.path[1:]\n        if not self.path:\n            self.path = '/'\n        if not os.path.exists(os.path.join(DIRECTORY, self.path)):\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n            return\n        self.send_response(200)\n        self.send_header('Content-type', self.guess_type(self.path)[0])\n        self.end_headers()\n        with open(os.path.join(DIRECTORY, self.path), 'rb') as f:\n            self.wfile.write(f.read())\n\ndef createFileServer():\n    with socketserver.TCPServer((\"\", PORT), CustomHTTPRequestHandler) as httpd:\n        print(\"serving at port\", PORT)\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nfrom urllib.parse import urlparse, parse_qs\nfrom mimetypes import guess_type\n\nPORT = 1338\nDIRECTORY = 'static'\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        parsed_path = urlparse(self.path)\n        path = parsed_path.path\n        if path == '/':\n            path = '/index.html'\n        self.send_response(200)\n        self.send_header('Content-type', self.guess_content_type(path))\n        self.end_headers()\n        try:\n            with open(os.path.join(DIRECTORY, path), 'rb') as file:\n                self.wfile.write(file.read())\n        except FileNotFoundError:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def guess_content_type(self, path):\n        mime_type, _ = guess_type(path)\n        return mime_type or 'application/octet-stream'\n\nhandler = CustomHTTPRequestHandler\nwith socketserver.TCPServer((\"\", PORT), handler) as httpd:\n    print(\"serving at port\", PORT)\n    httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport mimetypes\n\nPORT = 1338\nDIRECTORY = 'static'\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def send_error(self, code, message=None):\n        self.send_response(code)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        if message:\n            self.wfile.write(message.encode())\n\n    def do_GET(self):\n        try:\n            if self.path.startswith('/'):\n                self.path = self.path[1:]\n            if self.path == '':\n                self.path = '/index.html'\n            full_path = os.path.join(DIRECTORY, self.path)\n            if not os.path.exists(full_path):\n                self.send_error(404, 'File Not Found: %s' % self.path)\n                return\n            self.send_response(200)\n            mime_type, _ = mimetypes.guess_type(full_path)\n            if mime_type is None:\n                mime_type = 'application/octet-stream'\n            self.send_header('Content-type', mime_type)\n            self.end_headers()\n            with open(full_path, 'rb') as file:\n                self.wfile.write(file.read())\n        except Exception as e:\n            self.send_error(500, str(e))\n\ndef createFileServer():\n    with socketserver.TCPServer((\"\", PORT), CustomHTTPRequestHandler) as httpd:\n        print(\"serving at port\", PORT)\n        httpd.serve_forever()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport mimetypes\n\nPORT = 1338\nDIRECTORY = 'static'\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path.startswith('/'):\n            self.path = self.path[1:]\n        if not os.path.exists(os.path.join(DIRECTORY, self.path)):\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n            return\n        self.send_response(200)\n        self.send_header('Content-type', self.guess_type(self.path)[0])\n        self.end_headers()\n        with open(os.path.join(DIRECTORY, self.path), 'rb') as file:\n            self.wfile.write(file.read())\n\ndef createFileServer():\n    with socketserver.TCPServer((\"\", PORT), CustomHTTPRequestHandler) as httpd:\n        print(\"serving at port\", PORT)\n        httpd.serve_forever()\n\ncreateFileServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport mimetypes\n\nPORT = 1338\nDIRECTORY = 'static'\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        try:\n            self.send_response(200)\n            self.send_header('Content-type', self.get_headers())\n            self.end_headers()\n            self.copyfile(self.wfile, self.send_response)\n        except FileNotFoundError:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def get_headers(self):\n        mime_type, _ = mimetypes.guess_type(self.path)\n        if mime_type is None:\n            mime_type = 'application/octet-stream'\n        return mime_type\n\ndef createFileServer():\n    handler = CustomHTTPRequestHandler\n    with socketserver.TCPServer((\"\", PORT), handler) as httpd:\n        print(\"serving at port\", PORT)\n        httpd.serve_forever()\n\ncreateFileServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nfrom urllib.parse import urlparse, parse_qs\nfrom mimetypes import guess_type\n\nPORT = 1338\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        parsed_path = urlparse(self.path)\n        path = parsed_path.path\n        if path == '/':\n            path = '/index.html'\n        self.send_response(200)\n        self.send_header('Content-type', self.guess_content_type(path))\n        self.end_headers()\n        try:\n            with open(path, 'rb') as file:\n                self.wfile.write(file.read())\n        except FileNotFoundError:\n            self.send_error(404, \"File Not Found: %s\" % self.path)\n\n    def guess_content_type(self, path):\n        mime_type, _ = guess_type(path)\n        return mime_type if mime_type else 'application/octet-stream'\n\ndef createFileServer():\n    with socketserver.TCPServer((\"\", PORT), CustomHTTPRequestHandler) as httpd:\n        print(\"serving at port\", PORT)\n        httpd.serve_forever()\n\ncreateFileServer()\n```",
      "```python\nimport http.server\nimport socketserver\nimport os\nimport mimetypes\n\nPORT = 1338\nDIRECTORY = 'static'\n\nclass CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def send_error(self, code, message):\n        self.send_response(code)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        self.wfile.write(message.encode())\n\n    def do_GET(self):\n        if self.path.startswith('/'):\n            self.path = self.path[1:]\n        if not self.path:\n            self.path = '/index.html'\n        if not os.path.exists(os.path.join(DIRECTORY, self.path)):\n            self.send_error(404, 'File Not Found: %s' % self.path)\n            return\n        self.send_response(200)\n        self.send_header('Content-type', mimetypes.guess_type(self.path)[0] or 'text/plain')\n        self.end_headers()\n        with open(os.path.join(DIRECTORY, self.path), 'rb') as file:\n            self.wfile.write(file.read())\n\nhandler = CustomHTTPRequestHandler\nwith socketserver.TCPServer((\"\", PORT), handler) as httpd:\n    print(\"serving at port\", PORT)\n    httpd.serve_forever()\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Create a TCP server in Node.js that handles client connections, processes incoming data with authentication, and responds to commands.\n\nFunction Description: The code provides functions to create and manage a TCP server that listens for client connections, receives and validates data packets, processes commands, and sends responses. It includes packet validation using MD5 hashing with a timestamp and password for security.\n\nInput:\n- createTCPServer:\n  - host: string - The host address to bind to\n  - port: number - The port number to listen on\n  - password: string - The authentication password\n  - commandHandler: function - Async function to handle commands (accepts data and code parameters)\n\n- receiveData:\n  - receive: object - Contains accumulated data Buffer and socket reference\n  - data: Buffer - New data chunk received\n  - password: string - Authentication password\n  - commandHandler: function - Command handler function\n\n- checkData:\n  - receive: object - Contains accumulated data Buffer and socket reference\n  - password: string - Authentication password\n  - commandHandler: function - Command handler function\n\n- checkCode:\n  - data: Buffer - Received command data\n  - password: string - Authentication password\n  - code: Buffer - Received authentication code\n\n- pack:\n  - data: object - Response data to package (contains code and optional data)\n\nOutput:\n- createTCPServer: Returns a net.Server instance\n- receiveData: void (modifies receive.data in place)\n- checkData: void (may send responses via socket)\n- checkCode: boolean - Returns true if authentication is valid\n- pack: Buffer - Returns formatted packet Buffer",
    "Canonical_solution": "const net = require('net');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    const receive = {\n      data: Buffer.from(''),\n      socket,\n    };\n    socket.on('data', data => {\n      receiveData(receive, data, password, commandHandler);\n    });\n    socket.on('error', (err) => {\n      throw err;\n    });\n  }).on('error', (err) => {\n    throw err;\n  });\n\n  server.listen({\n    port,\n    host,\n  }, () => {\n    console.log(`server listen on ${ host }:${ port }`);\n  });\n\n  return server;\n}\n\nfunction receiveData(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const buffer = receive.data;\n  let length = 0;\n  let data;\n  let code;\n  if(buffer.length < 2) { return; }\n  length = buffer[0] * 256 + buffer[1];\n  if(buffer.length >= length + 2) {\n    data = buffer.slice(2, length - 2);\n    code = buffer.slice(length - 2);\n    if(!checkCode(data, password, code)) {\n      receive.socket.end(pack({ code: 2 }));\n      return;\n    }\n    commandHandler(data, code).then(s => {\n      receive.socket.end(pack({ code: 0, data: s }));\n    }).catch(err => {\n      let code = -1;\n      if(err === 'invalid command') { code = 1; }\n      receive.socket.end(pack({ code }));\n    });\n    if(buffer.length > length + 2) {\n      checkData(receive, password, commandHandler);\n    }\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const time = Number.parseInt(data.slice(0, 6).toString('hex'), 16);\n  if(Math.abs(Date.now() - time) > 10 * 60 * 1000) {\n    return false;\n  }\n  const command = data.slice(6).toString();\n  const md5 = crypto.createHash('md5').update(time + command + password).digest('hex');\n  return md5.substr(0, 8) === code.toString('hex');\n}\n\nfunction pack(data) {\n  const message = JSON.stringify(data);\n  const dataBuffer = Buffer.from(message);\n  const length = dataBuffer.length;\n  const lengthBuffer = Buffer.from(('0000000000000000' + length.toString(16)).substr(-8), 'hex');\n  const pack = Buffer.concat([lengthBuffer, dataBuffer]);\n  return pack;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: data, socket }, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const endOfData = receive.data.indexOf(0x0A);\n  if (endOfData !== -1) {\n    const data = receive.data.slice(0, endOfData);\n    const code = receive.data.slice(endOfData + 1);\n    if (checkCode(data, password, code)) {\n      commandHandler(data, code);\n    }\n    receive.data = receive.data.slice(endOfData + 2);\n    checkData(receive, password, commandHandler);\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHmac('md5', password).update(data).digest();\n  return Buffer.compare(hash, code) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.createHmac('md5', 'password').update(data).digest();\n  return Buffer.concat([Buffer.from(data), code]);\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: Buffer.alloc(0), socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const authCode = data.slice(0, 16);\n    const command = data.slice(16);\n    if (checkCode(command, password, authCode)) {\n      commandHandler(command, authCode);\n      receive.data = data.slice(32);\n    } else {\n      receive.socket.write('Authentication failed');\n      receive.data = Buffer.alloc(0);\n    }\n  }\n}\n\nfunction checkCode(data, password, authCode) {\n  const hash = crypto.createHmac('md5', password).update(data).digest();\n  return Buffer.compare(hash, authCode) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.createHmac('md5', 'password').update(data).digest();\n  return Buffer.concat([code, Buffer.from(data)]);\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: Buffer.alloc(0), socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const code = data.slice(0, 16);\n    const dataWithoutCode = data.slice(16);\n    if (checkCode(dataWithoutCode, password, code)) {\n      commandHandler(dataWithoutCode, code);\n      receive.data = data.slice(16 + 16);\n    } else {\n      receive.data = Buffer.alloc(0);\n    }\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHmac('md5', password).update(data).digest();\n  return Buffer.compare(hash, code) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.createHmac('md5', 'password').update(data).digest();\n  const packet = Buffer.concat([code, Buffer.from(JSON.stringify(data))]);\n  return packet;\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: Buffer.alloc(0), socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const code = data.slice(0, 16);\n    const dataWithoutCode = data.slice(16);\n    if (checkCode(dataWithoutCode, password, code)) {\n      commandHandler(dataWithoutCode, code);\n      receive.data = Buffer.alloc(0);\n    }\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHmac('md5', password).update(data).digest();\n  return Buffer.compare(hash, code) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.createHmac('md5', 'password').update(data).digest();\n  return Buffer.concat([code, Buffer.from(data)]);\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: data, socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const authCode = data.slice(0, 16);\n    const dataWithoutCode = data.slice(16);\n    if (checkCode(dataWithoutCode, password, authCode)) {\n      commandHandler(dataWithoutCode, authCode);\n      receive.data = Buffer.alloc(0);\n    }\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHash('md5');\n  hash.update(`${data.toString()}${password}`);\n  return Buffer.compare(hash.digest(), code) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.randomBytes(16);\n  const packet = Buffer.concat([code, Buffer.from(JSON.stringify(data))]);\n  return packet;\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: data, socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const authCode = data.slice(0, 16);\n    const dataWithoutCode = data.slice(16);\n    if (checkCode(dataWithoutCode, password, authCode)) {\n      commandHandler(dataWithoutCode, authCode);\n    }\n    receive.data = data.slice(16);\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHash('md5').update(`${data.toString()}${password}`).digest();\n  return Buffer.compare(hash, code) === 0;\n}\n\nfunction pack(data) {\n  const responseCode = Buffer.alloc(1, 0);\n  const packedData = Buffer.concat([responseCode, Buffer.from(JSON.stringify(data))]);\n  return packedData;\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: Buffer.alloc(0), socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const authCode = data.slice(0, 16);\n    const dataWithoutAuth = data.slice(16);\n    if (checkCode(dataWithoutAuth, password, authCode)) {\n      commandHandler(dataWithoutAuth, 'command');\n      receive.data = Buffer.alloc(0);\n    }\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHmac('md5', password).update(data).digest();\n  return Buffer.compare(hash, code) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.createHmac('md5', 'password').update(data).digest();\n  return Buffer.concat([code, Buffer.from(data)]);\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: Buffer.alloc(0), socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const code = data.slice(0, 16);\n    const dataWithoutCode = data.slice(16);\n    if (checkCode(dataWithoutCode, password, code)) {\n      commandHandler(dataWithoutCode, code);\n      receive.data = data.slice(16 + 16);\n    } else {\n      receive.data = Buffer.alloc(0);\n    }\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHmac('md5', password).update(data).digest();\n  return Buffer.compare(hash, code) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.createHmac('md5', 'password').update(data).digest();\n  return Buffer.concat([code, Buffer.from(data)]);\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: Buffer.alloc(0), socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const code = data.slice(0, 16);\n    const dataWithoutCode = data.slice(16);\n    if (checkCode(dataWithoutCode, password, code)) {\n      commandHandler(dataWithoutCode, code);\n      receive.data = data.slice(16 + 16);\n    } else {\n      receive.data = Buffer.alloc(0);\n    }\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHmac('md5', password).update(data).digest();\n  return Buffer.compare(hash, code) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.createHmac('md5', 'password').update(data).digest();\n  const packet = Buffer.concat([code, Buffer.from(JSON.stringify(data))]);\n  return packet;\n}\n```",
      "```javascript\nconst net = require('net');\nconst crypto = require('crypto');\n\nfunction createTCPServer(host, port, password, commandHandler) {\n  const server = net.createServer(socket => {\n    socket.on('data', data => {\n      receive({ data: Buffer.alloc(0), socket }, data, password, commandHandler);\n    });\n  });\n  server.listen(port, host);\n  return server;\n}\n\nfunction receive(receive, data, password, commandHandler) {\n  receive.data = Buffer.concat([receive.data, data]);\n  checkData(receive, password, commandHandler);\n}\n\nfunction checkData(receive, password, commandHandler) {\n  const data = receive.data;\n  if (data.length >= 16) {\n    const code = data.slice(0, 16);\n    const dataWithoutCode = data.slice(16);\n    if (checkCode(dataWithoutCode, password, code)) {\n      commandHandler(dataWithoutCode, code);\n      receive.data = data.slice(16 + 16);\n    } else {\n      receive.data = Buffer.alloc(0);\n    }\n  }\n}\n\nfunction checkCode(data, password, code) {\n  const hash = crypto.createHmac('md5', password).update(data).digest();\n  return Buffer.compare(hash, code) === 0;\n}\n\nfunction pack(data) {\n  const code = crypto.createHmac('md5', 'password').update(data).digest();\n  return Buffer.concat([code, Buffer.from(data)]);\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 152,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module to handle client connections and data exchange.\n\nFunction Description: The function creates and starts a TCP server that listens on a specified port. When a client connects, the server sends a greeting message (\"Hello.\") and logs any incoming data from the client to the console.\n\nInput: \n- port: [number] - The port number on which the TCP server should listen for incoming connections.\n\nOutput: \n- None (The function creates and starts a server but does not return any value).",
    "Canonical_solution": "const net = require(\"net\");\n\nfunction createTCPServer(port) {\n    const server = net.createServer(socket => {\n        socket.write(\"Hello.\");\n        socket.on(\"data\", data => {\n            console.log(data.toString());\n        });\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\n\nserver.listen(port);",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\nserver.listen(port);",
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\n\nserver.listen(port);",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\nserver.listen(port);",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\nserver.listen(port);",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\nserver.listen(port);",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\nserver.listen(port);",
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\n\nserver.listen(port);",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\nserver.listen(port);",
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('Hello.\\n');\n  socket.on('data', (data) => {\n    console.log(data.toString());\n  });\n});\n\nserver.listen(port);"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a TCP server that handles client connections with authentication and provides a random quote service upon successful authentication.\n\nFunction Description: The function `createServer` establishes a TCP server that listens on a specified port. It uses the `dnode` library for remote procedure calls (RPC) and implements an authentication mechanism. Upon successful authentication, clients gain access to a `randomQuote` service. The server logs connection and disconnection events.\n\nInput:  \n- `port` (Number): The port number on which the TCP server should listen for incoming connections.\n\nOutput:  \n- None (The function creates and starts a server instance but doesn't return anything. Side effects include logging connection events to the console.)  \n\nNote: The function relies on an undefined `randomQuote` function which should be implemented elsewhere to provide quote generation functionality. The authentication hardcodes credentials (user: 'moo', pass: 'hax') for demonstration purposes.",
    "Canonical_solution": "var dnode = require('dnode');\nvar fs = require('fs');\nvar net = require('net');\n\nfunction createServer(port) {\n    var server = net.createServer(function (stream) {\n        var d = dnode({ auth : auth });\n        d.pipe(stream).pipe(d);\n        \n        function auth (user, pass, cb) {\n            if (typeof cb !== 'function') return;\n            \n            if (user === 'moo' && pass === 'hax') {\n                console.log('signed in: ' + user);\n                d.on('end', function () {\n                    console.log('disconnected: ' + user);\n                });\n                \n                cb(null, { quote : randomQuote });\n            }\n            else cb('ACCESS DENIED')\n        }\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  const authCredentials = { user: 'moo', pass: 'hax' };\n\n  server.on('connection', (socket) => {\n    console.log('Client connected');\n    const d = dnode({ randomQuote });\n    d.on('remote', (client) => {\n      socket.write('Enter username: ');\n      socket.on('data', (data) => {\n        const username = data.toString().trim();\n        socket.write('Enter password: ');\n        socket.on('data', (data) => {\n          const password = data.toString().trim();\n          if (username === authCredentials.user && password === authCredentials.pass) {\n            socket.write('Authentication successful.\\n');\n            client.randomQuote((err, quote) => {\n              if (err) {\n                socket.write('Error fetching quote.\\n');\n              } else {\n                socket.write(`Random Quote: ${quote}\\n`);\n              }\n            });\n          } else {\n            socket.write('Authentication failed.\\n');\n            socket.end();\n          }\n        });\n      });\n    });\n    d.connect(socket);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  const credentials = { user: 'moo', pass: 'hax' };\n\n  server.on('connection', (socket) => {\n    console.log('Client connected');\n    const d = dnode({ randomQuote });\n    socket.pipe(d).pipe(socket);\n\n    d.on('remote', (client) => {\n      client.authenticate(credentials, (err, isAuthenticated) => {\n        if (err) {\n          console.log('Authentication failed');\n          socket.end();\n          return;\n        }\n        if (isAuthenticated) {\n          console.log('Authentication successful');\n          client.randomQuote((err, quote) => {\n            if (err) {\n              console.log('Error fetching quote');\n              socket.end();\n              return;\n            }\n            console.log('Quote:', quote);\n            socket.end();\n          });\n        } else {\n          console.log('Authentication failed');\n          socket.end();\n        }\n      });\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  const authCredentials = { user: 'moo', pass: 'hax' };\n\n  server.on('connection', (socket) => {\n    console.log('Client connected');\n    const d = dnode({ randomQuote });\n    d.on('remote', (client) => {\n      socket.write('Enter username: ');\n      socket.on('data', (data) => {\n        const username = data.toString().trim();\n        socket.write('Enter password: ');\n        socket.on('data', (data) => {\n          const password = data.toString().trim();\n          if (username === authCredentials.user && password === authCredentials.pass) {\n            socket.write('Authentication successful.\\n');\n            client.randomQuote((err, quote) => {\n              if (err) {\n                socket.write('Error fetching quote.\\n');\n              } else {\n                socket.write(`Random Quote: ${quote}\\n`);\n              }\n              socket.end();\n            });\n          } else {\n            socket.write('Authentication failed.\\n');\n            socket.end();\n          }\n        });\n      });\n    });\n    d.connect(socket);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  const authCredentials = { user: 'moo', pass: 'hax' };\n\n  server.on('connection', (socket) => {\n    console.log('Client connected');\n    const d = dnode({ randomQuote });\n    d.on('remote', (client) => {\n      socket.write('Enter username: ');\n      socket.on('data', (data) => {\n        const username = data.toString().trim();\n        socket.write('Enter password: ');\n        socket.on('data', (data) => {\n          const password = data.toString().trim();\n          if (username === authCredentials.user && password === authCredentials.pass) {\n            socket.write('Authentication successful.\\n');\n            client.randomQuote((err, quote) => {\n              if (err) {\n                socket.write('Error fetching quote.\\n');\n              } else {\n                socket.write(`Random Quote: ${quote}\\n`);\n              }\n            });\n          } else {\n            socket.write('Authentication failed.\\n');\n            socket.end();\n          }\n        });\n      });\n    });\n    d.connect(socket);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  const credentials = { user: 'moo', pass: 'hax' };\n\n  server.on('connection', (socket) => {\n    console.log('Client connected');\n    const d = dnode({ randomQuote });\n    socket.pipe(d).pipe(socket);\n\n    d.on('remote', (client) => {\n      client.authenticate(credentials, (err, isAuthenticated) => {\n        if (err) {\n          console.log('Authentication failed');\n          socket.end();\n        } else if (isAuthenticated) {\n          console.log('Client authenticated');\n        } else {\n          console.log('Authentication failed');\n          socket.end();\n        }\n      });\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  const credentials = { user: 'moo', pass: 'hax' };\n\n  server.on('connection', (socket) => {\n    console.log('Client connected');\n    const d = dnode({ randomQuote });\n    d.on('remote', (client) => {\n      socket.write('Username: ');\n      socket.on('data', (data) => {\n        const username = data.toString().trim();\n        socket.write('Password: ');\n        socket.on('data', (data) => {\n          const password = data.toString().trim();\n          if (username === credentials.user && password === credentials.pass) {\n            client.randomQuote((err, quote) => {\n              if (err) {\n                socket.write('Error: ' + err.message);\n              } else {\n                socket.write('Quote: ' + quote);\n              }\n              socket.end();\n            });\n          } else {\n            socket.write('Authentication failed');\n            socket.end();\n          }\n        });\n      });\n    });\n    socket.on('end', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port);\n}\n```",
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  const authCredentials = { user: 'moo', pass: 'hax' };\n\n  server.on('connection', (socket) => {\n    console.log('Client connected');\n    const d = dnode({ randomQuote });\n    d.on('remote', (client) => {\n      socket.write('Enter username: ');\n      socket.on('data', (data) => {\n        const username = data.toString().trim();\n        socket.write('Enter password: ');\n        socket.on('data', (data) => {\n          const password = data.toString().trim();\n          if (username === authCredentials.user && password === authCredentials.pass) {\n            socket.write('Authentication successful.\\n');\n            client.randomQuote((err, quote) => {\n              if (err) {\n                socket.write('Error fetching quote.\\n');\n              } else {\n                socket.write(`Random Quote: ${quote}\\n`);\n              }\n            });\n          } else {\n            socket.write('Authentication failed.\\n');\n            socket.end();\n          }\n        });\n      });\n    });\n    d.connect(socket);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('connection', (socket) => {\n    const d = dnode({ randomQuote });\n    d.on('remote', (client) => {\n      socket.write('Username: ');\n      socket.on('data', (data) => {\n        const username = data.toString().trim();\n        if (username === 'moo') {\n          socket.write('Password: ');\n        } else {\n          socket.end('Authentication failed');\n          return;\n        }\n      });\n      socket.on('data', (data) => {\n        const password = data.toString().trim();\n        if (password === 'hax') {\n          client.randomQuote((err, quote) => {\n            if (err) {\n              socket.end('Error retrieving quote');\n            } else {\n              socket.write(`Random Quote: ${quote}`);\n            }\n          });\n        } else {\n          socket.end('Authentication failed');\n        }\n      });\n    });\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('connection', (socket) => {\n    const d = dnode({ randomQuote });\n    d.on('remote', (client) => {\n      socket.write('Username: ');\n      socket.on('data', (data) => {\n        const username = data.toString().trim();\n        if (username === 'moo') {\n          socket.write('Password: ');\n          socket.on('data', (data) => {\n            const password = data.toString().trim();\n            if (password === 'hax') {\n              client.randomQuote((err, quote) => {\n                if (err) {\n                  socket.write('Error: Unable to get a random quote.');\n                } else {\n                  socket.write(`Random Quote: ${quote}`);\n                }\n              });\n            } else {\n              socket.write('Authentication failed.');\n            }\n          });\n        } else {\n          socket.write('Authentication failed.');\n        }\n      });\n    });\n\n    socket.on('end', () => {\n      console.log('Client disconnected');\n    });\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = net.createServer();\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('connection', (socket) => {\n    const d = dnode((remote) => {\n      remote.authenticate = (user, pass) => {\n        if (user === 'moo' && pass === 'hax') {\n          console.log('Client authenticated');\n          remote.randomQuote();\n        } else {\n          console.log('Authentication failed');\n          remote.end();\n        }\n      };\n    });\n\n    d.connect(socket);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```"
    ],
    "match_count": 7,
    "pass@3": 0.9916666666666667,
    "pass@5": 1.0
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a TCP server class in JavaScript that can handle both regular and TLS-encrypted connections, manage client connections, and provide methods to start and destroy the server.\n\nClass Description: The MockServer class is a TCP server implementation that can be configured to use either regular TCP or TLS encryption. It manages server lifecycle, client connections, and provides methods to start and stop the server gracefully.\n\nAttributes:\n- host: [String] - The host address the server binds to\n- port: [Number] - The port number the server listens on\n- family: [String] - The IP address family (e.g., 'ipv4')\n- server: [Object] - The underlying TCP/TLS server instance\n- tlsEnabled: [Boolean] - Flag indicating if TLS is enabled\n- state: [String] - Current server state ('stopped', 'running', or 'destroyed')\n- connections: [Number] - Count of active client connections\n- sockets: [Array] - Array of active client sockets\n\nMethods:\n- constructor(port, host, options) -> [void] - Initializes the server with specified port, host, and options (including TLS configuration)\n- start() -> [Promise] - Starts the server and returns a promise that resolves when listening\n- destroy() -> [Promise] - Gracefully shuts down the server and returns a promise that resolves when complete",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    // Save the settings\n    this.host = host;\n    this.port = port;\n    this.family = 'ipv4';\n\n    // Create a server socket\n    this.server = options.tls ? tls.createServer(options) : net.createServer(options);\n    this.tlsEnabled = !!options.tls;\n\n    // state\n    this.state = 'stopped';\n\n    // Number of connections\n    this.connections = 0;\n\n    // sockets\n    this.sockets = [];\n  }\n\n  /**\n   * Start the TCP server\n   */\n  start() {\n    const self = this;\n    return new Promise((resolve, reject) => {\n      self.server.on('error', err => {\n        reject(err);\n      });\n\n      const connectionEventName = self.tlsEnabled ? 'secureConnection' : 'connection';\n      self.server.on(connectionEventName, c => {\n        self.connections = self.connections + 1;\n        self.sockets.push(c);\n\n        c.on('error', e => {\n          console.warn('connection error: ', e);\n        });\n\n        c.on('close', () => {\n          self.connections = self.connections - 1;\n          const index = self.sockets.indexOf(c);\n          if (index !== -1) {\n            self.sockets.splice(index, 1);\n          }\n        });\n      });\n\n      self.server.listen(self.port, self.host, () => {\n        // update address information if necessary\n        self.host = self.server.address().address;\n        self.port = self.server.address().port;\n        self.family = self.server.address().family;\n\n        resolve(self);\n      });\n\n      self.state = 'running';\n    });\n  }\n\n  /**\n   * Destroy the TCP server\n   */\n  destroy() {\n    const self = this;\n    if (self.state === 'destroyed') {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      self.sockets.forEach(socket => socket.destroy());\n      self.server.close(err => {\n        if (err) return reject(err);\n        self.state = 'destroyed';\n        resolve();\n      });\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        return reject(new Error('Server is already running'));\n      }\n\n      this.state = 'starting';\n      const createServer = this.tlsEnabled ? tls.createServer : net.createServer;\n\n      this.server = createServer(this.options, (socket) => {\n        this.connections++;\n        this.sockets.push(socket);\n        socket.on('end', () => {\n          this.connections--;\n          const index = this.sockets.indexOf(socket);\n          if (index !== -1) {\n            this.sockets.splice(index, 1);\n          }\n        });\n        socket.on('error', (err) => {\n          console.error('Socket error:', err);\n        });\n      });\n\n      this.server.listen(this.port, this.host, () => {\n        this.state = 'running';\n        resolve();\n      });\n\n      this.server.on('error', (err) => {\n        this.state = 'stopped';\n        reject(err);\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'stopped') {\n        return reject(new Error('Server is already stopped'));\n      }\n\n      this.state = 'stopping';\n      this.server.close((err) => {\n        if (err) {\n          return reject(err);\n        }\n\n        this.state = 'stopped';\n        this.connections = 0;\n        this.sockets = [];\n        resolve();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        return reject(new Error('Server is already running'));\n      }\n      if (this.state === 'destroyed') {\n        return reject(new Error('Server has been destroyed'));\n      }\n\n      this.state = 'starting';\n      const createServer = this.tlsEnabled ? tls.createServer : net.createServer;\n\n      this.server = createServer(this.options, (socket) => {\n        this.connections++;\n        this.sockets.push(socket);\n        socket.on('end', () => {\n          this.connections--;\n          const index = this.sockets.indexOf(socket);\n          if (index > -1) {\n            this.sockets.splice(index, 1);\n          }\n        });\n        socket.on('error', (err) => {\n          console.error('Socket error:', err);\n        });\n      });\n\n      this.server.listen(this.port, this.host, () => {\n        this.state = 'running';\n        resolve();\n      });\n\n      this.server.on('error', (err) => {\n        this.state = 'stopped';\n        reject(err);\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'stopped') {\n        return reject(new Error('Server is already stopped'));\n      }\n      if (this.state === 'destroyed') {\n        return reject(new Error('Server has been destroyed'));\n      }\n\n      this.state = 'stopping';\n      this.server.close((err) => {\n        if (err) {\n          return reject(err);\n        }\n        this.state = 'destroyed';\n        this.connections = 0;\n        this.sockets = [];\n        resolve();\n      });\n    });\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options = {}) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options.tlsEnabled ? {\n      key: fs.readFileSync(options.key),\n      cert: fs.readFileSync(options.cert),\n      ca: options.ca ? fs.readFileSync(options.ca) : null\n    } : {};\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        return reject(new Error('Server is already running'));\n      }\n      this.state = 'starting';\n      this.server = this.tlsEnabled ? tls.createServer(this.options, (socket) => {\n        this.handleConnection(socket);\n      }) : net.createServer((socket) => {\n        this.handleConnection(socket);\n      });\n\n      this.server.listen(this.port, this.host, () => {\n        this.state = 'running';\n        this.connections = this.server.connections;\n        resolve();\n      });\n\n      this.server.on('connection', (socket) => {\n        this.connections++;\n      });\n\n      this.server.on('close', () => {\n        this.state = 'stopped';\n        this.connections = 0;\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'stopped') {\n        return reject(new Error('Server is already stopped'));\n      }\n      this.state = 'stopping';\n      this.server.close(() => {\n        this.state = 'destroyed';\n        this.connections = 0;\n        this.sockets = [];\n        resolve();\n      });\n    });\n  }\n\n  handleConnection(socket) {\n    this.sockets.push(socket);\n    socket.on('end', () => {\n      this.connections--;\n      const index = this.sockets.indexOf(socket);\n      if (index !== -1) {\n        this.sockets.splice(index, 1);\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        reject(new Error('Server is already running'));\n        return;\n      }\n\n      this.state = 'starting';\n      const createServer = this.tlsEnabled ? this.createTlsServer : this.createTcpServer;\n      this.server = createServer();\n\n      this.server.listen(this.port, this.host, () => {\n        this.state = 'running';\n        this.connections = 0;\n        this.sockets = [];\n        resolve();\n      });\n\n      this.server.on('connection', (socket) => {\n        this.connections++;\n        this.sockets.push(socket);\n        socket.on('close', () => {\n          this.connections--;\n          const index = this.sockets.indexOf(socket);\n          if (index !== -1) this.sockets.splice(index, 1);\n        });\n      });\n\n      this.server.on('error', (error) => {\n        this.state = 'stopped';\n        reject(error);\n      });\n    });\n  }\n\n  createTcpServer() {\n    return net.createServer((socket) => {\n      socket.on('data', (data) => {\n        // Handle data\n      });\n    });\n  }\n\n  createTlsServer() {\n    const credentials = {\n      key: fs.readFileSync(this.options.key),\n      cert: fs.readFileSync(this.options.cert)\n    };\n    return tls.createServer(credentials, (socket) => {\n      socket.on('data', (data) => {\n        // Handle data\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'stopped' || this.state === 'destroyed') {\n        reject(new Error('Server is already stopped or destroyed'));\n        return;\n      }\n\n      this.state = 'stopping';\n      this.server.close((error) => {\n        if (error) {\n          reject(error);\n        } else {\n          this.state = 'stopped';\n          this.connections = 0;\n          this.sockets = [];\n          resolve();\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        return reject(new Error('Server is already running'));\n      }\n\n      this.state = 'starting';\n\n      const createServer = () => {\n        if (this.tlsEnabled) {\n          this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n            this.handleConnection(socket);\n          });\n        } else {\n          this.server = net.createServer((socket) => {\n            this.handleConnection(socket);\n          });\n        }\n\n        this.server.listen(this.port, this.host, () => {\n          this.state = 'running';\n          this.connections = this.server.getConnections().length;\n          resolve();\n        });\n\n        this.server.on('connection', (socket) => {\n          this.connections++;\n          this.sockets.push(socket);\n        });\n\n        this.server.on('close', () => {\n          this.state = 'stopped';\n          this.connections = 0;\n          this.sockets = [];\n        });\n      };\n\n      if (this.tlsEnabled && !this.options.tlsOptions.key || !this.options.tlsOptions.cert) {\n        return reject(new Error('TLS options must include key and cert'));\n      }\n\n      createServer();\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'stopped') {\n        return reject(new Error('Server is already stopped'));\n      }\n\n      this.state = 'stopping';\n\n      this.server.close(() => {\n        this.state = 'destroyed';\n        this.connections = 0;\n        this.sockets = [];\n        resolve();\n      });\n    });\n  }\n\n  handleConnection(socket) {\n    // Handle client connection logic here\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        return reject(new Error('Server is already running'));\n      }\n\n      this.state = 'starting';\n      this.server = this.tlsEnabled\n        ? tls.createServer(this.options, (socket) => {\n            this.handleConnection(socket);\n          })\n        : net.createServer((socket) => {\n            this.handleConnection(socket);\n          });\n\n      this.server.listen(this.port, this.host, () => {\n        this.state = 'running';\n        this.connections = this.server.connections;\n        resolve();\n      });\n\n      this.server.on('connection', (socket) => {\n        this.connections++;\n        this.sockets.push(socket);\n      });\n\n      this.server.on('close', () => {\n        this.state = 'stopped';\n        this.connections = 0;\n        this.sockets = [];\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'stopped') {\n        return reject(new Error('Server is already stopped'));\n      }\n\n      this.state = 'stopping';\n      this.server.close(() => {\n        this.state = 'destroyed';\n        this.connections = 0;\n        this.sockets = [];\n        resolve();\n      });\n    });\n  }\n\n  handleConnection(socket) {\n    // Handle client connection logic here\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        reject(new Error('Server is already running'));\n        return;\n      }\n      this.state = 'starting';\n      const createServer = this.tlsEnabled ? tls.createServer : net.createServer;\n      this.server = createServer(this.options, (socket) => {\n        this.handleConnection(socket);\n      }).listen(this.port, this.host, () => {\n        this.state = 'running';\n        this.connections++;\n        resolve();\n      }).on('error', (err) => {\n        this.state = 'stopped';\n        reject(err);\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'stopped') {\n        reject(new Error('Server is already stopped'));\n        return;\n      }\n      this.state = 'stopping';\n      this.server.close((err) => {\n        if (err) {\n          reject(err);\n        } else {\n          this.state = 'stopped';\n          this.connections = 0;\n          this.sockets = [];\n          resolve();\n        }\n      });\n    });\n  }\n\n  handleConnection(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      // Handle incoming data\n    });\n    socket.on('end', () => {\n      this.connections--;\n      this.sockets = this.sockets.filter(s => s !== socket);\n    });\n    socket.on('error', (err) => {\n      this.sockets = this.sockets.filter(s => s !== socket);\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    if (this.tlsEnabled) {\n      this.server = tls.createServer(options.tlsOptions, (socket) => {\n        this.handleConnection(socket);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.handleConnection(socket);\n      });\n    }\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        reject(new Error('Server is already running'));\n        return;\n      }\n      this.server.listen(this.port, this.host, () => {\n        this.state = 'running';\n        this.connections = this.server.getConnections().length;\n        resolve();\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'destroyed') {\n        reject(new Error('Server is already destroyed'));\n        return;\n      }\n      this.server.close(() => {\n        this.state = 'destroyed';\n        this.connections = 0;\n        this.sockets.forEach(socket => socket.destroy());\n        resolve();\n      });\n    });\n  }\n\n  handleConnection(socket) {\n    this.connections++;\n    this.sockets.push(socket);\n    socket.on('end', () => {\n      this.connections--;\n      const index = this.sockets.indexOf(socket);\n      if (index > -1) {\n        this.sockets.splice(index, 1);\n      }\n    });\n    socket.on('error', (error) => {\n      console.error('Socket error:', error);\n      this.connections--;\n      const index = this.sockets.indexOf(socket);\n      if (index > -1) {\n        this.sockets.splice(index, 1);\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        return reject(new Error('Server is already running'));\n      }\n      if (this.state === 'destroyed') {\n        return reject(new Error('Server has been destroyed'));\n      }\n      this.state = 'starting';\n      let server;\n      if (this.tlsEnabled) {\n        const credentials = {\n          key: fs.readFileSync(this.options.key),\n          cert: fs.readFileSync(this.options.cert),\n          ca: this.options.ca ? fs.readFileSync(this.options.ca) : undefined\n        };\n        server = tls.createServer(credentials, (socket) => {\n          this.handleConnection(socket);\n        });\n      } else {\n        server = net.createServer((socket) => {\n          this.handleConnection(socket);\n        });\n      }\n      server.listen(this.port, this.host, () => {\n        this.server = server;\n        this.state = 'running';\n        this.connections = server.connections;\n        resolve();\n      });\n      server.on('connection', (socket) => {\n        this.connections++;\n      });\n      server.on('close', () => {\n        this.state = 'stopped';\n        this.connections = 0;\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'destroyed') {\n        return reject(new Error('Server has already been destroyed'));\n      }\n      if (this.state === 'stopped') {\n        return reject(new Error('Server is already stopped'));\n      }\n      this.state = 'destroying';\n      this.server.close(() => {\n        this.server = null;\n        this.state = 'destroyed';\n        this.connections = 0;\n        this.sockets = [];\n        resolve();\n      });\n    });\n  }\n\n  handleConnection(socket) {\n    this.sockets.push(socket);\n    socket.on('end', () => {\n      this.connections--;\n      const index = this.sockets.indexOf(socket);\n      if (index !== -1) {\n        this.sockets.splice(index, 1);\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options = {}) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = options.tlsEnabled || false;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n    this.options = options.tlsEnabled ? {\n      key: fs.readFileSync(options.key),\n      cert: fs.readFileSync(options.cert),\n      ca: options.ca ? fs.readFileSync(options.ca) : undefined\n    } : {};\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'running') {\n        return reject(new Error('Server is already running'));\n      }\n      this.server = this.tlsEnabled ? tls.createServer(this.options, (socket) => {\n        this.handleConnection(socket);\n      }) : net.createServer((socket) => {\n        this.handleConnection(socket);\n      });\n\n      this.server.listen(this.port, this.host, () => {\n        this.state = 'running';\n        this.connections = 0;\n        this.sockets = [];\n        resolve();\n      });\n\n      this.server.on('connection', (socket) => {\n        this.connections++;\n        this.sockets.push(socket);\n      });\n\n      this.server.on('close', () => {\n        this.state = 'stopped';\n      });\n\n      this.server.on('error', (error) => {\n        reject(error);\n      });\n    });\n  }\n\n  destroy() {\n    return new Promise((resolve, reject) => {\n      if (this.state === 'destroyed') {\n        return reject(new Error('Server is already destroyed'));\n      }\n      if (this.state === 'running') {\n        this.server.close(() => {\n          this.state = 'stopped';\n          this.connections = 0;\n          this.sockets = [];\n          resolve();\n        });\n      } else {\n        this.state = 'destroyed';\n        resolve();\n      }\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      // Handle incoming data\n    });\n\n    socket.on('end', () => {\n      this.connections--;\n      const index = this.sockets.indexOf(socket);\n      if (index !== -1) {\n        this.sockets.splice(index, 1);\n      }\n    });\n\n    socket.on('error', (error) => {\n      // Handle socket error\n    });\n  }\n}\n```"
    ],
    "match_count": 2,
    "pass@3": 0.5333333333333333,
    "pass@5": 0.7777777777777778
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's 'net' module that can handle client connections, respond to incoming data, and manage server lifecycle events.\n\nClass Description: The Server class represents a TCP server that listens on a dynamically assigned port. It handles client connections, processes incoming data, and sends appropriate responses. The server can be started, stopped, and connections can be dropped.\n\nAttributes:\n- server: [Object] - The TCP server instance created using the 'net' module\n- socket: [Object] - The current client socket connection\n- response: [Buffer|Object] - The predefined response to send to clients (optional)\n\nMethods:\n- constructor(response) -> [Server] - Initializes a new Server instance with an optional response buffer/object\n- start(cb) -> [void] - Starts the server on a random available port and invokes the callback with connection details (host and port)\n- drop() -> [void] - Terminates the current client connection\n- close(cb) -> [void] - Stops the server and invokes the callback when complete",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = undefined;\n    this.socket = undefined;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server = net.createServer(\n      function(socket) {\n        this.socket = socket;\n        if (this.response) {\n          this.socket.on(\n            'data',\n            function(data) {\n              if (data.length == 8) {\n                this.socket.write(Buffer.from('N', 'utf8'));\n              } else if (!data[0]) {\n                this.socket.write(buffers.authenticationOk());\n              } else {\n                this.socket.write(this.response);\n              }\n            }.bind(this)\n          );\n        }\n      }.bind(this)\n    );\n\n    const host = 'localhost';\n    this.server.listen({ host, port: 0 }, () => {\n      const port = this.server.address().port;\n      cb({\n        host,\n        port,\n      });\n    });\n  }\n\n  drop() {\n    this.socket.destroy();\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    if (this.server) {\n      this.server.close(() => {\n        this.server = null;\n        cb();\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      this.socket = this.server.socket;\n      cb({ host: address, port });\n    });\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(() => {\n      cb();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n    this.server.close(cb);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(() => {\n      cb();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n    this.server.close(cb);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(() => {\n      cb();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(() => {\n      cb();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(() => {\n      cb();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(() => {\n      cb();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(response) {\n    this.server = net.createServer();\n    this.socket = null;\n    this.response = response;\n  }\n\n  start(cb) {\n    this.server.listen(() => {\n      const { address, port } = this.server.address();\n      cb({ host: address, port });\n    });\n    this.server.on('connection', (socket) => {\n      this.socket = socket;\n      socket.on('data', (data) => {\n        if (this.response) {\n          socket.write(this.response);\n        }\n      });\n    });\n  }\n\n  drop() {\n    if (this.socket) {\n      this.socket.destroy();\n      this.socket = null;\n    }\n  }\n\n  close(cb) {\n    this.server.close(() => {\n      cb();\n    });\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module to handle client connections, parse incoming JSON data streams, and manage server lifecycle events.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that listens on port 9999. It handles client connections by piping incoming data through a JSON stream parser. The server closes after processing a specified number of data events or when the parser emits an 'end' event. The function demonstrates basic TCP server setup, client connection handling, and event-driven server management.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function does not return a value but creates a running TCP server instance)",
    "Canonical_solution": "function createTCPServer() {\n    var net = require('net');\n    var server = net.createServer(function(client) {\n        var parser = JSONStream.parse([]);\n        parser.on('end', function() {\n            console.log('close');\n            console.error('PASSED');\n            server.close();\n        });\n        client.pipe(parser);\n        var n = 4;\n        client.on('data', function() {\n            if(--n) return;\n            client.end();\n        });\n    });\n    server.listen(9999);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\nconst { StringDecoder } = require('string_decoder');\n\nconst decoder = new StringDecoder('utf-8');\nlet dataEvents = 0;\nconst maxDataEvents = 5;\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (chunk) => {\n    const data = decoder.write(chunk);\n    if (data) {\n      try {\n        const parsedData = JSON.parse(data);\n        console.log(parsedData);\n        dataEvents++;\n        if (dataEvents >= maxDataEvents || data === 'end') {\n          socket.end();\n          server.close();\n        }\n      } catch (error) {\n        console.error('Invalid JSON:', error);\n        socket.end();\n        server.close();\n      }\n    }\n  });\n\n  socket.on('end', () => {\n    console.log('Client disconnected');\n    server.close();\n  });\n\n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n    server.close();\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n```",
      "const net = require('net');\nconst { Transform } = require('stream');\n\nfunction createTCPServer() {\n  const server = net.createServer();\n  let dataEvents = 0;\n  const maxDataEvents = 10;\n\n  server.on('connection', (socket) => {\n    const parser = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        try {\n          const data = JSON.parse(chunk.toString());\n          this.push(data);\n          dataEvents++;\n          if (dataEvents >= maxDataEvents || this.readableEnded) {\n            socket.end();\n          }\n        } catch (error) {\n          socket.end();\n        }\n        callback();\n      }\n    });\n\n    socket.pipe(parser);\n    parser.on('end', () => {\n      server.close();\n    });\n  });\n\n  server.listen(9999);\n}",
      "const net = require('net');\nconst { Transform } = require('stream');\n\nconst createTCPServer = () => {\n  const server = net.createServer();\n  const parser = new Transform({\n    readableObjectMode: true,\n    transform(chunk, encoding, callback) {\n      try {\n        const data = JSON.parse(chunk.toString());\n        this.push(data);\n        callback();\n      } catch (error) {\n        callback(error);\n      }\n    }\n  });\n\n  let dataEvents = 0;\n  const maxDataEvents = 10;\n\n  server.on('connection', (socket) => {\n    socket.pipe(parser);\n    parser.on('data', (data) => {\n      dataEvents++;\n      console.log('Received data:', data);\n      if (dataEvents >= maxDataEvents || parser.readableEnded) {\n        socket.end();\n        server.close();\n      }\n    });\n  });\n\n  server.listen(9999);\n};",
      "```javascript\nconst net = require('net');\nconst { StringDecoder } = require('string_decoder');\n\nconst decoder = new StringDecoder('utf-8');\nlet dataEvents = 0;\nconst maxDataEvents = 5;\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (chunk) => {\n    const data = decoder.write(chunk);\n    if (data) {\n      try {\n        const parsedData = JSON.parse(data);\n        console.log(parsedData);\n        dataEvents++;\n        if (dataEvents >= maxDataEvents || data === 'end') {\n          socket.end();\n        }\n      } catch (error) {\n        console.error('Error parsing JSON:', error);\n        socket.end();\n      }\n    }\n  });\n\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n\n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n```",
      "const net = require('net');\nconst { Transform } = require('stream');\n\nfunction createTCPServer() {\n  const server = net.createServer();\n  let dataEventsCount = 0;\n  const maxDataEvents = 10;\n\n  server.on('connection', (socket) => {\n    const parser = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        try {\n          const data = JSON.parse(chunk.toString());\n          this.push(data);\n          dataEventsCount++;\n          if (dataEventsCount >= maxDataEvents || data.end) {\n            socket.end();\n            server.close();\n          }\n        } catch (error) {\n          socket.end();\n          server.close();\n        }\n        callback();\n      }\n    });\n\n    socket.pipe(parser);\n    parser.on('end', () => {\n      socket.end();\n      server.close();\n    });\n  });\n\n  server.listen(9999);\n}",
      "```javascript\nconst net = require('net');\nconst { StringDecoder } = require('string_decoder');\n\nconst decoder = new StringDecoder('utf-8');\nlet dataEvents = 0;\nconst maxDataEvents = 5;\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (chunk) => {\n    const data = decoder.write(chunk);\n    if (data) {\n      try {\n        const parsedData = JSON.parse(data);\n        console.log(parsedData);\n        dataEvents++;\n        if (dataEvents >= maxDataEvents || data === 'end') {\n          socket.end();\n          server.close();\n        }\n      } catch (error) {\n        console.error('Invalid JSON:', error);\n        socket.end();\n        server.close();\n      }\n    }\n  });\n\n  socket.on('end', () => {\n    console.log('Client disconnected');\n    server.close();\n  });\n\n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n    server.close();\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n```",
      "```javascript\nconst net = require('net');\nconst { StringDecoder } = require('string_decoder');\n\nconst decoder = new StringDecoder('utf-8');\nlet dataEvents = 0;\nconst maxDataEvents = 5;\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (chunk) => {\n    const data = decoder.write(chunk);\n    if (data) {\n      try {\n        const parsedData = JSON.parse(data);\n        console.log(parsedData);\n        dataEvents++;\n        if (dataEvents >= maxDataEvents || data === 'end') {\n          socket.end();\n        }\n      } catch (error) {\n        console.error('Error parsing JSON:', error);\n        socket.end();\n      }\n    }\n  });\n\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n\n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n```",
      "```javascript\nconst net = require('net');\nconst { Transform } = require('stream');\n\nconst createTCPServer = () => {\n  const server = net.createServer();\n  let dataEvents = 0;\n  const maxDataEvents = 10;\n\n  server.on('connection', (socket) => {\n    const parser = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        try {\n          const data = JSON.parse(chunk.toString());\n          this.push(data);\n          dataEvents++;\n          if (dataEvents >= maxDataEvents || this.readableEnded) {\n            socket.end();\n          }\n        } catch (error) {\n          socket.end();\n        }\n        callback();\n      }\n    });\n\n    socket.pipe(parser);\n    parser.on('end', () => {\n      server.close();\n    });\n  });\n\n  server.listen(9999);\n};\n```",
      "```javascript\nconst net = require('net');\nconst { Transform } = require('stream');\n\nfunction createTCPServer() {\n  const server = net.createServer();\n  let dataEventsCount = 0;\n  const maxDataEvents = 10;\n\n  server.on('connection', (socket) => {\n    const parser = new Transform({\n      readableObjectMode: true,\n      transform(chunk, encoding, callback) {\n        try {\n          const data = JSON.parse(chunk.toString());\n          this.push(data);\n          dataEventsCount++;\n          if (dataEventsCount >= maxDataEvents || this.readableEnded) {\n            socket.end();\n          }\n        } catch (error) {\n          socket.end();\n        }\n        callback();\n      }\n    });\n\n    socket.pipe(parser);\n    parser.on('end', () => {\n      server.close();\n    });\n  });\n\n  server.listen(9999);\n}\n```",
      "const net = require('net');\nconst { Transform } = require('stream');\n\nfunction createTCPServer() {\n  const server = net.createServer();\n  const parser = new Transform({ readableObjectMode: true });\n  let dataEvents = 0;\n  const maxDataEvents = 10;\n\n  parser._transform = function(chunk, encoding, callback) {\n    try {\n      const data = JSON.parse(chunk.toString());\n      this.push(data);\n      dataEvents++;\n      if (dataEvents >= maxDataEvents || this.readableEnded) {\n        server.close();\n      }\n      callback();\n    } catch (error) {\n      callback(error);\n    }\n  };\n\n  server.on('connection', (socket) => {\n    socket.pipe(parser);\n    parser.on('end', () => {\n      server.close();\n    });\n  });\n\n  server.listen(9999);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 157,
    "Instruction": "Task Description: Create a TCP proxy server that handles client connections, processes incoming data, and responds with HTTP-formatted messages. The server should be able to start and stop dynamically, track whether it was called, and store received data.\n\nFunction Description: The function creates and manages a TCP proxy server instance. It handles client connections, processes incoming data in two phases (initial connection and subsequent data), and responds with predefined HTTP responses. The server tracks all received data and whether any client has connected to it.\n\nInput: None (The function takes no parameters but returns an object with methods that can be called)\n\nOutput: Returns an object with the following methods:\n- start(callback): Starts the server on a random available port and executes the callback when ready\n- stop(callback): Stops the server and executes the callback when complete\n- getData(): Returns all data received from clients\n- wasCalled(): Returns a boolean indicating whether the server received any client connections\n\nThe server responds to client connections with:\n1. Initial response: 'HTTP/1.1 200 OK\\r\\n\\r\\n'\n2. Subsequent response: 'HTTP/1.1 200 OK\\r\\ncontent-type: text/plain\\r\\ncontent-length: 5\\r\\n\\r\\nderp\\n'",
    "Canonical_solution": "function createProxyServer() {\n    var called = false;\n    var proxiedHost = 'google.com';\n    var data = '';\n\n    var s = require('net').createServer(function (sock) {\n        called = true;\n        sock.once('data', function (c) {\n            data += c;\n\n            sock.write('HTTP/1.1 200 OK\\r\\n\\r\\n');\n\n            sock.once('data', function (c) {\n                data += c;\n\n                sock.write('HTTP/1.1 200 OK\\r\\n');\n                sock.write('content-type: text/plain\\r\\n');\n                sock.write('content-length: 5\\r\\n');\n                sock.write('\\r\\n');\n                sock.end('derp\\n');\n            });\n        });\n    });\n\n    return {\n        start: function(callback) {\n            s.listen(0, function () {\n                s.url = 'http://localhost:' + this.address().port;\n                callback();\n            });\n        },\n        stop: function(callback) {\n            s.close(function () {\n                callback();\n            });\n        },\n        getData: function() {\n            return data;\n        },\n        wasCalled: function() {\n            return called;\n        }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.server_socket.settimeout(1)\n        self.was_called = True\n        threading.Thread(target=self.accept_connections).start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        callback()\n\n    def accept_connections(self):\n        while True:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.data_received.append(client_socket.recv(1024).decode())\n                client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n                client_socket.close()\n            except socket.timeout:\n                break\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```",
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.server_socket.settimeout(1)\n        self.was_called = True\n        threading.Thread(target=self.accept_connections).start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        callback()\n\n    def accept_connections(self):\n        while True:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.data_received.append(client_socket.recv(1024).decode())\n                client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n                client_socket.close()\n            except socket.timeout:\n                break\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```",
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.server_socket.settimeout(1)\n        self.was_called = True\n        threading.Thread(target=self.accept_connections, args=(callback,)).start()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        callback()\n\n    def accept_connections(self, callback):\n        try:\n            client_socket, client_address = self.server_socket.accept()\n            client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n            self.data_received.append(client_socket.recv(1024).decode())\n            client_socket.close()\n            callback()\n        except socket.timeout:\n            callback()\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```",
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.server_socket.settimeout(1)\n        self.was_called = True\n        threading.Thread(target=self.accept_connections).start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        callback()\n\n    def accept_connections(self):\n        while True:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.data_received.append(client_socket.recv(1024).decode())\n                client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n                threading.Thread(target=self.handle_client, args=(client_socket,)).start()\n            except socket.timeout:\n                continue\n\n    def handle_client(self, client_socket):\n        while True:\n            try:\n                data = client_socket.recv(1024).decode()\n                if not data:\n                    break\n                self.data_received.append(data)\n                client_socket.sendall(b'HTTP/1.1 200 OK\\r\\ncontent-type: text/plain\\r\\ncontent-length: 5\\r\\n\\r\\nderp\\n')\n            except Exception as e:\n                break\n        client_socket.close()\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```",
      "```python\nimport socket\nimport threading\nimport select\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.client_sockets = []\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(5)\n        self.server_socket.setblocking(0)\n        self.was_called = True\n        self.server_thread = threading.Thread(target=self.server_loop)\n        self.server_thread.start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        for client_socket in self.client_sockets:\n            client_socket.close()\n        self.server_thread.join()\n        callback()\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n\n    def server_loop(self):\n        while True:\n            readable, writable, exceptional = select.select([self.server_socket] + self.client_sockets, [], [])\n            for s in readable:\n                if s is self.server_socket:\n                    client_socket, client_address = s.accept()\n                    client_socket.setblocking(0)\n                    self.client_sockets.append(client_socket)\n                else:\n                    data = s.recv(1024)\n                    if data:\n                        self.data_received.append(data.decode())\n                        s.sendall(self.http_response().encode())\n                        self.client_sockets.remove(s)\n                        s.close()\n            for s in exceptional:\n                s.close()\n                self.client_sockets.remove(s)\n\n    def http_response(self):\n        if len(self.data_received) == 0:\n            return 'HTTP/1.1 200 OK\\r\\n\\r\\n'\n        else:\n            return 'HTTP/1.1 200 OK\\r\\ncontent-type: text/plain\\r\\ncontent-length: 5\\r\\n\\r\\nderp\\n'\n```",
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.was_called = True\n        self.server_thread = threading.Thread(target=self.server_loop)\n        self.server_thread.start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        self.server_thread.join()\n        callback()\n\n    def server_loop(self):\n        client_socket, client_address = self.server_socket.accept()\n        self.data_received.append(client_socket.recv(1024).decode())\n        client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n        while True:\n            data = client_socket.recv(1024).decode()\n            if not data:\n                break\n            self.data_received.append(data)\n            client_socket.sendall(b'HTTP/1.1 200 OK\\r\\ncontent-type: text/plain\\r\\ncontent-length: 5\\r\\n\\r\\nderp\\n')\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```",
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.server_socket.settimeout(1)\n        self.was_called = True\n        threading.Thread(target=self.accept_connections).start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        callback()\n\n    def accept_connections(self):\n        while True:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                threading.Thread(target=self.handle_client, args=(client_socket,)).start()\n            except socket.timeout:\n                continue\n\n    def handle_client(self, client_socket):\n        client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n        while True:\n            data = client_socket.recv(1024)\n            if not data:\n                break\n            self.data_received.append(data.decode())\n            client_socket.sendall(b'HTTP/1.1 200 OK\\r\\ncontent-type: text/plain\\r\\ncontent-length: 5\\r\\n\\r\\nderp\\n')\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```",
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.server_socket.settimeout(1)\n        self.was_called = True\n        threading.Thread(target=self.accept_connections).start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        callback()\n\n    def accept_connections(self):\n        while True:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                threading.Thread(target=self.handle_client, args=(client_socket,)).start()\n            except socket.timeout:\n                continue\n\n    def handle_client(self, client_socket):\n        client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n        while True:\n            data = client_socket.recv(1024)\n            if not data:\n                break\n            self.data_received.append(data.decode())\n            client_socket.sendall(b'HTTP/1.1 200 OK\\r\\ncontent-type: text/plain\\r\\ncontent-length: 5\\r\\n\\r\\nderp\\n')\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```",
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.server_socket.settimeout(1)\n        self.was_called = True\n        threading.Thread(target=self.accept_connections).start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        callback()\n\n    def accept_connections(self):\n        while True:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                self.data_received.append(client_socket.recv(1024).decode())\n                client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n                client_socket.close()\n            except socket.timeout:\n                break\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```",
      "```python\nimport socket\nimport threading\nimport random\n\nclass TCPProxyServer:\n    def __init__(self):\n        self.server_socket = None\n        self.data_received = []\n        self.was_called = False\n\n    def start(self, callback):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(('', 0))\n        self.server_socket.listen(1)\n        self.server_socket.settimeout(1)\n        self.was_called = True\n        threading.Thread(target=self.accept_connections).start()\n        callback()\n\n    def stop(self, callback):\n        self.server_socket.close()\n        callback()\n\n    def accept_connections(self):\n        while True:\n            try:\n                client_socket, client_address = self.server_socket.accept()\n                threading.Thread(target=self.handle_client, args=(client_socket,)).start()\n            except socket.timeout:\n                continue\n\n    def handle_client(self, client_socket):\n        client_socket.sendall(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n        while True:\n            data = client_socket.recv(1024)\n            if not data:\n                break\n            self.data_received.append(data.decode())\n            client_socket.sendall(b'HTTP/1.1 200 OK\\r\\ncontent-type: text/plain\\r\\ncontent-length: 5\\r\\n\\r\\nderp\\n')\n\n    def getData(self):\n        return self.data_received\n\n    def wasCalled(self):\n        return self.was_called\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module to handle client connections, data parsing, and server lifecycle events.\n\nClass Description: TcpReader is an EventEmitter-based class that manages a TCP server instance, handles client connections, processes incoming data through a custom parser, and manages server lifecycle events. It's designed to work within a transporter system for inter-process communication.\n\nAttributes:\n- server: [Object] - The TCP server instance created by the net module\n- opts: [Object] - Configuration options including port and maxPacketSize\n- transporter: [Object] - Reference to the parent transporter object\n- Promise: [Object] - Reference to the Promise implementation used by the transporter\n- logger: [Object] - Logger instance for logging events and errors\n- sockets: [Array] - Array of currently connected client sockets\n\nMethods:\n- listen() -> [Promise] - Starts the TCP server on the configured port and resolves with the actual port number when listening\n- onTcpClientConnected(socket: [Object]) -> [void] - Handles new client connections, sets up data parsing and error handling\n- closeSocket(socket: [Object]) -> [void] - Closes and removes a specific client socket\n- close() -> [void] - Stops the server and closes all client connections",
    "Canonical_solution": "const net = require(\"net\");\nconst EventEmitter = require(\"events\");\nconst Parser = require(\"./parser\");\n\nclass TcpReader extends EventEmitter {\n\tconstructor(transporter, opts) {\n\t\tsuper();\n\n\t\tthis.server = null;\n\t\tthis.opts = opts;\n\t\tthis.transporter = transporter;\n\t\tthis.Promise = transporter.broker.Promise;\n\t\tthis.logger = transporter.logger;\n\n\t\tthis.sockets = [];\n\t}\n\n\tlisten() {\n\t\treturn new this.Promise((resolve, reject) => {\n\t\t\tconst server = net.createServer(socket => this.onTcpClientConnected(socket));\n\n\t\t\tserver.on(\"error\", err => {\n\t\t\t\tthis.logger.error(\"Server error.\", err);\n\n\t\t\t\tif (reject) reject(err);\n\t\t\t});\n\n\t\t\tlet h = this.opts.port;\n\n\t\t\tif (process.versions.node.split(\".\")[0] >= 8)\n\t\t\t\th = { port: this.opts.port, exclusive: true };\n\n\t\t\tserver.listen(h, () => {\n\t\t\t\tthis.opts.port = this.server.address().port;\n\t\t\t\tthis.logger.info(`TCP server is listening on port ${this.opts.port}`);\n\t\t\t\tthis.connected = true;\n\n\t\t\t\tresolve(this.opts.port);\n\t\t\t\treject = null;\n\t\t\t});\n\n\t\t\tthis.server = server;\n\t\t});\n\t}\n\n\tonTcpClientConnected(socket) {\n\t\tthis.sockets.push(socket);\n\n\t\tsocket.setNoDelay(true);\n\n\t\tconst address = socket.remoteAddress;\n\t\tthis.logger.debug(`New TCP client connected from '${address}'`);\n\n\t\tconst parser = new Parser(undefined, this.opts.maxPacketSize);\n\t\tsocket.pipe(parser);\n\n\t\tparser.on(\"data\", (type, message) => {\n\t\t\tthis.transporter.onIncomingMessage(type, message, socket);\n\t\t});\n\n\t\tparser.on(\"error\", err => {\n\t\t\tthis.logger.warn(\"Packet parser error!\", err);\n\t\t\tthis.closeSocket(socket, err);\n\t\t});\n\n\t\tsocket.on(\"error\", err => {\n\t\t\tthis.logger.debug(`TCP client '${address}' error!`, err);\n\t\t\tthis.closeSocket(socket, err);\n\t\t});\n\n\t\tsocket.on(\"close\", hadError => {\n\t\t\tthis.logger.debug(`TCP client disconnected from '${address}'! Had error:`, !!hadError);\n\t\t\tthis.closeSocket(socket);\n\t\t});\n\n\t\tthis.emit(\"connect\", socket);\n\t}\n\n\tcloseSocket(socket) {\n\t\tsocket.destroy();\n\n\t\tthis.sockets.splice(this.sockets.indexOf(socket), 1);\n\t}\n\n\tclose() {\n\t\tif (this.server && this.server.listening) {\n\t\t\tthis.server.close();\n\n\t\t\tthis.sockets.forEach(socket => socket.destroy());\n\t\t\tthis.sockets = [];\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitters {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      this.processData(data);\n    });\n    socket.on('error', (err) => {\n      this.logger.error(`Socket error: ${err.message}`);\n      this.closeSocket(socket);\n    });\n    socket.on('close', () => {\n      this.closeSocket(socket);\n    });\n  }\n\n  processData(data) {\n    // Custom data parsing logic here\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n  }\n\n  close() {\n    this.server.close(() => {\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n      this.logger.log('Server closed');\n    });\n    this.server.on('close', () => {\n      this.logger.log('Server closed');\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitters {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.logger.log(`Received data: ${parsedData}`);\n        this.emit('data', parsedData);\n      } catch (error) {\n        this.logger.error(`Error parsing data: ${error}`);\n      }\n    });\n    socket.on('error', (error) => {\n      this.logger.error(`Socket error: ${error}`);\n      this.closeSocket(socket);\n    });\n    socket.on('close', () => {\n      this.logger.log('Socket closed');\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n      socket.destroy();\n    }\n  }\n\n  close() {\n    this.server.close(() => {\n      this.logger.log('Server closed');\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n    });\n    this.server.on('close', () => {\n      this.logger.log('Server closed');\n    });\n  }\n\n  parseData(data) {\n    // Custom data parsing logic\n    return data.toString();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitter {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.logger.log(`Received data: ${parsedData}`);\n        this.emit('data', parsedData);\n      } catch (error) {\n        this.logger.error(`Error parsing data: ${error}`);\n      }\n    });\n    socket.on('error', (error) => {\n      this.logger.error(`Socket error: ${error}`);\n      this.closeSocket(socket);\n    });\n    socket.on('close', () => {\n      this.logger.log('Socket closed');\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n  }\n\n  close() {\n    this.server.close(() => {\n      this.logger.log('Server closed');\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n    });\n    this.server.removeAllListeners();\n  }\n\n  parseData(data) {\n    // Custom data parsing logic goes here\n    return data.toString();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitter {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      // Custom parser logic here\n      this.logger.log('Data received:', data);\n    });\n    socket.on('error', (err) => {\n      this.logger.error('Socket error:', err);\n    });\n    socket.on('close', () => {\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n      socket.destroy();\n    }\n  }\n\n  close() {\n    this.server.close(() => {\n      this.sockets.forEach(socket => socket.destroy());\n      this.logger.log('Server closed and all sockets destroyed');\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitter {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = this.transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', (err) => {\n        this.logger.error(`Server error: ${err.message}`);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.logger.log(`Received data: ${parsedData}`);\n        this.emit('data', parsedData);\n      } catch (err) {\n        this.logger.error(`Error parsing data: ${err.message}`);\n      }\n    });\n    socket.on('error', (err) => {\n      this.logger.error(`Socket error: ${err.message}`);\n    });\n    socket.on('close', () => {\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n  }\n\n  close() {\n    this.server.close(() => {\n      this.logger.log('Server closed');\n    });\n    this.sockets.forEach((socket) => {\n      socket.destroy();\n    });\n  }\n\n  parseData(data) {\n    // Custom data parsing logic\n    return data.toString();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitter {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.logger.log(`Received data: ${parsedData}`);\n        this.emit('data', parsedData);\n      } catch (error) {\n        this.logger.error(`Error parsing data: ${error}`);\n      }\n    });\n    socket.on('error', (error) => {\n      this.logger.error(`Socket error: ${error}`);\n    });\n    socket.on('close', () => {\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n      socket.destroy();\n    }\n  }\n\n  close() {\n    this.server.close(() => {\n      this.logger.log('Server closed');\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n    });\n    this.server.removeAllListeners();\n  }\n\n  parseData(data) {\n    // Custom data parsing logic goes here\n    return data.toString();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitter {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.logger.log(`Received data: ${parsedData}`);\n        this.emit('data', parsedData);\n      } catch (error) {\n        this.logger.error(`Error parsing data: ${error}`);\n      }\n    });\n    socket.on('error', (error) => {\n      this.logger.error(`Socket error: ${error}`);\n      this.closeSocket(socket);\n    });\n    socket.on('close', () => {\n      this.logger.log('Socket closed');\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n  }\n\n  close() {\n    this.server.close(() => {\n      this.logger.log('Server closed');\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n    });\n    this.server.removeAllListeners();\n  }\n\n  parseData(data) {\n    // Custom data parsing logic goes here\n    return data.toString();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitters {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.logger.log(`Received data: ${parsedData}`);\n        this.emit('data', parsedData);\n      } catch (error) {\n        this.logger.error(`Error parsing data: ${error}`);\n      }\n    });\n    socket.on('error', (error) => {\n      this.logger.error(`Socket error: ${error}`);\n      this.closeSocket(socket);\n    });\n    socket.on('close', () => {\n      this.logger.log('Socket closed');\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n  }\n\n  close() {\n    this.server.close(() => {\n      this.logger.log('Server closed');\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n    });\n    this.server.removeAllListeners();\n  }\n\n  parseData(data) {\n    // Custom data parsing logic goes here\n    return data.toString();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitter {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.logger.log(`Received data: ${parsedData}`);\n        this.emit('data', parsedData);\n      } catch (error) {\n        this.logger.error(`Error parsing data: ${error}`);\n      }\n    });\n    socket.on('error', (error) => {\n      this.logger.error(`Socket error: ${error}`);\n      this.closeSocket(socket);\n    });\n    socket.on('close', () => {\n      this.logger.log('Socket closed');\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n      socket.destroy();\n    }\n  }\n\n  close() {\n    this.server.close(() => {\n      this.logger.log('Server closed');\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n    });\n    this.server.removeAllListeners();\n  }\n\n  parseData(data) {\n    // Custom data parsing logic goes here\n    return data.toString();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader extends EventEmitter {\n  constructor(opts, transporter, logger) {\n    super();\n    this.server = net.createServer();\n    this.opts = opts;\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = logger;\n    this.sockets = [];\n  }\n\n  listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server.listen(this.opts.port, () => {\n        this.logger.log(`Server listening on port ${this.server.address().port}`);\n        resolve(this.server.address().port);\n      });\n      this.server.on('error', reject);\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.logger.log(`Received data: ${parsedData}`);\n        this.emit('data', parsedData);\n      } catch (error) {\n        this.logger.error(`Error parsing data: ${error}`);\n      }\n    });\n    socket.on('error', (error) => {\n      this.logger.error(`Socket error: ${error}`);\n      this.closeSocket(socket);\n    });\n    socket.on('close', () => {\n      this.logger.log('Socket closed');\n      this.closeSocket(socket);\n    });\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n      socket.destroy();\n    }\n  }\n\n  close() {\n    this.server.close(() => {\n      this.logger.log('Server closed');\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n    });\n    this.server.removeAllListeners();\n  }\n\n  parseData(data) {\n    // Custom data parsing logic goes here\n    return data.toString();\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 159,
    "Instruction": "Task Description: Create a TCP server class that handles authentication requests for Git or SSH operations, generating dynamic listening paths and managing server lifecycle events.\n\nClass Description: The ResponseServer class is designed to create a TCP server that responds to authentication prompts from Git or SSH clients. It generates platform-specific listening paths, handles incoming connection requests, and provides appropriate authentication credentials based on the server type.\n\nAttributes:\n- auth: [Object] - Contains authentication credentials (username, password, passphrase)\n- serverType: [String] - Specifies the server type ('git' or 'ssh')\n\nMethods:\n- constructor(auth, serverType = 'git') -> [void] - Initializes the server with authentication credentials and server type\n- getListenPath() -> [String] - Generates a platform-specific listening path with a random component for security\n- start() -> [Promise<Object>] - Starts the TCP server and returns a promise that resolves to an object containing the listening path and a close method\n\nMethods Details:\n1. constructor(auth, serverType = 'git'):\n   - auth: [Object] - Authentication credentials object\n   - serverType: [String] - Type of server ('git' or 'ssh'), defaults to 'git'\n   - Returns: [void]\n\n2. getListenPath():\n   - Returns: [String] - Platform-specific listening path (Windows named pipe or Unix domain socket path)\n\n3. start():\n   - Returns: [Promise<Object>] - Resolves to an object with:\n     - path: [String] - The listening path\n     - close: [Function] - Method to close the server\n   - The promise may reject with an error if server startup fails",
    "Canonical_solution": "var net = require(\"net\");\nvar fs = require(\"fs-extra\");\nvar path = require(\"path\");\nvar os = require(\"os\");\nconst crypto = require(\"crypto\");\n\nclass ResponseServer {\n    constructor(auth, serverType = 'git') {\n        this.auth = auth;\n        this.serverType = serverType;\n    }\n\n    getListenPath() {\n        var seed = crypto.randomBytes(8).toString('hex');\n        var fn = 'node-red-git-askpass-'+seed+'-sock';\n        var listenPath;\n        if (process.platform === 'win32') {\n            listenPath = '\\\\\\\\.\\\\pipe\\\\'+fn;\n        } else {\n            listenPath = path.join(process.env['XDG_RUNTIME_DIR'] || os.tmpdir(), fn);\n        }\n        return listenPath;\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            var server = net.createServer((connection) => {\n                connection.setEncoding('utf8');\n                var parts = [];\n                connection.on('data', (data) => {\n                    var m = data.indexOf(\"\\n\");\n                    if (m !== -1) {\n                        parts.push(data.substring(0, m));\n                        data = data.substring(m);\n                        var line = parts.join(\"\");\n                        parts = [];\n                        if (this.serverType === 'git') {\n                            if (line === 'Username') {\n                                connection.end(this.auth.username);\n                            } else if (line === 'Password') {\n                                connection.end(this.auth.password);\n                                server.close();\n                            }\n                        } else if (this.serverType === 'ssh') {\n                            if (line === 'The') {\n                                connection.end('yes');\n                            } else if (line === 'Enter') {\n                                connection.end(this.auth.passphrase);\n                            }\n                        }\n                    }\n                    if (data.length > 0) {\n                        parts.push(data);\n                    }\n                });\n            });\n\n            var listenPath = this.getListenPath();\n\n            server.listen(listenPath, (ready) => {\n                resolve({\n                    path: listenPath,\n                    close: () => { server.close(); }\n                });\n            });\n\n            server.on('close', () => {\n                fs.removeSync(listenPath);\n            });\n\n            server.on('error', (err) => {\n                console.log(\"ResponseServer unexpectedError:\", err.toString());\n                server.close();\n                reject(err);\n            });\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'socket://{self._random_string(10)}'\n        else:\n            return f'socket://{self._random_string(10)}'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, 'localhost', 0)\n        await server.serve_forever()\n        return {'path': path, 'close': server.close}\n\n    async def handle_connection(self, reader, writer):\n        data = await reader.read(100)\n        print(f'received {data.decode()}')\n        writer.write(self.auth['username'].encode())\n        await writer.drain()\n        writer.close()\n\n    def _random_string(self, length):\n        letters = string.ascii_letters\n        return ''.join(random.choice(letters) for i in range(length))\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'\\\\\\\\.\\\\pipe\\\\{self.serverType}_auth_{random.choices(string.ascii_letters + string.digits, k=6)}'\n        else:\n            return f'/tmp/{self.serverType}_auth_{random.choices(string.ascii_letters + string.digits, k=6)}'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = socket.socket(socket.AF_UNIX if self.serverType == 'ssh' else socket.AF_INET, socket.SOCK_STREAM)\n        server.bind(path)\n        server.listen()\n        await asyncio.sleep(0)  # Allow the event loop to run\n        return {\n            'path': path,\n            'close': lambda: server.close()\n        }\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'\\\\\\\\.\\\\pipe\\\\git_auth_{self._generateRandomString()}'\n        else:\n            return f'/tmp/ssh_auth_{self._generateRandomString()}'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, 'localhost', 0)\n        await server.serve_forever()\n        return {\n            'path': path,\n            'close': lambda: server.close()\n        }\n\n    async def handle_connection(self, reader, writer):\n        data = await reader.read(100)\n        if data.decode().startswith('Authentication required'):\n            writer.write(f'Username: {self.auth[\"username\"]}\\nPassword: {self.auth[\"password\"]}\\n'.encode())\n            await writer.drain()\n        writer.close()\n\n    def _generateRandomString(self):\n        return ''.join(random.choices(string.ascii_letters + string.digits, k=8))\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'\\\\\\\\.\\\\pipe\\\\git_auth_{self._random_string(8)}'\n        else:\n            return f'/tmp/ssh_auth_{self._random_string(8)}'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, 'localhost', 0)\n        await server.serve_forever()\n        return {\n            'path': path,\n            'close': lambda: server.close()\n        }\n\n    async def handle_connection(self, reader, writer):\n        data = await reader.read(100)\n        if data.decode().startswith('Authentication required'):\n            writer.write(f'Username: {self.auth[\"username\"]}\\n'.encode())\n            writer.write(f'Password: {self.auth[\"password\"]}\\n'.encode())\n            await writer.drain()\n        writer.close()\n\n    def _random_string(self, length):\n        letters = string.ascii_letters\n        return ''.join(random.choice(letters) for i in range(length))\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'socket://{self._generateRandomString()}.sock'\n        else:\n            return f'socket://{self._generateRandomString()}.sock'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, 'localhost', 0)\n        await server.serve_forever()\n        return {'path': path, 'close': server.close}\n\n    async def handle_connection(self, reader, writer):\n        data = await reader.read(100)\n        if data.decode().startswith('Authentication required'):\n            writer.write(self._generateAuthResponse().encode())\n            await writer.drain()\n        writer.close()\n\n    def _generateRandomString(self):\n        return ''.join(random.choices(string.ascii_letters + string.digits, k=10))\n\n    def _generateAuthResponse(self):\n        return f'Username: {self.auth[\"username\"]}\\nPassword: {self.auth[\"password\"]}'\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'socket://{self._random_string(10)}.sock'\n        else:\n            return f'socket://{self._random_string(10)}.sock'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, 'localhost', 0)\n        await server.serve_forever()\n        return {'path': path, 'close': server.close}\n\n    async def handle_connection(self, reader, writer):\n        data = await reader.read(100)\n        if data.decode().startswith('Authentication required'):\n            writer.write(f'Username: {self.auth[\"username\"]}\\n'.encode())\n            writer.write(f'Password: {self.auth[\"password\"]}\\n'.encode())\n            await writer.drain()\n        writer.close()\n        await writer.wait_closed()\n\n    def _random_string(self, length):\n        letters = string.ascii_letters\n        return ''.join(random.choice(letters) for i in range(length))\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'socket://{self._generateRandomString(10)}'\n        else:\n            return f'socket://{self._generateRandomString(10)}'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, path)\n        await server.serve_forever()\n        return {'path': path, 'close': server.close}\n\n    async def handle_connection(self, reader, writer):\n        # Authentication logic here\n        pass\n\n    def _generateRandomString(self, length):\n        letters = string.ascii_letters\n        return ''.join(random.choice(letters) for i in range(length))\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'socket://{self._random_string(10)}.sock'\n        else:\n            return f'socket://{self._random_string(10)}.sock'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, 'localhost', 0)\n        await server.serve_forever()\n        return {\n            'path': path,\n            'close': lambda: server.close()\n        }\n\n    async def handle_connection(self, reader, writer):\n        data = await reader.read(100)\n        if data.decode().startswith('Authentication required'):\n            writer.write(f'Username: {self.auth[\"username\"]}\\n'.encode())\n            writer.write(f'Password: {self.auth[\"password\"]}\\n'.encode())\n            writer.write(f'Passphrase: {self.auth[\"passphrase\"]}\\n'.encode())\n            writer.write(b'Authentication successful\\n')\n        writer.close()\n\n    def _random_string(self, length):\n        letters = string.ascii_letters + string.digits\n        return ''.join(random.choice(letters) for i in range(length))\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'\\\\\\\\.\\\\pipe\\\\{self.serverType}_auth_{self._random_string(8)}'\n        else:\n            return f'/tmp/{self.serverType}_auth_{self._random_string(8)}'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, 'localhost', 0)\n        await server.serve_forever()\n        return {\n            'path': path,\n            'close': lambda: server.close()\n        }\n\n    async def handle_connection(self, reader, writer):\n        data = await reader.read(100)\n        if data.decode().startswith('Authentication required'):\n            writer.write(f'Username: {self.auth[\"username\"]}\\nPassword: {self.auth[\"password\"]}\\n'.encode())\n            await writer.drain()\n        writer.close()\n\n    def _random_string(self, length):\n        letters = string.ascii_letters\n        return ''.join(random.choice(letters) for i in range(length))\n```",
      "```python\nimport socket\nimport os\nimport random\nimport string\nimport asyncio\n\nclass ResponseServer:\n    def __init__(self, auth, serverType='git'):\n        self.auth = auth\n        self.serverType = serverType\n\n    def getListenPath(self):\n        if self.serverType == 'git':\n            return f'socket://{self._generateRandomString(10)}'\n        else:\n            return f'socket://{self._generateRandomString(10)}'\n\n    async def start(self):\n        path = self.getListenPath()\n        server = await asyncio.start_server(self.handle_connection, 'localhost', 0)\n        await server.serve_forever()\n        return {\n            'path': path,\n            'close': lambda: server.close()\n        }\n\n    async def handle_connection(self, reader, writer):\n        data = await reader.read(100)\n        message = data.decode()\n        if message.startswith('Authentication required'):\n            writer.write(f'Username: {self.auth[\"username\"]}\\n'.encode())\n            writer.write(f'Password: {self.auth[\"password\"]}\\n'.encode())\n            await writer.drain()\n        writer.close()\n\n    def _generateRandomString(self, length):\n        letters = string.ascii_letters\n        return ''.join(random.choice(letters) for i in range(length))\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport json\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        url = urljoin(url, f\"/{self.did}/{self.oaid}\")\n        headers = self.generateHeaders(method, body)\n        if method == 'get':\n            response = requests.get(url, headers=headers)\n        elif method == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            raise ValueError(\"Unsupported HTTP method\")\n        if response.status_code != 200:\n            raise Exception(f\"Request failed with status code {response.status_code}: {response.text}\")\n        return response.json()\n\n    def generateHeaders(self, method, body):\n        timestamp = str(int(time.time()))\n        signature = self.generateSignature(method, timestamp, body)\n        headers = {\n            'Authorization': f'Bearer {self.token}',\n            'Fingerprint': self.finger,\n            'Timestamp': timestamp,\n            'Signature': signature\n        }\n        return headers\n\n    def generateSignature(self, method, timestamp, body):\n        data = f\"{method}\\n{timestamp}\\n{body}\"\n        signature = hmac.new(self.token.encode(), data.encode(), hashlib.sha256).digest()\n        return base64.b64encode(signature).decode()\n```",
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport time\nfrom urllib.parse import quote_plus\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        url = quote_plus(url)\n        timestamp = str(int(time.time()))\n        signature = self.generateSignature(method, url, timestamp, body)\n        headers = self.generateHeaders(timestamp, signature)\n        if method.lower() == 'get':\n            response = requests.get(url, headers=headers)\n        elif method.lower() == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            raise ValueError(\"Unsupported HTTP method\")\n        if response.status_code != 200:\n            raise Exception(f\"Request failed with status code {response.status_code}: {response.text}\")\n        return response.json()\n\n    def generateSignature(self, method, url, timestamp, body):\n        string_to_sign = f\"{method}\\n{url}\\n{timestamp}\\n{body}\"\n        signature_key = f\"{self.token}:{self.finger}\"\n        signature = hmac.new(base64.b64decode(signature_key), string_to_sign.encode(), hashlib.sha256).digest()\n        return base64.b64encode(signature).decode()\n\n    def generateHeaders(self, timestamp, signature):\n        return {\n            'Content-Type': 'application/json',\n            'Authorization': f'DID {self.did}, Finger {self.finger}, Timestamp {timestamp}, Signature {signature}, OAID {self.oaid}'\n        }\n```",
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport json\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        url = urljoin(url, f\"/{self.did}/{self.oaid}\")\n        headers = self.generateHeaders(method, body)\n        if method == 'get':\n            response = requests.get(url, headers=headers)\n        elif method == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            raise ValueError(\"Unsupported HTTP method\")\n        if response.status_code != 200:\n            raise Exception(f\"Request failed with status code {response.status_code}: {response.text}\")\n        return response.json()\n\n    def generateHeaders(self, method, body):\n        timestamp = str(int(time.time()))\n        signature = self.generateSignature(method, timestamp, body)\n        headers = {\n            'Content-Type': 'application/json',\n            'Authorization': f'Bearer {self.token}',\n            'X-Signature': signature,\n            'X-Timestamp': timestamp\n        }\n        return headers\n\n    def generateSignature(self, method, timestamp, body):\n        data = f\"{method}\\n{timestamp}\\n{body}\"\n        signature = hmac.new(self.finger.encode(), data.encode(), hashlib.sha256).digest()\n        return base64.b64encode(signature).decode()\n```",
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport json\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        url = urljoin(url, f'/api/v1/{self.did}')\n        headers = self.generateHeaders(method, body)\n        if method == 'get':\n            response = requests.get(url, headers=headers)\n        elif method == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            raise ValueError('Unsupported HTTP method')\n        if response.status_code != 200:\n            raise Exception(f'Request failed with status code {response.status_code}: {response.text}')\n        return response.json()\n\n    def generateHeaders(self, method, body):\n        timestamp = str(int(time.time()))\n        signature = self.generateSignature(method, body, timestamp)\n        headers = {\n            'Authorization': f'Bearer {self.token}',\n            'Fingerprint': self.finger,\n            'Timestamp': timestamp,\n            'Signature': signature\n        }\n        return headers\n\n    def generateSignature(self, method, body, timestamp):\n        payload = f'{method}\\n{timestamp}\\n{body}'\n        signature = hmac.new(self.token.encode(), payload.encode(), hashlib.sha256).digest()\n        return base64.urlsafe_b64encode(signature).decode()\n```",
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport time\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        url = urljoin(url, f'/api/v1/{self.did}')\n        timestamp = str(int(time.time()))\n        nonce = str(int(time.time() * 1000))\n        signature = self.generateSignature(method, url, body, timestamp, nonce)\n        headers = {\n            'Content-Type': 'application/json',\n            'Authorization': f'Bearer {self.token}',\n            'X-DID': self.did,\n            'X-Finger': self.finger,\n            'X-Timestamp': timestamp,\n            'X-Nonce': nonce,\n            'X-Signature': signature\n        }\n        if method == 'get':\n            response = requests.get(url, headers=headers)\n        elif method == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            raise ValueError('Unsupported HTTP method')\n        if response.status_code != 200:\n            raise Exception(f'Request failed with status code {response.status_code}: {response.text}')\n        return response.json()\n\n    def generateSignature(self, method, url, body, timestamp, nonce):\n        payload = f'{method}\\n{url}\\n{body}\\n{timestamp}\\n{nonce}'\n        signature_key = f'{self.token}{self.finger}'\n        signature = hmac.new(base64.b64decode(signature_key), payload.encode(), hashlib.sha256).digest()\n        return base64.b64encode(signature).decode()\n```",
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport json\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        url = urljoin(url, f'/api/v1/{self.did}')\n        headers = self.generateHeaders(method, body)\n        if method == 'get':\n            response = requests.get(url, headers=headers)\n        elif method == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            raise ValueError('Unsupported HTTP method')\n        if response.status_code != 200:\n            raise Exception(f'Request failed with status code {response.status_code}: {response.text}')\n        return response.json()\n\n    def generateHeaders(self, method, body):\n        timestamp = str(int(time.time()))\n        signature = self.generateSignature(method, timestamp, body)\n        headers = {\n            'Authorization': f'Bearer {self.token}',\n            'Fingerprint': self.finger,\n            'Timestamp': timestamp,\n            'Signature': signature\n        }\n        return headers\n\n    def generateSignature(self, method, timestamp, body):\n        message = f'{method}\\n{timestamp}\\n{body}'\n        signature = hmac.new(self.token.encode(), message.encode(), hashlib.sha256).digest()\n        return base64.urlsafe_b64encode(signature).decode()\n```",
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport json\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        url = urljoin(url, f\"/{self.did}/{self.oaid}\")\n        headers = self.generateHeaders(method, body)\n        if method == 'get':\n            response = requests.get(url, headers=headers)\n        elif method == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            raise ValueError(\"Unsupported HTTP method\")\n        if response.status_code != 200:\n            raise Exception(f\"Request failed with status code {response.status_code}: {response.text}\")\n        return response.json()\n\n    def generateHeaders(self, method, body):\n        timestamp = str(int(time.time()))\n        signature = self.generateSignature(method, timestamp, body)\n        headers = {\n            'Authorization': f'Bearer {self.token}',\n            'Fingerprint': self.finger,\n            'Timestamp': timestamp,\n            'Signature': signature\n        }\n        return headers\n\n    def generateSignature(self, method, timestamp, body):\n        message = f\"{method}\\n{timestamp}\\n{body}\"\n        signature = hmac.new(self.token.encode(), message.encode(), hashlib.sha256).digest()\n        return base64.urlsafe_b64encode(signature).decode()\n```",
      "```python\nimport requests\nimport hmac\nimport hashlib\nimport base64\nimport json\nfrom urllib.parse import quote\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def generate_signature(self, method, url, body):\n        timestamp = str(int(time.time()))\n        string_to_sign = f\"{method}\\n{url}\\n{timestamp}\\n{body}\"\n        signature_key = f\"{self.token}\"\n        signature = hmac.new(signature_key.encode(), string_to_sign.encode(), hashlib.sha256).digest()\n        encoded_signature = base64.b64encode(signature).decode()\n        return encoded_signature, timestamp\n\n    def taskRequest(self, method, url, body=''):\n        method = method.lower()\n        headers = {\n            'Authorization': f'Bearer {self.token}',\n            'Device-ID': self.did,\n            'Fingerprint': self.finger,\n            'OAID': self.oaid,\n            'Content-Type': 'application/json'\n        }\n        encoded_body = json.dumps(body) if body else ''\n        signature, timestamp = self.generate_signature(method, url, encoded_body)\n        headers['Signature'] = f\"{signature}\"\n        headers['Timestamp'] = f\"{timestamp}\"\n        try:\n            if method == 'get':\n                response = requests.get(url, headers=headers)\n            elif method == 'post':\n                response = requests.post(url, headers=headers, data=encoded_body)\n            else:\n                raise ValueError(\"Unsupported HTTP method\")\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            raise Exception(f\"Request failed: {str(e)}\")\n```",
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport json\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        url = urljoin(url, f\"/{self.did}/{self.oaid}\")\n        headers = self.generateHeaders(method, body)\n        if method == 'get':\n            response = requests.get(url, headers=headers)\n        elif method == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            raise ValueError(\"Unsupported HTTP method\")\n        if response.status_code != 200:\n            raise Exception(f\"Request failed with status code {response.status_code}: {response.text}\")\n        return response.json()\n\n    def generateHeaders(self, method, body):\n        timestamp = str(int(time.time()))\n        signature = self.generateSignature(method, timestamp, body)\n        headers = {\n            'Content-Type': 'application/json',\n            'Authorization': f'Bearer {self.token}',\n            'X-Signature': signature,\n            'X-Timestamp': timestamp\n        }\n        return headers\n\n    def generateSignature(self, method, timestamp, body):\n        data = f\"{method}\\n{timestamp}\\n{body}\"\n        signature = hmac.new(self.finger.encode(), data.encode(), hashlib.sha256).digest()\n        return base64.b64encode(signature).decode()\n```",
      "```python\nimport requests\nimport hashlib\nimport hmac\nimport base64\nimport json\n\nclass TaskRequest:\n    def __init__(self, did, finger, token, oaid):\n        self.did = did\n        self.finger = finger\n        self.token = token\n        self.oaid = oaid\n\n    def taskRequest(self, method, url, body=''):\n        if method.lower() not in ['get', 'post']:\n            raise ValueError(\"Invalid HTTP method. Only 'get' and 'post' are supported.\")\n        \n        headers = self.generateHeaders(method, url, body)\n        if method.lower() == 'post':\n            response = requests.post(url, headers=headers, data=body)\n        else:\n            response = requests.get(url, headers=headers)\n        \n        if response.status_code != 200:\n            raise Exception(f\"Request failed with status code {response.status_code}: {response.text}\")\n        \n        return response.json()\n\n    def generateHeaders(self, method, url, body):\n        timestamp = str(int(time.time()))\n        signature = self.generateSignature(method, url, body, timestamp)\n        headers = {\n            'Authorization': f'Bearer {self.token}',\n            'X-DID': self.did,\n            'X-Finger': self.finger,\n            'X-OAID': self.oaid,\n            'X-Signature': signature,\n            'X-Timestamp': timestamp\n        }\n        return headers\n\n    def generateSignature(self, method, url, body, timestamp):\n        string_to_sign = f\"{method}\\n{url}\\n{body}\\n{timestamp}\\n{self.token}\"\n        signature = hmac.new(self.token.encode(), string_to_sign.encode(), hashlib.sha256).digest()\n        return base64.b64encode(signature).decode()\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 160,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module that listens on an available port and discards any incoming data.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that automatically binds to an available port. It discards any incoming data to ensure the server can terminate properly. The server's port is stored in the instance for later reference.\n\nInput: None\n\nOutput: None (The function modifies the instance properties, specifically setting `this.server` and `this.port`)",
    "Canonical_solution": "function createTCPServer() {\n  const net = require('net');\n  this.server = net.createServer((socket) => {\n    socket.on('data', () => {\n      // discard any buffered data or the server wont terminate\n    });\n  });\n  this.server.listen(() => {\n    this.port = this.server.address().port;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.end();\n});\nserver.listen(() => {\n  this.port = server.address().port;\n  this.server = server;\n});",
      "const net = require('net');\nconst server = net.createServer();\nserver.on('connection', (socket) => {\n  socket.on('data', () => {});\n});\nserver.listen(() => {\n  this.port = server.address().port;\n  this.server = server;\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.end();\n});\nserver.listen(() => {\n  this.port = server.address().port;\n  this.server = server;\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.end();\n});\nserver.listen(() => {\n  this.port = server.address().port;\n  this.server = server;\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.end();\n});\nserver.listen(() => {\n  this.port = server.address().port;\n  this.server = server;\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.end();\n});\nserver.listen(() => {\n  this.port = server.address().port;\n  this.server = server;\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.end();\n});\nserver.listen(() => {\n  this.port = server.address().port;\n  this.server = server;\n});"
    ],
    "unmatched_results": [
      "const net = require('net');\nconst server = net.createServer();\nserver.listen(() => {\n  this.port = server.address().port;\n});\nserver.on('data', () => {});\nserver.on('end', () => server.close());\nserver.on('close', () => {\n  this.server = null;\n});",
      "const net = require('net');\nconst server = net.createServer();\nlet port;\n\nserver.listen(() => {\n  port = server.address().port;\n});\n\nserver.on('data', () => {});\n\nserver.on('error', (err) => {\n  console.error('Server error:', err);\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n\nmodule.exports = {\n  createTCPServer: function() {\n    return {\n      server: server,\n      port: port\n    };\n  }\n};",
      "const net = require('net');\nconst server = net.createServer();\nserver.listen(() => {\n  this.port = server.address().port;\n});\nserver.on('data', () => {});\nserver.on('end', () => server.close());\nserver.on('close', () => {\n  this.server = null;\n});"
    ],
    "match_count": 7,
    "pass@3": 0.9916666666666667,
    "pass@5": 1.0
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a TCP server in Node.js that handles client connections, processes incoming data in batches, and forwards each batch to an external service for processing.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that listens on port 5000. When a client connects, it sets up a bidirectional communication channel where incoming data from the client is collected in batches (separated by '.'). Each complete batch is then sent to an external 'uppercase' service via a REQ socket. The server handles data streaming and batch processing efficiently.\n\nInput: None (The function takes no parameters; configuration is hardcoded)\n\nOutput: None (The function creates a server instance that runs indefinitely, listening for connections)\n\n---\n\nIf you'd prefer the class format (though the reference code is function-based):\n\nTask Description: Implement a TCP server class in Node.js that manages client connections and batch processing of incoming data.\n\nClass Description: The `TCPServer` class encapsulates a TCP server that listens for client connections, collects incoming data in batches, and forwards complete batches to an external service.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- port: [number] - The port number the server listens on (default: 5000)\n\nMethods:\n- constructor([port: number]) -> void - Initializes the server with optional port configuration\n- start() -> void - Starts the server and begins listening for connections\n- handleConnection(conn: net.Socket) -> void - Internal method to manage client connections and data processing\n- processBatch(batch: string[]) -> void - Sends a complete batch to the external service",
    "Canonical_solution": "function createTCPServer() {\n    var server = require('net').createServer();\n    server.on('connection', function(conn) {\n        conn.setEncoding('utf8');\n        \n        var req = context.socket('REQ');\n        req.setEncoding('utf8');\n        req.pipe(conn);\n        req.connect('uppercase');\n        \n        var batch = [];\n        var ask = function (q) {\n            req.write(q, 'utf8');\n        }\n        function readBatch() {\n            var msg; while (msg = conn.read()) {\n                msg.split('\\n').forEach(function(item) {\n                    if (item == '.') {\n                        console.log('Sending batch %s', batch);\n                        batch.forEach(ask);\n                        batch = [];\n                    }\n                    else if (item != '') {\n                        batch.push(item);\n                    }\n                });\n            }\n        }\n        conn.on('readable', readBatch);\n        readBatch();\n    });\n    server.listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\nconst { createSocket } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (conn) => {\n      this.handleConnection(conn);\n    });\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      for (let i = 0; i < batches.length - 1; i++) {\n        const batch = batches[i];\n        if (batch) {\n          this.processBatch(batch.split(''));\n          buffer = batches[batches.length - 1];\n        }\n      }\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n  }\n\n  processBatch(batch) {\n    const uppercaseSocket = createSocket('udp4');\n    uppercaseSocket.send(batch.join(''), 0, batch.join('').length, 5000, 'localhost', () => {\n      uppercaseSocket.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { createSocket } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', this.handleConnection.bind(this));\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      buffer = batches.pop();\n\n      batches.forEach((batch) => {\n        if (batch) {\n          this.processBatch(batch.split(''));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n  }\n\n  processBatch(batch) {\n    const socket = createSocket('udp4');\n    socket.send(batch.join(''), 0, batch.length, 5000, 'localhost', () => {\n      socket.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { Socket } = net;\nconst { connect } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (conn) => {\n      this.handleConnection(conn);\n    });\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      for (let i = 0; i < batches.length - 1; i++) {\n        if (batches[i].trim() !== '') {\n          this.processBatch(batches.slice(0, i + 1));\n        }\n      }\n      buffer = batches[batches.length - 1];\n    });\n\n    conn.on('end', () => {\n      if (buffer.trim() !== '') {\n        this.processBatch([buffer]);\n      }\n    });\n  }\n\n  processBatch(batch) {\n    const uppercaseService = connect({ port: 12345, family: 'IPv4' });\n    uppercaseService.send(batch.join('.').toString(), (err) => {\n      if (err) {\n        console.error('Failed to send batch to uppercase service:', err);\n      }\n    });\n    uppercaseService.close();\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { createSocket } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', this.handleConnection.bind(this));\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      buffer = batches.pop(); // Keep the last incomplete batch\n\n      batches.forEach((batch) => {\n        if (batch) {\n          this.processBatch(batch.split(''));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n  }\n\n  processBatch(batch) {\n    const socket = createSocket('udp4');\n    const message = JSON.stringify(batch);\n    const uppercaseServiceAddress = '127.0.0.1';\n    const uppercaseServicePort = 12345;\n\n    socket.send(message, 0, message.length, uppercaseServicePort, uppercaseServiceAddress, (err) => {\n      if (err) {\n        console.error('Error sending batch to uppercase service:', err);\n      } else {\n        console.log('Batch sent to uppercase service');\n      }\n      socket.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { Socket } = net;\nconst { connect } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (conn) => {\n      this.handleConnection(conn);\n    });\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      buffer = batches.pop();\n      batches.forEach((batch) => {\n        if (batch) {\n          this.processBatch(batch.split(''));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n\n    conn.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n  }\n\n  processBatch(batch) {\n    const uppercaseService = connect({ port: 12345, family: 'IPv4' });\n    uppercaseService.send(batch.join(''), 0, batch.length, 0, 'localhost', (err) => {\n      if (err) {\n        console.error('Error sending batch to uppercase service:', err);\n      } else {\n        console.log('Batch processed successfully');\n      }\n      uppercaseService.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { Socket } = net;\nconst { connect } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (conn) => {\n      this.handleConnection(conn);\n    });\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      buffer = batches.pop();\n      batches.forEach((batch) => {\n        if (batch) {\n          this.processBatch(batch.split(''));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n  }\n\n  processBatch(batch) {\n    const uppercaseSocket = connect(12345, 'localhost');\n    uppercaseSocket.send(batch.join(''), 0, batch.length, 0, 'localhost', (err) => {\n      if (err) {\n        console.error('Error sending batch to external service:', err);\n      } else {\n        console.log('Batch sent to external service');\n      }\n      uppercaseSocket.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { Socket } = net;\nconst { connect } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (conn) => {\n      this.handleConnection(conn);\n    });\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      buffer = batches.pop();\n      batches.forEach((batch) => {\n        if (batch) {\n          this.processBatch(batch.split(''));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n\n    conn.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n  }\n\n  processBatch(batch) {\n    const uppercaseService = connect({ port: 12345, family: 'IPv4' });\n    uppercaseService.send(batch.join(''), 0, batch.length, 0, 'localhost', (err) => {\n      if (err) {\n        console.error('Failed to send batch to uppercase service:', err);\n      } else {\n        console.log('Batch sent to uppercase service');\n      }\n      uppercaseService.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { createSocket } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', this.handleConnection.bind(this));\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      buffer = batches.pop();\n\n      batches.forEach((batch) => {\n        if (batch) {\n          this.processBatch(batch.split(''));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n  }\n\n  processBatch(batch) {\n    const socket = createSocket('udp4');\n    socket.send(batch.join(''), 0, batch.length, 5000, 'localhost', () => {\n      socket.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { Socket } = net;\nconst { connect } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (conn) => {\n      this.handleConnection(conn);\n    });\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      buffer = batches.pop();\n      batches.forEach((batch) => {\n        if (batch) {\n          this.processBatch(batch.split(''));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n\n    conn.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n  }\n\n  processBatch(batch) {\n    const uppercaseService = connect({ port: 12345, family: 'IPv4' });\n    uppercaseService.send(batch.join(''), 0, batch.length, 0, 'localhost', (err) => {\n      if (err) {\n        console.error('Error sending batch to uppercase service:', err);\n      } else {\n        console.log('Batch sent to uppercase service');\n      }\n      uppercaseService.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```",
      "```javascript\nconst net = require('net');\nconst { Socket } = net;\nconst { connect } = require('dgram');\n\nclass TCPServer {\n  constructor(port = 5000) {\n    this.server = net.createServer();\n    this.port = port;\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`Server listening on port ${this.port}`);\n    });\n\n    this.server.on('connection', (conn) => {\n      this.handleConnection(conn);\n    });\n  }\n\n  handleConnection(conn) {\n    let buffer = '';\n    conn.on('data', (data) => {\n      buffer += data.toString();\n      const batches = buffer.split('.');\n      buffer = batches.pop();\n      batches.forEach((batch) => {\n        if (batch) {\n          this.processBatch(batch.split(''));\n        }\n      });\n    });\n\n    conn.on('end', () => {\n      if (buffer) {\n        this.processBatch(buffer.split(''));\n      }\n    });\n\n    conn.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n  }\n\n  processBatch(batch) {\n    const uppercaseService = connect({ port: 12345, family: 'IPv4' });\n    uppercaseService.send(batch.join(''), 0, batch.join('').length, 0, 'localhost', (err) => {\n      if (err) {\n        console.error('Failed to send batch to uppercase service:', err);\n      } else {\n        console.log('Batch sent to uppercase service');\n      }\n      uppercaseService.close();\n    });\n  }\n}\n\nconst server = new TCPServer();\nserver.start();\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a POP3 server class in Node.js that handles secure and non-secure connections, manages client connections, and provides event-driven communication.\n\nClass Description: The POP3Server class extends EventEmitter to create a TCP server that can handle both regular and TLS-secured POP3 connections. It manages client connections and emits events for server lifecycle and errors.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- connections: [Set] - Tracks active client connections\n- server: [net.Server|tls.Server] - The underlying TCP/TLS server instance\n\nMethods:\n- constructor(options) -> [void] - Initializes the server with optional configuration\n- _setListeners() -> [void] - Sets up event listeners for the server\n- _onListening() -> [void] - Handles the 'listening' event\n- _onClose() -> [void] - Handles the 'close' event\n- _onError(err) -> [void] - Handles the 'error' event\n- connect(socket, socketOptions) -> [void] - Creates and manages a new client connection\n- listen(...args) -> [void] - Starts the server listening on specified port\n- close(callback) -> [void] - Stops the server and invokes callback when closed",
    "Canonical_solution": "const EventEmitter = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass POP3Server extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.options = options || {};\n        this.connections = new Set();\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    this.connect(socket, socketOptions);\n                });\n            });\n        }\n\n        this._setListeners();\n    }\n\n    _setListeners() {\n        this.server.on('listening', () => this._onListening());\n        this.server.on('close', () => this._onClose());\n        this.server.on('error', err => this._onError(err));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new POP3Connection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.once('error', err => {\n            this.connections.delete(connection);\n            this._onError(err);\n        });\n        connection.once('close', () => {\n            this.connections.delete(connection);\n        });\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            if (typeof callback === 'function') {\n                return callback();\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing client connections\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    // Implementation for creating and managing a new client connection\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => {\n        this.connect(socket, this.options);\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, this.options);\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Create a TCP server in Node.js that serves Flash cross-domain policy files to clients, handling connections, errors, and policy file generation dynamically.\n\nClass Description: The Server class implements a TCP server that listens for Flash policy file requests and responds with an appropriate cross-domain policy XML. It handles server lifecycle events, client connections, and dynamic policy configuration.\n\nAttributes:\n- origins: [Array] - List of allowed domains and ports in \"domain:port\" format\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [net.Server] - The TCP server instance\n- server: [Object] - Optional fallback HTTP server\n- buffer: [Buffer] - Compiled policy file in binary format\n\nMethods:\n- constructor(options, origins) -> [Server] - Initializes the server with configuration options and allowed origins\n- listen(port, server, cb) -> [Server] - Starts listening on specified port, with optional fallback server and callback\n- responder(socket) -> [void] - Responds to client connections with policy file\n- compile() -> [Server] - Generates the policy file XML and converts it to buffer\n- add() -> [Server] - Adds one or more allowed origins to the policy\n- remove(origin) -> [Server] - Removes a specific origin from the policy\n- close() -> [Server] - Closes the server and cleans up resources",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => {\n        this.responder.call(this, socket);\n      });\n      this.responder.call(this, socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges. ' +\n          (\n            this.server\n            ? 'The Flash Policy File requests will only be served inline over the supplied HTTP server. Inline serving is slower than a dedicated server instance.'\n            : 'No fallback server supplied, we will be unable to answer Flash Policy File requests.'\n          )\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n      if (this.server && this.server['@'] && this.server.online) {\n        this.server.removeListener('connection', this.server['@']);\n      }\n      delete this.server?.online;\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (\n            data &&\n            data[0] === 60 &&\n            data.toString() === '<policy-file-request/>\\0' &&\n            socket &&\n            (socket.readyState === 'open' || socket.readyState === 'writeOnly')\n          ) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    if (this.port >= 0) {\n      this.socket.listen(this.port, () => {\n        this.socket.online = true;\n        callback?.call(this);\n      });\n    }\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = Buffer.from(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      this.log('Server error:', err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb();\n        });\n      } else {\n        cb();\n      }\n    });\n  }\n\n  responder(socket) {\n    let data = '';\n    socket.on('data', (chunk) => {\n      data += chunk.toString();\n    });\n\n    socket.on('end', () => {\n      const request = data.split('\\n')[0];\n      const origin = request.split('/')[2];\n      if (this.origins.includes(origin)) {\n        socket.write(this.buffer);\n      } else {\n        socket.write('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>');\n      }\n      socket.end();\n    });\n  }\n\n  compile() {\n    const xml = `<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>`;\n    this.buffer = Buffer.from(xml);\n  }\n\n  add(...origins) {\n    origins.forEach((origin) => {\n      this.origins.push(origin);\n    });\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(() => {\n        this.log('Server closed');\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      this.log('Server error:', err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb(null, this);\n        });\n      } else {\n        cb(null, this);\n      }\n    });\n  }\n\n  responder(socket) {\n    let data = '';\n    socket.on('data', (chunk) => {\n      data += chunk.toString();\n    });\n\n    socket.on('end', () => {\n      const request = data.split('\\n')[0];\n      const origin = request.split('/')[2];\n      if (this.origins.includes(origin)) {\n        socket.write(this.buffer);\n      } else {\n        socket.write('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>');\n      }\n      socket.end();\n    });\n  }\n\n  compile() {\n    const xml = `<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>`;\n    this.buffer = Buffer.from(xml);\n  }\n\n  add(origin) {\n    this.origins.push(origin);\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      this.log('Server error:', err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb(null, this);\n        });\n      } else {\n        cb(null, this);\n      }\n    });\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      const request = data.toString();\n      const response = this.compile();\n      socket.write(response);\n    });\n\n    socket.on('end', () => {\n      socket.destroy();\n    });\n  }\n\n  compile() {\n    let xml = '<?xml version=\"1.0\"?>\\n<cross-domain-policy>\\n';\n    xml += '<allow-access-from domain=\"*\" secure=\"false\"/>\\n';\n    this.origins.forEach((origin) => {\n      xml += `<allow-access-from domain=\"${origin}\" secure=\"false\" />\\n`;\n    });\n    xml += '</cross-domain-policy>';\n    this.buffer = Buffer.from(xml);\n    return this.buffer;\n  }\n\n  add(origin) {\n    if (!this.origins.includes(origin)) {\n      this.origins.push(origin);\n      this.compile();\n    }\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(() => {\n        this.log('Server closed');\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      this.log('Server error:', err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb();\n        });\n      } else {\n        cb();\n      }\n    });\n  }\n\n  responder(socket) {\n    let data = '';\n    socket.on('data', (chunk) => {\n      data += chunk.toString();\n    });\n\n    socket.on('end', () => {\n      const request = data.split('\\n')[0];\n      const origin = request.split(' ')[1];\n      if (this.origins.includes(origin)) {\n        socket.write(this.buffer);\n      } else {\n        socket.write('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>');\n      }\n      socket.end();\n    });\n  }\n\n  compile() {\n    const policyXML = `<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>`;\n    this.buffer = Buffer.from(policyXML);\n  }\n\n  add(...origins) {\n    origins.forEach((origin) => {\n      this.origins.push(origin);\n    });\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(() => {\n        this.log('Server closed');\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      this.log('Server error:', err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb();\n        });\n      } else {\n        cb();\n      }\n    });\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      const request = data.toString();\n      const response = this.compile(request);\n      socket.write(response);\n    });\n\n    socket.on('end', () => {\n      socket.destroy();\n    });\n  }\n\n  compile(request) {\n    const xml = `<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>`;\n    const buffer = Buffer.from(xml);\n    return buffer;\n  }\n\n  add(origin) {\n    this.origins.push(origin);\n    this.compile();\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(() => {\n        this.log('Server closed');\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer(socket => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', err => {\n      this.log(err);\n      if (this.server) {\n        this.server.close();\n      }\n      this.socket.close();\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (cb) cb();\n    });\n\n    if (this.server) {\n      this.server.listen(port, () => {\n        this.log(`Fallback HTTP server listening on port ${port}`);\n      });\n    }\n  }\n\n  responder(socket) {\n    socket.on('data', data => {\n      const request = data.toString();\n      const origin = request.split('\\n')[0].split(' ')[1];\n      if (this.origins.includes(origin)) {\n        socket.write(this.buffer);\n      } else {\n        socket.write('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>');\n      }\n    });\n  }\n\n  compile() {\n    let xml = '<cross-domain-policy>';\n    this.origins.forEach(origin => {\n      xml += `<allow-access-from domain=\"${origin}\" secure=\"false\"/>`;\n    });\n    xml += '</cross-domain-policy>';\n    this.buffer = Buffer.from(xml);\n  }\n\n  add(...origins) {\n    origins.forEach(origin => {\n      if (!this.origins.includes(origin)) {\n        this.origins.push(origin);\n      }\n    });\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    if (this.server) {\n      this.server.close();\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      this.log(err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb();\n        });\n      } else {\n        cb();\n      }\n    });\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      const request = data.toString();\n      const response = this.compile(request);\n      socket.write(response);\n    });\n\n    socket.on('end', () => {\n      socket.destroy();\n    });\n  }\n\n  compile(request) {\n    const xml = `<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>`;\n    const buffer = Buffer.from(xml);\n    return buffer;\n  }\n\n  add(origin) {\n    this.origins.push(origin);\n    this.compile();\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(() => {\n        this.log('Server closed');\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      this.log('Server error:', err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb(null, this);\n        });\n      } else {\n        cb(null, this);\n      }\n    });\n  }\n\n  responder(socket) {\n    let data = '';\n    socket.on('data', (chunk) => {\n      data += chunk.toString();\n    });\n\n    socket.on('end', () => {\n      const request = data.split('\\n')[0];\n      const origin = request.split('/')[2];\n      if (this.origins.includes(origin)) {\n        socket.write(this.buffer);\n      } else {\n        socket.write('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>');\n      }\n      socket.end();\n    });\n  }\n\n  compile() {\n    const xml = `<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>`;\n    this.buffer = Buffer.from(xml);\n  }\n\n  add(...origins) {\n    origins.forEach((origin) => {\n      this.origins.push(origin);\n    });\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(() => {\n        this.log('Server closed');\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer(socket => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', err => {\n      this.log(err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb();\n        });\n      } else {\n        cb();\n      }\n    });\n  }\n\n  responder(socket) {\n    const headers = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<cross-domain-policy>\\n<allow-access-from domain=\"*\"\\n port=\"*\"/>\\n</cross-domain-policy>`;\n    socket.write(this.buffer || Buffer.from(headers));\n    socket.end();\n  }\n\n  compile() {\n    const originsString = this.origins.map(origin => `<allow-access-from domain=\"${origin}\" port=\"*\"/>\\n`).join('');\n    const headers = `<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<cross-domain-policy>\\n${originsString}</cross-domain-policy>`;\n    this.buffer = Buffer.from(headers);\n  }\n\n  add(...newOrigins) {\n    this.origins = [...this.origins, ...newOrigins];\n    this.compile();\n  }\n\n  remove(origin) {\n    this.origins = this.origins.filter(o => o !== origin);\n    this.compile();\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.log('Server closed');\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.buffer = null;\n  }\n\n  listen(port, server, cb) {\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      this.log('Server error:', err);\n    });\n\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      if (server) {\n        server.listen(port, () => {\n          cb();\n        });\n      } else {\n        cb();\n      }\n    });\n  }\n\n  responder(socket) {\n    let data = '';\n    socket.on('data', (chunk) => {\n      data += chunk.toString();\n    });\n\n    socket.on('end', () => {\n      const request = data.split('\\n')[0];\n      const origin = request.split(' ')[1];\n      if (this.origins.includes(origin)) {\n        socket.write(this.buffer);\n      } else {\n        socket.write('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>');\n      }\n      socket.end();\n    });\n  }\n\n  compile() {\n    const policyXML = `<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>`;\n    this.buffer = Buffer.from(policyXML);\n  }\n\n  add(origin) {\n    this.origins.push(origin);\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(() => {\n        this.log('Server closed');\n      });\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module that can handle both secure (TLS) and non-secure connections, manage client connections, and emit relevant events.\n\nClass Description: The Server class extends Node.js's EventEmitter to create a TCP server that can handle multiple client connections. It supports both secure (TLS) and non-secure (plain TCP) modes, manages connection lifecycle events, and maintains a list of active connections.\n\nAttributes:\n- socket: [Object] - The underlying TCP/TLS server instance\n- connections: [Array] - Array of active Connection objects\n\nMethods:\n- constructor(secure, options, callback) -> [Server Instance] - Initializes the server. 'secure' is a boolean indicating TLS usage, 'options' is an optional configuration object, and 'callback' is an optional function for 'connection' events\n- listen(port, host, callback) -> [Server Instance] - Starts the server listening on specified port and host. 'host' is optional, and 'callback' is an optional function for 'listening' events\n\nEvents:\n- connection: Emitted when a new client connects (passes Connection object)\n- close: Emitted when the server closes\n- error: Emitted when an error occurs (passes error object)\n- listening: Emitted when the server starts listening",
    "Canonical_solution": "var util = require('util'),\n    net = require('net'),\n    tls = require('tls'),\n    events = require('events'),\n    Connection = require('./Connection');\n\nfunction nop() {}\n\nclass Server extends events.EventEmitter {\n    constructor(secure, options, callback) {\n        super();\n        var that = this;\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        var onConnection = function (socket) {\n            var conn = new Connection(socket, that, function () {\n                that.connections.push(conn);\n                conn.removeListener('error', nop);\n                that.emit('connection', conn);\n            });\n            conn.on('close', function () {\n                var pos = that.connections.indexOf(conn);\n                if (pos !== -1) {\n                    that.connections.splice(pos, 1);\n                }\n            });\n\n            // Ignore errors before the connection is established\n            conn.on('error', nop);\n        };\n\n        if (secure) {\n            this.socket = tls.createServer(options, onConnection);\n        } else {\n            this.socket = net.createServer(options, onConnection);\n        }\n\n        this.socket.on('close', function () {\n            that.emit('close');\n        });\n        this.socket.on('error', function (err) {\n            that.emit('error', err);\n        });\n        this.connections = [];\n\n        if (callback) {\n            this.on('connection', callback);\n        }\n    }\n\n    listen(port, host, callback) {\n        var that = this;\n\n        if (typeof host === 'function') {\n            callback = host;\n            host = undefined;\n        }\n\n        if (callback) {\n            this.on('listening', callback);\n        }\n\n        this.socket.listen(port, host, function () {\n            that.emit('listening');\n        });\n\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass Server extends net.Server {\n  constructor(secure, options, callback) {\n    super(options);\n    this.socket = secure ? tls.createServer(options, (socket) => {\n      this.emit('connection', new Connection(socket));\n    }) : net.createServer((socket) => {\n      this.emit('connection', new Connection(socket));\n    });\n    this.connections = [];\n    this.on('connection', (socket) => {\n      this.connections.push(socket);\n      socket.on('close', () => {\n        const index = this.connections.indexOf(socket);\n        if (index !== -1) this.connections.splice(index, 1);\n        this.emit('close');\n      });\n    });\n    this.on('error', (error) => {\n      this.emit('error', error);\n    });\n    if (callback) this.on('connection', callback);\n  }\n\n  listen(port, host, callback) {\n    this.socket.listen(port, host, () => {\n      this.emit('listening');\n      if (callback) callback();\n    });\n  }\n}\n\nclass Connection {\n  constructor(socket) {\n    this.socket = socket;\n  }\n}\n\nmodule.exports = Server;\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass Server extends net.Server {\n  constructor(secure, options, callback) {\n    super(options);\n    this.socket = secure ? tls.createServer(options, (socket) => {\n      this.emit('connection', new Connection(socket));\n    }) : net.createServer((socket) => {\n      this.emit('connection', new Connection(socket));\n    });\n    this.connections = [];\n    this.socket.on('connection', (socket) => {\n      this.connections.push(new Connection(socket));\n    });\n    this.socket.on('close', () => {\n      this.emit('close');\n    });\n    this.socket.on('error', (error) => {\n      this.emit('error', error);\n    });\n    if (callback) {\n      this.on('listening', callback);\n    }\n  }\n\n  listen(port, host, callback) {\n    this.socket.listen(port, host, callback);\n    this.emit('listening');\n  }\n}\n\nclass Connection {\n  constructor(socket) {\n    this.socket = socket;\n    this.socket.on('end', () => {\n      this.socket.destroy();\n    });\n    this.socket.on('error', (error) => {\n      this.socket.destroy();\n    });\n  }\n}\n\nmodule.exports = Server;\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass Server extends net.Server {\n  constructor(secure, options, callback) {\n    super(options);\n    this.socket = secure ? tls.createServer(options, (socket) => {\n      this.emit('connection', new Connection(socket));\n    }) : net.createServer((socket) => {\n      this.emit('connection', new Connection(socket));\n    });\n    this.connections = [];\n    this.on('connection', callback);\n    this.on('close', () => {\n      this.emit('close');\n    });\n    this.on('error', (error) => {\n      this.emit('error', error);\n    });\n    this.on('listening', () => {\n      this.emit('listening');\n    });\n  }\n\n  listen(port, host, callback) {\n    this.socket.listen(port, host, callback);\n    return this;\n  }\n}\n\nclass Connection {\n  constructor(socket) {\n    this.socket = socket;\n    this.socket.on('end', () => {\n      this.close();\n    });\n    this.socket.on('close', () => {\n      this.close();\n    });\n    this.socket.on('error', (error) => {\n      this.close();\n    });\n  }\n\n  close() {\n    this.socket.destroy();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst { createServer } = require('https');\n\nclass Server extends net.Server {\n  constructor(secure, options, callback) {\n    super(options);\n    this.socket = secure ? createServer(options) : net.createServer(options);\n    this.connections = [];\n    this.socket.on('connection', (conn) => {\n      this.connections.push(conn);\n      this.emit('connection', conn);\n    });\n    this.socket.on('close', () => {\n      this.emit('close');\n    });\n    this.socket.on('error', (err) => {\n      this.emit('error', err);\n    });\n    if (callback) {\n      this.socket.on('listening', callback);\n    }\n  }\n\n  listen(port, host, callback) {\n    if (this.socket === net.createServer) {\n      this.socket.listen(port, host, callback);\n    } else {\n      this.socket.listen(port, host, () => {\n        this.socket.emit('listening', callback);\n      });\n    }\n    return this;\n  }\n}\n\nmodule.exports = Server;\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass Server extends net.Server {\n  constructor(secure, options, callback) {\n    super(options);\n    this.socket = secure ? tls.createServer(options, (socket) => {\n      this.emit('connection', new Connection(socket));\n    }) : net.createServer((socket) => {\n      this.emit('connection', new Connection(socket));\n    });\n    this.connections = [];\n    this.socket.on('connection', (socket) => {\n      this.connections.push(new Connection(socket));\n    });\n    this.socket.on('close', () => {\n      this.emit('close');\n    });\n    this.socket.on('error', (error) => {\n      this.emit('error', error);\n    });\n    if (callback) {\n      this.on('listening', callback);\n    }\n  }\n\n  listen(port, host, callback) {\n    this.socket.listen(port, host, () => {\n      if (callback) {\n        callback();\n      }\n      this.emit('listening');\n    });\n    return this;\n  }\n}\n\nclass Connection {\n  constructor(socket) {\n    this.socket = socket;\n    this.socket.on('end', () => {\n      const index = this.connections.indexOf(this);\n      if (index !== -1) {\n        this.connections.splice(index, 1);\n      }\n    });\n  }\n}\n\nmodule.exports = Server;\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass Server extends net.Server {\n  constructor(secure, options, callback) {\n    super(options);\n    this.socket = secure ? tls.createServer(options, (socket) => {\n      this.emit('connection', new Connection(socket));\n    }) : net.createServer((socket) => {\n      this.emit('connection', new Connection(socket));\n    });\n    this.connections = [];\n    this.socket.on('connection', (socket) => {\n      this.connections.push(new Connection(socket));\n    });\n    this.socket.on('close', () => {\n      this.emit('close');\n    });\n    this.socket.on('error', (error) => {\n      this.emit('error', error);\n    });\n    if (callback) {\n      this.on('listening', callback);\n    }\n  }\n\n  listen(port, host, callback) {\n    this.socket.listen(port, host, () => {\n      if (callback) {\n        callback();\n      }\n      this.emit('listening');\n    });\n    return this;\n  }\n}\n\nclass Connection {\n  constructor(socket) {\n    this.socket = socket;\n    this.socket.on('end', () => {\n      this.socket.destroy();\n    });\n    this.socket.on('error', (error) => {\n      this.socket.destroy();\n    });\n  }\n}\n\nmodule.exports = Server;\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst { createServer } = require('https');\nconst EventEmitter = require('events');\n\nclass Server extends EventEmitter {\n  constructor(secure, options, callback) {\n    super();\n    this.socket = secure ? createServer(options, callback) : net.createServer();\n    this.connections = [];\n    this.socket.on('connection', (conn) => {\n      this.connections.push(conn);\n      this.emit('connection', conn);\n    });\n    this.socket.on('close', () => {\n      this.emit('close');\n    });\n    this.socket.on('error', (err) => {\n      this.emit('error', err);\n    });\n  }\n\n  listen(port, host, callback) {\n    if (this.socket === net.createServer()) {\n      this.socket.listen(port, host, callback);\n    } else {\n      this.socket.listen(port, host, (err) => {\n        if (err) return callback(err);\n        this.emit('listening');\n        callback();\n      });\n    }\n    return this;\n  }\n}\n\nmodule.exports = Server;\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\n\nclass Server extends net.Server {\n  constructor(secure, options, callback) {\n    super(options);\n    this.socket = secure ? tls.createServer(options, (socket) => {\n      this.emit('connection', new Connection(socket));\n    }) : net.createServer((socket) => {\n      this.emit('connection', new Connection(socket));\n    });\n    this.connections = [];\n    this.on('connection', callback);\n    this.on('close', () => {\n      this.emit('close');\n    });\n    this.on('error', (error) => {\n      this.emit('error', error);\n    });\n    this.on('listening', () => {\n      this.emit('listening');\n    });\n  }\n\n  listen(port, host, callback) {\n    this.socket.listen(port, host, callback);\n    return this;\n  }\n}\n\nclass Connection {\n  constructor(socket) {\n    this.socket = socket;\n    this.socket.on('end', () => {\n      this.close();\n    });\n    this.socket.on('error', (error) => {\n      this.close();\n    });\n  }\n\n  close() {\n    this.socket.destroy();\n    const index = this.connections.indexOf(this);\n    if (index !== -1) {\n      this.connections.splice(index, 1);\n    }\n    this.socket = null;\n  }\n}\n\nmodule.exports = Server;\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst { createServer } = require('https');\n\nclass Server extends net.Server {\n  constructor(secure, options, callback) {\n    super(options);\n    this.socket = secure ? createServer(options) : net.createServer(options);\n    this.connections = [];\n    this.socket.on('connection', (socket) => {\n      this.connections.push(socket);\n      this.emit('connection', socket);\n    });\n    this.socket.on('close', () => {\n      this.emit('close');\n    });\n    this.socket.on('error', (error) => {\n      this.emit('error', error);\n    });\n    if (callback) {\n      this.socket.on('listening', callback);\n    }\n  }\n\n  listen(port, host, callback) {\n    if (this.socket === net.createServer) {\n      this.socket.listen(port, host, callback);\n    } else {\n      this.socket.listen(port, host, () => {\n        this.socket.emit('listening', callback);\n      });\n    }\n    return this;\n  }\n}\n\nmodule.exports = Server;\n```",
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst { createServer } = require('https');\nconst EventEmitter = require('events');\n\nclass Server extends EventEmitter {\n  constructor(secure, options, callback) {\n    super();\n    this.socket = secure ? createServer(options, callback) : net.createServer();\n    this.connections = [];\n    this.socket.on('connection', (conn) => {\n      this.connections.push(conn);\n      this.emit('connection', conn);\n    });\n    this.socket.on('close', () => {\n      this.emit('close');\n    });\n    this.socket.on('error', (err) => {\n      this.emit('error', err);\n    });\n  }\n\n  listen(port, host, callback) {\n    if (this.socket instanceof net.Server) {\n      this.socket.listen(port, host, callback);\n    } else {\n      this.socket.listen(port, host, () => {\n        this.socket.on('connection', (conn) => {\n          this.connections.push(conn);\n          this.emit('connection', conn);\n        });\n        this.socket.on('close', () => {\n          this.emit('close');\n        });\n        this.socket.on('error', (err) => {\n          this.emit('error', err);\n        });\n        callback();\n      });\n    }\n    this.emit('listening');\n  }\n}\n\nmodule.exports = Server;\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 165,
    "Instruction": "Task Description: Create a function that sets up a TCP server with WebSocket support, handling client connections and message routing.\n\nFunction Description: The function `createTCPServer` initializes a TCP server using Node.js's `net` module, integrates WebSocket functionality, and manages client connections. It sets up event handlers for connection establishment, message piping, and error handling. The server listens on the specified port for incoming connections.\n\nInput:  \n- `port` (Number): The port number on which the TCP server should listen for incoming connections.\n\nOutput:  \n- None (The function starts a TCP server but does not return any value).  \n\n---\n\n**Note**: The function internally uses the `net` module to create the server, the `websocket` library for WebSocket support, and `permessage-deflate` for compression. It pipes data between the TCP connection and WebSocket driver for bidirectional communication.",
    "Canonical_solution": "function createTCPServer(port) {\n    var net = require('net'),\n        websocket = require('..'),\n        deflate = require('permessage-deflate');\n\n    var server = net.createServer(function(connection) {\n        var driver = websocket.server();\n        driver.addExtension(deflate);\n\n        driver.on('connect', function() {\n            if (websocket.isWebSocket(driver)) driver.start();\n        });\n\n        driver.on('close', function() { connection.end() });\n        connection.on('error', function() {});\n\n        connection.pipe(driver.io);\n        driver.io.pipe(connection);\n\n        driver.messages.pipe(driver.messages);\n    });\n\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\nconst WebSocketServer = require('ws').Server;\nconst WebSocket = require('ws');\nconst { Server: HttpServer } = require('http');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocketServer({ server });\n\n  server.on('connection', (socket) => {\n    const ws = new WebSocket(socket);\n    ws.on('message', (message) => {\n      server.emit('message', message);\n    });\n    ws.on('close', () => {\n      server.emit('close');\n    });\n    ws.on('error', (error) => {\n      server.emit('error', error);\n    });\n  });\n\n  server.on('message', (message) => {\n    wss.clients.forEach((client) => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(message);\n      }\n    });\n  });\n\n  server.on('close', () => {\n    wss.close();\n  });\n\n  server.on('error', (error) => {\n    wss.close();\n  });\n\n  const httpServer = new HttpServer(server);\n  httpServer.listen(port);\n}\n```",
      "```javascript\nconst net = require('net');\nconst WebSocket = require('ws');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocket.Server({ server });\n\n  server.on('connection', (socket) => {\n    const ws = wss.handleUpgrade({ socket, head: '', client: socket }, null, (request, socket, head) => {\n      wss.emit('connection', request, socket, head);\n    });\n  });\n\n  wss.on('connection', (ws, req) => {\n    ws.on('message', (message) => {\n      ws.send(message);\n    });\n\n    ws.on('close', () => {\n      console.log('WebSocket connection closed');\n    });\n\n    ws.on('error', (error) => {\n      console.error('WebSocket error:', error);\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('error', (error) => {\n    console.error('Server error:', error);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst WebSocket = require('ws');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocket.Server({ server });\n\n  server.on('connection', (socket) => {\n    const ws = wss.handleUpgrade({ headers: socket.headers, req: socket }, socket, socket.readable, (req, socket, head) => {\n      wss.emit('connection', req, socket, head);\n    });\n  });\n\n  wss.on('connection', (ws) => {\n    ws.on('message', (message) => {\n      ws.send(message);\n    });\n  });\n\n  server.listen(port);\n}\n```",
      "```javascript\nconst net = require('net');\nconst WebSocket = require('ws');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocket.Server({ server });\n\n  server.on('connection', (socket) => {\n    const ws = wss.connect({ \n      socket: socket \n    });\n\n    ws.on('message', (message) => {\n      socket.write(message);\n    });\n\n    socket.on('data', (data) => {\n      ws.send(data);\n    });\n\n    socket.on('end', () => {\n      ws.close();\n    });\n\n    socket.on('error', (error) => {\n      ws.close();\n      console.error('Socket error:', error);\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst WebSocket = require('ws');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocket.Server({ server });\n\n  server.on('connection', (socket) => {\n    const ws = wss.handleUpgrade({ headers: socket.headers, req: { url: socket.remoteAddress }, _socket: socket }, null, (req, socket, head) => {\n      wss.emit('connection', req, socket, head);\n    });\n  });\n\n  wss.on('connection', (ws) => {\n    ws.on('message', (message) => {\n      server.emit('data', message);\n    });\n\n    server.on('data', (data) => {\n      ws.send(data);\n    });\n\n    ws.on('close', () => {\n      server.emit('close');\n    });\n\n    ws.on('error', (error) => {\n      server.emit('error', error);\n    });\n  });\n\n  server.listen(port);\n}\n```",
      "```javascript\nconst net = require('net');\nconst WebSocket = require('ws');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocket.Server({ server });\n\n  server.on('connection', (socket) => {\n    const ws = wss.connect({ \n      port: socket.remotePort, \n      host: socket.remoteAddress \n    });\n\n    socket.on('data', (data) => {\n      ws.send(data);\n    });\n\n    socket.on('end', () => {\n      ws.close();\n    });\n\n    socket.on('error', (err) => {\n      ws.close();\n    });\n\n    ws.on('message', (message) => {\n      socket.write(message);\n    });\n\n    ws.on('close', () => {\n      socket.destroy();\n    });\n\n    ws.on('error', (err) => {\n      socket.destroy();\n    });\n  });\n\n  server.listen(port);\n}\n```",
      "```javascript\nconst net = require('net');\nconst WebSocket = require('ws');\nconst { Server } = WebSocket;\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new Server({ server });\n\n  server.on('connection', (socket) => {\n    const ws = new WebSocket.Server({ server: socket });\n    ws.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        socket.write(message);\n      });\n      ws.on('close', () => {\n        socket.end();\n      });\n    });\n  });\n\n  server.on('error', (err) => {\n    console.error('Server error:', err);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst WebSocket = require('ws');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocket.Server({ server });\n\n  server.on('connection', (socket) => {\n    const ws = wss.connect({ \n      socket: socket \n    });\n\n    ws.on('message', (message) => {\n      socket.write(message);\n    });\n\n    socket.on('data', (data) => {\n      ws.send(data);\n    });\n\n    socket.on('end', () => {\n      ws.close();\n    });\n\n    socket.on('error', (error) => {\n      ws.close();\n      console.error('Socket error:', error);\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\nconst WebSocketServer = require('ws').Server;\nconst { Server: HttpServer } = require('http');\nconst { createServer: createHttpServer } = require('http');\nconst WebSocket = require('ws');\nconst { Duplex } = require('stream');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocketServer({ server });\n  const httpServer = createHttpServer({ server });\n\n  server.on('connection', (socket) => {\n    const ws = new WebSocket();\n    const wsStream = new Duplex({ objectMode: true });\n    wsStream._read = () => {};\n    wsStream._write = (chunk, encoding, callback) => {\n      ws.send(chunk, { binary: !Buffer.isBuffer(chunk) });\n      callback();\n    };\n\n    ws.on('message', (message) => {\n      socket.write(message);\n    });\n\n    ws.on('close', () => {\n      socket.destroy();\n    });\n\n    ws.on('error', (error) => {\n      socket.destroy();\n    });\n\n    socket.pipe(wsStream).pipe(ws);\n  });\n\n  httpServer.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\nconst WebSocketServer = require('ws').Server;\nconst { PerMessageDeflate } = require('permessage-deflate');\n\nfunction createTCPServer(port) {\n  const server = net.createServer();\n  const wss = new WebSocketServer({ server, clientTracking: true, perMessageDeflate: new PerMessageDeflate() });\n\n  server.listen(port);\n\n  server.on('connection', (socket) => {\n    const ws = new WebSocket(wss, { perMessageDeflate: new PerMessageDeflate() });\n    ws.on('message', (message) => {\n      socket.write(message);\n    });\n    ws.on('close', () => {\n      socket.destroy();\n    });\n    ws.on('error', (error) => {\n      socket.destroy();\n    });\n  });\n\n  wss.on('connection', (ws) => {\n    ws.on('message', (message) => {\n      server.emit('data', message);\n    });\n    ws.on('close', () => {\n      server.emit('close');\n    });\n    ws.on('error', (error) => {\n      server.emit('error', error);\n    });\n  });\n\n  server.on('data', (data) => {\n    wss.clients.forEach((client) => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(data);\n      }\n    });\n  });\n\n  server.on('close', () => {\n    wss.close();\n  });\n\n  server.on('error', (error) => {\n    wss.close();\n  });\n}\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a TCP server connector class in JavaScript using Node.js's 'net' module that handles server creation, connection events, and lifecycle management.\n\nClass Description: The Connector class is an EventEmitter that creates and manages a TCP server. It handles server connections, errors, and provides methods to start and stop the server.\n\nAttributes:\n- opts: [Object] - Optional configuration options for the server\n- host: [String] - The host address the server will bind to\n- port: [Number] - The port number the server will listen on\n- tcpServer: [Object] - The underlying TCP server instance\n\nMethods:\n- constructor: [Connector](port, host, opts) -> [Connector] - Initializes a new Connector instance with specified port, host, and options\n- start: [start](cb) -> [undefined] - Starts the TCP server and sets up connection and error event handlers. Calls the callback when server is ready\n- stop: [stop](force, cb) -> [undefined] - Stops the TCP server and calls the callback when complete. The force parameter determines whether to force close connections",
    "Canonical_solution": "var net = require('net');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar Connector = function(port, host, opts) {\n  if (!(this instanceof Connector)) {\n    return new Connector(port, host, opts);\n  }\n\n  EventEmitter.call(this);\n  this.opts = opts || {};\n  this.host = host;\n  this.port = port;\n};\n\nutil.inherits(Connector, EventEmitter);\n\nConnector.prototype.start = function(cb) {\n  var self = this;\n  this.tcpServer = net.createServer();\n  \n  this.tcpServer.on('connection', function(socket) {\n    self.emit('connection', socket);\n  });\n\n  this.tcpServer.on('error', function(err) {\n    self.emit('error', err);\n  });\n\n  this.tcpServer.listen(this.port, this.host);\n  process.nextTick(cb);\n};\n\nConnector.prototype.stop = function(force, cb) {\n  this.tcpServer.close();\n  process.nextTick(cb);\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\n\nclass Connector {\n  constructor(port, host, opts) {\n    this.host = host;\n    this.port = port;\n    this.opts = opts;\n    this.tcpServer = net.createServer();\n    this.tcpServer.on('connection', this.handleConnection.bind(this));\n    this.tcpServer.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.tcpServer.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this.tcpServer.close(cb);\n    } else {\n      this.tcpServer.close((err) => {\n        if (err) {\n          cb(err);\n        } else {\n          cb();\n        }\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    // Handle connection logic here\n  }\n\n  handleError(err) {\n    // Handle error logic here\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Connector {\n  constructor(port, host, opts = {}) {\n    this.host = host;\n    this.port = port;\n    this.opts = opts;\n    this.tcpServer = net.createServer();\n    this.tcpServer.on('connection', this.handleConnection.bind(this));\n    this.tcpServer.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.tcpServer.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this.tcpServer.close(cb);\n    } else {\n      this.tcpServer.close((err) => {\n        if (err) {\n          cb(err);\n        } else {\n          cb();\n        }\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    // Custom connection handling logic\n  }\n\n  handleError(err) {\n    // Custom error handling logic\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Connector {\n  constructor(port, host, opts = {}) {\n    this.host = host;\n    this.port = port;\n    this.opts = opts;\n    this.tcpServer = net.createServer();\n    this.tcpServer.on('connection', this.handleConnection.bind(this));\n    this.tcpServer.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.tcpServer.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this.tcpServer.close(cb);\n    } else {\n      this.tcpServer.close((err) => {\n        if (err) {\n          cb(err);\n        } else {\n          cb();\n        }\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    // Handle connection logic here\n  }\n\n  handleError(err) {\n    // Handle error logic here\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Connector {\n  constructor(port, host, opts = {}) {\n    this.host = host;\n    this.port = port;\n    this.opts = opts;\n    this.tcpServer = net.createServer();\n    this.tcpServer.on('connection', this.handleConnection.bind(this));\n    this.tcpServer.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.tcpServer.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this.tcpServer.close(cb);\n    } else {\n      this.tcpServer.close((err) => {\n        if (err) {\n          cb(err);\n        } else {\n          cb();\n        }\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    // Connection handling logic\n  }\n\n  handleError(err) {\n    // Error handling logic\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Connector {\n  constructor(port, host, opts = {}) {\n    this.host = host;\n    this.port = port;\n    this.opts = opts;\n    this.tcpServer = net.createServer();\n    this.tcpServer.on('connection', this.handleConnection.bind(this));\n    this.tcpServer.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.tcpServer.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this.tcpServer.close(cb);\n    } else {\n      this.tcpServer.close(() => {\n        cb();\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    // Custom connection handling logic\n  }\n\n  handleError(error) {\n    // Custom error handling logic\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\n\nclass Connector extends net.Server {\n  constructor(port, host, opts) {\n    super(opts);\n    this.host = host;\n    this.port = port;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this.close(cb);\n    } else {\n      this.close(() => {\n        this.emit('close', () => {\n          cb();\n        });\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      // Handle incoming data\n    });\n    socket.on('end', () => {\n      // Handle end of data\n    });\n    socket.on('error', (err) => {\n      // Handle socket errors\n    });\n  }\n\n  handleError(err) {\n    // Handle server errors\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Connector {\n  constructor(port, host, opts = {}) {\n    this.host = host;\n    this.port = port;\n    this.opts = opts;\n    this.tcpServer = null;\n  }\n\n  start(cb) {\n    this.tcpServer = net.createServer(this.opts);\n    this.tcpServer.listen(this.port, this.host, () => {\n      this.tcpServer.on('connection', (socket) => {\n        // Handle connection logic here\n      });\n      this.tcpServer.on('error', (err) => {\n        // Handle error logic here\n      });\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (this.tcpServer) {\n      if (force) {\n        this.tcpServer.close(() => {\n          cb();\n        });\n      } else {\n        this.tcpServer.close(() => {\n          cb();\n        });\n      }\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Connector extends net.Server {\n  constructor(port, host, opts = {}) {\n    super({ ...opts });\n    this.host = host;\n    this.port = port;\n    this.opts = opts;\n    this.tcpServer = this;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this.close(cb);\n    } else {\n      this.close(() => {\n        this(tcpServer).close(cb);\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    // Custom connection handling logic\n  }\n\n  handleError(error) {\n    // Custom error handling logic\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Connector extends net.Server {\n  constructor(port, host, opts = {}) {\n    super(opts);\n    this.host = host;\n    this.port = port;\n    this.tcpServer = this;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.tcpServer.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this(tcpServer).close(cb);\n    } else {\n      this(tcpServer).close(() => {\n        cb();\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    // Custom connection handling logic\n  }\n\n  handleError(error) {\n    // Custom error handling logic\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Connector extends net.Server {\n  constructor(port, host, opts = {}) {\n    super({ ...opts });\n    this.host = host;\n    this.port = port;\n    this.opts = opts;\n    this.tcpServer = this;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start(cb) {\n    this.listen(this.port, this.host, () => {\n      cb();\n    });\n  }\n\n  stop(force, cb) {\n    if (force) {\n      this.close(cb);\n    } else {\n      this.close(() => {\n        this(tcpServer).close(cb);\n      });\n    }\n  }\n\n  handleConnection(socket) {\n    // Custom connection handling logic\n  }\n\n  handleError(error) {\n    // Custom error handling logic\n  }\n}\n```"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's 'net' module to listen for incoming connections, handle client messages, and emit events for commands received.\n\nClass Description: TCPListener is a class that creates a TCP server to listen for incoming connections on a specified port. It handles client connections, processes incoming data, and emits events when commands are received. The class extends Node.js's EventEmitter to provide event-driven functionality.\n\nAttributes:\n- port: [Number] - The port number on which the TCP server will listen\n- server: [Object] - The TCP server instance created by the 'net' module\n\nMethods:\n- constructor(port) -> [TCPListener] - Initializes the TCPListener instance with the specified port\n- start() -> [void] - Creates and starts the TCP server, sets up event handlers for client connections, data reception, and errors. Emits 'command' events when valid messages are received and 'log' events for server status updates\n\nThe class emits the following events:\n- 'command': (command, params, options, callback) - Emitted when a valid command message is received from a client\n- 'log': (message) - Emitted for logging server status and errors",
    "Canonical_solution": "var events = require('events');\nvar net = require('net');\n\nclass TCPListener {\n    constructor(port) {\n        this.port = port;\n        this.server = null;\n    }\n\n    start() {\n        this.server = net.createServer((c) => {\n            var data = '';\n            try {\n                c.on('data', (d) => {\n                    data += d;\n                    if (data.slice(-1) === '\\n') {\n                        var message = JSON.parse(data);\n                        this.emit('command', message.command, message.params, message.options, (message) => {\n                            c.end(message);\n                        });\n                    }\n                });\n                c.on('end', () => {});\n                c.on('error', () => {});\n            }\n            catch(e) {\n                this.emit('log', 'CLI listener failed to parse message ' + data);\n            }\n        }).listen(this.port, '127.0.0.1', () => {\n            this.emit('log', 'CLI listening on port ' + this.port);\n        });\n    }\n}\n\nTCPListener.prototype.__proto__ = events.EventEmitter.prototype;",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = this;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', this.handleData.bind(this));\n    socket.on('end', () => {\n      this.emit('log', 'Client disconnected');\n    });\n  }\n\n  handleData(data) {\n    const command = data.toString().trim();\n    if (command) {\n      this.emit('command', command);\n    }\n  }\n\n  handleError(error) {\n    this.emit('log', `Server error: ${error.message}`);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = super.listen(port);\n    this.server.on('connection', this.handleConnection.bind(this));\n    this.server.on('error', this.handleError.bind(this));\n  }\n\n  handleConnection(socket) {\n    socket.on('data', this.handleData.bind(this));\n    socket.on('end', this.handleEnd.bind(this));\n  }\n\n  handleData(data) {\n    const command = data.toString();\n    this.emit('command', command);\n  }\n\n  handleEnd() {\n    // Handle client disconnection\n  }\n\n  handleError(error) {\n    this.emit('log', error.message);\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server.on('connection', this.handleConnection.bind(this));\n    this.server.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      const message = data.toString();\n      this.processMessage(message, socket);\n    });\n  }\n\n  processMessage(message, socket) {\n    // Assuming message format is \"command:action,param1,param2\"\n    const parts = message.split(':');\n    if (parts.length === 2) {\n      const command = parts[1];\n      const params = message.split(':').slice(2).join(':').split(',');\n      this.emit('command', command, params, { socket }, (err, result) => {\n        if (err) {\n          this.emit('log', `Error processing command ${command}: ${err}`);\n        } else {\n          this.emit('log', `Command ${command} processed successfully`);\n        }\n      });\n    } else {\n      this.emit('log', `Invalid message format: ${message}`);\n    }\n  }\n\n  handleError(error) {\n    this.emit('log', `Server error: ${error.message}`);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = this;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      const message = data.toString();\n      this.emit('command', message, null, null, (err, response) => {\n        if (err) {\n          this.emit('log', `Error processing command: ${err}`);\n        } else {\n          socket.write(response);\n        }\n      });\n    });\n  }\n\n  handleError(error) {\n    this.emit('log', `Server error: ${error}`);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = this;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      const message = data.toString();\n      this.processMessage(message, socket);\n    });\n  }\n\n  processMessage(message, socket) {\n    // Assuming message format is \"command:action,param1,param2\"\n    const parts = message.split(':');\n    if (parts.length === 2) {\n      const command = parts[1];\n      const params = message.split(':').slice(2).join(':').split(',');\n      this.emit('command', command, params, { socket }, (err, result) => {\n        if (err) {\n          this.emit('log', `Error processing command ${command}: ${err}`);\n        } else {\n          this.emit('log', `Command ${command} processed successfully`);\n        }\n      });\n    } else {\n      this.emit('log', `Invalid message format: ${message}`);\n    }\n  }\n\n  handleError(error) {\n    this.emit('log', `Server error: ${error.message}`);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = this;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      const message = data.toString();\n      this.emit('command', message, null, null, (err, response) => {\n        if (err) {\n          this.emit('log', `Error processing command: ${err}`);\n        } else {\n          socket.write(response);\n        }\n      });\n    });\n  }\n\n  handleError(error) {\n    this.emit('log', `Server error: ${error}`);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server.on('connection', this.handleConnection.bind(this));\n    this.server.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      const message = data.toString();\n      this.processMessage(message, socket);\n    });\n  }\n\n  processMessage(message, socket) {\n    // Assuming message format is \"command:action,param1,param2\"\n    const parts = message.split(':');\n    if (parts.length === 2) {\n      const command = parts[1];\n      const params = message.split(':').slice(2).join(':').split(',');\n      this.emit('command', command, params, { socket }, (err, result) => {\n        if (err) {\n          this.emit('log', `Error processing command ${command}: ${err}`);\n        } else {\n          this.emit('log', `Command ${command} processed successfully`);\n        }\n      });\n    } else {\n      this.emit('log', `Invalid message format: ${message}`);\n    }\n  }\n\n  handleError(error) {\n    this.emit('log', `Server error: ${error.message}`);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server.on('connection', this.handleConnection.bind(this));\n    this.server.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      const message = data.toString();\n      this.processMessage(message, socket);\n    });\n  }\n\n  processMessage(message, socket) {\n    // Assuming message format is \"command:action,param1,param2\"\n    const parts = message.split(':');\n    if (parts.length === 2) {\n      const command = parts[1];\n      const params = message.split(':').slice(2).join(':').split(',');\n      this.emit('command', command, params, { socket }, (err, result) => {\n        if (err) {\n          this.emit('log', `Error processing command ${command}: ${err}`);\n        } else {\n          this.emit('log', `Command ${command} processed successfully`);\n        }\n      });\n    } else {\n      this.emit('log', `Invalid message format: ${message}`);\n    }\n  }\n\n  handleError(error) {\n    this.emit('log', `Server error: ${error.message}`);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server = this;\n    this.on('connection', this.handleConnection.bind(this));\n    this.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', this.handleData.bind(this));\n    socket.on('end', () => {\n      this.emit('log', 'Client disconnected');\n    });\n  }\n\n  handleData(data) {\n    const message = data.toString();\n    const command = this.parseCommand(message);\n    if (command) {\n      this.emit('command', command.command, command.params, command.options, command.callback);\n    }\n  }\n\n  parseCommand(message) {\n    // Implement command parsing logic here\n    // Return an object with command, params, options, and callback if valid\n    return null;\n  }\n\n  handleError(error) {\n    this.emit('log', `Error: ${error.message}`);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TCPListener extends net.Server {\n  constructor(port) {\n    super();\n    this.port = port;\n    this.server.on('connection', this.handleConnection.bind(this));\n    this.server.on('error', this.handleError.bind(this));\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      this.emit('log', `Server listening on port ${this.port}`);\n    });\n  }\n\n  handleConnection(socket) {\n    socket.on('data', (data) => {\n      const message = data.toString();\n      this.processMessage(message, socket);\n    });\n  }\n\n  processMessage(message, socket) {\n    // Assuming message format is \"command:action,param1,param2\"\n    const parts = message.split(':');\n    if (parts.length === 2) {\n      const command = parts[1];\n      const params = message.split(':').slice(2).join(':').split(',');\n      this.emit('command', command, params, { socket }, (err, result) => {\n        if (err) {\n          this.emit('log', `Error processing command ${command}: ${err}`);\n        } else {\n          this.emit('log', `Command ${command} processed successfully`);\n        }\n      });\n    } else {\n      this.emit('log', `Invalid message format: ${message}`);\n    }\n  }\n\n  handleError(error) {\n    this.emit('log', `Server error: ${error.message}`);\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a TCP server using Node.js's `net` module to handle client connections and manage sessions with unique identifiers, while optionally supporting weak references for garbage collection.\n\nClass Description: The `DNodeServer` class is a TCP server implementation that manages client connections, assigns unique session IDs, and provides event-based interaction with connected clients. It supports optional weak reference handling for callbacks to prevent memory leaks.\n\nAttributes:\n- cons: [Function] - The constructor or function to be called for each new connection.\n- opts: [Object] - Configuration options for the server, including weak reference settings.\n- server: [net.Server] - The underlying TCP server instance.\n- server.sessions: [Object] - Dictionary of active sessions indexed by session IDs.\n\nMethods:\n- constructor(cons, opts) -> [DNodeServer] - Initializes the server with a connection handler and options. Sets up weak reference handling if enabled.\n- _handleConnection(stream) -> [void] - Handles new client connections, creates session with unique ID, and sets up data piping and event forwarding.\n- listen(port, host, callback) -> [net.Server] - Starts the server listening on specified port/host or UNIX socket path. Accepts optional callback for 'listening' event.\n- _randomId() -> [string] - Generates a random 16-character hexadecimal string for session identification.\n\nInput:\n- cons: [Function] - Required connection handler function\n- opts: [Object] - Optional configuration object (may contain 'weak' and 'proto' properties)\n- port: [number|string] - Port number or UNIX socket path to listen on\n- host: [string] - Optional hostname to bind to\n- callback: [Function] - Optional callback for listening event\n\nOutput:\n- Instance of DNodeServer when constructed\n- Instance of net.Server when calling listen()",
    "Canonical_solution": "var dnode = require('./lib/dnode');\nvar net = require('net');\nvar weak;\n\nclass DNodeServer {\n    constructor(cons, opts) {\n        if (!opts) opts = {};\n        \n        if (opts.weak !== false && !opts.proto) {\n            if (!weak) {\n                weak = require(\"weak\");\n            }\n            \n            opts.proto = {};\n            opts.proto.wrap = function (cb, id) {\n                var proto = this;\n                return weak(cb, function () {\n                    proto.cull(id);\n                });\n            };\n            opts.proto.unwrap = function (ref, id) {\n                var cb = weak.get(ref);\n                return cb || function () {};\n            };\n        }\n        \n        this.cons = cons;\n        this.opts = opts;\n        this.server = net.createServer(this._handleConnection.bind(this));\n        this.server.sessions = {};\n    }\n\n    _handleConnection(stream) {\n        var d = new dnode(this.cons, this.opts);\n        do { d.id = this._randomId(); }\n        while (this.server.sessions[d.id]);\n        \n        this.server.sessions[d.id] = d;\n        d.on('end', () => {\n            delete this.server.sessions[d.id];\n        });\n        \n        d.on('local', (ref) => {\n            this.server.emit('local', ref, d);\n        });\n        \n        d.on('remote', (remote) => {\n            this.server.emit('remote', remote, d);\n        });\n        \n        stream.on('error', (err) => {\n            if (err && err.code === 'EPIPE') return;\n            d.emit('error', err);\n        });\n        \n        d.stream = stream;\n        stream.pipe(d);\n        d.pipe(stream);\n    }\n\n    listen(port, host, callback) {\n        if (typeof port === 'number' && port >= 0) {\n            this.server.listen(port, host);\n        } else if (typeof port === 'string') {\n            this.server.listen(port);\n        } else {\n            throw new Error('no port or path provided');\n        }\n        \n        if (callback) {\n            this.server.on('listening', callback);\n        }\n        \n        return this.server;\n    }\n\n    _randomId() {\n        var s = '';\n        for (var i = 0; i < 4; i++) {\n            s += Math.random().toString(16).slice(2);\n        }\n        return s;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n    if (opts && opts.weak) {\n      this.server.on('connection', this._handleConnection.bind(this, this._weakRef));\n    } else {\n      this.server.on('connection', this._handleConnection);\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n    stream.on('end', () => delete this.server.sessions[sessionId]);\n    stream.on('error', (err) => {\n      console.error(`Error on session ${sessionId}:`, err);\n      delete this.server.sessions[sessionId];\n    });\n  }\n\n  listen(port, host, callback) {\n    this.server.listen(port, host, callback);\n  }\n\n  _randomId() {\n    return Math.random().toString(16).substr(2, 16);\n  }\n\n  _weakRef(stream) {\n    const ref = WeakRef ? new WeakRef(stream) : stream;\n    return ref;\n  }\n}\n\nmodule.exports = DNodeServer;\n```",
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n    if (opts && opts.weak) {\n      this.server.on('connection', (stream) => {\n        const weakStream = new WeakRef(stream);\n        this._handleConnection(weakStream);\n      });\n    } else {\n      this.server.on('connection', this._handleConnection.bind(this));\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n    stream.on('data', (data) => {\n      this.server.sessions[sessionId].emit('data', data);\n    });\n    stream.on('end', () => {\n      delete this.server.sessions[sessionId];\n    });\n    stream.on('error', (err) => {\n      this.server.sessions[sessionId].emit('error', err);\n      delete this.server.sessions[sessionId];\n    });\n  }\n\n  _randomId() {\n    return Math.random().toString(16).substr(2, 16);\n  }\n\n  listen(port, host, callback) {\n    this.server.listen(port, host, callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n    if (opts && opts.weak) {\n      this.server.on('connection', this._handleConnection.bind(this, this._weakRef));\n    } else {\n      this.server.on('connection', this._handleConnection);\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n    stream.on('end', () => {\n      delete this.server.sessions[sessionId];\n    });\n    stream.on('error', (err) => {\n      delete this.server.sessions[sessionId];\n    });\n  }\n\n  listen(port, host, callback) {\n    this.server.listen(port, host, callback);\n    return this.server;\n  }\n\n  _randomId() {\n    return Math.floor(Math.random() * 0x10000000000000).toString(16).padStart(16, '0');\n  }\n\n  _weakRef(obj) {\n    return obj;\n  }\n}\n\nmodule.exports = DNodeServer;\n```",
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n    if (opts && opts.weak) {\n      this.server.on('connection', this._handleConnection.bind(this, this._weakRef));\n    } else {\n      this.server.on('connection', this._handleConnection);\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    const connHandler = this.cons.bind(this, stream, sessionId);\n    connHandler();\n    stream.on('data', (data) => {\n      this.server.sessions[sessionId].write(data);\n    });\n    stream.on('end', () => {\n      delete this.server.sessions[sessionId];\n    });\n    stream.on('error', (err) => {\n      console.error('Stream error:', err);\n    });\n  }\n\n  _randomId() {\n    return Math.floor(Math.random() * 0x10000000000000).toString(16);\n  }\n\n  listen(port, host, callback) {\n    this.server.listen(port, host, callback);\n  }\n\n  _weakRef(obj) {\n    return WeakRef ? new WeakRef(obj) : obj;\n  }\n}\n\nmodule.exports = DNodeServer;\n```",
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n    if (this.opts && this.opts.weak) {\n      this.server.on('connection', this._handleConnection.bind(this, this.opts.proto));\n    } else {\n      this.server.on('connection', this._handleConnection.bind(this));\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n    stream.on('end', () => {\n      delete this.server.sessions[sessionId];\n    });\n    stream.on('error', () => {\n      delete this.server.sessions[sessionId];\n    });\n  }\n\n  _randomId() {\n    return Math.floor(Math.random() * 0x10000000000000).toString(16);\n  }\n\n  listen(port, host, callback) {\n    this.server.listen(port, host, callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n    if (opts && opts.weak) {\n      this.server.on('connection', (stream) => {\n        const weakStream = new WeakRef(stream);\n        this._handleConnection(weakStream);\n      });\n    } else {\n      this.server.on('connection', this._handleConnection);\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n    stream.on('end', () => {\n      delete this.server.sessions[sessionId];\n    });\n  }\n\n  _randomId() {\n    return Math.floor(Math.random() * 0x10000000000000).toString(16).padStart(16, '0');\n  }\n\n  listen(port, host, callback) {\n    return this.server.listen(port, host, callback);\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n\n    if (opts && opts.weak) {\n      this.server.on('connection', (stream) => {\n        const weakStream = new WeakRef(stream);\n        this._handleConnection(weakStream);\n      });\n    } else {\n      this.server.on('connection', this._handleConnection.bind(this));\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n  }\n\n  _randomId() {\n    return Math.floor(Math.random() * 0x10000000000000).toString(16).padStart(16, '0');\n  }\n\n  listen(port, host, callback) {\n    this.server.listen(port, host, callback);\n    return this.server;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n\n    if (opts && opts.weak) {\n      this.server.on('connection', (stream) => {\n        const weakStream = new WeakRef(stream);\n        this._handleConnection(weakStream);\n      });\n    } else {\n      this.server.on('connection', this._handleConnection.bind(this));\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n  }\n\n  _randomId() {\n    return Math.random().toString(16).substr(2, 16);\n  }\n\n  listen(port, host, callback) {\n    this.server.listen(port, host, callback);\n    return this.server;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n    if (opts && opts.weak) {\n      this.server.on('connection', (stream) => {\n        const weakStream = new WeakRef(stream);\n        this._handleConnection(weakStream);\n      });\n    } else {\n      this.server.on('connection', this._handleConnection.bind(this));\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n  }\n\n  _randomId() {\n    return Math.floor(Math.random() * 0x10000000000000).toString(16).padStart(16, '0');\n  }\n\n  listen(port, host, callback) {\n    return this.server.listen(port, host, callback);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass DNodeServer {\n  constructor(cons, opts) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.server.sessions = {};\n    if (this.opts.weak) {\n      this.server.on('connection', (stream) => {\n        const weakStream = new WeakRef(stream);\n        this._handleConnection(weakStream);\n      });\n    } else {\n      this.server.on('connection', this._handleConnection);\n    }\n  }\n\n  _handleConnection(stream) {\n    const sessionId = this._randomId();\n    this.server.sessions[sessionId] = stream;\n    this.cons(stream, sessionId);\n  }\n\n  _randomId() {\n    return Math.floor(Math.random() * 0x10000000000000).toString(16);\n  }\n\n  listen(port, host, callback) {\n    this.server.listen(port, host, callback);\n    return this.server;\n  }\n}\n```"
    ],
    "match_count": 6,
    "pass@3": 0.9666666666666667,
    "pass@5": 1.0
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a TCP server class in JavaScript using Node.js's 'net' module to handle client connections, manage sockets, and provide event-driven communication.\n\nClass Description: The Socket class represents a TCP server that can bind to a specific port/host, manage client connections, handle socket errors, and emit events for various connection states. It extends EventEmitter for event handling capabilities.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- socks: [Array] - Array of connected client sockets\n- settings: [Object] - Configuration settings for the server\n- type: [String] - Indicates whether the instance is acting as a server or client\n\nMethods:\n- constructor() -> [void] - Initializes the socket instance with default settings\n- bind(port, host, fn) -> [Socket] - Binds the server to a specified port and host (supports both TCP and Unix sockets)\n- onconnect(sock) -> [void] - Handles new client connections\n- addSocket(sock) -> [void] - Adds a new socket to the connection pool and sets up message parsing\n- removeSocket(sock) -> [void] - Removes a socket from the connection pool\n- handleErrors(sock) -> [void] - Sets up error handling for a socket\n- closeServer(fn) -> [void] - Closes the server and all client connections",
    "Canonical_solution": "var Emitter = require('events').EventEmitter;\nvar net = require('net');\nvar debug = require('debug')('axon:sock');\n\nclass Socket {\n  constructor() {\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.set('hwm', Infinity);\n    this.set('identity', String(process.pid));\n    this.set('retry timeout', 100);\n    this.set('retry max timeout', 5000);\n  }\n\n  bind(port, host, fn) {\n    var self = this;\n    if ('client' == this.type) throw new Error('cannot bind() after connect()');\n    if ('function' == typeof host) {\n      fn = host;\n      host = undefined;\n    }\n\n    var unixSocket = false;\n\n    if ('string' == typeof port) {\n      port = url.parse(port);\n\n      if ('unix:' == port.protocol) {\n        host = fn;\n        fn = undefined;\n        port = port.pathname;\n        unixSocket = true;\n      } else {\n        host = port.hostname || '0.0.0.0';\n        port = parseInt(port.port, 10);\n      }\n    } else {\n      host = host || '0.0.0.0';\n    }\n\n    this.type = 'server';\n\n    this.server = net.createServer(this.onconnect.bind(this));\n\n    debug('%s bind %s:%s', this.type, host, port);\n    this.server.on('listening', this.emit.bind(this, 'bind'));\n\n    if (unixSocket) {\n      this.server.on('error', function(e) {\n        if (e.code == 'EADDRINUSE') {\n          var clientSocket = new net.Socket();\n\n          clientSocket.on('error', function(e2) {\n            if (e2.code == 'ECONNREFUSED') {\n              fs.unlink(port);\n              self.server.listen(port, host, fn);\n            }\n          });\n\n          clientSocket.connect({path: port}, function() {\n            throw e;\n          });\n        }\n      });\n    }\n\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    var self = this;\n    var addr = sock.remoteAddress + ':' + sock.remotePort;\n    debug('%s accept %s', self.type, addr);\n    this.addSocket(sock);\n    this.handleErrors(sock);\n    this.emit('connect', sock);\n    sock.on('close', function() {\n      debug('%s disconnect %s', self.type, addr);\n      self.emit('disconnect', sock);\n      self.removeSocket(sock);\n    });\n  }\n\n  addSocket(sock) {\n    var parser = new Parser;\n    var i = this.socks.push(sock) - 1;\n    debug('%s add socket %d', this.type, i);\n    sock.pipe(parser);\n    parser.on('data', this.onmessage(sock));\n  }\n\n  removeSocket(sock) {\n    var i = this.socks.indexOf(sock);\n    if (!~i) return;\n    debug('%s remove socket %d', this.type, i);\n    this.socks.splice(i, 1);\n  }\n\n  handleErrors(sock) {\n    var self = this;\n    sock.on('error', function(err) {\n      debug('%s error %s', self.type, err.code || err.message);\n      self.emit('socket error', err);\n      self.removeSocket(sock);\n      if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n      debug('%s ignored %s', self.type, err.code);\n      self.emit('ignored error', err);\n    });\n  }\n\n  closeServer(fn) {\n    debug('%s closing server', this.type);\n    this.server.on('close', this.emit.bind(this, 'close'));\n    this.server.close();\n    fn && fn();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\n\nclass Socket extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.server = net.createServer((sock) => {\n      this.onconnect(sock);\n    });\n\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      // Handle message parsing here\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n    });\n    sock.on('error', (err) => {\n      this.handleErrors(sock);\n    });\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    // Error handling logic here\n  }\n\n  closeServer(fn) {\n    this.server.close(() => {\n      this.socks.forEach((sock) => {\n        sock.destroy();\n      });\n      fn();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.server = net.createServer();\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    this.emit('connect', sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      this.emit('message', sock, data);\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n      this.emit('end', sock);\n    });\n    sock.on('error', (err) => {\n      this.handleErrors(sock);\n      this.emit('error', sock, err);\n    });\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    sock.removeAllListeners();\n  }\n\n  closeServer(fn) {\n    this.server.close((err) => {\n      if (err) {\n        this.emit('error', err);\n      }\n      this.socks.forEach(sock => sock.destroy());\n      fn();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.server = net.createServer((sock) => {\n      this.onconnect(sock);\n    });\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      // Handle message parsing here\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n    });\n    sock.on('error', (err) => {\n      this.handleErrors(sock);\n    });\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    // Error handling logic here\n  }\n\n  closeServer(fn) {\n    this.server.close(() => {\n      this.socks.forEach((sock) => {\n        sock.destroy();\n      });\n      fn();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    if (this.server) {\n      this.server.close();\n    }\n    this.server = net.createServer();\n    this.server.listen(port, host, fn);\n    this.server.on('connection', this.onconnect.bind(this));\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      // Handle message parsing here\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n    });\n    sock.on('error', this.handleErrors.bind(this, sock));\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    // Error handling logic here\n  }\n\n  closeServer(fn) {\n    this.server.close(() => {\n      this.socks.forEach(sock => sock.destroy());\n      fn();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    if (this.server) {\n      throw new Error('Server is already bound to a port.');\n    }\n    this.server = net.createServer();\n    this.server.listen(port, host, () => {\n      if (typeof fn === 'function') {\n        fn();\n      }\n    });\n    return this;\n  }\n\n  onconnect(sock) {\n    this.emit('connect', sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      this.emit('message', sock, data);\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n      this.emit('end', sock);\n    });\n    sock.on('error', (err) => {\n      this.handleErrors(sock);\n      this.emit('error', sock, err);\n    });\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    sock.end();\n  }\n\n  closeServer(fn) {\n    this.server.close(() => {\n      this.socks.forEach(sock => sock.end());\n      if (typeof fn === 'function') {\n        fn();\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    if (this.server) {\n      this.server.close();\n    }\n    this.server = net.createServer();\n    this.server.listen(port, host, fn);\n    this.server.on('connection', this.onconnect.bind(this));\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      // Handle message parsing here\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n    });\n    sock.on('error', this.handleErrors.bind(this, sock));\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    // Error handling logic here\n  }\n\n  closeServer(fn) {\n    this.server.close(() => {\n      this.socks.forEach(sock => sock.destroy());\n      fn();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.server = net.createServer((sock) => {\n      this.onconnect(sock);\n    });\n\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      // Handle incoming data\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n    });\n    sock.on('error', (err) => {\n      this.handleErrors(sock);\n    });\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    // Handle socket errors\n  }\n\n  closeServer(fn) {\n    this.server.close(() => {\n      this.socks.forEach((sock) => {\n        sock.destroy();\n      });\n      fn();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.server = net.createServer();\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    this.emit('connect', sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      this.emit('message', sock, data);\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n      this.emit('end', sock);\n    });\n    sock.on('error', (err) => {\n      this.handleErrors(sock);\n      this.emit('error', sock, err);\n    });\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    sock.end();\n  }\n\n  closeServer(fn) {\n    this.server.close((err) => {\n      if (err) {\n        this.emit('error', err);\n      }\n      this.socks.forEach(sock => sock.destroy());\n      fn();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.server = net.createServer();\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    this.emit('connect', sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    sock.on('data', (data) => {\n      this.emit('data', sock, data);\n    });\n    sock.on('end', () => {\n      this.emit('end', sock);\n      this.removeSocket(sock);\n    });\n    sock.on('error', (err) => {\n      this.emit('error', sock, err);\n      this.handleErrors(sock);\n    });\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n    }\n  }\n\n  handleErrors(sock) {\n    sock.removeAllListeners();\n    sock.destroy();\n  }\n\n  closeServer(fn) {\n    this.server.close(() => {\n      this.socks.forEach(sock => sock.destroy());\n      fn();\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Socket extends require('events').EventEmitter {\n    constructor() {\n        super();\n        this.server = null;\n        this.socks = [];\n        this.settings = {};\n        this.type = 'server';\n    }\n\n    bind(port, host, fn) {\n        if (this.server) {\n            this.server.close();\n        }\n        this.server = net.createServer();\n        this.server.listen(port, host, fn);\n        return this;\n    }\n\n    onconnect(sock) {\n        this.emit('connect', sock);\n    }\n\n    addSocket(sock) {\n        this.socks.push(sock);\n        sock.on('data', (data) => {\n            this.emit('data', sock, data);\n        });\n        sock.on('end', () => {\n            this.removeSocket(sock);\n            this.emit('end', sock);\n        });\n        sock.on('error', (err) => {\n            this.handleErrors(sock);\n        });\n    }\n\n    removeSocket(sock) {\n        const index = this.socks.indexOf(sock);\n        if (index !== -1) {\n            this.socks.splice(index, 1);\n        }\n    }\n\n    handleErrors(sock) {\n        sock.destroy();\n        this.emit('error', sock);\n    }\n\n    closeServer(fn) {\n        this.server.close(() => {\n            this.socks.forEach(sock => sock.destroy());\n            fn();\n        });\n    }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        if unsplashClientId:\n            return await WallpaperService.getUnsplashWallpaper()\n        else:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper():\n        url = f\"https://api.unsplash.com/photos/random?client_id={unsplashClientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": data\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.text()\n                start = data.find(\"url('\") + len(\"url('\")\n                end = data.find(\"'\", start)\n                image_url = data[start:end]\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": image_url\n                    }\n                }\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        if unsplashClientId:\n            return await WallpaperService.getUnsplashWallpaper()\n        else:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper():\n        url = f\"https://api.unsplash.com/photos/random?client_id={unsplashClientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": data\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.text()\n                start = data.find(\"url:\")\n                end = data.find(\";\", start)\n                wallpaper_url = data[start + 4:end].strip()\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": wallpaper_url\n                    }\n                }\n\nasync def main():\n    wallpaper = await WallpaperService.getWallpaper(\"your_unsplash_client_id_here\")\n    print(wallpaper)\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        try:\n            if unsplashClientId:\n                return await WallpaperService.getUnsplashWallpaper()\n            else:\n                return await WallpaperService.getBingWallpaper()\n        except Exception:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper():\n        url = f\"https://api.unsplash.com/photos/random?client_id={unsplashClientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": {\n                        \"url\": data[\"urls\"][\"full\"],\n                        \"author\": data[\"user\"][\"name\"]\n                    }\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=en-US\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                image_url = data[\"images\"][0][\"url\"]\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": image_url\n                    }\n                }\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        if unsplashClientId:\n            return await WallpaperService.getUnsplashWallpaper()\n        else:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper():\n        url = f\"https://api.unsplash.com/photos/random?client_id={unsplashClientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": data\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.text()\n                start = data.find(\"url:\")\n                end = data.find(\";\", start)\n                wallpaper_url = data[start + 4:end].strip()\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": wallpaper_url\n                    }\n                }\n\nasync def main():\n    wallpaper = await WallpaperService.getWallpaper(\"your_unsplash_client_id_here\")\n    print(wallpaper)\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        if unsplashClientId:\n            return await WallpaperService.getUnsplashWallpaper()\n        else:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper():\n        url = f\"https://api.unsplash.com/photos/random?client_id={unsplashClientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": data\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=en-US\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.text()\n                start = data.find(\"url:\")\n                end = data.find(\";\", start)\n                wallpaper_url = data[start + 4:end].strip()\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": wallpaper_url\n                    }\n                }\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        if unsplashClientId:\n            return await WallpaperService.getUnsplashWallpaper(unsplashClientId)\n        else:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper(clientId):\n        url = f\"https://api.unsplash.com/photos/random?client_id={clientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": data\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.text()\n                start = data.find('url\":\"')\n                end = data.find('\",')\n                if start != -1 and end != -1:\n                    wallpaper_url = data[start + 5:end]\n                    return {\n                        \"type\": \"bing\",\n                        \"data\": {\n                            \"url\": wallpaper_url\n                        }\n                    }\n                else:\n                    return {\n                        \"type\": \"bing\",\n                        \"data\": {\n                            \"url\": \"https://www.bing.com/th?id=OHR.FallFoliage2023-10&pid=hp&w=1080&h=720&rs=1\"\n                        }\n                    }\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        if unsplashClientId:\n            return await WallpaperService.getUnsplashWallpaper()\n        else:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper():\n        url = f\"https://api.unsplash.com/photos/random?client_id={unsplashClientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": data\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.text()\n                json_data = json.loads(data.split(\"}{\")[1])\n                image_url = json_data[\"images\"][0][\"url\"]\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": image_url\n                    }\n                }\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        if unsplashClientId:\n            return await WallpaperService.getUnsplashWallpaper(unsplashClientId)\n        else:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper(clientId):\n        url = f\"https://api.unsplash.com/photos/random?client_id={clientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": data\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=en-US\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.text()\n                start = data.find(\"url:\")\n                end = data.find(\";\", start)\n                wallpaper_url = data[start + 4:end].strip()\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": wallpaper_url\n                    }\n                }\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        if unsplashClientId:\n            return await WallpaperService.getUnsplashWallpaper()\n        else:\n            return await WallpaperService.getBingWallpaper()\n\n    @staticmethod\n    async def getUnsplashWallpaper():\n        url = f\"https://api.unsplash.com/photos/random?client_id={unsplashClientId}\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.json()\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": data\n                }\n\n    @staticmethod\n    async def getBingWallpaper():\n        url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                data = await response.text()\n                start = data.find(\"url('\") + len(\"url('\")\n                end = data.find(\"'\", start)\n                image_url = data[start:end]\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": image_url\n                    }\n                }\n```",
      "```python\nimport asyncio\nimport aiohttp\nimport random\n\nclass WallpaperService:\n    @staticmethod\n    async def getWallpaper(unsplashClientId=None):\n        try:\n            if unsplashClientId:\n                url = f\"https://api.unsplash.com/photos/random?client_id={unsplashClientId}\"\n                response = await WallpaperService.fetch(url)\n                return {\n                    \"type\": \"unsplash\",\n                    \"data\": response.json()\n                }\n            else:\n                url = \"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1\"\n                response = await WallpaperService.fetch(url)\n                data = response.json()['images'][0]\n                return {\n                    \"type\": \"bing\",\n                    \"data\": {\n                        \"url\": data['url'],\n                        \"copyright\": data['copyright']\n                    }\n                }\n        except Exception as e:\n            return {\n                \"type\": \"bing\",\n                \"data\": {\n                    \"url\": \"https://www.bing.com/th?id=OHR.TulipsBulbLayer_ZH-CN7459429795_1920x1080.jpg\",\n                    \"copyright\": \"Â© Alexey Klementiev / Adobe Stock\"\n                }\n            }\n\n    @staticmethod\n    async def fetch(url):\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                return response\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a function that establishes a TCP server which listens for specific termination codes from clients and responds with a predefined byte sequence before shutting down.\n\nFunction Description: The function `makeTerminatingBackend` creates a TCP server that listens for incoming connections. When a client sends data containing specific termination codes (80877103 or 80877104), the server responds with a predefined byte sequence and then closes the connection. The server automatically selects an available port and returns it for external use.\n\nInput: \n- `byte` [String] - The UTF-8 encoded byte sequence to send as a response when a termination code is received.\n\nOutput:\n- `port` [Number] - The port number on which the TCP server is listening. This is dynamically assigned by the system.",
    "Canonical_solution": "function makeTerminatingBackend(byte) {\n  const { createServer } = require('net');\n\n  const server = createServer((socket) => {\n    socket.on('data', (buff) => {\n      const code = buff.readInt32BE(4);\n      if (code === 80877103 || code === 80877104) {\n        const packet = Buffer.from(byte, 'utf-8');\n        socket.write(packet);\n      }\n    });\n    socket.on('close', () => {\n      server.close();\n    });\n  });\n\n  server.listen();\n  const { port } = server.address();\n  return port;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', 0))\n        s.listen()\n        port = s.getsockname()[1]\n        while True:\n            conn, addr = s.accept()\n            with conn:\n                while True:\n                    data = conn.recv(1024)\n                    if not data:\n                        break\n                    if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n                        conn.sendall(bytes(byte, 'utf-8'))\n                        break\n    return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', 0))\n        s.listen()\n        port = s.getsockname()[1]\n        while True:\n            conn, addr = s.accept()\n            with conn:\n                while True:\n                    data = conn.recv(1024)\n                    if not data:\n                        break\n                    if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n                        conn.sendall(bytes(byte, 'utf-8'))\n                        break\n        return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('', 0))\n    server_socket.listen(1)\n    port = server_socket.getsockname()[1]\n    while True:\n        client_socket, addr = server_socket.accept()\n        data = client_socket.recv(1024)\n        if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n            client_socket.sendall(bytes(byte, 'utf-8'))\n            client_socket.close()\n            break\n    server_socket.close()\n    return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('', 0))\n    server_socket.listen(1)\n    port = server_socket.getsockname()[1]\n    while True:\n        client_socket, addr = server_socket.accept()\n        data = client_socket.recv(1024)\n        if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n            client_socket.sendall(bytes(byte, 'utf-8'))\n            client_socket.close()\n            break\n    server_socket.close()\n    return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', 0))\n        s.listen()\n        port = s.getsockname()[1]\n        while True:\n            conn, addr = s.accept()\n            with conn:\n                while True:\n                    data = conn.recv(1024)\n                    if not data:\n                        break\n                    if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n                        conn.sendall(byte.encode('utf-8'))\n                        break\n    return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('', 0))\n    server_socket.listen(1)\n    port = server_socket.getsockname()[1]\n    while True:\n        client_socket, addr = server_socket.accept()\n        data = client_socket.recv(1024)\n        if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n            client_socket.sendall(byte.encode('utf-8'))\n            client_socket.close()\n            break\n    server_socket.close()\n    return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('', 0))\n    server_socket.listen(1)\n    port = server_socket.getsockname()[1]\n    while True:\n        client_socket, addr = server_socket.accept()\n        data = client_socket.recv(1024)\n        if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n            client_socket.sendall(bytes(byte, 'utf-8'))\n            client_socket.close()\n            break\n    server_socket.close()\n    return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', 0))\n        s.listen()\n        port = s.getsockname()[1]\n        while True:\n            conn, addr = s.accept()\n            with conn:\n                while True:\n                    data = conn.recv(1024)\n                    if not data:\n                        break\n                    if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n                        conn.sendall(byte.encode('utf-8'))\n                        break\n    return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('', 0))\n    server_socket.listen(1)\n    port = server_socket.getsockname()[1]\n    while True:\n        client_socket, addr = server_socket.accept()\n        data = client_socket.recv(1024)\n        if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n            client_socket.sendall(bytes(byte, 'utf-8'))\n            client_socket.close()\n            break\n    server_socket.close()\n    return port\n```",
      "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', 0))\n        s.listen()\n        port = s.getsockname()[1]\n        while True:\n            conn, addr = s.accept()\n            with conn:\n                while True:\n                    data = conn.recv(1024)\n                    if not data:\n                        break\n                    if data == b'\\x80\\x87\\x71\\x03' or data == b'\\x80\\x87\\x71\\x04':\n                        conn.sendall(bytes(byte, 'utf-8'))\n                        break\n    return port\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 171,
    "Instruction": "Task Description: Create a TCP-based P2P server class in JavaScript using Node.js's 'net' module and JsonSocket for message handling, capable of managing multiple client connections and processing structured JSON messages.\n\nClass Description: P2PServer is a TCP server implementation that handles peer-to-peer connections, manages client sockets, processes JSON-formatted messages with type-based routing, and provides lifecycle management for the server.\n\nAttributes:\n- tcpServer: [Object] - The underlying TCP server instance created using Node.js 'net' module\n- clients: [Array] - List of currently connected client sockets\n- send: [Function] - Callback function for sending messages (defaults to empty function)\n- messageHandlers: [Object] - Collection of registered message type handlers (implied by the code)\n\nMethods:\n- constructor([send: Function]) -> [P2PServer] - Initializes the TCP server with configuration, sets up connection handling, and prepares message processing infrastructure\n- listen(port: Number) -> [void] - Starts the server listening on the specified port and all network interfaces (0.0.0.0)\n- close() -> [Promise] - Gracefully shuts down the server, disconnects all clients, and returns a Promise that resolves when shutdown is complete\n- on(type: String, callback: Function) -> [void] - Registers a message handler function for a specific message type",
    "Canonical_solution": "const net = require('net');\nconst JsonSocket = require('json-socket');\n\nclass P2PServer {\n    constructor(send = () => {}) {\n        this.tcpServer = net.createServer();\n        this.tcpServer.maxConnections = config.p2pConnections * 2;\n        this.clients = [];\n        this.send = send;\n\n        this.tcpServer.on('connection', (socket) => {\n            if(!config.p2p) {\n                socket.destroy();\n                return;\n            }\n\n            this.tcpServer.getConnections((err, con) => {\n                logT('p2p', 'server connected', con, 'max', this.tcpServer.maxConnections);\n            });\n\n            socket = new JsonSocket(socket);\n            this.clients.push(socket);\n            \n            socket.on('close', () => {\n                this.clients.splice(this.clients.indexOf(socket), 1);\n            });\n            \n            socket.on('error', (err) => {});\n            \n            socket.on('message', (message) => {\n                if(message.type && this.messageHandlers[message.type]) {\n                    if(message.type != 'protocol' && !socket.rats) return;\n                    \n                    this.messageHandlers[message.type](message.data, (data) => {\n                        socket.sendMessage({\n                            id: message.id,\n                            data\n                        });\n                    }, socket, {\n                        version: message.version,\n                        info: message.info\n                    });\n                }\n            });\n            \n            socket.protocolTimeout = setTimeout(() => socket._socket.destroy(), 7000);\n        });\n    }\n\n    listen(port) {\n        this.tcpServer.listen(port, '0.0.0.0');\n    }\n\n    close() {\n        const promise = new Promise(resolve => this.tcpServer.close(resolve));\n        for (const client in this.clients) {\n            this.clients[client]._socket.destroy();\n        }\n        return promise;\n    }\n\n    on(type, callback) {\n        this.messageHandlers[type] = callback;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n    constructor(send = () => {}) {\n        this.tcpServer = net.createServer();\n        this.clients = [];\n        this.send = send;\n        this.messageHandlers = {};\n        this.tcpServer.on('connection', (socket) => {\n            const jsonSocket = new JsonSocket(socket);\n            jsonSocket.on('message', (message) => {\n                const { type } = message;\n                if (this.messageHandlers[type]) {\n                    this.messageHandlers[type](jsonSocket, message);\n                }\n            });\n            this.clients.push(jsonSocket);\n            jsonSocket.on('close', () => {\n                const index = this.clients.indexOf(jsonSocket);\n                if (index !== -1) {\n                    this.clients.splice(index, 1);\n                }\n            });\n        });\n    }\n\n    listen(port) {\n        this.tcpServer.listen(port, '0.0.0.0');\n    }\n\n    close() {\n        return new Promise((resolve) => {\n            this.tcpServer.close(() => {\n                this.clients.forEach((client) => {\n                    client.destroy();\n                });\n                resolve();\n            });\n        });\n    }\n\n    on(type, callback) {\n        this.messageHandlers[type] = callback;\n    }\n}\n```",
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n  constructor(send = () => {}) {\n    this.tcpServer = net.createServer();\n    this.clients = [];\n    this.send = send;\n    this.messageHandlers = {};\n\n    this.tcpServer.on('connection', (socket) => {\n      const jsonSocket = new JsonSocket(socket);\n      jsonSocket.on('message', (message) => {\n        if (this.messageHandlers[message.type]) {\n          this.messageHandlers[message.type](jsonSocket, message);\n        }\n      });\n      this.clients.push(jsonSocket);\n      jsonSocket.on('close', () => {\n        const index = this.clients.indexOf(jsonSocket);\n        if (index !== -1) {\n          this.clients.splice(index, 1);\n        }\n      });\n    });\n  }\n\n  listen(port) {\n    this.tcpServer.listen(port, '0.0.0.0');\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      this.tcpServer.close(() => {\n        this.clients.forEach((client) => {\n          client.destroy();\n        });\n        resolve();\n      });\n    });\n  }\n\n  on(type, callback) {\n    this.messageHandlers[type] = callback;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst JsonSocket = require('jsonsocket');\n\nclass P2PServer {\n  constructor(send = () => {}) {\n    this.tcpServer = net.createServer();\n    this.clients = [];\n    this.send = send;\n    this.messageHandlers = {};\n\n    this.tcpServer.on('connection', (socket) => {\n      const jsonSocket = new JsonSocket(socket);\n      jsonSocket.on('data', (data) => {\n        this.handleMessage(data);\n      });\n      jsonSocket.on('close', () => {\n        const index = this.clients.indexOf(socket);\n        if (index !== -1) {\n          this.clients.splice(index, 1);\n        }\n      });\n      this.clients.push(socket);\n    });\n  }\n\n  listen(port) {\n    return new Promise((resolve, reject) => {\n      this.tcpServer.listen(port, () => {\n        resolve();\n      }).on('error', reject);\n    });\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      this.tcpServer.close(() => {\n        this.clients.forEach((socket) => {\n          socket.destroy();\n        });\n        resolve();\n      });\n    });\n  }\n\n  on(type, callback) {\n    this.messageHandlers[type] = callback;\n  }\n\n  handleMessage(data) {\n    try {\n      const message = JSON.parse(data);\n      const handler = this.messageHandlers[message.type];\n      if (handler) {\n        handler(message, this.send);\n      }\n    } catch (error) {\n      console.error('Error handling message:', error);\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n  constructor(send = () => {}) {\n    this.tcpServer = net.createServer();\n    this.clients = [];\n    this.send = send;\n    this.messageHandlers = {};\n\n    this.tcpServer.on('connection', (socket) => {\n      const jsonSocket = new JsonSocket(socket);\n      jsonSocket.on('message', (message) => {\n        if (this.messageHandlers[message.type]) {\n          this.messageHandlers[message.type](jsonSocket, message);\n        }\n      });\n      this.clients.push(jsonSocket);\n      jsonSocket.on('close', () => {\n        const index = this.clients.indexOf(jsonSocket);\n        if (index !== -1) {\n          this.clients.splice(index, 1);\n        }\n      });\n    });\n  }\n\n  listen(port) {\n    this.tcpServer.listen(port, '0.0.0.0');\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      this.tcpServer.close(() => {\n        this.clients.forEach((client) => {\n          client.destroy();\n        });\n        resolve();\n      });\n    });\n  }\n\n  on(type, callback) {\n    this.messageHandlers[type] = callback;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n  constructor(send = () => {}) {\n    this.tcpServer = net.createServer();\n    this.clients = [];\n    this.send = send;\n    this.messageHandlers = {};\n\n    this.tcpServer.on('connection', (socket) => {\n      const jsonSocket = new JsonSocket(socket);\n      jsonSocket.on('message', (message) => {\n        if (this.messageHandlers[message.type]) {\n          this.messageHandlers[message.type](jsonSocket, message);\n        }\n      });\n      this.clients.push(jsonSocket);\n      jsonSocket.on('close', () => {\n        const index = this.clients.indexOf(jsonSocket);\n        if (index !== -1) {\n          this.clients.splice(index, 1);\n        }\n      });\n    });\n  }\n\n  listen(port) {\n    this.tcpServer.listen(port, '0.0.0.0');\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      this.tcpServer.close(() => {\n        this.clients.forEach((client) => {\n          client.destroy();\n        });\n        resolve();\n      });\n    });\n  }\n\n  on(type, callback) {\n    this.messageHandlers[type] = callback;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n  constructor(send = () => {}) {\n    this.tcpServer = net.createServer();\n    this.clients = [];\n    this.send = send;\n    this.messageHandlers = {};\n\n    this.tcpServer.on('connection', (socket) => {\n      const jsonSocket = new JsonSocket(socket);\n      jsonSocket.on('message', (message) => {\n        const { type } = message;\n        if (this.messageHandlers[type]) {\n          this.messageHandlers[type](jsonSocket, message);\n        }\n      });\n      this.clients.push(jsonSocket);\n      jsonSocket.on('close', () => {\n        const index = this.clients.indexOf(jsonSocket);\n        if (index !== -1) {\n          this.clients.splice(index, 1);\n        }\n      });\n    });\n  }\n\n  listen(port) {\n    this.tcpServer.listen(port, '0.0.0.0');\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      this.tcpServer.close(() => {\n        this.clients.forEach((client) => {\n          client.destroy();\n        });\n        resolve();\n      });\n    });\n  }\n\n  on(type, callback) {\n    this.messageHandlers[type] = callback;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n  constructor(send = () => {}) {\n    this.tcpServer = net.createServer();\n    this.clients = [];\n    this.send = send;\n    this.messageHandlers = {};\n\n    this.tcpServer.on('connection', (socket) => {\n      const jsonSocket = new JsonSocket(socket);\n      jsonSocket.on('message', (message) => {\n        if (this.messageHandlers[message.type]) {\n          this.messageHandlers[message.type](jsonSocket, message);\n        }\n      });\n      this.clients.push(jsonSocket);\n      jsonSocket.on('close', () => {\n        const index = this.clients.indexOf(jsonSocket);\n        if (index !== -1) {\n          this.clients.splice(index, 1);\n        }\n      });\n    });\n  }\n\n  listen(port) {\n    this.tcpServer.listen(port, '0.0.0.0');\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      this.clients.forEach((client) => {\n        client.end();\n      });\n      this.tcpServer.close(() => {\n        resolve();\n      });\n    });\n  }\n\n  on(type, callback) {\n    this.messageHandlers[type] = callback;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n    constructor(send = () => {}) {\n        this.tcpServer = net.createServer();\n        this.clients = [];\n        this.send = send;\n        this.messageHandlers = {};\n        this.tcpServer.on('connection', (socket) => {\n            const jsonSocket = new JsonSocket(socket);\n            jsonSocket.on('message', (message) => {\n                if (this.messageHandlers[message.type]) {\n                    this.messageHandlers[message.type](jsonSocket, message);\n                }\n            });\n            this.clients.push(jsonSocket);\n            jsonSocket.on('close', () => {\n                const index = this.clients.indexOf(jsonSocket);\n                if (index !== -1) {\n                    this.clients.splice(index, 1);\n                }\n            });\n        });\n    }\n\n    listen(port) {\n        this.tcpServer.listen(port, '0.0.0.0');\n    }\n\n    close() {\n        return new Promise((resolve) => {\n            this.clients.forEach((client) => {\n                client.end();\n            });\n            this.tcpServer.close(() => {\n                resolve();\n            });\n        });\n    }\n\n    on(type, callback) {\n        this.messageHandlers[type] = callback;\n    }\n}\n```",
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n  constructor(send = () => {}) {\n    this.tcpServer = net.createServer();\n    this.clients = [];\n    this.send = send;\n    this.messageHandlers = {};\n\n    this.tcpServer.on('connection', (socket) => {\n      const jsonSocket = new JsonSocket(socket);\n      jsonSocket.on('message', (message) => {\n        if (this.messageHandlers[message.type]) {\n          this.messageHandlers[message.type](jsonSocket, message);\n        }\n      });\n      this.clients.push(jsonSocket);\n    });\n  }\n\n  listen(port) {\n    return new Promise((resolve, reject) => {\n      this.tcpServer.listen(port, () => {\n        resolve();\n      }).on('error', reject);\n    });\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      this.tcpServer.close(() => {\n        this.clients.forEach((client) => {\n          client.destroy();\n        });\n        resolve();\n      });\n    });\n  }\n\n  on(type, callback) {\n    this.messageHandlers[type] = callback;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst { JsonSocket } = require('jsonsocket');\n\nclass P2PServer {\n  constructor(send = () => {}) {\n    this.tcpServer = net.createServer();\n    this.clients = [];\n    this.send = send;\n    this.messageHandlers = {};\n    this.tcpServer.on('connection', (socket) => {\n      const jsonSocket = new JsonSocket(socket);\n      jsonSocket.on('message', (message) => {\n        if (this.messageHandlers[message.type]) {\n          this.messageHandlers[message.type](jsonSocket, message);\n        }\n      });\n      this.clients.push(jsonSocket);\n      jsonSocket.on('close', () => {\n        const index = this.clients.indexOf(jsonSocket);\n        if (index !== -1) {\n          this.clients.splice(index, 1);\n        }\n      });\n    });\n  }\n\n  listen(port) {\n    this.tcpServer.listen(port, '0.0.0.0');\n  }\n\n  close() {\n    return new Promise((resolve) => {\n      this.tcpServer.close(() => {\n        this.clients.forEach((client) => {\n          client.destroy();\n        });\n        resolve();\n      });\n    });\n  }\n\n  on(type, callback) {\n    this.messageHandlers[type] = callback;\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module to handle client connections and manage server lifecycle events.\n\nFunction Description: The function creates a TCP server that listens for incoming client connections. When a client connects, the server immediately sends a 'goodbye' message and closes the connection. The server also handles errors by throwing them. Upon successful startup, it logs the server address.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a server instance that listens for connections)",
    "Canonical_solution": "function createTCPServer() {\n    const net = require('net');\n    var server = net.createServer((socket) => {  \n        socket.end('goodbye\\n');  \n    }).on('error', (err) => {  \n        throw err;  \n    });  \n    server.listen(() => {  \n        address = server.address();  \n        console.log('opened server on %j', address);  \n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n}).on('error', (err) => {\n  throw err;\n}).listen(() => {\n  const address = server.address();\n  console.log(`Server listening at ${address.address}:${address.port}`);\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n}).on('error', (err) => {\n  throw err;\n}).listen(() => {\n  const address = server.address();\n  console.log(`Server listening at ${address.address}:${address.port}`);\n});",
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n});\n\nserver.on('error', (err) => {\n  throw err;\n});\n\nserver.listen(0, () => {\n  console.log(`Server listening at ${server.address().port}`);\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n}).on('error', (err) => {\n  throw err;\n}).listen(() => {\n  const address = server.address();\n  console.log(`Server listening at ${address.address}:${address.port}`);\n});",
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n});\n\nserver.on('error', (err) => {\n  throw err;\n});\n\nserver.listen(0, () => {\n  console.log(`Server listening at ${server.address().port}`);\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n}).on('error', (err) => {\n  throw err;\n}).listen(() => {\n  const address = server.address();\n  console.log(`Server listening at ${address.address}:${address.port}`);\n});",
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n});\n\nserver.on('error', (err) => {\n  throw err;\n});\n\nserver.listen(0, () => {\n  console.log(`Server listening at ${server.address().port}`);\n});",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n}).on('error', (err) => {\n  throw err;\n}).listen(() => {\n  const address = server.address();\n  console.log(`Server listening at ${address.address}:${address.port}`);\n});",
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n});\n\nserver.on('error', (err) => {\n  throw err;\n});\n\nserver.listen(0, () => {\n  console.log(`Server listening at ${server.address().port}`);\n});",
      "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.write('goodbye');\n  socket.end();\n});\n\nserver.on('error', (err) => {\n  throw err;\n});\n\nserver.listen(0, () => {\n  console.log(`Server listening at ${server.address().port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Create a TCP server implementation for handling IMAP (Internet Message Access Protocol) connections with optional TLS/SSL security support.\n\nClass Description: IMAPServer is a class that implements a TCP server for IMAP protocol connections. It supports both plain and TLS/SSL encrypted connections, handles client connections, and manages server lifecycle events.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- server: [net.Server] - The underlying TCP server instance\n- connections: [Set] - Active client connections\n- _closeTimeout: [Timeout] - Timer for server shutdown operations\n\nMethods:\n- constructor(options) -> [IMAPServer] - Initializes the server with configuration options and sets up event listeners\n- connect(socket, socketOptions) -> [void] - Creates a new IMAPConnection for a client socket\n- listen(...args) -> [void] - Starts the server listening on specified port/address\n- close(callback) -> [void] - Gracefully shuts down the server\n- _setListeners() -> [void] - Sets up server event listeners\n- _onListening() -> [void] - Handles server 'listening' event\n- _onClose() -> [void] - Handles server 'close' event\n- _onError(err) -> [void] - Handles server 'error' event\n- _handleProxy(socket, callback) -> [void] - Handles proxy protocol if needed\n- _upgrade(socket, callback) -> [void] - Upgrades a connection to TLS/SSL",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass IMAPServer {\n    constructor(options) {\n        this.options = options || {};\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                socket.setKeepAlive(true, 5 * 1000);\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket =>\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    socket.setKeepAlive(true, 5 * 1000);\n                    this.connect(socket, socketOptions);\n                })\n            );\n        }\n\n        this._setListeners();\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new IMAPConnection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.on('error', this._onError.bind(this));\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            clearTimeout(this._closeTimeout);\n            callback();\n        });\n    }\n\n    _setListeners() {\n        this.server.on('listening', this._onListening.bind(this));\n        this.server.on('close', this._onClose.bind(this));\n        this.server.on('error', this._onError.bind(this));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    _handleProxy(socket, callback) {\n        let socketOptions = {\n            id: base32.encode(crypto.randomBytes(10)).toLowerCase()\n        };\n        return setImmediate(() => callback(null, socketOptions));\n    }\n\n    _upgrade(socket, callback) {\n        let socketOptions = {\n            secureContext: this.secureContext.get('*'),\n            isServer: true,\n            server: this.server\n        };\n\n        let tlsSocket = new tls.TLSSocket(socket, socketOptions);\n        tlsSocket.on('secure', () => {\n            return callback(null, tlsSocket);\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\nconst fs = require('fs');\nconst tls = require('tls');\nconst { promisify } = require('util');\nconst setTimeoutPromise = promisify(setTimeout);\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this.connections.forEach(connection => connection.close());\n      this._onClose();\n      callback();\n    });\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket) => {\n      this.connect(socket, this.options);\n    });\n\n    this.server.on('listening', () => {\n      this._onListening();\n    });\n\n    this.server.on('close', () => {\n      this._onClose();\n    });\n\n    this.server.on('error', (err) => {\n      this._onError(err);\n    });\n  }\n\n  _onListening() {\n    console.log('Server is listening');\n  }\n\n  _onClose() {\n    console.log('Server closed');\n  }\n\n  _onError(err) {\n    console.error('Server error:', err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const options = {\n      key: fs.readFileSync(this.options.tlsKey),\n      cert: fs.readFileSync(this.options.tlsCert),\n      ca: this.options.tlsCa\n    };\n\n    const secureSocket = tls.connect(options, () => {\n      secureSocket.pipe(socket).pipe(secureSocket);\n      callback();\n    });\n\n    socket.on('end', () => {\n      secureSocket.end();\n    });\n\n    socket.on('error', (err) => {\n      secureSocket.end();\n      callback(err);\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { promisify } = require('util');\nconst setTimeout = promisify(setTimeout);\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => this._onListening());\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this.connections.forEach(connection => connection.close());\n      if (this._closeTimeout) clearTimeout(this._closeTimeout);\n      callback();\n    });\n  }\n\n  _setListeners() {\n    this.server.on('listening', () => this._onListening());\n    this.server.on('close', () => this._onClose());\n    this.server.on('error', (err) => this._onError(err));\n  }\n\n  _onListening() {\n    console.log('Server is listening');\n  }\n\n  _onClose() {\n    console.log('Server closed');\n  }\n\n  _onError(err) {\n    console.error('Server error:', err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const options = this.options.tlsOptions;\n    const secureSocket = tls.connect(options, socket);\n    secureSocket.on('secureConnect', () => {\n      callback(secureSocket);\n    });\n  }\n}\n\nclass IMAPConnection {\n  constructor(socket, socketOptions, server) {\n    this.socket = socket;\n    this.server = server;\n    this.socket.on('data', (data) => {\n      // Handle incoming data\n    });\n    this.socket.on('end', () => {\n      this.server.connections.delete(this);\n      // Connection end logic\n    });\n    this.socket.on('error', (err) => {\n      // Connection error logic\n    });\n    this.server._handleProxy(socket, (proxySocket) => {\n      this.socket = proxySocket;\n      this.server._upgrade(this.socket, callback);\n    });\n  }\n\n  close() {\n    this.socket.end();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { setTimeout, clearTimeout } = require('timers');\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this.connections.forEach(connection => connection.close());\n      this._onClose();\n      callback();\n    });\n    this._closeTimeout = setTimeout(() => {\n      this.server.close();\n    }, this.options.closeTimeout || 5000);\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket, socketOptions) => {\n      this.connect(socket, socketOptions);\n    });\n    this.server.on('listening', () => {\n      this._onListening();\n    });\n    this.server.on('close', () => {\n      this._onClose();\n    });\n    this.server.on('error', (err) => {\n      this._onError(err);\n    });\n  }\n\n  _onListening() {\n    console.log('Server is listening');\n  }\n\n  _onClose() {\n    console.log('Server closed');\n  }\n\n  _onError(err) {\n    console.error('Server error:', err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const secureContext = tls.createSecureContext(this.options.tlsOptions);\n    const secureSocket = secureContext.wrapSocket(socket);\n    secureSocket.on('secureConnect', () => {\n      callback(null, secureSocket);\n    });\n    secureSocket.on('error', (err) => {\n      callback(err);\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { setTimeout, clearTimeout } = require('timers');\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this._onClose();\n      callback();\n    });\n    this._closeTimeout = setTimeout(() => {\n      this.server.close();\n    }, this.options.closeTimeout || 5000);\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket) => {\n      this.connect(socket, this.options.socketOptions);\n    });\n    this.server.on('listening', () => {\n      this._onListening();\n    });\n    this.server.on('close', () => {\n      this._onClose();\n    });\n    this.server.on('error', (err) => {\n      this._onError(err);\n    });\n  }\n\n  _onListening() {\n    console.log('Server is listening');\n  }\n\n  _onClose() {\n    console.log('Server closed');\n  }\n\n  _onError(err) {\n    console.error('Server error:', err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const secureContext = tls.createSecureContext(this.options.tlsOptions);\n    const secureSocket = secureContext.wrapSocket(socket, false);\n    secureSocket.on('secureConnect', () => {\n      callback(secureSocket);\n    });\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { setTimeout } = require('timers');\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this._onClose();\n      callback();\n    });\n    this._closeTimeout = setTimeout(() => {\n      this.server.close();\n    }, this.options.closeTimeout || 5000);\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {}\n\n  _onClose() {\n    clearTimeout(this._closeTimeout);\n    this.connections.forEach(connection => connection.close());\n  }\n\n  _onError(err) {\n    console.error(err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const secureContext = tls.createSecureContext(this.options.tlsOptions);\n    const secureSocket = secureContext.wrapSocket(socket);\n    callback(secureSocket);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { setTimeout } = require('timers');\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this.connections.forEach(connection => connection.close());\n      this._onClose();\n      callback();\n    });\n    this._closeTimeout = setTimeout(() => {\n      this.server.close();\n    }, this.options.closeTimeout || 1000);\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket, socketOptions) => {\n      this.connect(socket, socketOptions);\n    });\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {}\n\n  _onClose() {\n    clearTimeout(this._closeTimeout);\n  }\n\n  _onError(err) {\n    console.error(err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const secureContext = tls.createSecureContext(this.options.tlsOptions);\n    const secureSocket = secureContext.wrapSocket(socket);\n    secureSocket.on('secureConnect', () => {\n      callback(secureSocket);\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { setTimeout } = require('timers');\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this._onClose();\n      callback();\n    });\n    this._closeTimeout = setTimeout(() => {\n      this.server.close();\n    }, this.options.closeTimeout || 5000);\n  }\n\n  _setListeners() {\n    this.server.on('listening', () => this._onListening());\n    this.server.on('close', () => this._onClose());\n    this.server.on('error', (err) => this._onError(err));\n  }\n\n  _onListening() {}\n\n  _onClose() {\n    clearTimeout(this._closeTimeout);\n  }\n\n  _onError(err) {\n    console.error('Server error:', err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const secureContext = tls.createSecureContext(this.options.tlsOptions);\n    const secureSocket = secureContext.wrapSocket(socket, false);\n    callback(secureSocket);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { setTimeout } = require('timers');\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this._onClose();\n      callback();\n    });\n    this._closeTimeout = setTimeout(() => {\n      this.server.close();\n    }, this.options.closeTimeout || 5000);\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket) => {\n      this.connect(socket, this.options.socketOptions);\n    });\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {}\n\n  _onClose() {\n    clearTimeout(this._closeTimeout);\n    this.connections.forEach((connection) => {\n      connection.close();\n    });\n  }\n\n  _onError(err) {\n    console.error(err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const secureContext = tls.createSecureContext(this.options.tlsOptions);\n    const secureSocket = secureContext.wrapSocket(socket);\n    callback(secureSocket);\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { setTimeout } = require('timers');\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args);\n    this._setListeners();\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this.connections.forEach(conn => conn.close());\n      if (this._closeTimeout) {\n        clearTimeout(this._closeTimeout);\n      }\n      callback();\n    });\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket) => {\n      this.connect(socket, this.options);\n      this._handleProxy(socket, () => {\n        if (this.options.tls) {\n          this._upgrade(socket, () => {});\n        }\n      });\n    });\n\n    this.server.on('listening', this._onListening);\n    this.server.on('close', this._onClose);\n    this.server.on('error', this._onError);\n  }\n\n  _onListening() {}\n\n  _onClose() {}\n\n  _onError(err) {}\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n    callback();\n  }\n\n  _upgrade(socket, callback) {\n    const secureSocket = tls.connect({\n      socket: socket,\n      ...this.options.tls\n    }, () => {\n      callback();\n    });\n    secureSocket.on('data', (data) => {\n      // Handle encrypted data\n    });\n  }\n}\n\nclass IMAPConnection {\n  constructor(socket, socketOptions) {\n    this.socket = socket;\n    // Additional connection setup\n  }\n\n  close() {\n    this.socket.destroy();\n  }\n}\n```",
      "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst { setTimeout } = require('timers');\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n  }\n\n  connect(socket, socketOptions) {\n    const imapConnection = new IMAPConnection(socket, socketOptions, this);\n    this.connections.add(imapConnection);\n  }\n\n  listen(...args) {\n    this.server.listen(...args, () => {\n      this._onListening();\n    });\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this._onClose();\n      callback();\n    });\n    this._closeTimeout = setTimeout(() => {\n      this.server.close();\n    }, this.options.closeTimeout || 5000);\n  }\n\n  _setListeners() {\n    this.server.on('connection', (socket) => {\n      this.connect(socket, this.options);\n    });\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n  }\n\n  _onListening() {}\n\n  _onClose() {\n    clearTimeout(this._closeTimeout);\n  }\n\n  _onError(err) {\n    console.error(err);\n  }\n\n  _handleProxy(socket, callback) {\n    // Proxy protocol handling logic\n  }\n\n  _upgrade(socket, callback) {\n    const secureContext = tls.createSecureContext(this.options.tlsOptions);\n    const secureSocket = secureContext.wrapSocket(socket);\n    callback(secureSocket);\n  }\n}\n```"
    ],
    "match_count": 4,
    "pass@3": 0.8333333333333334,
    "pass@5": 0.9761904761904762
  },
  {
    "Task_id": 174,
    "Instruction": "Task Description: Create a TCP server function that listens on a specified port and responds to client connections with the current timestamp.\n\nFunction Description: The function creates a TCP server using Node.js's built-in 'net' module. When a client connects, the server sends the current timestamp and closes the connection. The server listens on the specified port or a random available port if none is provided.\n\nInput: \n- port: [Number] - (Optional) The port number on which the TCP server should listen. If not provided or 0, the OS will assign a random available port.\n\nOutput: \n- None (The function creates and starts a TCP server but doesn't return anything)",
    "Canonical_solution": "function createTCPServer(port) {\n  require('net').createServer(function (socket) {\n    socket.end(now(new Date()) + '\\n');\n  }).listen(port | 0);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(timestamp);\n    socket.end();\n  });\n\n  server.listen(port || 0, () => {\n    const { address, port: assignedPort } = server.address();\n    console.log(`Server listening on ${address}:${assignedPort}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(timestamp);\n    socket.end();\n  });\n\n  server.listen(port || 0, () => {\n    const { address, port: assignedPort } = server.address();\n    console.log(`Server listening on ${address}:${assignedPort}`);\n  });\n}\n```",
      "const net = require('net');\nconst os = require('os');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(timestamp);\n    socket.end();\n  });\n\n  const portToUse = port || 0;\n  server.listen(portToUse, () => {\n    if (portToUse === 0) {\n      console.log(`Server listening on port ${server.address().port}`);\n    }\n  });\n}",
      "```javascript\nconst net = require('net');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(timestamp);\n    socket.end();\n  });\n\n  server.listen(port || 0, () => {\n    const { address, port: assignedPort } = server.address();\n    console.log(`Server listening on ${address}:${assignedPort}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(timestamp);\n    socket.end();\n  });\n\n  server.listen(port || 0, () => {\n    const { port } = server.address();\n    console.log(`Server listening on port ${port}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(new Date().toISOString());\n    socket.end();\n  });\n\n  server.listen(port || 0, () => {\n    const { address, port: assignedPort } = server.address();\n    console.log(`Server listening at ${address}:${assignedPort}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(timestamp);\n    socket.end();\n  });\n\n  server.listen(port || 0, () => {\n    const { address, port: assignedPort } = server.address();\n    console.log(`Server listening on ${address}:${assignedPort}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(timestamp);\n    socket.end();\n  });\n\n  server.listen(port || 0, () => {\n    const { port } = server.address();\n    console.log(`Server listening on port ${port}`);\n  });\n}\n```",
      "```javascript\nconst net = require('net');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = new Date().toISOString();\n    socket.write(timestamp);\n    socket.end();\n  });\n\n  const portToUse = port || 0;\n  server.listen(portToUse, () => {\n    if (portToUse === 0) {\n      console.log(`Server listening on port ${server.address().port}`);\n    }\n  });\n}\n```",
      "const net = require('net');\nconst os = require('os');\n\nfunction createTCPServer(port) {\n  const server = net.createServer((socket) => {\n    const timestamp = os.time();\n    socket.write(timestamp.toString());\n    socket.end();\n  });\n\n  const portToUse = port || 0;\n  server.listen(portToUse, () => {\n    if (portToUse === 0) {\n      console.log(`Server listening on port ${server.address().port}`);\n    }\n  });\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module to handle client connections, manage socket communication, and process incoming messages.\n\nClass Description: The TcpReader class is responsible for establishing a TCP server, managing client connections, handling socket events, and processing incoming messages through a custom parser. It provides methods to start/stop the server and manage connected clients.\n\nAttributes:\n- transporter: [Object] - The parent transporter object that handles incoming messages\n- opts: [Object] - Configuration options including the port to listen on\n- sockets: [Array] - Array of currently connected client sockets\n- logger: [Object] - Logger instance from the transporter for error logging\n- server: [Object] - The TCP server instance\n- connected: [Boolean] - Flag indicating if the server is currently listening\n\nMethods:\n- constructor(transporter, opts) -> [void] - Initializes the TcpReader with transporter and options\n- listen() -> [Promise] - Starts the TCP server and begins listening for connections\n- onTcpClientConnected(socket) -> [void] - Handles new client connections and sets up event listeners\n- closeSocket(socket, err) -> [void] - Closes and removes a specific socket from the connections\n- close() -> [void] - Stops the server and closes all connected sockets",
    "Canonical_solution": "const net = require(\"net\");\n\nclass TcpReader {\n    constructor(transporter, opts) {\n        this.transporter = transporter;\n        this.opts = opts;\n        this.sockets = [];\n        this.logger = transporter.logger;\n    }\n\n    listen() {\n        return new Promise((resolve, reject) => {\n            this.server = net.createServer(socket => {\n                this.onTcpClientConnected(socket);\n            });\n\n            this.server.on(\"error\", err => {\n                reject(err);\n            });\n\n            const listenOptions = process.versions.node.split(\".\")[0] >= 8 \n                ? { port: this.opts.port, exclusive: true }\n                : this.opts.port;\n\n            this.server.listen(listenOptions, () => {\n                this.opts.port = this.server.address().port;\n                this.connected = true;\n                resolve();\n            });\n        });\n    }\n\n    onTcpClientConnected(socket) {\n        socket.on(\"error\", err => {\n            this.closeSocket(socket, err);\n        });\n\n        socket.on(\"close\", () => {\n            this.closeSocket(socket);\n        });\n\n        socket.setNoDelay(true);\n\n        const parser = require(\"../../../../src/transporters/tcp/parser\")();\n        socket.pipe(parser);\n\n        parser.on(\"data\", (type, message) => {\n            this.transporter.onIncomingMessage(type, message, socket);\n        });\n\n        parser.on(\"error\", err => {\n            this.closeSocket(socket, err);\n        });\n\n        this.sockets.push(socket);\n    }\n\n    closeSocket(socket, err) {\n        if (err) {\n            this.logger.warn(`TCP socket error: ${err.message}`);\n        }\n\n        const index = this.sockets.indexOf(socket);\n        if (index !== -1) {\n            this.sockets.splice(index, 1);\n            socket.destroy();\n        }\n    }\n\n    close() {\n        if (this.server && this.server.listening) {\n            this.server.close();\n        }\n\n        this.sockets.forEach(socket => {\n            socket.destroy();\n        });\n        this.sockets = [];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer((socket) => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', (err) => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', (err) => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => socket.destroy());\n      this.sockets = [];\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.sockets.forEach(socket => {\n      socket.destroy();\n    });\n    this.server.close(() => {\n      this.server = null;\n    });\n  }\n\n  processMessage(data) {\n    // Custom message processing logic\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => {\n        socket.destroy();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => {\n        socket.destroy();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => {\n        socket.destroy();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => {\n        socket.destroy();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => {\n        socket.destroy();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error('Server error:', err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error('Socket error:', err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => {\n        socket.destroy();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => {\n        socket.destroy();\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer(socket => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.server.on('error', err => {\n        this.logger.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', data => {\n      this.transporter.processMessage(data);\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n    });\n\n    socket.on('error', err => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy();\n    if (err) {\n      this.logger.error(err);\n    }\n  }\n\n  close() {\n    this.connected = false;\n    this.server.close(() => {\n      this.sockets.forEach(socket => {\n        socket.destroy();\n      });\n    });\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Create a TCP server class that intercepts Redis traffic, capable of operating in different modes (capture, test, or forward), with functionality to save, mock, or forward data between client and Redis server.\n\nClass Description: RedisInterceptor is a class that creates a TCP server to intercept Redis protocol traffic. It can operate in three modes: capture (save request/response pairs), test (respond with mocked data), or forward (pass through traffic unchanged). The class handles client connections, data forwarding, and response processing.\n\nAttributes:\n- Pythagora: [Object] - Reference to the parent Pythagora object for saving captured data\n- listenPort: [Number] - Port number on which the interceptor listens for client connections\n- targetPort: [Number] - Port number of the target Redis server (default: 6379)\n- intermediateData: [Array] - Array containing mocked request/response pairs for test mode\n- listenSocket: [Object] - Reference to the net.Server instance\n- targetSocket: [Object] - Reference to the net.Socket connection to Redis\n- mode: [String] - Current operation mode ('capture', 'test', or undefined for forward)\n\nMethods:\n- constructor(Pythagora, listenPort, targetPort, intermediateData) -> [RedisInterceptor] - Initializes the interceptor with configuration parameters\n- init() -> [Promise] - Asynchronously creates and starts the TCP server, resolving when listening\n- forwardData(connection, data, saveData) -> [undefined] - Forwards data to Redis server and handles response, optionally saving it\n- splitIntoChunks(str, chunkSize) -> [Array] - Helper method to split strings into chunks of specified size\n\nNote: The class assumes the existence of constants MODES (for operation modes) and CHUNK_SIZE (for response chunking) which should be defined elsewhere in the code.",
    "Canonical_solution": "const net = require('net');\n\nclass RedisInterceptor {\n    constructor(Pythagora, listenPort, targetPort, intermediateData) {\n        this.Pythagora = Pythagora;\n        this.listenPort = listenPort;\n        this.targetPort = targetPort || 6379;\n        this.intermediateData = intermediateData || [];\n    }\n\n    async init() {\n        await new Promise((resolve, reject) => {\n            this.listenSocket = net.createServer(connection => {\n                connection.on('data', data => {\n                    if (this.mode === MODES.capture) {\n                        this.forwardData(connection, data, true);\n                    } else if (this.mode === 'test') {\n                        let mockData = this.intermediateData.find(d => d.type === 'redis' && d.request === data.toString());\n                        if (mockData) {\n                            const chunks = this.splitIntoChunks(mockData.response, CHUNK_SIZE);\n                            chunks.forEach(chunk => connection.write(`+${chunk}\\r\\n`, 'utf8'));\n                        } else {\n                            this.forwardData(connection, data);\n                        }\n                    } else {\n                        this.forwardData(connection, data);\n                    }\n                });\n            });\n\n            this.listenSocket.listen(this.listenPort, () => {\n                resolve();\n            });\n        });\n    }\n\n    forwardData(connection, data, saveData) {\n        this.targetSocket = new net.Socket();\n        this.targetSocket.connect(this.targetPort, 'localhost', () => {\n            this.targetSocket.write(data);\n        });\n\n        this.targetSocket.on('data', response => {\n            if (saveData) Pythagora.saveRedisData(data.toString(), response.toString().replace(/^.*\\r\\n/, '').replace(/\\r\\n$/, ''));\n            connection.write(response);\n        });\n    }\n\n    splitIntoChunks(str, chunkSize) {\n        const chunks = [];\n        for (let i = 0; i < str.length; i += chunkSize) {\n            chunks.push(str.substring(i, i + chunkSize));\n        }\n        return chunks;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport asyncio\nimport net\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora, listenPort, targetPort=6379, intermediateData=None):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort\n        self.intermediateData = intermediateData or []\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self):\n        self.listenSocket = net.Server()\n        await self.listenSocket.listen(self.listenPort)\n        self.mode = 'forward'  # Default mode\n        return self.listenSocket\n\n    def forwardData(self, connection, data, saveData=False):\n        self.targetSocket.sendall(data)\n        response = self.targetSocket.recv(1024)\n        if saveData:\n            self.Pythagora.saveData(data, response)\n        connection.sendall(response)\n\n    def splitIntoChunks(self, str, chunkSize):\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n```",
      "```python\nimport asyncio\nimport net\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora, listenPort, targetPort=6379, intermediateData=None):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort\n        self.intermediateData = intermediateData or []\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self):\n        self.listenSocket = net.Server()\n        await self.listenSocket.listen(self.listenPort)\n        self.mode = await self.listenSocket.accept()\n\n    def forwardData(self, connection, data, saveData=False):\n        self.targetSocket = net.Socket()\n        self.targetSocket.connect(self.targetPort)\n        self.targetSocket.send(data)\n        response = self.targetSocket.recv()\n        if saveData:\n            self.Pythagora.saveData(data, response)\n        connection.send(response)\n\n    def splitIntoChunks(self, str, chunkSize):\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n```",
      "```python\nimport asyncio\nimport net\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora, listenPort, targetPort, intermediateData):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort or 6379\n        self.intermediateData = intermediateData\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self):\n        self.listenSocket = await net.createServer(self.handleConnection)\n        await self.listenSocket.listen(self.listenPort)\n\n    def handleConnection(self, connection):\n        asyncio.create_task(self.forwardData(connection, None, False))\n\n    async def forwardData(self, connection, data, saveData):\n        if self.mode == 'capture':\n            await self.saveData(data)\n        elif self.mode == 'test':\n            await self.testData(connection, data)\n        else:\n            await self.forwardToRedis(connection, data, saveData)\n\n    async def saveData(self, data):\n        # Save data to Pythagora object\n        pass\n\n    async def testData(self, connection, data):\n        # Respond with mocked data\n        pass\n\n    async def forwardToRedis(self, connection, data, saveData):\n        if data:\n            await self.targetSocket.sendall(data)\n            response = await self.targetSocket.recvall()\n            if saveData:\n                await self.saveData(response)\n            await connection.sendall(response)\n\n    def splitIntoChunks(self, str, chunkSize):\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n\n# Constants\nMODES = ['capture', 'test', 'forward']\nCHUNK_SIZE = 1024\n```",
      "```python\nimport asyncio\nimport net\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora, listenPort, targetPort, intermediateData):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort or 6379\n        self.intermediateData = intermediateData\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self):\n        self.listenSocket = await net.createServer(self.handleConnection)\n        await self.listenSocket.listen(self.listenPort)\n\n    def handleConnection(self, connection):\n        asyncio.create_task(self.forwardData(connection, None, False))\n\n    async def forwardData(self, connection, data, saveData):\n        if self.mode == 'capture':\n            await self.saveData(data)\n        elif self.mode == 'test':\n            await self.testMode(connection, data)\n        else:\n            await self.forwardToRedis(connection, data, saveData)\n\n    async def saveData(self, data):\n        # Save data to Pythagora object\n        pass\n\n    async def testMode(self, connection, data):\n        # Respond with mocked data\n        pass\n\n    async def forwardToRedis(self, connection, data, saveData):\n        if data:\n            await self.targetSocket.sendall(data)\n            response = await self.targetSocket.recvall()\n            if saveData:\n                await self.saveData(response)\n            await connection.sendall(response)\n\n    def splitIntoChunks(self, str, chunkSize):\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n\n    MODES = ['capture', 'test', 'forward']\n    CHUNK_SIZE = 1024\n```",
      "```python\nimport socket\nimport threading\nimport json\nfrom typing import Any, List, Tuple\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora: Any, listenPort: int, targetPort: int = 6379, intermediateData: List[Tuple[str, str]] = []):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort\n        self.intermediateData = intermediateData\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self) -> None:\n        self.listenSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.listenSocket.bind(('', self.listenPort))\n        self.listenSocket.listen()\n        self.mode = 'forward'  # Default mode\n        await self.handle_connections()\n\n    def forwardData(self, connection: socket.socket, data: bytes, saveData: bool = False) -> None:\n        self.targetSocket.sendall(data)\n        response = self.targetSocket.recv(1024)\n        connection.sendall(response)\n        if saveData:\n            self.Pythagora.save_data(data, response)\n\n    def splitIntoChunks(self, str: str, chunkSize: int) -> List[str]:\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n\n    async def handle_connections(self) -> None:\n        while True:\n            clientConnection, clientAddress = self.listenSocket.accept()\n            threading.Thread(target=self.handle_client, args=(clientConnection,)).start()\n\n    def handle_client(self, clientConnection: socket.socket) -> None:\n        data = b''\n        while True:\n            chunk = clientConnection.recv(1024)\n            if not chunk:\n                break\n            data += chunk\n            if self.mode == 'capture':\n                self.Pythagora.save_data(chunk, b'')\n            elif self.mode == 'test':\n                for request, response in self.intermediateData:\n                    if request in data.decode():\n                        clientConnection.sendall(response.encode())\n                        break\n            elif self.mode == 'forward':\n                self.forwardData(clientConnection, chunk)\n        clientConnection.close()\n```",
      "```python\nimport asyncio\nimport net\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora, listenPort, targetPort, intermediateData):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort if targetPort else 6379\n        self.intermediateData = intermediateData\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self):\n        self.listenSocket = await net.createServer(self.handleConnection)\n        await self.listenSocket.listen(self.listenPort)\n\n    def handleConnection(self, connection):\n        asyncio.create_task(self.forwardData(connection, None, False))\n\n    async def forwardData(self, connection, data, saveData):\n        if self.mode == 'capture':\n            await self.saveData(data)\n        elif self.mode == 'test':\n            await self.testData(connection, data)\n        elif self.mode == 'forward':\n            await self.forwardToRedis(connection, data, saveData)\n\n    def splitIntoChunks(self, str, chunkSize):\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n\n    async def saveData(self, data):\n        # Save data to Pythagora object\n        pass\n\n    async def testData(self, connection, data):\n        # Respond with mocked data\n        pass\n\n    async def forwardToRedis(self, connection, data, saveData):\n        # Forward data to Redis server and handle response\n        pass\n```",
      "```python\nimport asyncio\nimport net\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora, listenPort, targetPort, intermediateData):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort or 6379\n        self.intermediateData = intermediateData\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self):\n        self.listenSocket = await net.createServer(self.handleConnection)\n        await self.listenSocket.listen(self.listenPort)\n\n    def handleConnection(self, connection):\n        asyncio.create_task(self.forwardData(connection, None, False))\n\n    async def forwardData(self, connection, data, saveData):\n        if self.mode == 'capture':\n            self.Pythagora.saveData(data)\n        elif self.mode == 'test':\n            response = self.intermediateData[0]\n            connection.write(response)\n        else:\n            self.targetSocket = await net.connect(self.targetPort)\n            await self.targetSocket.write(data)\n            response = await self.targetSocket.read()\n            connection.write(response)\n            if saveData:\n                self.Pythagora.saveData(data + response)\n\n    def splitIntoChunks(self, str, chunkSize):\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n```",
      "```python\nimport asyncio\nimport net\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora, listenPort, targetPort, intermediateData):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort if targetPort else 6379\n        self.intermediateData = intermediateData\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self):\n        self.listenSocket = net.Server()\n        await self.listenSocket.listen(self.listenPort)\n        self.mode = await self.listenSocket.accept()\n\n    def forwardData(self, connection, data, saveData):\n        self.targetSocket = net.Socket()\n        self.targetSocket.connect(self.targetPort)\n        self.targetSocket.send(data)\n        response = self.targetSocket.recv()\n        if saveData:\n            self.Pythagora.saveData(data, response)\n        connection.send(response)\n\n    def splitIntoChunks(self, str, chunkSize):\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n```",
      "```python\nimport socket\nimport select\nimport json\nfrom typing import Any, List, Tuple\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora: Any, listenPort: int, targetPort: int = 6379, intermediateData: List[Tuple[str, str]] = []):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort\n        self.intermediateData = intermediateData\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self) -> Any:\n        self.listenSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.listenSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.listenSocket.bind(('', self.listenPort))\n        self.listenSocket.listen()\n        self.mode = 'forward'  # Default mode\n        return self.listenSocket\n\n    def forwardData(self, connection: Any, data: str, saveData: bool = False) -> None:\n        if self.mode == 'capture' and saveData:\n            self.Pythagora.save(data)\n        elif self.mode == 'test':\n            for mock_data in self.intermediateData:\n                if data.startswith(mock_data[0]):\n                    connection.sendall(mock_data[1].encode())\n                    return\n        self.targetSocket.sendall(data.encode())\n        response = self.targetSocket.recv(1024)\n        if self.mode == 'capture' and saveData:\n            self.Pythagora.save(response.decode())\n        connection.sendall(response)\n\n    def splitIntoChunks(self, str: str, chunkSize: int) -> List[str]:\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n\n    def handleClient(self, connection: Any) -> None:\n        data = b''\n        while True:\n            chunk = connection.recv(1024)\n            if not chunk:\n                break\n            data += chunk\n            while b'\\r\\n' in data:\n                request, _, response = data.partition(b'\\r\\n\\r\\n')\n                self.forwardData(connection, request.decode(), saveData=(self.mode == 'capture'))\n                data = response + b'\\r\\n'\n        connection.close()\n\n    def startServer(self) -> None:\n        self.targetSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.targetSocket.connect(('', self.targetPort))\n        while True:\n            readable, _, _ = select.select([self.listenSocket, self.targetSocket], [], [])\n            for s in readable:\n                if s is self.listenSocket:\n                    client, _ = self.listenSocket.accept()\n                    client.setblocking(0)\n                    self.handleClient(client)\n                elif s is self.targetSocket:\n                    data = self.targetSocket.recv(1024)\n                    if not data:\n                        break\n                    self.forwardData(self.listenSocket, data.decode())\n```",
      "```python\nimport socket\nimport asyncio\nimport json\n\nclass RedisInterceptor:\n    def __init__(self, Pythagora, listenPort, targetPort=6379, intermediateData=None):\n        self.Pythagora = Pythagora\n        self.listenPort = listenPort\n        self.targetPort = targetPort\n        self.intermediateData = intermediateData or []\n        self.listenSocket = None\n        self.targetSocket = None\n        self.mode = None\n\n    async def init(self):\n        self.listenSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.listenSocket.bind(('', self.listenPort))\n        self.listenSocket.listen()\n        await asyncio.sleep(0)  # Allow the server to start\n\n    async def handle_client(self, clientSocket):\n        data = b''\n        while True:\n            chunk = await clientSocket.recv(1024)\n            if not chunk:\n                break\n            data += chunk\n            while b'\\r\\n' in data:\n                request, data = data.split(b'\\r\\n', 1)\n                if self.mode == 'capture':\n                    self.Pythagora.save(request.decode(), data.decode())\n                elif self.mode == 'test':\n                    response = self.mock_response(request.decode())\n                    await clientSocket.sendall(response.encode() + b'\\r\\n')\n                elif self.mode == 'forward':\n                    await self.forward_data(clientSocket, request, False)\n                    response = await self.targetSocket.recv(1024)\n                    await clientSocket.sendall(response)\n        clientSocket.close()\n\n    async def forward_data(self, clientSocket, data, saveData):\n        self.targetSocket.sendall(data)\n        if saveData:\n            response = b''\n            while b'\\r\\n' in response:\n                response, _ = response.split(b'\\r\\n', 1)\n                self.Pythagora.save(data.decode(), response.decode())\n            return response\n        else:\n            return await self.targetSocket.recv(1024)\n\n    def mock_response(self, request):\n        for req, resp in self.intermediateData:\n            if req == request:\n                return resp\n        return b'OK\\r\\n'\n\n    def splitIntoChunks(self, str, chunkSize):\n        return [str[i:i + chunkSize] for i in range(0, len(str), chunkSize)]\n\n    async def run(self):\n        await self.init()\n        while True:\n            clientSocket, addr = await self.listenSocket.accept()\n            asyncio.create_task(self.handle_client(clientSocket))\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Create a TCP server in Node.js that listens on a specified port and handles incoming client connections, data, and disconnections.\n\nFunction Description: The function `createTCPServer` initializes a TCP server using Node.js's built-in `net` module. It sets up event handlers for incoming data and client disconnections, and starts listening on the specified port. The server pipes incoming data to the provided data handler.\n\nInput:\n- `port` [Number] - The port number on which the TCP server should listen.\n- `dataHandler` [Function] - A callback function to handle incoming data from clients. It receives the data as its argument.\n- `endHandler` [Function] - A callback function to handle client disconnections. It is called when a client disconnects.\n\nOutput:\n- Returns the TCP server instance [Object] - The created TCP server object, which can be used to further control the server (e.g., close it).",
    "Canonical_solution": "var net = require('net');\n\nfunction createTCPServer(port, dataHandler, endHandler) {\n    var server = net.createServer(function(client) {\n        client.on('data', dataHandler);\n        client.on('end', endHandler);\n        client.pipe(dataHandler);\n    });\n    server.listen(port);\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "const net = require('net');\nfunction createTCPServer(port, dataHandler, endHandler) {\n  const server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n      dataHandler(data);\n    });\n    socket.on('end', () => {\n      endHandler(socket);\n    });\n  });\n  server.listen(port);\n  return server;\n}",
      "const net = require('net');\nconst createTCPServer = (port, dataHandler, endHandler) => {\n  const server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n      dataHandler(data);\n    });\n    socket.on('end', () => {\n      endHandler();\n    });\n  });\n  server.listen(port);\n  return server;\n};",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    dataHandler(data);\n  });\n  socket.on('end', () => {\n    endHandler();\n  });\n});\nserver.listen(port);",
      "const net = require('net');\nconst createTCPServer = (port, dataHandler, endHandler) => {\n  const server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n      dataHandler(data);\n    });\n    socket.on('end', () => {\n      endHandler();\n    });\n  });\n  server.listen(port);\n  return server;\n};",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    dataHandler(data);\n  });\n  socket.on('end', () => {\n    endHandler();\n  });\n});\nserver.listen(port);",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    dataHandler(data);\n  });\n  socket.on('end', () => {\n    endHandler();\n  });\n});\nserver.listen(port);",
      "const net = require('net');\nconst createTCPServer = (port, dataHandler, endHandler) => {\n  const server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n      dataHandler(data);\n    });\n    socket.on('end', () => {\n      endHandler();\n    });\n  });\n  server.listen(port);\n  return server;\n};",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    dataHandler(data);\n  });\n  socket.on('end', () => {\n    endHandler();\n  });\n});\nserver.listen(port);",
      "const net = require('net');\nconst createTCPServer = (port, dataHandler, endHandler) => {\n  const server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n      dataHandler(data);\n    });\n    socket.on('end', () => {\n      endHandler();\n    });\n  });\n  server.listen(port);\n  return server;\n};",
      "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    dataHandler(data);\n  });\n  socket.on('end', () => {\n    endHandler();\n  });\n});\nserver.listen(port);"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 178,
    "Instruction": "Task Description: Create a Node class that implements a TCP-based peer-to-peer communication system using Node.js's net module. The class should handle server creation, client connections, message passing, and peer management.\n\nClass Description: The Node class represents a network node that can both accept incoming connections and establish outgoing connections to other peers. It uses TCP sockets for communication and implements basic peer discovery and message broadcasting capabilities.\n\nAttributes:\n\nid_: [Number] - Unique identifier for this node\npeers_: [Object] - Dictionary mapping peer IDs to their socket connections\nPORT: [Number] - Base port number for node communication (actual port is PORT + id)\nserver_: [net.Server] - TCP server instance for accepting incoming connections\n\nMethods:\n\nconstructor(id) -> [void] - Initializes the node with given ID, sets up event emitter, and creates TCP server\nstart() -> [Promise] - Attempts to connect to random peers (up to 5) for network formation\non_data(data, socket) -> [void] - Handles incoming data from sockets, parses messages and emits events\nsend(socket, data) -> [void] - Sends data to a peer (either via socket object or peer ID)\nbroadcast(data) -> [void] - Sends data to all connected peers\nadd_peer(socket, remote_id) -> [void] - Adds a peer connection to the peers dictionary\nremove_peer(socket) -> [void] - Removes a peer connection from the peers dictionary\nlist_peers() -> [Array] - Returns an array of connected peer IDs",
    "Canonical_solution": "var net = require(\"net\");\nvar Msg = require(\"./message\");\nvar EventEmitter = require('events').EventEmitter;\nvar Promise = require(\"bluebird\");\n\nclass Node extends EventEmitter {\n    constructor(id) {\n        super();\n        this.id_ = id;\n        this.peers_ = {};\n        this.PORT = 8000;\n\n        let self = this;\n        this.server_ = net.createServer((socket) => {\n            socket.setEncoding('utf8');\n            socket.on('data', (data) => { self.on_data(data, socket); });\n            socket.on('end', () => { self.remove_peer(socket); });\n        });\n        this.server_.listen(this.PORT + id);\n    }\n\n    async start() {\n        for (var i = 0; i < 5; ++i) {\n            var remote_id = Math.floor(Math.random() * 20);\n            if (remote_id !== this.id_ && !this.peers_[remote_id]) {\n                let self = this;\n                var socket = net.createConnection({ port: (this.PORT + remote_id) });\n                await new Promise((resolve, reject) => {\n                    socket.on('connect', () => {\n                        resolve();\n                    });\n                    socket.on('error', function (e) {\n                        resolve();\n                    });\n                    socket.setEncoding('utf8');\n                    socket.on('data', (data) => { self.on_data(data, socket); });\n                });\n                let data = Msg.connection(self.id_);\n                self.send(socket, data);\n                self.add_peer(socket, remote_id);\n            }\n        }\n    }\n\n    on_data(data, socket) {\n        try {\n            var arr = data.split(\"\\r\\n\");\n            for (var i = 0; i < arr.length; ++i) {\n                if (arr[i] == '') continue;\n                let obj = JSON.parse(arr[i]);\n                if (obj.type == Msg.type.Connection) {\n                    let remote_id = obj.data;\n                    this.add_peer(socket, remote_id);\n                } else {\n                    this.emit(\"message\", obj);\n                }\n            }\n        } catch (err) {\n            console.log(\"=========================\");\n            console.log(`node: ${this.id_}\\t receive msg error`);\n            console.log(err);\n            console.log(err.message);\n            console.log(data);\n            console.log(arr.length);\n            console.log(\"=========================\");\n            throw new Error();\n        }\n    }\n\n    send(socket, data) {\n        if (typeof socket === 'number') {\n            socket = this.peers_[socket];\n        }\n        if (typeof data === 'object') {\n            data = JSON.stringify(data);\n        }\n        socket.write(data + \"\\r\\n\");\n    }\n\n    broadcast(data) {\n        for (var index in this.peers_) {\n            let socket = this.peers_[index];\n            this.send(socket, data);\n        }\n    }\n\n    add_peer(socket, remote_id) {\n        if (!this.peers_[remote_id]) {\n            this.peers_[remote_id] = socket;\n        }\n    }\n\n    remove_peer(socket) {\n        for (var index in this.peers_) {\n            if (this.peers_[index] == socket) {\n                delete this.peers_[index];\n                break;\n            }\n        }\n    }\n\n    list_peers() {\n        let peer_ids = [];\n        for (var index in this.peers_) {\n            peer_ids.push(index);\n        }\n        return peer_ids;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer();\n    this.server_.on('connection', (socket) => {\n      this.add_peer(socket, socket.remoteAddress + ':' + socket.remotePort);\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        this.remove_peer(socket);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    const peer_ids = Array.from({ length: 5 }, () => Math.floor(Math.random() * 1000));\n    for (const peer_id of peer_ids) {\n      await this.connect_to_peer(peer_id);\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    // Handle message\n  }\n\n  send(socket, data) {\n    if (socket) {\n      socket.write(JSON.stringify(data));\n    } else {\n      const peer_id = this.get_peer_id_from_socket(socket);\n      const peer_socket = this.peers_[peer_id];\n      if (peer_socket) {\n        peer_socket.write(JSON.stringify(data));\n      }\n    }\n  }\n\n  broadcast(data) {\n    for (const peer_id in this.peers_) {\n      this.send(this.peers_[peer_id], data);\n    }\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n  }\n\n  remove_peer(socket) {\n    const peer_id = this.get_peer_id_from_socket(socket);\n    if (peer_id) {\n      delete this.peers_[peer_id];\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  get_peer_id_from_socket(socket) {\n    for (const peer_id in this.peers_) {\n      if (this.peers_[peer_id] === socket) {\n        return peer_id;\n      }\n    }\n    return null;\n  }\n\n  connect_to_peer(peer_id) {\n    return new Promise((resolve, reject) => {\n      const socket = net.connect(this.PORT + peer_id);\n      socket.on('connect', () => {\n        this.add_peer(socket, peer_id);\n        resolve(socket);\n      });\n      socket.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer();\n    this.server_.on('connection', (socket) => {\n      this.add_peer(socket, socket.remoteAddress + ':' + socket.remotePort);\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        this.remove_peer(socket);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    const peer_ids = Array.from({ length: 5 }, () => Math.floor(Math.random() * 1000));\n    for (const peer_id of peer_ids) {\n      await this.connect_to_peer(peer_id);\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    // Handle message\n  }\n\n  send(socket, data) {\n    if (socket) {\n      socket.write(JSON.stringify(data));\n    } else {\n      const peer_id = this.get_peer_id_from_socket(socket);\n      if (peer_id) {\n        const peer_socket = this.peers_[peer_id];\n        if (peer_socket) {\n          peer_socket.write(JSON.stringify(data));\n        }\n      }\n    }\n  }\n\n  broadcast(data) {\n    for (const peer_id in this.peers_) {\n      const peer_socket = this.peers_[peer_id];\n      peer_socket.write(JSON.stringify(data));\n    }\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n  }\n\n  remove_peer(socket) {\n    const peer_id = this.get_peer_id_from_socket(socket);\n    if (peer_id) {\n      delete this.peers_[peer_id];\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  get_peer_id_from_socket(socket) {\n    for (const peer_id in this.peers_) {\n      if (this.peers_[peer_id] === socket) {\n        return peer_id;\n      }\n    }\n    return null;\n  }\n\n  connect_to_peer(peer_id) {\n    return new Promise((resolve, reject) => {\n      const socket = net.connect(this.PORT + peer_id);\n      socket.on('connect', () => {\n        this.add_peer(socket, peer_id);\n        resolve(socket);\n      });\n      socket.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer();\n    this.server_.on('connection', (socket) => {\n      this.add_peer(socket, socket.remoteAddress + ':' + socket.remotePort);\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        this.remove_peer(socket);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    const peer_ids = Array.from({ length: 5 }, () => Math.floor(Math.random() * 1000));\n    for (const peer_id of peer_ids) {\n      await this.connect_to_peer(peer_id);\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    // Handle message\n  }\n\n  send(socket, data) {\n    if (typeof socket === 'string') {\n      const peer = this.peers_[socket];\n      if (peer) {\n        peer.write(JSON.stringify(data));\n      }\n    } else {\n      socket.write(JSON.stringify(data));\n    }\n  }\n\n  broadcast(data) {\n    for (const peer_id in this.peers_) {\n      this.send(this.peers_[peer_id], data);\n    }\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n  }\n\n  remove_peer(socket) {\n    for (const peer_id in this.peers_) {\n      if (this.peers_[peer_id] === socket) {\n        delete this.peers_[peer_id];\n        break;\n      }\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  connect_to_peer(peer_id) {\n    return new Promise((resolve, reject) => {\n      const socket = net.connect(this.PORT + peer_id, 'localhost');\n      socket.on('connect', () => {\n        this.add_peer(socket, peer_id);\n        resolve();\n      });\n      socket.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer((socket) => {\n      this.add_peer(socket, socket.remoteAddress + ':' + socket.remotePort);\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        this.remove_peer(socket);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    for (let i = 0; i < 5; i++) {\n      const peer = await this.connect_to_random_peer();\n      if (peer) {\n        this.add_peer(peer, peer.remoteAddress + ':' + peer.remotePort);\n      }\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    // Handle message\n  }\n\n  send(socketOrPeerId, data) {\n    const peer = typeof socketOrPeerId === 'string' ? this.peers_[socketOrPeerId] : socketOrPeerId;\n    if (peer) {\n      peer.write(JSON.stringify(data));\n    }\n  }\n\n  broadcast(data) {\n    for (const peerId in this.peers_) {\n      this.send(this.peers_[peerId], data);\n    }\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n  }\n\n  remove_peer(socket) {\n    for (const peerId in this.peers_) {\n      if (this.peers_[peerId] === socket) {\n        delete this.peers_[peerId];\n        break;\n      }\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  connect_to_random_peer() {\n    // Implement logic to connect to a random peer\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer((socket) => {\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        console.error('Socket error:', err);\n        this.remove_peer(socket);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    try {\n      const peer_ids = Array.from({ length: 5 }, () => Math.floor(Math.random() * 100));\n      for (const peer_id of peer_ids) {\n        await this.connect_to_peer(peer_id);\n      }\n    } catch (error) {\n      console.error('Error connecting to peers:', error);\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    if (message.type === 'peer-discovery') {\n      this.add_peer(socket, message.sender_id);\n    } else if (message.type === 'message') {\n      this.emit('message', message.data, message.sender_id);\n    }\n  }\n\n  send(socket, data) {\n    const message = JSON.stringify({ type: 'message', data, sender_id: this.id_ });\n    socket.write(message);\n  }\n\n  broadcast(data) {\n    for (const peer_id in this.peers_) {\n      this.send(this.peers_[peer_id], data);\n    }\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n    this.emit('peer-joined', remote_id);\n  }\n\n  remove_peer(socket) {\n    for (const peer_id in this.peers_) {\n      if (this.peers_[peer_id] === socket) {\n        delete this.peers_[peer_id];\n        this.emit('peer-left', peer_id);\n        break;\n      }\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  connect_to_peer(peer_id) {\n    return new Promise((resolve, reject) => {\n      const socket = net.connect(this.PORT + peer_id, () => {\n        this.add_peer(socket, peer_id);\n        resolve(socket);\n      });\n      socket.on('error', (err) => {\n        socket.destroy();\n        reject(err);\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n    constructor(id) {\n        this.id_ = id;\n        this.peers_ = {};\n        this.PORT = 3000;\n        this.server_ = net.createServer();\n        this.server_.on('connection', (socket) => {\n            this.add_peer(socket, socket.remoteAddress + ':' + socket.remotePort);\n            socket.on('data', (data) => {\n                this.on_data(data, socket);\n            });\n            socket.on('end', () => {\n                this.remove_peer(socket);\n            });\n            socket.on('error', (err) => {\n                this.remove_peer(socket);\n            });\n        });\n        this.server_.listen(this.PORT + this.id_);\n    }\n\n    async start() {\n        for (let i = 0; i < 5; i++) {\n            const peer = await this.connect_to_random_peer();\n            if (peer) {\n                this.add_peer(peer, peer.remoteAddress + ':' + peer.remotePort);\n            }\n        }\n    }\n\n    on_data(data, socket) {\n        const message = JSON.parse(data.toString());\n        // Handle message\n    }\n\n    send(socketOrId, data) {\n        const socket = typeof socketOrId === 'string' ? this.peers_[socketOrId] : socketOrId;\n        if (socket) {\n            socket.write(JSON.stringify(data));\n        }\n    }\n\n    broadcast(data) {\n        for (const peerId in this.peers_) {\n            this.send(this.peers_[peerId], data);\n        }\n    }\n\n    add_peer(socket, remote_id) {\n        this.peers_[remote_id] = socket;\n    }\n\n    remove_peer(socket) {\n        for (const peerId in this.peers_) {\n            if (this.peers_[peerId] === socket) {\n                delete this.peers_[peerId];\n                break;\n            }\n        }\n    }\n\n    list_peers() {\n        return Object.keys(this.peers_);\n    }\n\n    connect_to_random_peer() {\n        // Implement logic to connect to a random peer\n    }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer((socket) => {\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        this.remove_peer(socket);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    const peer_ids = Array.from({length: 5}, () => Math.floor(Math.random() * 100));\n    for (const peer_id of peer_ids) {\n      await this.connect_to_peer(peer_id);\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    if (message.type === 'broadcast') {\n      this.broadcast(message.data);\n    } else if (message.type === 'peer') {\n      this.add_peer(socket, message.peer_id);\n    }\n  }\n\n  send(socket, data) {\n    socket.write(JSON.stringify({ type: 'broadcast', data }));\n  }\n\n  broadcast(data) {\n    for (const peer_id in this.peers_) {\n      this.send(this.peers_[peer_id], data);\n    }\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n  }\n\n  remove_peer(socket) {\n    for (const peer_id in this.peers_) {\n      if (this.peers_[peer_id] === socket) {\n        delete this.peers_[peer_id];\n        break;\n      }\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  connect_to_peer(peer_id) {\n    return new Promise((resolve, reject) => {\n      const socket = net.connect(this.PORT + peer_id, () => {\n        this.add_peer(socket, peer_id);\n        resolve();\n      });\n      socket.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer();\n    this.server_.on('connection', (socket) => {\n      this.add_peer(socket, socket.remoteAddress + ':' + socket.remotePort);\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        this.remove_peer(socket);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    for (let i = 0; i < 5; i++) {\n      const peer = await this.connect_to_random_peer();\n      if (peer) {\n        this.add_peer(peer, peer.remoteAddress + ':' + peer.remotePort);\n      }\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    // Handle message\n  }\n\n  send(socketOrPeerId, data) {\n    const socket = this.peers_[socketOrPeerId] || socketOrPeerId;\n    socket.write(JSON.stringify(data));\n  }\n\n  broadcast(data) {\n    Object.values(this.peers_).forEach((socket) => {\n      socket.write(JSON.stringify(data));\n    });\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n  }\n\n  remove_peer(socket) {\n    const remote_id = Object.keys(this.peers_).find((id) => this.peers_[id] === socket);\n    if (remote_id) {\n      delete this.peers_[remote_id];\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  connect_to_random_peer() {\n    // Implement logic to connect to a random peer\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer((socket) => {\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        console.error('Socket error:', err);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    for (let i = 0; i < 5; i++) {\n      const peer = await this.connect_to_random_peer();\n      if (peer) {\n        this.add_peer(peer, peer.id);\n      }\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    if (message.type === 'peer-discovery') {\n      this.add_peer(socket, message.id);\n    } else if (message.type === 'message') {\n      this.emit('message', message.data);\n    }\n  }\n\n  send(socketOrId, data) {\n    const socket = this.peers_[socketOrId] || this.peers_[socketOrId.id];\n    if (socket) {\n      socket.write(JSON.stringify({ type: 'message', data }));\n    }\n  }\n\n  broadcast(data) {\n    for (const peerId in this.peers_) {\n      this.send(this.peers_[peerId], data);\n    }\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n    socket.on('data', (data) => {\n      this.on_data(data, socket);\n    });\n    socket.on('end', () => {\n      this.remove_peer(socket);\n    });\n    socket.on('error', (err) => {\n      console.error('Socket error:', err);\n    });\n    this.emit('peer-connected', remote_id);\n  }\n\n  remove_peer(socket) {\n    const peerId = Object.keys(this.peers_).find((id) => this.peers_[id] === socket);\n    if (peerId) {\n      delete this.peers_[peerId];\n      this.emit('peer-disconnected', peerId);\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  connect_to_random_peer() {\n    // This is a placeholder for the actual implementation\n    return new Promise((resolve, reject) => {\n      // Simulate connecting to a random peer\n      setTimeout(() => {\n        const peer = {\n          id: Math.floor(Math.random() * 1000),\n          write: (data) => console.log('Sending data to peer:', data),\n          end: () => resolve(peer),\n          on: () => {}\n        };\n        resolve(peer);\n      }, 1000);\n    });\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass Node {\n  constructor(id) {\n    this.id_ = id;\n    this.peers_ = {};\n    this.PORT = 3000;\n    this.server_ = net.createServer();\n    this.server_.on('connection', (socket) => {\n      this.add_peer(socket, socket.remoteAddress + ':' + socket.remotePort);\n      socket.on('data', (data) => {\n        this.on_data(data, socket);\n      });\n      socket.on('end', () => {\n        this.remove_peer(socket);\n      });\n      socket.on('error', (err) => {\n        this.remove_peer(socket);\n      });\n    });\n    this.server_.listen(this.PORT + this.id_);\n  }\n\n  async start() {\n    for (let i = 0; i < 5; i++) {\n      const peer = await this.connect_to_random_peer();\n      if (peer) {\n        this.add_peer(peer, peer.remoteAddress + ':' + peer.remotePort);\n      }\n    }\n  }\n\n  on_data(data, socket) {\n    const message = JSON.parse(data.toString());\n    this.emit('message', message, socket);\n  }\n\n  send(socketOrPeerId, data) {\n    const peer = typeof socketOrPeerId === 'string' ? this.peers_[socketOrPeerId] : socketOrPeerId;\n    if (peer) {\n      peer.write(JSON.stringify(data));\n    }\n  }\n\n  broadcast(data) {\n    Object.values(this.peers_).forEach((peer) => {\n      peer.write(JSON.stringify(data));\n    });\n  }\n\n  add_peer(socket, remote_id) {\n    this.peers_[remote_id] = socket;\n  }\n\n  remove_peer(socket) {\n    const keys = Object.keys(this.peers_);\n    for (let i = 0; i < keys.length; i++) {\n      if (this.peers_[keys[i]] === socket) {\n        delete this.peers_[keys[i]];\n        break;\n      }\n    }\n  }\n\n  list_peers() {\n    return Object.keys(this.peers_);\n  }\n\n  connect_to_random_peer() {\n    return new Promise((resolve, reject) => {\n      const randomPeerId = Math.floor(Math.random() * 1000);\n      const socket = net.connect(this.PORT + randomPeerId);\n      socket.on('connect', () => {\n        resolve(socket);\n      });\n      socket.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Create a function that sets up a TCP server using Node.js's built-in 'net' module to handle client connections and respond with the current timestamp.\n\nFunction Description: The function creates a TCP server that listens on a specified port. When a client connects, the server sends the current timestamp and immediately closes the connection. The server continues to listen for new connections after handling each client.\n\nInput: \n- port: [number] - The port number on which the TCP server should listen for incoming connections.\n\nOutput: \n- None (The function creates and starts the server but doesn't return anything. The server continues running to handle connections.)",
    "Canonical_solution": "function createTCPServer(port) {\n    const net = require('net');\n    const server = net.createServer(function (socket) {\n        socket.end(now() + '\\n');\n    });\n    server.listen(Number(port));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "const net = require('net');\n\nfunction startServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction setupTCPServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction setupTCPServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction setupServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction setupServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction setupServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction setupTCPServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction setupServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction startServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}",
      "const net = require('net');\n\nfunction startServer(port) {\n  const server = net.createServer((socket) => {\n    socket.write(Date.now().toString());\n    socket.end();\n  });\n\n  server.listen(port);\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Write a function that fetches version information and schema data from a remote API, caches the results locally, and handles errors appropriately.\n\nFunction Description: The function `fetchAndCacheVersions` retrieves version data from a specified API endpoint, then fetches schema data for each non-deprecated version. It caches all retrieved data in JSON files in a local directory. Errors during the process are caught and logged, with the process exiting on failure.\n\nInput: None (The function takes no parameters; all URLs and paths are hardcoded)\n\nOutput: \n- Success: Writes JSON files to the cache directory and logs success messages\n- Failure: Logs error messages and exits the process with status code 1",
    "Canonical_solution": "function fetchAndCacheVersions() {\n    const axios = require('axios');\n    const { writeJsonSync } = require('fs-extra');\n    const path = require('path');\n\n    axios\n        .get('https://exp.host/--/versions')\n        .then(async ({ data }) => {\n            writeJsonSync(path.join(__dirname, '../caches/versions.json'), data);\n\n            for (const version of Object.keys(data.sdkVersions)) {\n                if (data.sdkVersions[version].isDeprecated) {\n                    continue;\n                }\n                const {\n                    data: { data: schema },\n                } = await axios.get(`https://exp.host/--/api/v2/project/configuration/schema/${version}`);\n\n                const filePath = path.join(__dirname, `../caches/schema-${version}.json`);\n                console.log('Writing', filePath);\n                writeJsonSync(filePath, schema);\n            }\n        })\n        .then(() => console.log('Caches updated.'))\n        .catch(error => {\n            console.error(error);\n            console.error('Updating caches failed.');\n            process.exit(1);\n        });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nimport json\nimport os\n\nCACHE_DIR = \"cache\"\nAPI_VERSIONS_ENDPOINT = \"https://api.example.com/versions\"\nAPI_SCHEMA_ENDPOINT = \"https://api.example.com/schema\"\n\ndef fetchAndCacheVersions():\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n\n    try:\n        response = requests.get(API_VERSIONS_ENDPOINT)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get('deprecated'):\n                schema_response = requests.get(API_SCHEMA_ENDPOINT + \"?version=\" + version['version'])\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                with open(os.path.join(CACHE_DIR, version['version'] + \".json\"), 'w') as file:\n                    json.dump(schema_data, file)\n                print(f\"Successfully cached schema for version {version['version']}\")\n\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        exit(1)\n```",
      "```python\nimport requests\nimport os\nimport json\nimport logging\n\ndef fetchAndCacheVersions():\n    api_endpoint = \"https://api.example.com/versions\"\n    schema_endpoint = \"https://api.example.com/schema\"\n    cache_dir = \"cache\"\n    logging.basicConfig(level=logging.INFO)\n\n    try:\n        response = requests.get(api_endpoint)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get(\"deprecated\"):\n                schema_response = requests.get(schema_endpoint + \"?version=\" + version[\"version\"])\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                cache_file = os.path.join(cache_dir, version[\"version\"] + \".json\")\n                with open(cache_file, 'w') as file:\n                    json.dump(schema_data, file)\n                logging.info(f\"Cached schema data for version {version['version']}\")\n\n    except requests.exceptions.RequestException as e:\n        logging.error(f\"Error fetching data: {e}\")\n        exit(1)\n```",
      "```python\nimport requests\nimport json\nimport os\n\ndef fetchAndCacheVersions():\n    api_endpoint = \"https://api.example.com/versions\"\n    cache_dir = \"cache\"\n    versions_url = \"https://api.example.com/versions/{version}/schema\"\n\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n\n    try:\n        response = requests.get(api_endpoint)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get('deprecated'):\n                schema_url = versions_url.format(version=version['version'])\n                schema_response = requests.get(schema_url)\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                cache_file_path = os.path.join(cache_dir, f\"{version['version']}.json\")\n                with open(cache_file_path, 'w') as cache_file:\n                    json.dump(schema_data, cache_file)\n\n                print(f\"Successfully cached schema for version {version['version']}\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        exit(1)\n```",
      "```python\nimport requests\nimport json\nimport os\n\nCACHE_DIR = \"cache\"\nAPI_VERSIONS_ENDPOINT = \"https://api.example.com/versions\"\nAPI_SCHEMA_ENDPOINT = \"https://api.example.com/schema\"\n\ndef fetchAndCacheVersions():\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n\n    try:\n        response = requests.get(API_VERSIONS_ENDPOINT)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get('deprecated'):\n                schema_response = requests.get(API_SCHEMA_ENDPOINT + \"?version=\" + version['version'])\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                with open(os.path.join(CACHE_DIR, version['version'] + \".json\"), \"w\") as file:\n                    json.dump(schema_data, file)\n\n        print(\"All versions and schemas have been fetched and cached successfully.\")\n\n    except requests.RequestException as e:\n        print(f\"An error occurred: {e}\")\n        exit(1)\n```",
      "```python\nimport requests\nimport os\nimport json\n\nCACHE_DIR = 'cache'\nAPI_VERSIONS_ENDPOINT = 'https://api.example.com/versions'\nAPI_SCHEMA_ENDPOINT = 'https://api.example.com/schema'\n\ndef fetchAndCacheVersions():\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n    \n    try:\n        response = requests.get(API_VERSIONS_ENDPOINT)\n        response.raise_for_status()\n        versions = response.json()\n        \n        for version in versions:\n            if not version.get('deprecated'):\n                schema_response = requests.get(API_SCHEMA_ENDPOINT + '?version=' + version['version'])\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n                \n                with open(os.path.join(CACHE_DIR, f'schema_{version[\"version\"]}.json'), 'w') as schema_file:\n                    json.dump(schema_data, schema_file)\n                \n                print(f'Successfully cached schema for version {version[\"version\"]}')\n    except requests.RequestException as e:\n        print(f'Error fetching data: {e}')\n        exit(1)\n```",
      "```python\nimport requests\nimport os\nimport json\n\nCACHE_DIR = \"cache\"\nAPI_ENDPOINT = \"https://api.example.com/versions\"\nSCHEMA_ENDPOINT = \"https://api.example.com/schema\"\n\ndef fetchAndCacheVersions():\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n\n    try:\n        response = requests.get(API_ENDPOINT)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get('deprecated'):\n                schema_response = requests.get(SCHEMA_ENDPOINT + \"?version=\" + version['version'])\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                with open(os.path.join(CACHE_DIR, version['version'] + \".json\"), 'w') as file:\n                    json.dump(schema_data, file)\n                print(f\"Cached schema data for version {version['version']}\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        exit(1)\n\nfetchAndCacheVersions()\n```",
      "```python\nimport requests\nimport os\nimport json\nimport logging\n\ndef fetchAndCacheVersions():\n    api_endpoint = \"https://api.example.com/versions\"\n    cache_dir = \"cache\"\n    logging.basicConfig(level=logging.INFO)\n\n    try:\n        response = requests.get(api_endpoint)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get(\"deprecated\"):\n                schema_url = f\"https://api.example.com/schemas/{version['version']}\"\n                schema_response = requests.get(schema_url)\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                cache_file = os.path.join(cache_dir, f\"{version['version']}.json\")\n                with open(cache_file, 'w') as file:\n                    json.dump(schema_data, file)\n                logging.info(f\"Cached schema data for version {version['version']}\")\n\n    except requests.exceptions.RequestException as e:\n        logging.error(f\"Error fetching data: {e}\")\n        exit(1)\n```",
      "```python\nimport requests\nimport json\nimport os\n\ndef fetchAndCacheVersions():\n    api_endpoint = \"https://api.example.com/versions\"\n    cache_directory = \"cache\"\n    versions_url = f\"{api_endpoint}/versions\"\n    schema_url = f\"{api_endpoint}/schema\"\n\n    if not os.path.exists(cache_directory):\n        os.makedirs(cache_directory)\n\n    try:\n        response = requests.get(versions_url)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get('deprecated'):\n                schema_response = requests.get(schema_url, params={'version': version['version']})\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                cache_file_path = os.path.join(cache_directory, f\"{version['version']}.json\")\n                with open(cache_file_path, 'w') as cache_file:\n                    json.dump(schema_data, cache_file)\n\n                print(f\"Successfully cached schema for version {version['version']}\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        exit(1)\n```",
      "```python\nimport requests\nimport json\nimport os\n\nCACHE_DIR = \"cache\"\nAPI_VERSIONS_ENDPOINT = \"https://api.example.com/versions\"\nAPI_SCHEMA_ENDPOINT = \"https://api.example.com/schema\"\n\ndef fetchAndCacheVersions():\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n\n    try:\n        response = requests.get(API_VERSIONS_ENDPOINT)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get('deprecated'):\n                schema_response = requests.get(API_SCHEMA_ENDPOINT + \"?version=\" + version['version'])\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                with open(os.path.join(CACHE_DIR, version['version'] + \".json\"), 'w') as file:\n                    json.dump(schema_data, file)\n\n                print(f\"Successfully cached schema for version {version['version']}\")\n\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        exit(1)\n\nfetchAndCacheVersions()\n```",
      "```python\nimport requests\nimport json\nimport os\n\nCACHE_DIR = 'cache'\nAPI_VERSIONS_ENDPOINT = 'https://api.example.com/versions'\nAPI_SCHEMA_ENDPOINT = 'https://api.example.com/schema'\n\ndef fetchAndCacheVersions():\n    if not os.path.exists(CACHE_DIR):\n        os.makedirs(CACHE_DIR)\n\n    try:\n        response = requests.get(API_VERSIONS_ENDPOINT)\n        response.raise_for_status()\n        versions = response.json()\n\n        for version in versions:\n            if not version.get('deprecated'):\n                schema_response = requests.get(API_SCHEMA_ENDPOINT + '?version=' + version['version'])\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n\n                with open(os.path.join(CACHE_DIR, f'version_{version[\"version\"]}.json'), 'w') as file:\n                    json.dump(schema_data, file)\n\n        print(\"All versions and schemas fetched and cached successfully.\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"An error occurred: {e}\")\n        exit(1)\n\nfetchAndCacheVersions()\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 180,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module to handle client connections, parse incoming JSON data streams, and manage server lifecycle events.\n\nFunction Description: The function creates a TCP server that listens on a specified port for incoming client connections. It sets up a JSON stream parser to handle incoming data, with error handling and server cleanup on parser errors or stream end. The server automatically closes when parsing fails or the stream ends.\n\nInput: None (The port number 9999 is hardcoded in the implementation)\n\nOutput: None (The function creates and manages a server instance but doesn't return anything)",
    "Canonical_solution": "function createTcpServer() {\n    var net = require('net');\n    var server = net.createServer(function(client) {\n        var data_calls = 0;\n        var parser = JSONStream.parse();\n        parser.on('error', function(err) {\n            console.log(err);\n            server.close();\n        });\n\n        parser.on('end', function() {\n            console.log('END');\n            server.close();\n        });\n        client.pipe(parser);\n    });\n    server.listen(9999);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "matched_results": [
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle the parsed data here\n      data = ''; // Reset data for the next JSON object\n    } catch (error) {\n      socket.end(); // Close the connection if parsing fails\n      server.close(); // Close the server if it's the only connection\n      return;\n    }\n  });\n\n  socket.on('end', () => {\n    server.close(); // Close the server when the client ends the connection\n  });\n\n  socket.on('error', (error) => {\n    socket.end(); // Close the connection if an error occurs\n    server.close(); // Close the server if it's the only connection\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle the parsed data here\n      data = ''; // Reset data for the next JSON message\n    } catch (error) {\n      socket.end(); // End the connection if JSON parsing fails\n      server.close(); // Close the server if it fails to parse data\n    }\n  });\n\n  socket.on('end', () => {\n    server.close(); // Close the server if the client ends the connection\n  });\n\n  socket.on('error', (error) => {\n    socket.end(); // End the connection if an error occurs\n    server.close(); // Close the server if an error occurs\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle parsed data here\n      data = ''; // Reset data for next JSON\n    } catch (error) {\n      socket.end();\n      server.close();\n      return;\n    }\n  });\n\n  socket.on('end', () => {\n    server.close();\n  });\n\n  socket.on('error', (error) => {\n    socket.end();\n    server.close();\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle parsed data here\n      data = ''; // Reset data after parsing\n    } catch (error) {\n      socket.end('Error parsing JSON');\n      return;\n    }\n  });\n\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n\n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n    socket.end();\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle the parsed data here\n      data = ''; // Reset data for the next JSON object\n    } catch (error) {\n      socket.end();\n      server.close();\n      return;\n    }\n  });\n\n  socket.on('end', () => {\n    server.close();\n  });\n\n  socket.on('error', (error) => {\n    socket.end();\n    server.close();\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle parsed data here\n      data = ''; // Reset data for next JSON\n    } catch (error) {\n      socket.end(); // End the connection on parse error\n      server.close(); // Close the server\n      return;\n    }\n  });\n\n  socket.on('end', () => {\n    server.close(); // Close the server\n  });\n\n  socket.on('error', (error) => {\n    socket.end(); // End the connection on error\n    server.close(); // Close the server\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle the parsed data here\n      data = ''; // Reset data for the next JSON object\n    } catch (error) {\n      socket.end(); // End the connection on parsing error\n      server.close(); // Close the server on parsing error\n    }\n  });\n\n  socket.on('end', () => {\n    server.close(); // Close the server when the stream ends\n  });\n\n  socket.on('error', (error) => {\n    socket.end(); // End the connection on error\n    server.close(); // Close the server on error\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle the parsed data here\n      data = ''; // Reset data after parsing\n    } catch (error) {\n      socket.end(); // End the connection if parsing fails\n      server.close(); // Close the server if it fails to parse\n      return;\n    }\n  });\n\n  socket.on('end', () => {\n    server.close(); // Close the server if the stream ends\n  });\n\n  socket.on('error', (error) => {\n    socket.end(); // End the connection if there's an error\n    server.close(); // Close the server if there's an error\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle the parsed data here\n      data = ''; // Reset data for the next JSON object\n    } catch (error) {\n      socket.end('Error parsing JSON');\n      return;\n    }\n  });\n\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n\n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n    socket.end();\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```",
      "```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  let data = '';\n  socket.on('data', (chunk) => {\n    data += chunk.toString();\n    try {\n      const parsedData = JSON.parse(data);\n      // Handle the parsed data here\n      data = ''; // Reset data for the next JSON object\n    } catch (error) {\n      socket.end(); // End the connection if parsing fails\n      server.close(); // Close the server if it fails to parse\n    }\n  });\n\n  socket.on('end', () => {\n    server.close(); // Close the server if the client ends the connection\n  });\n\n  socket.on('error', (error) => {\n    socket.end(); // End the connection if an error occurs\n    server.close(); // Close the server if an error occurs\n  });\n});\n\nserver.listen(9999, () => {\n  console.log('Server listening on port 9999');\n});\n\nserver.on('close', () => {\n  console.log('Server closed');\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a Flash Policy Server class in JavaScript using Node.js's net module to handle cross-domain policy requests for socket connections.\n\nClass Description: The FlashPolicyServer class creates a TCP server that responds to Flash socket policy requests. It manages allowed origins/ports, compiles the XML policy file, and handles server lifecycle events.\n\nAttributes:\n- origins: [Array] - List of allowed domain:port combinations\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [Object] - TCP server instance\n- buffer: [Buffer] - Compiled policy file in binary format\n- server: [Object] - Optional existing server instance to attach to\n\nMethods:\n- constructor(options, origins) -> [FlashPolicyServer] - Initializes the server with options and allowed origins\n- listen(port, server, cb) -> [FlashPolicyServer] - Starts listening on specified port, optionally attaching to existing server\n- responder(socket) -> [void] - Responds to policy requests on a socket connection\n- compile() -> [FlashPolicyServer] - Generates the XML policy buffer from allowed origins\n- add() -> [FlashPolicyServer] - Adds new allowed origins to the policy\n- remove(origin) -> [FlashPolicyServer] - Removes an origin from the allowed list\n- close() -> [FlashPolicyServer] - Stops the server and cleans up listeners",
    "Canonical_solution": "var net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => this.responder(socket));\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges.'\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (data && data[0] === 60 && data.toString() === '<policy-file-request/>\\0' &&\n              socket && (socket.readyState === 'open' || socket.readyState === 'writeOnly')) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    this.port >= 0 && this.socket.listen(this.port, () => {\n      this.socket.online = true;\n      if (callback) {\n        callback.call(this);\n        callback = undefined;\n      }\n    });\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = new Buffer(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n      this.server.on('connection', this.responder.bind(this));\n    } else {\n      this.socket = net.createServer();\n      this.socket.on('connection', this.responder.bind(this));\n      this.socket.listen(port, () => {\n        this.log(`Server listening on port ${port}`);\n        cb && cb();\n      });\n    }\n    return this;\n  }\n\n  responder(socket) {\n    let data = '';\n    socket.on('data', chunk => {\n      data += chunk.toString();\n    });\n    socket.on('end', () => {\n      const request = data.split('\\n')[0];\n      const origin = request.split('/')[2].split(':')[0];\n      if (this.origins.includes(origin)) {\n        socket.write(this.buffer);\n      } else {\n        socket.write('<cross-domain-access allowed=\"false\"/>');\n      }\n      socket.end();\n    });\n  }\n\n  compile() {\n    const originsXML = this.origins.map(origin => `<cross-domain-access domain=\"${origin}\" allowed=\"true\"/>`).join('');\n    this.buffer = Buffer.from(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<cross-domain-policy>\\n${originsXML}\\n</cross-domain-policy>`);\n    return this;\n  }\n\n  add(origin) {\n    if (!this.origins.includes(origin)) {\n      this.origins.push(origin);\n      this.compile();\n    }\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index !== -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    if (this.server) {\n      this.server.close();\n    }\n    this.log('Server closed');\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n      this.server.listen(port, cb);\n    } else {\n      this.socket = net.createServer();\n      this.socket.listen(port, cb);\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      // Handle policy request and send response\n    });\n  }\n\n  compile() {\n    // Generate XML policy buffer from allowed origins\n    return this;\n  }\n\n  add() {\n    // Add new allowed origins to the policy\n    return this;\n  }\n\n  remove(origin) {\n    // Remove an origin from the allowed list\n    return this;\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close();\n    } else if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n    } else {\n      this.socket = net.createServer();\n      this.socket.on('connection', this.responder.bind(this));\n    }\n    this.socket.listen(port, () => {\n      this.log(`FlashPolicyServer listening on port ${port}`);\n      cb && cb();\n    });\n    return this;\n  }\n\n  responder(socket) {\n    let data = '';\n    socket.on('data', chunk => {\n      data += chunk.toString();\n    });\n    socket.on('end', () => {\n      const request = this.parsePolicyRequest(data);\n      if (request) {\n        const policy = this.compile();\n        socket.write(policy);\n      }\n      socket.end();\n    });\n  }\n\n  parsePolicyRequest(data) {\n    // Parse the policy request and return the origin if valid\n    // Implementation depends on the format of the policy request\n  }\n\n  compile() {\n    const xml = `<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>`;\n    const buffer = Buffer.from(xml);\n    this.buffer = buffer;\n    return buffer;\n  }\n\n  add(origin) {\n    this.origins.push(origin);\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index !== -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    } else if (this.server) {\n      this.server.close();\n    }\n    this.log('FlashPolicyServer closed');\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n      this.server.listen(port, cb);\n    } else {\n      this.socket = net.createServer();\n      this.socket.listen(port, cb);\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      // Process policy request and send response\n      socket.write(this.buffer);\n    });\n  }\n\n  compile() {\n    // Generate XML policy buffer\n    this.buffer = Buffer.from('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>');\n    return this;\n  }\n\n  add() {\n    // Add new allowed origins to the policy\n    return this;\n  }\n\n  remove(origin) {\n    // Remove an origin from the allowed list\n    return this;\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close();\n    } else {\n      this.socket.close();\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n      this.server.listen(port, cb);\n    } else {\n      this.socket = net.createServer();\n      this.socket.listen(port, cb);\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      // Handle policy request and send response\n    });\n  }\n\n  compile() {\n    // Generate XML policy buffer from allowed origins\n    return this;\n  }\n\n  add() {\n    // Add new allowed origins to the policy\n    return this;\n  }\n\n  remove(origin) {\n    // Remove an origin from the allowed list\n    return this;\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close();\n    } else if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n      this.server.listen(port, cb);\n    } else {\n      this.socket = net.createServer(cb);\n      this.socket.listen(port);\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      // Process policy request and send response\n      socket.write(this.buffer);\n    });\n  }\n\n  compile() {\n    // Generate XML policy buffer\n    this.buffer = Buffer.from('<cross-domain-policy><allow-access-from domain=\"*\"></allow-access-from></cross-domain-policy>');\n    return this;\n  }\n\n  add() {\n    // Add new allowed origins to the policy\n    return this;\n  }\n\n  remove(origin) {\n    // Remove an origin from the allowed list\n    return this;\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    if (this.server) {\n      this.server.close();\n    }\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n      this.server.listen(port, cb);\n    } else {\n      this.socket = net.createServer();\n      this.socket.listen(port, cb);\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      // Parse and respond to policy requests\n      // ...\n      this.log('Policy request received');\n    });\n  }\n\n  compile() {\n    // Generate XML policy buffer from allowed origins\n    // ...\n    this.buffer = Buffer.from('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"false\"/></cross-domain-policy>');\n    return this;\n  }\n\n  add(origin) {\n    this.origins.push(origin);\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close();\n    } else if (this.socket) {\n      this.socket.close();\n    }\n    this.log('Server closed');\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n    } else {\n      this.socket = net.createServer();\n      this.socket.on('connection', this.responder.bind(this));\n    }\n    this.socket.listen(port, () => {\n      this.log(`Server listening on port ${port}`);\n      cb && cb();\n    });\n    return this;\n  }\n\n  responder(socket) {\n    let data = '';\n    socket.on('data', chunk => {\n      data += chunk.toString();\n    });\n    socket.on('end', () => {\n      const request = data.split('\\n')[0];\n      const origin = request.split('/')[2];\n      if (this.origins.includes(origin)) {\n        socket.write(this.buffer);\n      } else {\n        socket.write('HTTP/1.1 403 Forbidden\\r\\n\\r\\n');\n      }\n      socket.end();\n    });\n  }\n\n  compile() {\n    const xml = `<cross-domain-policy><allow-access-from domain=\"*\">*</allow-access-from></cross-domain-policy>`;\n    this.buffer = Buffer.from(xml);\n    return this;\n  }\n\n  add(origin) {\n    this.origins.push(origin);\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index > -1) {\n      this.origins.splice(index, 1);\n    }\n    return this;\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close();\n    } else {\n      this.socket.close();\n    }\n    this.log('Server closed');\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n      this.server.listen(port, cb);\n    } else {\n      this.socket = net.createServer();\n      this.socket.listen(port, cb);\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      // Process policy request and send response\n      socket.write(this.buffer);\n    });\n  }\n\n  compile() {\n    // Generate XML policy buffer\n    this.buffer = Buffer.from('<cross-domain-policy><allow-access-from domain=\"*\" secure=\"true\"/></cross-domain-policy>');\n    return this;\n  }\n\n  add() {\n    // Add new allowed origins to the policy\n    return this;\n  }\n\n  remove(origin) {\n    // Remove an origin from the allowed list\n    return this;\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close();\n    } else if (this.socket) {\n      this.socket.close();\n    }\n    return this;\n  }\n}\n```",
      "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n  }\n\n  listen(port, server, cb) {\n    if (server) {\n      this.server = server;\n      this.server.listen(port, cb);\n    } else {\n      this.socket = net.createServer();\n      this.socket.listen(port, cb);\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      // Handle policy request and send response\n    });\n  }\n\n  compile() {\n    // Generate XML policy buffer from allowed origins\n    return this;\n  }\n\n  add() {\n    // Add new allowed origins to the policy\n    return this;\n  }\n\n  remove(origin) {\n    // Remove an origin from the allowed list\n    return this;\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close();\n    } else if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 182,
    "Instruction": "Task Description: Create a UDP server using Node.js's dgram module to listen for incoming messages on a specified port.\n\nFunction Description: The function `createUDPServer` initializes a UDP server socket, binds it to a specified port, and listens for incoming messages. When a message is received, it logs the message content and the sender's address and port.\n\nInput: None\n\nOutput: None (The function does not return any value but logs incoming messages to the console.)",
    "Canonical_solution": "function createUDPServer() {\n    const dgram = require('dgram');\n    const socket = dgram.createSocket('udp4');\n\n    socket.on('message', (msg, rinfo) => {\n        console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n    });\n\n    socket.bind(8081);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "matched_results": [
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port) {\n  const server = dgram.createSocket('udp4');\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.on('message', (msg, rinfo) => {\n    console.log(`Received ${msg} from ${rinfo.address}:${rinfo.port}`);\n  });\n  server.bind(port);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 12345;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.bind(PORT);\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst port = 12345;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nserver.bind(port);\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port) {\n  const server = dgram.createSocket('udp4');\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.on('message', (msg, rinfo) => {\n    console.log(`Received ${msg} from ${rinfo.address}:${rinfo.port}`);\n  });\n  server.bind(port);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port) {\n  const server = dgram.createSocket('udp4');\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  server.on('message', (msg, rinfo) => {\n    console.log(`Received ${msg} from ${rinfo.address}:${rinfo.port}`);\n  });\n\n  server.bind(port);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port) {\n  const server = dgram.createSocket('udp4');\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.on('message', (msg, rinfo) => {\n    console.log(`Received ${msg} from ${rinfo.address}:${rinfo.port}`);\n  });\n  server.bind(port);\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port) {\n  const server = dgram.createSocket('udp4');\n  server.bind(port, () => {\n    console.log(`UDP Server listening on port ${port}`);\n  });\n\n  server.on('message', (msg, rinfo) => {\n    console.log(`Received message: ${msg.toString()} from ${rinfo.address}:${rinfo.port}`);\n  });\n\n  server.on('error', (err) => {\n    console.error(`Server error: ${err.message}`);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.bind(port, () => {\n  console.log(`UDP Server listening on port ${port}`);\n});\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\nserver.on('close', () => {\n  console.log('UDP Server closed');\n});\nserver.on('error', (err) => {\n  console.error(`UDP Server error: ${err.message}`);\n});",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port) {\n  const server = dgram.createSocket('udp4');\n  server.bind(port, () => {\n    console.log(`UDP Server listening on port ${port}`);\n  });\n\n  server.on('message', (msg, rinfo) => {\n    console.log(`Received message: ${msg.toString()} from ${rinfo.address}:${rinfo.port}`);\n  });\n\n  server.on('error', (err) => {\n    console.error(`Server error: ${err.message}`);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port) {\n  const server = dgram.createSocket('udp4');\n  server.bind(port, () => {\n    console.log(`UDP Server listening on port ${port}`);\n  });\n\n  server.on('message', (msg, rinfo) => {\n    console.log(`Received message: ${msg.toString()} from ${rinfo.address}:${rinfo.port}`);\n  });\n\n  server.on('error', (err) => {\n    console.error(`Server error: ${err.message}`);\n  });\n\n  server.on('close', () => {\n    console.log('Server closed');\n  });\n}\n```"
    ],
    "match_count": 6,
    "pass@3": 0.9666666666666667,
    "pass@5": 1.0
  },
  {
    "Task_id": 183,
    "Instruction": "Task Description: Create a function that sets up a UDP server to listen for incoming messages on a specified port and handles them using a provided callback function.\n\nFunction Description: The function `createUDPServer` initializes a UDP server using Node.js's `dgram` module. It creates a socket, sets up event handlers for errors, incoming messages, and listening status, and binds the socket to the specified port. The server processes incoming messages as UTF-8 strings and passes them to the provided callback function along with the remote address information.\n\nInput:\n- `port` (Number) - The port number on which the UDP server should listen.\n- `messageHandler` (Function) - A callback function that handles incoming messages. It receives two parameters: the message data (String) and the remote address information (Object).\n\nOutput:\n- Returns the created UDP server (dgram.Socket) instance.\n\nNote: The server will automatically start listening once created and will log its listening address to the console. Errors will be logged and will cause the server to close.",
    "Canonical_solution": "const dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n    const server = dgram.createSocket('udp4');\n\n    server.on('error', err => {\n        console.error(err);\n        server.close();\n    });\n\n    server.on('message', (msg, rinfo) => {\n        const data = msg.toString('utf8').trim();\n        if (messageHandler) {\n            messageHandler(data, rinfo);\n        }\n    });\n\n    server.on('listening', () => {\n        const address = server.address();\n        console.log(`server listening ${address.address}:${address.port}`);\n    });\n\n    server.bind(port);\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "matched_results": [
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error:\\n${err.stack}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error: ${err.message}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error: ${err.message}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error:\\n${err.stack}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => {\n  console.error(`server error: ${err.message}`);\n  server.close();\n});\nserver.on('message', (msg, rinfo) => {\n  messageHandler(msg.toString(), rinfo);\n});\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\nserver.bind(port);\nserver;",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error:\\n${err.stack}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error:\\n${err.stack}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error:\\n${err.stack}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error:\\n${err.stack}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nfunction createUDPServer(port, messageHandler) {\n  const server = dgram.createSocket('udp4');\n  server.on('error', (err) => {\n    console.error(`server error:\\n${err.stack}`);\n    server.close();\n  });\n  server.on('message', (msg, rinfo) => {\n    messageHandler(msg.toString(), rinfo);\n  });\n  server.on('listening', () => {\n    const address = server.address();\n    console.log(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n  server.bind(port);\n  return server;\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 184,
    "Instruction": "Task Description: Create a UDP server using Node.js's dgram module to handle incoming messages and respond to clients.\n\nFunction Description: The function creates a UDP server that listens for incoming messages on a specified port. When a message is received, it parses the message (assuming JSON format), logs the sender's information, and sends a response back to the client. The server also logs its binding status once it starts listening.\n\nInput: None (The port number is hardcoded as 41234 in the function.)\n\nOutput: None (The function logs messages to the console and sends responses to clients but does not return any value.)",
    "Canonical_solution": "function createUDPServer() {\n    var server = require('dgram').createSocket(\"udp4\");\n\n    server.on(\"message\", function (msg, rinfo) {\n        try {\n            msg = JSON.parse(msg);\n        } catch (e) {\n            console.dir(e);\n        }\n        console.log(\"server got message: from \" + rinfo.address + \":\" + rinfo.port);\n        console.dir(msg);\n\n        var pong = new Buffer(JSON.stringify({'command': 'pong'}));\n        server.send(pong, 0, pong.length, rinfo.port, rinfo.address, function () {\n            console.log('sent message to ' + rinfo.address + ':' + rinfo.port);\n        });\n    });\n\n    server.on(\"listening\", function () {\n        var address = server.address();\n        console.log(\"server listening \" + address.address + \":\" + address.port);\n    });\n\n    server.bind(41234);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "matched_results": [
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 41234;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log(`Received data: ${JSON.stringify(data)}`);\n    const response = { status: 'message received' };\n    server.send(JSON.stringify(response), rinfo.port, rinfo.address, (err) => {\n      if (err) {\n        console.error(`Error sending response to ${rinfo.address}:${rinfo.port}`);\n      }\n    });\n  } catch (error) {\n    console.error(`Error parsing message: ${error.message}`);\n  }\n});\n\nserver.bind(PORT);\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 41234;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log(`Received data: ${JSON.stringify(data)}`);\n    const response = { status: 'success', message: 'Message received' };\n    server.send(JSON.stringify(response), 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) {\n        console.error(`Error sending response to ${rinfo.address}:${rinfo.port}`);\n      }\n    });\n  } catch (error) {\n    console.error(`Error parsing message: ${error.message}`);\n  }\n});\n\nserver.bind(PORT);\n```",
      "```javascript\nconst dgram = require('dgram');\n\nconst server = dgram.createSocket('udp4');\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  const data = JSON.parse(msg.toString());\n  console.log(`Message data: ${data}`);\n  const response = JSON.stringify({ status: 'message received' });\n  server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n    if (err) {\n      console.error(`Error sending response to ${rinfo.address}:${rinfo.port}`);\n    }\n  });\n});\n\nserver.bind(41234);\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 41234;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log(`Received data: ${JSON.stringify(data)}`);\n    const response = { status: 'success', message: 'Message received' };\n    server.send(JSON.stringify(response), 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) {\n        console.error(`Error sending response to ${rinfo.address}:${rinfo.port}`);\n      }\n    });\n  } catch (error) {\n    console.error(`Error parsing message: ${error}`);\n  }\n});\n\nserver.bind(PORT);\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 41234;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log(`Received data: ${JSON.stringify(data)}`);\n    const response = { status: 'success', message: 'Message received' };\n    server.send(JSON.stringify(response), 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) {\n        console.error(`Error sending response to ${rinfo.address}:${rinfo.port}`);\n      }\n    });\n  } catch (error) {\n    console.error(`Error parsing message: ${error.message}`);\n  }\n});\n\nserver.bind(PORT);\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 41234;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log('Message data:', data);\n    const response = JSON.stringify({ status: 'received' });\n    server.send(response, 0, response.length, rinfo.port, rinfo.address);\n  } catch (error) {\n    console.error('Error parsing message:', error);\n  }\n});\n\nserver.bind(PORT);\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 41234;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log(`Received data: ${JSON.stringify(data)}`);\n    const response = { status: 'success', message: 'Message received' };\n    server.send(JSON.stringify(response), 0, response.length, rinfo.port, rinfo.address);\n  } catch (error) {\n    console.error('Error parsing message:', error);\n  }\n});\n\nserver.bind(PORT);\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 41234;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log('Data received:', data);\n    const response = JSON.stringify({ status: 'message received' });\n    server.send(response, 0, response.length, rinfo.port, rinfo.address);\n  } catch (error) {\n    console.error('Error parsing message:', error);\n  }\n});\n\nserver.bind(PORT);\n```",
      "```javascript\nconst dgram = require('dgram');\n\nconst server = dgram.createSocket('udp4');\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log(`Received data: ${JSON.stringify(data)}`);\n    const response = { status: 'success', message: 'Message received' };\n    server.send(JSON.stringify(response), 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) {\n        console.error(`Error sending response to ${rinfo.address}:${rinfo.port}`);\n      }\n    });\n  } catch (error) {\n    console.error(`Error parsing message: ${error.message}`);\n  }\n});\n\nserver.bind(41234);\n```",
      "```javascript\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nconst PORT = 41234;\n\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  try {\n    const data = JSON.parse(msg.toString());\n    console.log(`Received data: ${JSON.stringify(data)}`);\n    const response = { status: 'success', message: 'Message received' };\n    server.send(JSON.stringify(response), 0, response.length, rinfo.port, rinfo.address);\n  } catch (error) {\n    console.error('Error parsing message:', error);\n  }\n});\n\nserver.bind(PORT);\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Create a UDP server that listens for incoming messages, processes them, and emits events to connected clients via WebSocket. The server should handle JSON-formatted messages, manage streams of data, and maintain a history of recent messages for each stream.\n\nFunction Description: The function `setupUDPServer` initializes a UDP server using Node.js's `dgram` module. It listens for incoming messages, parses them as JSON, and manages a collection of data streams. Each message is stored in its respective stream, with a limit of 100 messages per stream. The server also emits WebSocket events to notify clients of new messages and updates to the available streams.\n\nInput: \n- `argv.udpPort` [Number] - The port number on which the UDP server should listen.\n- `argv.udpHost` [String] - The host address on which the UDP server should bind (optional, defaults to all interfaces if not specified).\n- `io` [Object] - A WebSocket server instance (e.g., from `socket.io`) used to emit events to connected clients.\n- `debug` [Function] - A logging function used to output debug information.\n\nOutput: None (The function sets up the UDP server and binds it to the specified port and host, but does not return any value.)",
    "Canonical_solution": "function setupUDPServer() {\n    const dgram = require('dgram');\n    let streams = {};\n    let socket = dgram.createSocket('udp4');\n\n    socket.on('message', function (data, remote) {\n        try { data = JSON.parse(data); }\n        catch (err) { return debug('invalid data sent'); }\n\n        if (!streams[data.id]) {\n            streams[data.id] = [];\n            io.sockets.emit('streams', Object.keys(streams));\n        }\n\n        let message = {\n            timestamp: data.timestamp,\n            streamid: data.id,\n            host: remote.address,\n            port: remote.port,\n            content: data.content,\n            type: typeof data.content\n        };\n\n        streams[data.id].length >= 100 && streams[data.id].shift();\n        streams[data.id].push(message);\n\n        debug(JSON.stringify(message));\n        io.sockets.to(data.id).emit('line', message);\n    });\n\n    socket.bind(argv.udpPort, argv.udpHost);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "matched_results": [
      "```javascript\nconst dgram = require('dgram');\nconst WebSocket = require('ws');\nconst { argv } = require('process');\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const server = dgram.createSocket('udp4');\n  const streams = {};\n\n  server.on('listening', () => {\n    const address = server.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  server.on('message', (msg, rinfo) => {\n    try {\n      const message = JSON.parse(msg.toString());\n      const streamId = message.streamId;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      if (streams[streamId].length >= 100) {\n        streams[streamId].shift();\n      }\n      streams[streamId].push(message);\n      io.emit('newMessage', message);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  server.on('error', (error) => {\n    debug(`UDP Server error: ${error}`);\n  });\n\n  server.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocket = require('ws');\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const data = JSON.parse(msg);\n      const { streamId, message } = data;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      streams[streamId].push(message);\n      if (streams[streamId].length > 100) {\n        streams[streamId].shift();\n      }\n      io.emit('newMessage', { streamId, message });\n      debug(`Message received from ${rinfo.address}:${rinfo.port}`);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.on('error', (error) => {\n    debug(`UDP Server error: ${error}`);\n  });\n\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpPort = argv.udpPort;\n  udpServer.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocket = require('ws');\nconst { argv } = require('process');\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const message = JSON.parse(msg);\n      const streamId = message.streamId;\n      if (!streams[streamId]) streams[streamId] = [];\n      if (streams[streamId].length >= 100) streams[streamId].shift();\n      streams[streamId].push(message);\n      io.emit('message', message);\n      debug(`Message received from ${rinfo.address}:${rinfo.port}`);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocketServer = require('ws').Server;\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const message = JSON.parse(msg.toString());\n      const streamId = message.streamId;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      if (streams[streamId].length >= 100) {\n        streams[streamId].shift();\n      }\n      streams[streamId].push(message);\n      io.emit('newMessage', message);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  udpServer.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocketServer = require('ws').Server;\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const data = JSON.parse(msg.toString());\n      const streamId = data.streamId;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      if (streams[streamId].length >= 100) {\n        streams[streamId].shift();\n      }\n      streams[streamId].push(data);\n      io.emit('message', data);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  udpServer.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocketServer = require('ws').Server;\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const data = JSON.parse(msg.toString());\n      const streamId = data.streamId;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      if (streams[streamId].length >= 100) {\n        streams[streamId].shift();\n      }\n      streams[streamId].push(data);\n      io.emit('newMessage', { streamId, message: data });\n      debug(`Message received from ${rinfo.address}:${rinfo.port}`);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocketServer = require('ws').Server;\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const data = JSON.parse(msg.toString());\n      const streamId = data.streamId;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      if (streams[streamId].length >= 100) {\n        streams[streamId].shift();\n      }\n      streams[streamId].push(data);\n      io.emit('newMessage', { streamId, message: data });\n      debug(`Message received from ${rinfo.address}:${rinfo.port}`);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocketServer = require('ws').Server;\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const data = JSON.parse(msg.toString());\n      const streamId = data.streamId;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      if (streams[streamId].length >= 100) {\n        streams[streamId].shift();\n      }\n      streams[streamId].push(data);\n      io.emit('message', data);\n      debug(`Message from ${rinfo.address}:${rinfo.port}`);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.on('error', (error) => {\n    debug(`UDP Server error: ${error}`);\n  });\n\n  udpServer.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocketServer = require('ws').Server;\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const data = JSON.parse(msg.toString());\n      const streamId = data.streamId;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      if (streams[streamId].length >= 100) {\n        streams[streamId].shift();\n      }\n      streams[streamId].push(data);\n      io.emit('newMessage', { streamId, message: data });\n      debug(`Message received from ${rinfo.address}:${rinfo.port}`);\n    } catch (error) {\n      debug(`Error parsing message: ${error}`);\n    }\n  });\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.bind(udpPort, udpHost);\n}\n```",
      "```javascript\nconst dgram = require('dgram');\nconst WebSocketServer = require('ws').Server;\n\nfunction setupUDPServer(argv, io, debug) {\n  const udpPort = argv.udpPort;\n  const udpHost = argv.udpHost || '0.0.0.0';\n  const udpServer = dgram.createSocket('udp4');\n  const streams = {};\n\n  udpServer.on('message', (msg, rinfo) => {\n    try {\n      const data = JSON.parse(msg.toString());\n      const streamId = data.streamId;\n      if (!streams[streamId]) {\n        streams[streamId] = [];\n      }\n      if (streams[streamId].length >= 100) {\n        streams[streamId].shift();\n      }\n      streams[streamId].push(data);\n      io.emit('message', data);\n      debug(`Message from ${rinfo.address}:${rinfo.port}`);\n    } catch (e) {\n      debug(`Error parsing message: ${e}`);\n    }\n  });\n\n  udpServer.on('listening', () => {\n    const address = udpServer.address();\n    debug(`UDP Server listening on ${address.address}:${address.port}`);\n  });\n\n  udpServer.on('error', (err) => {\n    debug(`UDP Server error: ${err}`);\n  });\n\n  udpServer.bind(udpPort, udpHost);\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Create a UDP communication class in JavaScript using Node.js's dgram module for bidirectional message handling between processes.\n\nClass Description: The Udp class facilitates UDP-based communication with capabilities for both sending and receiving messages. It manages socket creation, port binding, message queuing, and event handling for network communication.\n\nAttributes:\n- stack: [Array] - Stores outgoing messages in a queue before sending\n- port: [Number|null] - The target port number for outgoing messages\n- socket: [dgram.Socket|null] - UDP socket instance for sending messages\n- listener: [dgram.Socket|null] - UDP socket instance for receiving messages\n- client: [Object] - Reference to the parent client object for message handling\n\nMethods:\n- constructor(client) -> [void] - Initializes the UDP instance with a client reference and creates socket objects\n- start() -> [void] - Begins UDP communication by setting up input and output sockets\n- clear() -> [void] - Clears the message queue\n- run() -> [void] - Processes all messages in the queue\n- push(msg) -> [void] - Adds a message to the outgoing queue (Input: msg [String] - Message to send)\n- play(data) -> [void] - Sends a single message via UDP (Input: data [String] - Message content)\n- selectOutput(port=49161) -> [void] - Configures the output port (Input: port [Number] - Target port number)\n- selectInput(port=49160) -> [void] - Configures and starts the input listener (Input: port [Number] - Listening port number)",
    "Canonical_solution": "const dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = dgram ? dgram.createSocket('udp4') : null;\n    this.listener = dgram ? dgram.createSocket('udp4') : null;\n    this.client = client;\n  }\n\n  start() {\n    if (!dgram || !this.socket || !this.listener) { \n      console.warn('UDP', 'Could not start.'); \n      return; \n    }\n    console.info('UDP', 'Starting..');\n\n    this.selectInput();\n    this.selectOutput();\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    for (const item of this.stack) {\n      this.play(item);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (!this.socket) { return; }\n    this.socket.send(Buffer.from(`${data}`), this.port, this.client.io.ip, (err) => {\n      if (err) { console.warn(err); }\n    });\n  }\n\n  selectOutput(port = 49161) {\n    if (!dgram) { console.warn('UDP', 'Unavailable.'); return; }\n    if (parseInt(port) === this.port) { console.warn('UDP', 'Already selected'); return; }\n    if (isNaN(port) || port < 1000) { console.warn('UDP', 'Unavailable port'); return; }\n\n    console.log('UDP', `Output: ${port}`);\n    this.port = parseInt(port);\n  }\n\n  selectInput(port = 49160) {\n    if (!dgram) { console.warn('UDP', 'Unavailable.'); return; }\n    if (this.listener) { this.listener.close(); }\n\n    console.log('UDP', `Input: ${port}`);\n    this.listener = dgram.createSocket('udp4');\n\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.commander.trigger(`${msg}`);\n    });\n\n    this.listener.on('listening', () => {\n      const address = this.listener.address();\n      console.info('UDP', `Started socket at ${address.address}:${address.port}`);\n    });\n\n    this.listener.on('error', (err) => {\n      console.warn('UDP', `Server error:\\n ${err.stack}`);\n      this.listener.close();\n    });\n\n    this.listener.bind(port);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "matched_results": [
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n    constructor(client) {\n        this.stack = [];\n        this.port = null;\n        this.socket = null;\n        this.listener = null;\n        this.client = client;\n    }\n\n    start() {\n        this.listener = dgram.createSocket('udp4');\n        this.listener.on('message', (msg, rinfo) => {\n            this.client.handleMessage(msg.toString());\n        });\n        this.listener.on('listening', () => {\n            const address = this.listener.address();\n            console.log(`UDP listener listening on ${address.address}:${address.port}`);\n        });\n        this.listener.on('error', (err) => {\n            console.error(`UDP listener error: ${err.message}`);\n        });\n    }\n\n    clear() {\n        this.stack = [];\n    }\n\n    run() {\n        while (this.stack.length > 0) {\n            const msg = this.stack.shift();\n            this.play(msg);\n        }\n    }\n\n    push(msg) {\n        this.stack.push(msg);\n    }\n\n    play(data) {\n        if (this.socket) {\n            this.socket.send(data, 0, data.length, this.port, 'localhost', (err) => {\n                if (err) {\n                    console.error(`UDP send error: ${err.message}`);\n                }\n            });\n        }\n    }\n\n    selectOutput(port = 49161) {\n        this.port = port;\n        this.socket = dgram.createSocket('udp4');\n        this.socket.on('message', (msg, rinfo) => {\n            this.client.handleMessage(msg.toString());\n        });\n        this.socket.on('error', (err) => {\n            console.error(`UDP socket error: ${err.message}`);\n        });\n    }\n\n    selectInput(port = 49160) {\n        this.listener.bind(port);\n    }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.socket = dgram.createSocket('udp4');\n    this.listener = dgram.createSocket('udp4');\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      const msg = this.stack.shift();\n      this.play(msg);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (this.port) {\n      this.socket.send(data, 0, data.length, this.port, 'localhost');\n    }\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n  }\n\n  selectInput(port = 49160) {\n    this.listener.bind(port);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.socket = dgram.createSocket('udp4');\n    this.listener = dgram.createSocket('udp4');\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      const msg = this.stack.shift();\n      this.play(msg);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (this.port) {\n      this.socket.send(data, 0, data.length, this.port, 'localhost');\n    }\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n  }\n\n  selectInput(port = 49160) {\n    this.listener.bind(port);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.socket = dgram.createSocket('udp4');\n    this.socket.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n    this.listener = dgram.createSocket('udp4');\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      const msg = this.stack.shift();\n      this.play(msg);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (this.port) {\n      this.socket.send(data, 0, data.length, this.port, 'localhost');\n    }\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n  }\n\n  selectInput(port = 49160) {\n    this.listener.bind(port);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n    constructor(client) {\n        this.stack = [];\n        this.port = null;\n        this.socket = null;\n        this.listener = null;\n        this.client = client;\n    }\n\n    start() {\n        this.socket = dgram.createSocket('udp4');\n        this.listener = dgram.createSocket('udp4');\n        this.listener.on('message', (msg, rinfo) => {\n            this.client.handleMessage(msg.toString());\n        });\n        this.listener.on('listening', () => {\n            const address = this.listener.address();\n            console.log(`UDP listener listening on ${address.address}:${address.port}`);\n        });\n    }\n\n    clear() {\n        this.stack = [];\n    }\n\n    run() {\n        while (this.stack.length > 0) {\n            const msg = this.stack.shift();\n            this.play(msg);\n        }\n    }\n\n    push(msg) {\n        this.stack.push(msg);\n    }\n\n    play(data) {\n        if (this.port) {\n            this.socket.send(data, 0, data.length, this.port, 'localhost', (err) => {\n                if (err) {\n                    console.error('Error sending message:', err);\n                }\n            });\n        }\n    }\n\n    selectOutput(port = 49161) {\n        this.port = port;\n    }\n\n    selectInput(port = 49160) {\n        this.listener.bind(port);\n    }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.listener = dgram.createSocket('udp4');\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n    this.listener.on('listening', () => {\n      const address = this.listener.address();\n      console.log(`UDP listener listening on ${address.address}:${address.port}`);\n    });\n    this.listener.on('error', (err) => {\n      console.error(`UDP listener error: ${err.message}`);\n    });\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      const msg = this.stack.shift();\n      this.play(msg);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (this.socket) {\n      this.socket.send(data, 0, data.length, this.port, 'localhost', (err) => {\n        if (err) {\n          console.error(`UDP send error: ${err.message}`);\n        }\n      });\n    }\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n    this.socket = dgram.createSocket('udp4');\n    this.socket.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n    this.socket.on('error', (err) => {\n      console.error(`UDP socket error: ${err.message}`);\n    });\n  }\n\n  selectInput(port = 49160) {\n    this.listener.bind(port);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n    constructor(client) {\n        this.stack = [];\n        this.port = null;\n        this.socket = null;\n        this.listener = null;\n        this.client = client;\n    }\n\n    start() {\n        this.socket = dgram.createSocket('udp4');\n        this.listener = dgram.createSocket('udp4');\n        this.listener.on('message', (msg, rinfo) => {\n            this.client.handleMessage(msg.toString());\n        });\n        this.listener.on('listening', () => {\n            const address = this.listener.address();\n            console.log(`UDP listener listening on ${address.address}:${address.port}`);\n        });\n    }\n\n    clear() {\n        this.stack = [];\n    }\n\n    run() {\n        while (this.stack.length > 0) {\n            const msg = this.stack.shift();\n            this.play(msg);\n        }\n    }\n\n    push(msg) {\n        this.stack.push(msg);\n    }\n\n    play(data) {\n        if (this.port !== null) {\n            this.socket.send(data, 0, data.length, this.port, 'localhost', (err) => {\n                if (err) {\n                    console.error('Error sending message:', err);\n                }\n            });\n        }\n    }\n\n    selectOutput(port = 49161) {\n        this.port = port;\n    }\n\n    selectInput(port = 49160) {\n        this.listener.bind(port);\n    }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.socket = dgram.createSocket('udp4');\n    this.listener = dgram.createSocket('udp4');\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      const msg = this.stack.shift();\n      this.play(msg);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (this.port) {\n      this.socket.send(data, 0, data.length, this.port, 'localhost');\n    }\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n  }\n\n  selectInput(port = 49160) {\n    this.listener.bind(port);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n    constructor(client) {\n        this.stack = [];\n        this.port = null;\n        this.socket = null;\n        this.listener = null;\n        this.client = client;\n    }\n\n    start() {\n        this.listener = dgram.createSocket('udp4');\n        this.listener.on('message', (msg, rinfo) => {\n            this.client.handleMessage(msg.toString());\n        });\n        this.listener.on('listening', () => {\n            const address = this.listener.address();\n            console.log(`UDP listener listening on ${address.address}:${address.port}`);\n        });\n        this.listener.on('error', (err) => {\n            console.error(`UDP listener error: ${err.message}`);\n        });\n    }\n\n    clear() {\n        this.stack = [];\n    }\n\n    run() {\n        while (this.stack.length > 0) {\n            const msg = this.stack.shift();\n            this.play(msg);\n        }\n    }\n\n    push(msg) {\n        this.stack.push(msg);\n    }\n\n    play(data) {\n        if (this.socket) {\n            this.socket.send(data, 0, data.length, this.port, 'localhost', (err) => {\n                if (err) {\n                    console.error(`UDP send error: ${err.message}`);\n                }\n            });\n        }\n    }\n\n    selectOutput(port = 49161) {\n        this.port = port;\n        this.socket = dgram.createSocket('udp4');\n        this.socket.on('message', (msg, rinfo) => {\n            this.client.handleMessage(msg.toString());\n        });\n        this.socket.on('close', () => {\n            console.log('UDP socket closed');\n        });\n        this.socket.on('error', (err) => {\n            console.error(`UDP socket error: ${err.message}`);\n        });\n    }\n\n    selectInput(port = 49160) {\n        this.listener.bind(port);\n    }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.socket = dgram.createSocket('udp4');\n    this.socket.on('message', (msg, rinfo) => {\n      this.client.handleMessage(msg.toString());\n    });\n    this.socket.on('listening', () => {\n      const address = this.socket.address();\n      console.log(`UDP server listening ${address.address}:${address.port}`);\n    });\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      const msg = this.stack.shift();\n      this.play(msg);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (this.port !== null) {\n      this.socket.send(data, 0, data.length, this.port, 'localhost');\n    }\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n  }\n\n  selectInput(port = 49160) {\n    this.listener = dgram.createSocket('udp4');\n    this.listener.bind(port);\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Implement a UDP-based server discovery system that allows servers to broadcast their presence and receive information about other nearby servers on the network.\n\nClass Description: The class provides functionality for UDP-based server discovery, including broadcasting server presence (heartbeats) and listening for broadcasts from other servers. It maintains a list of discovered servers and handles network communication errors.\n\nAttributes:\n- nearbyServers: [Object] - A dictionary storing information about discovered nearby servers, keyed by hostname.\n- lastDiscoveryBroadcast: [Number] - Timestamp of the last broadcast sent by this server.\n- broadcastIP: [String] - The broadcast IP address used for sending discovery messages.\n- discoveryListener: [Object] - The UDP socket instance used for listening to discovery messages.\n\nMethods:\n- setupDiscovery([callback: Function]) -> [void] - Initializes the UDP listener socket and binds it to the configured port. The optional callback is executed when binding is complete.\n- discoveryBroadcast([type: String, message: Object, callback: Function]) -> [void] - Creates a UDP client to broadcast a message of the specified type. The message should be an object that will be stringified to JSON. The optional callback is executed after the message is sent.\n- discoveryReceive([msg: Buffer, rinfo: Object]) -> [void] - Handles incoming UDP messages, parsing them as JSON and processing different message types (currently only 'heartbeat' is implemented). Updates the nearbyServers list when valid messages are received.\n- shutdownDiscovery() -> [void] - Closes the UDP listener socket if it exists, cleaning up network resources.\n- calcBroadcastIP() -> [String] - (Implied but not shown) Calculates the broadcast IP address based on network interfaces.",
    "Canonical_solution": "var dgram = require(\"dgram\");\nvar os = require('os');\nvar Netmask = require('netmask').Netmask;\n\nvar Class = require(\"pixl-class\");\nvar Tools = require(\"pixl-tools\");\n\nmodule.exports = Class.create({\n\t\n\tnearbyServers: null,\n\tlastDiscoveryBroadcast: 0,\n\t\n\tsetupDiscovery: function(callback) {\n\t\tvar self = this;\n\t\t\n\t\tthis.nearbyServers = {};\n\t\tthis.lastDiscoveryBroadcast = 0;\n\t\t\n\t\tif (!this.server.config.get('udp_broadcast_port')) {\n\t\t\tif (callback) callback();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.broadcastIP = this.server.config.get('broadcast_ip') || this.calcBroadcastIP();\n\t\t\n\t\tvar listener = this.discoveryListener = dgram.createSocket(\"udp4\");\n\t\t\n\t\tlistener.on(\"message\", function (msg, rinfo) {\n\t\t\tself.discoveryReceive( msg, rinfo );\n\t\t} );\n\t\t\n\t\tlistener.on(\"error\", function (err) {\n\t\t\tself.logError('udp', \"UDP socket listener error: \" + err);\n\t\t\tself.discoveryListener = null;\n\t\t} );\n\t\t\n\t\tlistener.bind( this.server.config.get('udp_broadcast_port'), function() {\n\t\t\tif (callback) callback();\n\t\t} );\n\t},\n\t\n\tdiscoveryBroadcast: function(type, message, callback) {\n\t\tvar self = this;\n\t\t\n\t\tmessage.action = type;\n\t\t\n\t\tvar client = dgram.createSocket('udp4');\n\t\tvar message = Buffer.from( JSON.stringify(message) + \"\\n\" );\n\t\tclient.bind( 0, function() {\n\t\t\tclient.setBroadcast( true );\t\t\t\n\t\t\tclient.send(message, 0, message.length, self.server.config.get('udp_broadcast_port'), self.broadcastIP, function(err) {\n\t\t\t\tif (err) self.logDebug(9, \"UDP broadcast failed: \" + err);\n\t\t\t\tclient.close();\n\t\t\t\tif (callback) callback();\n\t\t\t} );\n\t\t} );\n\t},\n\t\n\tdiscoveryReceive: function(msg, rinfo) {\n\t\tvar text = msg.toString();\n\t\tif (text.match(/^\\{/)) {\n\t\t\tvar json = null;\n\t\t\ttry { json = JSON.parse(text); }\n\t\t\tcatch (e) {\n\t\t\t\tthis.logError(9, \"Failed to parse UDP JSON message: \" + e);\n\t\t\t}\n\t\t\tif (json && json.action) {\n\t\t\t\tswitch (json.action) {\n\t\t\t\t\tcase 'heartbeat':\n\t\t\t\t\t\tif (json.hostname && (json.hostname != this.server.hostname)) {\n\t\t\t\t\t\t\tjson.now = Tools.timeNow();\n\t\t\t\t\t\t\tdelete json.action;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!this.nearbyServers[ json.hostname ]) {\n\t\t\t\t\t\t\t\tthis.nearbyServers[ json.hostname ] = json;\n\t\t\t\t\t\t\t\tif (this.multi.master) {\n\t\t\t\t\t\t\t\t\tthis.logDebug(6, \"Discovered nearby server: \" + json.hostname, json);\n\t\t\t\t\t\t\t\t\tthis.authSocketEmit( 'update', { nearby: this.nearbyServers } );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.nearbyServers[ json.hostname ] = json;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\tshutdownDiscovery: function() {\n\t\tif (this.discoveryListener) {\n\t\t\tthis.discoveryListener.close();\n\t\t}\n\t}\n});",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = 0\n        self.broadcastIP = ''\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message_to_send = json.dumps({'type': type, 'message': message})\n        client.sendto(message_to_send.encode(), (self.broadcastIP, 0))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            data = json.loads(msg.decode())\n            if data['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = data['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        interfaces = socket.getaddrinfo(socket.gethostname(), None)\n        for interface in interfaces:\n            if interface[0] == socket.AF_INET:\n                return interface[4][0]\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = time.time()\n        self.broadcastIP = \"\"\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message_to_send = json.dumps({\"type\": type, \"message\": message})\n        client.sendto(message_to_send.encode(), (self.broadcastIP, 0))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            message = json.loads(msg.decode())\n            if message['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = message['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        # This method is implied but not shown in the task description.\n        # It would contain logic to determine the broadcast IP address.\n        pass\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = time.time()\n        self.broadcastIP = ''\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message_str = json.dumps({'type': type, 'message': message})\n        client.sendto(message_str.encode(), (self.broadcastIP, 0))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            message = json.loads(msg.decode())\n            if message['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = message['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        interfaces = socket.getaddrinfo(socket.gethostname(), None)\n        for interface in interfaces:\n            if interface[0] == socket.AF_INET:\n                return interface[4][0]\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = 0\n        self.broadcastIP = \"\"\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        self.broadcastIP = self.calcBroadcastIP()\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message_to_send = json.dumps({'type': type, 'message': message})\n        client.sendto(message_to_send.encode(), (self.broadcastIP, 12345))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            data = json.loads(msg.decode())\n            if data['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = data['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        # This method is implied and not shown in the task description\n        # It should calculate the broadcast IP address based on network interfaces\n        return '192.168.1.255'\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = 0\n        self.broadcastIP = ''\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message = json.dumps({'type': type, 'message': message})\n        client.sendto(message.encode(), (self.broadcastIP, 12345))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            data = json.loads(msg.decode())\n            if data['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = data['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        # This method is not shown but would be implemented to calculate the broadcast IP\n        pass\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = 0\n        self.broadcastIP = \"\"\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message = json.dumps({'type': type, 'message': message})\n        client.sendto(message.encode(), (self.broadcastIP, 0))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            data = json.loads(msg.decode())\n            if data['type'] == 'heartbeat':\n                self.nearbyServers[rinfo['addr'][0]] = data['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        # This method is implied but not shown in the task description.\n        # It would calculate the broadcast IP address based on network interfaces.\n        pass\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = 0\n        self.broadcastIP = \"\"\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message = json.dumps({'type': type, 'message': message})\n        client.sendto(message.encode(), (self.broadcastIP, 0))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            data = json.loads(msg.decode())\n            if data['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = data['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        interfaces = socket.getaddrinfo(socket.gethostname(), None)\n        for interface in interfaces:\n            if interface[0] == socket.AF_INET:\n                return interface[4][0]\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = 0\n        self.broadcastIP = ''\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message = json.dumps({'type': type, 'message': message})\n        client.sendto(message.encode(), (self.broadcastIP, 0))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            data = json.loads(msg.decode())\n            if data['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = data['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        interfaces = socket.getaddrinfo(socket.gethostname(), None)\n        for interface in interfaces:\n            if interface[0] == socket.AF_INET:\n                return interface[4][0]\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = 0\n        self.broadcastIP = ''\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message_str = json.dumps({'type': type, 'message': message})\n        client.sendto(message_str.encode(), (self.broadcastIP, 0))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            message = json.loads(msg.decode())\n            if message['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = message['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        # This method is not shown, but would be implemented here.\n        pass\n```",
      "```python\nimport socket\nimport json\nimport time\n\nclass ServerDiscovery:\n    def __init__(self):\n        self.nearbyServers = {}\n        self.lastDiscoveryBroadcast = 0\n        self.broadcastIP = ''\n        self.discoveryListener = None\n\n    def setupDiscovery(self, callback=None):\n        self.discoveryListener = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.discoveryListener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.discoveryListener.bind(('', 0))\n        if callback:\n            callback()\n\n    def discoveryBroadcast(self, type, message, callback=None):\n        client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        message = json.dumps({'type': type, 'message': message})\n        client.sendto(message.encode(), (self.broadcastIP, 0))\n        if callback:\n            callback()\n\n    def discoveryReceive(self, msg, rinfo):\n        try:\n            data = json.loads(msg.decode())\n            if data['type'] == 'heartbeat':\n                self.nearbyServers[rinfo[0]] = data['message']\n        except json.JSONDecodeError:\n            pass\n\n    def shutdownDiscovery(self):\n        if self.discoveryListener:\n            self.discoveryListener.close()\n\n    def calcBroadcastIP(self):\n        interfaces = socket.getaddrinfo(socket.gethostname(), None)\n        for interface in interfaces:\n            if interface[0] == socket.AF_INET:\n                return interface[4][0]\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Create a UDP-based poller class in JavaScript that can send ping messages to a target UDP server and handle pong responses, with timeout functionality.\n\nClass Description: The UdpPoller class is designed to monitor UDP servers by sending periodic ping messages and listening for pong responses. It inherits from a base poller class and implements UDP communication using Node.js's dgram module.\n\nAttributes:\n- udpServer: [Object] - The UDP socket instance created using dgram module\n- target: [Object/String] - The target server address and port (parsed from input URL)\n- timeout: [Number] - The maximum time to wait for a response before timing out\n- callback: [Function] - The callback function to be executed when a response is received or an error occurs\n\nMethods:\n- constructor(target, timeout, callback) -> [void] - Initializes the poller with target, timeout, and callback\n- static get type() -> [String] - Returns the poller type ('udp')\n- static validateTarget(target) -> [Boolean] - Validates if the target URL matches UDP format\n- initialize() -> [void] - Sets up the UDP socket and parses the target address\n- poll() -> [void] - Sends a ping message to the target server and sets up response listener\n- onResponseCallback(message, sender) -> [void] - Handles incoming messages and processes pong responses\n- timeoutReached() -> [void] - Cleans up socket listeners when timeout occurs",
    "Canonical_solution": "var util = require('util');\nvar dgram = require('dgram');\nvar BasePoller = require('../basePoller');\n\nclass UdpPoller {\n  constructor(target, timeout, callback) {\n    UdpPoller.super_.call(this, target, timeout, callback);\n    this.udpServer = null;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    return reg.test(target);\n  }\n\n  initialize() {\n    this.udpServer = dgram.createSocket('udp4');\n    this.udpServer.bind();\n    this.udpServer.on('error', function() {});\n    \n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    if(!reg.test(this.target)) {\n      console.log(this.target + ' does not seems to be valid udp url');\n    }\n    var host = reg.exec(this.target);\n    this.target = {\n      'address': host[1],\n      'port': host[2]\n    };\n  }\n\n  poll() {\n    var ping = new Buffer(JSON.stringify({'command': 'ping'}));\n    this.udpServer.send(ping, 0, ping.length, this.target.port, this.target.address);\n    this.udpServer.on(\"message\", this.onResponseCallback.bind(this));\n  }\n\n  onResponseCallback(message, sender) {\n    var cmd;\n    try {\n      cmd = JSON.parse(message);\n    } catch (e) {\n      return this.onErrorCallback({ name: \"Unparsable answer\", message: \"server return answer \" + message.toString()});\n    }\n    if (cmd.command === 'pong') {\n      this.timer.stop();\n      this.callback(null, this.getTime(), cmd);\n    }\n  }\n\n  timeoutReached() {\n    this.udpServer.removeAllListeners();\n  }\n}\n\nutil.inherits(UdpPoller, BasePoller);",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (err) => {\n      this.callback(err);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    clearTimeout(this.timeoutId);\n    this.callback(null, message, sender);\n  }\n\n  timeoutReached() {\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target URL and extract address and port\n  }\n\n  close() {\n    this.udpServer.close();\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (err) => {\n      this.callback(err, null);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err, null);\n      } else {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    clearTimeout(this.timeoutId);\n    this.callback(null, message);\n  }\n\n  timeoutReached() {\n    this.udpServer.close();\n    this.callback(new Error('Timeout reached'), null);\n  }\n\n  parseTarget(target) {\n    // Parse target URL and return address and port\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (err) => {\n      this.callback(err);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    clearTimeout(this.timeoutId);\n    this.callback(null, message);\n  }\n\n  timeoutReached() {\n    this.udpServer.close();\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target address and port\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (error) => {\n      this.callback(error);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    clearTimeout(this.timeoutId);\n    this.callback(null, message);\n  }\n\n  timeoutReached() {\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target URL and extract address and port\n  }\n\n  close() {\n    this.udpServer.close();\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (err) => {\n      this.callback(err);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    clearTimeout(this.timeoutId);\n    this.callback(null, message, sender);\n  }\n\n  timeoutReached() {\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target URL and extract address and port\n  }\n\n  close() {\n    this.udpServer.close();\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (err) => {\n      this.callback(err);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    clearTimeout(this.timeoutId);\n    this.callback(null, message);\n  }\n\n  timeoutReached() {\n    this.udpServer.close();\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target URL and extract address and port\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (err) => {\n      this.callback(err);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    this.callback(null, message);\n  }\n\n  timeoutReached() {\n    this.udpServer.close();\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target URL to get address and port\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (err) => {\n      this.callback(err);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    clearTimeout(this.timeoutId);\n    this.callback(null, message, sender);\n  }\n\n  timeoutReached() {\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target URL and extract address and port\n  }\n\n  close() {\n    this.udpServer.close();\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (error) => {\n      this.callback(error);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    clearTimeout(this.timeoutId);\n    this.callback(null, message);\n  }\n\n  timeoutReached() {\n    this.udpServer.close();\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target URL and extract address and port\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super();\n    this.udpServer = dgram.createSocket('udp4');\n    this.target = this.parseTarget(target);\n    this.timeout = timeout;\n    this.callback = callback;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    // Validate target URL format\n  }\n\n  initialize() {\n    this.udpServer.on('message', (message, sender) => {\n      this.onResponseCallback(message, sender);\n    });\n    this.udpServer.on('error', (err) => {\n      this.callback(err);\n    });\n  }\n\n  poll() {\n    const pingMessage = Buffer.from('ping');\n    this.udpServer.send(pingMessage, 0, pingMessage.length, this.target.port, this.target.address, (err) => {\n      if (err) {\n        this.callback(err);\n      } else {\n        setTimeout(() => {\n          this.timeoutReached();\n        }, this.timeout);\n      }\n    });\n  }\n\n  onResponseCallback(message, sender) {\n    this.callback(null, message.toString());\n  }\n\n  timeoutReached() {\n    this.udpServer.close();\n    this.callback(new Error('Timeout reached'));\n  }\n\n  parseTarget(target) {\n    // Parse target URL and extract address and port\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a class that implements inter-process communication (IPC) using UDP sockets in Node.js, allowing communication between a master process and worker processes.\n\nClass Description: The MasterIPC class facilitates communication between a master process and worker processes using UDP sockets. It handles socket creation, message parsing, method invocation, and event emission for worker connections and restarts.\n\nAttributes:\n- options: [Object] - Configuration options including socket port and address.\n- _sock: [dgram.Socket] - The UDP socket instance for communication.\n- children: [Array] - List of connected worker processes.\n- sock: [dgram.Socket] - Alternative socket reference used for sending messages.\n\nMethods:\n- IPCSocket() -> [dgram.Socket] - Creates and configures a UDP socket if not already created, setting up message event handling.\n- setupIPC() -> [void] - Binds the socket to the specified port and address, emits 'start' event when listening.\n- call(id, method, ...args) -> [void] - Sends a message to a worker process with the specified ID, method, and arguments.\n- invoke(method, args, worker) -> [void] - Invokes the specified method with given arguments and worker context if the method exists.\n- connect(worker) -> [void] - Emits a 'worker connected' event for the specified worker.\n- connectMaster(sig) -> [void] - Kills the parent process with the specified signal, either immediately or after the socket is listening.\n- masterKilled(data) -> [void] - Emits a 'restart' event with the provided data.",
    "Canonical_solution": "var dgram = require('dgram');\nvar net = require('net');\nvar utils = require('./utils');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n  }\n\n  IPCSocket() {\n    var self = this;\n    if (this._sock) return this._sock;\n    \n    this._sock = dgram.createSocket('udp4');\n    this._sock.on('message', function(msg, info) {\n      try {\n        msg = JSON.parse(msg.toString('ascii'));\n        self.invoke(msg.method, msg.args, self.children[msg.id]);\n      } catch (err) {\n        console.error(err.stack || String(err));\n      }\n    });\n    return this._sock;\n  }\n\n  setupIPC() {\n    var self = this;\n    this.IPCSocket().on('listening', function() {\n      process.nextTick(function() {\n        self.emit('start');\n      });\n    });\n    this.IPCSocket().bind(\n      this.options['socket port'],\n      this.options['socket addr']\n    );\n  }\n\n  call(id, method) {\n    this.sock = this.sock || dgram.createSocket('udp4');\n    var msg = new Buffer(utils.frame({\n      args: utils.toArray(arguments, 2),\n      method: method,\n      id: id\n    }));\n    this.sock.send(\n      msg,\n      0,\n      msg.length,\n      this.options['socket port'],\n      this.options['socket addr']\n    );\n  }\n\n  invoke(method, args, worker) {\n    if (this[method]) {\n      this[method].apply(this, args.concat(worker));\n    }\n  }\n\n  connect(worker) {\n    this.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    var self = this;\n    function kill() {\n      process.kill(self.ppid, sig);\n    }\n    if (this.listening) return kill();\n    this.on('listening', kill);\n  }\n\n  masterKilled(data) {\n    this.emit('restart', data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "matched_results": [
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', (msg, rinfo) => {\n        const data = JSON.parse(msg.toString());\n        this.invoke(data.method, data.args, data.worker);\n      });\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this.sock = this.IPCSocket();\n    this.sock.bind(this.options.port, this.options.address, () => {\n      this.sock.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const data = JSON.stringify({ id, method, args });\n    this.sock.send(data, 0, data.length, this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (typeof worker[method] === 'function') {\n      worker[method](...args);\n    }\n  }\n\n  connect(worker) {\n    this.children.push(worker);\n    this.sock.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    process.on('SIGTERM', () => {\n      process.kill(process.pid, sig);\n    });\n    this.setupIPC();\n  }\n\n  masterKilled(data) {\n    this.sock.emit('restart', data);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n    constructor(options) {\n        this.options = options;\n        this._sock = null;\n        this.children = [];\n        this.sock = null;\n    }\n\n    IPCSocket() {\n        if (!this._sock) {\n            this._sock = dgram.createSocket('udp4');\n            this._sock.on('message', (msg, rinfo) => {\n                const data = JSON.parse(msg.toString());\n                if (data.type === 'worker connected') {\n                    this.connect(data.worker);\n                } else if (data.type === 'master killed') {\n                    this.masterKilled(data.data);\n                }\n            });\n        }\n        return this._sock;\n    }\n\n    setupIPC() {\n        this.sock = this.IPCSocket();\n        this.sock.bind(this.options.port, this.options.address, () => {\n            this.sock.emit('start');\n        });\n    }\n\n    call(id, method, ...args) {\n        const message = JSON.stringify({ type: 'call', id, method, args });\n        this.sock.send(message, 0, message.length, this.options.port, this.options.address);\n    }\n\n    invoke(method, args, worker) {\n        if (typeof worker[method] === 'function') {\n            worker[method](...args);\n        }\n    }\n\n    connect(worker) {\n        this.children.push(worker);\n        this.sock.emit('worker connected', worker);\n    }\n\n    connectMaster(sig) {\n        if (this.sock && this.sock.listening) {\n            process.kill(process.pid, sig);\n        } else {\n            this.sock.on('listening', () => {\n                process.kill(process.pid, sig);\n            });\n        }\n    }\n\n    masterKilled(data) {\n        this.sock.emit('restart', data);\n    }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', (msg, rinfo) => {\n        const data = JSON.parse(msg.toString());\n        this.handleMessage(data, rinfo);\n      });\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this.sock = this.IPCSocket();\n    this.sock.bind(this.options.port, this.options.address, () => {\n      this.sock.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const message = JSON.stringify({ id, method, args });\n    this.sock.send(message, 0, message.length, this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (typeof worker[method] === 'function') {\n      worker[method](...args);\n    }\n  }\n\n  connect(worker) {\n    this.children.push(worker);\n    this.sock.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    process.on('SIGTERM', () => {\n      process.kill(process.pid, sig);\n    });\n    this.setupIPC();\n  }\n\n  masterKilled(data) {\n    this.sock.emit('restart', data);\n  }\n\n  handleMessage(data, rinfo) {\n    if (data.type === 'request') {\n      const worker = this.children.find(child => child.id === data.id);\n      this.invoke(data.method, data.args, worker);\n    }\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', (msg, rinfo) => {\n        const data = JSON.parse(msg.toString());\n        if (data.type === 'worker connected') {\n          this.connect(data.worker);\n        } else if (data.type === 'master killed') {\n          this.masterKilled(data.data);\n        }\n      });\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this.sock = this.IPCSocket();\n    this.sock.bind(this.options.port, this.options.address, () => {\n      this.sock.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const message = JSON.stringify({ type: 'call', id, method, args });\n    this.sock.send(message, 0, message.length, this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (this[method]) {\n      this[method].apply(this, args);\n    }\n  }\n\n  connect(worker) {\n    this.children.push(worker);\n    this.sock.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    process.on('SIGTERM', () => {\n      process.kill(process.pid, sig);\n    });\n    this.setupIPC();\n  }\n\n  masterKilled(data) {\n    this.sock.emit('restart', data);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', (msg, rinfo) => {\n        const data = JSON.parse(msg.toString());\n        if (data.type === 'worker connected') {\n          this.connect(data.worker);\n        } else if (data.type === 'master killed') {\n          this.masterKilled(data.data);\n        }\n      });\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this.sock = this.IPCSocket();\n    this.sock.bind(this.options.port, this.options.address, () => {\n      this.sock.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const message = JSON.stringify({ type: 'call', id, method, args });\n    this.sock.send(message, 0, message.length, this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (this[method]) {\n      this[method].apply(this, args);\n    }\n  }\n\n  connect(worker) {\n    this.children.push(worker);\n    this.sock.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    if (sig === 'immediate') {\n      process.kill(process.pid, 'SIGTERM');\n    } else {\n      this.setupIPC();\n    }\n  }\n\n  masterKilled(data) {\n    this.sock.emit('restart', data);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', (msg, rinfo) => {\n        const data = JSON.parse(msg.toString());\n        this.invoke(data.method, data.args, data.worker);\n      });\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this._sock = this.IPCSocket();\n    this._sock.bind(this.options.port, this.options.address, () => {\n      this.sock = this._sock;\n      this.sock.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const data = JSON.stringify({ id, method, args });\n    this.sock.send(data, 0, data.length, this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (this[method]) {\n      this[method].apply(this, args);\n    }\n  }\n\n  connect(worker) {\n    this.children.push(worker);\n    this.sock.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    process.on('SIGTERM', () => {\n      process.kill(process.pid, sig);\n    });\n    this.setupIPC();\n  }\n\n  masterKilled(data) {\n    this.sock.emit('restart', data);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', (msg, rinfo) => {\n        const data = JSON.parse(msg.toString());\n        if (data.type === 'worker connected') {\n          this.connect(data.worker);\n        } else if (data.type === 'master killed') {\n          this.masterKilled(data.data);\n        }\n      });\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this.sock = this.IPCSocket();\n    this.sock.bind(this.options.port, this.options.address, () => {\n      this.sock.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const message = JSON.stringify({ type: 'call', id, method, args });\n    this.sock.send(message, 0, message.length, this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (this[method]) {\n      this[method].apply(this, args);\n    }\n  }\n\n  connect(worker) {\n    this.children.push(worker);\n    this.sock.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    if (sig === 'immediate') {\n      process.kill(process.pid, 'SIGTERM');\n    } else {\n      this.setupIPC();\n    }\n  }\n\n  masterKilled(data) {\n    this.sock.emit('restart', data);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', (msg, rinfo) => {\n        const data = JSON.parse(msg.toString());\n        this.handleMessage(data, rinfo);\n      });\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this.sock = this.IPCSocket();\n    this.sock.bind(this.options.port, this.options.address, () => {\n      this.sock.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const message = JSON.stringify({ id, method, args });\n    this.sock.send(message, 0, message.length, this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (typeof worker[method] === 'function') {\n      worker[method](...args);\n    }\n  }\n\n  connect(worker) {\n    this.children.push(worker);\n    this.sock.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    if (this.sock) {\n      this.sock.once('listening', () => {\n        process.kill(process.pid, sig);\n      });\n    }\n  }\n\n  masterKilled(data) {\n    this.sock.emit('restart', data);\n  }\n\n  handleMessage(data, rinfo) {\n    const worker = this.children.find(child => child.id === data.id);\n    if (worker) {\n      this.invoke(data.method, data.args, worker);\n    }\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (!this._sock) {\n      this._sock = dgram.createSocket('udp4');\n      this._sock.on('message', (msg, rinfo) => {\n        const { id, method, args } = JSON.parse(msg.toString());\n        this.invoke(method, args, id);\n      });\n    }\n    return this._sock;\n  }\n\n  setupIPC() {\n    this.sock = this.IPCSocket();\n    this.sock.bind(this.options.port, this.options.address, () => {\n      this.sock.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const msg = JSON.stringify({ id, method, args });\n    this.sock.send(msg, 0, msg.length, this.options.port, this.options.address);\n  }\n\n  invoke(method, args, worker) {\n    if (typeof this.children[worker] === 'function') {\n      this.children[worker](method, args);\n    }\n  }\n\n  connect(worker) {\n    this.children.push(worker);\n    this.sock.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    if (this.sock) {\n      this.sock.once('listening', () => process.kill(process.pid, sig));\n    } else {\n      process.kill(process.pid, sig);\n    }\n  }\n\n  masterKilled(data) {\n    this.sock.emit('restart', data);\n  }\n}\n```",
      "```javascript\nconst dgram = require('dgram');\n\nclass MasterIPC {\n    constructor(options) {\n        this.options = options;\n        this._sock = null;\n        this.children = [];\n        this.sock = null;\n    }\n\n    IPCSocket() {\n        if (!this._sock) {\n            this._sock = dgram.createSocket('udp4');\n            this._sock.on('message', (msg, rinfo) => {\n                const data = JSON.parse(msg.toString());\n                if (data.type === 'worker connected') {\n                    this.connect(data.worker);\n                } else if (data.type === 'master killed') {\n                    this.masterKilled(data.data);\n                }\n            });\n        }\n        return this._sock;\n    }\n\n    setupIPC() {\n        this.sock = this.IPCSocket();\n        this.sock.bind(this.options.port, this.options.address, () => {\n            this.sock.emit('start');\n        });\n    }\n\n    call(id, method, ...args) {\n        const message = JSON.stringify({ type: 'call', id, method, args });\n        this.sock.send(message, 0, message.length, this.options.port, this.options.address);\n    }\n\n    invoke(method, args, worker) {\n        if (typeof worker[method] === 'function') {\n            worker[method](...args);\n        }\n    }\n\n    connect(worker) {\n        this.children.push(worker);\n        this.sock.emit('worker connected', worker);\n    }\n\n    connectMaster(sig) {\n        if (this.sock) {\n            this.sock.once('listening', () => {\n                process.kill(process.pid, sig);\n            });\n        }\n    }\n\n    masterKilled(data) {\n        this.sock.emit('restart', data);\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a reusable HTTP client class that simplifies making HTTP requests using Axios, with support for common methods like GET and POST, while handling errors consistently.\n\nClass Description: The HTTPClient class encapsulates Axios functionality to provide a clean interface for making HTTP requests. It maintains headers across requests and provides methods for GET and POST operations with error handling.\n\nAttributes:\n- headers: Object - Contains HTTP headers to be sent with every request\n\nMethods:\n- constructor(headers: Object) -> void - Initializes the HTTP client with default headers\n- get(url: String, params: Object = {}) -> Promise<Object> - Sends a GET request to the specified URL with optional query parameters, returns response data or throws error\n- post(url: String, data: Object = {}, params: Object = {}) -> Promise<Object> - Sends a POST request to the specified URL with optional request body and query parameters, returns response data or throws error",
    "Canonical_solution": "const axios = require('axios');\n\nclass HTTPClient {\n    constructor(headers) {\n        this.headers = headers;\n    }\n\n    async get(url, params = {}) {\n        try {\n            const response = await axios({\n                method: 'get',\n                url: url,\n                headers: this.headers,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('GET request failed:', error);\n            throw error;\n        }\n    }\n\n    async post(url, data = {}, params = {}) {\n        try {\n            const response = await axios({\n                method: 'post',\n                url: url,\n                headers: this.headers,\n                data: data,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('POST request failed:', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: this.headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.headers = headers;\n    this.instance = axios.create({\n      headers: headers\n    });\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await this.instance.get(url, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await this.instance.post(url, data, { params });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Create a function that sets up a UDP server using Node.js's dgram module to listen for incoming messages on a specified port and IP address.\n\nFunction Description: The function `setupUDPServer` initializes a UDP server socket, configures event handlers for errors and incoming messages, and binds the socket to a specified port and IP address. The server logs errors and received messages to the console.\n\nInput: None\n\nOutput: Returns the created UDP server socket object.",
    "Canonical_solution": "function setupUDPServer() {\n    const IP_ADDR = '127.0.0.1';\n    const UDP_PORT = 49161;\n    \n    const dgram = require('dgram');\n    const udpserver = dgram.createSocket('udp4');\n\n    udpserver.on('error', (err) => {\n        console.log(`UDP server:\\n${err.stack}`);\n        udpserver.close();\n    });\n\n    udpserver.on('message', (msg, rinfo) => {\n        console.log(`UDP server: ${msg} from ${rinfo.address}:${rinfo.port}`);\n    });\n\n    udpserver.bind(UDP_PORT);\n\n    return udpserver;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "matched_results": [
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => console.log('UDP Server listening on port %d', server.address().port));\nserver.bind({ port: 12345, address: '127.0.0.1' });\nserver",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind({ port: 12345, address: '127.0.0.1' });\nserver",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`UDP Server listening on ${address.address}:${address.port}`);\n});\nserver.bind({ port: 12345, address: '127.0.0.1' });\nserver",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind({ port: 12345, address: '127.0.0.1' });\nserver;",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => console.log('UDP Server listening on port %d', server.address().port));\nserver.bind({ port: 12345, address: '127.0.0.1' });\nserver;",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind({ port: 12345, address: '127.0.0.1' });\nserver;",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind({port: 12345, address: '127.0.0.1'});\nserver",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind({ port: 12345, address: '127.0.0.1' });\nserver;",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind({ port: 12345, address: '127.0.0.1' });\nserver;",
      "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('error', (err) => console.error(`server error: ${err.message}`));\nserver.on('message', (msg, rinfo) => console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`));\nserver.on('listening', () => {\n  const address = server.address();\n  console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind({port: 12345, address: '127.0.0.1'});\nserver"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome DevTools Protocol, handling connection, message exchange, and disconnection events.\n\nClass Description: The Chrome class is an EventEmitter that establishes and manages a WebSocket connection to Chrome's DevTools Protocol. It handles message parsing, error handling, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The WebSocket instance\n- _notifier: [EventEmitter] - External event notifier\n- _callbacks: [Object] - Stores pending command callbacks\n- _nextCommandId: [Number] - Tracks the next command ID\n\nMethods:\n- constructor(options, notifier) -> [void] - Initializes the Chrome instance with connection options and notifier\n- _start() -> [Promise] - Internal method to initiate WebSocket connection\n- _connectToWebSocket() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleConnectionClose() -> [void] - Cleans up when connection closes\n- _handleMessage(message) -> [void] - Processes incoming WebSocket messages\n- send(method, params, sessionId, callback) -> [Promise|void] - Sends a command to Chrome DevTools Protocol\n- _enqueueCommand(method, params, sessionId, callback) -> [void] - Internal method to queue commands\n- close(callback) -> [Promise|void] - Closes the WebSocket connection cleanly",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this.webSocketUrl = undefined;\n        this._ws = null;\n        this._notifier = notifier;\n        this._start();\n    }\n\n    async _start() {\n        try {\n            await this._connectToWebSocket();\n            process.nextTick(() => {\n                this._notifier.emit('connect', this);\n            });\n        } catch (err) {\n            this._notifier.emit('error', err);\n        }\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleConnectionClose() {\n        this._callbacks = {};\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n\n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    close(callback) {\n        const closeWebSocket = (callback) => {\n            if (this._ws.readyState === 3) {\n                callback();\n            } else {\n                this._ws.removeAllListeners('close');\n                this._ws.once('close', () => {\n                    this._ws.removeAllListeners();\n                    this._handleConnectionClose();\n                    callback();\n                });\n                this._ws.close();\n            }\n        };\n        if (typeof callback === 'function') {\n            closeWebSocket(callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                closeWebSocket(fulfill);\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return new Promise((resolve, reject) => {\n      this._connectToWebSocket()\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onmessage = (event) => {\n        this._handleMessage(event.data);\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n      };\n      this._ws.onclose = () => {\n        this._handleConnectionClose();\n      };\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('disconnect');\n    this._callbacks = {};\n  }\n\n  _handleMessage(message) {\n    const parsedMessage = JSON.parse(message);\n    if (parsedMessage.id) {\n      const callback = this._callbacks[parsedMessage.id];\n      if (callback) {\n        callback(parsedMessage.result, parsedMessage.error);\n        delete this._callbacks[parsedMessage.id];\n      }\n    } else {\n      this.emit(parsedMessage.method, parsedMessage.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    this._enqueueCommand(method, params, sessionId, callback, commandId);\n  }\n\n  _enqueueCommand(method, params, sessionId, callback, commandId) {\n    const command = {\n      id: commandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n    this._callbacks[commandId] = callback;\n  }\n\n  close(callback) {\n    return new Promise((resolve, reject) => {\n      this._ws.close();\n      this._ws.onclose = () => {\n        if (callback) {\n          callback();\n        }\n        resolve();\n      };\n    });\n  }\n}\n```",
      "```javascript\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return new Promise((resolve, reject) => {\n      this._connectToWebSocket()\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = () => {\n        this._handleConnectionClose();\n      };\n      this._ws.onmessage = (message) => {\n        this._handleMessage(message);\n      };\n    });\n  }\n\n  _handleConnectionClose() {\n    this._ws = null;\n    this.emit('disconnect');\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(data.result, data.error);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    if (callback) {\n      this._nextCommandId++;\n      this._callbacks[this._nextCommandId] = callback;\n    }\n    const message = JSON.stringify({\n      id: this._nextCommandId,\n      method,\n      params,\n      sessionId\n    });\n    this._ws.send(message);\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    this.send(method, params, sessionId, callback);\n  }\n\n  close(callback) {\n    if (this._ws) {\n      this._ws.close();\n      if (callback) {\n        this._ws.onclose = callback;\n      }\n    }\n  }\n}\n```",
      "```javascript\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this._generateWebSocketUrl();\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return this._connectToWebSocket();\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = this._handleConnectionClose;\n      this._ws.onmessage = this._handleMessage;\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('disconnect');\n    this._notifier.removeListener('message', this._onNotificationMessage);\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.method) {\n      this.emit(data.method, data.params, data.sessionId);\n    } else if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(data.result, data.error);\n        delete this._callbacks[data.id];\n      }\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    this._enqueueCommand(method, params, sessionId, callback);\n    return new Promise((resolve, reject) => {\n      this._callbacks[commandId] = (result, error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n    });\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const command = {\n      id: this._nextCommandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n  }\n\n  close(callback) {\n    return new Promise((resolve, reject) => {\n      this._ws.close();\n      this._ws.onclose = () => {\n        if (callback) {\n          callback();\n        }\n        resolve();\n      };\n    });\n  }\n\n  _generateWebSocketUrl() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.host}:${this.port}`;\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this._generateWebSocketUrl();\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return this._connectToWebSocket();\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = this._handleConnectionClose;\n      this._ws.onmessage = this._handleMessage;\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('disconnect');\n    this._cleanup();\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    if (callback) {\n      this._nextCommandId++;\n      this._callbacks[this._nextCommandId] = callback;\n    }\n    const command = {\n      id: this._nextCommandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    this.send(method, params, sessionId, callback);\n  }\n\n  close(callback) {\n    if (this._ws) {\n      this._ws.close();\n      if (callback) {\n        this._ws.onclose = callback;\n      }\n    }\n  }\n\n  _cleanup() {\n    this.removeAllListeners();\n    this._ws = null;\n    this._notifier = null;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _generateWebSocketUrl() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.host}:${this.port}`;\n  }\n}\n```",
      "```javascript\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this._generateWebSocketUrl();\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return this._connectToWebSocket();\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = this._handleConnectionClose;\n      this._ws.onmessage = this._handleMessage;\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('disconnect');\n    this._cleanup();\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    if (callback) {\n      this._nextCommandId++;\n      this._callbacks[this._nextCommandId] = callback;\n    }\n    const command = {\n      id: this._nextCommandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    this.send(method, params, sessionId, callback);\n  }\n\n  close(callback) {\n    if (this._ws) {\n      this._ws.close();\n      if (callback) {\n        this._ws.onclose = callback;\n      }\n    }\n  }\n\n  _cleanup() {\n    this.removeAllListeners();\n    this._ws = null;\n    this._notifier = null;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _generateWebSocketUrl() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.host}:${this.port}`;\n  }\n}\n```",
      "```javascript\nclass Chrome extends events.EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this._generateWebSocketUrl();\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return this._connectToWebSocket();\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = this._handleConnectionClose;\n      this._ws.onmessage = this._handleMessage;\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('disconnect');\n    this._cleanup();\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    if (callback) {\n      this._nextCommandId++;\n      this._callbacks[this._nextCommandId] = callback;\n    }\n    const command = {\n      id: this._nextCommandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    this.send(method, params, sessionId, callback);\n  }\n\n  close(callback) {\n    if (this._ws) {\n      this._ws.close();\n      if (callback) {\n        this._ws.onclose = callback;\n      }\n    }\n  }\n\n  _cleanup() {\n    this.removeAllListeners();\n    this._ws = null;\n    this._notifier = null;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _generateWebSocketUrl() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.host}:${this.port}`;\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return new Promise((resolve, reject) => {\n      this._connectToWebSocket()\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onclose = this._handleConnectionClose.bind(this);\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onmessage = this._handleMessage.bind(this);\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('disconnect');\n    this._callbacks = {};\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(data.result, data.error);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    if (callback) {\n      this._nextCommandId++;\n      this._callbacks[this._nextCommandId] = callback;\n    }\n    const message = JSON.stringify({\n      id: this._nextCommandId,\n      method,\n      params,\n      sessionId\n    });\n    this._ws.send(message);\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    this.send(method, params, sessionId, callback);\n  }\n\n  close(callback) {\n    if (this._ws) {\n      this._ws.close();\n      if (callback) {\n        this._ws.onclose = callback;\n      }\n    }\n  }\n}\n```",
      "```javascript\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return new Promise((resolve, reject) => {\n      this._connectToWebSocket()\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = () => {\n        this._handleConnectionClose();\n      };\n      this._ws.onmessage = (message) => {\n        this._handleMessage(message);\n      };\n    });\n  }\n\n  _handleConnectionClose() {\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.emit('disconnect');\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    if (callback) {\n      this._nextCommandId++;\n      this._callbacks[this._nextCommandId] = callback;\n    }\n    const command = {\n      id: this._nextCommandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    this.send(method, params, sessionId, callback);\n  }\n\n  close(callback) {\n    if (this._ws) {\n      this._ws.close();\n      if (callback) {\n        this._ws.onclose = callback;\n      }\n    }\n  }\n}\n```",
      "```javascript\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this._generateWebSocketUrl();\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return this._connectToWebSocket();\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = this._handleConnectionClose;\n      this._ws.onmessage = this._handleMessage;\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('disconnect');\n    this._cleanup();\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    this._enqueueCommand(method, params, sessionId, callback, commandId);\n  }\n\n  _enqueueCommand(method, params, sessionId, callback, commandId) {\n    const command = {\n      id: commandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n    this._callbacks[commandId] = callback;\n  }\n\n  close(callback) {\n    return new Promise((resolve, reject) => {\n      this._ws.onclose = () => {\n        if (callback) callback();\n        resolve();\n      };\n      this._ws.close();\n    });\n  }\n\n  _cleanup() {\n    this.removeAllListeners();\n    this._ws = null;\n    this._notifier = null;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _generateWebSocketUrl() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.host}:${this.port}`;\n  }\n}\n```",
      "```javascript\nclass Chrome extends events.EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this._buildWebSocketUrl();\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n  }\n\n  _start() {\n    return this._connectToWebSocket();\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connect');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onclose = () => {\n        this._handleConnectionClose();\n      };\n      this._ws.onmessage = (message) => {\n        this._handleMessage(message.data);\n      };\n    });\n  }\n\n  _handleConnectionClose() {\n    this.emit('disconnect');\n    this._callbacks = {};\n  }\n\n  _handleMessage(message) {\n    const parsedMessage = JSON.parse(message);\n    if (parsedMessage.id) {\n      const callback = this._callbacks[parsedMessage.id];\n      if (callback) {\n        callback(parsedMessage.result, parsedMessage.error);\n        delete this._callbacks[parsedMessage.id];\n      }\n    } else {\n      this.emit(parsedMessage.method, parsedMessage.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    this._enqueueCommand(method, params, sessionId, callback, commandId);\n  }\n\n  _enqueueCommand(method, params, sessionId, callback, commandId) {\n    const command = {\n      id: commandId,\n      method,\n      params,\n      sessionId\n    };\n    this._callbacks[commandId] = callback;\n    this._ws.send(JSON.stringify(command));\n  }\n\n  close(callback) {\n    return new Promise((resolve) => {\n      this._ws.onclose = () => {\n        if (callback) callback();\n        resolve();\n      };\n      this._ws.close();\n    });\n  }\n\n  _buildWebSocketUrl() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.host}:${this.port}`;\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Create a WebSocket client class in Node.js that manages connections, sends commands, and handles responses asynchronously.\n\nClass Description: The CustomEnvironment class provides a WebSocket client implementation that establishes and manages a connection to a WebSocket server. It handles command execution with unique IDs, callback management for responses, and connection lifecycle.\n\nAttributes:\n- callbacks: [Map] - Stores pending callbacks mapped by unique IDs for command responses\n- idSeq: [Number] - Sequence counter for generating unique command IDs\n- ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- initWs(): [Promise<void>] - Initializes WebSocket connection and sets up message handler. Resolves when connection is open.\n- runCommand(type: [String], data: [Any]): [Promise<Any>] - Sends a command to the server and returns a promise that resolves with response data or rejects with error\n- teardown(): [void] - Closes the WebSocket connection if it exists\n\nThe implementation should:\n1. Use the 'ws' library for WebSocket functionality\n2. Maintain connection state and automatically reconnect if needed\n3. Handle message parsing and callback execution\n4. Manage command IDs and response correlation\n5. Provide proper error handling for connection and command execution",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 1;\n  }\n\n  async initWs() {\n    this.ws = new WebSocket(\"ws://127.0.0.1:8080\");\n\n    await new Promise((resolve) => this.ws.on(\"open\", resolve));\n\n    this.ws.on(\"message\", (message) => {\n      const { id, data, error } = JSON.parse(message);\n      const cb = this.callbacks.get(id);\n      if (cb) {\n        this.callbacks.delete(id);\n        cb(error, data);\n      }\n    });\n  }\n\n  async runCommand(type, data) {\n    if (!this.ws) {\n      await this.initWs();\n    }\n\n    return new Promise((resolve, reject) => {\n      const id = String(this.idSeq++);\n\n      this.callbacks.set(id, (error, data) => {\n        if (error) {\n          reject(new Error(error));\n        } else {\n          resolve(data);\n        }\n      });\n\n      this.ws.send(JSON.stringify({ id, type, data }));\n    });\n  }\n\n  async teardown() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs() {\n    this.ws = new WebSocket('ws://example.com');\n    this.ws.on('open', () => {\n      console.log('WebSocket connection established');\n    });\n    this.ws.on('message', this.handleMessage.bind(this));\n    this.ws.on('close', () => {\n      console.log('WebSocket connection closed');\n      this.reconnect();\n    });\n    this.ws.on('error', (error) => {\n      console.error('WebSocket error:', error);\n      this.ws.terminate();\n    });\n  }\n\n  handleMessage(message) {\n    const { id, data } = JSON.parse(message);\n    if (this.callbacks.has(id)) {\n      this.callbacks.get(id)(data);\n      this.callbacks.delete(id);\n    }\n  }\n\n  runCommand(type, data) {\n    return new Promise((resolve, reject) => {\n      const id = ++this.idSeq;\n      this.callbacks.set(id, (response) => {\n        resolve(response);\n      });\n      const command = { id, type, data };\n      this.ws.send(JSON.stringify(command));\n    });\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n        this.initWs();\n      }\n    }, 5000);\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs() {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket('ws://example.com');\n\n      this.ws.on('open', () => {\n        resolve();\n      });\n\n      this.ws.on('message', this.handleMessage.bind(this));\n\n      this.ws.on('close', () => {\n        this.ws = null;\n      });\n\n      this.ws.on('error', reject);\n    });\n  }\n\n  handleMessage(data) {\n    const { id, response } = JSON.parse(data);\n    const callback = this.callbacks.get(id);\n    if (callback) {\n      this.callbacks.delete(id);\n      callback(response);\n    }\n  }\n\n  async runCommand(type, data) {\n    const id = ++this.idSeq;\n    return new Promise((resolve, reject) => {\n      const callback = (response) => {\n        if (response.error) {\n          reject(response.error);\n        } else {\n          resolve(response.data);\n        }\n      };\n      this.callbacks.set(id, callback);\n\n      const command = JSON.stringify({ id, type, data });\n      if (this.ws) {\n        this.ws.send(command);\n      } else {\n        reject(new Error('WebSocket connection is not established'));\n      }\n    });\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs(url) {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket(url, { perMessageDeflate: false });\n\n      this.ws.on('open', () => {\n        resolve();\n      });\n\n      this.ws.on('message', this.handleMessage.bind(this));\n\n      this.ws.on('close', () => {\n        this.ws = null;\n      });\n\n      this.ws.on('error', reject);\n    });\n  }\n\n  handleMessage(data) {\n    const { id, response } = JSON.parse(data.toString());\n    const callback = this.callbacks.get(id);\n    if (callback) {\n      this.callbacks.delete(id);\n      callback(response);\n    }\n  }\n\n  async runCommand(type, data) {\n    const id = ++this.idSeq;\n    return new Promise((resolve, reject) => {\n      const callback = (response) => {\n        if (response.error) {\n          reject(response.error);\n        } else {\n          resolve(response.data);\n        }\n      };\n      this.callbacks.set(id, callback);\n\n      const command = { id, type, data };\n      this.ws.send(JSON.stringify(command), (error) => {\n        if (error) {\n          this.callbacks.delete(id);\n          reject(error);\n        }\n      });\n    });\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs() {\n    this.ws = new WebSocket('ws://example.com');\n    this.ws.on('open', () => {\n      console.log('WebSocket connection established');\n    });\n    this.ws.on('message', this.handleMessage.bind(this));\n    this.ws.on('close', () => {\n      console.log('WebSocket connection closed');\n      this.reconnect();\n    });\n    this.ws.on('error', (error) => {\n      console.error('WebSocket error:', error);\n      this.ws.terminate();\n    });\n  }\n\n  handleMessage(data) {\n    const message = JSON.parse(data);\n    const callback = this.callbacks.get(message.id);\n    if (callback) {\n      callback(message.data);\n      this.callbacks.delete(message.id);\n    }\n  }\n\n  runCommand(type, data) {\n    return new Promise((resolve, reject) => {\n      const id = ++this.idSeq;\n      this.callbacks.set(id, (data) => resolve(data));\n      this.ws.send(JSON.stringify({ id, type, data }));\n    });\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n        this.initWs();\n      }\n    }, 5000);\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs(url) {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket(url, { perMessageDeflate: false });\n\n      this.ws.on('open', () => {\n        resolve();\n      });\n\n      this.ws.on('message', this.handleMessage.bind(this));\n\n      this.ws.on('close', (code, reason) => {\n        if (code !== 1000) {\n          console.error(`WebSocket connection closed with code ${code}: ${reason}`);\n          this.reconnect();\n        }\n      });\n\n      this.ws.on('error', (error) => {\n        console.error('WebSocket error:', error);\n        this.ws.terminate();\n      });\n    });\n  }\n\n  handleMessage(data) {\n    try {\n      const message = JSON.parse(data);\n      const callback = this.callbacks.get(message.id);\n      if (callback) {\n        this.callbacks.delete(message.id);\n        callback(message.data);\n      }\n    } catch (error) {\n      console.error('Error parsing message:', error);\n    }\n  }\n\n  runCommand(type, data) {\n    return new Promise((resolve, reject) => {\n      const id = ++this.idSeq;\n      const message = JSON.stringify({ id, type, data });\n      this.ws.send(message, (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          this.callbacks.set(id, (data) => resolve(data));\n        }\n      });\n    });\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (this.ws) {\n        this.ws.terminate();\n      }\n      this.initWs(this.ws.url);\n    }, 5000);\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs() {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket('ws://example.com');\n\n      this.ws.on('open', () => {\n        resolve();\n      });\n\n      this.ws.on('message', this.handleMessage.bind(this));\n\n      this.ws.on('close', () => {\n        this.ws = null;\n      });\n\n      this.ws.on('error', reject);\n    });\n  }\n\n  handleMessage(data) {\n    const { id, response } = JSON.parse(data);\n    const callback = this.callbacks.get(id);\n    if (callback) {\n      this.callbacks.delete(id);\n      callback(response);\n    }\n  }\n\n  async runCommand(type, data) {\n    const id = ++this.idSeq;\n    return new Promise((resolve, reject) => {\n      this.callbacks.set(id, (response) => {\n        if (response.error) {\n          reject(response.error);\n        } else {\n          resolve(response.data);\n        }\n      });\n\n      const command = { id, type, data };\n      this.ws.send(JSON.stringify(command));\n    });\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs() {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket('ws://example.com');\n\n      this.ws.on('open', () => {\n        resolve();\n      });\n\n      this.ws.on('message', this.handleMessage.bind(this));\n\n      this.ws.on('close', () => {\n        this.ws = null;\n      });\n\n      this.ws.on('error', reject);\n    });\n  }\n\n  handleMessage(data) {\n    const { id, response } = JSON.parse(data);\n    const callback = this.callbacks.get(id);\n    if (callback) {\n      this.callbacks.delete(id);\n      callback(response);\n    }\n  }\n\n  async runCommand(type, data) {\n    const id = ++this.idSeq;\n    return new Promise((resolve, reject) => {\n      const callback = (response) => {\n        if (response.error) {\n          reject(response.error);\n        } else {\n          resolve(response.data);\n        }\n      };\n      this.callbacks.set(id, callback);\n\n      const command = JSON.stringify({ id, type, data });\n      if (this.ws) {\n        this.ws.send(command);\n      } else {\n        reject(new Error('WebSocket connection not established'));\n      }\n    });\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs() {\n    this.ws = new WebSocket('ws://example.com');\n    this.ws.on('open', () => {\n      console.log('WebSocket connection established');\n    });\n    this.ws.on('message', this.handleMessage.bind(this));\n    this.ws.on('close', () => {\n      console.log('WebSocket connection closed');\n      this.reconnect();\n    });\n    this.ws.on('error', (error) => {\n      console.error('WebSocket error:', error);\n      this.ws.terminate();\n    });\n  }\n\n  handleMessage(message) {\n    const { id, data } = JSON.parse(message);\n    if (this.callbacks.has(id)) {\n      this.callbacks.get(id)(data);\n      this.callbacks.delete(id);\n    }\n  }\n\n  runCommand(type, data) {\n    return new Promise((resolve, reject) => {\n      const id = ++this.idSeq;\n      this.callbacks.set(id, (response) => {\n        resolve(response);\n      });\n      const command = { id, type, data };\n      this.ws.send(JSON.stringify(command));\n    });\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n        this.initWs();\n      }\n    }, 5000);\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs(url) {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket(url, { perMessageDeflate: false });\n\n      this.ws.on('open', () => {\n        resolve();\n      });\n\n      this.ws.on('message', this.handleMessage.bind(this));\n\n      this.ws.on('close', () => {\n        this.ws = null;\n      });\n\n      this.ws.on('error', reject);\n    });\n  }\n\n  handleMessage(data) {\n    const { id, response } = JSON.parse(data.toString());\n    const callback = this.callbacks.get(id);\n    if (callback) {\n      this.callbacks.delete(id);\n      callback(response);\n    }\n  }\n\n  async runCommand(type, data) {\n    const id = ++this.idSeq;\n    return new Promise((resolve, reject) => {\n      this.callbacks.set(id, (response) => {\n        if (response.error) {\n          reject(response.error);\n        } else {\n          resolve(response.data);\n        }\n      });\n\n      const command = { id, type, data };\n      this.ws.send(JSON.stringify(command));\n    });\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomEnvironment {\n  constructor() {\n    this.callbacks = new Map();\n    this.idSeq = 0;\n    this.ws = null;\n  }\n\n  async initWs(url) {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket(url, { perMessageDeflate: false });\n\n      this.ws.on('open', () => {\n        resolve();\n      });\n\n      this.ws.on('message', this.handleMessage.bind(this));\n\n      this.ws.on('close', (code, reason) => {\n        if (code !== 1000) {\n          reject(new Error(`WebSocket connection closed with code ${code}: ${reason}`));\n        }\n      });\n\n      this.ws.on('error', reject);\n    });\n  }\n\n  handleMessage(data) {\n    try {\n      const { id, response } = JSON.parse(data);\n      const callback = this.callbacks.get(id);\n      if (callback) {\n        this.callbacks.delete(id);\n        callback(null, response);\n      }\n    } catch (error) {\n      console.error('Error parsing message:', error);\n    }\n  }\n\n  async runCommand(type, data) {\n    const id = ++this.idSeq;\n    return new Promise((resolve, reject) => {\n      const callback = (error, response) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(response);\n        }\n      };\n      this.callbacks.set(id, callback);\n\n      const command = JSON.stringify({ id, type, data });\n      if (this.ws.readyState === WebSocket.OPEN) {\n        this.ws.send(command);\n      } else {\n        reject(new Error('WebSocket connection is not open'));\n      }\n    });\n  }\n\n  teardown() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a WebSocket client class in Node.js that connects to a speech synthesis service, sends SSML requests, and handles the audio response streams.\n\nClass Description: WebSocketClient is a class that manages WebSocket connections to Microsoft's Bing Speech API for text-to-speech synthesis. It handles connection lifecycle, request/response mapping, and binary audio data streaming.\n\nAttributes:\n- ws: [WebSocket|null] - Active WebSocket connection instance\n- executorMap: [Map] - Stores promise resolvers/rejectors mapped by request IDs\n- bufferMap: [Map] - Accumulates binary audio data chunks mapped by request IDs\n- timer: [Timeout|null] - Connection timeout handler\n\nMethods:\n- connect() -> [Promise<WebSocket>] - Establishes WebSocket connection with proper headers and returns a promise that resolves when connected\n- sendRequest(ssml: [String], format: [String]) -> [Promise<Buffer>] - Sends SSML request with specified audio format and returns promise resolving to audio buffer\n\nInput:\n- For connect(): None\n- For sendRequest():\n  - ssml: [String] - SSML markup for speech synthesis\n  - format: [String] - Desired audio output format (e.g., \"audio-24khz-48kbitrate-mono-mp3\")\n\nOutput:\n- For connect(): Resolves with WebSocket instance or rejects with error\n- For sendRequest(): Resolves with audio buffer or rejects with error",
    "Canonical_solution": "const { WebSocket } = require(\"ws\");\nconst { randomBytes } = require(\"crypto\");\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  async connect() {\n    const connectionId = randomBytes(16).toString(\"hex\").toLowerCase();\n    let url = `wss://speech.platform.bing.com/consumer/speech/synthesize/readaloud/edge/v1?TrustedClientToken=6A5AA1D4EAFF4E9FB37E23D68491D6F4&ConnectionId=${connectionId}`;\n    let ws = new WebSocket(url, {\n      host: \"speech.platform.bing.com\",\n      origin: \"chrome-extension://jdiccldimpdaibmpdkjnbmckianbfold\",\n      headers: {\n        \"User-Agent\":\n          \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.66 Safari/537.36 Edg/103.0.1264.44\",\n      },\n    });\n    \n    return new Promise((resolve, reject) => {\n      ws.on(\"open\", () => {\n        resolve(ws);\n      });\n      \n      ws.on(\"close\", (code, reason) => {\n        this.ws = null;\n        if (this.timer) {\n          clearTimeout(this.timer);\n          this.timer = null;\n        }\n        for (let [key, value] of this.executorMap) {\n          value.reject(`è¿žæŽ¥å·²å…³é—­: ${reason} ${code}`);\n        }\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on(\"message\", (message, isBinary) => {\n        let pattern = /X-RequestId:(?<id>[a-z|0-9]*)/;\n        if (!isBinary) {\n          let data = message.toString();\n          if (data.includes(\"Path:turn.start\")) {\n            let matches = data.match(pattern);\n            let requestId = matches.groups.id;\n            this.bufferMap.set(requestId, Buffer.from([]));\n          } else if (data.includes(\"Path:turn.end\")) {\n            let matches = data.match(pattern);\n            let requestId = matches.groups.id;\n            let executor = this.executorMap.get(requestId);\n            if (executor) {\n              this.executorMap.delete(matches.groups.id);\n              let result = this.bufferMap.get(requestId);\n              executor.resolve(result);\n            }\n          }\n        } else if (isBinary) {\n          let separator = \"Path:audio\\r\\n\";\n          let data = message;\n          let contentIndex = data.indexOf(separator) + separator.length;\n          let headers = data.slice(2, contentIndex).toString();\n          let matches = headers.match(pattern);\n          let requestId = matches.groups.id;\n          let content = data.slice(contentIndex);\n          let buffer = this.bufferMap.get(requestId);\n          if (buffer) {\n            buffer = Buffer.concat([buffer, content], buffer.length+content.length);\n            this.bufferMap.set(requestId, buffer);\n          }\n        }\n      });\n      \n      ws.on(\"error\", (error) => {\n        reject(`è¿žæŽ¥å¤±è´¥ï¼š ${error}`);\n      });\n    });\n  }\n\n  async sendRequest(ssml, format) {\n    if (this.ws == null || this.ws.readyState != WebSocket.OPEN) {\n      let connection = await this.connect();\n      this.ws = connection;\n    }\n    \n    const requestId = randomBytes(16).toString(\"hex\").toLowerCase();\n    let result = new Promise((resolve, reject) => {\n      this.executorMap.set(requestId, { resolve, reject });\n      \n      let configData = {\n        context: {\n          synthesis: {\n            audio: {\n              metadataoptions: {\n                sentenceBoundaryEnabled: \"false\",\n                wordBoundaryEnabled: \"false\",\n              },\n              outputFormat: format,\n            },\n          },\n        },\n      };\n      \n      let configMessage =\n        `X-Timestamp:${Date()}\\r\\n` +\n        \"Content-Type:application/json; charset=utf-8\\r\\n\" +\n        \"Path:speech.config\\r\\n\\r\\n\" +\n        JSON.stringify(configData);\n        \n      this.ws.send(configMessage, (configError) => {\n        if (configError) return;\n        \n        let ssmlMessage =\n          `X-Timestamp:${Date()}\\r\\n` +\n          `X-RequestId:${requestId}\\r\\n` +\n          `Content-Type:application/ssml+xml\\r\\n` +\n          `Path:ssml\\r\\n\\r\\n` +\n          ssml;\n        this.ws.send(ssmlMessage);\n      });\n    });\n\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    \n    this.timer = setTimeout(() => {\n      if (this.ws && this.ws.readyState == WebSocket.OPEN) {\n        this.ws.close(1000);\n        this.timer = null;\n      }\n    }, 10000);\n\n    return await Promise.race([\n      result,\n      new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.executorMap.delete(requestId);\n          this.bufferMap.delete(requestId);\n          reject(\"è¯·æ±‚è¶…æ—¶\");\n        }, 10000);\n      }),\n    ]);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'X-Microsoft-OutputFormat': 'audio-24khz-48kbitrate-mono-mp3'\n        }\n      });\n\n      this.ws = ws;\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        this.bufferMap.get(requestId).push(audio);\n      });\n\n      ws.on('close', () => {\n        this.executorMap.forEach((executor, requestId) => {\n          executor(new Error('WebSocket connection closed'));\n        });\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n\n      this.timer = setTimeout(() => {\n        ws.terminate();\n        reject(new Error('WebSocket connection timeout'));\n      }, 30000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Date.now().toString();\n      const executor = (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(this.bufferMap.get(requestId).concat());\n        }\n      };\n      this.executorMap.set(requestId, executor);\n\n      if (this.ws) {\n        this.ws.send(JSON.stringify({ requestId, ssml }));\n      } else {\n        reject(new Error('WebSocket connection not established'));\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n        }\n      });\n\n      this.ws = ws;\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        if (audio) {\n          this.bufferMap.get(requestId).push(audio);\n        }\n      });\n\n      ws.on('close', () => {\n        this.executorMap.forEach((executor, requestId) => {\n          executor(new Error('WebSocket connection closed'));\n        });\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n\n      this.timer = setTimeout(() => {\n        ws.terminate();\n        reject(new Error('WebSocket connection timeout'));\n      }, 30000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Math.random().toString(36).substring(2, 15);\n      const executor = (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          const audioBuffer = Buffer.concat(this.bufferMap.get(requestId));\n          resolve(audioBuffer);\n        }\n      };\n      this.executorMap.set(requestId, executor);\n      this.bufferMap.set(requestId, []);\n\n      const ws = this.ws;\n      if (!ws) {\n        reject(new Error('WebSocket connection not established'));\n      } else {\n        ws.send(JSON.stringify({ requestId, ssml, format }));\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst { WebSocket } = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'X-Microsoft-OutputFormat': 'audio-24khz-48kbitrate-mono-mp3'\n        }\n      });\n\n      this.ws = ws;\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        if (audio) {\n          const buffer = this.bufferMap.get(requestId);\n          if (buffer) {\n            buffer.push(audio);\n          } else {\n            this.bufferMap.set(requestId, [audio]);\n          }\n        }\n      });\n\n      ws.on('close', () => {\n        this.ws = null;\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n\n      this.timer = setTimeout(() => {\n        ws.terminate();\n        reject(new Error('Connection timeout'));\n      }, 30000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Math.random().toString(36).substring(2, 15);\n      const executor = (error, buffer) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(buffer);\n        }\n      };\n\n      this.executorMap.set(requestId, executor);\n\n      const ws = this.ws;\n      if (!ws) {\n        reject(new Error('WebSocket connection not established'));\n        return;\n      }\n\n      const message = JSON.stringify({ requestId, ssml });\n      ws.send(message);\n\n      const buffer = [];\n      const onMessage = (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        if (audio) {\n          buffer.push(audio);\n          if (this.bufferMap.get(requestId).length === buffer.length) {\n            ws.removeEventListener('message', onMessage);\n            const finalBuffer = Buffer.concat(buffer);\n            this.executorMap.delete(requestId);\n            this.bufferMap.delete(requestId);\n            executor(null, finalBuffer);\n          }\n        }\n      };\n\n      ws.addEventListener('message', onMessage);\n    });\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n        }\n      });\n\n      this.ws = ws;\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        if (audio) {\n          this.bufferMap.get(requestId).push(audio);\n        }\n      });\n\n      ws.on('close', () => {\n        this.executorMap.forEach((executor, requestId) => {\n          executor(new Error('WebSocket connection closed'));\n        });\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n\n      this.timer = setTimeout(() => {\n        ws.terminate();\n        reject(new Error('WebSocket connection timeout'));\n      }, 30000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Math.random().toString(36).substring(2, 15);\n      const executor = (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          const audioBuffer = Buffer.concat(this.bufferMap.get(requestId));\n          resolve(audioBuffer);\n        }\n      };\n\n      this.executorMap.set(requestId, executor);\n      this.bufferMap.set(requestId, []);\n\n      const ws = this.ws;\n      if (!ws) {\n        reject(new Error('WebSocket connection not established'));\n      } else {\n        ws.send(JSON.stringify({ requestId, ssml, format }));\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'X-Microsoft-OutputFormat': 'audio-24khz-48kbitrate-mono-mp3'\n        }\n      });\n\n      this.ws = ws;\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const requestId = data.toString().split(':')[1];\n        this.bufferMap.set(requestId, this.bufferMap.get(requestId) ? Buffer.concat([this.bufferMap.get(requestId), data]) : data);\n      });\n\n      ws.on('close', () => {\n        this.executorMap.forEach((executor, requestId) => {\n          executor(new Error('WebSocket connection closed'));\n        });\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n\n      this.timer = setTimeout(() => {\n        ws.terminate();\n        reject(new Error('WebSocket connection timeout'));\n      }, 30000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Math.random().toString(36).substring(2, 15);\n      const executor = (error, buffer) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(buffer);\n        }\n      };\n      this.executorMap.set(requestId, executor);\n\n      if (this.ws) {\n        this.ws.send(`${requestId}:${ssml}`);\n      } else {\n        reject(new Error('WebSocket connection not established'));\n      }\n    });\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'X-Microsoft-OutputFormat': 'audio-24khz-48kbitrate-mono-mp3'\n        }\n      });\n\n      this.ws = ws;\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        this.bufferMap.get(requestId).push(audio);\n      });\n\n      ws.on('close', () => {\n        this.executorMap.forEach((executor, requestId) => {\n          executor.reject(new Error('WebSocket connection closed'));\n        });\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n\n      this.timer = setTimeout(() => {\n        ws.terminate();\n        reject(new Error('WebSocket connection timeout'));\n      }, 30000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Math.random().toString(36).substring(2, 15);\n      const executor = { resolve, reject };\n      this.executorMap.set(requestId, executor);\n\n      if (!this.ws) {\n        return this.connect().then(() => this.sendRequest(ssml, format));\n      }\n\n      const payload = JSON.stringify({ requestId, ssml });\n      this.ws.send(payload);\n\n      const buffer = [];\n      this.bufferMap.set(requestId, buffer);\n\n      this.ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        if (requestId === payload.requestId) {\n          buffer.push(audio);\n          if (audio.length === 0) {\n            const audioBuffer = Buffer.concat(buffer);\n            this.executorMap.delete(requestId);\n            this.bufferMap.delete(requestId);\n            resolve(audioBuffer);\n          }\n        }\n      });\n\n      this.ws.on('close', () => {\n        this.executorMap.delete(requestId);\n        this.bufferMap.delete(requestId);\n        reject(new Error('WebSocket connection closed'));\n      });\n\n      this.ws.on('error', (error) => {\n        this.executorMap.delete(requestId);\n        this.bufferMap.delete(requestId);\n        reject(error);\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      this.timer = setTimeout(() => {\n        reject(new Error('Connection timeout'));\n      }, 10000);\n\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'X-Microsoft-OutputFormat': 'audio-24khz-48kbitrate-mono-mp3'\n        }\n      });\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        this.ws = ws;\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        this.bufferMap.get(requestId).push(audio);\n      });\n\n      ws.on('close', () => {\n        this.ws = null;\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Date.now().toString();\n      const executor = (audio) => {\n        const buffer = Buffer.concat(this.bufferMap.get(requestId));\n        this.bufferMap.delete(requestId);\n        resolve(buffer);\n      };\n      this.executorMap.set(requestId, executor);\n\n      this.bufferMap.set(requestId, []);\n\n      if (!this.ws) {\n        return reject(new Error('WebSocket connection not established'));\n      }\n\n      this.ws.send(JSON.stringify({ requestId, ssml }));\n    });\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n        }\n      });\n\n      this.ws = ws;\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        if (audio) {\n          this.bufferMap.set(requestId, Buffer.concat([this.bufferMap.get(requestId), audio]));\n        } else {\n          const buffer = this.bufferMap.get(requestId);\n          this.executorMap.get(requestId)(buffer);\n          this.executorMap.delete(requestId);\n          this.bufferMap.delete(requestId);\n        }\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n\n      ws.on('close', () => {\n        this.ws = null;\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      this.timer = setTimeout(() => {\n        ws.terminate();\n        reject(new Error('Connection timed out'));\n      }, 30000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Date.now().toString();\n      this.executorMap.set(requestId, resolve);\n      this.bufferMap.set(requestId, Buffer.alloc(0));\n\n      if (!this.ws) {\n        return this.connect().then(() => this.sendRequest(ssml, format));\n      }\n\n      const message = JSON.stringify({ requestId, ssml, format });\n      this.ws.send(message);\n    });\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket('wss://speech.speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n        }\n      });\n\n      this.ws = ws;\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('message', (data) => {\n        const { requestId, audio } = JSON.parse(data);\n        if (audio) {\n          this.bufferMap.set(requestId, this.bufferMap.get(requestId) ? Buffer.concat([this.bufferMap.get(requestId), audio]) : audio);\n        }\n      });\n\n      ws.on('close', () => {\n        this.executorMap.forEach((executor) => executor(new Error('WebSocket closed')));\n        this.executorMap.clear();\n        this.bufferMap.clear();\n        this.ws = null;\n      });\n\n      ws.on('error', (error) => {\n        reject(error);\n      });\n\n      this.timer = setTimeout(() => {\n        ws.terminate();\n        reject(new Error('Connection timed out'));\n      }, 30000);\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Math.random().toString(36).substring(2, 15);\n      this.executorMap.set(requestId, resolve);\n      this.bufferMap.set(requestId, Buffer.alloc(0));\n\n      this.ws.send(JSON.stringify({ requestId, ssml, format }));\n    });\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      this.timer = setTimeout(() => {\n        reject(new Error('Connection timeout'));\n      }, 5000);\n\n      const ws = new WebSocket('wss://speech.microsoft.com/speechservices/v1.0/synthesis', {\n        headers: {\n          'Content-Type': 'application/ssml+xml',\n          'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n        }\n      });\n\n      ws.on('open', () => {\n        clearTimeout(this.timer);\n        resolve(ws);\n      });\n\n      ws.on('error', (error) => {\n        clearTimeout(this.timer);\n        reject(error);\n      });\n\n      ws.on('close', () => {\n        clearTimeout(this.timer);\n        this.ws = null;\n      });\n\n      ws.on('message', (data) => {\n        const requestId = data.toString().split(':')[0];\n        const buffer = this.bufferMap.get(requestId);\n        if (buffer) {\n          buffer.push(data);\n          this.bufferMap.set(requestId, buffer);\n        } else {\n          this.bufferMap.set(requestId, [data]);\n          this.executorMap.get(requestId)(data);\n          this.executorMap.delete(requestId);\n        }\n      });\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      this.connect().then((ws) => {\n        const requestId = Math.random().toString(36).substring(2, 15);\n        this.executorMap.set(requestId, resolve);\n        this.bufferMap.set(requestId, []);\n\n        ws.send(`${requestId}:<speak>${ssml}</speak>`);\n      }).catch(reject);\n    }).then((buffer) => {\n      const chunks = this.bufferMap.get(buffer[0].toString().split(':')[0]);\n      return Buffer.concat(chunks);\n    });\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [],
    "unmatched_results": [
      "```typescript\nimport { EventEmitter } from 'events';\n\nenum STATES {\n  CONNECTING,\n  OPEN,\n  CLOSING,\n  CLOSED\n}\n\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = STATES.CONNECTING;\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {};\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book = {};\n    this.queue = [];\n  }\n\n  connect(): void {\n    if (this.state !== STATES.OPEN) {\n      this.socket = new WebSocket(this.websocketURI);\n      this.socket.onopen = this.onOpen.bind(this);\n      this.socket.onclose = this.onClose.bind(this);\n      this.socket.onmessage = this.onMessage.bind(this);\n      this.socket.onerror = (error) => {\n        this.emit('error', error);\n      };\n    }\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string): void {\n    this.state = stateName;\n    this.emit('statechange', this.state);\n  }\n\n  onOpen(): void {\n    this.changeState(STATES.OPEN);\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState(STATES.CLOSED);\n    this.fail_count++;\n    if (this.fail_count < 3) {\n      this.connect();\n    }\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === STATES.OPEN) {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    this.socket.send(`subscribe ${this.productID}`);\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(data => {\n        this.book = data;\n        this.emit('snapshot', this.book);\n      })\n      .catch(error => {\n        this.emit('error', error);\n      });\n  }\n\n  processMessage(message: any, t: Date): void {\n    // Validate and process message\n    // Emit appropriate events\n  }\n}\n```",
      "```typescript\nimport { EventEmitter } from 'events';\n\nenum STATES {\n  CONNECTING,\n  OPEN,\n  CLOSING,\n  CLOSED\n}\n\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = STATES.CONNECTING;\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {};\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book = {};\n    this.queue = [];\n  }\n\n  connect(): void {\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string): void {\n    this.state = stateName;\n    this.emit('statechange', stateName);\n  }\n\n  onOpen(): void {\n    this.changeState(STATES.OPEN);\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState(STATES.CLOSED);\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === STATES.OPEN) {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    // Send subscription message\n    // Fetch initial snapshot from REST API\n  }\n\n  processMessage(message: any, t: Date): void {\n    // Validate and process order book updates\n    // Emit message-type events\n  }\n}\n```",
      "```typescript\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = 'DISCONNECTED';\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {};\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book = {};\n    this.queue = [];\n  }\n\n  connect(): void {\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string): void {\n    this.state = stateName;\n    this.emit('statechange', stateName);\n  }\n\n  onOpen(): void {\n    this.changeState('CONNECTED');\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState('DISCONNECTED');\n    this.fail_count++;\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === 'SYNCHRONIZING') {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    this.changeState('SYNCHRONIZING');\n    // Fetch initial snapshot from REST API\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(data => {\n        this.book = data;\n        this.queue.forEach(message => {\n          this.processMessage(JSON.parse(message), new Date());\n        });\n        this.queue = [];\n        this.changeState('SYNCHRONIZED');\n      })\n      .catch(error => {\n        this.changeState('ERROR');\n        this.emit('error', error);\n      });\n  }\n\n  processMessage(message: object, t: Date): void {\n    // Validate and process message\n    // Emit appropriate events\n  }\n}\n```",
      "```typescript\nimport { EventEmitter } from 'events';\n\nenum STATES {\n  DISCONNECTED,\n  CONNECTING,\n  CONNECTED,\n  SYNCHRONIZING,\n  SYNCHRONIZED,\n  ERROR\n}\n\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: { sequence: number, bids: Array<any>, asks: Array<any> };\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = STATES.DISCONNECTED;\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = { sequence: 0, bids: [], asks: [] };\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book.sequence = 0;\n    this.book.bids = [];\n    this.book.asks = [];\n    this.queue = [];\n  }\n\n  connect(): void {\n    if (this.state !== STATES.CONNECTED) {\n      this.changeState(STATES.CONNECTING);\n      this.socket = new WebSocket(this.websocketURI);\n      this.socket.onopen = this.onOpen.bind(this);\n      this.socket.onclose = this.onClose.bind(this);\n      this.socket.onmessage = this.onMessage.bind(this);\n      this.socket.onerror = (error) => {\n        this.emit('error', error);\n        this.changeState(STATES.ERROR);\n      };\n    }\n  }\n\n  disconnect(): void {\n    if (this.state === STATES.CONNECTED) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string): void {\n    this.state = stateName;\n    this.emit('statechange', stateName);\n  }\n\n  onOpen(): void {\n    this.changeState(STATES.CONNECTED);\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState(STATES.DISCONNECTED);\n    this.fail_count++;\n    if (this.fail_count < 3) {\n      this.connect();\n    }\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === STATES.SYNCHRONIZED) {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    this.changeState(STATES.SYNCHRONIZING);\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(data => {\n        this.book.sequence = data.sequence;\n        this.book.bids = data.bids;\n        this.book.asks = data.asks;\n        this.changeState(STATES.SYNCHRONIZED);\n        this.queue.forEach(message => this.processMessage(JSON.parse(message), new Date()));\n        this.queue = [];\n      })\n      .catch(error => {\n        this.emit('error', error);\n        this.changeState(STATES.ERROR);\n      });\n  }\n\n  processMessage(message: object, t: Date): void {\n    // Validate and process message\n    // Emit appropriate events\n  }\n}\n```",
      "```typescript\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = 'disconnected';\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {};\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book = {};\n    this.queue = [];\n  }\n\n  connect(): void {\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string): void {\n    this.state = stateName;\n    this.emit('statechange', stateName);\n  }\n\n  onOpen(): void {\n    this.changeState('connected');\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState('disconnected');\n    this.fail_count++;\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === 'connected') {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    this.socket.send(`subscribe ${this.productID}`);\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(data => {\n        this.book = data;\n        this.emit('snapshot', data);\n      });\n  }\n\n  processMessage(message: object, t: Date): void {\n    // Validate and process message\n    // Emit appropriate events\n  }\n}\n```",
      "```typescript\nimport { EventEmitter } from 'events';\n\nenum STATES {\n  DISCONNECTED,\n  CONNECTING,\n  CONNECTED,\n  SYNCHRONIZING,\n  SYNCHRONIZED,\n  ERROR\n}\n\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = STATES.DISCONNECTED;\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {\n      sequence: 0,\n      bids: [],\n      asks: []\n    };\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book.sequence = 0;\n    this.book.bids = [];\n    this.book.asks = [];\n    this.queue = [];\n  }\n\n  connect(): void {\n    if (this.state === STATES.CONNECTED || this.state === STATES.CONNECTING) return;\n    this.state = STATES.CONNECTING;\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onerror = (error) => {\n      this.emit('error', error);\n      this.changeState(STATES.ERROR);\n    };\n  }\n\n  disconnect(): void {\n    if (this.state !== STATES.CONNECTED) return;\n    this.socket.close();\n  }\n\n  changeState(stateName: string): void {\n    const state = STATES[stateName.toUpperCase()];\n    if (state === undefined) return;\n    this.state = state;\n    this.emit('statechange', state);\n  }\n\n  onOpen(): void {\n    this.changeState(STATES.CONNECTED);\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState(STATES.DISCONNECTED);\n    this.fail_count++;\n    if (this.fail_count < 3) {\n      setTimeout(() => this.connect(), 1000 * this.fail_count);\n    }\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === STATES.SYNCHRONIZED) {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    this.changeState(STATES.SYNCHRONIZING);\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(data => {\n        this.book.sequence = data.sequence;\n        this.book.bids = data.bids;\n        this.book.asks = data.asks;\n        this.changeState(STATES.SYNCHRONIZED);\n      })\n      .catch(error => {\n        this.emit('error', error);\n        this.changeState(STATES.ERROR);\n      });\n  }\n\n  processMessage(message: object, t: Date): void {\n    if (message.type === 'update') {\n      this.emit('update', message, t);\n    } else if (message.type === 'add') {\n      this.emit('add', message, t);\n    } else if (message.type === 'remove') {\n      this.emit('remove', message, t);\n    }\n  }\n}\n```",
      "```typescript\nimport { EventEmitter } from 'events';\n\nenum STATES {\n  CONNECTING,\n  OPEN,\n  CLOSING,\n  CLOSED\n}\n\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = STATES.CONNECTING;\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {};\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book = {};\n    this.queue = [];\n  }\n\n  connect(): void {\n    if (this.state !== STATES.OPEN) {\n      this.socket = new WebSocket(this.websocketURI);\n      this.socket.onopen = this.onOpen.bind(this);\n      this.socket.onclose = this.onClose.bind(this);\n      this.socket.onmessage = this.onMessage.bind(this);\n      this.socket.onerror = (error) => {\n        this.emit('error', error);\n      };\n      this.changeState(STATES.OPEN);\n    }\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string): void {\n    this.state = stateName;\n    this.emit('statechange', this.state);\n  }\n\n  onOpen(): void {\n    this.changeState(STATES.OPEN);\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState(STATES.CLOSED);\n    this.fail_count++;\n    if (this.fail_count < 3) {\n      setTimeout(() => this.connect(), 5000);\n    }\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === STATES.OPEN) {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(data => {\n        this.book = data;\n        this.queue.forEach(message => this.onMessage(message));\n        this.queue = [];\n      })\n      .catch(error => {\n        this.emit('error', error);\n      });\n  }\n\n  processMessage(message: object, t: Date): void {\n    // Validate and process message\n    // Emit appropriate events\n  }\n}\n```",
      "```typescript\nimport { EventEmitter } from 'events';\n\nenum STATES {\n  CONNECTING,\n  OPEN,\n  CLOSING,\n  CLOSED\n}\n\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = STATES.CONNECTING;\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {};\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book = {};\n    this.queue = [];\n  }\n\n  connect(): void {\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onerror = (error) => {\n      this.emit('error', error);\n    };\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string): void {\n    this.state = stateName;\n    this.emit('statechange', this.state);\n  }\n\n  onOpen(): void {\n    this.changeState(STATES.OPEN);\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState(STATES.CLOSED);\n    this.fail_count++;\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === STATES.OPEN) {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    this.socket.send(`subscribe ${this.productID}`);\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(data => {\n        this.book = data;\n        this.emit('snapshot', this.book);\n      })\n      .catch(error => {\n        this.emit('error', error);\n      });\n  }\n\n  processMessage(message: object, t: Date): void {\n    // Validate and process message\n    // Emit appropriate events\n  }\n}\n```",
      "```typescript\nclass OrderBook extends EventEmitter {\n    productID: string;\n    websocketURI: string;\n    restURI: string;\n    state: string;\n    fail_count: number;\n    timeProvider: any;\n    socket: WebSocket;\n    queue: Array<string>;\n    book: any;\n\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        super();\n        this.productID = productID;\n        this.websocketURI = websocketURI;\n        this.restURI = restURI;\n        this.state = 'DISCONNECTED';\n        this.fail_count = 0;\n        this.timeProvider = timeProvider;\n        this.socket = null;\n        this.queue = [];\n        this.book = {};\n        this.connect();\n    }\n\n    clear_book(): void {\n        this.book = {};\n        this.queue = [];\n    }\n\n    connect(): void {\n        this.socket = new WebSocket(this.websocketURI);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    disconnect(): void {\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n\n    changeState(stateName: string): void {\n        this.state = stateName;\n        this.emit('statechange', stateName);\n    }\n\n    onOpen(): void {\n        this.changeState('CONNECTED');\n        this.sync();\n    }\n\n    onClose(): void {\n        this.changeState('DISCONNECTED');\n        this.fail_count++;\n        if (this.fail_count > 3) {\n            this.fail_count = 0;\n            this.connect();\n        }\n    }\n\n    onMessage(datastr: string): void {\n        this.queue.push(datastr);\n        if (this.state === 'SYNCHRONIZING') {\n            this.processMessage(JSON.parse(datastr), new Date());\n        }\n    }\n\n    sync(): void {\n        this.changeState('SYNCHRONIZING');\n        fetch(this.restURI)\n            .then(response => response.json())\n            .then(data => {\n                this.book = data;\n                this.queue.forEach(message => {\n                    this.processMessage(JSON.parse(message), new Date());\n                });\n                this.queue = [];\n                this.changeState('SYNCHRONIZED');\n            })\n            .catch(error => {\n                console.error('Failed to fetch initial snapshot:', error);\n                this.changeState('ERROR');\n            });\n    }\n\n    processMessage(message: any, t: Date): void {\n        // Validate and process message\n        // Emit appropriate events\n    }\n}\n```",
      "```typescript\nimport { EventEmitter } from 'events';\n\nenum STATES {\n  CONNECTING,\n  OPEN,\n  CLOSING,\n  CLOSED\n}\n\nclass OrderBook extends EventEmitter {\n  productID: string;\n  websocketURI: string;\n  restURI: string;\n  state: string;\n  fail_count: number;\n  timeProvider: any;\n  socket: WebSocket;\n  queue: Array<string>;\n  book: any;\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = STATES.CONNECTING;\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {};\n    this.connect();\n  }\n\n  clear_book(): void {\n    this.book = {};\n    this.queue = [];\n  }\n\n  connect(): void {\n    if (this.state !== STATES.OPEN) {\n      this.socket = new WebSocket(this.websocketURI);\n      this.socket.onopen = this.onOpen.bind(this);\n      this.socket.onclose = this.onClose.bind(this);\n      this.socket.onmessage = this.onMessage.bind(this);\n      this.socket.onerror = (error) => {\n        this.emit('error', error);\n      };\n    }\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName: string): void {\n    this.state = stateName;\n    this.emit('statechange', this.state);\n  }\n\n  onOpen(): void {\n    this.changeState(STATES.OPEN);\n    this.sync();\n  }\n\n  onClose(): void {\n    this.changeState(STATES.CLOSED);\n    this.fail_count++;\n    if (this.fail_count < 3) {\n      this.connect();\n    }\n  }\n\n  onMessage(datastr: string): void {\n    this.queue.push(datastr);\n    if (this.state === STATES.OPEN) {\n      this.processMessage(JSON.parse(datastr), new Date());\n    }\n  }\n\n  sync(): void {\n    this.socket.send(`subscribe ${this.productID}`);\n    fetch(this.restURI)\n      .then(response => response.json())\n      .then(data => {\n        this.book = data;\n        this.emit('snapshot', this.book);\n      })\n      .catch(error => {\n        this.emit('error', error);\n      });\n  }\n\n  processMessage(message: any, t: Date): void {\n    // Validate and process message\n    // Emit appropriate events\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 195,
    "Instruction": "Task Description: Create a function to test WebSocket communication between a client and server, verifying the ability to send and receive empty payload messages.\n\nFunction Description: The function sets up a WebSocket server and client, where the server echoes back an empty message when it receives any message from the client. The test verifies that the client can successfully receive this empty message.\n\nInput: None (The function is self-contained and doesn't require external parameters)\n\nOutput: None (The function performs assertions internally and doesn't return any value)",
    "Canonical_solution": "function testWebSocketCommunication() {\n  const { test } = require('node:test');\n  const { WebSocketServer } = require('ws');\n  const { WebSocket } = require('../..');\n  const { tspl } = require('@matteo.collina/tspl');\n\n  test('Receiving frame with payload length 0 works', async (t) => {\n    const { ok, completed } = tspl(t, { plan: 1 });\n\n    const server = new WebSocketServer({ port: 0 });\n\n    server.on('connection', (socket) => {\n      socket.on('message', () => {\n        socket.send('');\n      });\n    });\n\n    t.after(() => {\n      server.close();\n      ws.close();\n    });\n\n    const ws = new WebSocket(`ws://127.0.0.1:${server.address().port}`);\n\n    ws.addEventListener('open', () => {\n      ws.send('Hi');\n    });\n\n    ws.addEventListener('message', () => {\n      ok(true);\n    });\n\n    await completed;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        if message == \"\":\n            await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect('ws://localhost:8765') as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\"\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, 'localhost', 8765)\n    async with server:\n        await asyncio.gather(echo_client(), server.serve_forever())\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect('ws://localhost:8765') as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\"\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, 'localhost', 8765)\n    async with server:\n        await asyncio.gather(echo_client(), server.serve_forever())\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        if message == \"\":\n            await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect('ws://localhost:8765') as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\"\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, 'localhost', 8765)\n    async with server:\n        await echo_client()\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        await websocket.send('')\n\nasync def echo_client():\n    async with websockets.connect('ws://localhost:8765') as websocket:\n        await websocket.send('')\n        response = await websocket.recv()\n        assert response == ''\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, 'localhost', 8765)\n    async with server:\n        await asyncio.gather(echo_client(), server.serve_forever())\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        if message == \"\":\n            await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect(\"ws://localhost:8765\") as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\"\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, \"localhost\", 8765)\n    async with server:\n        await echo_client()\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        if message == \"\":\n            await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect(\"ws://localhost:8765\") as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\", \"Received non-empty message\"\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, \"localhost\", 8765)\n    async with server:\n        await echo_client()\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect('ws://localhost:8765') as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\"\n\nasync def main():\n    server = await asyncio.start_server(echo_server, 'localhost', 8765)\n    async with server:\n        await asyncio.gather(echo_client(), server.serve_forever())\n\nasyncio.run(main())\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        if message == \"\":\n            await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect('ws://localhost:8765') as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\"\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, 'localhost', 8765)\n    async with server:\n        await echo_client()\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        if message == \"\":\n            await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect(\"ws://localhost:8765\") as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\"\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, \"localhost\", 8765)\n    async with server:\n        await echo_client()\n```",
      "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        await websocket.send(\"\")\n\nasync def echo_client():\n    async with websockets.connect('ws://localhost:8765') as websocket:\n        await websocket.send(\"\")\n        response = await websocket.recv()\n        assert response == \"\"\n\nasync def test_websocket_communication():\n    server = await asyncio.start_server(echo_server, 'localhost', 8765)\n    async with server:\n        await asyncio.gather(echo_client(), server.serve_forever())\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [],
    "unmatched_results": [
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = None\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = None\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new session\n        pass\n\n    def _cleanupSession(self, session_id):\n        # Implementation for cleaning up a session\n        pass\n```",
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = None\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = None\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new debugging session\n        pass\n```",
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = None\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = None\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new debugging session\n        pass\n```",
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = None\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = None\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new debugging session\n        pass\n```",
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = None\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = None\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new debugging session\n        pass\n```",
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message.data)\n\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = None\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = None\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new debugging session\n        pass\n\n    def _cleanupSession(self, session):\n        # Implementation for cleaning up a session\n        pass\n```",
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = None\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = None\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new session\n        pass\n\n    def _cleanupSession(self, session_id):\n        # Implementation for cleaning up a session\n        pass\n```",
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = None\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = None\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new session\n        pass\n```",
      "```python\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    def send(self, message):\n        if self._ws.open:\n            self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.onmessage = None\n\n    def _messageReceived(self, message):\n        if self._handler:\n            self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = Promise()\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = \"/tmp/ndd_service_pipe\"\n\n    def _startSession(self, info, frontend):\n        # Implementation for starting a new debugging session\n        pass\n\n    async def cleanup(self):\n        # Implementation for cleaning up a session\n        pass\n```",
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass Channel:\n    def __init__(self, ws):\n        self._ws = ws\n        self._handler = None\n        self._messageListener = self._messageReceived\n\n    async def send(self, message):\n        if self._ws.open:\n            await self._ws.send(message)\n\n    def close(self):\n        self._ws.close()\n\n    def listen(self, handler):\n        self._handler = handler\n\n    def dispose(self):\n        self._ws.close()\n\n    async def _messageReceived(self, message):\n        if self._handler:\n            await self._handler(message)\n\nclass NddService:\n    def __init__(self, frontend):\n        self._disconnectPromise = asyncio.get_event_loop().create_future()\n        self._connected = set()\n        self._frontend = frontend\n        self._pipe = \"debugging_pipe\"\n\n    async def _startSession(self, info, frontend):\n        # Implementation for starting a new debugging session\n        pass\n\n    async def run(self):\n        # Implementation for running the IPC server\n        pass\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome's DevTools Protocol, handling connection, message exchange, and event emission.\n\nClass Description: The Chrome class extends EventEmitter to create a WebSocket client that connects to Chrome's DevTools Protocol. It manages WebSocket connections, handles message parsing, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- _notifier: [Object] - External notification handler\n- _callbacks: [Object] - Map of pending command callbacks\n- _nextCommandId: [Number] - Counter for generating command IDs\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- constructor: [constructor](options: Object, notifier: Object) -> [Chrome] - Initializes the Chrome instance with connection options and notifier\n- _connectToWebSocket: [_connectToWebSocket]() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleMessage: [_handleMessage](message: Object) -> [void] - Processes incoming WebSocket messages (responses and events)\n- _enqueueCommand: [_enqueueCommand](method: String, params: Object, sessionId: String, callback: Function) -> [void] - Sends a command through WebSocket and tracks its callback\n- send: [send](method: String, ...args: Any) -> [Promise|undefined] - Public method to send commands, supporting both callback and Promise patterns",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this._notifier = notifier;\n        this._callbacks = {};\n        this._nextCommandId = 1;\n        this.webSocketUrl = undefined;\n        this._start();\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n        \n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = reject;\n      this._ws.onmessage = this._handleMessage.bind(this);\n      this._ws.onclose = () => {\n        this.emit('close');\n        this._ws = null;\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(data.result, data.error);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = { id: commandId, method, params, sessionId };\n    this._callbacks[commandId] = callback;\n    this._ws.send(JSON.stringify(command));\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      this._enqueueCommand(method, args, null, (result, error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        reject(error);\n      };\n      this._ws.onmessage = (event) => {\n        this._handleMessage(JSON.parse(event.data));\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    if (message.id) {\n      const callback = this._callbacks[message.id];\n      if (callback) {\n        callback(message.result, message.error);\n        delete this._callbacks[message.id];\n      }\n    } else {\n      this.emit(message.method, message.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = {\n      id: commandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n    this._callbacks[commandId] = callback;\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      this._enqueueCommand(method, args, null, (result, error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = reject;\n      this._ws.onmessage = this._handleMessage.bind(this);\n      this._ws.onclose = () => {\n        this.emit('close');\n        this._ws = null;\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = { id: commandId, method, params, sessionId };\n    this._callbacks[commandId] = callback;\n    this._ws.send(JSON.stringify(command));\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      this._enqueueCommand(method, args, null, (err, result) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options = {}, notifier = {}) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = reject;\n      this._ws.onmessage = this._handleMessage.bind(this);\n      this._ws.onclose = () => {\n        this.emit('close');\n        this._ws = null;\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(data.result, data.error);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = { id: commandId, method, params, sessionId };\n    this._callbacks[commandId] = callback;\n    this._ws.send(JSON.stringify(command));\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      this._enqueueCommand(method, args, null, (result, error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        reject(error);\n      };\n      this._ws.onmessage = (event) => {\n        this._handleMessage(JSON.parse(event.data));\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    if (message.id) {\n      const callback = this._callbacks[message.id];\n      if (callback) {\n        callback(message.result, message.error);\n        delete this._callbacks[message.id];\n      }\n    } else {\n      this.emit(message.method, message.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = { id: commandId, method, params, sessionId };\n    this._ws.send(JSON.stringify(command));\n    this._callbacks[commandId] = callback;\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      const sessionId = args[0];\n      const callback = args[1];\n      this._enqueueCommand(method, args.slice(2), sessionId, (result, error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this._createWebSocketUrl();\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => {\n        this.emit('connected');\n        resolve();\n      };\n      this._ws.onerror = (error) => {\n        this.emit('error', error);\n        reject(error);\n      };\n      this._ws.onmessage = (event) => {\n        this._handleMessage(JSON.parse(event.data));\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    if (message.id) {\n      const callback = this._callbacks[message.id];\n      if (callback) {\n        callback(message.result, message.error);\n        delete this._callbacks[message.id];\n      }\n    } else {\n      this.emit(message.method, message.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = { id: commandId, method, params, sessionId };\n    this._ws.send(JSON.stringify(command));\n    this._callbacks[commandId] = callback;\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      this._enqueueCommand(method, args, null, (result, error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n\n  _createWebSocketUrl() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.host}:${this.port}`;\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = reject;\n      this._ws.onmessage = this._handleMessage.bind(this);\n      this._ws.onclose = () => {\n        this.emit('close');\n        this._ws = null;\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(data.result, data.error);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = { id: commandId, method, params, sessionId };\n    this._callbacks[commandId] = callback;\n    this._ws.send(JSON.stringify(command));\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      const callback = (result, error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n      this._enqueueCommand(method, args, null, callback);\n    });\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options = {}, notifier = {}) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = reject;\n      this._ws.onmessage = this._handleMessage.bind(this);\n    });\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(data.result, data.error);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = {\n      id: commandId,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(command));\n    this._callbacks[commandId] = callback;\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      const sessionId = args[0];\n      const callback = args[1];\n      this._enqueueCommand(method, args.slice(2), sessionId, (result, error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n```",
      "```javascript\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this._buildWebSocketUrl();\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = reject;\n      this._ws.onmessage = this._handleMessage.bind(this);\n    });\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const message = JSON.stringify({\n      id: commandId,\n      method,\n      params,\n      sessionId\n    });\n    this._ws.send(message);\n    this._callbacks[commandId] = callback;\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      this._enqueueCommand(method, args, null, (err, result) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n\n  _buildWebSocketUrl() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.host}:${this.port}`;\n  }\n}\n```",
      "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 0;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = reject;\n      this._ws.onmessage = this._handleMessage.bind(this);\n      this._ws.onclose = () => {\n        this.emit('close');\n        this._ws = null;\n      };\n    });\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message.data);\n    if (data.id) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result);\n        delete this._callbacks[data.id];\n      }\n    } else {\n      this.emit(data.method, data.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const commandId = ++this._nextCommandId;\n    const command = { id: commandId, method, params, sessionId };\n    this._callbacks[commandId] = callback;\n    this._ws.send(JSON.stringify(command));\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      this._enqueueCommand(method, args, null, (err, result) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a WebSocket client class in Node.js that handles WebSocket connections, message transmission, and connection lifecycle events.\n\nClass Description: WebSocketImpl is a WebSocket client implementation that manages WebSocket connections, including establishing connections, handling incoming messages, managing connection states, and sending messages. It wraps the 'ws' library functionality with additional state management and event handling.\n\nAttributes:\n- _globalObject: [Object] - The global context in which the WebSocket operates\n- _ownerDocument: [Object] - The document associated with the WebSocket\n- _urlRecord: [Object|null] - URL information for the WebSocket connection\n- url: [String] - The WebSocket server URL\n- extensions: [String] - Supported WebSocket extensions\n- binaryType: [String] - Type of binary data handling (\"blob\" or \"arraybuffer\")\n- _ws: [Object|null] - The underlying WebSocket instance\n- _readyState: [Number] - Current connection state (0=CONNECTING, 1=OPEN, 2=CLOSING, 3=CLOSED)\n- _requiredToFail: [Boolean] - Flag indicating if the connection should fail\n- bufferedAmount: [Number] - Number of bytes of queued data\n- _sendQueue: [Array] - Queue of messages waiting to be sent\n- _dequeueScheduled: [Boolean] - Flag for send queue scheduling\n\nMethods:\n- constructor(globalObject, args, privateData) -> [void] - Initializes the WebSocket client with configuration and establishes connection\n- _onConnectionEstablished() -> [void] - Handles successful connection establishment\n- _onMessageReceived(data, isBinary) -> [void] - Processes incoming WebSocket messages\n- _onConnectionClosed(code, reason) -> [void] - Handles connection closure\n- close(code, reason) -> [void] - Closes the WebSocket connection with optional code and reason\n- send(data) -> [void] - Queues data for sending through the WebSocket\n- _actuallySend() -> [void] - Internal method that sends queued messages\n- _scheduleSend() -> [void] - Schedules message sending on the next event loop tick",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = privateData.document;\n    this._urlRecord = null;\n    this.url = \"\";\n    this.extensions = \"\";\n    this.binaryType = \"blob\";\n    this._ws = null;\n    this._readyState = 0; // CONNECTING\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    const url = args[0];\n    let protocols = args[1] !== undefined ? args[1] : [];\n\n    this._ws = new WebSocket(this.url, protocols, {\n      headers: {\n        \"user-agent\": globalObject.navigator.userAgent,\n        \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n        \"origin\": globalObject._origin\n      },\n      rejectUnauthorized: globalObject._resourceLoader._strictSSL\n    });\n\n    this._ws.once(\"open\", () => {\n      this._onConnectionEstablished();\n    });\n    this._ws.on(\"message\", this._onMessageReceived.bind(this));\n    this._ws.once(\"close\", (...closeArgs) => {\n      this._onConnectionClosed(...closeArgs);\n    });\n    this._ws.once(\"error\", () => {\n      this._requiredToFail = true;\n    });\n  }\n\n  _onConnectionEstablished() {\n    if (this._ws.extensions !== null) {\n      this.extensions = Object.keys(this._ws.extensions).join(\", \");\n    }\n    // fire open event\n  }\n\n  _onMessageReceived(data, isBinary) {\n    if (this.readyState !== 1) { // OPEN\n      return;\n    }\n    // process message data and fire message event\n  }\n\n  _onConnectionClosed(code, reason) {\n    // fire close event\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (this.readyState === 0) { // CONNECTING\n      this._requiredToFail = true;\n      if (this._ws !== null) {\n        this._ws.terminate();\n      } else {\n        this._readyState = 2; // CLOSING\n      }\n    } else if (this.readyState === 1) { // OPEN\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this.readyState === 0) { // CONNECTING\n      throw new Error(\"Still in CONNECTING state.\");\n    }\n    if (this.readyState !== 1) { // OPEN\n      return;\n    }\n    let length;\n    if (typeof data === \"string\") {\n      length = Buffer.byteLength(data, \"utf8\");\n    } else {\n      length = data.byteLength;\n    }\n    this.bufferedAmount += length;\n    this._sendQueue.push([data, length]);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    for (const [data, length] of this._sendQueue.splice(0)) {\n      this._ws.send(data, { binary: typeof data !== \"string\" }, () => {\n        this.bufferedAmount -= length;\n      });\n    }\n  }\n\n  _scheduleSend() {\n    if (this._dequeueScheduled) {\n      return;\n    }\n    this._dequeueScheduled = true;\n    process.nextTick(() => {\n      this._dequeueScheduled = false;\n      this._actuallySend();\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, { extensions: this.extensions });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._onConnectionClosed(1006, 'Error');\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle connection closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => this._actuallySend());\n    }\n  }\n\n  _actuallySend() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n    this._dequeueScheduled = false;\n  }\n\n  _scheduleSend() {\n    process.nextTick(() => this._actuallySend());\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = args.ownerDocument;\n    this._urlRecord = args.urlRecord;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, {\n      perMessageDeflate: false,\n      extensions: this.extensions,\n      binaryType: this.binaryType\n    });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._onConnectionClosed(1006, 'Error');\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle connection closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN && this._sendQueue.length > 0) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => {\n        this._dequeueScheduled = false;\n        this._actuallySend();\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = args.ownerDocument;\n    this._urlRecord = args.urlRecord;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, { extensions: this.extensions });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._onConnectionClosed(1006, 'Error');\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle connection closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => this._actuallySend());\n    }\n  }\n\n  _actuallySend() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n    this._dequeueScheduled = false;\n  }\n\n  _scheduleSend() {\n    process.nextTick(() => this._actuallySend());\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = args.ownerDocument;\n    this._urlRecord = args.urlRecord;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, { extensions: this.extensions });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._onConnectionClosed(1006, 'Error');\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle connection closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN && this._sendQueue.length > 0) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => {\n        this._dequeueScheduled = false;\n        this._actuallySend();\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, { extensions: this.extensions });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._readyState = WebSocket.CLOSED;\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n    this._dequeueScheduled = false;\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => this._actuallySend());\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = args.ownerDocument;\n    this._urlRecord = privateData.urlRecord;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, {\n      perMessageDeflate: false,\n      extensions: this.extensions,\n      binaryType: this.binaryType\n    });\n\n    this._ws.on('open', () => {\n      this._readyState = WebSocket.OPEN;\n      this._onConnectionEstablished();\n    });\n\n    this._ws.on('message', (data, isBinary) => {\n      this._onMessageReceived(data, isBinary);\n    });\n\n    this._ws.on('close', (code, reason) => {\n      this._readyState = WebSocket.CLOSED;\n      this._onConnectionClosed(code, reason);\n    });\n\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._readyState = WebSocket.CLOSED;\n      this._onConnectionClosed(1006, 'Error: ' + error.message);\n    });\n  }\n\n  _onConnectionEstablished() {\n    // Custom implementation for connection established\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Custom implementation for message received\n  }\n\n  _onConnectionClosed(code, reason) {\n    // Custom implementation for connection closed\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN && this._sendQueue.length > 0) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => {\n        this._dequeueScheduled = false;\n        this._actuallySend();\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, { extensions: this.extensions });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._onConnectionClosed(1006, 'Error');\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle connection closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN && this._sendQueue.length > 0) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => {\n        this._dequeueScheduled = false;\n        this._actuallySend();\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, { extensions: this.extensions });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._onConnectionClosed(1006, 'Error');\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle connection closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN && this._sendQueue.length > 0) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => {\n        this._dequeueScheduled = false;\n        this._actuallySend();\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, { extensions: this.extensions });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._onConnectionClosed(1006, 'Error');\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle connection closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN && this._sendQueue.length > 0) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => {\n        this._dequeueScheduled = false;\n        this._actuallySend();\n      });\n    }\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this.extensions = args.extensions;\n    this.binaryType = args.binaryType;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n    this._ws = new WebSocket(this.url, {\n      perMessageDeflate: false,\n      extensions: this.extensions,\n      binaryType: this.binaryType\n    });\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._readyState = WebSocket.CLOSED;\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN && this._sendQueue.length > 0) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n    }\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => {\n        this._dequeueScheduled = false;\n        this._actuallySend();\n      });\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Create a WebSocket processor class that manages WebSocket connections and integrates with an HTTP server for handling real-time communication.\n\nClass Description: The Processor class extends EventEmitter to handle WebSocket connections over an HTTP server. It manages the server lifecycle, connection events, and data transmission between client and server.\n\nAttributes:\n- httpServer: [Object] - Instance of Node.js HTTP server used as base for WebSocket server\n- wsServer: [Object] - WebSocket server instance attached to the HTTP server\n- state: [Number] - Tracks the server state (ST_STARTED or ST_CLOSED)\n\nMethods:\n- constructor() -> [void] - Initializes the HTTP and WebSocket servers, sets up connection event handling\n- add(socket: [Object], data: [Buffer|String]) -> [void] - Processes incoming socket connection and data\n- close() -> [void] - Properly shuts down the WebSocket and HTTP servers",
    "Canonical_solution": "var HttpServer = require('http').Server;\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar WebSocketServer = require('ws').Server;\n\nvar ST_STARTED = 1;\nvar ST_CLOSED = 2;\n\nclass Processor extends EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = new HttpServer();\n    this.wsServer = new WebSocketServer({server: this.httpServer});\n    this.state = ST_STARTED;\n\n    this.wsServer.on('connection', (socket) => {\n      this.emit('connection', socket);\n    });\n  }\n\n  add(socket, data) {\n    if(this.state !== ST_STARTED) {\n      return;\n    }\n    this.httpServer.emit('connection', socket);\n    if(typeof socket.ondata === 'function') {\n      socket.ondata(data, 0, data.length);\n    } else {\n      socket.emit('data', data);\n    }\n  }\n\n  close() {\n    if(this.state !== ST_STARTED) {\n      return;\n    }\n    this.state = ST_CLOSED;\n    this.wsServer.close();\n    this.wsServer = null;\n    this.httpServer = null;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nclass Processor extends EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new WebSocket.Server({ server: this.httpServer });\n    this.state = 0; // ST_CLOSED\n    this.wsServer.on('connection', (socket) => {\n      this.emit('connection', socket);\n    });\n    this.httpServer.listen(() => {\n      this.state = 1; // ST_STARTED\n      this.emit('start');\n    });\n  }\n\n  add(socket, data) {\n    if (socket.readyState === WebSocket.OPEN) {\n      socket.send(data);\n    }\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close();\n    this.state = 0; // ST_CLOSED\n    this.emit('close');\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nclass Processor extends EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new WebSocket.Server({ server: this.httpServer });\n    this.state = 0; // ST_CLOSED\n    this.httpServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n    this.wsServer.on('connection', (ws) => {\n      ws.on('message', (data) => {\n        this.add(null, data);\n      });\n    });\n  }\n\n  add(socket, data) {\n    if (socket) {\n      // Handle incoming socket connection\n    } else {\n      // Handle incoming WebSocket message\n    }\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close();\n    this.state = 1; // ST_CLOSED\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nclass Processor extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new Server(this.httpServer);\n    this.state = 0; // ST_CLOSED\n    this.httpServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n    this.wsServer.on('connection', (socket) => {\n      socket.on('message', (data) => {\n        this.add(socket, data);\n      });\n    });\n  }\n\n  add(socket, data) {\n    if (this.state === 0) {\n      this.state = 1; // ST_STARTED\n      this.httpServer.listen(8080);\n    }\n    if (data) {\n      this.emit('data', data);\n    }\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close();\n    this.state = 0; // ST_CLOSED\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nclass Processor extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new Server(this.httpServer);\n    this.state = 0; // ST_CLOSED\n    this.httpServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n    this.wsServer.on('connection', (socket) => {\n      socket.on('message', (data) => {\n        this.add(socket, data);\n      });\n    });\n  }\n\n  add(socket, data) {\n    if (this.state === 0) {\n      this.state = 1; // ST_STARTED\n      this.emit('start');\n    }\n    if (data) {\n      this.emit('data', data);\n    }\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close();\n    this.state = 0; // ST_CLOSED\n    this.emit('close');\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nclass Processor extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new Server(this.httpServer);\n    this.state = 0; // ST_CLOSED\n    this.httpServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n    this.wsServer.on('connection', (socket) => {\n      socket.on('message', (data) => {\n        this.add(socket, data);\n      });\n    });\n  }\n\n  add(socket, data) {\n    if (this.state === 0) {\n      this.state = 1; // ST_STARTED\n      this.httpServer.listen(8080);\n    }\n    if (data) {\n      this.emit('data', data);\n    }\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close();\n    this.state = 0; // ST_CLOSED\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nclass Processor extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new Server(this.httpServer);\n    this.state = 0; // ST_CLOSED\n    this.httpServer.listen(() => {\n      this.state = 1; // ST_STARTED\n      this.emit('serverStarted');\n    });\n    this.wsServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n  }\n\n  add(socket, data) {\n    // Process socket connection and data\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close(() => {\n      this.state = 0; // ST_CLOSED\n      this.emit('serverClosed');\n    });\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nclass Processor extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new Server(this.httpServer);\n    this.state = 0; // ST_CLOSED\n    this.httpServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n    this.wsServer.on('connection', (socket) => {\n      socket.on('message', (data) => {\n        this.add(socket, data);\n      });\n      socket.on('close', () => {\n        this.close();\n      });\n    });\n  }\n\n  add(socket, data) {\n    if (this.state === 0) {\n      this.state = 1; // ST_STARTED\n      this.httpServer.listen(8080);\n    }\n    if (data) {\n      this.emit('data', data);\n    }\n  }\n\n  close() {\n    if (this.state === 1) {\n      this.state = 0; // ST_CLOSED\n      this.httpServer.close();\n      this.wsServer.close();\n    }\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nclass Processor extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new Server(this.httpServer);\n    this.state = 0; // ST_CLOSED\n    this.httpServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n    this.wsServer.on('connection', (socket) => {\n      socket.on('message', (data) => {\n        this.add(socket, data);\n      });\n    });\n  }\n\n  add(socket, data) {\n    if (this.state === 0) {\n      this.state = 1; // ST_STARTED\n      this.httpServer.listen(8080);\n    }\n    if (data) {\n      this.emit('data', data);\n    }\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close();\n    this.state = 0; // ST_CLOSED\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nclass Processor extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new Server(this.httpServer);\n    this.state = 0; // ST_CLOSED\n    this.httpServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n    this.wsServer.on('connection', (socket) => {\n      socket.on('message', (data) => {\n        this.add(socket, data);\n      });\n    });\n  }\n\n  add(socket, data) {\n    if (this.state === 0) {\n      this.state = 1; // ST_STARTED\n      this.httpServer.listen(8080);\n    }\n    if (data) {\n      this.emit('data', data);\n    }\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close();\n    this.state = 0; // ST_CLOSED\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst { Server } = require('socket.io');\nconst EventEmitter = require('events');\n\nclass Processor extends EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = http.createServer();\n    this.wsServer = new Server(this.httpServer);\n    this.state = 0; // ST_CLOSED\n    this.httpServer.listen(() => {\n      this.state = 1; // ST_STARTED\n      this.emit('serverStarted');\n    });\n    this.wsServer.on('connection', (socket) => {\n      this.add(socket, null);\n    });\n  }\n\n  add(socket, data) {\n    // Process the socket connection and data\n  }\n\n  close() {\n    this.wsServer.close();\n    this.httpServer.close(() => {\n      this.state = 0; // ST_CLOSED\n      this.emit('serverClosed');\n    });\n  }\n}\n```"
    ],
    "match_count": 2,
    "pass@3": 0.5333333333333333,
    "pass@5": 0.7777777777777778
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a JavaScript class for interacting with the Cryptsy cryptocurrency exchange API, handling both public and private endpoints with proper authentication and request management.\n\nClass Description: The Cryptsy class provides a wrapper for the Cryptsy API, enabling users to make authenticated requests to private endpoints and public data requests. It handles API authentication, request signing, and response processing.\n\nAttributes:\n- key: string - API key for authentication\n- secret: string - API secret for request signing\n- PUBLIC_API_URL: string - Base URL for public API endpoints (default: 'http://pubapi.cryptsy.com/api.php')\n- PRIVATE_API_URL: string - Base URL for private API endpoints (default: 'https://api.cryptsy.com/api')\n- USER_AGENT: string - User agent string for requests (default: 'nomp/node-open-mining-portal')\n- STRICT_SSL: boolean - Static flag for SSL verification (default: true)\n\nMethods:\n- constructor(key, secret) -> Cryptsy - Initializes the API client with credentials\n- _getPrivateHeaders(parameters: object) -> object - Generates authentication headers for private requests\n- _request(options: object, callback: function) -> Cryptsy - Base request method with common configuration\n- _public(parameters: object, callback: function) -> Cryptsy - Makes public API requests\n- _private(parameters: object, callback: function) -> Cryptsy - Makes authenticated private API requests\n- getTicker(callback: function) -> Cryptsy - Gets market ticker data\n- getOrderBook(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets order book for a currency pair\n- getTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets public trade history\n- myBalances(callback: function) -> Cryptsy - Gets user's account balances\n- myOpenOrders(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's open orders\n- myTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's trade history\n- buy(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a buy order\n- sell(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a sell order\n- cancelOrder(currencyA: string, currencyB: string, orderNumber: string, callback: function) -> Cryptsy - Cancels an order\n- withdraw(currency: string, amount: number, address: string, callback: function) -> Cryptsy - Withdraws funds\n- _joinCurrencies(currencyA: string, currencyB: string) -> string - Helper to format currency pairs",
    "Canonical_solution": "var request = require('request');\nvar nonce = require('nonce');\nvar crypto = require('crypto');\n\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n    }\n\n    static STRICT_SSL = true;\n\n    _getPrivateHeaders(parameters) {\n        if (!this.key || !this.secret) {\n            throw 'Cryptsy: Error. API key and secret required';\n        }\n\n        let paramString = Object.keys(parameters).sort().map(function(param) {\n            return encodeURIComponent(param) + '=' + encodeURIComponent(parameters[param]);\n        }).join('&');\n\n        let signature = crypto.createHmac('sha512', this.secret).update(paramString).digest('hex');\n\n        return {\n            Key: this.key,\n            Sign: signature\n        };\n    }\n\n    _request(options, callback) {\n        if (!('headers' in options)) {\n            options.headers = {};\n        }\n\n        options.headers['User-Agent'] = this.USER_AGENT;\n        options.json = true;\n        options.strictSSL = Cryptsy.STRICT_SSL;\n\n        request(options, function(err, response, body) {\n            callback(err, body);\n        });\n\n        return this;\n    }\n\n    _public(parameters, callback) {\n        let options = {\n            method: 'GET',\n            url: this.PUBLIC_API_URL,\n            qs: parameters\n        };\n\n        return this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        parameters.nonce = nonce();\n        let options = {\n            method: 'POST',\n            url: this.PRIVATE_API_URL,\n            form: parameters,\n            headers: this._getPrivateHeaders(parameters)\n        };\n\n        return this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        let parameters = {\n            method: 'marketdatav2'\n        };\n        return this._public(parameters, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOrderBook',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    myBalances(callback) {\n        let parameters = {\n            command: 'returnBalances'\n        };\n        return this._private(parameters, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOpenOrders',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'buy',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'sell',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        let parameters = {\n            command: 'cancelOrder',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            orderNumber: orderNumber\n        };\n        return this._private(parameters, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        let parameters = {\n            command: 'withdraw',\n            currency: currency,\n            amount: amount,\n            address: address\n        };\n        return this._private(parameters, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return currencyA + '_' + currencyB;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "class Cryptsy {\n  constructor(key, secret) {\n    this.key = key;\n    this.secret = secret;\n    this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n    this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n    this.USER_AGENT = 'nomp/node-open-mining-portal';\n    this.STRICT_SSL = true;\n  }\n\n  _getPrivateHeaders(parameters) {\n    const timestamp = new Date().getTime();\n    const nonce = timestamp;\n    const signature = this._sign(timestamp, nonce);\n    return {\n      'API-Key': this.key,\n      'Nonce': nonce,\n      'Sign': signature\n    };\n  }\n\n  _request(options, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          callback(null, JSON.parse(xhr.responseText));\n        } else {\n          callback(new Error(xhr.statusText), null);\n        }\n      }\n    };\n    xhr.open(options.method, options.url, true);\n    xhr.setRequestHeader('User-Agent', this.USER_AGENT);\n    if (options.headers) {\n      for (const key in options.headers) {\n        xhr.setRequestHeader(key, options.headers[key]);\n      }\n    }\n    xhr.send(options.body);\n  }\n\n  _public(parameters, callback) {\n    const url = `${this.PUBLIC_API_URL}?method=${parameters.method}`;\n    const options = {\n      method: 'GET',\n      url: url,\n      headers: {}\n    };\n    this._request(options, callback);\n  }\n\n  _private(parameters, callback) {\n    const url = `${this.PRIVATE_API_URL}?method=${parameters.method}`;\n    const options = {\n      method: 'POST',\n      url: url,\n      headers: this._getPrivateHeaders(parameters),\n      body: JSON.stringify(parameters)\n    };\n    this._request(options, callback);\n  }\n\n  getTicker(callback) {\n    this._public({ method: 'marketdata' }, callback);\n  }\n\n  getOrderBook(currencyA, currencyB, callback) {\n    this._public({ method: 'marketdata', pair: `${currencyA}_${currencyB}` }, callback);\n  }\n\n  getTradeHistory(currencyA, currencyB, callback) {\n    this._public({ method: 'marketdata', pair: `${currencyA}_${currencyB}`, tradehistory: 'true' }, callback);\n  }\n\n  myBalances(callback) {\n    this._private({ method: 'userdata', action: 'balances' }, callback);\n  }\n\n  myOpenOrders(currencyA, currencyB, callback) {\n    this._private({ method: 'userdata', action: 'openorders', pair: `${currencyA}_${currencyB}` }, callback);\n  }\n\n  myTradeHistory(currencyA, currencyB, callback) {\n    this._private({ method: 'userdata', action: 'trades', pair: `${currencyA}_${currencyB}` }, callback);\n  }\n\n  buy(currencyA, currencyB, rate, amount, callback) {\n    this._private({ method: 'order', action: 'buy', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount }, callback);\n  }\n\n  sell(currencyA, currencyB, rate, amount, callback) {\n    this._private({ method: 'order', action: 'sell', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount }, callback);\n  }\n\n  cancelOrder(currencyA, currencyB, orderNumber, callback) {\n    this._private({ method: 'order', action: 'cancel', pair: `${currencyA}_${currencyB}`, orderid: orderNumber }, callback);\n  }\n\n  withdraw(currency, amount, address, callback) {\n    this._private({ method: 'userdata', action: 'withdraw', currency: currency, amount: amount, address: address }, callback);\n  }\n\n  _joinCurrencies(currencyA, currencyB) {\n    return `${currencyA}_${currencyB}`;\n  }\n\n  _sign(timestamp, nonce) {\n    const stringToSign = `${timestamp}${nonce}${this.secret}`;\n    return CryptoJS.HmacSHA512(stringToSign, this.secret).toString();\n  }\n}",
      "class Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n        this.STRICT_SSL = true;\n    }\n\n    _getPrivateHeaders(parameters) {\n        const timestamp = Math.floor(Date.now() / 1000);\n        const nonce = Math.floor(Math.random() * 1000000000);\n        const parametersWithNonce = Object.assign({}, parameters, { nonce, timestamp });\n        const parametersString = Object.keys(parametersWithNonce).sort().map(key => `${key}=${encodeURIComponent(parametersWithNonce[key])}`).join('&');\n        const signature = CryptoJS.HmacSHA512(this.secret + parametersString, this.key).toString();\n        return {\n            'apisign': signature,\n            'apisignature': signature,\n            'apisignaturemethod': 'HMAC-SHA512',\n            'apisignaturenonce': nonce,\n            'apisignaturetimestamp': timestamp,\n            'useragent': this.USER_AGENT\n        };\n    }\n\n    _request(options, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(new Error(xhr.statusText), null);\n                }\n            }\n        };\n        xhr.open(options.method, options.url, true);\n        if (options.headers) {\n            Object.keys(options.headers).forEach(key => xhr.setRequestHeader(key, options.headers[key]));\n        }\n        xhr.send(options.body);\n    }\n\n    _public(parameters, callback) {\n        const url = this.PUBLIC_API_URL + '?' + Object.keys(parameters).map(key => `${key}=${encodeURIComponent(parameters[key])}`).join('&');\n        this._request({ url, method: 'GET' }, callback);\n    }\n\n    _private(parameters, callback) {\n        const headers = this._getPrivateHeaders(parameters);\n        const url = this.PRIVATE_API_URL + '?' + Object.keys(parameters).map(key => `${key}=${encodeURIComponent(parameters[key])}`).join('&');\n        this._request({ url, method: 'GET', headers }, callback);\n    }\n\n    getTicker(callback) {\n        this._public({ method: 'getmarketdata' }, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        this._public({ method: 'getorderbook', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        this._public({ method: 'getmarkettrades', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n    }\n\n    myBalances(callback) {\n        this._private({ method: 'getbalances' }, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        this._private({ method: 'getopenorders', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        this._private({ method: 'gettrades', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'buy', marketid: this._joinCurrencies(currencyA, currencyB), rate, amount }, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'sell', marketid: this._joinCurrencies(currencyA, currencyB), rate, amount }, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        this._private({ method: 'cancelorder', marketid: this._joinCurrencies(currencyA, currencyB), orderid: orderNumber }, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        this._private({ method: 'withdraw', currency, amount, address }, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return `${currencyA}_${currencyB}`;\n    }\n}",
      "```javascript\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n        this.STRICT_SSL = true;\n    }\n\n    _getPrivateHeaders(parameters) {\n        // Implementation for generating private request headers\n    }\n\n    _request(options, callback) {\n        // Implementation for base request method\n    }\n\n    _public(parameters, callback) {\n        // Implementation for public API requests\n    }\n\n    _private(parameters, callback) {\n        // Implementation for private API requests\n    }\n\n    getTicker(callback) {\n        // Implementation for getting market ticker data\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        // Implementation for getting order book for a currency pair\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        // Implementation for getting public trade history\n    }\n\n    myBalances(callback) {\n        // Implementation for getting user's account balances\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        // Implementation for getting user's open orders\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        // Implementation for getting user's trade history\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        // Implementation for placing a buy order\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        // Implementation for placing a sell order\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        // Implementation for canceling an order\n    }\n\n    withdraw(currency, amount, address, callback) {\n        // Implementation for withdrawing funds\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        // Implementation for formatting currency pairs\n    }\n}\n```",
      "```javascript\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n        this.STRICT_SSL = true;\n    }\n\n    _getPrivateHeaders(parameters) {\n        const timestamp = Math.floor(Date.now() / 1000);\n        const nonce = Math.floor(Math.random() * 1000000000);\n        const signature = this._sign(timestamp, nonce, parameters);\n        return {\n            'Content-Type': 'application/json',\n            'API-Key': this.key,\n            'Timestamp': timestamp,\n            'Nonce': nonce,\n            'Sign': signature\n        };\n    }\n\n    _request(options, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(new Error(xhr.statusText), null);\n                }\n            }\n        };\n        xhr.open(options.method, options.url, true);\n        for (const key in options.headers) {\n            xhr.setRequestHeader(key, options.headers[key]);\n        }\n        xhr.send(options.body ? JSON.stringify(options.body) : null);\n    }\n\n    _public(parameters, callback) {\n        const url = `${this.PUBLIC_API_URL}?method=${parameters.method}`;\n        const options = {\n            method: 'GET',\n            url: url,\n            headers: {\n                'User-Agent': this.USER_AGENT\n            }\n        };\n        this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        const url = `${this.PRIVATE_API_URL}?method=${parameters.method}`;\n        const headers = this._getPrivateHeaders(parameters);\n        const options = {\n            method: 'POST',\n            url: url,\n            headers: headers,\n            body: parameters\n        };\n        this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        this._public({ method: 'marketdata' }, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        this._public({ method: 'marketdata', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        this._public({ method: 'marketdata', pair: `${currencyA}_${currencyB}`, tradehistory: 'true' }, callback);\n    }\n\n    myBalances(callback) {\n        this._private({ method: 'balances' }, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        this._private({ method: 'openorders', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        this._private({ method: 'trades', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'buy', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount }, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'sell', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount }, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        this._private({ method: 'cancelorder', pair: `${currencyA}_${currencyB}`, orderid: orderNumber }, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        this._private({ method: 'withdraw', currency: currency, amount: amount, address: address }, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return `${currencyA}_${currencyB}`;\n    }\n\n    _sign(timestamp, nonce, parameters) {\n        const stringToSign = `${timestamp}${nonce}${JSON.stringify(parameters)}`;\n        return CryptoJS.HmacSHA512(stringToSign, this.secret).toString();\n    }\n}\n```",
      "class Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n        this.STRICT_SSL = true;\n    }\n\n    _getPrivateHeaders(parameters) {\n        // Implementation for generating private request headers\n    }\n\n    _request(options, callback) {\n        // Implementation for base request method\n    }\n\n    _public(parameters, callback) {\n        // Implementation for public API requests\n    }\n\n    _private(parameters, callback) {\n        // Implementation for private API requests\n    }\n\n    getTicker(callback) {\n        // Implementation for getting market ticker data\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        // Implementation for getting order book for a currency pair\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        // Implementation for getting public trade history\n    }\n\n    myBalances(callback) {\n        // Implementation for getting user's account balances\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        // Implementation for getting user's open orders\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        // Implementation for getting user's trade history\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        // Implementation for placing a buy order\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        // Implementation for placing a sell order\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        // Implementation for canceling an order\n    }\n\n    withdraw(currency, amount, address, callback) {\n        // Implementation for withdrawing funds\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        // Helper to format currency pairs\n    }\n}",
      "class Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n        this.STRICT_SSL = true;\n    }\n\n    _getPrivateHeaders(parameters) {\n        // Implementation for private headers\n    }\n\n    _request(options, callback) {\n        // Implementation for base request method\n    }\n\n    _public(parameters, callback) {\n        // Implementation for public API requests\n    }\n\n    _private(parameters, callback) {\n        // Implementation for private API requests\n    }\n\n    getTicker(callback) {\n        // Implementation for getting market ticker data\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        // Implementation for getting order book for a currency pair\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        // Implementation for getting public trade history\n    }\n\n    myBalances(callback) {\n        // Implementation for getting user's account balances\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        // Implementation for getting user's open orders\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        // Implementation for getting user's trade history\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        // Implementation for placing a buy order\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        // Implementation for placing a sell order\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        // Implementation for canceling an order\n    }\n\n    withdraw(currency, amount, address, callback) {\n        // Implementation for withdrawing funds\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        // Implementation for helper to format currency pairs\n    }\n}",
      "```javascript\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n        this.STRICT_SSL = true;\n    }\n\n    _getPrivateHeaders(parameters) {\n        const timestamp = Math.floor(Date.now() / 1000);\n        const nonce = Math.floor(Math.random() * 1000000000);\n        const signature = this._sign(timestamp, nonce, parameters);\n        return {\n            'Content-Type': 'application/json',\n            'API-Key': this.key,\n            'Timestamp': timestamp,\n            'Nonce': nonce,\n            'Sign': signature\n        };\n    }\n\n    _request(options, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(new Error(xhr.statusText), null);\n                }\n            }\n        };\n        xhr.open(options.method, options.url, true);\n        for (const key in options.headers) {\n            xhr.setRequestHeader(key, options.headers[key]);\n        }\n        xhr.send(options.body ? JSON.stringify(options.body) : null);\n    }\n\n    _public(parameters, callback) {\n        const url = `${this.PUBLIC_API_URL}?method=${parameters.method}`;\n        const options = {\n            method: 'GET',\n            url: url,\n            headers: {\n                'User-Agent': this.USER_AGENT\n            }\n        };\n        this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        const url = `${this.PRIVATE_API_URL}?method=${parameters.method}`;\n        const options = {\n            method: 'POST',\n            url: url,\n            headers: this._getPrivateHeaders(parameters),\n            body: parameters\n        };\n        this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        this._public({ method: 'marketdata' }, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        this._public({ method: 'marketdata', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        this._public({ method: 'marketdata', pair: `${currencyA}_${currencyB}`, tradehistory: 'true' }, callback);\n    }\n\n    myBalances(callback) {\n        this._private({ method: 'userdata', action: 'balances' }, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        this._private({ method: 'userdata', action: 'openorders', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        this._private({ method: 'userdata', action: 'trades', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'order', action: 'buy', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount }, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'order', action: 'sell', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount }, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        this._private({ method: 'order', action: 'cancel', pair: `${currencyA}_${currencyB}`, orderid: orderNumber }, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        this._private({ method: 'userdata', action: 'withdraw', currency: currency, amount: amount, address: address }, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return `${currencyA}_${currencyB}`;\n    }\n\n    _sign(timestamp, nonce, parameters) {\n        const stringToSign = `${timestamp}${nonce}${JSON.stringify(parameters)}${this.secret}`;\n        return CryptoJS.HmacSHA512(stringToSign, this.secret).toString();\n    }\n}\n```",
      "```javascript\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n        this.STRICT_SSL = true;\n    }\n\n    _getPrivateHeaders(parameters) {\n        const timestamp = Math.floor(Date.now() / 1000);\n        const nonce = Math.floor(Math.random() * 1000000000);\n        const signature = this._sign(timestamp, nonce, parameters);\n        return {\n            'Content-Type': 'application/json',\n            'API-Key': this.key,\n            'Timestamp': timestamp,\n            'Nonce': nonce,\n            'Sign': signature\n        };\n    }\n\n    _request(options, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status === 200) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(new Error(xhr.statusText), null);\n                }\n            }\n        };\n        xhr.open(options.method, options.url, true);\n        for (const key in options.headers) {\n            xhr.setRequestHeader(key, options.headers[key]);\n        }\n        xhr.send(options.body ? JSON.stringify(options.body) : null);\n    }\n\n    _public(parameters, callback) {\n        const url = `${this.PUBLIC_API_URL}?method=${parameters.method}`;\n        const options = {\n            method: 'GET',\n            url: url,\n            headers: {\n                'User-Agent': this.USER_AGENT\n            }\n        };\n        this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        const url = `${this.PRIVATE_API_URL}?method=${parameters.method}`;\n        const headers = this._getPrivateHeaders(parameters);\n        const options = {\n            method: 'POST',\n            url: url,\n            headers: headers,\n            body: parameters\n        };\n        this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        this._public({ method: 'marketdata' }, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        this._public({ method: 'marketdata', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        this._public({ method: 'marketdata', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    myBalances(callback) {\n        this._private({ method: 'balances' }, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        this._private({ method: 'openorders', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        this._private({ method: 'trades', pair: `${currencyA}_${currencyB}` }, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'buy', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount }, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'sell', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount }, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        this._private({ method: 'cancelorder', pair: `${currencyA}_${currencyB}`, orderid: orderNumber }, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        this._private({ method: 'withdraw', currency: currency, amount: amount, address: address }, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return `${currencyA}_${currencyB}`;\n    }\n\n    _sign(timestamp, nonce, parameters) {\n        const stringToSign = `${timestamp}${nonce}${JSON.stringify(parameters)}${this.secret}`;\n        return CryptoJS.HmacSHA512(stringToSign, this.secret).toString();\n    }\n}\n```",
      "```javascript\nclass Cryptsy {\n  constructor(key, secret) {\n    this.key = key;\n    this.secret = secret;\n    this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n    this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n    this.USER_AGENT = 'nomp/node-open-mining-portal';\n    this.STRICT_SSL = true;\n  }\n\n  _getPrivateHeaders(parameters) {\n    const timestamp = new Date().getTime();\n    const nonce = Math.floor(Math.random() * 10000000000000);\n    const signature = this._sign(timestamp, nonce, parameters);\n    return {\n      'User-Agent': this.USER_AGENT,\n      'Timestamp': timestamp,\n      'Nonce': nonce,\n      'Sign': signature\n    };\n  }\n\n  _request(options, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          callback(null, JSON.parse(xhr.responseText));\n        } else {\n          callback(new Error(xhr.statusText), null);\n        }\n      }\n    };\n    xhr.open(options.method, options.url, true);\n    for (const key in options.headers) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n    xhr.send(options.body);\n  }\n\n  _public(parameters, callback) {\n    const url = `${this.PUBLIC_API_URL}?method=${parameters.method}`;\n    const options = {\n      method: 'GET',\n      url: url,\n      headers: {}\n    };\n    this._request(options, callback);\n  }\n\n  _private(parameters, callback) {\n    const url = `${this.PRIVATE_API_URL}?method=${parameters.method}`;\n    const headers = this._getPrivateHeaders(parameters);\n    const options = {\n      method: 'POST',\n      url: url,\n      headers: headers,\n      body: JSON.stringify(parameters)\n    };\n    this._request(options, callback);\n  }\n\n  getTicker(callback) {\n    const parameters = { method: 'marketdata' };\n    this._public(parameters, callback);\n  }\n\n  getOrderBook(currencyA, currencyB, callback) {\n    const parameters = { method: 'marketdata', pair: `${currencyA}_${currencyB}` };\n    this._public(parameters, callback);\n  }\n\n  getTradeHistory(currencyA, currencyB, callback) {\n    const parameters = { method: 'marketdata', pair: `${currencyA}_${currencyB}` };\n    this._public(parameters, callback);\n  }\n\n  myBalances(callback) {\n    const parameters = { method: 'userdata', action: 'balances' };\n    this._private(parameters, callback);\n  }\n\n  myOpenOrders(currencyA, currencyB, callback) {\n    const parameters = { method: 'userdata', action: 'openorders', pair: `${currencyA}_${currencyB}` };\n    this._private(parameters, callback);\n  }\n\n  myTradeHistory(currencyA, currencyB, callback) {\n    const parameters = { method: 'userdata', action: 'trades', pair: `${currencyA}_${currencyB}` };\n    this._private(parameters, callback);\n  }\n\n  buy(currencyA, currencyB, rate, amount, callback) {\n    const parameters = { method: 'userdata', action: 'buy', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount };\n    this._private(parameters, callback);\n  }\n\n  sell(currencyA, currencyB, rate, amount, callback) {\n    const parameters = { method: 'userdata', action: 'sell', pair: `${currencyA}_${currencyB}`, rate: rate, amount: amount };\n    this._private(parameters, callback);\n  }\n\n  cancelOrder(currencyA, currencyB, orderNumber, callback) {\n    const parameters = { method: 'userdata', action: 'cancelorder', pair: `${currencyA}_${currencyB}`, orderid: orderNumber };\n    this._private(parameters, callback);\n  }\n\n  withdraw(currency, amount, address, callback) {\n    const parameters = { method: 'userdata', action: 'withdraw', currency: currency, amount: amount, address: address };\n    this._private(parameters, callback);\n  }\n\n  _joinCurrencies(currencyA, currencyB) {\n    return `${currencyA}_${currencyB}`;\n  }\n\n  _sign(timestamp, nonce, parameters) {\n    const stringToSign = `${timestamp}${nonce}${JSON.stringify(parameters)}${this.secret}`;\n    return CryptoJS.HmacSHA512(stringToSign, this.secret).toString();\n  }\n}\n```",
      "```javascript\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n        this.STRICT_SSL = true;\n    }\n\n    _getPrivateHeaders(parameters) {\n        const timestamp = Math.floor(Date.now() / 1000);\n        const nonce = Math.floor(Math.random() * 1000000000);\n        const parametersWithNonce = Object.assign({}, parameters, { nonce, timestamp });\n        const parametersString = Object.keys(parametersWithNonce).sort().map(key => `${key}=${encodeURIComponent(parametersWithNonce[key])}`).join('&');\n        const signature = CryptoJS.HmacSHA512(parametersString + this.secret, this.key).toString();\n        return {\n            'API-Key': this.key,\n            'Sign': signature,\n            'Nonce': nonce,\n            'Timestamp': timestamp,\n            'User-Agent': this.USER_AGENT\n        };\n    }\n\n    _request(options, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(new Error(xhr.statusText), null);\n                }\n            }\n        };\n        xhr.open(options.method, options.url, true);\n        xhr.setRequestHeader('User-Agent', this.USER_AGENT);\n        if (options.headers) {\n            Object.keys(options.headers).forEach(key => {\n                xhr.setRequestHeader(key, options.headers[key]);\n            });\n        }\n        xhr.send(options.body ? JSON.stringify(options.body) : null);\n    }\n\n    _public(parameters, callback) {\n        const url = this.PUBLIC_API_URL + '?' + Object.keys(parameters).map(key => `${key}=${encodeURIComponent(parameters[key])}`).join('&');\n        this._request({ url, method: 'GET' }, callback);\n    }\n\n    _private(parameters, callback) {\n        const headers = this._getPrivateHeaders(parameters);\n        const url = this.PRIVATE_API_URL + '?' + Object.keys(parameters).map(key => `${key}=${encodeURIComponent(parameters[key])}`).join('&');\n        this._request({ url, method: 'GET', headers }, callback);\n    }\n\n    getTicker(callback) {\n        this._public({ method: 'getmarketdata' }, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        this._public({ method: 'getmarketorderbook', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        this._public({ method: 'getmarkettrades', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n    }\n\n    myBalances(callback) {\n        this._private({ method: 'getbalances' }, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        this._private({ method: 'getopenorders', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        this._private({ method: 'gettrades', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'buy', marketid: this._joinCurrencies(currencyA, currencyB), rate, amount }, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        this._private({ method: 'sell', marketid: this._joinCurrencies(currencyA, currencyB), rate, amount }, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        this._private({ method: 'cancelorder', marketid: this._joinCurrencies(currencyA, currencyB), orderid: orderNumber }, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        this._private({ method: 'withdraw', currency, amount, address }, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return `${currencyA}_${currencyB}`;\n    }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a class that handles the downloading and installation of binary packages from a specified URL, including directory management and error handling.\n\nClass Description: The Binary class is responsible for downloading a binary package from a given URL, extracting it to a specified directory, and managing the installation process. It handles directory creation, file extraction, and provides feedback on the installation status.\n\nAttributes:\n- url: [String] - The URL from which the binary package will be downloaded.\n- name: [String] - The name of the binary package (optional, defaults to -1).\n- installDirectory: [String] - The base directory where the binary will be installed (optional, defaults to a 'bin' subdirectory in the current working directory).\n- binaryDirectory: [String] - The full path to the directory where the binary will be extracted (initialized as -1, set during installation).\n- binaryPath: [String] - The full path to the binary file (initialized as -1, not used in current implementation).\n\nMethods:\n- constructor(url, data) -> [None] - Initializes the Binary instance with the download URL and optional configuration data (name and installDirectory).\n- install() -> [Promise] - Handles the complete installation process including directory preparation, downloading, extraction, and cleanup. Returns a Promise that resolves when installation is complete or rejects on error.\n  - Internal method _getInstallDirectory() is used to determine the installation directory path.",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass Binary {\n    constructor(url, data) {\n        this.url = url;\n        this.name = data.name || -1;\n        this.installDirectory = data.installDirectory || join(__dirname, \"bin\");\n        this.binaryDirectory = -1;\n        this.binaryPath = -1;\n    }\n\n    install() {\n        const dir = this._getInstallDirectory();\n        if (!existsSync(dir)) {\n            mkdirSync(dir, { recursive: true });\n        }\n\n        this.binaryDirectory = join(dir, \"bin\");\n\n        if (existsSync(this.binaryDirectory)) {\n            rimraf.sync(this.binaryDirectory);\n        }\n\n        mkdirSync(this.binaryDirectory, { recursive: true });\n\n        console.log(`Downloading release from ${this.url}`);\n\n        return axios({ url: this.url, responseType: \"stream\" })\n            .then(res => {\n                const writer = tar.x({ strip: 1, C: this.binaryDirectory });\n\n                return new Promise((resolve, reject) => {\n                    res.data.pipe(writer);\n                    let error = null;\n                    writer.on('error', err => {\n                      error = err;\n                      reject(err);\n                    });\n                    writer.on('close', () => {\n                      if (!error) {\n                        resolve(true);\n                      }\n                    });\n                })\n            })\n            .then(() => {\n                console.log(\n                    `${this.name ? this.name : \"Your package\"} has been installed!`\n                );\n            })\n            .catch(e => {\n                error(`Error fetching release: ${e.message}`);\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport os\nimport urllib.request\nimport zipfile\nimport shutil\nimport promise\n\nclass Binary:\n    def __init__(self, url, name=None, installDirectory=None):\n        self.url = url\n        self.name = name if name else \"binary\"\n        self.installDirectory = installDirectory if installDirectory else os.path.join(os.getcwd(), \"bin\")\n        self.binaryDirectory = None\n        self.binaryPath = None\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def install(self):\n        return promise.resolve().then(() => {\n            self.binaryDirectory = self._getInstallDirectory()\n            return urllib.request.urlretrieve(self.url, os.path.join(self.binaryDirectory, self.name + \".zip\"))\n        }).then(() => {\n            with zipfile.ZipFile(os.path.join(self.binaryDirectory, self.name + \".zip\"), \"r\") as zip_ref:\n                zip_ref.extractall(self.binaryDirectory)\n            self.binaryPath = os.path.join(self.binaryDirectory, self.name)\n            return promise.resolve()\n        }).then(() => {\n            shutil.rmtree(os.path.join(self.binaryDirectory, self.name + \".zip\"))\n            return promise.resolve()\n        }).catch((error) => {\n            return promise.reject(error)\n        })\n```",
      "```python\nimport os\nimport zipfile\nimport requests\nimport shutil\nimport tempfile\n\nclass Binary:\n    def __init__(self, url, name=None, installDirectory=None):\n        self.url = url\n        self.name = name if name else \"binary\"\n        self.installDirectory = installDirectory if installDirectory else os.path.join(os.getcwd(), \"bin\")\n        self.binaryDirectory = None\n        self.binaryPath = None\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def install(self):\n        return new Promise((resolve, reject) => {\n            const installDir = this._getInstallDirectory();\n            const tempDir = tempfile.mkdtemp();\n            const binaryPath = os.path.join(tempDir, self.name);\n            const installPath = os.path.join(installDir, self.name);\n\n            const download = () => {\n                const req = new XMLHttpRequest();\n                req.open(\"GET\", this.url, true);\n                req.responseType = \"blob\";\n                req.onload = () => {\n                    if (req.status === 200) {\n                        const blob = new Blob([req.response], {type: \"application/octet-stream\"});\n                        const zip = new zip.File(blob);\n                        zip.extractAllTo(tempDir, true);\n                        this.binaryDirectory = tempDir;\n                        this.binaryPath = binaryPath;\n                        resolve();\n                    } else {\n                        reject(new Error(\"Failed to download binary\"));\n                    }\n                };\n                req.onerror = () => reject(new Error(\"Network error\"));\n                req.send();\n            };\n\n            const cleanup = () => {\n                if (os.path.exists(tempDir)) {\n                    shutil.rmtree(tempDir);\n                }\n            };\n\n            download().then(() => {\n                if (os.path.exists(installPath)) {\n                    os.remove(installPath);\n                }\n                shutil.move(binaryPath, installPath);\n                cleanup();\n            }).catch(reject);\n        });\n    }\n```",
      "```python\nimport os\nimport zipfile\nimport requests\nimport shutil\nimport tempfile\n\nclass Binary:\n    def __init__(self, url, name=None, installDirectory=None):\n        self.url = url\n        self.name = name if name else \"binary\"\n        self.installDirectory = installDirectory if installDirectory else os.path.join(os.getcwd(), \"bin\")\n        self.binaryDirectory = None\n        self.binaryPath = None\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def install(self):\n        return new Promise((resolve, reject) => {\n            const installDir = this._getInstallDirectory();\n            const tempDir = tempfile.mkdtemp();\n            const binaryPath = os.path.join(tempDir, self.name);\n            const downloadUrl = this.url;\n\n            const download = () => {\n                const req = http.get(downloadUrl);\n                req.on('error', (err) => {\n                    reject(err);\n                });\n                req.on('end', () => {\n                    const zip = new zipfile.ZipFile(binaryPath);\n                    zip.extractall(tempDir);\n                    zip.close();\n                    this.binaryDirectory = tempDir;\n                    this.binaryPath = os.path.join(tempDir, self.name);\n                    resolve();\n                });\n            };\n\n            const cleanup = () => {\n                if (os.path.exists(tempDir)) {\n                    shutil.rmtree(tempDir);\n                }\n            };\n\n            download().then(() => {\n                cleanup();\n            }).catch((err) => {\n                reject(err);\n            });\n        });\n    }\n```",
      "```python\nimport os\nimport zipfile\nimport requests\nimport shutil\nimport tempfile\n\nclass Binary:\n    def __init__(self, url, name=None, installDirectory=None):\n        self.url = url\n        self.name = name if name else \"binary\"\n        self.installDirectory = installDirectory if installDirectory else os.path.join(os.getcwd(), \"bin\")\n        self.binaryDirectory = None\n        self.binaryPath = None\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def install(self):\n        return new Promise((resolve, reject) => {\n            self.binaryDirectory = self._getInstallDirectory()\n            const tempDir = tempfile.mkdtemp()\n            const zipPath = os.path.join(tempDir, self.name + \".zip\")\n            const binaryPath = os.path.join(tempDir, self.name)\n\n            const download = () => {\n                return requests.get(this.url).then(response => {\n                    if (response.status_code === 200) {\n                        return response.content;\n                    } else {\n                        throw new Error(\"Failed to download binary package\");\n                    }\n                });\n            };\n\n            const extract = (content) => {\n                const zip = new zipfile.ZipFile(content);\n                zip.extractall(tempDir);\n                return zip.testzip();\n            };\n\n            const install = () => {\n                if (os.path.exists(binaryPath)) {\n                    const targetPath = os.path.join(self.binaryDirectory, self.name);\n                    shutil.move(binaryPath, targetPath);\n                    this.binaryPath = targetPath;\n                    resolve(\"Installation complete\");\n                } else {\n                    reject(new Error(\"Binary file not found after extraction\"));\n                }\n            };\n\n            download().then(content => extract(content)).then(() => install()).catch(error => {\n                reject(error);\n                if (os.path.exists(tempDir)) {\n                    shutil.rmtree(tempDir);\n                }\n            });\n        });\n    }\n```",
      "```python\nimport os\nimport zipfile\nimport requests\nimport shutil\nimport tempfile\n\nclass Binary:\n    def __init__(self, url, name=None, installDirectory=None):\n        self.url = url\n        self.name = name if name else \"binary\"\n        self.installDirectory = installDirectory if installDirectory else os.path.join(os.getcwd(), \"bin\")\n        self.binaryDirectory = None\n        self.binaryPath = None\n\n    def install(self):\n        return self._getInstallDirectory().then(self._download).then(self._extract).then(self._cleanup)\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return Promise.resolve(self.installDirectory)\n\n    def _download(self, installDirectory):\n        tempDir = tempfile.mkdtemp()\n        response = requests.get(self.url, stream=True)\n        if response.status_code == 200:\n            zipPath = os.path.join(tempDir, self.name + \".zip\")\n            with open(zipPath, 'wb') as f:\n                for chunk in response.iter_content(chunk_size=8192):\n                    f.write(chunk)\n            self.binaryDirectory = os.path.join(installDirectory, self.name)\n            return Promise.resolve(zipPath)\n        else:\n            return Promise.reject(\"Failed to download binary package.\")\n\n    def _extract(self, zipPath):\n        with zipfile.ZipFile(zipPath, 'r') as zip_ref:\n            zip_ref.extractall(self.binaryDirectory)\n        self.binaryPath = os.path.join(self.binaryDirectory, self.name)\n        return Promise.resolve(self.binaryPath)\n\n    def _cleanup(self, binaryPath):\n        shutil.rmtree(tempfile.mkdtemp())\n        return Promise.resolve(\"Installation complete.\")\n```",
      "```python\nimport os\nimport urllib.request\nimport zipfile\nimport shutil\nimport tempfile\n\nclass Binary:\n    def __init__(self, url, name=None, installDirectory=None):\n        self.url = url\n        self.name = name if name else \"binary\"\n        self.installDirectory = installDirectory if installDirectory else os.path.join(os.getcwd(), \"bin\")\n        self.binaryDirectory = None\n        self.binaryPath = None\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def install(self):\n        return new Promise((resolve, reject) => {\n            const installDir = this._getInstallDirectory();\n            const tempDir = tempfile.mkdtemp();\n            const downloadPath = os.path.join(tempDir, self.name);\n            const binaryPath = os.path.join(installDir, self.name);\n\n            urllib.request.urlretrieve(this.url, downloadPath);\n            try {\n                with zipfile.ZipFile(downloadPath, 'r') as zip_ref:\n                    zip_ref.extractall(tempDir);\n                shutil.move(os.path.join(tempDir, self.name), binaryPath);\n                this.binaryDirectory = installDir;\n                this.binaryPath = binaryPath;\n                resolve(\"Installation complete.\");\n            } catch (error) {\n                reject(\"Installation failed: \" + error.message);\n            } finally {\n                shutil.rmtree(tempDir);\n            }\n        });\n    }\n```",
      "```python\nimport os\nimport shutil\nimport tarfile\nimport urllib.request\nimport tempfile\nfrom promise import Promise\n\nclass Binary:\n    def __init__(self, url, data=None):\n        self.url = url\n        self.name = data.get('name', '-1')\n        self.installDirectory = data.get('installDirectory', os.path.join(os.getcwd(), 'bin'))\n        self.binaryDirectory = '-1'\n        self.binaryPath = '-1'\n\n    def install(self):\n        return Promise.resolve().then(self._getInstallDirectory).then(self._download).then(self._extract).then(self._cleanup).catch(self._handleError)\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def _download(self):\n        tempDir = tempfile.mkdtemp()\n        tempFilePath = os.path.join(tempDir, self.name)\n        try:\n            urllib.request.urlretrieve(self.url, tempFilePath)\n        except Exception as e:\n            return Promise.reject(e)\n        return tempFilePath\n\n    def _extract(self, tempFilePath):\n        self.binaryDirectory = os.path.join(self.installDirectory, self.name)\n        try:\n            with tarfile.open(tempFilePath, 'r') as tar:\n                tar.extractall(path=self.binaryDirectory)\n        except Exception as e:\n            return Promise.reject(e)\n        return self.binaryDirectory\n\n    def _cleanup(self):\n        shutil.rmtree(tempfile.gettempdir())\n\n    def _handleError(self, error):\n        return Promise.reject(error)\n```",
      "```python\nimport os\nimport zipfile\nimport requests\nimport shutil\nimport tempfile\n\nclass Binary:\n    def __init__(self, url, name=None, installDirectory=None):\n        self.url = url\n        self.name = name if name else \"binary\"\n        self.installDirectory = installDirectory if installDirectory else os.path.join(os.getcwd(), \"bin\")\n        self.binaryDirectory = None\n        self.binaryPath = None\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def install(self):\n        return new Promise((resolve, reject) => {\n            const installDir = this._getInstallDirectory();\n            const tempDir = tempfile.mkdtemp();\n            const binaryPath = os.path.join(tempDir, self.name);\n\n            const download = () => {\n                return new Promise((resolve, reject) => {\n                    const response = requests.get(this.url);\n                    if (response.status_code === 200) {\n                        response.content.saveAs(binaryPath);\n                        resolve();\n                    } else {\n                        reject(new Error(\"Failed to download binary\"));\n                    }\n                });\n            };\n\n            const extract = () => {\n                return new Promise((resolve, reject) => {\n                    const zip = new zipfile.ZipFile(binaryPath);\n                    zip.extractAllTo(tempDir);\n                    zip.close();\n                    resolve();\n                });\n            };\n\n            const cleanup = () => {\n                if (os.path.exists(binaryPath)) {\n                    os.remove(binaryPath);\n                }\n                if (os.path.exists(tempDir)) {\n                    shutil.rmtree(tempDir);\n                }\n            };\n\n            download().then(() => extract()).then(() => {\n                this.binaryDirectory = tempDir;\n                this.binaryPath = os.path.join(tempDir, self.name);\n                resolve();\n            }).catch((error) => {\n                cleanup();\n                reject(error);\n            });\n        });\n    };\n```",
      "```python\nimport os\nimport urllib.request\nimport zipfile\nimport shutil\nimport tempfile\nimport promise\n\nclass Binary:\n    def __init__(self, url, data=None):\n        self.url = url\n        self.name = data.get('name', '-1')\n        self.installDirectory = data.get('installDirectory', os.path.join(os.getcwd(), 'bin'))\n        self.binaryDirectory = '-1'\n        self.binaryPath = '-1'\n\n    def install(self):\n        return promise.resolve(self._getInstallDirectory()).then(self._download).then(self._extract).then(self._cleanup)\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def _download(self, installDirectory):\n        tempDir = tempfile.mkdtemp()\n        tempFilePath = os.path.join(tempDir, self.name)\n        try:\n            urllib.request.urlretrieve(self.url, tempFilePath)\n        except Exception as e:\n            shutil.rmtree(tempDir)\n            raise e\n        return tempFilePath\n\n    def _extract(self, tempFilePath):\n        self.binaryDirectory = os.path.join(self.installDirectory, self.name)\n        with zipfile.ZipFile(tempFilePath, 'r') as zip_ref:\n            zip_ref.extractall(self.binaryDirectory)\n        self.binaryPath = os.path.join(self.binaryDirectory, 'binary')\n        return self.binaryPath\n\n    def _cleanup(self, binaryPath):\n        shutil.rmtree(tempfile.gettempdir())\n```",
      "```python\nimport os\nimport urllib.request\nimport zipfile\nimport shutil\nimport promise\n\nclass Binary:\n    def __init__(self, url, name=None, installDirectory=None):\n        self.url = url\n        self.name = name if name else \"binary\"\n        self.installDirectory = installDirectory if installDirectory else os.path.join(os.getcwd(), \"bin\")\n        self.binaryDirectory = None\n        self.binaryPath = None\n\n    def _getInstallDirectory(self):\n        if not os.path.exists(self.installDirectory):\n            os.makedirs(self.installDirectory)\n        return self.installDirectory\n\n    def install(self):\n        return promise.resolve().then(() => {\n            self.binaryDirectory = self._getInstallDirectory()\n            return urllib.request.urlretrieve(self.url, os.path.join(self.binaryDirectory, self.name + \".zip\"))\n        }).then(() => {\n            with zipfile.ZipFile(os.path.join(self.binaryDirectory, self.name + \".zip\"), \"r\") as zip_ref:\n                zip_ref.extractall(self.binaryDirectory)\n            self.binaryPath = os.path.join(self.binaryDirectory, self.name)\n            return promise.resolve()\n        }).then(() => {\n            shutil.rmtree(os.path.join(self.binaryDirectory, self.name + \".zip\"))\n            return promise.resolve()\n        }).catch((error) => {\n            return promise.reject(error)\n        })\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    ws.send(JSON.stringify({ type: 'hello', message: 'Hello WebSocket Server!' }));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Received message:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed:', event);\n  };\n\n  return () => {\n    ws.close();\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    const message = { type: 'greeting', content: 'Hello, WebSocket server!' };\n    ws.send(JSON.stringify(message));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed:', event);\n  };\n\n  return () => {\n    ws.close();\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    const message = { type: 'hello', content: 'Hello, server!' };\n    ws.send(JSON.stringify(message));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed:', event);\n  };\n\n  return () => {\n    ws.close();\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    ws.send(JSON.stringify({ type: 'HELLO', message: 'Hello, WebSocket server!' }));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Received message:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  return () => {\n    ws.close();\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    const message = { type: 'init', data: 'Hello WebSocket Server' };\n    ws.send(JSON.stringify(message));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    ws.send(JSON.stringify({ type: 'hello', message: 'Hello, server!' }));\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    console.log('Received:', data);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed:', event);\n  };\n\n  return () => {\n    ws.close();\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    ws.send(JSON.stringify({ type: 'hello', message: 'Hello, server!' }));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    const message = { type: 'greeting', content: 'Hello, server!' };\n    ws.send(JSON.stringify(message));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    const message = { type: 'hello', content: 'Hello, server!' };\n    ws.send(JSON.stringify(message));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed:', event);\n  };\n\n  return () => {\n    ws.close();\n  };\n};\n```",
      "```javascript\nconst testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    const message = { type: 'hello', content: 'Hello, WebSocket server!' };\n    ws.send(JSON.stringify(message));\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', JSON.parse(event.data));\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed:', event);\n  };\n\n  return () => {\n    ws.close();\n  };\n};\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript using Node.js that establishes a connection to a WebSocket server, handles incoming messages, and manages connection events.\n\nClass Description: The WebSocketImpl class provides a wrapper around the Node.js 'ws' library to create and manage WebSocket connections. It handles connection establishment, message reception, error handling, and connection closure events. The class also provides methods for sending data and closing the connection.\n\nAttributes:\n- _globalObject: [Object] - The global context in which the WebSocket operates\n- _ownerDocument: [Object] - The document object associated with the WebSocket\n- _urlRecord: [Object] - Parsed URL information for the WebSocket connection\n- url: [String] - The WebSocket server URL as a string\n- _ws: [WebSocket|null] - The underlying WebSocket instance or null if not connected\n- _readyState: [Number] - Current connection state (0 = CONNECTING)\n- _requiredToFail: [Boolean] - Flag indicating if the connection should fail\n- bufferedAmount: [Number] - Amount of buffered data in bytes\n- _sendQueue: [Array] - Queue of messages waiting to be sent\n\nMethods:\n- constructor(globalObject, args, privateData) -> [void] - Initializes the WebSocket connection with the given parameters and sets up event handlers\n- _onConnectionEstablished() -> [void] - Internal method called when the WebSocket connection is successfully established\n- _onMessageReceived(data, isBinary) -> [void] - Internal method called when a message is received from the server\n- _onConnectionClosed(code, reason) -> [void] - Internal method called when the WebSocket connection is closed\n- close(code, reason) -> [void] - Closes the WebSocket connection with optional code and reason\n- send(data) -> [void] - Sends data through the WebSocket connection (supports strings and Blob objects)\n- get readyState() -> [Number] - Returns the current ready state of the WebSocket connection",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = idlUtils.implForWrapper(globalObject._document);\n    this._urlRecord = parseURL(args[0]);\n    this.url = serializeURL(this._urlRecord);\n    this._ws = null;\n    this._readyState = 0; // CONNECTING\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    const protocols = typeof args[1] === \"string\" ? [args[1]] : (args[1] || []);\n    const nodeParsedURL = nodeURL.parse(this.url);\n\n    this._ws = new WebSocket(this.url, protocols, {\n      headers: {\n        \"user-agent\": globalObject.navigator.userAgent,\n        \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n        \"origin\": globalObject._origin\n      },\n      rejectUnauthorized: globalObject._resourceLoader._strictSSL\n    });\n\n    this._ws.once(\"open\", () => {\n      this._onConnectionEstablished();\n    });\n    this._ws.on(\"message\", this._onMessageReceived.bind(this));\n    this._ws.once(\"close\", (...closeArgs) => {\n      this._onConnectionClosed(...closeArgs);\n    });\n    this._ws.once(\"error\", () => {\n      this._requiredToFail = true;\n    });\n  }\n\n  _onConnectionEstablished() {\n    fireAnEvent(\"open\", this);\n  }\n\n  _onMessageReceived(data, isBinary) {\n    let dataForEvent;\n    if (!isBinary) {\n      dataForEvent = data.toString();\n    } else if (this.binaryType === \"arraybuffer\") {\n      dataForEvent = copyToArrayBufferInNewRealm(data, this._globalObject);\n    } else {\n      dataForEvent = Blob.create(this._globalObject, [[data], { type: \"\" }]);\n    }\n    fireAnEvent(\"message\", this, MessageEvent, {\n      data: dataForEvent,\n      origin: serializeURLOrigin(this._urlRecord)\n    });\n  }\n\n  _onConnectionClosed(code, reason) {\n    fireAnEvent(\"close\", this, CloseEvent, {\n      wasClean: !this._requiredToFail,\n      code,\n      reason: reason.toString()\n    });\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN) {\n      if (Blob.isImpl(data)) {\n        data = data._buffer;\n      }\n      this._ws.send(data, { binary: typeof data !== \"string\" });\n    }\n  }\n\n  get readyState() {\n    return this._ws ? this._ws.readyState : this._readyState;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "matched_results": [
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.OPENING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._initializeConnection();\n  }\n\n  _initializeConnection() {\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._handleError(error));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      this.send(this._sendQueue.shift());\n    }\n  }\n\n  _handleError(error) {\n    // Handle error\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.CONNECTING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._initializeConnection();\n  }\n\n  _initializeConnection() {\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._handleError(error));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      this.send(this._sendQueue.shift());\n    }\n  }\n\n  _handleError(error) {\n    // Handle error\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => {\n      this._requiredToFail = true;\n      this._readyState = WebSocket.CLOSED;\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.OPENING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._initializeConnection();\n  }\n\n  _initializeConnection() {\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._handleError(error));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      this.send(this._sendQueue.shift());\n    }\n  }\n\n  _handleError(error) {\n    // Handle error\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.OPEN;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._onConnectionClosed(1006, error.message));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._sendQueue.forEach(message => this.send(message));\n    this._sendQueue = [];\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle close\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.CONNECTING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._initializeConnection();\n  }\n\n  _initializeConnection() {\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._handleError(error));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      this.send(this._sendQueue.shift());\n    }\n  }\n\n  _handleError(error) {\n    // Handle error\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.OPENING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._initializeConnection();\n  }\n\n  _initializeConnection() {\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._handleError(error));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      this.send(this._sendQueue.shift());\n    }\n  }\n\n  _handleError(error) {\n    // Handle error\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.OPENING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._initializeConnection();\n  }\n\n  _initializeConnection() {\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._handleError(error));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      this.send(this._sendQueue.shift());\n    }\n  }\n\n  _handleError(error) {\n    // Handle error\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.OPENING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._initializeConnection();\n  }\n\n  _initializeConnection() {\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._handleError(error));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      this.send(this._sendQueue.shift());\n    }\n  }\n\n  _handleError(error) {\n    // Handle error\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args.url;\n    this._ws = null;\n    this._readyState = WebSocket.OPENING;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._initializeConnection();\n  }\n\n  _initializeConnection() {\n    this._ws = new WebSocket(this.url);\n    this._ws.on('open', () => this._onConnectionEstablished());\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (error) => this._handleError(error));\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = WebSocket.OPEN;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = WebSocket.CLOSED;\n    // Handle closure\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === WebSocket.OPEN) {\n      this._ws.send(data);\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0 && this._readyState === WebSocket.OPEN) {\n      this.send(this._sendQueue.shift());\n    }\n  }\n\n  _handleError(error) {\n    // Handle error\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Implement a ReconnectingWebSocket class in JavaScript that provides a WebSocket client with automatic reconnection capabilities, customizable reconnection strategies, and event handling for connection states, messages, and errors.\n\nClass Description: The ReconnectingWebSocket class extends basic WebSocket functionality by automatically reconnecting when the connection is lost, with configurable reconnection intervals and exponential backoff. It provides event handlers for connection states (open, close, connecting), message reception, and errors.\n\nAttributes:\n- debug: Boolean - Enables debug logging when true\n- automaticOpen: Boolean - Automatically opens connection when instantiated if true\n- reconnectInterval: Number - Initial delay before reconnection attempt (ms)\n- maxReconnectInterval: Number - Maximum delay between reconnection attempts (ms)\n- reconnectDecay: Number - Multiplier for increasing reconnect delay\n- timeoutInterval: Number - Connection timeout duration (ms)\n- url: String - WebSocket server URL\n- reconnectAttempts: Number - Count of reconnection attempts\n- readyState: Number - Current connection state (matching WebSocket constants)\n- protocol: String|null - Selected subprotocol\n\nMethods:\n- constructor(url, protocols, options) -> ReconnectingWebSocket - Initializes the WebSocket connection with specified URL, optional subprotocols, and configuration options\n- addEventListener(type, listener) -> void - Adds event listener for WebSocket events\n- removeEventListener(type, listener) -> void - Removes event listener\n- dispatchEvent(event) -> void - Dispatches custom event\n- open(wasReconnect) -> void - Opens WebSocket connection (internal use)\n- send(data) -> void - Sends data through WebSocket connection\n- close(code, reason) -> void - Closes WebSocket connection and stops reconnection attempts\n- refresh() -> void - Forces reconnection by closing current connection\n- createEvent(eventName, detail) -> CustomEvent - Creates custom event object\n- onopen(event) -> void - Placeholder for open event handler\n- onclose(event) -> void - Placeholder for close event handler\n- onconnecting(event) -> void - Placeholder for connecting event handler\n- onmessage(event) -> void - Placeholder for message event handler\n- onerror(event) -> void - Placeholder for error event handler",
    "Canonical_solution": "class ReconnectingWebSocket {\n    constructor(url, protocols, options) {\n        this.debug = false;\n        this.automaticOpen = true;\n        this.reconnectInterval = 1000;\n        this.maxReconnectInterval = 30000;\n        this.reconnectDecay = 1.5;\n        this.timeoutInterval = 2000;\n        \n        if (options) {\n            for (var key in options) {\n                this[key] = options[key];\n            }\n        }\n        \n        this.url = url;\n        this.reconnectAttempts = 0;\n        this.readyState = WebSocket.CONNECTING;\n        this.protocol = null;\n        \n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n        \n        eventTarget.addEventListener('open', (event) => { this.onopen(event); });\n        eventTarget.addEventListener('close', (event) => { this.onclose(event); });\n        eventTarget.addEventListener('connecting', (event) => { this.onconnecting(event); });\n        eventTarget.addEventListener('message', (event) => { this.onmessage(event); });\n        eventTarget.addEventListener('error', (event) => { this.onerror(event); });\n        \n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n        \n        this.open = function(wasReconnect) {\n            var ws = new WebSocket(this.url, protocols || []);\n            if (!wasReconnect) {\n                eventTarget.dispatchEvent(this.createEvent('connecting'));\n            }\n            \n            var timeout = setTimeout(() => {\n                timedOut = true;\n                ws.close();\n                timedOut = false;\n            }, this.timeoutInterval);\n            \n            ws.onopen = () => {\n                clearTimeout(timeout);\n                this.protocol = ws.protocol;\n                this.readyState = WebSocket.OPEN;\n                this.reconnectAttempts = 0;\n                var event = this.createEvent('open');\n                event.isReconnect = wasReconnect;\n                wasReconnect = false;\n                eventTarget.dispatchEvent(event);\n            };\n            \n            ws.onclose = (event) => {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    this.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(this.createEvent('close'));\n                } else {\n                    this.readyState = WebSocket.CONNECTING;\n                    var connectingEvent = this.createEvent('connecting');\n                    connectingEvent.code = event.code;\n                    connectingEvent.reason = event.reason;\n                    connectingEvent.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(connectingEvent);\n                    \n                    if (!wasReconnect && !timedOut) {\n                        eventTarget.dispatchEvent(this.createEvent('close'));\n                    }\n                    \n                    var reconnectTimeout = this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts);\n                    setTimeout(() => {\n                        this.reconnectAttempts++;\n                        this.open(true);\n                    }, Math.min(reconnectTimeout, this.maxReconnectInterval));\n                }\n            };\n            \n            ws.onmessage = (event) => {\n                var messageEvent = this.createEvent('message');\n                messageEvent.data = event.data;\n                eventTarget.dispatchEvent(messageEvent);\n            };\n            \n            ws.onerror = (event) => {\n                eventTarget.dispatchEvent(this.createEvent('error'));\n            };\n        };\n        \n        if (this.automaticOpen) {\n            this.open(false);\n        }\n        \n        this.send = function(data) {\n            if (ws) {\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n        \n        this.close = function(code, reason) {\n            forcedClose = true;\n            if (ws) {\n                ws.close(code || 1000, reason);\n            }\n        };\n        \n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n    \n    createEvent(eventName, detail) {\n        var event = document.createEvent('CustomEvent');\n        event.initCustomEvent(eventName, false, false, detail);\n        return event;\n    }\n    \n    onopen(event) {}\n    onclose(event) {}\n    onconnecting(event) {}\n    onmessage(event) {}\n    onerror(event) {}\n}\n\nReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\nReconnectingWebSocket.OPEN = WebSocket.OPEN;\nReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\nReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\nReconnectingWebSocket.debugAll = false;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 20000;\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.eventListeners = {};\n\n    this.addEventListener('open', this.onopen);\n    this.addEventListener('close', this.onclose);\n    this.addEventListener('connecting', this.onconnecting);\n    this.addEventListener('message', this.onmessage);\n    this.addEventListener('error', this.onerror);\n\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  addEventListener(type, listener) {\n    if (!this.eventListeners[type]) {\n      this.eventListeners[type] = [];\n    }\n    this.eventListeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.eventListeners[type]) {\n      const index = this.eventListeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.eventListeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.eventListeners[event.type]) {\n      this.eventListeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(wasReconnect) {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.readyState = WebSocket.CONNECTING;\n    this.reconnectAttempts = 0;\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = (event) => {\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this.ws.protocol;\n      this.reconnectAttempts = 0;\n      this.dispatchEvent(new CustomEvent('open', { detail: { wasReconnect } }));\n      this.dispatchEvent(new CustomEvent('connecting', { detail: { wasReconnect } }));\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new CustomEvent('close', { detail: { wasReconnect } }));\n      this.scheduleReconnect();\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent(new CustomEvent('message', { detail: { data: event.data } }));\n    };\n    this.ws.onerror = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new CustomEvent('error', { detail: { event } }));\n      this.scheduleReconnect();\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent(new CustomEvent('error', { detail: { message: 'WebSocket is not open' } }));\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n    this.readyState = WebSocket.CLOSED;\n    this.reconnectAttempts = 0;\n  }\n\n  refresh() {\n    this.close(1000, 'refresh');\n    this.open(false);\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {}\n\n  onclose(event) {}\n\n  onconnecting(event) {}\n\n  onmessage(event) {}\n\n  onerror(event) {}\n\n  scheduleReconnect() {\n    if (this.readyState === WebSocket.CLOSED) {\n      setTimeout(() => {\n        this.reconnectAttempts++;\n        const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n        this.open(true);\n      }, this.reconnectInterval);\n    }\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 20000;\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.eventListeners = {};\n\n    this.addEventListener('open', this.onopen);\n    this.addEventListener('close', this.onclose);\n    this.addEventListener('connecting', this.onconnecting);\n    this.addEventListener('message', this.onmessage);\n    this.addEventListener('error', this.onerror);\n\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  addEventListener(type, listener) {\n    if (!this.eventListeners[type]) {\n      this.eventListeners[type] = [];\n    }\n    this.eventListeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.eventListeners[type]) {\n      const index = this.eventListeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.eventListeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.eventListeners[event.type]) {\n      this.eventListeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(wasReconnect) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      return;\n    }\n    this.readyState = WebSocket.CONNECTING;\n    this.reconnectAttempts++;\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = 'blob';\n    this.ws.onopen = (event) => {\n      this.readyState = WebSocket.OPEN;\n      this.reconnectAttempts = 0;\n      this.dispatchEvent(new CustomEvent('open', { detail: event }));\n      if (wasReconnect) {\n        this.dispatchEvent(new CustomEvent('reconnect', { detail: event }));\n      }\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new CustomEvent('close', { detail: event }));\n      if (this.reconnectAttempts < 10) {\n        setTimeout(() => {\n          this.open(true);\n        }, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n      }\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent(new CustomEvent('message', { detail: event }));\n    };\n    this.ws.onerror = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new CustomEvent('error', { detail: event }));\n    };\n  }\n\n  send(data) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n    this.readyState = WebSocket.CLOSED;\n    this.reconnectAttempts = 0;\n  }\n\n  refresh() {\n    this.close(1000, 'refresh');\n    this.open(false);\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {}\n\n  onclose(event) {}\n\n  onconnecting(event) {}\n\n  onmessage(event) {}\n\n  onerror(event) {}\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 20000;\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.eventListeners = {};\n    this.initWebSocket();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.eventListeners[type]) {\n      this.eventListeners[type] = [];\n    }\n    this.eventListeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.eventListeners[type]) {\n      this.eventListeners[type] = this.eventListeners[type].filter(l => l !== listener);\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.eventListeners[event.type]) {\n      this.eventListeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(wasReconnect) {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = 'blob';\n    this.ws.onopen = this.onopen.bind(this);\n    this.ws.onclose = this.onclose.bind(this);\n    this.ws.onmessage = this.onmessage.bind(this);\n    this.ws.onerror = this.onerror.bind(this);\n    this.readyState = WebSocket.OPEN;\n    if (wasReconnect) {\n      this.dispatchEvent(this.createEvent('reconnect', { url: this.url }));\n    } else {\n      this.dispatchEvent(this.createEvent('open', { url: this.url }));\n    }\n    if (this.timeoutInterval) {\n      this.ws.ontimeout = () => {\n        this.ws.close();\n      };\n    }\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent(this.createEvent('error', { message: 'WebSocket is not open', data: data }));\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n    this.readyState = WebSocket.CLOSED;\n    this.reconnectAttempts = 0;\n    this.dispatchEvent(this.createEvent('close', { code, reason }));\n  }\n\n  refresh() {\n    this.close(1000, 'refresh');\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {\n    this.readyState = WebSocket.OPEN;\n    this.reconnectAttempts = 0;\n    this.dispatchEvent(this.createEvent('open', { url: this.url }));\n    if (this.automaticOpen) {\n      this.automaticOpen = false;\n    }\n  }\n\n  onclose(event) {\n    this.readyState = WebSocket.CLOSED;\n    this.dispatchEvent(this.createEvent('close', { code: event.code, reason: event.reason }));\n    if (this.reconnectInterval) {\n      setTimeout(() => {\n        this.reconnectAttempts++;\n        const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n        this.open(true);\n      }, this.reconnectInterval);\n    }\n  }\n\n  onconnecting(event) {\n    this.readyState = WebSocket.CONNECTING;\n    this.dispatchEvent(this.createEvent('connecting', { url: this.url }));\n  }\n\n  onmessage(event) {\n    this.dispatchEvent(this.createEvent('message', { data: event.data }));\n  }\n\n  onerror(event) {\n    this.readyState = WebSocket.CLOSED;\n    this.dispatchEvent(this.createEvent('error', { message: event.message, data: event.data }));\n  }\n\n  initWebSocket() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n    constructor(url, protocols, options) {\n        this.debug = options.debug || false;\n        this.automaticOpen = options.automaticOpen || false;\n        this.reconnectInterval = options.reconnectInterval || 1000;\n        this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n        this.reconnectDecay = options.reconnectDecay || 1.5;\n        this.timeoutInterval = options.timeoutInterval || 20000;\n        this.url = url;\n        this.protocols = protocols;\n        this.reconnectAttempts = 0;\n        this.readyState = WebSocket.CLOSED;\n        this.protocol = null;\n        this.ws = null;\n        this.eventListeners = {};\n\n        this.addEventListener('open', this.onopen);\n        this.addEventListener('close', this.onclose);\n        this.addEventListener('connecting', this.onconnecting);\n        this.addEventListener('message', this.onmessage);\n        this.addEventListener('error', this.onerror);\n\n        if (this.automaticOpen) {\n            this.open(false);\n        }\n    }\n\n    addEventListener(type, listener) {\n        if (!this.eventListeners[type]) {\n            this.eventListeners[type] = [];\n        }\n        this.eventListeners[type].push(listener);\n    }\n\n    removeEventListener(type, listener) {\n        if (this.eventListeners[type]) {\n            const index = this.eventListeners[type].indexOf(listener);\n            if (index !== -1) {\n                this.eventListeners[type].splice(index, 1);\n            }\n        }\n    }\n\n    dispatchEvent(event) {\n        if (this.eventListeners[event.type]) {\n            this.eventListeners[event.type].forEach(listener => listener(event));\n        }\n    }\n\n    open(wasReconnect) {\n        if (this.ws) {\n            this.ws.close();\n        }\n        this.readyState = WebSocket.CONNECTING;\n        this.reconnectAttempts = 0;\n        this.ws = new WebSocket(this.url, this.protocols);\n        this.ws.onopen = (event) => {\n            this.readyState = WebSocket.OPEN;\n            this.protocol = this.ws.protocol;\n            this.reconnectAttempts = 0;\n            this.dispatchEvent(new CustomEvent('open', { detail: { wasReconnect } }));\n            this.dispatchEvent(new CustomEvent('connecting', { detail: { wasReconnect } }));\n        };\n        this.ws.onclose = (event) => {\n            this.readyState = WebSocket.CLOSED;\n            this.dispatchEvent(new CustomEvent('close', { detail: { wasReconnect } }));\n            this.reconnect();\n        };\n        this.ws.onmessage = (event) => {\n            this.dispatchEvent(new CustomEvent('message', { detail: { data: event.data } }));\n        };\n        this.ws.onerror = (event) => {\n            this.readyState = WebSocket.CLOSED;\n            this.dispatchEvent(new CustomEvent('error', { detail: { event } }));\n            this.reconnect();\n        };\n    }\n\n    send(data) {\n        if (this.readyState === WebSocket.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.dispatchEvent(new CustomEvent('error', { detail: { message: 'WebSocket is not open' } }));\n        }\n    }\n\n    close(code, reason) {\n        if (this.ws) {\n            this.ws.close(code, reason);\n        }\n        this.readyState = WebSocket.CLOSED;\n        this.reconnectAttempts = 0;\n    }\n\n    refresh() {\n        this.close(1000, 'refresh');\n    }\n\n    createEvent(eventName, detail) {\n        return new CustomEvent(eventName, { detail });\n    }\n\n    onopen(event) {}\n\n    onclose(event) {}\n\n    onconnecting(event) {}\n\n    onmessage(event) {}\n\n    onerror(event) {}\n\n    reconnect() {\n        if (this.readyState === WebSocket.CLOSED) {\n            const delay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n            setTimeout(() => {\n                this.reconnectAttempts++;\n                this.open(true);\n            }, delay);\n        }\n    }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n    constructor(url, protocols, options) {\n        this.debug = options.debug || false;\n        this.automaticOpen = options.automaticOpen || false;\n        this.reconnectInterval = options.reconnectInterval || 1000;\n        this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n        this.reconnectDecay = options.reconnectDecay || 1.5;\n        this.timeoutInterval = options.timeoutInterval || 20000;\n        this.url = url;\n        this.protocols = protocols;\n        this.reconnectAttempts = 0;\n        this.readyState = WebSocket.CLOSED;\n        this.protocol = null;\n        this.ws = null;\n        this.eventListeners = {};\n        this.connect();\n    }\n\n    addEventListener(type, listener) {\n        if (!this.eventListeners[type]) {\n            this.eventListeners[type] = [];\n        }\n        this.eventListeners[type].push(listener);\n    }\n\n    removeEventListener(type, listener) {\n        if (this.eventListeners[type]) {\n            const index = this.eventListeners[type].indexOf(listener);\n            if (index !== -1) {\n                this.eventListeners[type].splice(index, 1);\n            }\n        }\n    }\n\n    dispatchEvent(event) {\n        if (this.eventListeners[event.type]) {\n            this.eventListeners[event.type].forEach(listener => listener(event));\n        }\n    }\n\n    open(wasReconnect) {\n        if (this.ws) {\n            this.ws.close();\n        }\n        this.ws = new WebSocket(this.url, this.protocols);\n        this.ws.onopen = this.onopen.bind(this);\n        this.ws.onclose = this.onclose.bind(this);\n        this.ws.onmessage = this.onmessage.bind(this);\n        this.ws.onerror = this.onerror.bind(this);\n        this.readyState = WebSocket.OPEN;\n        this.reconnectAttempts = 0;\n        if (wasReconnect) {\n            this.dispatchEvent(new CustomEvent('reconnecting', { detail: { url: this.url } }));\n        }\n    }\n\n    send(data) {\n        if (this.readyState === WebSocket.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.dispatchEvent(new CustomEvent('error', { detail: { message: 'WebSocket is not open' } }));\n        }\n    }\n\n    close(code, reason) {\n        if (this.ws) {\n            this.ws.close(code, reason);\n        }\n        this.readyState = WebSocket.CLOSED;\n        this.reconnectAttempts = 0;\n    }\n\n    refresh() {\n        this.close();\n        this.open(false);\n    }\n\n    createEvent(eventName, detail) {\n        return new CustomEvent(eventName, { detail: detail });\n    }\n\n    onopen(event) {\n        this.readyState = WebSocket.OPEN;\n        this.reconnectAttempts = 0;\n        this.dispatchEvent(new CustomEvent('open', { detail: { url: this.url } }));\n        this.dispatchEvent(new CustomEvent('reconnecting', { detail: { url: this.url } }));\n    }\n\n    onclose(event) {\n        this.readyState = WebSocket.CLOSED;\n        this.dispatchEvent(new CustomEvent('close', { detail: { url: this.url } }));\n        this.reconnect();\n    }\n\n    onconnecting(event) {\n        this.readyState = WebSocket.CONNECTING;\n        this.dispatchEvent(new CustomEvent('connecting', { detail: { url: this.url } }));\n    }\n\n    onmessage(event) {\n        this.dispatchEvent(new CustomEvent('message', { detail: { data: event.data } }));\n    }\n\n    onerror(event) {\n        this.dispatchEvent(new CustomEvent('error', { detail: { message: event.message, url: this.url } }));\n    }\n\n    reconnect() {\n        if (this.readyState === WebSocket.CLOSED) {\n            const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n            setTimeout(() => {\n                this.reconnectAttempts++;\n                this.open(true);\n            }, reconnectDelay);\n        }\n    }\n\n    connect() {\n        if (this.automaticOpen) {\n            this.open(false);\n        }\n    }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 20000;\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = this.onopen.bind(this);\n    this.ws.onclose = this.onclose.bind(this);\n    this.ws.onmessage = this.onmessage.bind(this);\n    this.ws.onerror = this.onerror.bind(this);\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  addEventListener(type, listener) {\n    this.ws.addEventListener(type, listener);\n  }\n\n  removeEventListener(type, listener) {\n    this.ws.removeEventListener(type, listener);\n  }\n\n  dispatchEvent(event) {\n    this.ws.dispatchEvent(event);\n  }\n\n  open(wasReconnect) {\n    if (wasReconnect) {\n      this.reconnectAttempts++;\n      this.reconnectInterval = Math.min(this.maxReconnectInterval, this.reconnectInterval * this.reconnectDecay);\n    }\n    this.ws.open();\n  }\n\n  send(data) {\n    this.ws.send(data);\n  }\n\n  close(code, reason) {\n    this.ws.close(code, reason);\n    this.reconnectAttempts = 0;\n    this.reconnectInterval = 1000;\n  }\n\n  refresh() {\n    this.close(0, null);\n    this.open(false);\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {\n    this.readyState = WebSocket.OPEN;\n    this.reconnectAttempts = 0;\n    this.reconnectInterval = 1000;\n    this.onopen(event);\n  }\n\n  onclose(event) {\n    this.readyState = WebSocket.CLOSED;\n    this.onclose(event);\n  }\n\n  onconnecting(event) {\n    this.readyState = WebSocket.CONNECTING;\n    this.onconnecting(event);\n  }\n\n  onmessage(event) {\n    this.onmessage(event);\n  }\n\n  onerror(event) {\n    this.onerror(event);\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 20000;\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.eventListeners = {};\n    this.init();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.eventListeners[type]) {\n      this.eventListeners[type] = [];\n    }\n    this.eventListeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.eventListeners[type]) {\n      const index = this.eventListeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.eventListeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.eventListeners[event.type]) {\n      this.eventListeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {\n    this.readyState = WebSocket.OPEN;\n    this.reconnectAttempts = 0;\n    this.dispatchEvent(this.createEvent('open', event));\n    this.dispatchEvent(this.createEvent('message', event));\n  }\n\n  onclose(event) {\n    this.readyState = WebSocket.CLOSED;\n    this.dispatchEvent(this.createEvent('close', event));\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  onconnecting(event) {\n    this.readyState = WebSocket.CONNECTING;\n    this.dispatchEvent(this.createEvent('connecting', event));\n  }\n\n  onmessage(event) {\n    this.dispatchEvent(this.createEvent('message', event));\n  }\n\n  onerror(event) {\n    this.readyState = WebSocket.CLOSED;\n    this.dispatchEvent(this.createEvent('error', event));\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  open(wasReconnect) {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = this.onopen.bind(this);\n    this.ws.onclose = this.onclose.bind(this);\n    this.ws.onconnecting = this.onconnecting.bind(this);\n    this.ws.onmessage = this.onmessage.bind(this);\n    this.ws.onerror = this.onerror.bind(this);\n    this.onconnecting();\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent(this.createEvent('error', new Error('WebSocket is not open')));\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n    this.automaticOpen = false;\n  }\n\n  refresh() {\n    this.close();\n    this.open(false);\n  }\n\n  init() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 20000;\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.eventListeners = {};\n\n    this.addEventListener('open', this.onopen);\n    this.addEventListener('close', this.onclose);\n    this.addEventListener('connecting', this.onconnecting);\n    this.addEventListener('message', this.onmessage);\n    this.addEventListener('error', this.onerror);\n\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  addEventListener(type, listener) {\n    if (!this.eventListeners[type]) {\n      this.eventListeners[type] = [];\n    }\n    this.eventListeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.eventListeners[type]) {\n      const index = this.eventListeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.eventListeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    const listeners = this.eventListeners[event.type];\n    if (listeners) {\n      listeners.forEach(listener => listener(event));\n    }\n  }\n\n  open(wasReconnect) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      return;\n    }\n    this.reconnectAttempts++;\n    this.readyState = WebSocket.CONNECTING;\n    this.dispatchEvent(this.createEvent('connecting', { wasReconnect }));\n\n    const ws = new WebSocket(this.url, this.protocols);\n    this.ws = ws;\n\n    ws.onopen = () => {\n      this.readyState = WebSocket.OPEN;\n      this.reconnectAttempts = 0;\n      this.protocol = ws.protocol;\n      this.dispatchEvent(this.createEvent('open', { wasReconnect }));\n    };\n\n    ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(this.createEvent('close', { wasReconnect, code: event.code, reason: event.reason }));\n      if (this.reconnectAttempts < 10) {\n        setTimeout(() => {\n          this.open(true);\n        }, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n      }\n    };\n\n    ws.onmessage = (event) => {\n      this.dispatchEvent(this.createEvent('message', { data: event.data }));\n    };\n\n    ws.onerror = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(this.createEvent('error', { wasReconnect, event }));\n    };\n  }\n\n  send(data) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n  }\n\n  refresh() {\n    this.close(1000, 'refresh');\n    this.open(false);\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {}\n\n  onclose(event) {}\n\n  onconnecting(event) {}\n\n  onmessage(event) {}\n\n  onerror(event) {}\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 20000;\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.eventListeners = {};\n\n    this.addEventListener('open', this.onopen);\n    this.addEventListener('close', this.onclose);\n    this.addEventListener('connecting', this.onconnecting);\n    this.addEventListener('message', this.onmessage);\n    this.addEventListener('error', this.onerror);\n\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  addEventListener(type, listener) {\n    if (!this.eventListeners[type]) {\n      this.eventListeners[type] = [];\n    }\n    this.eventListeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.eventListeners[type]) {\n      const index = this.eventListeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.eventListeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.eventListeners[event.type]) {\n      this.eventListeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(wasReconnect) {\n    if (this.ws && this.ws.readyState !== WebSocket.CLOSED) {\n      this.close(1000, 'Connection already open');\n      return;\n    }\n    this.readyState = WebSocket.CONNECTING;\n    this.reconnectAttempts = wasReconnect ? this.reconnectAttempts + 1 : 0;\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = 'blob';\n\n    this.ws.onopen = (event) => {\n      this.readyState = WebSocket.OPEN;\n      this.reconnectAttempts = 0;\n      this.protocol = this.ws.protocol;\n      this.dispatchEvent(new CustomEvent('open', { detail: event }));\n      this.dispatchEvent(new CustomEvent('message', { detail: event }));\n    };\n\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new CustomEvent('close', { detail: event }));\n      if (this.reconnectAttempts < 10) {\n        setTimeout(() => {\n          this.open(true);\n        }, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n      }\n    };\n\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent(new CustomEvent('message', { detail: event }));\n    };\n\n    this.ws.onerror = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new CustomEvent('error', { detail: event }));\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent(new CustomEvent('error', { detail: new Error('WebSocket is not open') }));\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n      this.ws = null;\n    }\n  }\n\n  refresh() {\n    this.close(1000, 'Refresh connection');\n    this.open(false);\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {}\n\n  onclose(event) {}\n\n  onconnecting(event) {}\n\n  onmessage(event) {}\n\n  onerror(event) {}\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || false;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 20000;\n    this.url = url;\n    this.protocols = protocols;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.eventListeners = {};\n\n    this.addEventListener('open', this.onopen);\n    this.addEventListener('close', this.onclose);\n    this.addEventListener('connecting', this.onconnecting);\n    this.addEventListener('message', this.onmessage);\n    this.addEventListener('error', this.onerror);\n\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  addEventListener(type, listener) {\n    if (!this.eventListeners[type]) {\n      this.eventListeners[type] = [];\n    }\n    this.eventListeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.eventListeners[type]) {\n      const index = this.eventListeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.eventListeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    const listeners = this.eventListeners[event.type];\n    if (listeners) {\n      listeners.forEach(listener => listener(event));\n    }\n  }\n\n  open(wasReconnect) {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.readyState = WebSocket.CONNECTING;\n    this.reconnectAttempts = 0;\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = 'blob';\n    this.ws.onopen = (event) => {\n      this.readyState = WebSocket.OPEN;\n      this.reconnectAttempts = 0;\n      this.protocol = this.ws.protocol;\n      this.dispatchEvent(new CustomEvent('open', { detail: { wasReconnect } }));\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new CustomEvent('close', { detail: { wasReconnect } }));\n      this.reconnect();\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent(new CustomEvent('message', { detail: { data: event.data } }));\n    };\n    this.ws.onerror = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new CustomEvent('error', { detail: { event } }));\n      this.reconnect();\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent(new CustomEvent('error', { detail: { message: 'WebSocket is not open' } }));\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n    this.readyState = WebSocket.CLOSED;\n  }\n\n  refresh() {\n    this.close(1000, 'refresh');\n    this.open(false);\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {}\n\n  onclose(event) {}\n\n  onconnecting(event) {}\n\n  onmessage(event) {}\n\n  onerror(event) {}\n\n  reconnect() {\n    if (this.readyState === WebSocket.CLOSED) {\n      const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n      setTimeout(() => {\n        this.reconnectAttempts++;\n        this.open(true);\n      }, reconnectDelay);\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 203,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with automatic reconnection capabilities and event handling.\n\nClass Description: The WebSocketClient class provides a wrapper around the browser's native WebSocket API, adding features like automatic reconnection with exponential backoff, connection state management, and customizable event handlers for connection events.\n\nAttributes:\n- URI: string - The WebSocket server URI to connect to\n- _socket: WebSocket - The underlying WebSocket connection instance\n- _isOpen: boolean - Tracks whether the connection is currently open\n- _shouldClose: boolean - Flag indicating if the connection was intentionally closed\n- _delayUntilReconnect: number - Current delay before attempting reconnection (in milliseconds)\n- openHandler: function - Callback for connection open events\n- messageHandler: function - Callback for incoming message events\n- closeHandler: function - Callback for connection close events\n\nMethods:\n- constructor(uri: string) -> void - Initializes the WebSocket client with the given URI\n- open() -> void - Establishes a new WebSocket connection and sets up event handlers\n- send(message: string) -> void - Sends a message through the WebSocket if connected\n- close() -> void - Closes the WebSocket connection intentionally\n- reconnect() -> void - Forces a reconnection by closing the current connection\n- getReconnectDelay() -> number - Returns the current reconnection delay\n- _onopen() -> void - Internal handler for WebSocket open events\n- _resetDelay() -> void - Resets the reconnection delay to initial value\n- _onmessage(e: MessageEvent) -> void - Internal handler for WebSocket message events\n- _onclose() -> void - Internal handler for WebSocket close events\n- _reconnect() -> void - Handles reconnection logic with exponential backoff",
    "Canonical_solution": "class WebSocketClient {\n  constructor(uri) {\n    this.URI = uri;\n    this._resetDelay();\n    this._socket = null;\n    this._isOpen = false;\n    this._shouldClose = false;\n    this._delayUntilReconnect = null;\n    this.openHandler = null;\n    this.messageHandler = null;\n    this.closeHandler = null;\n  }\n\n  open() {\n    if (!window.WebSocket) {\n      return;\n    }\n\n    this._shouldClose = false;\n\n    this._socket = new WebSocket(this.URI);\n    this._socket.onopen = this._onopen.bind(this);\n    this._socket.onmessage = this._onmessage.bind(this);\n    this._socket.onclose = this._onclose.bind(this);\n  }\n\n  send(message) {\n    if (this._isOpen) {\n      this._socket.send(message);\n    }\n  }\n\n  close() {\n    if (!this._isOpen) {\n      return;\n    }\n    this._shouldClose = true;\n    this._socket.close();\n  }\n\n  reconnect() {\n    if (!this._isOpen) {\n      return;\n    }\n    this._socket.close();\n  }\n\n  getReconnectDelay() {\n    return this._delayUntilReconnect;\n  }\n\n  _onopen() {\n    this._isOpen = true;\n    this._delayUntilReconnect = 0;\n\n    if (this.openHandler) {\n      this.openHandler();\n    }\n  }\n\n  _resetDelay() {\n    this._delayUntilReconnect = 2000;\n  }\n\n  _onmessage(e) {\n    var data = e.data;\n    if (this.messageHandler) {\n      this.messageHandler(data);\n    }\n  }\n\n  _onclose() {\n    this._isOpen = false;\n    var done = false;\n\n    if (this.closeHandler) {\n      done = this.closeHandler();\n    }\n\n    if (!done && !this._shouldClose) {\n      setTimeout(this._reconnect.bind(this), this._delayUntilReconnect);\n    }\n  }\n\n  _reconnect() {\n    if (!this._delayUntilReconnect) {\n      this._resetDelay();\n    } else {\n      this._delayUntilReconnect = this._delayUntilReconnect * 2;\n    }\n\n    this._delayUntilReconnect = Math.min(this._delayUntilReconnect, 300000);\n    this.open();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WebSocketClient {\n    constructor(uri) {\n        this.URI = uri;\n        this._socket = null;\n        this._isOpen = false;\n        this._shouldClose = false;\n        this._delayUntilReconnect = 1000;\n        this.openHandler = null;\n        this.messageHandler = null;\n        this.closeHandler = null;\n    }\n\n    open() {\n        if (this._socket) {\n            this.close();\n        }\n        this._socket = new WebSocket(this.URI);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    send(message) {\n        if (this._socket && this._isOpen) {\n            this._socket.send(message);\n        }\n    }\n\n    close() {\n        if (this._socket) {\n            this._shouldClose = true;\n            this._socket.close();\n        }\n    }\n\n    reconnect() {\n        if (this._shouldClose) {\n            this.close();\n            this._reconnect();\n        }\n    }\n\n    getReconnectDelay() {\n        return this._delayUntilReconnect;\n    }\n\n    _onopen() {\n        this._isOpen = true;\n        this._resetDelay();\n        if (this.openHandler) {\n            this.openHandler();\n        }\n    }\n\n    _resetDelay() {\n        this._delayUntilReconnect = 1000;\n    }\n\n    _onmessage(e) {\n        if (this.messageHandler) {\n            this.messageHandler(e);\n        }\n    }\n\n    _onclose() {\n        this._isOpen = false;\n        if (!this._shouldClose) {\n            this._reconnect();\n        } else if (this.closeHandler) {\n            this.closeHandler();\n        }\n    }\n\n    _reconnect() {\n        setTimeout(() => {\n            this.open();\n        }, this._delayUntilReconnect);\n        this._delayUntilReconnect *= 2;\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(uri) {\n        this.URI = uri;\n        this._socket = null;\n        this._isOpen = false;\n        this._shouldClose = false;\n        this._delayUntilReconnect = 1000;\n        this.openHandler = null;\n        this.messageHandler = null;\n        this.closeHandler = null;\n    }\n\n    open() {\n        if (this._socket) {\n            this._socket.close();\n        }\n        this._socket = new WebSocket(this.URI);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    send(message) {\n        if (this._isOpen && this._socket) {\n            this._socket.send(message);\n        }\n    }\n\n    close() {\n        this._shouldClose = true;\n        if (this._socket) {\n            this._socket.close();\n        }\n    }\n\n    reconnect() {\n        this.close();\n        this._reconnect();\n    }\n\n    getReconnectDelay() {\n        return this._delayUntilReconnect;\n    }\n\n    _onopen() {\n        this._isOpen = true;\n        this._resetDelay();\n        if (this.openHandler) {\n            this.openHandler();\n        }\n    }\n\n    _resetDelay() {\n        this._delayUntilReconnect = 1000;\n    }\n\n    _onmessage(e) {\n        if (this.messageHandler) {\n            this.messageHandler(e);\n        }\n    }\n\n    _onclose() {\n        this._isOpen = false;\n        if (this.closeHandler) {\n            this.closeHandler();\n        }\n        if (!this._shouldClose) {\n            this._reconnect();\n        }\n    }\n\n    _reconnect() {\n        setTimeout(() => {\n            if (!this._shouldClose) {\n                this.open();\n            }\n        }, this._delayUntilReconnect);\n        this._delayUntilReconnect *= 2;\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(uri) {\n    this.URI = uri;\n    this._socket = null;\n    this._isOpen = false;\n    this._shouldClose = false;\n    this._delayUntilReconnect = 1000;\n    this.openHandler = null;\n    this.messageHandler = null;\n    this.closeHandler = null;\n  }\n\n  open() {\n    if (this._socket) {\n      this._socket.close();\n    }\n    this._socket = new WebSocket(this.URI);\n    this._socket.onopen = this._onopen.bind(this);\n    this._socket.onmessage = this._onmessage.bind(this);\n    this._socket.onclose = this._onclose.bind(this);\n  }\n\n  send(message) {\n    if (this._isOpen && this._socket) {\n      this._socket.send(message);\n    }\n  }\n\n  close() {\n    this._shouldClose = true;\n    if (this._socket) {\n      this._socket.close();\n    }\n  }\n\n  reconnect() {\n    this.close();\n    this._reconnect();\n  }\n\n  getReconnectDelay() {\n    return this._delayUntilReconnect;\n  }\n\n  _onopen() {\n    this._isOpen = true;\n    this._resetDelay();\n    if (this.openHandler) {\n      this.openHandler();\n    }\n  }\n\n  _resetDelay() {\n    this._delayUntilReconnect = 1000;\n  }\n\n  _onmessage(e) {\n    if (this.messageHandler) {\n      this.messageHandler(e);\n    }\n  }\n\n  _onclose() {\n    this._isOpen = false;\n    if (this.closeHandler) {\n      this.closeHandler();\n    }\n    if (!this._shouldClose) {\n      this._reconnect();\n    }\n  }\n\n  _reconnect() {\n    setTimeout(() => {\n      if (!this._isOpen && !this._shouldClose) {\n        this.open();\n      }\n    }, this._delayUntilReconnect);\n    this._delayUntilReconnect *= 2;\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(uri) {\n        this.URI = uri;\n        this._socket = null;\n        this._isOpen = false;\n        this._shouldClose = false;\n        this._delayUntilReconnect = 1000;\n        this.openHandler = null;\n        this.messageHandler = null;\n        this.closeHandler = null;\n    }\n\n    open() {\n        if (this._socket) {\n            this.close();\n        }\n        this._socket = new WebSocket(this.URI);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    send(message) {\n        if (this._socket && this._isOpen) {\n            this._socket.send(message);\n        }\n    }\n\n    close() {\n        if (this._socket) {\n            this._shouldClose = true;\n            this._socket.close();\n        }\n    }\n\n    reconnect() {\n        this.close();\n        setTimeout(() => {\n            this.open();\n        }, this.getReconnectDelay());\n    }\n\n    getReconnectDelay() {\n        return this._delayUntilReconnect;\n    }\n\n    _onopen() {\n        this._isOpen = true;\n        this._resetDelay();\n        if (this.openHandler) {\n            this.openHandler();\n        }\n    }\n\n    _resetDelay() {\n        this._delayUntilReconnect = 1000;\n    }\n\n    _onmessage(e) {\n        if (this.messageHandler) {\n            this.messageHandler(e);\n        }\n    }\n\n    _onclose() {\n        this._isOpen = false;\n        if (!this._shouldClose) {\n            this.reconnect();\n        } else {\n            if (this.closeHandler) {\n                this.closeHandler();\n            }\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(uri) {\n        this.URI = uri;\n        this._socket = null;\n        this._isOpen = false;\n        this._shouldClose = false;\n        this._delayUntilReconnect = 1000;\n        this.openHandler = null;\n        this.messageHandler = null;\n        this.closeHandler = null;\n    }\n\n    open() {\n        if (this._socket) {\n            this.close();\n        }\n        this._socket = new WebSocket(this.URI);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    send(message) {\n        if (this._socket && this._isOpen) {\n            this._socket.send(message);\n        }\n    }\n\n    close() {\n        if (this._socket) {\n            this._shouldClose = true;\n            this._socket.close();\n        }\n    }\n\n    reconnect() {\n        if (this._shouldClose) {\n            this.close();\n            this._reconnect();\n        }\n    }\n\n    getReconnectDelay() {\n        return this._delayUntilReconnect;\n    }\n\n    _onopen() {\n        this._isOpen = true;\n        this._resetDelay();\n        if (this.openHandler) {\n            this.openHandler();\n        }\n    }\n\n    _resetDelay() {\n        this._delayUntilReconnect = 1000;\n    }\n\n    _onmessage(e) {\n        if (this.messageHandler) {\n            this.messageHandler(e);\n        }\n    }\n\n    _onclose() {\n        this._isOpen = false;\n        if (this.closeHandler) {\n            this.closeHandler();\n        }\n        if (!this._shouldClose) {\n            this._reconnect();\n        }\n    }\n\n    _reconnect() {\n        setTimeout(() => {\n            this.open();\n        }, this._delayUntilReconnect);\n        this._delayUntilReconnect *= 2;\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(uri) {\n        this.URI = uri;\n        this._socket = null;\n        this._isOpen = false;\n        this._shouldClose = false;\n        this._delayUntilReconnect = 1000;\n        this.openHandler = null;\n        this.messageHandler = null;\n        this.closeHandler = null;\n    }\n\n    open() {\n        if (this._socket) {\n            this._socket.close();\n        }\n        this._socket = new WebSocket(this.URI);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    send(message) {\n        if (this._socket && this._isOpen) {\n            this._socket.send(message);\n        }\n    }\n\n    close() {\n        this._shouldClose = true;\n        if (this._socket) {\n            this._socket.close();\n        }\n    }\n\n    reconnect() {\n        this.close();\n        setTimeout(() => {\n            this.open();\n        }, this.getReconnectDelay());\n    }\n\n    getReconnectDelay() {\n        return this._delayUntilReconnect;\n    }\n\n    _onopen() {\n        this._isOpen = true;\n        this._resetDelay();\n        if (this.openHandler) {\n            this.openHandler();\n        }\n    }\n\n    _resetDelay() {\n        this._delayUntilReconnect = 1000;\n    }\n\n    _onmessage(e) {\n        if (this.messageHandler) {\n            this.messageHandler(e);\n        }\n    }\n\n    _onclose() {\n        this._isOpen = false;\n        if (this.closeHandler) {\n            this.closeHandler();\n        }\n        if (!this._shouldClose) {\n            this.reconnect();\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(uri) {\n        this.URI = uri;\n        this._socket = null;\n        this._isOpen = false;\n        this._shouldClose = false;\n        this._delayUntilReconnect = 1000;\n        this.openHandler = null;\n        this.messageHandler = null;\n        this.closeHandler = null;\n    }\n\n    open() {\n        if (this._socket) {\n            this.close();\n        }\n        this._socket = new WebSocket(this.URI);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    send(message) {\n        if (this._socket && this._isOpen) {\n            this._socket.send(message);\n        }\n    }\n\n    close() {\n        if (this._socket) {\n            this._shouldClose = true;\n            this._socket.close();\n        }\n    }\n\n    reconnect() {\n        if (this._shouldClose) {\n            this.close();\n            this._reconnect();\n        }\n    }\n\n    getReconnectDelay() {\n        return this._delayUntilReconnect;\n    }\n\n    _onopen() {\n        this._isOpen = true;\n        this._resetDelay();\n        if (this.openHandler) {\n            this.openHandler();\n        }\n    }\n\n    _resetDelay() {\n        this._delayUntilReconnect = 1000;\n    }\n\n    _onmessage(e) {\n        if (this.messageHandler) {\n            this.messageHandler(e);\n        }\n    }\n\n    _onclose() {\n        this._isOpen = false;\n        if (this.closeHandler) {\n            this.closeHandler();\n        }\n        if (!this._shouldClose) {\n            this._reconnect();\n        }\n    }\n\n    _reconnect() {\n        setTimeout(() => {\n            this.open();\n        }, this._delayUntilReconnect);\n        this._delayUntilReconnect *= 2;\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(uri) {\n    this.URI = uri;\n    this._socket = null;\n    this._isOpen = false;\n    this._shouldClose = false;\n    this._delayUntilReconnect = 1000;\n    this.openHandler = null;\n    this.messageHandler = null;\n    this.closeHandler = null;\n  }\n\n  open() {\n    if (this._socket) {\n      this._socket.close();\n    }\n    this._socket = new WebSocket(this.URI);\n    this._socket.onopen = this._onopen.bind(this);\n    this._socket.onmessage = this._onmessage.bind(this);\n    this._socket.onclose = this._onclose.bind(this);\n  }\n\n  send(message) {\n    if (this._socket && this._isOpen) {\n      this._socket.send(message);\n    }\n  }\n\n  close() {\n    this._shouldClose = true;\n    if (this._socket) {\n      this._socket.close();\n    }\n  }\n\n  reconnect() {\n    this.close();\n    setTimeout(() => {\n      this.open();\n    }, this.getReconnectDelay());\n  }\n\n  getReconnectDelay() {\n    return this._delayUntilReconnect;\n  }\n\n  _onopen() {\n    this._isOpen = true;\n    this._resetDelay();\n    if (this.openHandler) {\n      this.openHandler();\n    }\n  }\n\n  _resetDelay() {\n    this._delayUntilReconnect = 1000;\n  }\n\n  _onmessage(e) {\n    if (this.messageHandler) {\n      this.messageHandler(e);\n    }\n  }\n\n  _onclose() {\n    this._isOpen = false;\n    if (this.closeHandler) {\n      this.closeHandler();\n    }\n    if (!this._shouldClose) {\n      this.reconnect();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(uri) {\n        this.URI = uri;\n        this._socket = null;\n        this._isOpen = false;\n        this._shouldClose = false;\n        this._delayUntilReconnect = 1000;\n        this.openHandler = null;\n        this.messageHandler = null;\n        this.closeHandler = null;\n    }\n\n    open() {\n        if (this._socket) {\n            this.close();\n        }\n        this._socket = new WebSocket(this.URI);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    send(message) {\n        if (this._socket && this._isOpen) {\n            this._socket.send(message);\n        }\n    }\n\n    close() {\n        if (this._socket) {\n            this._shouldClose = true;\n            this._socket.close();\n        }\n    }\n\n    reconnect() {\n        if (this._shouldClose) {\n            this.close();\n            this._reconnect();\n        }\n    }\n\n    getReconnectDelay() {\n        return this._delayUntilReconnect;\n    }\n\n    _onopen() {\n        this._isOpen = true;\n        this._resetDelay();\n        if (this.openHandler) {\n            this.openHandler();\n        }\n    }\n\n    _resetDelay() {\n        this._delayUntilReconnect = 1000;\n    }\n\n    _onmessage(e) {\n        if (this.messageHandler) {\n            this.messageHandler(e);\n        }\n    }\n\n    _onclose() {\n        this._isOpen = false;\n        if (this.closeHandler) {\n            this.closeHandler();\n        }\n        if (!this._shouldClose) {\n            setTimeout(() => {\n                this.reconnect();\n            }, this._delayUntilReconnect);\n            this._delayUntilReconnect *= 2;\n        }\n    }\n\n    _reconnect() {\n        if (this._delayUntilReconnect > 0) {\n            setTimeout(() => {\n                this.open();\n            }, this._delayUntilReconnect);\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(uri) {\n        this.URI = uri;\n        this._socket = null;\n        this._isOpen = false;\n        this._shouldClose = false;\n        this._delayUntilReconnect = 1000;\n        this.openHandler = null;\n        this.messageHandler = null;\n        this.closeHandler = null;\n    }\n\n    open() {\n        if (this._socket) {\n            this.close();\n        }\n        this._socket = new WebSocket(this.URI);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    send(message) {\n        if (this._isOpen && this._socket) {\n            this._socket.send(message);\n        }\n    }\n\n    close() {\n        this._shouldClose = true;\n        if (this._socket) {\n            this._socket.close();\n        }\n    }\n\n    reconnect() {\n        this.close();\n        setTimeout(() => {\n            this.open();\n        }, this.getReconnectDelay());\n    }\n\n    getReconnectDelay() {\n        return this._delayUntilReconnect;\n    }\n\n    _onopen() {\n        this._isOpen = true;\n        this._resetDelay();\n        if (this.openHandler) {\n            this.openHandler();\n        }\n    }\n\n    _resetDelay() {\n        this._delayUntilReconnect = 1000;\n    }\n\n    _onmessage(e) {\n        if (this.messageHandler) {\n            this.messageHandler(e);\n        }\n    }\n\n    _onclose() {\n        this._isOpen = false;\n        if (!this._shouldClose) {\n            this.reconnect();\n        } else if (this.closeHandler) {\n            this.closeHandler();\n        }\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a WebSocket client in JavaScript that automatically reconnects to a server upon disconnection and triggers a page reload when receiving a message from the server.\n\nFunction Description: The function establishes a WebSocket connection to a specified URL. It handles connection closure by attempting to reconnect after a delay and reloads the page upon receiving any message from the server.\n\nInput: \n- a (String): The WebSocket server URL to connect to (e.g., \"ws://localhost:12450/reload\")\n\nOutput: None (The function's effects are side effects: establishing connection, handling messages, and attempting reconnections)",
    "Canonical_solution": "function b(a) {\n    var c = new WebSocket(a);\n    c.onclose = function() {\n        setTimeout(function() {\n            b(a)\n        }, 2E3)\n    };\n    c.onmessage = function() {\n        location.reload()\n    }\n}\ntry {\n    if (window.WebSocket) {\n        try {\n            b(\"ws://localhost:12450/reload\")\n        } catch (a) {\n            console.error(a)\n        }\n    } else {\n        console.log(\"Your browser does not support WebSockets.\")\n    }\n} catch (a) {\n    console.error(\"Exception during connecting to Reload:\", a)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst connectToWebSocket = (a) => {\n  let ws = new WebSocket(a);\n  let reconnectDelay = 5000;\n\n  ws.onopen = () => {\n    console.log('Connected to WebSocket server');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed. Attempting to reconnect...');\n    setTimeout(() => {\n      connectToWebSocket(a);\n    }, reconnectDelay);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    ws.close();\n  };\n};\n\nconnectToWebSocket(a);\n```",
      "```javascript\nconst connectToWebSocket = (a) => {\n  let socket = new WebSocket(a);\n  let reconnectDelay = 5000;\n\n  socket.onopen = () => {\n    console.log('Connected to WebSocket server');\n  };\n\n  socket.onmessage = (event) => {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  socket.onclose = () => {\n    console.log('WebSocket connection closed. Attempting to reconnect...');\n    setTimeout(() => {\n      connectToWebSocket(a);\n    }, reconnectDelay);\n  };\n\n  socket.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    socket.close();\n  };\n};\n\nconnectToWebSocket(a);\n```",
      "```javascript\nconst connectToWebSocket = (a) => {\n  let ws;\n  const reconnectDelay = 5000;\n\n  const connect = () => {\n    ws = new WebSocket(a);\n    ws.onopen = () => console.log('Connected to WebSocket server');\n    ws.onmessage = (event) => {\n      console.log('Message from server:', event.data);\n      window.location.reload();\n    };\n    ws.onclose = () => {\n      console.log('WebSocket connection closed. Attempting to reconnect...');\n      setTimeout(connect, reconnectDelay);\n    };\n  };\n\n  connect();\n};\n```",
      "```javascript\nconst connectToWebSocket = (a) => {\n  let ws = new WebSocket(a);\n  let reconnectDelay = 5000;\n\n  ws.onopen = () => {\n    console.log('Connected to WebSocket server');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed. Attempting to reconnect...');\n    setTimeout(() => {\n      connectToWebSocket(a);\n    }, reconnectDelay);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    ws.close();\n  };\n};\n\nconnectToWebSocket(a);\n```",
      "```javascript\nconst connectToWebSocket = (a) => {\n  let ws;\n  const reconnectDelay = 5000;\n  const maxReconnectAttempts = 10;\n  let reconnectAttempts = 0;\n\n  const connect = () => {\n    ws = new WebSocket(a);\n    ws.onopen = () => {\n      reconnectAttempts = 0;\n    };\n    ws.onmessage = (event) => {\n      window.location.reload();\n    };\n    ws.onclose = () => {\n      if (reconnectAttempts < maxReconnectAttempts) {\n        setTimeout(connect, reconnectDelay);\n        reconnectAttempts++;\n      }\n    };\n  };\n\n  connect();\n};\n```",
      "```javascript\nconst connectToWebSocket = (a) => {\n  let socket = new WebSocket(a);\n  let reconnectDelay = 5000;\n\n  socket.onopen = () => {\n    console.log('Connected to WebSocket server');\n  };\n\n  socket.onmessage = (event) => {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  socket.onclose = () => {\n    console.log('WebSocket connection closed. Attempting to reconnect...');\n    setTimeout(() => {\n      connectToWebSocket(a);\n    }, reconnectDelay);\n  };\n\n  socket.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    socket.close();\n  };\n};\n\nconnectToWebSocket(a);\n```",
      "```javascript\nconst a = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(a);\n\n  ws.onopen = function() {\n    console.log('Connected to the server');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log('Disconnected from the server');\n    setTimeout(connect, 2000);\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst connectToWebSocket = (a) => {\n  let ws = new WebSocket(a);\n  let reconnectDelay = 5000;\n\n  ws.onopen = () => {\n    console.log('Connected to WebSocket server');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed. Attempting to reconnect...');\n    setTimeout(() => {\n      connectToWebSocket(a);\n    }, reconnectDelay);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    ws.close();\n  };\n};\n\nconnectToWebSocket(a);\n```",
      "```javascript\nconst connectToWebSocket = (a) => {\n  let ws = new WebSocket(a);\n  ws.onopen = () => {\n    console.log('Connected to WebSocket server');\n  };\n  ws.onmessage = (event) => {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n  ws.onclose = () => {\n    console.log('WebSocket connection closed. Attempting to reconnect...');\n    setTimeout(() => connectToWebSocket(a), 5000);\n  };\n};\nconnectToWebSocket(a);\n```",
      "```javascript\nconst connectToWebSocket = (a) => {\n  let ws = new WebSocket(a);\n  let reconnectInterval = 5000;\n\n  ws.onopen = () => {\n    console.log('Connected to WebSocket server');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = () => {\n    console.log('Disconnected from WebSocket server. Attempting to reconnect...');\n    setTimeout(() => {\n      connectToWebSocket(a);\n    }, reconnectInterval);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    ws.close();\n  };\n};\n\nconnectToWebSocket(a);\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a JavaScript function that manages parallel execution of tests using WebSocket communication to coordinate test runs and report results.\n\nFunction Description: The function establishes a WebSocket connection to a test server, manages a queue of tests to run in parallel (with configurable parallelism), opens test cases in separate windows, and processes test results and status updates received through the WebSocket connection. It handles test queuing, parallel execution, status tracking, and result reporting.\n\nInput: None (The function operates on DOM elements and uses a hardcoded WebSocket URL)\n\nOutput: None (The function modifies the DOM to display test statuses and results)\n\nAttributes (internal variables used by the function):\n- socket: WebSocket - The WebSocket connection to the test server\n- maxParallelRuns: Number - Maximum number of tests to run simultaneously\n- subscriptionKey: Number - Unique identifier for this test session\n- queue: Array - Queue of tests waiting to be executed\n- numRunning: Number - Count of currently running tests\n\nMethods (internal functions):\n- processQueue() -> void - Processes the test queue by opening test windows up to the maximum parallel limit\n- WebSocket.onopen handler -> void - Handles WebSocket connection establishment\n- WebSocket.onmessage handler -> void - Processes incoming WebSocket messages (test results and status updates)",
    "Canonical_solution": "function runAllTests() {\n    var socket = null;\n    var maxParallelRuns = 4;\n    var subscriptionKey = Date.now();\n    var queue = [];\n    var numRunning = 0;\n\n    function processQueue() {\n        var toRun = queue.splice(0, Math.min(maxParallelRuns - numRunning, queue.length));\n        toRun.forEach(function (linkDiv) {\n            linkDiv.querySelector(\".status\").textContent = \"- Running...\";\n            window.open(linkDiv.querySelector(\".testLink\").href + \"&autostart=true&subscriptionKey=\" + subscriptionKey, \"\", \"width=800, height=800, top=0, left=400\")\n            numRunning++;\n        });\n    }\n\n    socket = new WebSocket(\"ws://localhost:9998\");\n    socket.onopen = function () {\n        socket.send(JSON.stringify({ \n            id: \"Dashboard\", \n            type: \"registerSubscriber\", \n            args: { subscriptionKey: subscriptionKey } \n        }));\n\n        var linkDivs = document.querySelectorAll(\".testLinkDiv\");\n        for (var i = 0, l = linkDivs.length; i < l; i++) {\n            var linkDiv = linkDivs[i];\n            linkDiv.querySelector(\".status\").textContent = \"- Queued to run\";\n            queue.push(linkDiv);\n        }\n        processQueue();\n    };\n    socket.onmessage = function (m) {\n        var message = JSON.parse(m.data);\n\n        switch (message.type) {\n            case \"osinfo\":\n                processQueue();\n                break;\n\n            case \"report\":\n                var li = document.querySelector(\"#id_\" + message.id);\n                var data = message.args.data;\n                switch (data.type) {\n                    case \"singleFailure\":\n                        li.classList.add(\"failed\");\n                        break;\n                    case \"finished\":\n                        li.classList.add(\"reported\");\n                        li.querySelector(\".status\").textContent = \"- \" + (((+data.runtime / 1000) + 1) | 0) + \"s\";\n                        if (data.failures) {\n                            li.classList.add(\"failed\");\n                        } else {\n                            li.classList.add(\"passed\");\n                        }\n                        break;\n                }\n                break;\n\n            case \"reporterDisconnected\":\n                var li = document.querySelector(\"#id_\" + message.id);\n                if (!li.classList.contains(\"reported\")) {\n                    li.classList.add(\"reported\");\n                    li.classList.add(\"failed\");\n                    var status = li.querySelector(\".status\");\n                    status.textContent = \"- Canceled\";\n                }\n                numRunning--;\n                processQueue();\n                break;\n        }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction TestManager() {\n  this.socket = new WebSocket('ws://testserver.com');\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.socket.onopen = () => {\n    this.socket.send(JSON.stringify({ type: 'subscribe', key: this.subscriptionKey }));\n  };\n\n  this.socket.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'result') {\n      this.processResult(data);\n    } else if (data.type === 'status') {\n      this.updateStatus(data);\n    }\n  };\n\n  this.processQueue = () => {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.numRunning++;\n      window.open(test.url, '_blank');\n      this.socket.send(JSON.stringify({ type: 'run', key: this.subscriptionKey, test: test.id }));\n    }\n  };\n\n  this.processResult = (data) => {\n    const resultElement = document.getElementById(`result-${data.testId}`);\n    if (resultElement) {\n      resultElement.textContent = `Test ${data.testId} completed with status: ${data.status}`;\n    }\n  };\n\n  this.updateStatus = (data) => {\n    const statusElement = document.getElementById(`status-${data.testId}`);\n    if (statusElement) {\n      statusElement.textContent = `Test ${data.testId} status: ${data.status}`;\n    }\n  };\n\n  this.start = () => {\n    this.processQueue();\n  };\n}\n\nconst testManager = new TestManager();\ntestManager.start();\n```",
      "```javascript\nfunction TestManager() {\n  this.socket = new WebSocket('ws://testserver.com');\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.socket.onopen = () => {\n    this.socket.send(JSON.stringify({ type: 'subscribe', key: this.subscriptionKey }));\n  };\n\n  this.socket.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'result') {\n      this.processResult(data);\n    } else if (data.type === 'status') {\n      this.updateStatus(data);\n    }\n  };\n\n  this.processQueue = () => {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.numRunning++;\n      window.open(test.url, '_blank');\n      this.socket.send(JSON.stringify({ type: 'start', key: this.subscriptionKey, testId: test.id }));\n    }\n  };\n\n  this.processResult = (data) => {\n    const resultElement = document.getElementById(`result-${data.testId}`);\n    if (resultElement) {\n      resultElement.textContent = data.result;\n    }\n  };\n\n  this.updateStatus = (data) => {\n    const statusElement = document.getElementById(`status-${data.testId}`);\n    if (statusElement) {\n      statusElement.textContent = data.status;\n    }\n  };\n\n  window.addEventListener('load', () => {\n    this.processQueue();\n  });\n}\n```",
      "```javascript\nconst socket = new WebSocket('ws://testserver.com');\nconst maxParallelRuns = 5;\nconst subscriptionKey = Math.floor(Math.random() * 1000000);\nconst queue = [];\nconst numRunning = 0;\n\nsocket.onopen = function() {\n  socket.send(JSON.stringify({ type: 'subscribe', key: subscriptionKey }));\n};\n\nsocket.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  if (data.type === 'result') {\n    updateTestStatus(data.testId, data.status, data.result);\n  } else if (data.type === 'status') {\n    updateTestStatus(data.testId, data.status);\n  }\n};\n\nfunction updateTestStatus(testId, status, result = null) {\n  const statusElement = document.getElementById(`status-${testId}`);\n  if (statusElement) {\n    statusElement.textContent = status;\n    if (result !== null) {\n      const resultElement = document.getElementById(`result-${testId}`);\n      resultElement.textContent = result;\n    }\n  }\n}\n\nfunction processQueue() {\n  while (numRunning < maxParallelRuns && queue.length > 0) {\n    const test = queue.shift();\n    openTestWindow(test);\n  }\n}\n\nfunction openTestWindow(test) {\n  numRunning++;\n  const testWindow = window.open(test.url, `TestWindow-${test.id}`);\n  testWindow.onload = function() {\n    testWindow.document.body.innerHTML = `<div id=\"status-${test.id}\">Running</div><div id=\"result-${test.id}\"></div>`;\n    testWindow.postMessage({ type: 'start', testId: test.id }, '*');\n  };\n  testWindow.onunload = function() {\n    numRunning--;\n    processQueue();\n  };\n}\n\nwindow.onload = function() {\n  processQueue();\n};\n```",
      "```javascript\nfunction TestManager() {\n  this.socket = new WebSocket('ws://testserver.com');\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.socket.onopen = () => {\n    this.socket.send(JSON.stringify({ type: 'subscribe', key: this.subscriptionKey }));\n  };\n\n  this.socket.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'result') {\n      this.processResult(data);\n    } else if (data.type === 'status') {\n      this.updateStatus(data);\n    }\n  };\n\n  this.processQueue = () => {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.numRunning++;\n      window.open(test.url, '_blank');\n      this.socket.send(JSON.stringify({ type: 'run', key: this.subscriptionKey, testId: test.id }));\n    }\n  };\n\n  this.processResult = (data) => {\n    const resultElement = document.getElementById(`result-${data.testId}`);\n    if (resultElement) {\n      resultElement.textContent = `Test ${data.testId} completed with status: ${data.status}`;\n    }\n  };\n\n  this.updateStatus = (data) => {\n    const statusElement = document.getElementById(`status-${data.testId}`);\n    if (statusElement) {\n      statusElement.textContent = `Test ${data.testId} status: ${data.status}`;\n    }\n  };\n\n  this.start = () => {\n    this.processQueue();\n    setInterval(this.processQueue, 1000);\n  };\n}\n\nconst testManager = new TestManager();\ntestManager.start();\n```"
    ],
    "unmatched_results": [
      "```javascript\nfunction TestManager() {\n  this.socket = null;\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.processQueue = function() {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.openTestWindow(test);\n    }\n  };\n\n  this.openTestWindow = function(test) {\n    this.numRunning++;\n    window.open(test.url, 'testWindow' + this.numRunning);\n  };\n\n  this.handleOpen = function() {\n    this.socket.send(JSON.stringify({\n      type: 'subscribe',\n      key: this.subscriptionKey\n    }));\n  };\n\n  this.handleMessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'result') {\n      this.displayResult(data.testId, data.result);\n    } else if (data.type === 'status') {\n      this.displayStatus(data.testId, data.status);\n    }\n  };\n\n  this.displayResult = function(testId, result) {\n    const resultElement = document.getElementById('result' + testId);\n    if (resultElement) {\n      resultElement.textContent = 'Result: ' + result;\n    }\n  };\n\n  this.displayStatus = function(testId, status) {\n    const statusElement = document.getElementById('status' + testId);\n    if (statusElement) {\n      statusElement.textContent = 'Status: ' + status;\n    }\n  };\n\n  this.connect = function() {\n    this.socket = new WebSocket('ws://testserver.com');\n    this.socket.onopen = this.handleOpen;\n    this.socket.onmessage = this.handleMessage;\n  };\n\n  this.connect();\n}\n\nconst testManager = new TestManager();\n```",
      "```javascript\nfunction TestManager() {\n  this.socket = null;\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.processQueue = function() {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.openTestWindow(test);\n    }\n  };\n\n  this.openTestWindow = function(test) {\n    this.numRunning++;\n    window.open(test.url, 'testWindow' + this.numRunning);\n  };\n\n  this.WebSocket_onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  this.WebSocket_onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'result') {\n      this.handleTestResult(data);\n    } else if (data.type === 'status') {\n      this.updateTestStatus(data);\n    }\n  };\n\n  this.handleTestResult = function(data) {\n    console.log('Test Result:', data.result);\n    this.numRunning--;\n    this.processQueue();\n  };\n\n  this.updateTestStatus = function(data) {\n    console.log('Test Status:', data.status);\n  };\n\n  this.connectToServer = function() {\n    this.socket = new WebSocket('wss://testserver.com');\n    this.socket.onopen = this.WebSocket_onopen;\n    this.socket.onmessage = this.WebSocket_onmessage;\n  };\n\n  this.connectToServer();\n}\n\nconst testManager = new TestManager();\n```",
      "```javascript\nfunction TestManager() {\n  this.socket = null;\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.processQueue = function() {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.openTestWindow(test);\n    }\n  };\n\n  this.openTestWindow = function(test) {\n    this.numRunning++;\n    window.open(test.url, 'testWindow' + this.numRunning);\n  };\n\n  this.WebSocket = {\n    onopen: function(event) {\n      console.log('WebSocket connection established');\n    },\n    onmessage: function(event) {\n      const data = JSON.parse(event.data);\n      if (data.type === 'result') {\n        this.handleResult(data);\n      } else if (data.type === 'status') {\n        this.handleStatus(data);\n      }\n    },\n    handleResult: function(data) {\n      console.log('Test result:', data.result);\n      this.numRunning--;\n      this.processQueue();\n    },\n    handleStatus: function(data) {\n      console.log('Test status:', data.status);\n    }\n  };\n\n  this.connectToServer = function() {\n    this.socket = new WebSocket('ws://testserver.com');\n    this.socket.onopen = this.WebSocket.onopen;\n    this.socket.onmessage = this.WebSocket.onmessage;\n  };\n\n  this.connectToServer();\n}\n\nconst testManager = new TestManager();\n```",
      "```javascript\nfunction TestManager() {\n  this.socket = null;\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.processQueue = function() {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.openTestWindow(test);\n    }\n  };\n\n  this.openTestWindow = function(test) {\n    this.numRunning++;\n    window.open(test.url, '_blank');\n    this.socket.send(JSON.stringify({\n      type: 'start',\n      subscriptionKey: this.subscriptionKey,\n      testId: test.id\n    }));\n  };\n\n  this.onOpen = function() {\n    console.log('WebSocket connection established');\n  };\n\n  this.onMessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'result') {\n      this.displayResult(data);\n    } else if (data.type === 'status') {\n      this.displayStatus(data);\n    }\n  };\n\n  this.displayResult = function(data) {\n    const resultElement = document.getElementById('result-' + data.testId);\n    if (resultElement) {\n      resultElement.textContent = 'Test ' + data.testId + ' completed with status: ' + data.status;\n    } else {\n      const resultDiv = document.createElement('div');\n      resultDiv.id = 'result-' + data.testId;\n      resultDiv.textContent = 'Test ' + data.testId + ' completed with status: ' + data.status;\n      document.body.appendChild(resultDiv);\n    }\n  };\n\n  this.displayStatus = function(data) {\n    const statusElement = document.getElementById('status-' + data.testId);\n    if (statusElement) {\n      statusElement.textContent = 'Test ' + data.testId + ' status: ' + data.status;\n    } else {\n      const statusDiv = document.createElement('div');\n      statusDiv.id = 'status-' + data.testId;\n      statusDiv.textContent = 'Test ' + data.testId + ' status: ' + data.status;\n      document.body.appendChild(statusDiv);\n    }\n  };\n\n  this.connectToServer = function() {\n    this.socket = new WebSocket('wss://testserver.com');\n    this.socket.onopen = this.onOpen;\n    this.socket.onmessage = this.onMessage;\n  };\n\n  this.connectToServer();\n}\n\nconst testManager = new TestManager();\n```",
      "```javascript\nfunction TestManager() {\n  this.socket = null;\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.processQueue = function() {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.openTestWindow(test);\n    }\n  };\n\n  this.openTestWindow = function(test) {\n    this.numRunning++;\n    window.open(test.url, 'testWindow' + this.numRunning);\n  };\n\n  this.onOpen = function() {\n    console.log('WebSocket connection established');\n  };\n\n  this.onMessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'result') {\n      this.displayResult(data);\n    } else if (data.type === 'status') {\n      this.displayStatus(data);\n    }\n  };\n\n  this.displayResult = function(data) {\n    const resultElement = document.getElementById('result' + data.testId);\n    if (resultElement) {\n      resultElement.textContent = data.result;\n    } else {\n      const resultDiv = document.createElement('div');\n      resultDiv.id = 'result' + data.testId;\n      resultDiv.textContent = data.result;\n      document.body.appendChild(resultDiv);\n    }\n  };\n\n  this.displayStatus = function(data) {\n    const statusElement = document.getElementById('status' + data.testId);\n    if (statusElement) {\n      statusElement.textContent = data.status;\n    } else {\n      const statusDiv = document.createElement('div');\n      statusDiv.id = 'status' + data.testId;\n      statusDiv.textContent = data.status;\n      document.body.appendChild(statusDiv);\n    }\n  };\n\n  this.connect = function() {\n    this.socket = new WebSocket('wss://testserver.com');\n    this.socket.onopen = this.onOpen;\n    this.socket.onmessage = this.onMessage;\n  };\n\n  this.connect();\n}\n\nconst testManager = new TestManager();\n```",
      "```javascript\nfunction TestManager() {\n  this.socket = null;\n  this.maxParallelRuns = 5;\n  this.subscriptionKey = Math.floor(Math.random() * 1000000);\n  this.queue = [];\n  this.numRunning = 0;\n\n  this.processQueue = function() {\n    while (this.numRunning < this.maxParallelRuns && this.queue.length > 0) {\n      const test = this.queue.shift();\n      this.openTestWindow(test);\n    }\n  };\n\n  this.openTestWindow = function(test) {\n    this.numRunning++;\n    window.open(test.url, 'testWindow' + this.numRunning);\n  };\n\n  this.WebSocket = {\n    onopen: function(event) {\n      console.log('WebSocket connection established');\n    },\n    onmessage: function(event) {\n      const data = JSON.parse(event.data);\n      if (data.type === 'result') {\n        this.handleResult(data);\n      } else if (data.type === 'status') {\n        this.handleStatus(data);\n      }\n    },\n    handleResult: function(data) {\n      console.log('Test Result:', data.result);\n      this.numRunning--;\n      this.processQueue();\n    },\n    handleStatus: function(data) {\n      console.log('Test Status:', data.status);\n    }\n  };\n\n  this.connectToServer = function() {\n    this.socket = new WebSocket('wss://testserver.com');\n    this.socket.onopen = this.WebSocket.onopen;\n    this.socket.onmessage = this.WebSocket.onmessage;\n  };\n\n  this.connectToServer();\n}\n\nconst testManager = new TestManager();\n```"
    ],
    "match_count": 4,
    "pass@3": 0.8333333333333334,
    "pass@5": 0.9761904761904762
  },
  {
    "Task_id": 206,
    "Instruction": "The provided reference code is at the function level, so I'll structure the instruction accordingly:\n\nTask Description: Implement a WebSocket client that automatically reconnects on connection loss and triggers a page reload when receiving a message.\n\nFunction Description: The function establishes a WebSocket connection to the specified URL. It handles connection closure by automatically attempting to reconnect after a delay (2 seconds). When a message is received through the WebSocket, it triggers a full page reload. This is useful for implementing live-reload functionality during development or for real-time updates in web applications.\n\nInput: \n- a: [String] - The WebSocket server URL to connect to (e.g., \"ws://localhost:8080\")\n\nOutput: \n- None (the function doesn't return anything, but has side effects of managing WebSocket connection and page reloading)",
    "Canonical_solution": "function b(a) {\n    var c = new WebSocket(a);\n    c.onclose = function() {\n        setTimeout(function() {\n            b(a)\n        }, 2E3)\n    };\n    c.onmessage = function() {\n        location.reload()\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('Connected to the WebSocket server');\n};\n\nws.onmessage = function(event) {\n  window.location.reload();\n};\n\nws.onclose = function() {\n  setTimeout(function() {\n    console.log('Attempting to reconnect...');\n    ws = new WebSocket(a);\n  }, 2000);\n};\n```",
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  window.location.reload();\n};\n\nws.onclose = function() {\n  setTimeout(() => {\n    console.log('WebSocket connection closed, attempting to reconnect...');\n    ws.connect(a);\n  }, 2000);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n```",
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('Connected to the WebSocket server');\n};\n\nws.onmessage = function(event) {\n  window.location.reload();\n};\n\nws.onclose = function() {\n  setTimeout(function() {\n    console.log('Attempting to reconnect...');\n    ws = new WebSocket(a);\n  }, 2000);\n};\n```",
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('Connected to the WebSocket server');\n};\n\nws.onmessage = function(event) {\n  window.location.reload();\n};\n\nws.onclose = function() {\n  setTimeout(function() {\n    console.log('Attempting to reconnect...');\n    ws = new WebSocket(a);\n  }, 2000);\n};\n```",
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('Connected to the WebSocket server');\n};\n\nws.onmessage = function(event) {\n  window.location.reload();\n};\n\nws.onclose = function() {\n  setTimeout(function() {\n    console.log('Attempting to reconnect...');\n    ws = new WebSocket(a);\n  }, 2000);\n};\n```",
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('Connected to the WebSocket server');\n};\n\nws.onmessage = function(event) {\n  window.location.reload();\n};\n\nws.onclose = function() {\n  setTimeout(function() {\n    console.log('Attempting to reconnect...');\n    ws = new WebSocket(a);\n  }, 2000);\n};\n```",
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('Connected to the WebSocket server');\n};\n\nws.onmessage = function(event) {\n  console.log('Message received:', event.data);\n  window.location.reload();\n};\n\nws.onclose = function() {\n  console.log('Connection closed. Attempting to reconnect...');\n  setTimeout(function() {\n    ws = new WebSocket(a);\n  }, 2000);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n  ws.close();\n};\n```",
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('Connected to the WebSocket server');\n};\n\nws.onmessage = function(event) {\n  window.location.reload();\n};\n\nws.onclose = function() {\n  setTimeout(function() {\n    console.log('Attempting to reconnect...');\n    ws = new WebSocket(a);\n  }, 2000);\n};\n```",
      "```javascript\nfunction createWebSocketClient(a) {\n    let ws;\n    const reconnectDelay = 2000;\n\n    function connect() {\n        ws = new WebSocket(a);\n        ws.onopen = function() {\n            console.log('WebSocket connection established');\n        };\n        ws.onmessage = function(event) {\n            window.location.reload();\n        };\n        ws.onclose = function() {\n            console.log('WebSocket connection closed. Attempting to reconnect...');\n            setTimeout(connect, reconnectDelay);\n        };\n        ws.onerror = function(error) {\n            console.error('WebSocket error:', error);\n            ws.close();\n        };\n    }\n\n    connect();\n}\n```",
      "```javascript\nconst ws = new WebSocket(a);\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  window.location.reload();\n};\n\nws.onclose = function() {\n  setTimeout(() => {\n    console.log('WebSocket connection lost. Attempting to reconnect...');\n    ws = new WebSocket(a);\n  }, 2000);\n};\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 207,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles real-time communication with a server, including connection management, message handling, and error recovery.\n\nClass Description: The WebSocketClient class manages WebSocket connections to a server, providing methods to open/close connections, send messages, and handle various WebSocket events. It includes automatic reconnection logic and heartbeat mechanism to maintain connection.\n\nAttributes:\n- websocket: [WebSocket] - The WebSocket connection instance\n- wxErrorCount: [Number] - Counter for tracking connection errors\n- updateUrl: [String] - Base URL for WebSocket connection\n- gridKey: [String] - Identifier for the grid/session\n- retryTimer: [Number] - Timer ID for the heartbeat interval\n\nMethods:\n- constructor(updateUrl, gridKey) -> [WebSocketClient] - Initializes the WebSocket client with connection URL and grid key\n- openWebSocket() -> [void] - Establishes WebSocket connection and sets up event handlers\n- sendMessage(data) -> [void] - Sends compressed data through the WebSocket connection\n- closeConnection() -> [void] - Properly closes the WebSocket connection\n\nEvent Handlers:\n- onopen: [Function] - Handles connection establishment\n- onmessage: [Function] - Processes incoming messages from server\n- onerror: [Function] - Manages connection errors with retry logic\n- onclose: [Function] - Handles connection closure scenarios",
    "Canonical_solution": "import pako from 'pako';\n\nclass WebSocketClient {\n    constructor(updateUrl, gridKey) {\n        this.websocket = null;\n        this.wxErrorCount = 0;\n        this.updateUrl = updateUrl;\n        this.gridKey = gridKey;\n    }\n\n    openWebSocket() {\n        let _this = this;\n\n        if('WebSocket' in window) {\n            let wxUrl = _this.updateUrl + \"?t=111&g=\" + encodeURIComponent(_this.gridKey);\n            if(_this.updateUrl.indexOf('?') > -1) {\n                wxUrl = _this.updateUrl + \"&t=111&g=\" + encodeURIComponent(_this.gridKey);\n            }\n\n            _this.websocket = new WebSocket(wxUrl);\n\n            // Connection established\n            _this.websocket.onopen = function() {\n                console.info(locale().websocket.success);\n                hideloading();\n                _this.wxErrorCount = 0;\n\n                // Prevent WebSocket from disconnecting due to inactivity\n                _this.retryTimer = setInterval(function() {\n                    _this.websocket.send(\"rub\");\n                }, 60000);\n            }\n\n            // Client receives server data\n            _this.websocket.onmessage = function(result) {\n                Store.result = result;\n                let data = new Function(\"return \" + result.data)();\n                method.createHookFunction('cooperativeMessage', data);\n                console.info(data);\n                let type = data.type;\n                let {message, id} = data;\n                \n                // Handle different message types\n                if(message === 'ç”¨æˆ·é€€å‡º') {\n                    $(\"#luckysheet-multipleRange-show-\" + id).hide();\n                    Store.cooperativeEdit.changeCollaborationSize = Store.cooperativeEdit.changeCollaborationSize.filter(value => {\n                        return value.id != id\n                    });\n                    Store.cooperativeEdit.checkoutData = Store.cooperativeEdit.checkoutData.filter(value => {\n                        return value.id != id\n                    });\n                }\n                \n                // Handle different message types (1: send success/failure, 2: update data, etc.)\n                // ... (rest of the message handling logic)\n            }\n\n            // Communication error occurred\n            _this.websocket.onerror = function() {\n                _this.wxErrorCount++;\n\n                if(_this.wxErrorCount > 3) {\n                    showloading(locale().websocket.refresh);\n                } else {\n                    showloading(locale().websocket.wait);\n                    _this.openWebSocket();\n                }\n            }\n\n            // Connection closed\n            _this.websocket.onclose = function(e) {\n                console.info(locale().websocket.close);\n                if(e.code === 1000) {\n                    clearInterval(_this.retryTimer);\n                    _this.retryTimer = null;\n                } else {\n                    alert(locale().websocket.contact);\n                }\n            }\n        } else {\n            alert(locale().websocket.support);\n        }\n    }\n\n    sendMessage(data) {\n        if(this.websocket != null) {\n            let msg = pako.gzip(encodeURIComponent(JSON.stringify(data)), {to: \"string\"});\n            this.websocket.send(msg);\n        }\n    }\n\n    closeConnection() {\n        if(this.websocket != null) {\n            this.websocket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WebSocketClient {\n    constructor(updateUrl, gridKey) {\n        this.websocket = null;\n        this.wxErrorCount = 0;\n        this.updateUrl = updateUrl;\n        this.gridKey = gridKey;\n        this.retryTimer = null;\n    }\n\n    openWebSocket() {\n        const ws = new WebSocket(this.updateUrl);\n        this.websocket = ws;\n        ws.onopen = this.onopen.bind(this);\n        ws.onmessage = this.onmessage.bind(this);\n        ws.onerror = this.onerror.bind(this);\n        ws.onclose = this.onclose.bind(this);\n    }\n\n    sendMessage(data) {\n        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n            this.websocket.send(data);\n        }\n    }\n\n    closeConnection() {\n        if (this.websocket) {\n            this.websocket.close();\n        }\n    }\n\n    onopen() {\n        this.wxErrorCount = 0;\n        this.retryTimer = null;\n        console.log('WebSocket connection established');\n    }\n\n    onmessage(event) {\n        console.log('Message from server:', event.data);\n    }\n\n    onerror(event) {\n        this.wxErrorCount++;\n        console.error('WebSocket error:', event);\n        if (this.wxErrorCount < 3) {\n            setTimeout(() => this.openWebSocket(), 2000);\n        } else {\n            console.error('Too many errors, not retrying');\n        }\n    }\n\n    onclose() {\n        console.log('WebSocket connection closed');\n        if (this.retryTimer) {\n            clearTimeout(this.retryTimer);\n        }\n        this.retryTimer = setTimeout(() => this.openWebSocket(), 2000);\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(updateUrl, gridKey) {\n    this.websocket = null;\n    this.wxErrorCount = 0;\n    this.updateUrl = updateUrl;\n    this.gridKey = gridKey;\n    this.retryTimer = null;\n  }\n\n  openWebSocket() {\n    const wsUrl = `${this.updateUrl}?gridKey=${this.gridKey}`;\n    this.websocket = new WebSocket(wsUrl);\n\n    this.websocket.onopen = () => {\n      this.wxErrorCount = 0;\n      clearInterval(this.retryTimer);\n    };\n\n    this.websocket.onmessage = (event) => {\n      // Handle incoming messages\n    };\n\n    this.websocket.onerror = (error) => {\n      this.wxErrorCount++;\n      if (this.wxErrorCount >= 3) {\n        this.openWebSocket();\n      }\n    };\n\n    this.websocket.onclose = () => {\n      this.wxErrorCount = 0;\n      this.retryTimer = setInterval(() => {\n        this.openWebSocket();\n      }, 5000);\n    };\n  }\n\n  sendMessage(data) {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.send(data);\n    }\n  }\n\n  closeConnection() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(updateUrl, gridKey) {\n    this.websocket = null;\n    this.wxErrorCount = 0;\n    this.updateUrl = updateUrl;\n    this.gridKey = gridKey;\n    this.retryTimer = null;\n  }\n\n  openWebSocket() {\n    const wsUrl = `${this.updateUrl}?gridKey=${this.gridKey}`;\n    this.websocket = new WebSocket(wsUrl);\n\n    this.websocket.onopen = () => {\n      this.wxErrorCount = 0;\n      clearTimeout(this.retryTimer);\n      console.log('WebSocket connection established');\n    };\n\n    this.websocket.onmessage = (event) => {\n      console.log('Message received:', event.data);\n    };\n\n    this.websocket.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      this.wxErrorCount++;\n      if (this.wxErrorCount >= 3) {\n        this.closeConnection();\n        this.retryTimer = setTimeout(() => this.openWebSocket(), 5000);\n      }\n    };\n\n    this.websocket.onclose = () => {\n      console.log('WebSocket connection closed');\n      this.wxErrorCount++;\n      if (this.wxErrorCount >= 3) {\n        this.retryTimer = setTimeout(() => this.openWebSocket(), 5000);\n      }\n    };\n  }\n\n  sendMessage(data) {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.send(data);\n    } else {\n      console.error('WebSocket is not open');\n    }\n  }\n\n  closeConnection() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(updateUrl, gridKey) {\n    this.websocket = null;\n    this.wxErrorCount = 0;\n    this.updateUrl = updateUrl;\n    this.gridKey = gridKey;\n    this.retryTimer = null;\n  }\n\n  openWebSocket() {\n    const wsUrl = `${this.updateUrl}?gridKey=${this.gridKey}`;\n    this.websocket = new WebSocket(wsUrl);\n\n    this.websocket.onopen = () => {\n      this.wxErrorCount = 0;\n      clearInterval(this.retryTimer);\n    };\n\n    this.websocket.onmessage = (event) => {\n      // Process incoming messages\n    };\n\n    this.websocket.onerror = (error) => {\n      this.wxErrorCount++;\n      if (this.wxErrorCount >= 3) {\n        this.openWebSocket();\n      }\n    };\n\n    this.websocket.onclose = () => {\n      this.wxErrorCount = 0;\n      this.retryTimer = setInterval(() => {\n        this.openWebSocket();\n      }, 5000);\n    };\n  }\n\n  sendMessage(data) {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.send(data);\n    }\n  }\n\n  closeConnection() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(updateUrl, gridKey) {\n    this.websocket = null;\n    this.wxErrorCount = 0;\n    this.updateUrl = updateUrl;\n    this.gridKey = gridKey;\n    this.retryTimer = null;\n  }\n\n  openWebSocket() {\n    const wsUrl = `${this.updateUrl}?gridKey=${this.gridKey}`;\n    this.websocket = new WebSocket(wsUrl);\n\n    this.websocket.onopen = () => {\n      this.wxErrorCount = 0;\n      clearInterval(this.retryTimer);\n      this.onopen();\n    };\n\n    this.websocket.onmessage = (event) => {\n      this.onmessage(event.data);\n    };\n\n    this.websocket.onerror = (error) => {\n      this.wxErrorCount++;\n      this.onerror(error);\n    };\n\n    this.websocket.onclose = (event) => {\n      this.onclose(event);\n    };\n  }\n\n  sendMessage(data) {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.send(data);\n    }\n  }\n\n  closeConnection() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n\n  onopen() {}\n\n  onmessage(data) {}\n\n  onerror(error) {\n    if (this.wxErrorCount < 3) {\n      this.retryTimer = setTimeout(() => {\n        this.openWebSocket();\n      }, 5000);\n    }\n  }\n\n  onclose(event) {\n    if (this.retryTimer) {\n      clearInterval(this.retryTimer);\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(updateUrl, gridKey) {\n        this.websocket = null;\n        this.wxErrorCount = 0;\n        this.updateUrl = updateUrl;\n        this.gridKey = gridKey;\n        this.retryTimer = null;\n    }\n\n    openWebSocket() {\n        const ws = new WebSocket(this.updateUrl);\n        this.websocket = ws;\n        this.websocket.onopen = this.onopen.bind(this);\n        this.websocket.onmessage = this.onmessage.bind(this);\n        this.websocket.onerror = this.onerror.bind(this);\n        this.websocket.onclose = this.onclose.bind(this);\n    }\n\n    sendMessage(data) {\n        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n            this.websocket.send(data);\n        }\n    }\n\n    closeConnection() {\n        if (this.websocket) {\n            this.websocket.close();\n        }\n    }\n\n    onopen() {\n        this.wxErrorCount = 0;\n        this.retryTimer = null;\n        // Heartbeat mechanism can be implemented here\n    }\n\n    onmessage(event) {\n        // Process incoming messages\n    }\n\n    onerror(event) {\n        this.wxErrorCount++;\n        if (this.wxErrorCount < 3) {\n            setTimeout(() => this.openWebSocket(), 2000);\n        } else {\n            // Additional error handling can be implemented here\n        }\n    }\n\n    onclose() {\n        if (this.retryTimer) {\n            clearTimeout(this.retryTimer);\n        }\n        this.wxErrorCount = 0;\n        // Reconnection logic can be implemented here\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(updateUrl, gridKey) {\n    this.websocket = null;\n    this.wxErrorCount = 0;\n    this.updateUrl = updateUrl;\n    this.gridKey = gridKey;\n    this.retryTimer = null;\n  }\n\n  openWebSocket() {\n    const wsUrl = `${this.updateUrl}?gridKey=${this.gridKey}`;\n    this.websocket = new WebSocket(wsUrl);\n\n    this.websocket.onopen = () => {\n      this.wxErrorCount = 0;\n      clearInterval(this.retryTimer);\n    };\n\n    this.websocket.onmessage = (event) => {\n      // Process incoming messages\n    };\n\n    this.websocket.onerror = (error) => {\n      this.wxErrorCount++;\n      if (this.wxErrorCount >= 3) {\n        this.openWebSocket();\n      }\n    };\n\n    this.websocket.onclose = () => {\n      this.wxErrorCount = 0;\n      this.retryTimer = setInterval(() => {\n        this.openWebSocket();\n      }, 5000);\n    };\n  }\n\n  sendMessage(data) {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.send(data);\n    }\n  }\n\n  closeConnection() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(updateUrl, gridKey) {\n        this.websocket = null;\n        this.wxErrorCount = 0;\n        this.updateUrl = updateUrl;\n        this.gridKey = gridKey;\n        this.retryTimer = null;\n    }\n\n    openWebSocket() {\n        const wsUrl = `${this.updateUrl}?gridKey=${this.gridKey}`;\n        this.websocket = new WebSocket(wsUrl);\n\n        this.websocket.onopen = this.onopen.bind(this);\n        this.websocket.onmessage = this.onmessage.bind(this);\n        this.websocket.onerror = this.onerror.bind(this);\n        this.websocket.onclose = this.onclose.bind(this);\n    }\n\n    sendMessage(data) {\n        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n            this.websocket.send(data);\n        }\n    }\n\n    closeConnection() {\n        if (this.websocket) {\n            this.websocket.close();\n        }\n    }\n\n    onopen() {\n        this.wxErrorCount = 0;\n        this.startHeartbeat();\n    }\n\n    onmessage(event) {\n        // Process incoming message\n    }\n\n    onerror(event) {\n        this.wxErrorCount++;\n        if (this.wxErrorCount < 3) {\n            this.reconnect();\n        } else {\n            console.error('WebSocket error:', event);\n        }\n    }\n\n    onclose() {\n        this.wxErrorCount = 0;\n        this.stopHeartbeat();\n        this.reconnect();\n    }\n\n    reconnect() {\n        clearTimeout(this.retryTimer);\n        this.retryTimer = setTimeout(() => {\n            this.openWebSocket();\n        }, 5000);\n    }\n\n    startHeartbeat() {\n        this.heartbeat();\n        this.retryTimer = setInterval(this.heartbeat.bind(this), 30000);\n    }\n\n    stopHeartbeat() {\n        clearInterval(this.retryTimer);\n    }\n\n    heartbeat() {\n        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n            this.websocket.send('heartbeat');\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(updateUrl, gridKey) {\n    this.websocket = null;\n    this.wxErrorCount = 0;\n    this.updateUrl = updateUrl;\n    this.gridKey = gridKey;\n    this.retryTimer = null;\n  }\n\n  openWebSocket() {\n    const wsUrl = `${this.updateUrl}?gridKey=${this.gridKey}`;\n    this.websocket = new WebSocket(wsUrl);\n\n    this.websocket.onopen = () => {\n      this.wxErrorCount = 0;\n      this.onopen();\n    };\n\n    this.websocket.onmessage = (event) => {\n      this.onmessage(event.data);\n    };\n\n    this.websocket.onerror = (error) => {\n      this.onerror(error);\n    };\n\n    this.websocket.onclose = (event) => {\n      this.onclose(event);\n    };\n  }\n\n  sendMessage(data) {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.send(data);\n    }\n  }\n\n  closeConnection() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n\n  onopen() {}\n\n  onmessage(data) {}\n\n  onerror(error) {\n    this.wxErrorCount++;\n    if (this.wxErrorCount < 3) {\n      setTimeout(() => this.openWebSocket(), 2000);\n    } else {\n      this.wxErrorCount = 0;\n      this.onclose();\n    }\n  }\n\n  onclose(event) {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n    }\n    this.retryTimer = setTimeout(() => this.openWebSocket(), 20000);\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(updateUrl, gridKey) {\n    this.websocket = null;\n    this.wxErrorCount = 0;\n    this.updateUrl = updateUrl;\n    this.gridKey = gridKey;\n    this.retryTimer = null;\n  }\n\n  openWebSocket() {\n    const wsUrl = `${this.updateUrl}?gridKey=${this.gridKey}`;\n    this.websocket = new WebSocket(wsUrl);\n\n    this.websocket.onopen = () => {\n      this.wxErrorCount = 0;\n      clearInterval(this.retryTimer);\n    };\n\n    this.websocket.onmessage = (event) => {\n      // Process incoming messages\n    };\n\n    this.websocket.onerror = (error) => {\n      this.wxErrorCount++;\n      if (this.wxErrorCount >= 3) {\n        this.closeConnection();\n        this.retryTimer = setInterval(() => this.openWebSocket(), 5000);\n      }\n    };\n\n    this.websocket.onclose = () => {\n      // Handle connection closure scenarios\n    };\n  }\n\n  sendMessage(data) {\n    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {\n      this.websocket.send(data);\n    }\n  }\n\n  closeConnection() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Implement a WebSocket transport class for establishing and managing WebSocket connections in a browser or Node.js environment, supporting both binary and text data transmission with configurable options.\n\nClass Description: The WS class extends a base Transport class to provide WebSocket-specific functionality. It handles connection establishment, message transmission, error handling, and connection cleanup, with support for various WebSocket options like binary data, compression, and security settings.\n\nAttributes:\n- supportsBinary: Boolean - Indicates whether the connection supports binary data transmission\n- perMessageDeflate: Object - Configuration for message compression\n- ws: WebSocket - The underlying WebSocket connection instance\n- writable: Boolean - Indicates if the connection is ready to send data\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the WebSocket transport with configuration options\n- doOpen() -> void - Establishes the WebSocket connection and sets up event listeners\n- addEventListeners() -> void - Attaches event handlers for connection events (open, close, message, error)\n- write(packets: Array) -> void - Encodes and sends multiple packets through the WebSocket connection\n- onClose() -> void - Handles connection closure and cleans up resources\n- doClose() -> void - Explicitly closes the WebSocket connection\n- uri() -> String - Generates the WebSocket connection URI with query parameters\n- check() -> Boolean - Verifies WebSocket availability and compatibility\n\nInput:\n- opts: Object - Configuration options including:\n  - forceBase64: Boolean - Forces base64 encoding if binary not supported\n  - perMessageDeflate: Object - Compression settings\n  - agent: Object - Custom HTTP agent\n  - pfx: String - SSL PFX certificate\n  - key: String - SSL key\n  - passphrase: String - SSL passphrase\n  - cert: String - SSL certificate\n  - ca: Array - SSL certificate authorities\n  - ciphers: String - SSL cipher suite\n  - rejectUnauthorized: Boolean - SSL verification setting\n  - extraHeaders: Object - Additional HTTP headers\n  - secure: Boolean - Use secure protocol (wss)\n  - port: Number - Custom port number\n  - timestampRequests: Boolean - Add timestamp to requests\n  - timestampParam: String - Parameter name for timestamp\n  - hostname: String - Server hostname\n  - path: String - WebSocket endpoint path\n  - query: Object - Additional query parameters\n\nOutput:\n- Instance of WS class with established WebSocket connection and configured event handlers",
    "Canonical_solution": "var Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  try {\n    WebSocket = require('ws');\n  } catch (e) { }\n}\n\nfunction WS(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  Transport.call(this, opts);\n}\n\ninherit(WS, Transport);\n\nWS.prototype.name = 'websocket';\nWS.prototype.supportsBinary = true;\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    return;\n  }\n\n  var self = this;\n  var uri = this.uri();\n  var protocols = void(0);\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n\n  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'buffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\nWS.prototype.addEventListeners = function(){\n  var self = this;\n\n  this.ws.onopen = function(){\n    self.onOpen();\n  };\n  this.ws.onclose = function(){\n    self.onClose();\n  };\n  this.ws.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function(packet) {\n      parser.encodePacket(packet, self.supportsBinary, function(data) {\n        if (!BrowserWebSocket) {\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        try {\n          if (BrowserWebSocket) {\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e){\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done(){\n    self.emit('flush');\n    setTimeout(function(){\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\nWS.prototype.onClose = function(){\n  Transport.prototype.onClose.call(this);\n};\n\nWS.prototype.doClose = function(){\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\nWS.prototype.check = function(){\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary;\n    this.perMessageDeflate = opts.perMessageDeflate;\n    this.ws = null;\n    this.writable = false;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.getProtocol());\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n      this.emit('open');\n    };\n    this.ws.onclose = (event) => {\n      this.onClose(event);\n    };\n    this.ws.onmessage = (event) => {\n      this.emit('message', event.data);\n    };\n    this.ws.onerror = (event) => {\n      this.emit('error', event);\n    };\n  }\n\n  write(packets) {\n    packets.forEach((packet) => {\n      if (this.supportsBinary) {\n        this.ws.binaryType = 'arraybuffer';\n        this.ws.send(packet);\n      } else {\n        this.ws.send(JSON.stringify(packet));\n      }\n    });\n  }\n\n  onClose(event) {\n    this.writable = false;\n    this.emit('close', event);\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const base = `${this.hostname}:${this.port}`;\n    const path = this.path || '/';\n    const secure = this.secure ? 'wss' : 'ws';\n    const query = Object.keys(this.query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(this.query[key])}`).join('&');\n    return `${secure}://${base}${path}?${query}`;\n  }\n\n  check() {\n    return this.ws.readyState === WebSocket.OPEN;\n  }\n\n  getProtocol() {\n    if (this.secure) {\n      return 'wss';\n    }\n    return 'ws';\n  }\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary;\n    this.perMessageDeflate = opts.perMessageDeflate;\n    this.ws = null;\n    this.writable = false;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.getProtocol());\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n      this.emit('open');\n    };\n    this.ws.onclose = (event) => {\n      this.onClose(event);\n    };\n    this.ws.onmessage = (event) => {\n      this.emit('message', event.data);\n    };\n    this.ws.onerror = (event) => {\n      this.emit('error', event);\n    };\n  }\n\n  write(packets) {\n    packets.forEach((packet) => {\n      if (this.supportsBinary && packet.isBinary) {\n        this.ws.binaryType = 'arraybuffer';\n        this.ws.send(packet.data);\n      } else {\n        this.ws.send(packet.data);\n      }\n    });\n  }\n\n  onClose(event) {\n    this.writable = false;\n    this.emit('close', event);\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const base = `${this.hostname}:${this.port}`;\n    const path = this.path || '/';\n    const secure = this.secure ? 'wss' : 'ws';\n    const query = Object.keys(this.query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(this.query[key])}`).join('&');\n    return `${secure}://${base}${path}?${query}`;\n  }\n\n  check() {\n    try {\n      new WebSocket(this.uri());\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  getProtocol() {\n    const protocols = [];\n    if (this.supportsBinary) {\n      protocols.push('binary');\n    }\n    if (this.perMessageDeflate) {\n      protocols.push('deflate-frame');\n    }\n    return protocols.length ? protocols.join(',') : null;\n  }\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary;\n    this.perMessageDeflate = opts.perMessageDeflate;\n    this.ws = null;\n    this.writable = false;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n    };\n    this.ws.onclose = () => {\n      this.onClose();\n    };\n    this.ws.onmessage = (event) => {\n      this.handleMessage(event);\n    };\n    this.ws.onerror = (error) => {\n      this.handleError(error);\n    };\n  }\n\n  write(packets) {\n    if (this.writable) {\n      packets.forEach((packet) => {\n        this.ws.send(packet);\n      });\n    }\n  }\n\n  onClose() {\n    this.writable = false;\n    // Clean up resources if necessary\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const { hostname, path, query, secure } = this;\n    const protocol = secure ? 'wss' : 'ws';\n    const base = `${protocol}://${hostname}`;\n    const queryString = Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n    return `${base}${path}?${queryString}`;\n  }\n\n  check() {\n    // Implement WebSocket availability and compatibility check\n    return true;\n  }\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary || false;\n    this.perMessageDeflate = opts.perMessageDeflate || {};\n    this.ws = null;\n    this.writable = false;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.getProtocol());\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n      this.emit('open');\n    };\n    this.ws.onclose = (event) => {\n      this.onClose(event);\n    };\n    this.ws.onmessage = (event) => {\n      this.emit('message', event.data);\n    };\n    this.ws.onerror = (event) => {\n      this.emit('error', event);\n    };\n  }\n\n  write(packets) {\n    if (this.writable) {\n      packets.forEach((packet) => {\n        this.ws.send(packet, { binary: this.supportsBinary });\n      });\n    }\n  }\n\n  onClose(event) {\n    this.writable = false;\n    this.emit('close', event);\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const base = `${this.hostname}:${this.port}`;\n    const path = this.path || '/';\n    const secure = this.secure ? 'wss' : 'ws';\n    const query = this.query ? '?' + Object.keys(this.query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(this.query[key])}`).join('&') : '';\n    return `${secure}://${base}${path}${query}`;\n  }\n\n  check() {\n    return this.ws && this.ws.readyState === WebSocket.OPEN;\n  }\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary || false;\n    this.perMessageDeflate = opts.perMessageDeflate || {};\n    this.ws = null;\n    this.writable = false;\n    this.opts = opts;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n    };\n    this.ws.onclose = () => {\n      this.onClose();\n    };\n    this.ws.onmessage = (event) => {\n      this.onMessage(event);\n    };\n    this.ws.onerror = (error) => {\n      this.onError(error);\n    };\n  }\n\n  write(packets) {\n    if (this.writable) {\n      packets.forEach((packet) => {\n        if (this.supportsBinary && packet instanceof ArrayBuffer) {\n          this.ws.binaryType = 'arraybuffer';\n          this.ws.send(packet);\n        } else {\n          this.ws.send(JSON.stringify(packet));\n        }\n      });\n    }\n  }\n\n  onClose() {\n    this.writable = false;\n    // Cleanup resources if necessary\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const { hostname, port, path, query, secure } = this.opts;\n    const protocol = secure ? 'wss' : 'ws';\n    const base = `${protocol}://${hostname}:${port}`;\n    const queryString = Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n    return `${base}${path}?${queryString}`;\n  }\n\n  check() {\n    // Implement WebSocket availability and compatibility check\n    return true;\n  }\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary;\n    this.perMessageDeflate = opts.perMessageDeflate;\n    this.ws = null;\n    this.writable = false;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.getProtocol());\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n      this.emit('open');\n    };\n    this.ws.onclose = (event) => {\n      this.onClose(event);\n    };\n    this.ws.onmessage = (event) => {\n      this.emit('message', event.data);\n    };\n    this.ws.onerror = (event) => {\n      this.emit('error', event);\n    };\n  }\n\n  write(packets) {\n    packets.forEach(packet => {\n      if (this.supportsBinary) {\n        this.ws.binaryType = 'arraybuffer';\n        this.ws.send(packet);\n      } else {\n        this.ws.send(JSON.stringify(packet));\n      }\n    });\n  }\n\n  onClose(event) {\n    this.writable = false;\n    this.emit('close', event);\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const base = `${this.hostname}:${this.port}`;\n    const path = this.path || '/';\n    const secure = this.secure ? 'wss' : 'ws';\n    const query = Object.keys(this.query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(this.query[key])}`).join('&');\n    return `${secure}://${base}${path}?${query}`;\n  }\n\n  check() {\n    return this.ws.readyState === WebSocket.OPEN;\n  }\n\n  getProtocol() {\n    if (this.perMessageDeflate) {\n      return 'binary';\n    }\n    return null;\n  }\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary;\n    this.perMessageDeflate = opts.perMessageDeflate;\n    this.ws = null;\n    this.writable = false;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.getProtocol());\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n      this.emit('open');\n    };\n    this.ws.onclose = (event) => {\n      this.onClose(event);\n    };\n    this.ws.onmessage = (event) => {\n      this.emit('message', event.data);\n    };\n    this.ws.onerror = (event) => {\n      this.emit('error', event);\n    };\n  }\n\n  write(packets) {\n    packets.forEach(packet => {\n      const data = this.encode(packet);\n      this.ws.send(data);\n    });\n  }\n\n  onClose(event) {\n    this.writable = false;\n    this.emit('close', event);\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const { hostname, port, path, query, secure } = this.getOptions();\n    let uri = secure ? 'wss' : 'ws';\n    uri += '://' + hostname;\n    if (port) {\n      uri += ':' + port;\n    }\n    uri += path;\n    if (query) {\n      const queryParams = Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n      uri += '?' + queryParams;\n    }\n    return uri;\n  }\n\n  check() {\n    return typeof WebSocket !== 'undefined';\n  }\n\n  getOptions() {\n    const opts = this.getBaseOptions();\n    opts.hostname = opts.hostname || 'localhost';\n    opts.port = opts.port || (opts.secure ? 443 : 80);\n    opts.path = opts.path || '/';\n    return opts;\n  }\n\n  getBaseOptions() {\n    return {\n      forceBase64: this.opts.forceBase64,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      agent: this.opts.agent,\n      pfx: this.opts.pfx,\n      key: this.opts.key,\n      passphrase: this.opts.passphrase,\n      cert: this.opts.cert,\n      ca: this.opts.ca,\n      ciphers: this.opts.ciphers,\n      rejectUnauthorized: this.opts.rejectUnauthorized,\n      extraHeaders: this.opts.extraHeaders,\n      secure: this.opts.secure,\n      port: this.opts.port,\n      timestampRequests: this.opts.timestampRequests,\n      timestampParam: this.opts.timestampParam\n    };\n  }\n\n  getProtocol() {\n    const protocols = [];\n    if (this.opts.perMessageDeflate) {\n      protocols.push('permessage-deflate');\n    }\n    return protocols.length ? protocols.join(',') : '';\n  }\n\n  encode(packet) {\n    if (this.supportsBinary && packet instanceof ArrayBuffer) {\n      return packet;\n    } else if (this.opts.forceBase64 && typeof packet === 'string') {\n      return btoa(packet);\n    }\n    return packet;\n  }\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary || false;\n    this.perMessageDeflate = opts.perMessageDeflate || {};\n    this.ws = null;\n    this.writable = false;\n    this.opts = opts;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.opts.extraHeaders);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n    };\n    this.ws.onclose = () => {\n      this.onClose();\n    };\n    this.ws.onmessage = (event) => {\n      this.onMessage(event);\n    };\n    this.ws.onerror = (error) => {\n      this.onError(error);\n    };\n  }\n\n  write(packets) {\n    if (this.writable) {\n      packets.forEach((packet) => {\n        if (this.supportsBinary && packet instanceof ArrayBuffer) {\n          this.ws.binaryType = 'arraybuffer';\n          this.ws.send(packet);\n        } else {\n          this.ws.send(packet);\n        }\n      });\n    }\n  }\n\n  onClose() {\n    this.writable = false;\n    // Clean up resources if necessary\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const { hostname, path, query, secure } = this.opts;\n    const scheme = secure ? 'wss' : 'ws';\n    const base = `${scheme}://${hostname}`;\n    const pathWithQuery = `${path}?${queryToString(query)}`;\n    return `${base}${pathWithQuery}`;\n  }\n\n  check() {\n    // Implement WebSocket availability and compatibility check\n  }\n}\n\nfunction queryToString(query) {\n  return Object.keys(query)\n    .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`)\n    .join('&');\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary;\n    this.perMessageDeflate = opts.perMessageDeflate;\n    this.ws = null;\n    this.writable = false;\n  }\n\n  doOpen() {\n    this.ws = new WebSocket(this.uri());\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n    };\n    this.ws.onclose = () => {\n      this.onClose();\n    };\n    this.ws.onmessage = (event) => {\n      this.handleMessage(event);\n    };\n    this.ws.onerror = (error) => {\n      this.handleError(error);\n    };\n  }\n\n  write(packets) {\n    packets.forEach((packet) => {\n      if (this.supportsBinary) {\n        this.ws.send(packet);\n      } else {\n        this.ws.send(packet.toString());\n      }\n    });\n  }\n\n  onClose() {\n    this.writable = false;\n    // Clean up resources if necessary\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const { hostname, path, query, secure } = this;\n    let uri = `${secure ? 'wss' : 'ws'}://${hostname}${path}`;\n    if (query) {\n      uri += `?${Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&')}`;\n    }\n    return uri;\n  }\n\n  check() {\n    // Implement WebSocket availability and compatibility check\n    return true;\n  }\n}\n```",
      "```javascript\nclass WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.supportsBinary || false;\n    this.perMessageDeflate = opts.perMessageDeflate || {};\n    this.ws = null;\n    this.writable = false;\n  }\n\n  doOpen() {\n    const uri = this.uri();\n    this.ws = new WebSocket(uri);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.writable = true;\n    };\n    this.ws.onclose = () => {\n      this.onClose();\n    };\n    this.ws.onmessage = (event) => {\n      this.onMessage(event);\n    };\n    this.ws.onerror = (error) => {\n      this.onError(error);\n    };\n  }\n\n  write(packets) {\n    if (this.writable) {\n      packets.forEach(packet => {\n        if (this.supportsBinary && packet.isBinary) {\n          this.ws.binaryType = 'arraybuffer';\n          this.ws.send(packet.data);\n        } else {\n          this.ws.send(packet.data);\n        }\n      });\n    }\n  }\n\n  onClose() {\n    this.writable = false;\n    // Additional cleanup if necessary\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const { hostname, path, query, secure } = this;\n    const scheme = secure ? 'wss' : 'ws';\n    const base = `${scheme}://${hostname}`;\n    const queryString = Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n    return `${base}${path}?${queryString}`;\n  }\n\n  check() {\n    // Implementation to check WebSocket availability and compatibility\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 209,
    "Instruction": "Task Description: Implement a WebSocket-based RPC (Remote Procedure Call) client class in JavaScript that supports establishing connections, sending requests, handling responses, and managing event listeners.\n\nClass Description: The RPCWebSocket class provides a WebSocket client implementation for JSON-RPC 2.0 communication. It handles connection management, request/response patterns, and event-based notifications with automatic reconnection capabilities.\n\nAttributes:\n_namespace: String - The namespace prefix for all RPC methods\n_listeners: Object - Stores registered event listeners as key-value pairs\n_handles: Object - Tracks pending requests and their callbacks\n_socket: WebSocket - The underlying WebSocket connection instance\n\nMethods:\nconstructor(address, encryption, namespace) -> void - Initializes the WebSocket connection with the given address, encryption flag, and namespace prefix\n\nsetAddress(address, encryption) -> void - Sets or resets the WebSocket connection URL with optional encryption (wss/ws)\n\naddListener(method, callback) -> void - Registers a callback function for a specific method name\n\nremoveListener(method) -> void - Removes the listener for a specific method name\n\nrequest(method, params, id, successCallback, errorCallback) -> void - Sends a single JSON-RPC request with the given method, parameters, and callbacks\n\nbatchRequest(requests, successCallback, errorCallback) -> void - Sends multiple JSON-RPC requests in a batch with shared callbacks\n\n_formatData(method, params, id) -> Object - Formats the data into JSON-RPC 2.0 compliant structure\n\n_send(data) -> void - Internal method for sending data through the WebSocket connection with state handling\n\n_onerror(error, handles) -> void - Internal error handler that triggers all pending error callbacks\n\n_onmessage(message, handles, listeners) -> void - Internal message handler that processes responses and notifications",
    "Canonical_solution": "class RPCWebSocket {\n  constructor (address, encryption = false, namespace) {\n    this.namespace = namespace\n    this._listeners = {}\n    this.setAddress(address, encryption)\n  }\n\n  setAddress (address, encryption) {\n    this._handles = {}\n    if (typeof WebSocket !== 'function') throw Error('This client does not support WebSocket.')\n    else {\n      let url = (encryption ? 'wss://' : 'ws://') + address\n      try {\n        this._socket = new WebSocket(url)\n        let that = this\n        this._socket.onclose = event => {\n          setTimeout(() => {\n            if (that._socket.readyState > 1) that.setAddress(address, encryption)\n          }, 10000)\n        }\n        this._socket.onerror = error => that._onerror(error, that._handles)\n        this._socket.onmessage = message => that._onmessage(message, that._handles, that._listeners)\n      } catch (error) {\n        console.error(error.message)\n      }\n    }\n  }\n\n  addListener (method, callback) {\n    if (typeof callback === 'function') this._listeners[this.namespace + '.' + method] = callback\n  }\n\n  removeListener (method) {\n    delete this._listeners[this.namespace + '.' + method]\n  }\n\n  request (method, params = [], id, successCallback, errorCallback) {\n    this._handles[id] = {\n      success: successCallback,\n      error: errorCallback\n    }\n    let data = this._formatData(method, params, id)\n    this._send(data)\n  }\n\n  batchRequest (requests, successCallback, errorCallback) {\n    if (requests.constructor !== Array) requests = [requests]\n    requests.forEach(request => {\n      this._handles[request.id] = {\n        success: successCallback,\n        error: errorCallback\n      }\n    })\n    let data = requests.map(request => this._formatData(request.method, request.params, request.id))\n    this._send(data)\n  }\n\n  _formatData (method, params = [], id = '') {\n    return {\n      jsonrpc: '2.0',\n      id: id,\n      method: this.namespace + '.' + method,\n      params: params.constructor === Array ? params : [params]\n    }\n  }\n\n  _send (data) {\n    let that = this\n    let socket = this._socket\n    if (socket.readyState > 1) socket.onerror(Error('WebSocket is in state ' + socket.readyState + '.'))\n    else if (socket.readyState === 0) setTimeout(() => that._send(data), 1000)\n    else socket.send(JSON.stringify(data))\n  }\n\n  _onerror (error, handles) {\n    if (error.hasOwnProperty('message')) console.error(error.message)\n    Object.keys(handles).forEach(id => {\n      if (typeof handles[id].error === 'function') handles[id].error(error)\n      delete handles[id]\n    })\n  }\n\n  _onmessage (message, handles, listeners) {\n    let data = JSON.parse(message.data)\n    if (data.constructor === Array) {\n      data = data.reduce((last, cur) => {\n        if (last.hasOwnProperty(cur.id)) last[cur.id].push(cur)\n        else last[cur.id] = [cur]\n        return last\n      }, {})\n      for (let id in data) {\n        if (handles.hasOwnProperty(id)) {\n          if (typeof handles[id].success === 'function') handles[id].success(data[id])\n          delete handles[id]\n        }\n      }\n    } else if (data.hasOwnProperty('id')) {\n      if (handles.hasOwnProperty(data.id)) {\n        if (typeof handles[data.id].success === 'function') handles[data.id].success(data)\n        delete handles[data.id]\n      }\n    } else if (data.hasOwnProperty('method')) {\n      if (listeners.hasOwnProperty(data.method)) {\n        if (typeof listeners[data.method] === 'function') listeners[data.method](data)\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(address + (encryption ? 's' : '') + '://');\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    setAddress(address, encryption) {\n        this._socket.close();\n        this._socket = new WebSocket(address + (encryption ? 's' : '') + '://');\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        delete this._listeners[this._namespace + method];\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const request = this._formatData(method, params, id);\n        this._handles[id] = { successCallback, errorCallback };\n        this._send(request);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const batch = [];\n        let id = 1;\n        requests.forEach((request) => {\n            request.id = id++;\n            batch.push(this._formatData(request.method, request.params, request.id));\n            this._handles[request.id] = { successCallback, errorCallback };\n        });\n        this._send(batch);\n    }\n\n    _formatData(method, params, id) {\n        return {\n            jsonrpc: '2.0',\n            method: this._namespace + method,\n            params: params,\n            id: id\n        };\n    }\n\n    _send(data) {\n        if (this._socket.readyState === WebSocket.OPEN) {\n            this._socket.send(JSON.stringify(data));\n        } else {\n            this._handles[data.id] = { errorCallback: new Error('WebSocket not open') };\n        }\n    }\n\n    _onerror(error) {\n        for (const id in this._handles) {\n            this._handles[id].errorCallback(error);\n        }\n    }\n\n    _onmessage(message) {\n        let response;\n        try {\n            response = JSON.parse(message.data);\n        } catch (e) {\n            this._onerror(e);\n            return;\n        }\n\n        if (response.id) {\n            const handle = this._handles[response.id];\n            if (handle) {\n                if (response.error) {\n                    handle.errorCallback(response.error);\n                } else {\n                    handle.successCallback(response.result);\n                }\n                delete this._handles[response.id];\n            }\n        } else {\n            const method = response.method;\n            const listeners = this._listeners[this._namespace + method];\n            if (listeners) {\n                listeners.forEach((listener) => listener(response.params));\n            }\n        }\n    }\n\n    _onopen() {\n        // Reconnect logic can be implemented here if needed\n    }\n\n    _onclose() {\n        // Reconnect logic can be implemented here if needed\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(address + (encryption ? 's' : '') + '://');\n        this._socket.onopen = () => this._onopen();\n        this._socket.onmessage = (event) => this._onmessage(JSON.parse(event.data), this._handles, this._listeners);\n        this._socket.onerror = (error) => this._onerror(error, this._handles);\n        this._socket.onclose = () => this._onclose();\n    }\n\n    setAddress(address, encryption) {\n        this._socket = new WebSocket(address + (encryption ? 's' : '') + '://');\n        this._socket.onopen = () => this._onopen();\n        this._socket.onmessage = (event) => this._onmessage(JSON.parse(event.data), this._handles, this._listeners);\n        this._socket.onerror = (error) => this._onerror(error, this._handles);\n        this._socket.onclose = () => this._onclose();\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        delete this._listeners[this._namespace + method];\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const data = this._formatData(method, params, id);\n        this._handles[id] = { success: successCallback, error: errorCallback };\n        this._send(data);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const batch = { jsonrpc: '2.0', method: 'batch', params: requests, id: 'batch' };\n        this._handles[batch.id] = { success: successCallback, error: errorCallback };\n        this._send(batch);\n    }\n\n    _formatData(method, params, id) {\n        return { jsonrpc: '2.0', method: this._namespace + method, params: params, id: id };\n    }\n\n    _send(data) {\n        this._socket.send(JSON.stringify(data));\n    }\n\n    _onerror(error, handles) {\n        for (const id in handles) {\n            if (handles[id].error) {\n                handles[id].error(error);\n            }\n        }\n    }\n\n    _onmessage(message, handles, listeners) {\n        if (message.jsonrpc === '2.0') {\n            if (message.id) {\n                if (handles[message.id]) {\n                    if (message.error) {\n                        handles[message.id].error(message.error);\n                    } else {\n                        handles[message.id].success(message.result);\n                    }\n                    delete handles[message.id];\n                }\n            } else {\n                const method = message.method;\n                if (listeners[this._namespace + method]) {\n                    listeners[this._namespace + method].forEach(callback => callback(message.params));\n                }\n            }\n        }\n    }\n\n    _onopen() {\n        // Handle connection open\n    }\n\n    _onclose() {\n        // Handle connection close\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(address, encryption ? 'wss' : 'ws');\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    setAddress(address, encryption) {\n        this._socket = new WebSocket(address, encryption ? 'wss' : 'ws');\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        delete this._listeners[this._namespace + method];\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const data = this._formatData(method, params, id);\n        this._handles[id] = { success: successCallback, error: errorCallback };\n        this._send(data);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const data = requests.map(req => this._formatData(req.method, req.params, req.id));\n        this._handles = requests.reduce((acc, req) => {\n            acc[req.id] = { success: req.successCallback, error: req.errorCallback };\n            return acc;\n        }, {});\n        this._send({ jsonrpc: '2.0', method: 'batch', params: data });\n    }\n\n    _formatData(method, params, id) {\n        return {\n            jsonrpc: '2.0',\n            method: this._namespace + method,\n            params: params,\n            id: id\n        };\n    }\n\n    _send(data) {\n        if (this._socket.readyState === WebSocket.OPEN) {\n            this._socket.send(JSON.stringify(data));\n        }\n    }\n\n    _onerror(error) {\n        console.error('WebSocket Error:', error);\n        this._onerror(error, this._handles);\n    }\n\n    _onmessage(message) {\n        try {\n            const response = JSON.parse(message.data);\n            if (response.id) {\n                const handle = this._handles[response.id];\n                if (handle && handle.success) {\n                    handle.success(response.result);\n                }\n            } else {\n                const method = response.method;\n                const listeners = this._listeners[this._namespace + method];\n                if (listeners) {\n                    listeners.forEach(listener => listener(response.result));\n                }\n            }\n        } catch (e) {\n            console.error('Error parsing message:', e);\n        }\n    }\n\n    _onclose() {\n        console.log('WebSocket connection closed');\n        this._reconnect();\n    }\n\n    _reconnect() {\n        setTimeout(() => {\n            if (this._socket.readyState === WebSocket.CLOSED) {\n                this.setAddress(this._socket.url, this._socket.protocol === 'wss:');\n            }\n        }, 5000);\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(address, encryption ? 'wss' : 'ws');\n        this._socket.onopen = () => this._onopen();\n        this._socket.onmessage = (event) => this._onmessage(event.data);\n        this._socket.onerror = (error) => this._onerror(error);\n        this._socket.onclose = () => this._onclose();\n    }\n\n    setAddress(address, encryption) {\n        this._socket = new WebSocket(address, encryption ? 'wss' : 'ws');\n        this._socket.onopen = () => this._onopen();\n        this._socket.onmessage = (event) => this._onmessage(event.data);\n        this._socket.onerror = (error) => this._onerror(error);\n        this._socket.onclose = () => this._onclose();\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        delete this._listeners[this._namespace + method];\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const data = this._formatData(method, params, id);\n        this._handles[id] = { success: successCallback, error: errorCallback };\n        this._send(data);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const batch = requests.map((req) => {\n            const id = req.id || Date.now();\n            this._handles[id] = { success: successCallback, error: errorCallback };\n            return this._formatData(req.method, req.params, id);\n        });\n        this._send(batch);\n    }\n\n    _formatData(method, params, id) {\n        return {\n            jsonrpc: '2.0',\n            method: this._namespace + method,\n            params: params,\n            id: id\n        };\n    }\n\n    _send(data) {\n        if (this._socket.readyState === WebSocket.OPEN) {\n            this._socket.send(JSON.stringify(data));\n        }\n    }\n\n    _onerror(error) {\n        for (const id in this._handles) {\n            const handle = this._handles[id];\n            if (handle.error) {\n                handle.error(error);\n            }\n        }\n    }\n\n    _onmessage(message) {\n        try {\n            const response = JSON.parse(message);\n            if (response.id) {\n                const handle = this._handles[response.id];\n                if (handle && handle.success) {\n                    handle.success(response.result);\n                }\n            } else {\n                const method = response.method;\n                if (this._listeners[this._namespace + method]) {\n                    this._listeners[this._namespace + method].forEach(callback => callback(response.params));\n                }\n            }\n        } catch (error) {\n            this._onerror(error);\n        }\n    }\n\n    _onopen() {\n        // Handle reconnection logic if necessary\n    }\n\n    _onclose() {\n        // Handle disconnection logic if necessary\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(address, encryption ? 'wss' : 'ws');\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    setAddress(address, encryption) {\n        this._socket = new WebSocket(address, encryption ? 'wss' : 'ws');\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        delete this._listeners[this._namespace + method];\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const data = this._formatData(method, params, id);\n        this._handles[id] = { successCallback, errorCallback };\n        this._send(data);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const data = requests.map(req => this._formatData(req.method, req.params, req.id));\n        this._handles = Object.assign({}, this._handles, requests.reduce((acc, req) => {\n            acc[req.id] = { successCallback, errorCallback };\n            return acc;\n        }, {}));\n        this._send({ jsonrpc: '2.0', method: 'batch', params: data });\n    }\n\n    _formatData(method, params, id) {\n        return {\n            jsonrpc: '2.0',\n            method: this._namespace + method,\n            params: params,\n            id: id\n        };\n    }\n\n    _send(data) {\n        if (this._socket.readyState === WebSocket.OPEN) {\n            this._socket.send(JSON.stringify(data));\n        } else {\n            this._handles[data.id] = { errorCallback: () => {} };\n            this._socket.onopen = () => {\n                this._send(data);\n            };\n        }\n    }\n\n    _onerror(error) {\n        this._onerror(error, this._handles);\n    }\n\n    _onerror(error, handles) {\n        for (const id in handles) {\n            if (handles[id].errorCallback) {\n                handles[id].errorCallback(error);\n            }\n        }\n    }\n\n    _onmessage(message) {\n        const response = JSON.parse(message.data);\n        if (response.id) {\n            const handle = this._handles[response.id];\n            if (handle && handle.successCallback) {\n                handle.successCallback(response.result);\n            }\n        } else {\n            const method = response.method;\n            if (this._listeners[this._namespace + method]) {\n                this._listeners[this._namespace + method].forEach(callback => callback(response.params));\n            }\n        }\n    }\n\n    _onclose() {\n        for (const id in this._handles) {\n            this._handles[id].errorCallback(new Error('Connection closed'));\n        }\n        this._handles = {};\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(this._formatURL(address, encryption));\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    setAddress(address, encryption) {\n        this._socket.close();\n        this._socket = new WebSocket(this._formatURL(address, encryption));\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        const namespaceMethod = this._namespace + method;\n        if (this._listeners[namespaceMethod]) {\n            delete this._listeners[namespaceMethod];\n        }\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const request = this._formatData(method, params, id);\n        this._handles[id] = { successCallback, errorCallback };\n        this._send(request);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const batch = { jsonrpc: \"2.0\", method: \"batch\", params: requests };\n        this._send(batch);\n    }\n\n    _formatData(method, params, id) {\n        return {\n            jsonrpc: \"2.0\",\n            method: this._namespace + method,\n            params: params,\n            id: id\n        };\n    }\n\n    _send(data) {\n        if (this._socket.readyState === WebSocket.OPEN) {\n            this._socket.send(JSON.stringify(data));\n        } else {\n            this._handles[data.id] = { data };\n        }\n    }\n\n    _onerror(error) {\n        for (const handle of Object.values(this._handles)) {\n            if (handle.errorCallback) {\n                handle.errorCallback(error);\n            }\n        }\n    }\n\n    _onmessage(message) {\n        const response = JSON.parse(message.data);\n        if (response.id) {\n            const handle = this._handles[response.id];\n            if (handle) {\n                if (response.error) {\n                    handle.errorCallback(response.error);\n                } else {\n                    handle.successCallback(response.result);\n                }\n                delete this._handles[response.id];\n            }\n        } else {\n            const method = response.method;\n            if (this._listeners[this._namespace + method]) {\n                this._listeners[this._namespace + method].forEach(callback => callback(response.params));\n            }\n        }\n    }\n\n    _onopen() {\n        for (const handle of Object.values(this._handles)) {\n            if (handle.data) {\n                this._send(handle.data);\n            }\n        }\n    }\n\n    _onclose() {\n        for (const handle of Object.values(this._handles)) {\n            if (handle.errorCallback) {\n                handle.errorCallback(new Error(\"WebSocket connection closed\"));\n            }\n        }\n    }\n\n    _formatURL(address, encryption) {\n        return encryption ? `wss://${address}` : `ws://${address}`;\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(address, encryption ? 'wss' : 'ws');\n        this._socket.onopen = () => this._onopen();\n        this._socket.onmessage = (event) => this._onmessage(JSON.parse(event.data), this._handles, this._listeners);\n        this._socket.onerror = (error) => this._onerror(error, this._handles);\n        this._socket.onclose = () => this._onclose();\n    }\n\n    setAddress(address, encryption) {\n        this._socket = new WebSocket(address, encryption ? 'wss' : 'ws');\n        this._socket.onopen = () => this._onopen();\n        this._socket.onmessage = (event) => this._onmessage(JSON.parse(event.data), this._handles, this._listeners);\n        this._socket.onerror = (error) => this._onerror(error, this._handles);\n        this._socket.onclose = () => this._onclose();\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        delete this._listeners[this._namespace + method];\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const request = this._formatData(method, params, id);\n        this._handles[id] = { success: successCallback, error: errorCallback };\n        this._send(request);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const batch = { jsonrpc: '2.0', method: 'batch', params: requests };\n        this._send(batch);\n    }\n\n    _formatData(method, params, id) {\n        return { jsonrpc: '2.0', method: this._namespace + method, params: params, id: id };\n    }\n\n    _send(data) {\n        this._socket.send(JSON.stringify(data));\n    }\n\n    _onerror(error, handles) {\n        for (const id in handles) {\n            if (handles[id].error) {\n                handles[id].error(error);\n            }\n        }\n    }\n\n    _onmessage(message, handles, listeners) {\n        if (message.jsonrpc === '2.0') {\n            if (message.id) {\n                if (handles[message.id]) {\n                    if (message.error) {\n                        handles[message.id].error(message.error);\n                    } else {\n                        handles[message.id].success(message.result);\n                    }\n                    delete handles[message.id];\n                }\n            } else {\n                const method = message.method;\n                if (listeners[this._namespace + method]) {\n                    listeners[this._namespace + method].forEach(callback => callback(message.result));\n                }\n            }\n        }\n    }\n\n    _onopen() {\n        // Reconnection logic can be implemented here\n    }\n\n    _onclose() {\n        // Reconnection logic can be implemented here\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(address + (encryption ? 's' : '') + '://');\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    setAddress(address, encryption) {\n        this._socket.close();\n        this._socket = new WebSocket(address + (encryption ? 's' : '') + '://');\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        delete this._listeners[this._namespace + method];\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const data = this._formatData(method, params, id);\n        this._handles[id] = { success: successCallback, error: errorCallback };\n        this._send(data);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const batch = { jsonrpc: '2.0', method: 'batch', params: requests, id: 'batch' };\n        this._send(batch);\n        this._handles[batch.id] = { success: successCallback, error: errorCallback };\n    }\n\n    _formatData(method, params, id) {\n        return { jsonrpc: '2.0', method: this._namespace + method, params: params, id: id };\n    }\n\n    _send(data) {\n        this._socket.send(JSON.stringify(data));\n    }\n\n    _onerror(error) {\n        if (this._handles[error.id]) {\n            this._onerror(error, this._handles);\n        }\n    }\n\n    _onmessage(message) {\n        const response = JSON.parse(message.data);\n        if (response.id) {\n            if (this._handles[response.id]) {\n                if (response.error) {\n                    this._handles[response.id].error(response.error);\n                } else {\n                    this._handles[response.id].success(response.result);\n                }\n                delete this._handles[response.id];\n            }\n        } else {\n            const method = response.method;\n            if (this._listeners[this._namespace + method]) {\n                this._listeners[this._namespace + method].forEach(callback => callback(response.result));\n            }\n        }\n    }\n\n    _onclose() {\n        this._socket = new WebSocket(this._socket.url);\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    _onopen() {\n        // Reconnect logic can be implemented here if needed\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(address + (encryption ? 's' : '') + '://');\n        this._socket.onopen = () => this._onopen();\n        this._socket.onmessage = (event) => this._onmessage(JSON.parse(event.data), this._handles, this._listeners);\n        this._socket.onerror = (error) => this._onerror(error, this._handles);\n        this._socket.onclose = () => this._onclose();\n    }\n\n    setAddress(address, encryption) {\n        this._socket.close();\n        this._socket = new WebSocket(address + (encryption ? 's' : '') + '://');\n        this._socket.onopen = () => this._onopen();\n        this._socket.onmessage = (event) => this._onmessage(JSON.parse(event.data), this._handles, this._listeners);\n        this._socket.onerror = (error) => this._onerror(error, this._handles);\n        this._socket.onclose = () => this._onclose();\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        if (this._listeners[this._namespace + method]) {\n            delete this._listeners[this._namespace + method];\n        }\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const data = this._formatData(method, params, id);\n        this._handles[id] = { success: successCallback, error: errorCallback };\n        this._send(data);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const data = requests.map(req => this._formatData(req.method, req.params, req.id));\n        this._handles = data.reduce((acc, req) => {\n            acc[req.id] = { success: successCallback, error: errorCallback };\n            return acc;\n        }, {});\n        this._send({ jsonrpc: '2.0', method: 'batch', params: data });\n    }\n\n    _formatData(method, params, id) {\n        return {\n            jsonrpc: '2.0',\n            method: this._namespace + method,\n            params: params,\n            id: id\n        };\n    }\n\n    _send(data) {\n        if (this._socket.readyState === WebSocket.OPEN) {\n            this._socket.send(JSON.stringify(data));\n        }\n    }\n\n    _onerror(error, handles) {\n        for (const id in handles) {\n            if (handles[id].error) {\n                handles[id].error(error);\n            }\n        }\n    }\n\n    _onmessage(message, handles, listeners) {\n        if (message.jsonrpc === '2.0') {\n            if (message.id) {\n                if (handles[message.id]) {\n                    if (message.error) {\n                        handles[message.id].error(message.error);\n                    } else {\n                        handles[message.id].success(message.result);\n                    }\n                    delete handles[message.id];\n                }\n            } else {\n                const method = message.method;\n                if (listeners[this._namespace + method]) {\n                    listeners[this._namespace + method].forEach(callback => callback(message.params));\n                }\n            }\n        }\n    }\n\n    _onopen() {\n        // Reconnect logic can be implemented here if needed\n    }\n\n    _onclose() {\n        // Reconnect logic can be implemented here if needed\n    }\n}\n```",
      "```javascript\nclass RPCWebSocket {\n    constructor(address, encryption, namespace) {\n        this._namespace = namespace;\n        this._listeners = {};\n        this._handles = {};\n        this._socket = new WebSocket(this._formatURL(address, encryption));\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    setAddress(address, encryption) {\n        this._socket.close();\n        this._socket = new WebSocket(this._formatURL(address, encryption));\n        this._socket.onopen = this._onopen.bind(this);\n        this._socket.onmessage = this._onmessage.bind(this);\n        this._socket.onerror = this._onerror.bind(this);\n        this._socket.onclose = this._onclose.bind(this);\n    }\n\n    addListener(method, callback) {\n        if (!this._listeners[this._namespace + method]) {\n            this._listeners[this._namespace + method] = [];\n        }\n        this._listeners[this._namespace + method].push(callback);\n    }\n\n    removeListener(method) {\n        delete this._listeners[this._namespace + method];\n    }\n\n    request(method, params, id, successCallback, errorCallback) {\n        const request = this._formatData(method, params, id);\n        this._handles[id] = { success: successCallback, error: errorCallback };\n        this._send(request);\n    }\n\n    batchRequest(requests, successCallback, errorCallback) {\n        const batch = { jsonrpc: '2.0', method: 'batch', params: requests };\n        this._send(batch);\n    }\n\n    _formatData(method, params, id) {\n        return {\n            jsonrpc: '2.0',\n            method: this._namespace + method,\n            params: params,\n            id: id\n        };\n    }\n\n    _send(data) {\n        this._socket.send(JSON.stringify(data));\n    }\n\n    _onerror(error) {\n        this._onerror(error, this._handles);\n    }\n\n    _onmessage(message) {\n        const response = JSON.parse(message.data);\n        if (response.id) {\n            const handle = this._handles[response.id];\n            if (handle && handle.success) {\n                handle.success(response.result);\n            }\n        } else {\n            const method = response.method;\n            if (this._listeners[this._namespace + method]) {\n                this._listeners[this._namespace + method].forEach(callback => callback(response.result));\n            }\n        }\n    }\n\n    _onopen() {\n        // Handle reconnection logic if needed\n    }\n\n    _onclose() {\n        // Handle disconnection logic if needed\n    }\n\n    _formatURL(address, encryption) {\n        return encryption ? `wss://${address}` : `ws://${address}`;\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using HTTP POST request with error handling.\n\nFunction Description: The function `sendWebhook` is an asynchronous function that takes data as input and sends it to a predefined webhook URL using an HTTP POST request. It handles potential errors during the request and logs them to the console.\n\nInput: \n- `data` [Object] - The payload/data to be sent to the webhook URL.\n\nOutput: \n- None (The function does not return any value, but it may log errors to the console if the request fails).",
    "Canonical_solution": "const axios = require('axios');\n\nconst sendWebhook = async (data) => {\n    try {\n        await axios.post(process.env.UPDATE_WEBHOOK, data);\n    } catch (err) {\n        console.log(err);\n    }\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  const webhookUrl = 'https://your-webhook-url.com';\n  try {\n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  try {\n    const response = await fetch('YOUR_WEBHOOK_URL', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  try {\n    const response = await fetch('https://your-webhook-url.com', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}\n```",
      "```python\nimport requests\nimport json\n\nasync def sendWebhook(data):\n    webhook_url = \"https://example.com/webhook\"\n    headers = {\"Content-Type\": \"application/json\"}\n    try:\n        response = await requests.post(webhook_url, json=data, headers=headers)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        print(f\"Error sending webhook: {e}\")\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  const webhookUrl = 'https://example.com/webhook';\n  try {\n    await fetch(webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n  } catch (error) {\n    console.error('Failed to send webhook:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  try {\n    const response = await fetch('YOUR_WEBHOOK_URL', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  try {\n    const response = await fetch('YOUR_WEBHOOK_URL', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  try {\n    await fetch('https://your-webhook-url.com', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  try {\n    const response = await fetch('YOUR_WEBHOOK_URL', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function sendWebhook(data) {\n  try {\n    const response = await fetch('https://your-webhook-url.com', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles WebSocket connections, message processing, and connection lifecycle events. The class should support sending and receiving JSON messages, handling different commands, and managing connection states.\n\nClass Description: The `Client` class represents a WebSocket client that connects to a server, processes incoming messages, and sends commands. It handles connection events, message parsing, and provides methods for common operations like sending hello messages and triggering reloads.\n\nAttributes:\n- `ws`: [WebSocket] - The WebSocket connection instance.\n- `options`: [Object] - Configuration options for the client.\n- `id`: [String] - Unique identifier for the client instance.\n- `plugins`: [Array] - List of plugins received from the server.\n- `url`: [String] - URL received from the server.\n\nMethods:\n- `constructor(req, socket, head, options)` -> [Client] - Initializes a new WebSocket client instance with the given request, socket, head, and options.\n- `message(event)` -> [void] - Handles incoming WebSocket messages, parses them, and routes to appropriate command handlers.\n- `close(event)` -> [void] - Closes the WebSocket connection and emits an 'end' event.\n- `hello()` -> [void] - Sends a 'hello' command to the server with supported protocols and server name.\n- `info(data)` -> [void] - Processes 'info' command data from the server, storing plugins and URL.\n- `reload(files)` -> [void] - Sends 'reload' commands for each file in the provided list, with live reload options.\n- `_data(event)` -> [Object] - Parses incoming message data from JSON string to object.\n- `send(data)` -> [void] - Sends data as a JSON string over the WebSocket connection.\n- `uniqueId(prefix)` -> [String] - Generates a unique ID with an optional prefix.",
    "Canonical_solution": "var WebSocket = require('faye-websocket');\n\nclass Client {\n  constructor(req, socket, head, options) {\n    options = this.options = options || {};\n    this.ws = new WebSocket(req, socket, head);\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n    this.id = this.uniqueId('ws');\n  }\n\n  message(event) {\n    var data = this.data(event);\n    if(this[data.command]) return this[data.command](data);\n  }\n\n  close(event) {\n    if(this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.emit('end', event);\n  }\n\n  hello() {\n    this.send({\n      command: 'hello',\n      protocols: [\n        'http://livereload.com/protocols/official-7'\n      ],\n      serverName: 'tiny-lr'\n    });\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(function(file) {\n      this.send({\n        command: 'reload',\n        path: file,\n        liveCss: this.options.liveCss !== false,\n        liveJs: this.options.liveJs !== false,\n        liveImg: this.options.liveImg !== false\n      });\n    }, this);\n  }\n\n  _data(event) {\n    var data = {};\n    try {\n      data = JSON.parse(event.data);\n    } catch (e) {}\n    return data;\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  }\n}\n\nvar idCounter = 0;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(req.url);\n    this.options = options;\n    this.id = this.uniqueId(options.prefix);\n    this.plugins = [];\n    this.url = req.url;\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n  }\n\n  message(event) {\n    const data = this._data(event.data);\n    if (data.command) {\n      switch (data.command) {\n        case 'info':\n          this.info(data.data);\n          break;\n        case 'reload':\n          this.reload(data.data.files);\n          break;\n        default:\n          console.log('Unknown command:', data.command);\n      }\n    }\n  }\n\n  close(event) {\n    this.emit('end', event);\n  }\n\n  hello() {\n    const data = {\n      command: 'hello',\n      protocols: this.options.protocols,\n      serverName: this.options.serverName\n    };\n    this.send(data);\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(file => {\n      const data = {\n        command: 'reload',\n        file: file,\n        liveReload: this.options.liveReload\n      };\n      this.send(data);\n    });\n  }\n\n  _data(event) {\n    return JSON.parse(event);\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    return prefix + Math.random().toString(36).substr(2, 9);\n  }\n}\n```",
      "```javascript\nclass Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(req.url);\n    this.options = options;\n    this.id = this.uniqueId(options.prefix);\n    this.plugins = [];\n    this.url = req.url;\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n  }\n\n  message(event) {\n    const data = this._data(event.data);\n    if (data.command) {\n      switch (data.command) {\n        case 'info':\n          this.info(data.data);\n          break;\n        case 'reload':\n          this.reload(data.data.files);\n          break;\n        default:\n          console.log('Unknown command:', data.command);\n      }\n    }\n  }\n\n  close(event) {\n    this.emit('end', event);\n  }\n\n  hello() {\n    const data = {\n      command: 'hello',\n      protocols: this.options.protocols,\n      serverName: this.options.serverName\n    };\n    this.send(data);\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(file => {\n      const data = {\n        command: 'reload',\n        file: file,\n        liveReload: this.options.liveReload\n      };\n      this.send(data);\n    });\n  }\n\n  _data(event) {\n    return JSON.parse(event);\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    return prefix + Math.random().toString(36).substr(2, 9);\n  }\n}\n```",
      "```javascript\nclass Client {\n    constructor(req, socket, head, options) {\n        this.ws = new WebSocket(socket);\n        this.options = options;\n        this.id = req.headers['x-client-id'] || uniqueId('client');\n        this.plugins = [];\n        this.url = '';\n        this.ws.onmessage = this.message.bind(this);\n        this.ws.onclose = this.close.bind(this);\n    }\n\n    message(event) {\n        const data = this._data(event.data);\n        if (data.command === 'info') {\n            this.info(data.data);\n        }\n    }\n\n    close(event) {\n        this.ws.close();\n        this.emit('end', event);\n    }\n\n    hello() {\n        const message = {\n            command: 'hello',\n            protocols: ['protocol1', 'protocol2'],\n            serverName: 'ServerName'\n        };\n        this.send(message);\n    }\n\n    info(data) {\n        this.plugins = data.plugins;\n        this.url = data.url;\n    }\n\n    reload(files) {\n        files.forEach(file => {\n            const message = {\n                command: 'reload',\n                file: file,\n                liveReload: true\n            };\n            this.send(message);\n        });\n    }\n\n    _data(event) {\n        return JSON.parse(event.data);\n    }\n\n    send(data) {\n        this.ws.send(JSON.stringify(data));\n    }\n\n    uniqueId(prefix) {\n        return prefix + Math.random().toString(36).substr(2, 9);\n    }\n}\n```",
      "```javascript\nclass Client {\n    constructor(req, socket, head, options) {\n        this.ws = new WebSocket(socket);\n        this.options = options;\n        this.id = `${prefix}-${Date.now()}`;\n        this.plugins = [];\n        this.url = '';\n        this.ws.onmessage = this.message.bind(this);\n        this.ws.onclose = this.close.bind(this);\n    }\n\n    message(event) {\n        const data = this._data(event.data);\n        if (data.command === 'info') {\n            this.info(data.data);\n        }\n    }\n\n    close(event) {\n        this.ws.close();\n        this.emit('end', event);\n    }\n\n    hello() {\n        const message = {\n            command: 'hello',\n            protocols: this.options.protocols,\n            serverName: this.options.serverName\n        };\n        this.send(message);\n    }\n\n    info(data) {\n        this.plugins = data.plugins;\n        this.url = data.url;\n    }\n\n    reload(files) {\n        files.forEach(file => {\n            const message = {\n                command: 'reload',\n                file: file,\n                liveReload: this.options.liveReload\n            };\n            this.send(message);\n        });\n    }\n\n    _data(event) {\n        return JSON.parse(event.data);\n    }\n\n    send(data) {\n        this.ws.send(JSON.stringify(data));\n    }\n\n    uniqueId(prefix) {\n        return `${prefix}-${Date.now()}`;\n    }\n}\n```",
      "```javascript\nclass Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(socket);\n    this.options = options;\n    this.id = `${prefix}-${Date.now()}`;\n    this.plugins = [];\n    this.url = '';\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n  }\n\n  message(event) {\n    const data = this._data(event.data);\n    if (data.command === 'info') {\n      this.info(data.data);\n    }\n  }\n\n  close(event) {\n    this.ws.close();\n    this.emit('end', event);\n  }\n\n  hello() {\n    const message = {\n      command: 'hello',\n      protocols: this.options.protocols,\n      serverName: this.options.serverName\n    };\n    this.send(message);\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(file => {\n      this.send({\n        command: 'reload',\n        file: file,\n        liveReload: this.options.liveReload\n      });\n    });\n  }\n\n  _data(event) {\n    return JSON.parse(event.data);\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    return `${prefix}-${Date.now()}`;\n  }\n}\n```",
      "```javascript\nclass Client {\n    constructor(req, socket, head, options) {\n        this.ws = new WebSocket(socket);\n        this.options = options;\n        this.id = `${prefix}-${Date.now()}`;\n        this.plugins = [];\n        this.url = '';\n        this.ws.onmessage = this.message.bind(this);\n        this.ws.onclose = this.close.bind(this);\n    }\n\n    message(event) {\n        const data = this._data(event.data);\n        if (data.command === 'info') {\n            this.info(data.data);\n        }\n    }\n\n    close(event) {\n        this.ws.close();\n        this.emit('end', event);\n    }\n\n    hello() {\n        const message = {\n            command: 'hello',\n            protocols: this.options.protocols,\n            serverName: this.options.serverName\n        };\n        this.send(message);\n    }\n\n    info(data) {\n        this.plugins = data.plugins;\n        this.url = data.url;\n    }\n\n    reload(files) {\n        files.forEach(file => {\n            const message = {\n                command: 'reload',\n                file: file,\n                liveReload: this.options.liveReload\n            };\n            this.send(message);\n        });\n    }\n\n    _data(event) {\n        return JSON.parse(event.data);\n    }\n\n    send(data) {\n        this.ws.send(JSON.stringify(data));\n    }\n\n    uniqueId(prefix) {\n        return `${prefix}-${Date.now()}`;\n    }\n}\n```",
      "```javascript\nclass Client {\n    constructor(req, socket, head, options) {\n        this.ws = new WebSocket(req.url);\n        this.options = options;\n        this.id = this.uniqueId(options.prefix);\n        this.plugins = [];\n        this.url = req.url;\n        this.ws.onmessage = this.message.bind(this);\n        this.ws.onclose = this.close.bind(this);\n    }\n\n    message(event) {\n        const data = this._data(event.data);\n        if (data.command) {\n            switch (data.command) {\n                case 'info':\n                    this.info(data.data);\n                    break;\n                case 'reload':\n                    this.reload(data.data.files);\n                    break;\n                default:\n                    console.log('Unknown command:', data.command);\n            }\n        }\n    }\n\n    close(event) {\n        this.emit('end', event);\n    }\n\n    hello() {\n        const data = {\n            command: 'hello',\n            protocols: this.options.protocols,\n            serverName: this.options.serverName\n        };\n        this.send(data);\n    }\n\n    info(data) {\n        this.plugins = data.plugins;\n        this.url = data.url;\n    }\n\n    reload(files) {\n        files.forEach(file => {\n            const data = {\n                command: 'reload',\n                file: file,\n                liveReload: this.options.liveReload\n            };\n            this.send(data);\n        });\n    }\n\n    _data(event) {\n        return JSON.parse(event);\n    }\n\n    send(data) {\n        this.ws.send(JSON.stringify(data));\n    }\n\n    uniqueId(prefix) {\n        return prefix + Math.random().toString(36).substr(2, 9);\n    }\n}\n```",
      "```javascript\nclass Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(socket);\n    this.options = options;\n    this.id = `${prefix}-${Date.now()}`;\n    this.plugins = [];\n    this.url = '';\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n  }\n\n  message(event) {\n    const data = this._data(event.data);\n    if (data.command === 'info') {\n      this.info(data.data);\n    }\n  }\n\n  close(event) {\n    this.ws.close();\n    this.emit('end', event);\n  }\n\n  hello() {\n    const message = {\n      command: 'hello',\n      protocols: this.options.protocols,\n      serverName: this.options.serverName\n    };\n    this.send(message);\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(file => {\n      const message = {\n        command: 'reload',\n        file: file,\n        liveReload: this.options.liveReload\n      };\n      this.send(message);\n    });\n  }\n\n  _data(event) {\n    return JSON.parse(event.data);\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    return `${prefix}-${Date.now()}`;\n  }\n}\n```",
      "```javascript\nclass Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(socket);\n    this.options = options;\n    this.id = `${prefix}-${Date.now()}`;\n    this.plugins = [];\n    this.url = '';\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n  }\n\n  message(event) {\n    const data = this._data(event.data);\n    if (data.command === 'info') {\n      this.info(data.data);\n    }\n  }\n\n  close(event) {\n    this.ws.close();\n    this.emit('end', event);\n  }\n\n  hello() {\n    const message = {\n      command: 'hello',\n      protocols: this.options.protocols,\n      serverName: this.options.serverName\n    };\n    this.send(message);\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(file => {\n      const message = {\n        command: 'reload',\n        file: file,\n        liveReload: this.options.liveReload\n      };\n      this.send(message);\n    });\n  }\n\n  _data(event) {\n    return JSON.parse(event.data);\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    return `${prefix}-${Date.now()}`;\n  }\n}\n```",
      "```javascript\nclass Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(socket);\n    this.options = options;\n    this.id = `${prefix}-${Date.now()}`;\n    this.plugins = [];\n    this.url = '';\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n  }\n\n  message(event) {\n    const data = this._data(event.data);\n    if (data.command === 'info') {\n      this.info(data.data);\n    }\n  }\n\n  close(event) {\n    this.ws.close();\n    this.emit('end', event);\n  }\n\n  hello() {\n    const message = {\n      command: 'hello',\n      protocols: this.options.protocols,\n      serverName: this.options.serverName\n    };\n    this.send(message);\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(file => {\n      const message = {\n        command: 'reload',\n        file: file,\n        liveReload: this.options.liveReload\n      };\n      this.send(message);\n    });\n  }\n\n  _data(event) {\n    return JSON.parse(event.data);\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    return `${prefix}-${Date.now()}`;\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 211,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with support for reconnection, message handling, and connection lifecycle events.\n\nClass Description: The `N` class represents a WebSocket client that connects to a specified URL, handles incoming messages, manages connection state, and provides automatic reconnection capabilities. It supports event callbacks for connection establishment and completion, and can pipe received data to a destination.\n\nAttributes:\n- url: [String] - The WebSocket server URL to connect to\n- options: [Object] - Configuration options including protocols, reconnect interval, and callbacks\n- socket: [WebSocket|null] - The active WebSocket connection instance\n- streaming: [Boolean] - Flag indicating if the connection is active\n- callbacks: [Object] - Collection of event callback arrays (connect, data)\n- destination: [Object|null] - Target to pipe received data to\n- reconnectInterval: [Number] - Time in seconds between reconnection attempts\n- shouldAttemptReconnect: [Boolean] - Flag controlling reconnection behavior\n- completed: [Boolean] - Connection completion state\n- established: [Boolean] - Connection establishment state\n- progress: [Number] - Connection progress indicator\n- reconnectTimeoutId: [Number] - Timer ID for reconnection attempts\n- onEstablishedCallback: [Function|null] - Called when connection is established\n- onCompletedCallback: [Function|null] - Called when connection completes\n- hookOnEstablished: [Function|null] - Optional hook for connection establishment\n\nMethods:\n- constructor(url, options) -> [N] - Initializes the WebSocket client with URL and options\n- connect(destination) -> [void] - Sets the destination for received data\n- destroy() -> [void] - Cleans up resources and closes the connection\n- start() -> [void] - Initiates the WebSocket connection with optional protocols\n- resume() -> [void] - Placeholder for resuming functionality (currently empty)\n- onOpen() -> [void] - Handles WebSocket open event, updates progress\n- onClose() -> [void] - Handles WebSocket close/error events, manages reconnection\n- onMessage(message) -> [void] - Handles incoming messages, triggers establishment callbacks",
    "Canonical_solution": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = true;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== options.reconnectInterval ? options.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = options.onSourceEstablished;\n    this.onCompletedCallback = options.onSourceCompleted;\n    options.hookOnEstablished && (this.hookOnEstablished = options.hookOnEstablished);\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = false;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = false;\n    this.options.protocols\n      ? this.socket = new WebSocket(this.url, this.options.protocols)\n      : this.socket = new WebSocket(this.url);\n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    const reconnect = () => {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, 1000 * this.reconnectInterval);\n    };\n    this.shouldAttemptReconnect && reconnect();\n  }\n\n  onMessage(message) {\n    const wasEstablished = this.established;\n    this.established = true;\n    wasEstablished || this.hookOnEstablished?.();\n    wasEstablished || this.onEstablishedCallback?.(this);\n    this.destination?.write(message.data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {\n            connect: [],\n            data: []\n        };\n        this.destination = null;\n        this.reconnectInterval = options.reconnectInterval || 5000;\n        this.shouldAttemptReconnect = true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = options.onEstablished;\n        this.onCompletedCallback = options.onCompleted;\n        this.hookOnEstablished = options.hookOnEstablished;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        this.completed = true;\n        if (this.socket) {\n            this.socket.close();\n        }\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n    }\n\n    start() {\n        const protocols = this.options.protocols || [];\n        this.socket = new WebSocket(this.url, protocols);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onClose.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.streaming = true;\n        this.established = true;\n        this.progress = 100;\n        this.callbacks.connect.forEach(callback => callback());\n        if (this.hookOnEstablished) {\n            this.hookOnEstablished();\n        }\n        if (this.onEstablishedCallback) {\n            this.onEstablishedCallback();\n        }\n    }\n\n    onClose() {\n        this.streaming = false;\n        this.established = false;\n        this.progress = 0;\n        if (this.onCompletedCallback) {\n            this.onCompletedCallback();\n        }\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(message) {\n        if (this.destination) {\n            this.destination.write(message.data);\n        }\n        this.callbacks.data.forEach(callback => callback(message));\n    }\n\n    reconnect() {\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.start();\n        }, this.reconnectInterval);\n    }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connect: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablished;\n    this.onCompletedCallback = options.onCompleted;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.completed = true;\n    this.socket?.close();\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    const protocols = this.options.protocols || [];\n    this.socket = new WebSocket(this.url, protocols);\n    this.socket.onopen = this.onOpen;\n    this.socket.onclose = this.onClose;\n    this.socket.onerror = this.onClose;\n    this.socket.onmessage = this.onMessage;\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    this.progress = 0;\n    this.callbacks.data.forEach(callback => callback(null));\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n    if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n  }\n\n  onMessage(message) {\n    if (this.destination) {\n      this.destination.write(message.data);\n    } else {\n      this.callbacks.data.forEach(callback => callback(message));\n    }\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connect: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablished;\n    this.onCompletedCallback = options.onCompleted;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    const protocols = this.options.protocols || [];\n    this.socket = new WebSocket(this.url, protocols);\n    this.socket.onopen = this.onOpen;\n    this.socket.onclose = this.onClose;\n    this.socket.onerror = this.onClose;\n    this.socket.onmessage = this.onMessage;\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.streaming = true;\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.data.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.streaming = false;\n    this.established = false;\n    this.progress = 0;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(message) {\n    if (this.destination) {\n      this.destination.write(message.data);\n    }\n    this.callbacks.data.forEach(callback => callback(message));\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      this.start();\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {\n            connect: [],\n            data: []\n        };\n        this.destination = null;\n        this.reconnectInterval = options.reconnectInterval || 5;\n        this.shouldAttemptReconnect = true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = options.onEstablished;\n        this.onCompletedCallback = options.onCompleted;\n        this.hookOnEstablished = options.hookOnEstablished;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        this.streaming = false;\n        if (this.socket) {\n            this.socket.close();\n            this.socket = null;\n        }\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n            this.reconnectTimeoutId = null;\n        }\n    }\n\n    start() {\n        const protocols = this.options.protocols || [];\n        this.socket = new WebSocket(this.url, protocols);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onClose.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.streaming = true;\n        this.established = true;\n        this.progress = 100;\n        this.callbacks.connect.forEach(callback => callback());\n        if (this.onEstablishedCallback) {\n            this.onEstablishedCallback();\n        }\n        if (this.hookOnEstablished) {\n            this.hookOnEstablished();\n        }\n    }\n\n    onClose() {\n        this.streaming = false;\n        this.established = false;\n        this.progress = 0;\n        this.callbacks.data.forEach(callback => callback());\n        if (this.onCompletedCallback) {\n            this.onCompletedCallback();\n        }\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(message) {\n        if (this.destination) {\n            this.destination.write(message.data);\n        }\n        this.callbacks.data.forEach(callback => callback(message));\n    }\n\n    reconnect() {\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.start();\n        }, this.reconnectInterval * 1000);\n    }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connect: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablished;\n    this.onCompletedCallback = options.onCompleted;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = true;\n    this.established = false;\n    this.progress = 0;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    if (this.options.protocols) {\n      this.socket = new WebSocket(this.url, this.options.protocols);\n    } else {\n      this.socket = new WebSocket(this.url);\n    }\n    this.socket.onopen = this.onOpen;\n    this.socket.onclose = this.onClose;\n    this.socket.onmessage = this.onMessage;\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.streaming = true;\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.data.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.streaming = false;\n    this.established = false;\n    this.progress = 0;\n    if (this.shouldAttemptReconnect) {\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, this.reconnectInterval * 1000);\n    }\n    if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n  }\n\n  onMessage(message) {\n    if (this.destination) {\n      this.destination.write(message.data);\n    }\n    this.callbacks.data.forEach(callback => callback(message));\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connect: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablished;\n    this.onCompletedCallback = options.onCompleted;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.streaming = false;\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n  }\n\n  start() {\n    if (this.socket) {\n      return;\n    }\n    const protocols = this.options.protocols || [];\n    this.socket = new WebSocket(this.url, protocols);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.streaming = true;\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.data.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.streaming = false;\n    this.established = false;\n    this.progress = 0;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(message) {\n    if (this.destination) {\n      this.destination.write(message.data);\n    }\n    this.callbacks.data.forEach(callback => callback(message));\n  }\n\n  reconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n    this.reconnectTimeoutId = setTimeout(() => {\n      this.start();\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connect: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablished;\n    this.onCompletedCallback = options.onCompleted;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.streaming = false;\n    this.completed = true;\n    this.established = false;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    if (this.options.protocols) {\n      this.socket = new WebSocket(this.url, this.options.protocols);\n    } else {\n      this.socket = new WebSocket(this.url);\n    }\n    this.socket.onopen = this.onOpen;\n    this.socket.onclose = this.onClose;\n    this.socket.onmessage = this.onMessage;\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.streaming = true;\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n  }\n\n  onClose() {\n    this.streaming = false;\n    this.established = false;\n    this.progress = 0;\n    if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(message) {\n    if (this.destination) {\n      this.destination.write(message.data);\n    }\n    this.callbacks.data.forEach(callback => callback(message));\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connect: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablished;\n    this.onCompletedCallback = options.onCompleted;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.socket = null;\n    this.streaming = false;\n    this.completed = true;\n    this.established = false;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    if (this.options.protocols) {\n      this.socket = new WebSocket(this.url, this.options.protocols);\n    } else {\n      this.socket = new WebSocket(this.url);\n    }\n    this.socket.onopen = this.onOpen;\n    this.socket.onclose = this.onClose;\n    this.socket.onmessage = this.onMessage;\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.streaming = true;\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n  }\n\n  onClose() {\n    this.streaming = false;\n    this.established = false;\n    this.progress = 0;\n    if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(message) {\n    if (this.destination) {\n      this.destination.write(message.data);\n    }\n    this.callbacks.data.forEach(callback => callback(message));\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {\n            connect: [],\n            data: []\n        };\n        this.destination = null;\n        this.reconnectInterval = options.reconnectInterval || 5;\n        this.shouldAttemptReconnect = true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = options.onEstablished;\n        this.onCompletedCallback = options.onCompleted;\n        this.hookOnEstablished = options.hookOnEstablished;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        if (this.socket) {\n            this.socket.close();\n            this.socket = null;\n        }\n        this.streaming = false;\n        this.completed = true;\n        this.established = false;\n        clearTimeout(this.reconnectTimeoutId);\n    }\n\n    start() {\n        if (this.options.protocols) {\n            this.socket = new WebSocket(this.url, this.options.protocols);\n        } else {\n            this.socket = new WebSocket(this.url);\n        }\n        this.socket.onopen = this.onOpen;\n        this.socket.onclose = this.onClose;\n        this.socket.onmessage = this.onMessage;\n    }\n\n    resume() {\n        // Placeholder for resuming functionality\n    }\n\n    onOpen() {\n        this.streaming = true;\n        this.established = true;\n        this.progress = 100;\n        this.callbacks.connect.forEach(callback => callback());\n        if (this.hookOnEstablished) {\n            this.hookOnEstablished();\n        }\n        if (this.onEstablishedCallback) {\n            this.onEstablishedCallback();\n        }\n    }\n\n    onClose() {\n        this.streaming = false;\n        this.established = false;\n        this.progress = 0;\n        if (this.onCompletedCallback) {\n            this.onCompletedCallback();\n        }\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(message) {\n        if (this.destination) {\n            this.destination.write(message.data);\n        }\n        this.callbacks.data.forEach(callback => callback(message));\n    }\n\n    reconnect() {\n        clearTimeout(this.reconnectTimeoutId);\n        this.reconnectTimeoutId = setTimeout(() => {\n            if (!this.completed) {\n                this.start();\n            }\n        }, this.reconnectInterval * 1000);\n    }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      connect: [],\n      data: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5000;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablished;\n    this.onCompletedCallback = options.onCompleted;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.socket = null;\n    this.streaming = false;\n    this.completed = true;\n    this.established = false;\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n  }\n\n  start() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.socket = new WebSocket(this.url, this.options.protocols);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.streaming = true;\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.streaming = false;\n    this.established = false;\n    this.progress = 0;\n    this.callbacks.data.forEach(callback => callback());\n    if (this.onCompletedCallback) {\n      this.onCompletedCallback();\n    }\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(message) {\n    if (this.destination) {\n      this.destination.write(message.data);\n    }\n    this.callbacks.data.forEach(callback => callback(message));\n  }\n\n  reconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n    this.reconnectTimeoutId = setTimeout(() => {\n      this.start();\n    }, this.reconnectInterval);\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes a connection to a WebSocket server, handles communication events (open, message, close, error), and provides methods to send messages and close the connection. The class should integrate with a listener interface to notify about connection events and received messages.\n\nClass Description: The WebSocketClient class is an implementation of the AiClient interface that manages WebSocket connections in a browser environment. It handles the WebSocket lifecycle, including connection establishment, message exchange, and error handling, while notifying a listener about these events.\n\nAttributes:\n- isStop: boolean - Indicates whether the connection has been stopped.\n- url: string - The WebSocket server URL to connect to.\n- webSocket: WebSocket | undefined - The WebSocket instance.\n- isOpen: boolean - Indicates whether the WebSocket connection is open.\n- payload: string | undefined - The initial message payload to send after connection.\n- listener: AiClientListener - The listener interface for event notifications.\n\nMethods:\n- constructor(url: string, listener: AiClientListener) -> void - Initializes the WebSocketClient with the server URL and a listener.\n- start(payload: string) -> void - Starts the WebSocket connection and sets up event handlers. Sends the initial payload once connected.\n- stop() -> void - Closes the WebSocket connection and notifies the listener.\n- send(message: string) -> void - Sends a message through the WebSocket if the connection is open.\n- onOpen(_: Event) -> void - Handles the WebSocket 'open' event, sets the connection state, and sends the initial payload.\n- onMessage(event: MessageEvent) -> void - Handles incoming messages and notifies the listener.\n- onClose(_: CloseEvent) -> void - Handles the WebSocket 'close' event, updates the connection state, and notifies the listener.\n- onError(_: Event) -> void - Handles WebSocket errors, updates the connection state, and notifies the listener.",
    "Canonical_solution": "import {AiClientListener} from \"../../AiClientListener.ts\";\nimport {AiClient} from \"../../AiClient.ts\";\n\nexport class WebSocketClient implements AiClient {\n    isStop: boolean = false\n    url: string;\n    webSocket?: WebSocket;\n    isOpen: boolean = false;\n    payload?: string;\n    listener: AiClientListener;\n\n    constructor(url: string, listener: AiClientListener) {\n        this.url = url;\n        this.listener = listener;\n    }\n\n    start(payload: string) {\n        this.listener.onStart(this);\n        this.payload = payload;\n        this.webSocket = new WebSocket(this.url);\n        this.webSocket.onopen = (e) => this.onOpen(e)\n        this.webSocket.onmessage = (e) => this.onMessage(e)\n        this.webSocket.onclose = (e) => this.onClose(e)\n        this.webSocket.onerror = (e) => this.onError(e)\n    }\n\n    stop() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = void 0;\n\n            if (!this.isStop) {\n                this.listener.onStop();\n                this.isStop = true;\n            }\n        }\n    }\n\n    send(message: string) {\n        if (this.webSocket && this.isOpen) {\n            this.webSocket.send(message);\n        }\n    }\n\n    protected onOpen(_: Event) {\n        this.isOpen = true;\n        this.send(this.payload!);\n    }\n\n    protected onMessage(event: MessageEvent) {\n        this.listener.onMessage(event.data)\n    }\n\n    protected onClose(_: CloseEvent) {\n        this.isOpen = false;\n        if (!this.isStop) {\n            this.listener.onStop();\n            this.isStop = true;\n        }\n    }\n\n    protected onError(_: Event) {\n        this.isOpen = false;\n        if (!this.isStop) {\n            this.listener.onStop();\n            this.isStop = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WebSocketClient {\n  constructor(url, listener) {\n    this.isStop = false;\n    this.url = url;\n    this.webSocket = undefined;\n    this.isOpen = false;\n    this.payload = undefined;\n    this.listener = listener;\n  }\n\n  start(payload) {\n    this.payload = payload;\n    const ws = new WebSocket(this.url);\n    this.webSocket = ws;\n    ws.onopen = this.onOpen.bind(this);\n    ws.onmessage = this.onMessage.bind(this);\n    ws.onclose = this.onClose.bind(this);\n    ws.onerror = this.onError.bind(this);\n  }\n\n  stop() {\n    if (this.webSocket) {\n      this.webSocket.close();\n      this.listener.onConnectionClosed();\n    }\n    this.isStop = true;\n  }\n\n  send(message) {\n    if (this.isOpen) {\n      this.webSocket.send(message);\n    }\n  }\n\n  onOpen(event) {\n    this.isOpen = true;\n    if (this.payload) {\n      this.webSocket.send(this.payload);\n      this.payload = undefined;\n    }\n    this.listener.onConnectionOpened();\n  }\n\n  onMessage(event) {\n    this.listener.onMessageReceived(event.data);\n  }\n\n  onClose(event) {\n    this.isOpen = false;\n    this.listener.onConnectionClosed();\n  }\n\n  onError(event) {\n    this.listener.onErrorOccurred(event);\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, listener) {\n    this.isStop = false;\n    this.url = url;\n    this.webSocket = undefined;\n    this.isOpen = false;\n    this.payload = undefined;\n    this.listener = listener;\n  }\n\n  start(payload) {\n    this.payload = payload;\n    this.webSocket = new WebSocket(this.url);\n    this.webSocket.onopen = this.onOpen;\n    this.webSocket.onmessage = this.onMessage;\n    this.webSocket.onclose = this.onClose;\n    this.webSocket.onerror = this.onError;\n  }\n\n  stop() {\n    if (this.webSocket) {\n      this.webSocket.close();\n    }\n    this.listener.onConnectionClosed();\n  }\n\n  send(message) {\n    if (this.isOpen) {\n      this.webSocket.send(message);\n    }\n  }\n\n  onOpen(event) {\n    this.isOpen = true;\n    if (this.payload) {\n      this.webSocket.send(this.payload);\n      this.payload = undefined;\n    }\n    this.listener.onConnectionOpened();\n  }\n\n  onMessage(event) {\n    this.listener.onMessageReceived(event.data);\n  }\n\n  onClose(event) {\n    this.isOpen = false;\n    this.listener.onConnectionClosed();\n  }\n\n  onError(event) {\n    this.listener.onConnectionError(event);\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(url, listener) {\n        this.isStop = false;\n        this.url = url;\n        this.webSocket = undefined;\n        this.isOpen = false;\n        this.payload = undefined;\n        this.listener = listener;\n    }\n\n    start(payload) {\n        this.payload = payload;\n        const ws = new WebSocket(this.url);\n        this.webSocket = ws;\n        ws.onopen = this.onOpen.bind(this);\n        ws.onmessage = this.onMessage.bind(this);\n        ws.onclose = this.onClose.bind(this);\n        ws.onerror = this.onError.bind(this);\n    }\n\n    stop() {\n        if (this.webSocket) {\n            this.webSocket.close();\n        }\n        this.listener.onStop();\n    }\n\n    send(message) {\n        if (this.isOpen) {\n            this.webSocket.send(message);\n        }\n    }\n\n    onOpen(event) {\n        this.isOpen = true;\n        if (this.payload) {\n            this.send(this.payload);\n        }\n        this.listener.onOpen(event);\n    }\n\n    onMessage(event) {\n        this.listener.onMessage(event);\n    }\n\n    onClose(event) {\n        this.isOpen = false;\n        this.listener.onClose(event);\n    }\n\n    onError(event) {\n        this.listener.onError(event);\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, listener) {\n    this.isStop = false;\n    this.url = url;\n    this.webSocket = undefined;\n    this.isOpen = false;\n    this.payload = undefined;\n    this.listener = listener;\n  }\n\n  start(payload) {\n    this.payload = payload;\n    this.webSocket = new WebSocket(this.url);\n    this.webSocket.onopen = this.onOpen.bind(this);\n    this.webSocket.onmessage = this.onMessage.bind(this);\n    this.webSocket.onclose = this.onClose.bind(this);\n    this.webSocket.onerror = this.onError.bind(this);\n  }\n\n  stop() {\n    if (this.webSocket) {\n      this.webSocket.close();\n    }\n    this.listener.onStop();\n    this.isStop = true;\n  }\n\n  send(message) {\n    if (this.isOpen && this.webSocket) {\n      this.webSocket.send(message);\n    }\n  }\n\n  onOpen(event) {\n    this.isOpen = true;\n    if (this.payload) {\n      this.send(this.payload);\n    }\n    this.listener.onOpen(event);\n  }\n\n  onMessage(event) {\n    this.listener.onMessage(event);\n  }\n\n  onClose(event) {\n    this.isOpen = false;\n    this.listener.onClose(event);\n  }\n\n  onError(event) {\n    this.listener.onError(event);\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(url, listener) {\n        this.isStop = false;\n        this.url = url;\n        this.webSocket = undefined;\n        this.isOpen = false;\n        this.payload = undefined;\n        this.listener = listener;\n    }\n\n    start(payload) {\n        this.payload = payload;\n        const ws = new WebSocket(this.url);\n        this.webSocket = ws;\n        ws.onopen = this.onOpen.bind(this);\n        ws.onmessage = this.onMessage.bind(this);\n        ws.onclose = this.onClose.bind(this);\n        ws.onerror = this.onError.bind(this);\n    }\n\n    stop() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.listener.onStop();\n        }\n    }\n\n    send(message) {\n        if (this.isOpen && this.webSocket) {\n            this.webSocket.send(message);\n        }\n    }\n\n    onOpen(event) {\n        this.isOpen = true;\n        if (this.payload) {\n            this.send(this.payload);\n        }\n        this.listener.onOpen(event);\n    }\n\n    onMessage(event) {\n        this.listener.onMessage(event);\n    }\n\n    onClose(event) {\n        this.isOpen = false;\n        this.listener.onClose(event);\n    }\n\n    onError(event) {\n        this.listener.onError(event);\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(url, listener) {\n        this.isStop = false;\n        this.url = url;\n        this.webSocket = undefined;\n        this.isOpen = false;\n        this.payload = undefined;\n        this.listener = listener;\n    }\n\n    start(payload) {\n        this.payload = payload;\n        this.connect();\n    }\n\n    stop() {\n        if (this.webSocket) {\n            this.webSocket.close();\n        }\n        this.isStop = true;\n        this.listener.onStop();\n    }\n\n    send(message) {\n        if (this.isOpen && this.webSocket) {\n            this.webSocket.send(message);\n        }\n    }\n\n    connect() {\n        this.webSocket = new WebSocket(this.url);\n        this.webSocket.onopen = this.onOpen.bind(this);\n        this.webSocket.onmessage = this.onMessage.bind(this);\n        this.webSocket.onclose = this.onClose.bind(this);\n        this.webSocket.onerror = this.onError.bind(this);\n    }\n\n    onOpen(event) {\n        this.isOpen = true;\n        if (this.payload) {\n            this.send(this.payload);\n        }\n        this.listener.onOpen(event);\n    }\n\n    onMessage(event) {\n        this.listener.onMessage(event);\n    }\n\n    onClose(event) {\n        this.isOpen = false;\n        this.listener.onClose(event);\n    }\n\n    onError(event) {\n        this.isOpen = false;\n        this.listener.onError(event);\n    }\n}\n\ninterface AiClientListener {\n    onOpen(event: Event): void;\n    onMessage(event: MessageEvent): void;\n    onClose(event: CloseEvent): void;\n    onError(event: Event): void;\n    onStop(): void;\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, listener) {\n    this.isStop = false;\n    this.url = url;\n    this.webSocket = undefined;\n    this.isOpen = false;\n    this.payload = undefined;\n    this.listener = listener;\n  }\n\n  start(payload) {\n    this.payload = payload;\n    this.connect();\n  }\n\n  stop() {\n    if (this.webSocket) {\n      this.webSocket.close();\n    }\n    this.isStop = true;\n    this.listener.onStop();\n  }\n\n  send(message) {\n    if (this.isOpen && this.webSocket) {\n      this.webSocket.send(message);\n    }\n  }\n\n  connect() {\n    this.webSocket = new WebSocket(this.url);\n    this.webSocket.onopen = this.onOpen.bind(this);\n    this.webSocket.onmessage = this.onMessage.bind(this);\n    this.webSocket.onclose = this.onClose.bind(this);\n    this.webSocket.onerror = this.onError.bind(this);\n  }\n\n  onOpen(event) {\n    this.isOpen = true;\n    if (this.payload) {\n      this.send(this.payload);\n    }\n    this.listener.onOpen(event);\n  }\n\n  onMessage(event) {\n    this.listener.onMessage(event);\n  }\n\n  onClose(event) {\n    this.isOpen = false;\n    this.listener.onClose(event);\n  }\n\n  onError(event) {\n    this.isOpen = false;\n    this.listener.onError(event);\n  }\n}\n\ninterface AiClientListener {\n  onOpen(event: Event): void;\n  onMessage(event: MessageEvent): void;\n  onClose(event: CloseEvent): void;\n  onError(event: Event): void;\n  onStop(): void;\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, listener) {\n    this.isStop = false;\n    this.url = url;\n    this.webSocket = undefined;\n    this.isOpen = false;\n    this.payload = undefined;\n    this.listener = listener;\n  }\n\n  start(payload) {\n    this.payload = payload;\n    this.connect();\n  }\n\n  stop() {\n    this.isStop = true;\n    if (this.webSocket) {\n      this.webSocket.close();\n    }\n    this.listener.onStop();\n  }\n\n  send(message) {\n    if (this.isOpen && this.webSocket) {\n      this.webSocket.send(message);\n    }\n  }\n\n  connect() {\n    if (this.isStop) return;\n    this.webSocket = new WebSocket(this.url);\n    this.webSocket.onopen = this.onOpen.bind(this);\n    this.webSocket.onmessage = this.onMessage.bind(this);\n    this.webSocket.onclose = this.onClose.bind(this);\n    this.webSocket.onerror = this.onError.bind(this);\n  }\n\n  onOpen(event) {\n    this.isOpen = true;\n    if (this.payload) {\n      this.send(this.payload);\n    }\n    this.listener.onOpen(event);\n  }\n\n  onMessage(event) {\n    this.listener.onMessage(event);\n  }\n\n  onClose(event) {\n    this.isOpen = false;\n    this.listener.onClose(event);\n  }\n\n  onError(event) {\n    this.isOpen = false;\n    this.listener.onError(event);\n  }\n}\n\ninterface AiClientListener {\n  onOpen(event: Event): void;\n  onMessage(event: MessageEvent): void;\n  onClose(event: CloseEvent): void;\n  onError(event: Event): void;\n  onStop(): void;\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, listener) {\n    this.isStop = false;\n    this.url = url;\n    this.webSocket = undefined;\n    this.isOpen = false;\n    this.payload = undefined;\n    this.listener = listener;\n  }\n\n  start(payload) {\n    this.payload = payload;\n    this.connect();\n  }\n\n  stop() {\n    if (this.webSocket) {\n      this.webSocket.close();\n    }\n    this.isStop = true;\n    this.listener.onStop();\n  }\n\n  send(message) {\n    if (this.isOpen && this.webSocket) {\n      this.webSocket.send(message);\n    }\n  }\n\n  connect() {\n    if (this.isStop) return;\n    this.webSocket = new WebSocket(this.url);\n    this.webSocket.onopen = this.onOpen.bind(this);\n    this.webSocket.onmessage = this.onMessage.bind(this);\n    this.webSocket.onclose = this.onClose.bind(this);\n    this.webSocket.onerror = this.onError.bind(this);\n  }\n\n  onOpen(event) {\n    this.isOpen = true;\n    if (this.payload) {\n      this.send(this.payload);\n    }\n    this.listener.onOpen(event);\n  }\n\n  onMessage(event) {\n    this.listener.onMessage(event);\n  }\n\n  onClose(event) {\n    this.isOpen = false;\n    this.listener.onClose(event);\n  }\n\n  onError(event) {\n    this.isOpen = false;\n    this.listener.onError(event);\n  }\n}\n\ninterface AiClientListener {\n  onOpen(event: Event): void;\n  onMessage(event: MessageEvent): void;\n  onClose(event: CloseEvent): void;\n  onError(event: Event): void;\n  onStop(): void;\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, listener) {\n    this.isStop = false;\n    this.url = url;\n    this.webSocket = undefined;\n    this.isOpen = false;\n    this.payload = undefined;\n    this.listener = listener;\n  }\n\n  start(payload) {\n    this.payload = payload;\n    this.connect();\n  }\n\n  stop() {\n    this.isStop = true;\n    if (this.webSocket) {\n      this.webSocket.close();\n    }\n    this.listener.onStop();\n  }\n\n  send(message) {\n    if (this.isOpen && this.webSocket) {\n      this.webSocket.send(message);\n    }\n  }\n\n  connect() {\n    if (this.isStop) return;\n    this.webSocket = new WebSocket(this.url);\n    this.webSocket.onopen = this.onOpen.bind(this);\n    this.webSocket.onmessage = this.onMessage.bind(this);\n    this.webSocket.onclose = this.onClose.bind(this);\n    this.webSocket.onerror = this.onError.bind(this);\n  }\n\n  onOpen(event) {\n    this.isOpen = true;\n    if (this.payload) {\n      this.send(this.payload);\n    }\n    this.listener.onOpen(event);\n  }\n\n  onMessage(event) {\n    this.listener.onMessage(event);\n  }\n\n  onClose(event) {\n    this.isOpen = false;\n    this.listener.onClose(event);\n  }\n\n  onError(event) {\n    this.isOpen = false;\n    this.listener.onError(event);\n  }\n}\n\ninterface AiClientListener {\n  onOpen(event: Event): void;\n  onMessage(event: MessageEvent): void;\n  onClose(event: CloseEvent): void;\n  onError(event: Event): void;\n  onStop(): void;\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 213,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that connects to a server for real-time speech-to-text (STT) transcription, handles incoming messages, and updates the UI accordingly.\n\nFunction Description: The function `connectToDataSocket` establishes a WebSocket connection to a specified URL, sets up event handlers for connection status, incoming messages, errors, and connection closure. It processes real-time transcription data and full sentence updates, displaying them in designated HTML elements while handling errors gracefully.\n\nInput: None (The function uses the global variable `dataURL` for WebSocket endpoint and assumes predefined HTML elements: `statusDiv`, `transcriptionDiv`, `fullTextDiv`, `transcriptionContainer`, `fullTextContainer`)\n\nOutput: None (The function's effects are side-effects: updates UI elements and logs to console)",
    "Canonical_solution": "function connectToDataSocket() {\n    dataSocket = new WebSocket(dataURL);\n\n    dataSocket.onopen = () => {\n        statusDiv.textContent = \"Connected to STT server.\";\n        console.log(\"Connected to data WebSocket.\");\n    };\n\n    dataSocket.onmessage = (event) => {\n        try {\n            const message = JSON.parse(event.data);\n\n            if (message.type === \"realtime\") {\n                let words = message.text.split(\" \");\n                let lastWord = words.pop();\n                transcriptionDiv.innerHTML = `${words.join(\" \")} <span class=\"last-word\">${lastWord}</span>`;\n\n                const transcriptionContainer = document.getElementById(\"transcriptionContainer\");\n                transcriptionContainer.scrollTop = transcriptionContainer.scrollHeight;\n            } else if (message.type === \"fullSentence\") {\n                fullTextDiv.innerHTML += message.text + \" \";\n                transcriptionDiv.innerHTML = message.text;\n\n                const fullTextContainer = document.getElementById(\"fullTextContainer\");\n                fullTextContainer.scrollTop = fullTextContainer.scrollHeight;\n            }\n        } catch (e) {\n            console.error(\"Error parsing message:\", e);\n        }\n    };\n\n    dataSocket.onclose = () => {\n        statusDiv.textContent = \"Disconnected from STT server.\";\n    };\n\n    dataSocket.onerror = (error) => {\n        console.error(\"WebSocket error:\", error);\n        statusDiv.textContent = \"Error connecting to the STT server.\";\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n    document.getElementById('statusDiv').innerText = 'Connected';\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').innerText += data.transcription + ' ';\n      document.getElementById('transcriptionContainer').scrollTop = document.getElementById('transcriptionContainer').scrollHeight;\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').innerText = data.fullText;\n      document.getElementById('fullTextContainer').scrollTop = document.getElementById('fullTextContainer').scrollHeight;\n    }\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket error:', error);\n    document.getElementById('statusDiv').innerText = 'Error';\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed:', event);\n    document.getElementById('statusDiv').innerText = 'Disconnected';\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    document.getElementById('statusDiv').textContent = 'Connected';\n    console.log('WebSocket connection established');\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').textContent += data.transcription + ' ';\n      document.getElementById('transcriptionContainer').scrollTop = document.getElementById('transcriptionContainer').scrollHeight;\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').textContent = data.fullText;\n      document.getElementById('fullTextContainer').scrollTop = document.getElementById('fullTextContainer').scrollHeight;\n    }\n  };\n\n  socket.onerror = function(error) {\n    document.getElementById('statusDiv').textContent = 'Error';\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onclose = function(event) {\n    document.getElementById('statusDiv').textContent = 'Disconnected';\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    document.getElementById('statusDiv').innerText = 'Connected';\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').innerText = data.transcription;\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').innerText = data.fullText;\n    }\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket Error:', error);\n    document.getElementById('statusDiv').innerText = 'Error';\n  };\n\n  socket.onclose = function(event) {\n    document.getElementById('statusDiv').innerText = 'Disconnected';\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    document.getElementById('statusDiv').innerText = 'Connected';\n    console.log('WebSocket connection established');\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').innerText += data.transcription + '\\n';\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').innerText = data.fullText;\n    }\n  };\n\n  socket.onerror = function(error) {\n    document.getElementById('statusDiv').innerText = 'Error';\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onclose = function(event) {\n    document.getElementById('statusDiv').innerText = 'Disconnected';\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    document.getElementById('statusDiv').innerText = 'Connected';\n    console.log('WebSocket connection established');\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').innerText += data.transcription + '\\n';\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').innerText = data.fullText;\n    }\n  };\n\n  socket.onerror = function(error) {\n    document.getElementById('statusDiv').innerText = 'Error';\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onclose = function(event) {\n    document.getElementById('statusDiv').innerText = 'Disconnected';\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    document.getElementById('statusDiv').innerText = 'Connected';\n    console.log('WebSocket connection established');\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').innerText += data.transcription + ' ';\n      document.getElementById('transcriptionContainer').scrollTop = document.getElementById('transcriptionContainer').scrollHeight;\n    } else if (data.fullText) {\n      document.getElementById('fullTextDiv').innerText = data.fullText;\n      document.getElementById('fullTextContainer').scrollTop = document.getElementById('fullTextContainer').scrollHeight;\n    }\n  };\n\n  socket.onerror = function(error) {\n    document.getElementById('statusDiv').innerText = 'Error';\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onclose = function(event) {\n    document.getElementById('statusDiv').innerText = 'Disconnected';\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    document.getElementById('statusDiv').textContent = 'Connected';\n    console.log('WebSocket connection established');\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').textContent += data.transcription + '\\n';\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').textContent = data.fullText;\n    }\n  };\n\n  socket.onerror = function(error) {\n    document.getElementById('statusDiv').textContent = 'Error';\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onclose = function(event) {\n    document.getElementById('statusDiv').textContent = 'Disconnected';\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    document.getElementById('statusDiv').innerText = 'Connected';\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').innerText += data.transcription + ' ';\n      document.getElementById('transcriptionContainer').scrollTop = document.getElementById('transcriptionContainer').scrollHeight;\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').innerText = data.fullText;\n      document.getElementById('fullTextContainer').scrollTop = document.getElementById('fullTextContainer').scrollHeight;\n    }\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket Error:', error);\n    document.getElementById('statusDiv').innerText = 'Error';\n  };\n\n  socket.onclose = function(event) {\n    document.getElementById('statusDiv').innerText = 'Disconnected';\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n    document.getElementById('statusDiv').textContent = 'Connected';\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').textContent = data.transcription;\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').textContent = data.fullText;\n    }\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket error:', error);\n    document.getElementById('statusDiv').textContent = 'Error';\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed:', event);\n    document.getElementById('statusDiv').textContent = 'Disconnected';\n  };\n}\n```",
      "```javascript\nfunction connectToDataSocket() {\n  const socket = new WebSocket(dataURL);\n\n  socket.onopen = function(event) {\n    document.getElementById('statusDiv').innerText = 'Connected';\n    console.log('WebSocket connection established');\n  };\n\n  socket.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.transcription) {\n      document.getElementById('transcriptionDiv').innerText += data.transcription + '\\n';\n    }\n    if (data.fullText) {\n      document.getElementById('fullTextDiv').innerText = data.fullText;\n    }\n  };\n\n  socket.onerror = function(error) {\n    document.getElementById('statusDiv').innerText = 'Error: ' + error.message;\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onclose = function(event) {\n    document.getElementById('statusDiv').innerText = 'Disconnected';\n    console.log('WebSocket connection closed');\n  };\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript to establish a connection with a server, send a command, and handle connection events.\n\nFunction Description: The code establishes a WebSocket connection to a specified URL with a custom protocol. It sends a \"REBOOT\" command upon successful connection and provides empty handlers for incoming messages and connection closure. Error handling is included for connection issues.\n\nInput: None (The WebSocket URL is obtained internally via get_appropriate_ws_url() function)\n\nOutput: None (The function establishes a WebSocket connection and sends a command, but doesn't return any value)\n\nKey Steps:\n1. Initialize WebSocket connection with appropriate browser API (MozWebSocket or standard WebSocket)\n2. Set up event handlers for connection opening, message reception, and connection closing\n3. Implement error handling for connection attempts\n4. Send \"REBOOT\" command upon successful connection\n5. Provide empty handlers for message reception and connection closing events",
    "Canonical_solution": "function init_command() {\n    socket_command.send(\"REBOOT\\n\");\n}\n\nvar socket_command;\n\nif (typeof MozWebSocket != \"undefined\") {\n    socket_command = new MozWebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n} else {\n    socket_command = new WebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n}\n\ntry {\n    socket_command.onopen = function() {\n        init_command();\n    }\n\n    socket_command.onmessage = function got_packet(msg) {\n    }\n\n    socket_command.onclose = function(){\n    }\n} catch(exception) {\n    alert('<p>Error' + exception);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nvar ws;\n\nfunction get_appropriate_ws_url() {\n  // Implementation to get the WebSocket URL\n}\n\nfunction setupWebSocket() {\n  var url = get_appropriate_ws_url();\n  if (window.MozWebSocket) {\n    ws = new MozWebSocket(url);\n  } else {\n    ws = new WebSocket(url);\n  }\n\n  ws.onopen = function() {\n    ws.send(\"REBOOT\");\n  };\n\n  ws.onmessage = function() {};\n\n  ws.onclose = function() {};\n\n  ws.onerror = function() {};\n}\n\nsetupWebSocket();\n```",
      "```javascript\nvar ws_url = get_appropriate_ws_url();\nvar ws;\n\nif (window.MozWebSocket) {\n    ws = new MozWebSocket(ws_url);\n} else {\n    ws = new WebSocket(ws_url);\n}\n\nws.onopen = function() {\n    ws.send(\"REBOOT\");\n};\n\nws.onmessage = function() {};\n\nws.onclose = function() {};\n\nws.onerror = function() {};\n```",
      "```javascript\nvar ws;\n\nfunction get_appropriate_ws_url() {\n  // Placeholder function to simulate getting a WebSocket URL\n  return 'wss://example.com/socket';\n}\n\nfunction setupWebSocket() {\n  var url = get_appropriate_ws_url();\n  if (window.MozWebSocket) {\n    ws = new MozWebSocket(url);\n  } else {\n    ws = new WebSocket(url);\n  }\n\n  ws.onopen = function() {\n    ws.send('REBOOT');\n  };\n\n  ws.onmessage = function(event) {};\n\n  ws.onclose = function() {};\n\n  ws.onerror = function(error) {\n    console.error('WebSocket Error:', error);\n  };\n}\n\nsetupWebSocket();\n```",
      "```javascript\nvar ws_url = get_appropriate_ws_url();\nvar ws;\n\nif (window.MozWebSocket) {\n    ws = new MozWebSocket(ws_url);\n} else {\n    ws = new WebSocket(ws_url);\n}\n\nws.onopen = function() {\n    ws.send(\"REBOOT\");\n};\n\nws.onmessage = function() {};\n\nws.onclose = function() {};\n\nws.onerror = function(error) {\n    console.error(\"WebSocket Error: \" + error);\n};\n```",
      "```javascript\nvar ws_url = get_appropriate_ws_url();\nvar ws = new WebSocket(ws_url, 'custom-protocol');\n\nws.onopen = function() {\n    ws.send('REBOOT');\n};\n\nws.onmessage = function() {};\n\nws.onclose = function() {};\n\nws.onerror = function(error) {\n    console.error('WebSocket Error:', error);\n};\n```",
      "```javascript\nvar ws_url = get_appropriate_ws_url();\nvar ws;\n\nif (window.MozWebSocket) {\n    ws = new MozWebSocket(ws_url);\n} else {\n    ws = new WebSocket(ws_url);\n}\n\nws.onopen = function() {\n    ws.send(\"REBOOT\");\n};\n\nws.onmessage = function() {};\n\nws.onclose = function() {};\n\nws.onerror = function() {};\n```",
      "```javascript\nvar ws_url = get_appropriate_ws_url();\nvar ws;\n\nfunction get_appropriate_ws_url() {\n  // Implementation to get the WebSocket URL\n}\n\nfunction connect_to_server() {\n  if (window.MozWebSocket) {\n    ws = new MozWebSocket(ws_url);\n  } else {\n    ws = new WebSocket(ws_url);\n  }\n\n  ws.onopen = function() {\n    ws.send(\"REBOOT\");\n  };\n\n  ws.onmessage = function(event) {};\n\n  ws.onclose = function() {};\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket Error: \" + error);\n  };\n}\n\nconnect_to_server();\n```",
      "```javascript\nvar ws;\n\nfunction get_appropriate_ws_url() {\n  // Implementation to get the WebSocket URL\n}\n\nfunction connect_to_server() {\n  var url = get_appropriate_ws_url();\n  if (window.MozWebSocket) {\n    ws = new MozWebSocket(url);\n  } else {\n    ws = new WebSocket(url);\n  }\n\n  ws.onopen = function() {\n    ws.send(\"REBOOT\");\n  };\n\n  ws.onmessage = function() {};\n\n  ws.onclose = function() {};\n\n  ws.onerror = function() {};\n}\n\nconnect_to_server();\n```",
      "```javascript\nvar ws_url = get_appropriate_ws_url();\nvar ws;\n\nif (window.MozWebSocket) {\n    ws = new MozWebSocket(ws_url);\n} else {\n    ws = new WebSocket(ws_url);\n}\n\nws.onopen = function() {\n    ws.send(\"REBOOT\");\n};\n\nws.onmessage = function() {};\n\nws.onclose = function() {};\n\nws.onerror = function() {};\n```",
      "```javascript\nvar ws_url = get_appropriate_ws_url();\nvar ws;\n\nif (window.MozWebSocket) {\n    ws = new MozWebSocket(ws_url);\n} else {\n    ws = new WebSocket(ws_url);\n}\n\nws.onopen = function() {\n    ws.send(\"REBOOT\");\n};\n\nws.onmessage = function(event) {};\n\nws.onclose = function(event) {};\n\nws.onerror = function(error) {};\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 215,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, handles incoming messages, errors, and sends messages to the server.\n\nFunction Description: The WebSocket client will initialize a connection to a specified WebSocket server URI, define event handlers for connection opening, incoming messages, and errors, and provide a function to send messages to the server.\n\nInput:\n- wsUri: [String] - The WebSocket server URI to connect to.\n- username: [String] - The username of the client sending messages.\n- textField: [HTMLInputElement] - The input field containing the message to send.\n- userField: [HTMLElement] - The HTML element to display the list of connected users.\n- chatlogField: [HTMLElement] - The HTML element to display the chat log.\n\nOutput:\n- None (The functions handle events and update the DOM directly).\n\nMethods:\n- send_message(): [Function]() -> [void] - Sends a message to the WebSocket server in the format \"username: message\".\n- onMessage(): [Function](evt: [MessageEvent]) -> [void] - Handles incoming messages, updating the user list or chat log based on the message content.\n- onError(): [Function](evt: [ErrorEvent]) -> [void] - Logs errors to the console and displays them in the DOM.\n- onOpen(): [Function](evt: [Event]) -> [void] - Handles the WebSocket connection opening event (implementation not shown in reference code).",
    "Canonical_solution": "function send_message() {\n    websocket.send(username + \": \" + textField.value);\n}\n\nfunction onMessage(evt) {\n    console.log(\"onMessage: \" + evt.data);\n    if (evt.data.indexOf(\"joined\") != -1) {\n        userField.innerHTML += evt.data.substring(0, evt.data.indexOf(\" joined\")) + \"\\n\";\n    } else {\n        chatlogField.innerHTML += evt.data + \"\\n\";\n    }\n}\n\nfunction onError(evt) {\n    writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nvar websocket = new WebSocket(wsUri);\nwebsocket.onopen = function(evt) { onOpen(evt) };\nwebsocket.onmessage = function(evt) { onMessage(evt) };\nwebsocket.onerror = function(evt) { onError(evt) };",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst wsUri = 'ws://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nconst ws = new WebSocket(wsUri);\n\nws.onopen = onOpen;\nws.onmessage = onMessage;\nws.onerror = onError;\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  const messageParts = data.split(': ');\n  if (messageParts[0] === 'userlist') {\n    userField.innerHTML = messageParts[1];\n  } else {\n    chatlogField.innerHTML += `<div>${data}</div>`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket Error:', evt);\n  chatlogField.innerHTML += `<div>Error: ${evt.message}</div>`;\n}\n\nfunction onOpen(evt) {\n  // Implementation not shown in reference code\n}\n```",
      "```javascript\nconst wsUri = 'wss://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nconst ws = new WebSocket(wsUri);\n\nws.onopen = onOpen;\nws.onmessage = onMessage;\nws.onerror = onError;\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  if (data.startsWith('user:')) {\n    const users = data.split(':')[1].split(',');\n    userField.textContent = users.join(', ');\n  } else {\n    chatlogField.textContent += `${data}\\n`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket error:', evt);\n  chatlogField.textContent += `Error: ${evt.message}\\n`;\n}\n\nfunction onOpen(evt) {\n  // Implementation not shown in reference code\n}\n```",
      "```javascript\nconst wsUri = 'ws://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nlet ws = new WebSocket(wsUri);\n\nws.onopen = function(evt) {\n  // Implementation not shown\n};\n\nws.onmessage = function(evt) {\n  onMessage(evt);\n};\n\nws.onerror = function(evt) {\n  onError(evt);\n};\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  if (data.startsWith('user:')) {\n    const users = data.split(':')[1].split(',');\n    userField.textContent = users.join(', ');\n  } else {\n    chatlogField.textContent += `${data}\\n`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket Error:', evt);\n  chatlogField.textContent += `Error: ${evt.message}\\n`;\n}\n```",
      "```javascript\nconst wsUri = 'wss://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nlet ws = new WebSocket(wsUri);\n\nws.onopen = function(evt) {\n    // Implementation not shown\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction send_message() {\n    const message = textField.value;\n    ws.send(`${username}: ${message}`);\n    textField.value = '';\n}\n\nfunction onMessage(evt) {\n    const data = evt.data;\n    const messageParts = data.split(':');\n    const sender = messageParts[0];\n    const messageContent = messageParts[1];\n\n    if (sender === username) {\n        chatlogField.innerHTML += `<div>${messageContent}</div>`;\n    } else {\n        userField.innerHTML += `<div>${sender}</div>`;\n    }\n}\n\nfunction onError(evt) {\n    console.error('WebSocket Error:', evt);\n    chatlogField.innerHTML += `<div>Error: ${evt.message}</div>`;\n}\n```",
      "```javascript\nconst wsUri = 'wss://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nlet ws = new WebSocket(wsUri);\n\nws.onopen = function(evt) {\n  // Implementation not shown\n};\n\nws.onmessage = function(evt) {\n  onMessage(evt);\n};\n\nws.onerror = function(evt) {\n  onError(evt);\n};\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  if (data.startsWith('user:')) {\n    const users = data.split(':')[1].split(',');\n    userField.textContent = users.join(', ');\n  } else {\n    chatlogField.textContent += `${data}\\n`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket Error:', evt);\n  chatlogField.textContent += `Error: ${evt.message}\\n`;\n}\n```",
      "```javascript\nconst wsUri = 'wss://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nconst ws = new WebSocket(wsUri);\n\nws.onopen = onOpen;\nws.onmessage = onMessage;\nws.onerror = onError;\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  if (data.startsWith('user:')) {\n    const users = data.split(':')[1].split(',');\n    userField.textContent = users.join(', ');\n  } else {\n    chatlogField.textContent += `${data}\\n`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket error:', evt);\n  chatlogField.textContent += `Error: ${evt.message}\\n`;\n}\n\nfunction onOpen(evt) {\n  // Implementation not shown\n}\n```",
      "```javascript\nconst wsUri = 'ws://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nlet ws = new WebSocket(wsUri);\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  const messageParts = data.split(': ');\n  if (messageParts[0] === 'userlist') {\n    userField.innerHTML = messageParts[1];\n  } else {\n    chatlogField.innerHTML += `<div>${data}</div>`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket Error:', evt);\n  chatlogField.innerHTML += `<div>Error: ${evt.message}</div>`;\n}\n\nfunction onOpen(evt) {\n  // Implementation not shown\n}\n\nws.onmessage = onMessage;\nws.onerror = onError;\nws.onopen = onOpen;\n```",
      "```javascript\nconst wsUri = 'wss://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nconst ws = new WebSocket(wsUri);\n\nws.onopen = onOpen;\nws.onmessage = onMessage;\nws.onerror = onError;\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  if (data.startsWith('user:')) {\n    const users = data.split(':')[1];\n    userField.textContent = users;\n  } else {\n    chatlogField.textContent += `\\n${data}`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket error:', evt);\n  chatlogField.textContent += `\\nError: ${evt.message}`;\n}\n\nfunction onOpen(evt) {\n  // Implementation not shown\n}\n```",
      "```javascript\nconst wsUri = 'wss://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nconst ws = new WebSocket(wsUri);\n\nws.onopen = onOpen;\nws.onmessage = onMessage;\nws.onerror = onError;\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  if (data.startsWith('user:')) {\n    userField.textContent = data.substring(5);\n  } else {\n    chatlogField.textContent += `${data}\\n`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket error:', evt);\n  chatlogField.textContent += `Error: ${evt.message}\\n`;\n}\n\nfunction onOpen(evt) {\n  // Implementation not shown\n}\n```",
      "```javascript\nconst wsUri = 'ws://example.com/socket';\nconst username = 'user123';\nconst textField = document.getElementById('messageInput');\nconst userField = document.getElementById('userList');\nconst chatlogField = document.getElementById('chatLog');\n\nconst ws = new WebSocket(wsUri);\n\nws.onopen = onOpen;\nws.onmessage = onMessage;\nws.onerror = onError;\n\nfunction send_message() {\n  const message = `${username}: ${textField.value}`;\n  ws.send(message);\n  textField.value = '';\n}\n\nfunction onMessage(evt) {\n  const data = evt.data;\n  if (data.startsWith('user:')) {\n    const users = data.split(':')[1].split(',');\n    userField.textContent = users.join(', ');\n  } else {\n    chatlogField.textContent += `${data}\\n`;\n  }\n}\n\nfunction onError(evt) {\n  console.error('WebSocket error:', evt);\n  chatlogField.textContent += `Error: ${evt.message}\\n`;\n}\n\nfunction onOpen(evt) {\n  // Implementation not shown in reference code\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 216,
    "Instruction": "Task Description: Create a WebSocket client function in JavaScript that establishes a connection to a server, handles incoming messages, and manages connection events.\n\nFunction Description: The `connectServer` function initializes a WebSocket connection to a specified port on localhost. It sets up event handlers for connection opening, incoming messages, and connection closing. The function processes different types of messages (config, checkResult, moduleStart, moduleEnd, mobileAppInfo) and triggers appropriate actions including notifications and event emissions.\n\nInput:\n- port: Number - The port number to connect to on localhost (127.0.0.1)\n\nOutput: None (The function establishes a WebSocket connection and sets up event handlers but doesn't return any value)\n\nNote: The function maintains connection state through the global variable `wsSocket` and interacts with other parts of the system through the `GlobalEvents` emitter and Chrome notifications API.",
    "Canonical_solution": "function connectServer(port) {\n    if (!wsSocket) {\n        wsSocket = new WebSocket('ws://127.0.0.1:' + port, \"protocolOne\");\n        wsSocket.onopen = function(event) {\n            console.log('ws connected!');\n        }\n        wsSocket.onmessage = function(message) {\n            message = message.data;\n            try {\n                message = JSON.parse(message);\n            } catch (e) {}\n            var type = message.type;\n            var data = message.data;\n            switch (type) {\n                case 'config':\n                    recordConfig = data;\n                    i18n = recordConfig.i18n;\n                    GlobalEvents.emit('updateConfig', recordConfig);\n                    break;\n                case 'checkResult':\n                    chrome.notifications.create({\n                        type: 'basic',\n                        iconUrl: 'img/' + (data.success ? 'success' : 'fail') + '.png',\n                        title: data.success ? __('exec_succeed') : __('exec_failed'),\n                        message: data.title\n                    });\n                    GlobalEvents.emit('checkResult', data);\n                    break;\n                case 'moduleStart':\n                    isModuleLoading = true;\n                    recordConfig.isModuleLoading = true;\n                    chrome.notifications.create({\n                        type: 'basic',\n                        iconUrl: 'img/warn.png',\n                        title: __('module_start_title'),\n                        message: __('module_start_message', data.file)\n                    });\n                    GlobalEvents.emit('moduleStart');\n                    break;\n                case 'moduleEnd':\n                    isModuleLoading = false;\n                    recordConfig.isModuleLoading = false;\n                    chrome.notifications.create({\n                        type: 'basic',\n                        iconUrl: 'img/' + (data.success ? 'success' : 'fail') + '.png',\n                        title: __('module_end_title'),\n                        message: __('module_end_message', data.success ? __('succeed') : __('failed'), data.file)\n                    });\n                    GlobalEvents.emit('moduleEnd');\n                    break;\n                case 'mobileAppInfo':\n                    GlobalEvents.emit('mobileAppInfo', data);\n                    break;\n            }\n        }\n        wsSocket.onclose = function() {\n            wsSocket = null;\n            console.log('ws closed!');\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nconst GlobalEvents = new EventEmitter();\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    console.log('Connection opened');\n    GlobalEvents.emit('connectionOpened');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        console.log('Received config message');\n        GlobalEvents.emit('configReceived', message.data);\n        break;\n      case 'checkResult':\n        console.log('Received checkResult message');\n        GlobalEvents.emit('checkResultReceived', message.data);\n        break;\n      case 'moduleStart':\n        console.log('Received moduleStart message');\n        GlobalEvents.emit('moduleStartReceived', message.data);\n        break;\n      case 'moduleEnd':\n        console.log('Received moduleEnd message');\n        GlobalEvents.emit('moduleEndReceived', message.data);\n        break;\n      case 'mobileAppInfo':\n        console.log('Received mobileAppInfo message');\n        GlobalEvents.emit('mobileAppInfoReceived', message.data);\n        break;\n      default:\n        console.log('Received unknown message type');\n        break;\n    }\n  });\n\n  ws.on('close', function close() {\n    console.log('Connection closed');\n    GlobalEvents.emit('connectionClosed');\n  });\n\n  ws.on('error', function error(err) {\n    console.error('WebSocket error:', err);\n    GlobalEvents.emit('connectionError', err);\n  });\n\n  wsSocket = ws;\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nconst GlobalEvents = new EventEmitter();\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    GlobalEvents.emit('connectionOpen');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        // Handle config message\n        break;\n      case 'checkResult':\n        // Handle checkResult message\n        break;\n      case 'moduleStart':\n        // Handle moduleStart message\n        break;\n      case 'moduleEnd':\n        // Handle moduleEnd message\n        break;\n      case 'mobileAppInfo':\n        // Handle mobileAppInfo message\n        break;\n      default:\n        // Handle unknown message type\n        break;\n    }\n  });\n\n  ws.on('close', function close() {\n    GlobalEvents.emit('connectionClose');\n  });\n\n  ws.on('error', function error(err) {\n    GlobalEvents.emit('connectionError', err);\n  });\n\n  wsSocket = ws;\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nclass GlobalEvents extends EventEmitter {}\n\nconst globalEvents = new GlobalEvents();\n\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    globalEvents.emit('connectionOpen');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        // Handle config message\n        break;\n      case 'checkResult':\n        // Handle checkResult message\n        break;\n      case 'moduleStart':\n        // Handle moduleStart message\n        break;\n      case 'moduleEnd':\n        // Handle moduleEnd message\n        break;\n      case 'mobileAppInfo':\n        // Handle mobileAppInfo message\n        break;\n      default:\n        // Handle unknown message type\n        break;\n    }\n  });\n\n  ws.on('close', function close() {\n    globalEvents.emit('connectionClose');\n  });\n\n  ws.on('error', function error(err) {\n    globalEvents.emit('connectionError', err);\n  });\n\n  wsSocket = ws;\n}\n\nmodule.exports = { connectServer, globalEvents };\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nclass GlobalEvents extends EventEmitter {}\n\nconst globalEvents = new GlobalEvents();\n\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const socket = new WebSocket('ws://127.0.0.1:' + port);\n\n  wsSocket = socket;\n\n  socket.on('open', function() {\n    globalEvents.emit('connectionOpen');\n  });\n\n  socket.on('message', function(message) {\n    const data = JSON.parse(message);\n    switch (data.type) {\n      case 'config':\n        handleConfig(data);\n        break;\n      case 'checkResult':\n        handleCheckResult(data);\n        break;\n      case 'moduleStart':\n        handleModuleStart(data);\n        break;\n      case 'moduleEnd':\n        handleModuleEnd(data);\n        break;\n      case 'mobileAppInfo':\n        handleMobileAppInfo(data);\n        break;\n      default:\n        console.log('Unknown message type:', data.type);\n    }\n  });\n\n  socket.on('close', function() {\n    globalEvents.emit('connectionClose');\n  });\n\n  socket.on('error', function(error) {\n    globalEvents.emit('connectionError', error);\n  });\n}\n\nfunction handleConfig(data) {\n  // Handle config message\n}\n\nfunction handleCheckResult(data) {\n  // Handle checkResult message\n}\n\nfunction handleModuleStart(data) {\n  // Handle moduleStart message\n}\n\nfunction handleModuleEnd(data) {\n  // Handle moduleEnd message\n}\n\nfunction handleMobileAppInfo(data) {\n  // Handle mobileAppInfo message\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nconst GlobalEvents = new EventEmitter();\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    wsSocket = ws;\n    GlobalEvents.emit('connectionOpen');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        // Handle config message\n        break;\n      case 'checkResult':\n        // Handle checkResult message\n        break;\n      case 'moduleStart':\n        // Handle moduleStart message\n        break;\n      case 'moduleEnd':\n        // Handle moduleEnd message\n        break;\n      case 'mobileAppInfo':\n        // Handle mobileAppInfo message\n        break;\n    }\n  });\n\n  ws.on('close', function close() {\n    wsSocket = null;\n    GlobalEvents.emit('connectionClose');\n  });\n\n  ws.on('error', function error(err) {\n    console.error('WebSocket error:', err);\n    GlobalEvents.emit('connectionError', err);\n  });\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nconst GlobalEvents = new EventEmitter();\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    GlobalEvents.emit('connectionOpen');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        // Handle config message\n        break;\n      case 'checkResult':\n        // Handle checkResult message\n        break;\n      case 'moduleStart':\n        // Handle moduleStart message\n        break;\n      case 'moduleEnd':\n        // Handle moduleEnd message\n        break;\n      case 'mobileAppInfo':\n        // Handle mobileAppInfo message\n        break;\n    }\n  });\n\n  ws.on('close', function close() {\n    GlobalEvents.emit('connectionClose');\n  });\n\n  ws.on('error', function error(err) {\n    GlobalEvents.emit('connectionError', err);\n  });\n\n  wsSocket = ws;\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nconst GlobalEvents = new EventEmitter();\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    console.log('Connected to server');\n    GlobalEvents.emit('connectionOpen');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        // Handle config message\n        break;\n      case 'checkResult':\n        // Handle checkResult message\n        break;\n      case 'moduleStart':\n        // Handle moduleStart message\n        break;\n      case 'moduleEnd':\n        // Handle moduleEnd message\n        break;\n      case 'mobileAppInfo':\n        // Handle mobileAppInfo message\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  });\n\n  ws.on('close', function close() {\n    console.log('Disconnected from server');\n    GlobalEvents.emit('connectionClose');\n  });\n\n  ws.on('error', function error(err) {\n    console.error('WebSocket error:', err);\n    GlobalEvents.emit('connectionError', err);\n  });\n\n  wsSocket = ws;\n}\n\nmodule.exports = connectServer;\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nclass GlobalEvents extends EventEmitter {}\n\nconst globalEvents = new GlobalEvents();\n\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    globalEvents.emit('connectionOpen');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        handleConfig(message);\n        break;\n      case 'checkResult':\n        handleCheckResult(message);\n        break;\n      case 'moduleStart':\n        handleModuleStart(message);\n        break;\n      case 'moduleEnd':\n        handleModuleEnd(message);\n        break;\n      case 'mobileAppInfo':\n        handleMobileAppInfo(message);\n        break;\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  });\n\n  ws.on('close', function close() {\n    globalEvents.emit('connectionClose');\n  });\n\n  ws.on('error', function error(err) {\n    globalEvents.emit('connectionError', err);\n  });\n\n  function handleConfig(message) {\n    // Handle config message\n  }\n\n  function handleCheckResult(message) {\n    // Handle checkResult message\n  }\n\n  function handleModuleStart(message) {\n    // Handle moduleStart message\n  }\n\n  function handleModuleEnd(message) {\n    // Handle moduleEnd message\n  }\n\n  function handleMobileAppInfo(message) {\n    // Handle mobileAppInfo message\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nclass GlobalEvents extends EventEmitter {}\n\nconst globalEvents = new GlobalEvents();\n\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    globalEvents.emit('connectionOpen');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        // Handle config message\n        break;\n      case 'checkResult':\n        // Handle checkResult message\n        break;\n      case 'moduleStart':\n        // Handle moduleStart message\n        break;\n      case 'moduleEnd':\n        // Handle moduleEnd message\n        break;\n      case 'mobileAppInfo':\n        // Handle mobileAppInfo message\n        break;\n      default:\n        // Handle unknown message type\n        break;\n    }\n  });\n\n  ws.on('close', function close() {\n    globalEvents.emit('connectionClose');\n  });\n\n  ws.on('error', function error(err) {\n    globalEvents.emit('connectionError', err);\n  });\n\n  wsSocket = ws;\n}\n\nmodule.exports = { connectServer, globalEvents };\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst EventEmitter = require('events');\n\nclass GlobalEvents extends EventEmitter {}\n\nconst globalEvents = new GlobalEvents();\n\nconst wsSocket = null;\n\nfunction connectServer(port) {\n  const ws = new WebSocket('ws://127.0.0.1:' + port);\n\n  ws.on('open', function open() {\n    globalEvents.emit('connectionOpen');\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    switch (message.type) {\n      case 'config':\n        // Handle config message\n        break;\n      case 'checkResult':\n        // Handle checkResult message\n        break;\n      case 'moduleStart':\n        // Handle moduleStart message\n        break;\n      case 'moduleEnd':\n        // Handle moduleEnd message\n        break;\n      case 'mobileAppInfo':\n        // Handle mobileAppInfo message\n        break;\n      default:\n        // Handle unknown message type\n        break;\n    }\n  });\n\n  ws.on('close', function close() {\n    globalEvents.emit('connectionClose');\n  });\n\n  ws.on('error', function error(err) {\n    globalEvents.emit('connectionError', err);\n  });\n\n  wsSocket = ws;\n}\n\nmodule.exports = { connectServer, globalEvents };\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 217,
    "Instruction": "Task Description: Implement a WebSocket client class that manages WebSocket connections with automatic reconnection capabilities, message handling, and connection state management.\n\nClass Description: The WebSocketClient class provides a wrapper around the browser's native WebSocket API with additional features for connection management. It handles connection establishment, automatic reconnection on failure, message processing, and clean disconnection.\n\nAttributes:\n- DISCONNECT_TIMEOUT: [Number] - Timeout duration (in milliseconds) before disconnecting\n- RECONNECT_TIMEOUT: [Number] - Timeout duration (in milliseconds) before attempting to reconnect\n- wsState: [Number] - Current state of the WebSocket connection (CLOSED, CONNECTING, OPEN)\n- ws: [WebSocket|null] - The active WebSocket connection instance\n- wsURL: [String] - URL for the WebSocket server connection\n- connectTS: [Number] - Timestamp of the last connection attempt\n- disconnectTID: [Number] - Timeout ID for disconnection\n- reconnectTID: [Number] - Timeout ID for reconnection\n- onmessage: [Object|null] - Callback functions for incoming messages\n\nMethods:\n- onconnect() -> [Boolean] - Initiates a new WebSocket connection. Returns true if connection attempt was made.\n- ondisconnect() -> [void] - Closes the current WebSocket connection and cleans up resources.\n- onopen([Event] e) -> [void] - Handles WebSocket connection open event and sets up message listeners.\n- onclose() -> [Boolean] - Handles WebSocket connection close event and schedules reconnection. Returns true if reconnection was scheduled.\n- send([Object] e) -> [void] - Sends a JSON-serialized message through the WebSocket connection.\n- reconnect() -> [void] - Forces reconnection by closing existing connection (if any) and initiating a new one.",
    "Canonical_solution": "class b extends HTMLElement {\n  constructor() {\n    super();\n    this.DISCONNECT_TIMEOUT = 5e3;\n    this.RECONNECT_TIMEOUT = 15e3;\n    this.wsState = WebSocket.CLOSED;\n    this.ws = null;\n    this.wsURL = \"\";\n    this.connectTS = 0;\n    this.disconnectTID = 0;\n    this.reconnectTID = 0;\n    this.onmessage = null;\n  }\n\n  onconnect() {\n    if (!this.isConnected || !this.wsURL || this.ws || this.pc) return false;\n    this.wsState = WebSocket.CONNECTING;\n    this.connectTS = Date.now();\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.binaryType = \"arraybuffer\";\n    this.ws.addEventListener(\"open\", (e) => this.onopen(e));\n    this.ws.addEventListener(\"close\", (e) => this.onclose(e));\n    return true;\n  }\n\n  ondisconnect() {\n    this.wsState = WebSocket.CLOSED;\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.disconnectTID = 0;\n  }\n\n  onopen() {\n    this.wsState = WebSocket.OPEN;\n    this.ws.addEventListener(\"message\", (e) => {\n      if (\"string\" == typeof e.data) {\n        const t = JSON.parse(e.data);\n        for (const e in this.onmessage) this.onmessage[e](t);\n      }\n    });\n    this.onmessage = {};\n  }\n\n  onclose() {\n    if (this.wsState === WebSocket.CLOSED) return false;\n    this.wsState = WebSocket.CONNECTING;\n    this.ws = null;\n    const e = Math.max(this.RECONNECT_TIMEOUT - (Date.now() - this.connectTS), 0);\n    this.reconnectTID = setTimeout(() => {\n      this.reconnectTID = 0;\n      this.onconnect();\n    }, e);\n    return true;\n  }\n\n  send(e) {\n    this.ws && this.ws.send(JSON.stringify(e));\n  }\n\n  reconnect() {\n    if (this.wsState !== WebSocket.CLOSED) {\n      this.ws?.addEventListener(\"close\", () => this.onconnect());\n      this.ondisconnect();\n    } else {\n      this.ondisconnect();\n      this.onconnect();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```python\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 5000\n    RECONNECT_TIMEOUT = 10000\n\n    def __init__(self, wsURL):\n        self.wsState = 3\n        self.ws = None\n        self.wsURL = wsURL\n        self.connectTS = 0\n        self.disconnectTID = 0\n        self.reconnectTID = 0\n        self.onmessage = None\n\n    def onconnect(self):\n        if self.wsState == 1:\n            self.ws = new WebSocket(self.wsURL)\n            self.ws.onopen = self.onopen\n            self.ws.onclose = self.onclose\n            self.ws.onerror = self.onerror\n            self.ws.onmessage = self.onmessage\n            self.wsState = 0\n            return True\n        return False\n\n    def ondisconnect(self):\n        if self.wsState == 1:\n            clearTimeout(self.disconnectTID)\n            self.wsState = 3\n            self.ws = None\n            return\n        if self.wsState == 0:\n            self.ws.close()\n            self.wsState = 3\n            self.disconnectTID = setTimeout(self.ondisconnect, self.DISCONNECT_TIMEOUT)\n            return\n\n    def onopen(self, e):\n        self.wsState = 1\n        clearTimeout(self.reconnectTID)\n        clearTimeout(self.disconnectTID)\n\n    def onclose(self):\n        self.wsState = 3\n        clearTimeout(self.reconnectTID)\n        clearTimeout(self.disconnectTID)\n        self.reconnectTID = setTimeout(self.reconnect, self.RECONNECT_TIMEOUT)\n\n    def send(self, e):\n        if self.wsState == 1:\n            self.ws.send(JSON.stringify(e))\n\n    def reconnect(self):\n        self.ondisconnect()\n        self.onconnect()\n```"
    ],
    "unmatched_results": [
      "```python\nimport websocket\nimport json\nimport time\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 5000\n    RECONNECT_TIMEOUT = 10000\n\n    def __init__(self, wsURL, onmessage=None):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.onmessage = onmessage\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onconnect(self):\n        if self.wsState != websocket.OPEN:\n            self.ws = websocket.WebSocketApp(self.wsURL, on_open=self.onopen, on_close=self.onclose, on_error=self.onerror)\n            self.ws.on_message = self.onmessage\n            self.ws.run_forever()\n            return True\n        return False\n\n    def ondisconnect(self):\n        if self.wsState != websocket.CLOSED:\n            self.wsState = websocket.CLOSED\n            if self.disconnectTID:\n                self.disconnectTID.cancel()\n                self.disconnectTID = None\n            if self.reconnectTID:\n                self.reconnectTID.cancel()\n                self.reconnectTID = None\n            self.ws.close()\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        self.schedule_reconnect()\n\n    def onerror(self, e):\n        print(\"WebSocket error:\", e)\n\n    def send(self, e):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(e))\n\n    def reconnect(self):\n        self.ondisconnect()\n        self.onconnect()\n\n    def schedule_reconnect(self):\n        if not self.reconnectTID:\n            self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.onconnect)\n            self.reconnectTID.start()\n```",
      "```python\nimport websocket\nimport threading\nimport time\nimport json\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 10000\n    RECONNECT_TIMEOUT = 5000\n\n    def __init__(self, wsURL, onmessage=None):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.onmessage = onmessage\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onconnect(self):\n        if self.wsState != websocket.OPEN:\n            self.ws = websocket.WebSocketApp(self.wsURL,\n                                             on_open=self.onopen,\n                                             on_message=self.onmessage,\n                                             on_error=self.onerror,\n                                             on_close=self.onclose)\n            self.ws.run_forever()\n            return True\n        return False\n\n    def ondisconnect(self):\n        if self.wsState == websocket.OPEN:\n            self.ws.close()\n            self.wsState = websocket.CLOSED\n            if self.disconnectTID:\n                threading.cancel(self.disconnectTID)\n                self.disconnectTID = None\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = threading.Timer(self.DISCONNECT_TIMEOUT, self.ondisconnect)\n        self.disconnectTID.start()\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        if self.reconnectTID:\n            threading.cancel(self.reconnectTID)\n            self.reconnectTID = None\n        self.reconnect()\n\n    def send(self, message):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(message))\n\n    def reconnect(self):\n        if self.wsState == websocket.CLOSED:\n            self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.onconnect)\n            self.reconnectTID.start()\n```",
      "```python\nimport websocket\nimport threading\nimport time\nimport json\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 10000\n    RECONNECT_TIMEOUT = 5000\n\n    def __init__(self, wsURL, onmessage=None):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.onmessage = onmessage\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onconnect(self):\n        if self.wsState == websocket.OPEN:\n            return False\n        self.ws = websocket.WebSocketApp(self.wsURL,\n                                         on_open=self.onopen,\n                                         on_message=self.onmessage,\n                                         on_error=self.onerror,\n                                         on_close=self.onclose)\n        self.ws.run_forever()\n        return True\n\n    def ondisconnect(self):\n        if self.wsState == websocket.OPEN:\n            self.ws.close()\n            self.wsState = websocket.CLOSED\n            if self.disconnectTID:\n                threading.cancel(self.disconnectTID)\n                self.disconnectTID = None\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = threading.Timer(self.DISCONNECT_TIMEOUT, self.ondisconnect)\n        self.disconnectTID.start()\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        if self.reconnectTID:\n            threading.cancel(self.reconnectTID)\n            self.reconnectTID = None\n        self.reconnect()\n\n    def send(self, e):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(e))\n\n    def reconnect(self):\n        if self.wsState == websocket.CLOSED:\n            self.ondisconnect()\n            self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.onconnect)\n            self.reconnectTID.start()\n```",
      "```python\nimport websocket\nimport threading\nimport time\nimport json\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 10000\n    RECONNECT_TIMEOUT = 5000\n\n    def __init__(self, wsURL, onmessage=None):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.onmessage = onmessage\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onconnect(self):\n        if self.wsState == websocket.CLOSED:\n            self.ws = websocket.WebSocketApp(self.wsURL,\n                                             on_open=self.onopen,\n                                             on_message=self.onmessage,\n                                             on_error=self.onerror,\n                                             on_close=self.onclose)\n            self.ws.run_forever()\n            return True\n        return False\n\n    def ondisconnect(self):\n        if self.wsState != websocket.CLOSED:\n            self.ws.close()\n            self.wsState = websocket.CLOSED\n            if self.disconnectTID:\n                threading.cancel(self.disconnectTID)\n                self.disconnectTID = None\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = threading.Timer(self.DISCONNECT_TIMEOUT, self.ondisconnect)\n        self.disconnectTID.start()\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        if self.reconnectTID:\n            threading.cancel(self.reconnectTID)\n            self.reconnectTID = None\n        self.reconnect()\n\n    def onerror(self, e):\n        print(\"WebSocket error:\", e)\n\n    def send(self, message):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(message))\n\n    def reconnect(self):\n        if self.wsState != websocket.OPEN:\n            self.ondisconnect()\n            self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.onconnect)\n            self.reconnectTID.start()\n```",
      "```python\nimport websocket\nimport json\nimport time\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 5000\n    RECONNECT_TIMEOUT = 10000\n\n    def __init__(self, wsURL):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n        self.onmessage = None\n\n    def onconnect(self):\n        if self.wsState == websocket.CLOSED:\n            self.ws = websocket.WebSocketApp(self.wsURL,\n                                             on_open=self.onopen,\n                                             on_message=self.onmessage,\n                                             on_error=self.onerror,\n                                             on_close=self.onclose)\n            self.ws.run_forever()\n            return True\n        return False\n\n    def ondisconnect(self):\n        if self.wsState != websocket.CLOSED:\n            self.ws.close()\n            self.wsState = websocket.CLOSED\n            if self.disconnectTID:\n                self.disconnectTID.cancel()\n                self.disconnectTID = None\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        self.ondisconnect()\n        if self.reconnectTID is None:\n            self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.reconnect)\n            self.reconnectTID.start()\n\n    def send(self, e):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(e))\n\n    def reconnect(self):\n        self.ondisconnect()\n        self.onconnect()\n```",
      "```python\nimport websocket\nimport threading\nimport time\nimport json\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 10000\n    RECONNECT_TIMEOUT = 5000\n\n    def __init__(self, wsURL, onmessage=None):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.onmessage = onmessage\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onconnect(self):\n        if self.wsState == websocket.CLOSED:\n            self.ws = websocket.WebSocketApp(self.wsURL,\n                                             on_open=self.onopen,\n                                             on_message=self.onmessage,\n                                             on_error=self.onerror,\n                                             on_close=self.onclose)\n            self.ws.run_forever()\n            return True\n        return False\n\n    def ondisconnect(self):\n        if self.wsState != websocket.CLOSED:\n            self.ws.close()\n            self.wsState = websocket.CLOSED\n            if self.disconnectTID:\n                threading.cancel(self.disconnectTID)\n                self.disconnectTID = None\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = threading.Timer(self.DISCONNECT_TIMEOUT, self.ondisconnect)\n        self.disconnectTID.start()\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        if self.reconnectTID:\n            threading.cancel(self.reconnectTID)\n            self.reconnectTID = None\n        self.reconnect()\n\n    def onerror(self, e):\n        print(\"WebSocket error:\", e)\n\n    def send(self, message):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(message))\n\n    def reconnect(self):\n        if self.wsState != websocket.OPEN:\n            self.ondisconnect()\n            self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.onconnect)\n            self.reconnectTID.start()\n```",
      "```python\nimport websocket\nimport threading\nimport time\nimport json\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 10000\n    RECONNECT_TIMEOUT = 5000\n\n    def __init__(self, wsURL, onmessage=None):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.onmessage = onmessage\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onconnect(self):\n        if self.wsState != websocket.OPEN:\n            self.ws = websocket.WebSocketApp(self.wsURL,\n                                             on_message=self.onopen,\n                                             on_error=self.onerror,\n                                             on_close=self.onclose)\n            self.ws.on_message = self.onmessage\n            self.ws.run_forever()\n            return True\n        return False\n\n    def ondisconnect(self):\n        if self.wsState != websocket.CLOSED:\n            self.wsState = websocket.CLOSED\n            self.ws.close()\n            self.ws = None\n            if self.disconnectTID:\n                threading.cancel(self.disconnectTID)\n                self.disconnectTID = None\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = threading.Timer(self.DISCONNECT_TIMEOUT, self.ondisconnect)\n        self.disconnectTID.start()\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        self.ondisconnect()\n        if self.reconnectTID:\n            threading.cancel(self.reconnectTID)\n            self.reconnectTID = None\n        self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.onconnect)\n        self.reconnectTID.start()\n\n    def send(self, e):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(e))\n\n    def reconnect(self):\n        if self.wsState != websocket.CLOSED:\n            self.ondisconnect()\n        self.onconnect()\n```",
      "```python\nimport websocket\nimport threading\nimport time\nimport json\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 10000\n    RECONNECT_TIMEOUT = 5000\n\n    def __init__(self, wsURL, onmessage=None):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.onmessage = onmessage\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onconnect(self):\n        if self.wsState == websocket.OPEN:\n            return False\n        self.ws = websocket.WebSocketApp(self.wsURL,\n                                         on_open=self.onopen,\n                                         on_message=self.onmessage,\n                                         on_error=self.onerror,\n                                         on_close=self.onclose)\n        self.ws.run_forever()\n        return True\n\n    def ondisconnect(self):\n        if self.wsState == websocket.OPEN:\n            self.ws.close()\n            self.wsState = websocket.CLOSED\n            if self.disconnectTID:\n                threading.cancel(self.disconnectTID)\n                self.disconnectTID = None\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = threading.Timer(self.DISCONNECT_TIMEOUT, self.ondisconnect)\n        self.disconnectTID.start()\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        if self.reconnectTID:\n            threading.cancel(self.reconnectTID)\n            self.reconnectTID = None\n        self.reconnect()\n\n    def send(self, e):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(e))\n\n    def reconnect(self):\n        if self.wsState == websocket.CLOSED:\n            self.ondisconnect()\n            self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.onconnect)\n            self.reconnectTID.start()\n```",
      "```python\nimport websocket\nimport threading\nimport time\nimport json\n\nclass WebSocketClient:\n    DISCONNECT_TIMEOUT = 5000\n    RECONNECT_TIMEOUT = 10000\n\n    def __init__(self, wsURL, onmessage=None):\n        self.wsState = websocket.CLOSED\n        self.ws = None\n        self.wsURL = wsURL\n        self.onmessage = onmessage\n        self.connectTS = 0\n        self.disconnectTID = None\n        self.reconnectTID = None\n\n    def onconnect(self):\n        if self.wsState == websocket.CLOSED:\n            self.ws = websocket.WebSocketApp(self.wsURL,\n                                             on_open=self.onopen,\n                                             on_message=self.onmessage,\n                                             on_error=self.onerror,\n                                             on_close=self.onclose)\n            self.ws.run_forever()\n            return True\n        return False\n\n    def ondisconnect(self):\n        if self.wsState != websocket.CLOSED:\n            self.ws.close()\n            self.wsState = websocket.CLOSED\n            if self.disconnectTID:\n                threading.cancel(self.disconnectTID)\n                self.disconnectTID = None\n\n    def onopen(self, e):\n        self.wsState = websocket.OPEN\n        self.connectTS = time.time()\n        self.disconnectTID = threading.Timer(self.DISCONNECT_TIMEOUT, self.ondisconnect)\n        self.disconnectTID.start()\n\n    def onclose(self):\n        self.wsState = websocket.CLOSED\n        if self.reconnectTID:\n            threading.cancel(self.reconnectTID)\n            self.reconnectTID = None\n        self.reconnect()\n\n    def onerror(self, e):\n        print(\"WebSocket error:\", e)\n\n    def send(self, message):\n        if self.wsState == websocket.OPEN:\n            self.ws.send(json.dumps(message))\n\n    def reconnect(self):\n        if self.wsState != websocket.OPEN:\n            self.ondisconnect()\n            self.reconnectTID = threading.Timer(self.RECONNECT_TIMEOUT, self.onconnect)\n            self.reconnectTID.start()\n```"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a WebSocket client in JavaScript that automatically reconnects to a server upon connection loss and triggers a page reload when receiving a message from the server.\n\nFunction Description: The function establishes a WebSocket connection to a specified URL. It handles connection closure by attempting to reconnect after a delay (2 seconds) and automatically reloads the page when a message is received from the server. This is particularly useful for development environments where live-reloading of web pages is desired.\n\nInput: \n- a [String] - The WebSocket server URL to connect to (e.g., \"ws://localhost:12450/reload\")\n\nOutput: None (This function establishes a persistent connection and handles events asynchronously)",
    "Canonical_solution": "function b(a) {\n    var c = new WebSocket(a);\n    c.onclose = function() {\n        setTimeout(function() {\n            b(a)\n        }, 2E3)\n    };\n    c.onmessage = function() {\n        location.reload()\n    }\n}\ntry {\n    if (window.WebSocket) {\n        try {\n            b(\"ws://localhost:12450/reload\")\n        } catch (a) {\n            console.error(a)\n        }\n    } else {\n        console.log(\"Your browser does not support WebSockets.\")\n    }\n} catch (a) {\n    console.error(\"Exception during connecting to Reload:\", a)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log('Connected to the WebSocket server');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log('Connection closed. Attempting to reconnect...');\n    setTimeout(connect, 2000);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n    ws.close();\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"Connected to the WebSocket server.\");\n  };\n\n  ws.onmessage = function(event) {\n    console.log(\"Message received from server:\", event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log(\"Connection closed. Attempting to reconnect...\");\n    setTimeout(connect, 2000);\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"Connected to the WebSocket server.\");\n  };\n\n  ws.onmessage = function(event) {\n    console.log(\"Message from server: \" + event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log(\"Connection closed. Attempting to reconnect...\");\n    setTimeout(connect, 2000);\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error: \" + error);\n    ws.close();\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"Connected to the WebSocket server.\");\n  };\n\n  ws.onmessage = function(event) {\n    console.log(\"Message received from server:\", event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log(\"Connection closed. Attempting to reconnect...\");\n    setTimeout(connect, 2000);\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"Connected to the WebSocket server.\");\n  };\n\n  ws.onmessage = function(event) {\n    console.log(\"Message received from server:\", event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log(\"Connection closed. Attempting to reconnect...\");\n    setTimeout(connect, 2000);\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error:\", error);\n    ws.close();\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"Connected to the WebSocket server.\");\n  };\n\n  ws.onmessage = function(event) {\n    console.log(\"Message from server: \" + event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log(\"Disconnected from the WebSocket server. Attempting to reconnect...\");\n    setTimeout(connect, 2000);\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error: \" + error);\n    ws.close();\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"Connected to the WebSocket server.\");\n  };\n\n  ws.onmessage = function(event) {\n    console.log(\"Message received from server:\", event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log(\"Connection closed. Attempting to reconnect...\");\n    setTimeout(connect, 2000);\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"Connected to the WebSocket server.\");\n  };\n\n  ws.onmessage = function(event) {\n    console.log(\"Message from server: \" + event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log(\"Connection closed. Attempting to reconnect...\");\n    setTimeout(connect, 2000);\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log('Connected to the WebSocket server');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message from server:', event.data);\n    window.location.reload();\n  };\n\n  ws.onclose = function() {\n    console.log('WebSocket connection closed. Attempting to reconnect...');\n    setTimeout(connect, 2000);\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://localhost:12450/reload\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n  ws.onopen = function() {\n    console.log(\"Connected to the WebSocket server\");\n  };\n  ws.onmessage = function(event) {\n    console.log(\"Message received from server: \" + event.data);\n    window.location.reload();\n  };\n  ws.onclose = function() {\n    console.log(\"Connection closed. Attempting to reconnect...\");\n    setTimeout(connect, 2000);\n  };\n}\n\nconnect();\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 219,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a WebSocket server, handles incoming messages, and sends messages from a form input.\n\nFunction Description: The `initializeWebSocket` function sets up a WebSocket client that connects to a specified WebSocket server URL. It manages the WebSocket connection lifecycle, including opening, message handling, and closing events. It also provides a form submission handler for sending messages through the WebSocket connection and displays all messages in a log area.\n\nInput:\n- None (The function uses DOM elements with IDs \"msg\", \"log\", and \"form\" from the HTML document)\n- Implicitly uses a WebSocket server URL (\"ws://{{$}}/ws\")\n\nOutput:\n- None (The function's effects are visible through DOM manipulation and WebSocket communication)\n- Side effects:\n  - Creates a WebSocket connection\n  - Modifies the DOM to display connection status and messages\n  - Handles form submission to send messages through WebSocket\n\nNote: The function assumes the presence of jQuery for DOM manipulation and requires the following HTML elements:\n- An input field with ID \"msg\" for message input\n- A container with ID \"log\" for displaying messages\n- A form with ID \"form\" for message submission",
    "Canonical_solution": "function initializeWebSocket() {\n    var conn;\n    var msg = $(\"#msg\");\n    var log = $(\"#log\");\n\n    function appendLog(msg) {\n        var d = log[0]\n        var doScroll = d.scrollTop == d.scrollHeight - d.clientHeight;\n        msg.appendTo(log)\n        if (doScroll) {\n            d.scrollTop = d.scrollHeight - d.clientHeight;\n        }\n    }\n\n    $(\"#form\").submit(function() {\n        if (!conn) {\n            return false;\n        }\n        if (!msg.val()) {\n            return false;\n        }\n        conn.send(msg.val());\n        msg.val(\"\");\n        return false\n    });\n\n    if (window[\"WebSocket\"]) {\n        conn = new WebSocket(\"ws://{{$}}/ws\");\n        conn.onclose = function(evt) {\n            appendLog($(\"<div><b>Connection closed.</b></div>\"))\n        }\n        conn.onmessage = function(evt) {\n            appendLog($(\"<div/>\").text(evt.data))\n        }\n    } else {\n        appendLog($(\"<div><b>Your browser does not support WebSockets.</b></div>\"))\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\n$(document).ready(function() {\n    var socket;\n    var serverUrl = \"ws://{{$}}/ws\";\n\n    function initializeWebSocket() {\n        socket = new WebSocket(serverUrl);\n\n        socket.onopen = function() {\n            $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n        };\n\n        socket.onmessage = function(event) {\n            $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n        };\n\n        socket.onclose = function() {\n            $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n        };\n\n        socket.onerror = function(error) {\n            $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n        };\n\n        $(\"#form\").submit(function(e) {\n            e.preventDefault();\n            var message = $(\"#msg\").val();\n            socket.send(message);\n            $(\"#msg\").val(\"\");\n        });\n    }\n\n    initializeWebSocket();\n});\n```",
      "```javascript\n$(document).ready(function() {\n    var socket = new WebSocket(\"ws://{{$}}/ws\");\n\n    socket.onopen = function() {\n        $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n    };\n\n    socket.onmessage = function(event) {\n        $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n    };\n\n    socket.onclose = function() {\n        $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n    };\n\n    socket.onerror = function(error) {\n        $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n    };\n\n    $(\"#form\").submit(function(event) {\n        event.preventDefault();\n        var message = $(\"#msg\").val();\n        socket.send(message);\n        $(\"#msg\").val(\"\");\n    });\n});\n```",
      "```javascript\n$(document).ready(function() {\n    var socket;\n    var serverUrl = \"ws://{{$}}/ws\";\n\n    function initializeWebSocket() {\n        socket = new WebSocket(serverUrl);\n\n        socket.onopen = function() {\n            $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n        };\n\n        socket.onmessage = function(event) {\n            $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n        };\n\n        socket.onclose = function() {\n            $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n        };\n\n        socket.onerror = function(error) {\n            $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n        };\n\n        $(\"#form\").submit(function(e) {\n            e.preventDefault();\n            var message = $(\"#msg\").val();\n            socket.send(message);\n            $(\"#msg\").val(\"\");\n        });\n    }\n\n    initializeWebSocket();\n});\n```",
      "```javascript\n$(document).ready(function() {\n  var socket = new WebSocket(\"ws://{{$}}/ws\");\n\n  socket.onopen = function() {\n    $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n  };\n\n  socket.onmessage = function(event) {\n    $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n  };\n\n  socket.onclose = function() {\n    $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n  };\n\n  socket.onerror = function(error) {\n    $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n  };\n\n  $(\"#form\").submit(function(event) {\n    event.preventDefault();\n    var message = $(\"#msg\").val();\n    socket.send(message);\n    $(\"#msg\").val(\"\");\n  });\n});\n```",
      "```javascript\n$(document).ready(function() {\n    var socket = new WebSocket(\"ws://{{$}}/ws\");\n\n    socket.onopen = function() {\n        $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n    };\n\n    socket.onmessage = function(event) {\n        $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n    };\n\n    socket.onclose = function() {\n        $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n    };\n\n    socket.onerror = function(error) {\n        $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n    };\n\n    $(\"#form\").submit(function(e) {\n        e.preventDefault();\n        var message = $(\"#msg\").val();\n        socket.send(message);\n        $(\"#msg\").val(\"\");\n    });\n});\n```",
      "```javascript\n$(document).ready(function() {\n    var socket = new WebSocket(\"ws://{{$}}/ws\");\n\n    socket.onopen = function() {\n        $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n    };\n\n    socket.onmessage = function(event) {\n        $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n    };\n\n    socket.onclose = function() {\n        $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n    };\n\n    socket.onerror = function(error) {\n        $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n    };\n\n    $(\"#form\").submit(function(e) {\n        e.preventDefault();\n        var message = $(\"#msg\").val();\n        socket.send(message);\n        $(\"#msg\").val(\"\");\n    });\n});\n```",
      "```javascript\n$(document).ready(function() {\n    var ws;\n    var serverUrl = \"ws://{{$}}/ws\";\n\n    function initializeWebSocket() {\n        ws = new WebSocket(serverUrl);\n\n        ws.onopen = function() {\n            $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n        };\n\n        ws.onmessage = function(event) {\n            $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n        };\n\n        ws.onclose = function() {\n            $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n        };\n\n        ws.onerror = function(error) {\n            $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n        };\n\n        $(\"#form\").submit(function(e) {\n            e.preventDefault();\n            var message = $(\"#msg\").val();\n            ws.send(message);\n            $(\"#msg\").val(\"\");\n        });\n    }\n\n    initializeWebSocket();\n});\n```",
      "```javascript\n$(document).ready(function() {\n    var socket = new WebSocket(\"ws://{{$}}/ws\");\n\n    socket.onopen = function() {\n        $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n    };\n\n    socket.onmessage = function(event) {\n        $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n    };\n\n    socket.onclose = function() {\n        $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n    };\n\n    socket.onerror = function(error) {\n        $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n    };\n\n    $(\"#form\").submit(function(event) {\n        event.preventDefault();\n        var message = $(\"#msg\").val();\n        socket.send(message);\n        $(\"#msg\").val(\"\");\n    });\n});\n```",
      "```javascript\n$(document).ready(function() {\n    var socket;\n    var serverUrl = \"ws://{{$}}/ws\";\n\n    function initializeWebSocket() {\n        socket = new WebSocket(serverUrl);\n\n        socket.onopen = function() {\n            $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n        };\n\n        socket.onmessage = function(event) {\n            $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n        };\n\n        socket.onclose = function() {\n            $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n        };\n\n        socket.onerror = function(error) {\n            $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n        };\n\n        $(\"#form\").submit(function(e) {\n            e.preventDefault();\n            var message = $(\"#msg\").val();\n            socket.send(message);\n            $(\"#msg\").val(\"\");\n        });\n    }\n\n    initializeWebSocket();\n});\n```",
      "```javascript\n$(document).ready(function() {\n    var ws;\n\n    function initializeWebSocket() {\n        ws = new WebSocket(\"ws://{{$}}/ws\");\n\n        ws.onopen = function() {\n            $(\"#log\").append(\"<p>WebSocket connection established.</p>\");\n        };\n\n        ws.onmessage = function(event) {\n            $(\"#log\").append(\"<p>\" + event.data + \"</p>\");\n        };\n\n        ws.onclose = function() {\n            $(\"#log\").append(\"<p>WebSocket connection closed.</p>\");\n        };\n\n        ws.onerror = function(error) {\n            $(\"#log\").append(\"<p>Error: \" + error.message + \"</p>\");\n        };\n\n        $(\"#form\").submit(function(e) {\n            e.preventDefault();\n            var message = $(\"#msg\").val();\n            ws.send(message);\n            $(\"#msg\").val(\"\");\n        });\n    }\n\n    initializeWebSocket();\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a client for interacting with Quqi.com's API to perform daily tasks, manage group operations, and track rewards.\n\nClass Description: The QuqiClient class provides methods to interact with Quqi.com's web services including task management, group operations, file uploads, and reward collection. It handles HTTP requests using Axios with proper headers and error handling.\n\nAttributes:\n- headers: [Object] - Contains HTTP headers including cookies and referer for API authentication\n- config: [Object] - Configuration object containing user credentials and settings\n\nMethods:\n- constructor(config) -> [void] - Initializes the client with configuration including authentication cookies\n- _sleep(ms) -> [Promise] - Utility method for delaying execution\n- getDailyTask() -> [Promise<Array|null>] - Retrieves list of incomplete daily tasks\n- getReward(id) -> [Promise<void>] - Claims reward for a specific task ID\n- visit(id) -> [Promise<void>] - Visits a specified group to complete visit tasks\n- getQuqiId() -> [Promise<Object|null>] - Gets group information and handles group joining if needed\n- uploadImg(id) -> [Promise<void>] - Uploads and deletes a dummy image to complete upload tasks\n- executeTasks() -> [Promise<String>] - Executes all available tasks and returns wallet information",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass QuqiClient {\n    constructor(config) {\n        this.headers = {\n            cookie: config.quqi.cookie,\n            referer: \"https://quqi.com/\"\n        };\n    }\n\n    async _sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    async getDailyTask() {\n        try {\n            let res = await axios.get(`https://exp.quqi.com/v1/dailyTask/state?_=1${Date.now()}`, {headers: this.headers});\n            if(res.data.err == 0) {\n                let list = res.data.data.filter(x => x.status != 2);\n                console.log(`å‰©ä½™${list.length}ä»»åŠ¡æœªå®Œæˆ`);\n                return list;\n            }\n        } catch (err) {\n            console.log(err);\n        }\n        return null;\n    }\n\n    async getReward(id) {\n        try {\n            let res = await axios.get(`https://exp.quqi.com/v1/dailyTask/sendAward/${id}`, {headers: this.headers});\n            console.log(\"é¢†å–å¥–åŠ±ï¼š\" + res.data.msg);\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async visit(id) {\n        try {\n            this.headers[\"User-Agent\"] = \"Mozilla/5.0 (Linux; Android 11; Redmi K30) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36\";\n            let res = await axios.post(`https://quqi.com/api/dir/ls?quqi_id=${id}`, `quqi_id=${id}&tree_id=1&node_id=0`, {headers: this.headers});\n            let res1 = await axios.post(`https://quqi.com/auth/updateVisit?quqi_id=${id}`, `quqi_id=${id}`, {headers: this.headers});\n            console.log(\"æµè§ˆå¤šäººç¾¤ç»„ï¼š\" + res1.data.msg);\n            await this._sleep(1000);\n            await this.getReward(14);\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async getQuqiId() {\n        try {\n            let res = await axios.get(\"https://group.quqi.com/v1/group/list\", {headers: this.headers});\n            if (res.data.msg == \"success\") {\n                let gplist = res.data.data.filter(x => x.type == 14);\n                let quqid = gplist.length == 0 ? res.data.data[0].quqi_id : gplist[0].quqi_id;\n                let gtype = gplist.length == 0 ? 1 : 2;\n                if (gtype == 1) {\n                    console.log(\"ðŸˆšï¸å¤šäººç¾¤ç»„,è¯·è‡ªè¡Œåˆ›å»ºä¸€ä¸ªå¤šäººç¾¤ç»„,æˆ–è€…ç”³è¯·åŠ å…¥https://quqi.avyeld.com/join/company/team.html?jointarget=ed521eef-7ed1-486f-a903-2457ebe5704f\");\n                    let sqres = await axios.post(\"https://group.quqi.com/v1/application\", \"credential=ed521eef-7ed1-486f-a903-2457ebe5704f\", {headers: this.headers});\n                    console.log(\"ç”³è¯·åŠ å…¥å¤šäººç¾¤ç»„ï¼š\" + sqres.data.msg);\n                }\n                return {\n                    qid: quqid,\n                    gtype: gtype\n                };\n            }\n        } catch (err) {\n            console.log(err);\n        }\n        return null;\n    }\n\n    async uploadImg(id) {\n        try {\n            let name = `æ¯æ—¥ç­¾åˆ°${Date.now()}`;\n            this.headers[\"User-Agent\"] = \"Mozilla/5.0 (Linux; Android 11; Redmi K30) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36\";\n            let res = await axios.post(`https://quqi.com/api/upload/v1/file/init?quqi_id=${id}`, `file_name=${name}.jpg&is_slice=false&md5=507cf982c5db90bc35f9c6c8179c292f&parent_id=0&quqi_id=${id}&sha=4b4afc24113d86d0afd9be21b6841d9c627cdabf01317e3e760308b05f8bdd81&sign=617db783e0ba01343338ee9887dfdb18&size=331665&tree_id=1`, {headers: this.headers});\n            if (res.data.msg == \"ok\") {\n                console.log(`ä¸Šä¼ å›¾ç‰‡ ${name} æˆåŠŸ`);\n                let nid = res.data.data.node_id;\n                if (nid) await axios.post(`https://quqi.com/api/node/batchDel?quqi_id=${id}`, `quqi_id=${id}&tree_id=1&node_ids=${nid}`, {headers: this.headers});\n                await this._sleep(1000);\n                await this.getReward(15);\n            } else {\n                console.log(\"ä¸Šä¼ å¤±è´¥ï¼š\" + res.data.msg);\n            }\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async executeTasks() {\n        let quqinfo = \"\";\n        let dailyTaskList = await this.getDailyTask();\n        let qgp = await this.getQuqiId();\n        \n        if (dailyTaskList) {\n            for (let task of dailyTaskList) {\n                console.log(task.task_decreption);\n                if (task.status == 1) {\n                    await this.getReward(task.task_type);\n                } else if (task.task_type == 14 && task.status == 0 && qgp.gtype == 2) {\n                    await this.visit(qgp.qid);\n                } else if (task.task_type == 15 && task.status == 0) {\n                    await this.uploadImg(qgp.qid);\n                }\n            }\n        }\n        \n        let ires = await axios.get(\"https://api.quqi.com/vipWallet/v1/vipAndWallet\", {headers: this.headers});\n        if (ires.data.msg == \"success\") {\n            quqinfo = `æ›²å¥‡é¥¼ï¼š${ires.data.data.wallet_info.cookie}  æ›²å¥‡è±†ï¼š${ires.data.data.wallet_info.bean}`;\n        } else {\n            quqinfo = ires.data.msg;\n        }\n        console.log(quqinfo);\n        return \"ã€æ›²å¥‡ç½‘ç›˜ã€‘ï¼š\" + quqinfo;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.config = config;\n    this.headers = {\n      'Cookie': this.config.cookies,\n      'Referer': 'https://quqi.com'\n    };\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/tasks/daily', {\n        headers: this.headers\n      });\n      return response.data;\n    } catch (error) {\n      console.error(error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post(`https://quqi.com/api/rewards/${id}`, {}, {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post(`https://quqi.com/api/groups/${id}/visit`, {}, {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/group/info', {\n        headers: this.headers\n      });\n      if (response.data.needsJoin) {\n        await axios.post('https://quqi.com/api/group/join', {}, {\n          headers: this.headers\n        });\n      }\n      return response.data;\n    } catch (error) {\n      console.error(error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post(`https://quqi.com/api/groups/${id}/upload`, {\n        image: 'dummy-image.jpg'\n      }, {\n        headers: this.headers\n      });\n      await axios.delete(`https://quqi.com/api/groups/${id}/upload`, {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async executeTasks() {\n    const tasks = await this.getDailyTask();\n    if (tasks) {\n      for (const task of tasks) {\n        if (task.type === 'reward') {\n          await this.getReward(task.id);\n        } else if (task.type === 'visit') {\n          await this.visit(task.id);\n        } else if (task.type === 'upload') {\n          await this.uploadImg(task.id);\n        }\n      }\n    }\n    try {\n      const response = await axios.get('https://quqi.com/api/wallet', {\n        headers: this.headers\n      });\n      return response.data;\n    } catch (error) {\n      console.error(error);\n      return null;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'Cookie': config.cookies,\n      'Referer': 'https://quqi.com'\n    };\n    this.config = config;\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/dailyTask', { headers: this.headers });\n      return response.data;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post('https://quqi.com/api/getReward', { id }, { headers: this.headers });\n    } catch (error) {\n      // Handle error\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post('https://quqi.com/api/visit', { id }, { headers: this.headers });\n    } catch (error) {\n      // Handle error\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/getQuqiId', { headers: this.headers });\n      return response.data;\n    } catch (error) {\n      // Handle group joining if needed\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post('https://quqi.com/api/uploadImg', { id }, { headers: this.headers });\n    } catch (error) {\n      // Handle error\n    }\n  }\n\n  async executeTasks() {\n    try {\n      const tasks = await this.getDailyTask();\n      for (const task of tasks) {\n        if (task.type === 'reward') {\n          await this.getReward(task.id);\n        } else if (task.type === 'visit') {\n          await this.visit(task.id);\n        } else if (task.type === 'upload') {\n          await this.uploadImg(task.id);\n        }\n      }\n      const walletInfo = await axios.get('https://quqi.com/api/walletInfo', { headers: this.headers });\n      return walletInfo.data;\n    } catch (error) {\n      // Handle error\n      return null;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'Cookie': config.cookies,\n      'Referer': 'https://quqi.com'\n    };\n    this.config = config;\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/dailyTasks', {\n        headers: this.headers\n      });\n      return response.data;\n    } catch (error) {\n      console.error(error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post('https://quqi.com/api/rewards/' + id, {}, {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post('https://quqi.com/api/groups/' + id + '/visit', {}, {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/groupInfo', {\n        headers: this.headers\n      });\n      if (response.data.needsJoining) {\n        await axios.post('https://quqi.com/api/groupJoin', {}, {\n          headers: this.headers\n        });\n      }\n      return response.data;\n    } catch (error) {\n      console.error(error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post('https://quqi.com/api/groups/' + id + '/upload', {\n        image: 'dummyImage.jpg'\n      }, {\n        headers: this.headers\n      });\n      await axios.delete('https://quqi.com/api/groups/' + id + '/upload', {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async executeTasks() {\n    const tasks = await this.getDailyTask();\n    if (tasks) {\n      for (const task of tasks) {\n        if (task.type === 'reward') {\n          await this.getReward(task.id);\n        } else if (task.type === 'visit') {\n          await this.visit(task.id);\n        } else if (task.type === 'upload') {\n          await this.uploadImg(task.id);\n        }\n      }\n    }\n    try {\n      const response = await axios.get('https://quqi.com/api/walletInfo', {\n        headers: this.headers\n      });\n      return response.data;\n    } catch (error) {\n      console.error(error);\n      return '';\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'Cookie': config.cookies,\n      'Referer': 'https://quqi.com',\n    };\n    this.config = config;\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/tasks/daily', {\n        headers: this.headers,\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching daily tasks:', error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post('https://quqi.com/api/rewards/claim', {\n        id: id,\n      }, {\n        headers: this.headers,\n      });\n    } catch (error) {\n      console.error('Error claiming reward:', error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post('https://quqi.com/api/groups/visit', {\n        id: id,\n      }, {\n        headers: this.headers,\n      });\n    } catch (error) {\n      console.error('Error visiting group:', error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/groups/info', {\n        headers: this.headers,\n      });\n      if (response.data.needsJoining) {\n        await axios.post('https://quqi.com/api/groups/join', {\n          id: response.data.groupId,\n        }, {\n          headers: this.headers,\n        });\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Error getting Quqi ID:', error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post('https://quqi.com/api/images/upload', {\n        id: id,\n      }, {\n        headers: this.headers,\n      });\n      await axios.delete('https://quqi.com/api/images/delete', {\n        headers: this.headers,\n      });\n    } catch (error) {\n      console.error('Error uploading image:', error);\n    }\n  }\n\n  async executeTasks() {\n    const tasks = await this.getDailyTask();\n    if (tasks) {\n      for (const task of tasks) {\n        if (task.type === 'reward') {\n          await this.getReward(task.id);\n        } else if (task.type === 'visit') {\n          await this.visit(task.id);\n        } else if (task.type === 'upload') {\n          await this.uploadImg(task.id);\n        }\n      }\n    }\n    try {\n      const response = await axios.get('https://quqi.com/api/wallet/info', {\n        headers: this.headers,\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error executing tasks:', error);\n      return '';\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'Cookie': config.cookies,\n      'Referer': 'https://quqi.com'\n    };\n    this.config = config;\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/dailyTask', { headers: this.headers });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching daily tasks:', error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post('https://quqi.com/api/getReward', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error claiming reward:', error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post('https://quqi.com/api/visit', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error visiting group:', error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/getQuqiId', { headers: this.headers });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting Quqi ID:', error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post('https://quqi.com/api/uploadImg', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error uploading image:', error);\n    }\n  }\n\n  async executeTasks() {\n    try {\n      const tasks = await this.getDailyTask();\n      if (tasks) {\n        for (const task of tasks) {\n          if (task.type === 'reward') {\n            await this.getReward(task.id);\n          } else if (task.type === 'visit') {\n            await this.visit(task.id);\n          } else if (task.type === 'upload') {\n            await this.uploadImg(task.id);\n          }\n        }\n      }\n      const walletInfo = await axios.get('https://quqi.com/api/walletInfo', { headers: this.headers });\n      return walletInfo.data;\n    } catch (error) {\n      console.error('Error executing tasks:', error);\n      return null;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'Cookie': config.cookies,\n      'Referer': 'https://quqi.com'\n    };\n    this.config = config;\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/dailyTask', { headers: this.headers });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching daily tasks:', error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post('https://quqi.com/api/getReward', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error claiming reward:', error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post('https://quqi.com/api/visit', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error visiting group:', error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/quqiId', { headers: this.headers });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting Quqi ID:', error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post('https://quqi.com/api/uploadImg', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error uploading image:', error);\n    }\n  }\n\n  async executeTasks() {\n    try {\n      const tasks = await this.getDailyTask();\n      if (tasks) {\n        for (const task of tasks) {\n          if (task.type === 'reward') {\n            await this.getReward(task.id);\n          } else if (task.type === 'visit') {\n            await this.visit(task.id);\n          } else if (task.type === 'upload') {\n            await this.uploadImg(task.id);\n          }\n        }\n      }\n      const walletInfo = await axios.get('https://quqi.com/api/walletInfo', { headers: this.headers });\n      return walletInfo.data;\n    } catch (error) {\n      console.error('Error executing tasks:', error);\n      return null;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'Cookie': config.cookies,\n      'Referer': 'https://quqi.com'\n    };\n    this.config = config;\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/dailyTasks', { headers: this.headers });\n      return response.data.tasks || null;\n    } catch (error) {\n      console.error('Error fetching daily tasks:', error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post(`https://quqi.com/api/rewards/${id}`, {}, { headers: this.headers });\n    } catch (error) {\n      console.error('Error claiming reward:', error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post(`https://quqi.com/api/groups/${id}/visit`, {}, { headers: this.headers });\n    } catch (error) {\n      console.error('Error visiting group:', error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/groupInfo', { headers: this.headers });\n      if (response.data.needsJoining) {\n        await axios.post('https://quqi.com/api/groupJoin', {}, { headers: this.headers });\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Error getting Quqi ID:', error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post(`https://quqi.com/api/groups/${id}/uploadImg`, {}, { headers: this.headers });\n      await axios.delete(`https://quqi.com/api/groups/${id}/deleteImg`, { headers: this.headers });\n    } catch (error) {\n      console.error('Error uploading and deleting image:', error);\n    }\n  }\n\n  async executeTasks() {\n    const tasks = await this.getDailyTask();\n    if (tasks) {\n      for (const task of tasks) {\n        if (task.type === 'reward') {\n          await this.getReward(task.id);\n        } else if (task.type === 'visit') {\n          await this.visit(task.id);\n        } else if (task.type === 'uploadImg') {\n          await this.uploadImg(task.id);\n        }\n      }\n    }\n    try {\n      const response = await axios.get('https://quqi.com/api/walletInfo', { headers: this.headers });\n      return response.data.walletInfo;\n    } catch (error) {\n      console.error('Error executing tasks:', error);\n      return '';\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'Cookie': config.cookies,\n      'Referer': 'https://quqi.com'\n    };\n    this.config = config;\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/dailyTask', { headers: this.headers });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching daily tasks:', error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post('https://quqi.com/api/getReward', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error claiming reward:', error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post('https://quqi.com/api/visit', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error visiting group:', error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/getQuqiId', { headers: this.headers });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting Quqi ID:', error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post('https://quqi.com/api/uploadImg', { id }, { headers: this.headers });\n    } catch (error) {\n      console.error('Error uploading image:', error);\n    }\n  }\n\n  async executeTasks() {\n    try {\n      const tasks = await this.getDailyTask();\n      if (tasks) {\n        for (const task of tasks) {\n          if (task.type === 'reward') {\n            await this.getReward(task.id);\n          } else if (task.type === 'visit') {\n            await this.visit(task.id);\n          } else if (task.type === 'upload') {\n            await this.uploadImg(task.id);\n          }\n        }\n      }\n      const walletInfo = await axios.get('https://quqi.com/api/walletInfo', { headers: this.headers });\n      return walletInfo.data;\n    } catch (error) {\n      console.error('Error executing tasks:', error);\n      return null;\n    }\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass QuqiClient {\n  constructor(config) {\n    this.headers = {\n      'Cookie': config.cookies,\n      'Referer': 'https://quqi.com'\n    };\n    this.config = config;\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/dailyTask', {\n        headers: this.headers\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching daily tasks:', error);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post('https://quqi.com/api/getReward', { id }, {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error('Error claiming reward:', error);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post('https://quqi.com/api/visit', { id }, {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error('Error visiting group:', error);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/getQuqiId', {\n        headers: this.headers\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting Quqi ID:', error);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      await axios.post('https://quqi.com/api/uploadImg', { id }, {\n        headers: this.headers\n      });\n    } catch (error) {\n      console.error('Error uploading image:', error);\n    }\n  }\n\n  async executeTasks() {\n    try {\n      const tasks = await this.getDailyTask();\n      if (tasks) {\n        for (const task of tasks) {\n          if (task.type === 'reward') {\n            await this.getReward(task.id);\n          } else if (task.type === 'visit') {\n            await this.visit(task.id);\n          } else if (task.type === 'upload') {\n            await this.uploadImg(task.id);\n          }\n        }\n      }\n      const walletInfo = await axios.get('https://quqi.com/api/walletInfo', {\n        headers: this.headers\n      });\n      return walletInfo.data;\n    } catch (error) {\n      console.error('Error executing tasks:', error);\n      return null;\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```python\nimport axios\nimport Promise\n\nclass QuqiClient:\n    def __init__(self, config):\n        self.headers = {\n            'cookies': config['cookies'],\n            'referer': config['referer']\n        }\n        self.config = config\n\n    def _sleep(self, ms):\n        return new Promise(resolve => setTimeout(resolve, ms))\n\n    def getDailyTask(self):\n        return axios.get('https://quqi.com/api/dailyTask', { headers: self.headers })\n            .then(response => response.data)\n            .then(data => data['tasks'] if data['tasks'] else null)\n            .catch(error => Promise.reject(error))\n\n    def getReward(self, id):\n        return axios.post('https://quqi.com/api/getReward', { id: id }, { headers: self.headers })\n            .then(response => response.data)\n            .catch(error => Promise.reject(error))\n\n    def visit(self, id):\n        return axios.post('https://quqi.com/api/visit', { id: id }, { headers: self.headers })\n            .then(response => response.data)\n            .catch(error => Promise.reject(error))\n\n    def getQuqiId(self):\n        return axios.get('https://quqi.com/api/getQuqiId', { headers: self.headers })\n            .then(response => response.data)\n            .then(data => {\n                if (data['join_needed']):\n                    return axios.post('https://quqi.com/api/joinGroup', { id: data['group_id'] }, { headers: self.headers })\n                        .then(response => response.data)\n                        .catch(error => Promise.reject(error))\n                return data\n            })\n            .catch(error => Promise.reject(error))\n\n    def uploadImg(self, id):\n        return axios.post('https://quqi.com/api/uploadImg', { id: id }, { headers: self.headers })\n            .then(response => response.data)\n            .then(data => axios.delete('https://quqi.com/api/deleteImg', { headers: self.headers }))\n            .catch(error => Promise.reject(error))\n\n    def executeTasks(self):\n        return Promise.all([\n            self.getDailyTask(),\n            self.getReward(1),\n            self.visit(2),\n            self.getQuqiId(),\n            self.uploadImg(3)\n        ]).then(results => {\n            const walletInfo = results[0]['wallet_info'];\n            return `Wallet info: ${walletInfo}`;\n        })\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 220,
    "Instruction": "Task Description: Implement a WebSocket client initialization function that establishes a connection to a server, handles incoming messages, manages connection events, and provides reconnection logic upon disconnection.\n\nFunction Description: The function initializes a WebSocket connection to the specified URL and sets up event handlers for connection opening, message reception, and connection closing. It also provides a callback mechanism to expose the WebSocket instance to the caller and implements automatic reconnection when the connection is lost.\n\nInput:\n- handleFunctionCall: Function - A callback function to handle incoming messages from the WebSocket server\n- url: string - The WebSocket server URL to connect to\n- cb: Function - A callback function that receives the initialized WebSocket instance\n\nOutput: None (The function's effects are through callbacks and event handlers)\n- The function doesn't return anything directly but:\n  - Calls the provided callback with the WebSocket instance\n  - Posts messages via postMessage for connection status changes\n  - Automatically attempts reconnection on close\n  - Handles incoming messages through the provided handleFunctionCall",
    "Canonical_solution": "export const initWs = (\n  handleFunctionCall: Function,\n  url: string,\n  cb: (_ws: WebSocket) => void\n) => {\n  const ws = new WebSocket(url);\n  ws.onopen = () => {\n    console.log(\"Connected to server\");\n    postMessage(\"msg:Connected to server\");\n    postMessage({\n      id: getUuid(),\n      data: null,\n      type: MsgType.WebSocketConnected,\n    });\n  };\n  ws.onmessage = (e) => {\n    const channel = new MessageChannel();\n    const msg = deserializedMsg(e.data);\n    handleFunctionCall(msg.data, msg.id, channel.port1);\n    channel.port2.onmessage = (e) => {\n      ws.send(JSON.stringify(e.data));\n    };\n  };\n  ws.onclose = () => {\n    console.log(\"Disconnected from server\");\n    postMessage({\n      id: getUuid(),\n      data: null,\n      type: MsgType.WebSocketDisconnected,\n    });\n    setTimeout(() => {\n      initWs(handleFunctionCall, url, cb);\n    }, 1000);\n  };\n  cb(ws);\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction initializeWebSocket(handleFunctionCall, url, cb) {\n  const ws = new WebSocket(url);\n  ws.onopen = function() {\n    cb(ws);\n    postMessage('WebSocket connected');\n  };\n  ws.onmessage = function(event) {\n    handleFunctionCall(event.data);\n  };\n  ws.onclose = function() {\n    postMessage('WebSocket disconnected');\n    setTimeout(() => initializeWebSocket(handleFunctionCall, url, cb), 5000);\n  };\n  ws.onerror = function(error) {\n    postMessage('WebSocket error: ' + error.message);\n    ws.close();\n  };\n}\n```",
      "```javascript\nconst ws = new WebSocket(url);\n\nfunction initializeWebSocket(handleFunctionCall, url, cb) {\n  ws.onopen = function() {\n    cb(ws);\n    postMessage('connected');\n  };\n\n  ws.onmessage = function(event) {\n    handleFunctionCall(event.data);\n  };\n\n  ws.onclose = function() {\n    postMessage('disconnected');\n    setTimeout(() => {\n      initializeWebSocket(handleFunctionCall, url, cb);\n    }, 5000);\n  };\n\n  ws.onerror = function(error) {\n    postMessage('error: ' + error.message);\n    ws.close();\n  };\n}\n```",
      "```javascript\nfunction initializeWebSocket(handleFunctionCall, url, cb) {\n  const ws = new WebSocket(url);\n  ws.onopen = function() {\n    cb(ws);\n    postMessage('connected');\n  };\n  ws.onmessage = function(event) {\n    handleFunctionCall(event.data);\n  };\n  ws.onclose = function() {\n    postMessage('disconnected');\n    setTimeout(() => initializeWebSocket(handleFunctionCall, url, cb), 5000);\n  };\n  ws.onerror = function(error) {\n    postMessage('error: ' + error.message);\n    ws.close();\n  };\n}\n```",
      "function initializeWebSocketConnection(handleFunctionCall, url, cb) {\n  var ws = new WebSocket(url);\n  ws.onopen = function() {\n    cb(ws);\n    postMessage('WebSocket connected');\n  };\n  ws.onmessage = function(event) {\n    handleFunctionCall(event.data);\n  };\n  ws.onclose = function() {\n    postMessage('WebSocket disconnected');\n    setTimeout(function() {\n      initializeWebSocketConnection(handleFunctionCall, url, cb);\n    }, 5000);\n  };\n  ws.onerror = function(error) {\n    postMessage('WebSocket error: ' + error.message);\n    ws.close();\n  };\n}",
      "function initializeWebSocketConnection(handleFunctionCall, url, cb) {\n  var ws = new WebSocket(url);\n\n  ws.onopen = function() {\n    cb(ws);\n    postMessage('WebSocket connected');\n  };\n\n  ws.onmessage = function(event) {\n    handleFunctionCall(event.data);\n  };\n\n  ws.onclose = function() {\n    postMessage('WebSocket disconnected');\n    setTimeout(function() {\n      initializeWebSocketConnection(handleFunctionCall, url, cb);\n    }, 5000);\n  };\n\n  ws.onerror = function(error) {\n    postMessage('WebSocket error: ' + error.message);\n    ws.close();\n  };\n}",
      "```javascript\nconst ws = new WebSocket(url);\n\nfunction initializeWebSocket(handleFunctionCall, url, cb) {\n  ws.onopen = function() {\n    cb(ws);\n    postMessage('connected');\n  };\n\n  ws.onmessage = function(event) {\n    handleFunctionCall(event.data);\n  };\n\n  ws.onclose = function() {\n    postMessage('disconnected');\n    setTimeout(() => {\n      initializeWebSocket(handleFunctionCall, url, cb);\n    }, 5000);\n  };\n\n  ws.onerror = function(error) {\n    postMessage('error: ' + error.message);\n    ws.close();\n  };\n}\n```",
      "```javascript\nfunction initializeWebSocket(handleFunctionCall, url, cb) {\n  let ws;\n  const reconnectInterval = 5000;\n  const maxReconnectAttempts = 10;\n  let reconnectAttempts = 0;\n\n  function connect() {\n    ws = new WebSocket(url);\n    ws.onopen = function() {\n      reconnectAttempts = 0;\n      cb(ws);\n    };\n    ws.onmessage = function(event) {\n      handleFunctionCall(event.data);\n    };\n    ws.onclose = function() {\n      if (reconnectAttempts < maxReconnectAttempts) {\n        setTimeout(connect, reconnectInterval);\n        reconnectAttempts++;\n      }\n    };\n  }\n\n  connect();\n}\n```",
      "```javascript\nconst ws = new WebSocket(url);\n\nws.onopen = function() {\n  cb(ws);\n  postMessage('connected');\n};\n\nws.onmessage = function(event) {\n  handleFunctionCall(event.data);\n};\n\nws.onclose = function() {\n  postMessage('disconnected');\n  setTimeout(() => {\n    const newWs = new WebSocket(url);\n    newWs.onopen = ws.onopen;\n    newWs.onmessage = ws.onmessage;\n    newWs.onclose = ws.onclose;\n    ws = newWs;\n  }, 5000);\n};\n```",
      "```javascript\nconst ws = new WebSocket(url);\n\nfunction initializeWebSocket(handleFunctionCall, url, cb) {\n  ws.onopen = function() {\n    cb(ws);\n    postMessage('connected');\n  };\n\n  ws.onmessage = function(event) {\n    handleFunctionCall(event.data);\n  };\n\n  ws.onclose = function() {\n    postMessage('disconnected');\n    setTimeout(() => {\n      initializeWebSocket(handleFunctionCall, url, cb);\n    }, 5000);\n  };\n\n  ws.onerror = function(error) {\n    postMessage('error: ' + error.message);\n    ws.close();\n  };\n}\n```",
      "```javascript\nfunction initializeWebSocket(handleFunctionCall, url, cb) {\n  let ws = new WebSocket(url);\n  ws.onopen = function() {\n    cb(ws);\n    postMessage('connected');\n  };\n  ws.onmessage = function(event) {\n    handleFunctionCall(event.data);\n  };\n  ws.onclose = function() {\n    postMessage('disconnected');\n    setTimeout(function() {\n      initializeWebSocket(handleFunctionCall, url, cb);\n    }, 5000);\n  };\n  ws.onerror = function(error) {\n    postMessage('error: ' + error.message);\n    ws.close();\n  };\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 221,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes multiple WebSocket connections for different binary data types (byte array, byte buffer, and input stream) and handles their communication events.\n\nClass Description: The WebSocketClient class manages three WebSocket connections for different binary data types. It initializes connections, sets binary data types, handles connection events (open, message, error), and provides methods for sending binary data and displaying communication status.\n\nAttributes:\n- websocketByteArray: [WebSocket] - WebSocket connection for byte array data\n- websocketByteBuffer: [WebSocket] - WebSocket connection for byte buffer data\n- websocketInputStream: [WebSocket] - WebSocket connection for input stream data\n- output: [HTMLElement] - DOM element for displaying communication logs\n\nMethods:\n- constructor() -> [void] - Initializes WebSocket connections and event handlers\n- initializeEventHandlers() -> [void] - Sets up event handlers for all WebSocket connections\n- onOpenByteArray(evt: [Event]) -> [void] - Handles byte array connection open event\n- onOpenByteBuffer(evt: [Event]) -> [void] - Handles byte buffer connection open event\n- onOpenInputStream(evt: [Event]) -> [void] - Handles input stream connection open event\n- echoBinaryByteArray() -> [void] - Sends binary data as byte array\n- echoBinaryByteBuffer() -> [void] - Sends binary data as byte buffer\n- echoBinaryInputStream() -> [void] - Sends binary data as input stream\n- onMessageByteArray(evt: [MessageEvent]) -> [void] - Handles received byte array messages\n- onMessageByteBuffer(evt: [MessageEvent]) -> [void] - Handles received byte buffer messages\n- onMessageInputStream(evt: [MessageEvent]) -> [void] - Handles received input stream messages\n- onError(evt: [Event]) -> [void] - Handles WebSocket errors\n- writeToScreen(message: [string]) -> [void] - Displays messages in the output element",
    "Canonical_solution": "var wsByteArrayUri = \"ws://\" + document.location.host + document.location.pathname + \"bytearray\";\nvar wsByteBufferUri = \"ws://\" + document.location.host + document.location.pathname + \"bytebuffer\";\nvar wsInputStreamUri = \"ws://\" + document.location.host + document.location.pathname + \"inputstream\";\n\nclass WebSocketClient {\n    constructor() {\n        this.websocketByteArray = new WebSocket(wsByteArrayUri);\n        this.websocketByteBuffer = new WebSocket(wsByteBufferUri);\n        this.websocketInputStream = new WebSocket(wsInputStreamUri);\n        \n        this.websocketByteArray.binaryType = \"arraybuffer\";\n        this.websocketByteBuffer.binaryType = \"arraybuffer\";\n        this.websocketInputStream.binaryType = \"arraybuffer\";\n        \n        this.output = document.getElementById(\"output\");\n        \n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = (evt) => this.onOpenByteArray(evt);\n        this.websocketByteArray.onmessage = (evt) => this.onMessageByteArray(evt);\n        this.websocketByteArray.onerror = (evt) => this.onError(evt);\n\n        this.websocketByteBuffer.onopen = (evt) => this.onOpenByteBuffer(evt);\n        this.websocketByteBuffer.onmessage = (evt) => this.onMessageByteBuffer(evt);\n        this.websocketByteBuffer.onerror = (evt) => this.onError(evt);\n\n        this.websocketInputStream.onopen = (evt) => this.onOpenInputStream(evt);\n        this.websocketInputStream.onmessage = (evt) => this.onMessageInputStream(evt);\n        this.websocketInputStream.onerror = (evt) => this.onError(evt);\n    }\n\n    onOpenByteArray() {\n        console.log(\"onOpen (byte])\");\n    }\n\n    onOpenByteBuffer() {\n        console.log(\"onOpen (ByteBuffer)\");\n    }\n\n    onOpenInputStream() {\n        console.log(\"onOpen (InputStream)\");\n    }\n\n    echoBinaryByteArray() {\n        var buffer = new ArrayBuffer(myField.value.length);\n        var bytes = new Uint8Array(buffer);\n        for (var i=0; i<bytes.length; i++) {\n            bytes[i] = i;\n        }\n        this.websocketByteArray.send(buffer);\n        this.writeToScreen(\"SENT (byte[]): \" + buffer.byteLength + \" bytes\");\n    }\n\n    echoBinaryByteBuffer() {\n        var buffer = new ArrayBuffer(myField.value.length);\n        var bytes = new Uint8Array(buffer);\n        for (var i=0; i<bytes.length; i++) {\n            bytes[i] = i;\n        }\n        this.websocketByteBuffer.send(buffer);\n        this.writeToScreen(\"SENT (ByteBuffer): \" + buffer.byteLength + \" bytes\");\n    }\n\n    echoBinaryInputStream() {\n        var buffer = new ArrayBuffer(myField.value.length);\n        var bytes = new Uint8Array(buffer);\n        for (var i=0; i<bytes.length; i++) {\n            bytes[i] = i;\n        }\n        this.websocketInputStream.send(buffer);\n        this.writeToScreen(\"SENT (InputStream): \" + buffer.byteLength + \" bytes\");\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen(\"RECEIVED (byte[]): \" + evt.data);\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen(\"RECEIVED (ByteBuffer): \" + evt.data);\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen(\"RECEIVED (InputStream): \" + evt.data);\n    }\n\n    onError(evt) {\n        this.writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n    }\n\n    writeToScreen(message) {\n        var pre = document.createElement(\"p\");\n        pre.style.wordWrap = \"break-word\";\n        pre.innerHTML = message;\n        this.output.appendChild(pre);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WebSocketClient {\n    constructor() {\n        this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n        this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n        this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n        this.output = document.getElementById('output');\n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n        this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n        this.websocketByteArray.onerror = this.onError.bind(this);\n\n        this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n        this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n        this.websocketByteBuffer.onerror = this.onError.bind(this);\n\n        this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n        this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n        this.websocketInputStream.onerror = this.onError.bind(this);\n    }\n\n    onOpenByteArray(evt) {\n        this.writeToScreen('ByteArray connection opened');\n    }\n\n    onOpenByteBuffer(evt) {\n        this.writeToScreen('ByteBuffer connection opened');\n    }\n\n    onOpenInputStream(evt) {\n        this.writeToScreen('InputStream connection opened');\n    }\n\n    echoBinaryByteArray() {\n        const byteArray = [1, 2, 3, 4, 5];\n        this.websocketByteArray.send(byteArray);\n    }\n\n    echoBinaryByteBuffer() {\n        const byteArray = [1, 2, 3, 4, 5];\n        const buffer = new ArrayBuffer(byteArray.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < byteArray.length; i++) {\n            view[i] = byteArray[i];\n        }\n        this.websocketByteBuffer.send(buffer);\n    }\n\n    echoBinaryInputStream() {\n        const byteArray = [1, 2, 3, 4, 5];\n        const buffer = new ArrayBuffer(byteArray.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < byteArray.length; i++) {\n            view[i] = byteArray[i];\n        }\n        this.websocketInputStream.send(buffer);\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen('Received byteArray message');\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen('Received ByteBuffer message');\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen('Received InputStream message');\n    }\n\n    onError(evt) {\n        this.writeToScreen('WebSocket error: ' + evt.message);\n    }\n\n    writeToScreen(message) {\n        this.output.innerHTML += message + '<br>';\n    }\n}\n```",
      "class WebSocketClient {\n    websocketByteArray;\n    websocketByteBuffer;\n    websocketInputStream;\n    output;\n\n    constructor() {\n        this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n        this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n        this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n        this.output = document.getElementById('output');\n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n        this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n        this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n        this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n        this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n        this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n        this.websocketByteArray.onerror = this.onError.bind(this);\n        this.websocketByteBuffer.onerror = this.onError.bind(this);\n        this.websocketInputStream.onerror = this.onError.bind(this);\n    }\n\n    onOpenByteArray(evt) {\n        this.writeToScreen('ByteArray connection opened');\n    }\n\n    onOpenByteBuffer(evt) {\n        this.writeToScreen('ByteBuffer connection opened');\n    }\n\n    onOpenInputStream(evt) {\n        this.writeToScreen('InputStream connection opened');\n    }\n\n    echoBinaryByteArray() {\n        const byteArray = [1, 2, 3, 4, 5];\n        this.websocketByteArray.send(byteArray);\n    }\n\n    echoBinaryByteBuffer() {\n        const byteArray = [1, 2, 3, 4, 5];\n        const buffer = new ArrayBuffer(byteArray.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < byteArray.length; i++) {\n            view[i] = byteArray[i];\n        }\n        this.websocketByteBuffer.send(buffer);\n    }\n\n    echoBinaryInputStream() {\n        const byteArray = [1, 2, 3, 4, 5];\n        const inputStream = new Uint8Array(byteArray);\n        this.websocketInputStream.send(inputStream);\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen('Received byteArray message');\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen('Received ByteBuffer message');\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen('Received InputStream message');\n    }\n\n    onError(evt) {\n        this.writeToScreen('WebSocket error: ' + evt.message);\n    }\n\n    writeToScreen(message) {\n        this.output.innerHTML += message + '<br>';\n    }\n}",
      "```javascript\nclass WebSocketClient {\n    constructor() {\n        this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n        this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n        this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n        this.output = document.getElementById('output');\n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n        this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n        this.websocketByteArray.onerror = this.onError.bind(this);\n\n        this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n        this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n        this.websocketByteBuffer.onerror = this.onError.bind(this);\n\n        this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n        this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n        this.websocketInputStream.onerror = this.onError.bind(this);\n    }\n\n    onOpenByteArray(evt) {\n        this.writeToScreen('ByteArray connection opened');\n    }\n\n    onOpenByteBuffer(evt) {\n        this.writeToScreen('ByteBuffer connection opened');\n    }\n\n    onOpenInputStream(evt) {\n        this.writeToScreen('InputStream connection opened');\n    }\n\n    echoBinaryByteArray() {\n        const byteArray = [1, 2, 3, 4, 5];\n        this.websocketByteArray.send(byteArray);\n    }\n\n    echoBinaryByteBuffer() {\n        const byteArray = [1, 2, 3, 4, 5];\n        const buffer = new ArrayBuffer(byteArray.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < byteArray.length; i++) {\n            view[i] = byteArray[i];\n        }\n        this.websocketByteBuffer.send(buffer);\n    }\n\n    echoBinaryInputStream() {\n        const byteArray = [1, 2, 3, 4, 5];\n        const buffer = new ArrayBuffer(byteArray.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < byteArray.length; i++) {\n            view[i] = byteArray[i];\n        }\n        this.websocketInputStream.send(buffer);\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen('Received byteArray message');\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen('Received ByteBuffer message');\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen('Received InputStream message');\n    }\n\n    onError(evt) {\n        this.writeToScreen('WebSocket error: ' + evt.message);\n    }\n\n    writeToScreen(message) {\n        this.output.innerHTML += message + '<br>';\n    }\n}\n```",
      "class WebSocketClient {\n  constructor() {\n    this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n    this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n    this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n    this.output = document.getElementById('output');\n    this.initializeEventHandlers();\n  }\n\n  initializeEventHandlers() {\n    this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n    this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n    this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n    this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n    this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n    this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n    this.websocketByteArray.onerror = this.onError.bind(this);\n    this.websocketByteBuffer.onerror = this.onError.bind(this);\n    this.websocketInputStream.onerror = this.onError.bind(this);\n  }\n\n  onOpenByteArray(evt) {\n    this.writeToScreen('ByteArray connection opened');\n  }\n\n  onOpenByteBuffer(evt) {\n    this.writeToScreen('ByteBuffer connection opened');\n  }\n\n  onOpenInputStream(evt) {\n    this.writeToScreen('InputStream connection opened');\n  }\n\n  echoBinaryByteArray() {\n    const byteArray = [1, 2, 3, 4, 5];\n    this.websocketByteArray.send(byteArray);\n  }\n\n  echoBinaryByteBuffer() {\n    const buffer = new ArrayBuffer(5);\n    const dataView = new DataView(buffer);\n    dataView.setInt8(0, 1);\n    dataView.setInt8(1, 2);\n    dataView.setInt8(2, 3);\n    dataView.setInt8(3, 4);\n    dataView.setInt8(4, 5);\n    this.websocketByteBuffer.send(buffer);\n  }\n\n  echoBinaryInputStream() {\n    const inputStream = new (window['TextEncoder'] || TextEncoder)();\n    inputStream.encode('12345');\n    const buffer = inputStream.buffer;\n    this.websocketInputStream.send(buffer);\n  }\n\n  onMessageByteArray(evt) {\n    this.writeToScreen('Received byteArray message');\n  }\n\n  onMessageByteBuffer(evt) {\n    this.writeToScreen('Received ByteBuffer message');\n  }\n\n  onMessageInputStream(evt) {\n    this.writeToScreen('Received InputStream message');\n  }\n\n  onError(evt) {\n    this.writeToScreen('WebSocket error: ' + evt.message);\n  }\n\n  writeToScreen(message) {\n    this.output.innerHTML += message + '<br>';\n  }\n}",
      "```javascript\nclass WebSocketClient {\n  constructor() {\n    this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n    this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n    this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n    this.output = document.getElementById('output');\n    this.initializeEventHandlers();\n  }\n\n  initializeEventHandlers() {\n    this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n    this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n    this.websocketByteArray.onerror = this.onError.bind(this);\n\n    this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n    this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n    this.websocketByteBuffer.onerror = this.onError.bind(this);\n\n    this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n    this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n    this.websocketInputStream.onerror = this.onError.bind(this);\n  }\n\n  onOpenByteArray(evt) {\n    this.writeToScreen('ByteArray connection opened');\n  }\n\n  onOpenByteBuffer(evt) {\n    this.writeToScreen('ByteBuffer connection opened');\n  }\n\n  onOpenInputStream(evt) {\n    this.writeToScreen('InputStream connection opened');\n  }\n\n  echoBinaryByteArray() {\n    const byteArray = [1, 2, 3, 4, 5];\n    this.websocketByteArray.send(byteArray);\n  }\n\n  echoBinaryByteBuffer() {\n    const byteArray = [1, 2, 3, 4, 5];\n    const buffer = new ArrayBuffer(byteArray.length);\n    const view = new Uint8Array(buffer);\n    for (let i = 0; i < byteArray.length; i++) {\n      view[i] = byteArray[i];\n    }\n    this.websocketByteBuffer.send(buffer);\n  }\n\n  echoBinaryInputStream() {\n    const byteArray = [1, 2, 3, 4, 5];\n    const buffer = new ArrayBuffer(byteArray.length);\n    const view = new Uint8Array(buffer);\n    for (let i = 0; i < byteArray.length; i++) {\n      view[i] = byteArray[i];\n    }\n    this.websocketInputStream.send(buffer);\n  }\n\n  onMessageByteArray(evt) {\n    this.writeToScreen('Received byteArray message');\n  }\n\n  onMessageByteBuffer(evt) {\n    this.writeToScreen('Received ByteBuffer message');\n  }\n\n  onMessageInputStream(evt) {\n    this.writeToScreen('Received InputStream message');\n  }\n\n  onError(evt) {\n    this.writeToScreen('WebSocket error: ' + evt.message);\n  }\n\n  writeToScreen(message) {\n    this.output.innerHTML += message + '<br>';\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor() {\n        this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n        this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n        this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n        this.output = document.getElementById('output');\n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n        this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n        this.websocketByteArray.onerror = this.onError.bind(this);\n\n        this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n        this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n        this.websocketByteBuffer.onerror = this.onError.bind(this);\n\n        this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n        this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n        this.websocketInputStream.onerror = this.onError.bind(this);\n    }\n\n    onOpenByteArray(evt) {\n        this.writeToScreen('ByteArray connection opened');\n    }\n\n    onOpenByteBuffer(evt) {\n        this.writeToScreen('ByteBuffer connection opened');\n    }\n\n    onOpenInputStream(evt) {\n        this.writeToScreen('InputStream connection opened');\n    }\n\n    echoBinaryByteArray() {\n        const byteArray = [1, 2, 3, 4, 5];\n        this.websocketByteArray.send(byteArray);\n    }\n\n    echoBinaryByteBuffer() {\n        const byteArray = [1, 2, 3, 4, 5];\n        const buffer = new ArrayBuffer(byteArray.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < byteArray.length; i++) {\n            view[i] = byteArray[i];\n        }\n        this.websocketByteBuffer.send(buffer);\n    }\n\n    echoBinaryInputStream() {\n        const byteArray = [1, 2, 3, 4, 5];\n        const buffer = new ArrayBuffer(byteArray.length);\n        const view = new Uint8Array(buffer);\n        for (let i = 0; i < byteArray.length; i++) {\n            view[i] = byteArray[i];\n        }\n        this.websocketInputStream.send(buffer);\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen('Received byteArray message');\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen('Received ByteBuffer message');\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen('Received InputStream message');\n    }\n\n    onError(evt) {\n        this.writeToScreen('WebSocket error: ' + evt.message);\n    }\n\n    writeToScreen(message) {\n        this.output.innerHTML += message + '<br>';\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor() {\n        this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n        this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n        this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n        this.output = document.getElementById('output');\n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n        this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n        this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n\n        this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n        this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n        this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n\n        this.websocketByteArray.onerror = this.onError.bind(this);\n        this.websocketByteBuffer.onerror = this.onError.bind(this);\n        this.websocketInputStream.onerror = this.onError.bind(this);\n    }\n\n    onOpenByteArray(evt) {\n        this.writeToScreen('ByteArray connection opened');\n    }\n\n    onOpenByteBuffer(evt) {\n        this.writeToScreen('ByteBuffer connection opened');\n    }\n\n    onOpenInputStream(evt) {\n        this.writeToScreen('InputStream connection opened');\n    }\n\n    echoBinaryByteArray() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        this.websocketByteArray.send(byteArray);\n    }\n\n    echoBinaryByteBuffer() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        const buffer = new ArrayBuffer(byteArray.length);\n        const bufferView = new Uint8Array(buffer);\n        bufferView.set(byteArray);\n        this.websocketByteBuffer.send(buffer);\n    }\n\n    echoBinaryInputStream() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        const stream = new ReadableStream({\n            start(controller) {\n                controller.enqueue(byteArray);\n                controller.close();\n            }\n        });\n        this.websocketInputStream.send(stream);\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen('Received byteArray message');\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen('Received ByteBuffer message');\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen('Received InputStream message');\n    }\n\n    onError(evt) {\n        this.writeToScreen('WebSocket error: ' + evt.message);\n    }\n\n    writeToScreen(message) {\n        this.output.innerHTML += message + '<br>';\n    }\n}\n```",
      "class WebSocketClient {\n    websocketByteArray;\n    websocketByteBuffer;\n    websocketInputStream;\n    output;\n\n    constructor() {\n        this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n        this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n        this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n        this.output = document.getElementById('output');\n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n        this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n        this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n        this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n        this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n        this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n        this.websocketByteArray.onerror = this.onError.bind(this);\n        this.websocketByteBuffer.onerror = this.onError.bind(this);\n        this.websocketInputStream.onerror = this.onError.bind(this);\n    }\n\n    onOpenByteArray(evt) {\n        this.writeToScreen('ByteArray connection opened');\n    }\n\n    onOpenByteBuffer(evt) {\n        this.writeToScreen('ByteBuffer connection opened');\n    }\n\n    onOpenInputStream(evt) {\n        this.writeToScreen('InputStream connection opened');\n    }\n\n    echoBinaryByteArray() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        this.websocketByteArray.send(byteArray);\n    }\n\n    echoBinaryByteBuffer() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        const buffer = new ArrayBuffer(byteArray.length);\n        const bufferView = new Uint8Array(buffer);\n        bufferView.set(byteArray);\n        this.websocketByteBuffer.send(buffer);\n    }\n\n    echoBinaryInputStream() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        const stream = new ReadableStream({\n            start(controller) {\n                controller.enqueue(byteArray);\n                controller.close();\n            }\n        });\n        this.websocketInputStream.send(stream);\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen('Received byteArray message');\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen('Received ByteBuffer message');\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen('Received InputStream message');\n    }\n\n    onError(evt) {\n        this.writeToScreen('WebSocket error: ' + evt.message);\n    }\n\n    writeToScreen(message) {\n        this.output.innerHTML += message + '<br>';\n    }\n}",
      "class WebSocketClient {\n    websocketByteArray;\n    websocketByteBuffer;\n    websocketInputStream;\n    output;\n\n    constructor() {\n        this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n        this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n        this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n        this.output = document.getElementById('output');\n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n        this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n        this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n        this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n        this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n        this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n        this.websocketByteArray.onerror = this.onError.bind(this);\n        this.websocketByteBuffer.onerror = this.onError.bind(this);\n        this.websocketInputStream.onerror = this.onError.bind(this);\n    }\n\n    onOpenByteArray(evt) {\n        this.writeToScreen('ByteArray connection opened');\n    }\n\n    onOpenByteBuffer(evt) {\n        this.writeToScreen('ByteBuffer connection opened');\n    }\n\n    onOpenInputStream(evt) {\n        this.writeToScreen('InputStream connection opened');\n    }\n\n    echoBinaryByteArray() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        this.websocketByteArray.send(byteArray);\n    }\n\n    echoBinaryByteBuffer() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        const buffer = new ArrayBuffer(byteArray.length);\n        const bufferView = new Uint8Array(buffer);\n        bufferView.set(byteArray);\n        this.websocketByteBuffer.send(buffer);\n    }\n\n    echoBinaryInputStream() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        const stream = new ReadableStream({\n            start(controller) {\n                controller.enqueue(byteArray);\n                controller.close();\n            }\n        });\n        this.websocketInputStream.send(stream);\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen('Received byteArray message');\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen('Received ByteBuffer message');\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen('Received InputStream message');\n    }\n\n    onError(evt) {\n        this.writeToScreen('WebSocket error occurred');\n    }\n\n    writeToScreen(message) {\n        this.output.innerHTML += message + '<br>';\n    }\n}",
      "```javascript\nclass WebSocketClient {\n    constructor() {\n        this.websocketByteArray = new WebSocket('ws://example.com/byteArray');\n        this.websocketByteBuffer = new WebSocket('ws://example.com/byteBuffer');\n        this.websocketInputStream = new WebSocket('ws://example.com/inputStream');\n        this.output = document.getElementById('output');\n        this.initializeEventHandlers();\n    }\n\n    initializeEventHandlers() {\n        this.websocketByteArray.onopen = this.onOpenByteArray.bind(this);\n        this.websocketByteBuffer.onopen = this.onOpenByteBuffer.bind(this);\n        this.websocketInputStream.onopen = this.onOpenInputStream.bind(this);\n        this.websocketByteArray.onmessage = this.onMessageByteArray.bind(this);\n        this.websocketByteBuffer.onmessage = this.onMessageByteBuffer.bind(this);\n        this.websocketInputStream.onmessage = this.onMessageInputStream.bind(this);\n        this.websocketByteArray.onerror = this.onError.bind(this);\n        this.websocketByteBuffer.onerror = this.onError.bind(this);\n        this.websocketInputStream.onerror = this.onError.bind(this);\n    }\n\n    onOpenByteArray(evt) {\n        this.writeToScreen('ByteArray connection opened');\n    }\n\n    onOpenByteBuffer(evt) {\n        this.writeToScreen('ByteBuffer connection opened');\n    }\n\n    onOpenInputStream(evt) {\n        this.writeToScreen('InputStream connection opened');\n    }\n\n    echoBinaryByteArray() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        this.websocketByteArray.send(byteArray);\n    }\n\n    echoBinaryByteBuffer() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        const buffer = new ArrayBuffer(byteArray.length);\n        const bufferView = new Uint8Array(buffer);\n        bufferView.set(byteArray);\n        this.websocketByteBuffer.send(buffer);\n    }\n\n    echoBinaryInputStream() {\n        const byteArray = new Uint8Array([1, 2, 3, 4, 5]);\n        const stream = new ReadableStream({\n            start(controller) {\n                controller.enqueue(byteArray);\n                controller.close();\n            }\n        });\n        this.websocketInputStream.send(stream);\n    }\n\n    onMessageByteArray(evt) {\n        this.writeToScreen('Received byteArray message');\n    }\n\n    onMessageByteBuffer(evt) {\n        this.writeToScreen('Received ByteBuffer message');\n    }\n\n    onMessageInputStream(evt) {\n        this.writeToScreen('Received InputStream message');\n    }\n\n    onError(evt) {\n        this.writeToScreen('WebSocket error occurred');\n    }\n\n    writeToScreen(message) {\n        this.output.innerHTML += message + '<br>';\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles WebSocket connections, message transmission, and error handling.\n\nClass Description: The WS class provides a WebSocket client implementation with configurable connection parameters, event handling, and message transmission capabilities. It supports both secure (wss) and non-secure (ws) connections, binary data transmission, and connection lifecycle management.\n\nAttributes:\n- secure: [Boolean] - Indicates whether to use a secure WebSocket connection (wss)\n- hostname: [String] - The hostname to connect to\n- port: [Number] - The port number for the connection\n- path: [String] - The path for the WebSocket endpoint\n- query: [Object] - Additional query parameters for the connection\n- timestampParam: [String] - Parameter name for timestamp in requests\n- timestampRequests: [Boolean] - Whether to include timestamps in requests\n- readyState: [String] - Current state of the WebSocket connection\n- ws: [WebSocket] - The underlying WebSocket instance\n- binaryType: [String] - Type of binary data to use ('buffer' or 'arraybuffer')\n- perMessageDeflate: [Object|Boolean] - Configuration for per-message deflate extension\n\nMethods:\n- constructor(opts): [Object] -> [void] - Initializes the WebSocket client with configuration options\n- doOpen(): [void] -> [void] - Establishes the WebSocket connection\n- addEventListeners(): [void] -> [void] - Sets up event handlers for the WebSocket\n- write(packets): [Array] -> [void] - Sends multiple packets through the WebSocket\n- doClose(): [void] -> [void] - Closes the WebSocket connection\n- uri(): [void] -> [String] - Generates the WebSocket connection URI\n- check(): [void] -> [Boolean] - Verifies WebSocket availability and initialization status",
    "Canonical_solution": "var WebSocket = global.WebSocket || global.MozWebSocket;\n\nclass WS {\n  constructor(opts) {\n    this.secure = null != opts.secure ? opts.secure : (global.location && 'https:' == location.protocol);\n    this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');\n    this.port = opts.port || (global.location && location.port ? location.port : (this.secure ? 443 : 80));\n    this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n    this.query = opts.query || {};\n    this.timestampParam = opts.timestampParam || 't';\n    this.timestampRequests = opts.timestampRequests;\n    this.readyState = '';\n    this.ws = null;\n    this.binaryType = null;\n    this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n  }\n\n  doOpen() {\n    if (!this.check()) return;\n\n    var uri = this.uri();\n    var protocols = void(0);\n    var opts = {\n      agent: this.agent,\n      perMessageDeflate: this.perMessageDeflate\n    };\n\n    this.ws = new WebSocket(uri, protocols, opts);\n\n    if (this.ws.binaryType === undefined) {\n      this.supportsBinary = false;\n    }\n\n    if (this.ws.supports && this.ws.supports.binary) {\n      this.supportsBinary = true;\n      this.ws.binaryType = 'buffer';\n    } else {\n      this.ws.binaryType = 'arraybuffer';\n    }\n\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    var self = this;\n\n    this.ws.onopen = function() {\n      self.onOpen();\n    };\n    this.ws.onclose = function() {\n      self.onClose();\n    };\n    this.ws.onmessage = function(ev) {\n      self.onData(ev.data);\n    };\n    this.ws.onerror = function(e) {\n      self.onError('websocket error', e);\n    };\n  }\n\n  write(packets) {\n    var self = this;\n    this.writable = false;\n\n    for (var i = 0, l = packets.length; i < l; i++) {\n      (function(packet) {\n        parser.encodePacket(packet, self.supportsBinary, function(data) {\n          try {\n            self.ws.send(data);\n          } catch(e) {\n            debug('websocket closed before onclose event');\n          }\n        });\n      })(packets[i]);\n    }\n\n    setTimeout(function() {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n\n  doClose() {\n    if (typeof this.ws !== 'undefined') {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    var query = this.query || {};\n    var schema = this.secure ? 'wss' : 'ws';\n    var port = '';\n\n    if (this.port && (('wss' == schema && this.port != 443) || ('ws' == schema && this.port != 80))) {\n      port = ':' + this.port;\n    }\n\n    if (this.timestampRequests) {\n      query[this.timestampParam] = yeast();\n    }\n\n    if (!this.supportsBinary) {\n      query.b64 = 1;\n    }\n\n    query = parseqs.encode(query);\n\n    if (query.length) {\n      query = '?' + query;\n    }\n\n    var ipv6 = this.hostname.indexOf(':') !== -1;\n    return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n  }\n\n  check() {\n    return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WS {\n    constructor(opts) {\n        this.secure = opts.secure;\n        this.hostname = opts.hostname;\n        this.port = opts.port;\n        this.path = opts.path;\n        this.query = opts.query;\n        this.timestampParam = opts.timestampParam;\n        this.timestampRequests = opts.timestampRequests;\n        this.readyState = 'CONNECTING';\n        this.ws = null;\n        this.binaryType = opts.binaryType || 'blob';\n        this.perMessageDeflate = opts.perMessageDeflate;\n    }\n\n    doOpen() {\n        const protocol = this.secure ? 'wss' : 'ws';\n        const uri = this.uri();\n        this.ws = new WebSocket(uri, this.perMessageDeflate);\n        this.addEventListeners();\n    }\n\n    addEventListeners() {\n        this.ws.onopen = () => {\n            this.readyState = 'OPEN';\n        };\n        this.ws.onmessage = (event) => {\n            // Handle incoming messages\n        };\n        this.ws.onerror = (error) => {\n            // Handle errors\n        };\n        this.ws.onclose = () => {\n            this.readyState = 'CLOSED';\n        };\n    }\n\n    write(packets) {\n        packets.forEach(packet => {\n            this.ws.send(packet);\n        });\n    }\n\n    doClose() {\n        if (this.ws) {\n            this.ws.close();\n        }\n    }\n\n    uri() {\n        const base = `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}`;\n        const pathWithQuery = `${this.path}?${this.queryToString(this.query)}`;\n        return `${base}${pathWithQuery}`;\n    }\n\n    queryToString(query) {\n        return Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n    }\n\n    check() {\n        return this.readyState === 'OPEN';\n    }\n}\n```",
      "```javascript\nclass WS {\n  constructor(opts) {\n    this.secure = opts.secure;\n    this.hostname = opts.hostname;\n    this.port = opts.port;\n    this.path = opts.path;\n    this.query = opts.query;\n    this.timestampParam = opts.timestampParam;\n    this.timestampRequests = opts.timestampRequests;\n    this.readyState = 'CONNECTING';\n    this.ws = null;\n    this.binaryType = opts.binaryType || 'blob';\n    this.perMessageDeflate = opts.perMessageDeflate;\n  }\n\n  doOpen() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.perMessageDeflate);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.readyState = 'OPEN';\n    };\n    this.ws.onmessage = (event) => {\n      // Handle incoming messages\n    };\n    this.ws.onerror = (error) => {\n      // Handle errors\n    };\n    this.ws.onclose = () => {\n      this.readyState = 'CLOSED';\n    };\n  }\n\n  write(packets) {\n    packets.forEach((packet) => {\n      this.ws.send(packet, { binaryType: this.binaryType });\n    });\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const base = `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}`;\n    const pathWithQuery = `${this.path}?${new URLSearchParams(this.query).toString()}`;\n    return `${base}${pathWithQuery}`;\n  }\n\n  check() {\n    return this.readyState === 'OPEN';\n  }\n}\n```",
      "```javascript\nclass WS {\n  constructor(opts) {\n    this.secure = opts.secure;\n    this.hostname = opts.hostname;\n    this.port = opts.port;\n    this.path = opts.path;\n    this.query = opts.query;\n    this.timestampParam = opts.timestampParam;\n    this.timestampRequests = opts.timestampRequests;\n    this.readyState = 'CONNECTING';\n    this.ws = null;\n    this.binaryType = opts.binaryType || 'blob';\n    this.perMessageDeflate = opts.perMessageDeflate;\n  }\n\n  doOpen() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    const url = `${protocol}://${this.hostname}:${this.port}${this.path}?${this.queryStringify(this.query)}`;\n    this.ws = new WebSocket(url, this.perMessageDeflate);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.readyState = 'OPEN';\n    };\n    this.ws.onmessage = (event) => {\n      this.onMessage(event);\n    };\n    this.ws.onerror = (error) => {\n      this.onError(error);\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = 'CLOSED';\n      this.onClose(event);\n    };\n  }\n\n  write(packets) {\n    packets.forEach((packet) => {\n      if (this.timestampRequests) {\n        packet[this.timestampParam] = Date.now();\n      }\n      this.ws.send(packet, { binaryType: this.binaryType });\n    });\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.hostname}:${this.port}${this.path}?${this.queryStringify(this.query)}`;\n  }\n\n  check() {\n    return this.readyState === 'OPEN';\n  }\n\n  queryStringify(query) {\n    return Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n  }\n\n  onMessage(event) {}\n\n  onError(error) {}\n\n  onClose(event) {}\n}\n```",
      "```javascript\nclass WS {\n  constructor(opts) {\n    this.secure = opts.secure;\n    this.hostname = opts.hostname;\n    this.port = opts.port;\n    this.path = opts.path;\n    this.query = opts.query;\n    this.timestampParam = opts.timestampParam;\n    this.timestampRequests = opts.timestampRequests;\n    this.readyState = 'CONNECTING';\n    this.ws = null;\n    this.binaryType = opts.binaryType || 'blob';\n    this.perMessageDeflate = opts.perMessageDeflate;\n  }\n\n  doOpen() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.perMessageDeflate);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.readyState = 'OPEN';\n    };\n    this.ws.onmessage = (event) => {\n      // Handle incoming messages\n    };\n    this.ws.onerror = (error) => {\n      // Handle errors\n    };\n    this.ws.onclose = () => {\n      this.readyState = 'CLOSED';\n    };\n  }\n\n  write(packets) {\n    packets.forEach((packet) => {\n      this.ws.send(packet, { binaryType: this.binaryType });\n    });\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const base = `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}`;\n    const pathWithQuery = `${this.path}?${new URLSearchParams(this.query).toString()}`;\n    return `${base}${pathWithQuery}`;\n  }\n\n  check() {\n    return this.readyState === 'OPEN';\n  }\n}\n```",
      "```javascript\nclass WS {\n  constructor(opts) {\n    this.secure = opts.secure;\n    this.hostname = opts.hostname;\n    this.port = opts.port;\n    this.path = opts.path;\n    this.query = opts.query;\n    this.timestampParam = opts.timestampParam;\n    this.timestampRequests = opts.timestampRequests;\n    this.readyState = 'CONNECTING';\n    this.ws = null;\n    this.binaryType = opts.binaryType || 'blob';\n    this.perMessageDeflate = opts.perMessageDeflate;\n  }\n\n  doOpen() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    const url = `${protocol}://${this.hostname}:${this.port}${this.path}?${this.queryStringify(this.query)}`;\n    this.ws = new WebSocket(url, this.perMessageDeflate);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.readyState = 'OPEN';\n    };\n    this.ws.onmessage = (event) => {\n      // Handle incoming messages\n    };\n    this.ws.onerror = (error) => {\n      // Handle errors\n    };\n    this.ws.onclose = () => {\n      this.readyState = 'CLOSED';\n    };\n  }\n\n  write(packets) {\n    packets.forEach(packet => {\n      const message = this.timestampRequests ? `${this.timestampParam}=${Date.now()};${packet}` : packet;\n      this.ws.send(message, { binaryType: this.binaryType });\n    });\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    return `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}${this.path}?${this.queryStringify(this.query)}`;\n  }\n\n  check() {\n    return this.readyState === 'OPEN';\n  }\n\n  queryStringify(query) {\n    return Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n  }\n}\n```",
      "```javascript\nclass WS {\n    constructor(opts) {\n        this.secure = opts.secure;\n        this.hostname = opts.hostname;\n        this.port = opts.port;\n        this.path = opts.path;\n        this.query = opts.query;\n        this.timestampParam = opts.timestampParam;\n        this.timestampRequests = opts.timestampRequests;\n        this.readyState = 'CONNECTING';\n        this.ws = null;\n        this.binaryType = opts.binaryType || 'blob';\n        this.perMessageDeflate = opts.perMessageDeflate;\n    }\n\n    doOpen() {\n        const protocol = this.secure ? 'wss' : 'ws';\n        const url = `${protocol}://${this.hostname}:${this.port}${this.path}?${this.queryStringify(this.query)}`;\n        this.ws = new WebSocket(url, this.perMessageDeflate);\n        this.addEventListeners();\n    }\n\n    addEventListeners() {\n        this.ws.onopen = () => {\n            this.readyState = 'OPEN';\n        };\n        this.ws.onmessage = (event) => {\n            // Handle incoming messages\n        };\n        this.ws.onerror = (error) => {\n            // Handle errors\n        };\n        this.ws.onclose = () => {\n            this.readyState = 'CLOSED';\n        };\n    }\n\n    write(packets) {\n        packets.forEach(packet => {\n            const message = this.timestampRequests ? `${this.timestampParam}=${Date.now()};${packet}` : packet;\n            this.ws.send(message, { binaryType: this.binaryType });\n        });\n    }\n\n    doClose() {\n        if (this.ws) {\n            this.ws.close();\n        }\n    }\n\n    uri() {\n        return `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}${this.path}?${this.queryStringify(this.query)}`;\n    }\n\n    check() {\n        return this.readyState === 'OPEN';\n    }\n\n    queryStringify(query) {\n        return Object.keys(query).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n    }\n}\n```",
      "```javascript\nclass WS {\n  constructor(opts) {\n    this.secure = opts.secure;\n    this.hostname = opts.hostname;\n    this.port = opts.port;\n    this.path = opts.path;\n    this.query = opts.query;\n    this.timestampParam = opts.timestampParam;\n    this.timestampRequests = opts.timestampRequests;\n    this.readyState = 'CONNECTING';\n    this.ws = null;\n    this.binaryType = opts.binaryType || 'blob';\n    this.perMessageDeflate = opts.perMessageDeflate;\n  }\n\n  doOpen() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.perMessageDeflate);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.readyState = 'OPEN';\n    };\n    this.ws.onmessage = (event) => {\n      // Handle message\n    };\n    this.ws.onerror = (error) => {\n      // Handle error\n    };\n    this.ws.onclose = () => {\n      this.readyState = 'CLOSED';\n    };\n  }\n\n  write(packets) {\n    packets.forEach(packet => {\n      this.ws.send(packet, { binaryType: this.binaryType });\n    });\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const base = `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}`;\n    const pathWithQuery = `${this.path}?${Object.keys(this.query).map(key => `${key}=${encodeURIComponent(this.query[key])}`).join('&)`};\n    return `${base}${pathWithQuery}`;\n  }\n\n  check() {\n    return this.readyState === 'OPEN';\n  }\n}\n```",
      "```javascript\nclass WS {\n    constructor(opts) {\n        this.secure = opts.secure;\n        this.hostname = opts.hostname;\n        this.port = opts.port;\n        this.path = opts.path;\n        this.query = opts.query;\n        this.timestampParam = opts.timestampParam;\n        this.timestampRequests = opts.timestampRequests;\n        this.readyState = 'CONNECTING';\n        this.ws = null;\n        this.binaryType = opts.binaryType || 'blob';\n        this.perMessageDeflate = opts.perMessageDeflate;\n    }\n\n    doOpen() {\n        const protocol = this.secure ? 'wss' : 'ws';\n        const uri = this.uri();\n        this.ws = new WebSocket(uri, this.perMessageDeflate);\n        this.addEventListeners();\n    }\n\n    addEventListeners() {\n        this.ws.onopen = () => {\n            this.readyState = 'OPEN';\n        };\n        this.ws.onmessage = (event) => {\n            // Handle incoming messages\n        };\n        this.ws.onerror = (error) => {\n            // Handle errors\n        };\n        this.ws.onclose = () => {\n            this.readyState = 'CLOSED';\n        };\n    }\n\n    write(packets) {\n        packets.forEach(packet => {\n            this.ws.send(packet, { binaryType: this.binaryType });\n        });\n    }\n\n    doClose() {\n        if (this.ws) {\n            this.ws.close();\n        }\n    }\n\n    uri() {\n        const base = `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}`;\n        const pathWithQuery = `${this.path}?${new URLSearchParams(this.query).toString()}`;\n        return `${base}${pathWithQuery}`;\n    }\n\n    check() {\n        return this.ws && this.readyState === 'OPEN';\n    }\n}\n```",
      "```javascript\nclass WS {\n  constructor(opts) {\n    this.secure = opts.secure;\n    this.hostname = opts.hostname;\n    this.port = opts.port;\n    this.path = opts.path;\n    this.query = opts.query;\n    this.timestampParam = opts.timestampParam;\n    this.timestampRequests = opts.timestampRequests;\n    this.readyState = 'CONNECTING';\n    this.ws = null;\n    this.binaryType = opts.binaryType || 'blob';\n    this.perMessageDeflate = opts.perMessageDeflate;\n  }\n\n  doOpen() {\n    const protocol = this.secure ? 'wss' : 'ws';\n    const uri = this.uri();\n    this.ws = new WebSocket(uri, this.perMessageDeflate);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.readyState = 'OPEN';\n    };\n    this.ws.onmessage = (event) => {\n      // Handle incoming messages\n    };\n    this.ws.onerror = (error) => {\n      // Handle errors\n    };\n    this.ws.onclose = () => {\n      this.readyState = 'CLOSED';\n    };\n  }\n\n  write(packets) {\n    packets.forEach((packet) => {\n      this.ws.send(packet, { binaryType: this.binaryType });\n    });\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const base = `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}`;\n    const pathWithQuery = `${this.path}?${new URLSearchParams(this.query).toString()}`;\n    return `${base}${pathWithQuery}`;\n  }\n\n  check() {\n    return this.ws && this.readyState === 'OPEN';\n  }\n}\n```",
      "```javascript\nclass WS {\n    constructor(opts) {\n        this.secure = opts.secure;\n        this.hostname = opts.hostname;\n        this.port = opts.port;\n        this.path = opts.path;\n        this.query = opts.query;\n        this.timestampParam = opts.timestampParam;\n        this.timestampRequests = opts.timestampRequests;\n        this.readyState = 'CONNECTING';\n        this.ws = null;\n        this.binaryType = opts.binaryType || 'blob';\n        this.perMessageDeflate = opts.perMessageDeflate;\n    }\n\n    doOpen() {\n        const protocol = this.secure ? 'wss' : 'ws';\n        const uri = this.uri();\n        this.ws = new WebSocket(uri, this.perMessageDeflate);\n        this.addEventListeners();\n    }\n\n    addEventListeners() {\n        this.ws.onopen = () => {\n            this.readyState = 'OPEN';\n        };\n        this.ws.onmessage = (event) => {\n            // Handle incoming messages\n        };\n        this.ws.onerror = (error) => {\n            // Handle errors\n        };\n        this.ws.onclose = () => {\n            this.readyState = 'CLOSED';\n        };\n    }\n\n    write(packets) {\n        packets.forEach(packet => {\n            if (this.timestampRequests) {\n                packet[this.timestampParam] = new Date().toISOString();\n            }\n            this.ws.send(packet, { binaryType: this.binaryType });\n        });\n    }\n\n    doClose() {\n        if (this.ws) {\n            this.ws.close();\n        }\n    }\n\n    uri() {\n        const base = `${this.secure ? 'wss' : 'ws'}://${this.hostname}:${this.port}`;\n        const pathWithQuery = `${this.path}?${Object.keys(this.query).map(key => `${key}=${encodeURIComponent(this.query[key])}`).join('&')}`;\n        return `${base}${pathWithQuery}`;\n    }\n\n    check() {\n        return this.readyState === 'OPEN';\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Implement a WebSocket client class for handling real-time communication with a redirect API service, managing connection events, message processing, and various monetization workflows.\n\nClass Description: Workink is a WebSocket client implementation that extends BypassDefinition. It establishes a WebSocket connection to a specified URL, handles different message types from the server, and executes appropriate actions including social media interactions, captcha handling, and monetization processes.\n\nAttributes:\n- websocketUrl: String - The WebSocket server URL to connect to (default: 'wss://redirect-api.work.ink/v1/ws')\n- ws: WebSocket - The active WebSocket connection instance\n- interval: Number - Interval ID for the periodic ping message\n- socials: Array - Stores social media URLs received from the server\n- activeMonetizationTypes: Array - Tracks active monetization methods ('readArticles', 'browserExtension')\n\nMethods:\n- constructor() -> void - Initializes the class instance and inherits from BypassDefinition\n- execute() -> Promise<void> - Main execution method that:\n  1. Creates WebSocket connection\n  2. Sets up event handlers\n  3. Manages message processing workflow\n  4. Handles different server message types including:\n     * s_link_info: Processes social media and monetization data\n     * s_start_recaptcha_check: Initiates captcha process\n     * s_recaptcha_okay: Executes social media and monetization actions\n     * s_monetization: Handles browser extension monetization\n     * s_link_destination: Processes final destination URL",
    "Canonical_solution": "import BypassDefinition from './BypassDefinition.js';\n\nclass Workink extends BypassDefinition {\n    constructor() {\n        super();\n    }\n\n    async execute() {\n        const websocketUrl = 'wss://redirect-api.work.ink/v1/ws';\n        let ws = new WebSocket(websocketUrl);\n        let interval;\n\n        ws.onopen = () => {\n            ws.send(payloads.announce);\n            interval = setInterval(() => ws.send(payloads.ping), 10 * 1000);\n        };\n\n        ws.onmessage = async (e) => {\n            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n            const data = JSON.parse(e.data);\n            if (data.error) return;\n            const payload = data.payload;\n\n            switch (data.type) {\n                case 's_link_info':\n                    if (payload.socials) socials.push(...payload.socials);\n                    const monetizationTypes = ['readArticles', 'browserExtension'];\n                    for (const type of monetizationTypes) {\n                        if (payload.monetizationScript.includes(type)) {\n                            activeMonetizationTypes.push(type);\n                        }\n                    }\n                    break;\n                case 's_start_recaptcha_check':\n                    ws.send(payloads.captcha);\n                    break;\n                case 's_recaptcha_okay':\n                    if (socials.length) {\n                        for (const [index, social] of socials.entries()) {\n                            ws.send(payloads.social(social.url));\n                            await sleep(3 * 1000);\n                        }\n                    }\n\n                    if (activeMonetizationTypes.length) {\n                        for (const type of activeMonetizationTypes) {\n                            switch (type) {\n                                case 'readArticles':\n                                    ws.send(payloads.readArticles['1']);\n                                    ws.send(payloads.readArticles['2']);\n                                    break;\n                                case 'browserExtension':\n                                    if (activeMonetizationTypes.includes('readArticles'))\n                                        await sleep(16 * 1000);\n                                    ws.send(payloads.browserExtension['1']);\n                                    break;\n                            }\n                        }\n                    }\n                    break;\n                case 's_monetization':\n                    if (payload.type !== 'browserExtension') break;\n                    ws.send(payloads.browserExtension['2'](payload.payload.token));\n                    break;\n                case 's_link_destination': {\n                    const url = new URL(payload.url);\n                    if (url.searchParams.has('duf')) {\n                        payload.url = window.atob(\n                            url.searchParams.get('duf').split('').reverse().join('')\n                        );\n                    }\n                    this.helpers.safelyNavigate(payload.url);\n                    break;\n                }\n            }\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport asyncio\nimport websockets\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    async def execute(self):\n        async with websockets.connect(self.websocketUrl) as self.ws:\n            self.ws.on_open = self.on_open\n            self.ws.on_message = self.on_message\n            self.ws.on_close = self.on_close\n            await asyncio.Future()  # Run forever\n\n    def on_open(self):\n        self.interval = asyncio.get_event_loop().call_later(30, self.send_ping)\n\n    def on_message(self, message):\n        data = json.loads(message)\n        if data['type'] == 's_link_info':\n            self.process_social_and_monetization(data['data'])\n        elif data['type'] == 's_start_recaptcha_check':\n            self.start_recaptcha_process()\n        elif data['type'] == 's_recaptcha_okay':\n            self.execute_social_and_monetization_actions()\n        elif data['type'] == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif data['type'] == 's_link_destination':\n            self.process_final_destination_url(data['data'])\n\n    def on_close(self):\n        if self.interval:\n            asyncio.get_event_loop().cancel(self.interval)\n        self.interval = None\n\n    def send_ping(self):\n        self.ws.send(json.dumps({'type': 'ping'}))\n        self.interval = asyncio.get_event_loop().call_later(30, self.send_ping)\n\n    def process_social_and_monetization(self, data):\n        self.socials = data['socials']\n        self.activeMonetizationTypes = data['monetizationTypes']\n\n    def start_recaptcha_process(self):\n        # Implement recaptcha process\n        pass\n\n    def execute_social_and_monetization_actions(self):\n        # Execute social media and monetization actions\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Handle browser extension monetization\n        pass\n\n    def process_final_destination_url(self, data):\n        # Process final destination URL\n        pass\n```",
      "```python\nimport websocket\nimport json\nimport threading\nimport time\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    async def execute(self):\n        self.ws = websocket.WebSocketApp(self.websocketUrl,\n                                         on_open=self.on_open,\n                                         on_message=self.on_message,\n                                         on_error=self.on_error,\n                                         on_close=self.on_close)\n        wst = threading.Thread(target=self.ws.run_forever)\n        wst.start()\n        self.setup_periodic_ping()\n\n    def on_open(self, ws):\n        print(\"Connection opened\")\n\n    def on_message(self, ws, message):\n        data = json.loads(message)\n        message_type = data.get('type')\n        if message_type == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif message_type == 's_start_recaptcha_check':\n            self.start_recaptcha_process()\n        elif message_type == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization_actions()\n        elif message_type == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif message_type == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_error(self, ws, error):\n        print(\"Error: \" + str(error))\n\n    def on_close(self, ws):\n        print(\"### closed ###\")\n\n    def setup_periodic_ping(self):\n        self.interval = threading.Timer(30.0, self.send_ping)\n        self.interval.start()\n\n    def send_ping(self):\n        if self.ws:\n            self.ws.send(json.dumps({'type': 'ping'}))\n        self.interval = threading.Timer(30.0, self.send_ping)\n        self.interval.start()\n\n    def process_social_media_and_monetization(self, data):\n        self.socials = data.get('socials')\n        self.activeMonetizationTypes = data.get('monetizationTypes')\n\n    def start_recaptcha_process(self):\n        # Implement recaptcha handling logic\n        pass\n\n    def execute_social_media_and_monetization_actions(self):\n        # Implement social media and monetization actions\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Implement browser extension monetization logic\n        pass\n\n    def process_final_destination_url(self, data):\n        # Implement final destination URL processing\n        pass\n```",
      "```python\nimport websocket\nimport json\nimport time\nimport threading\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    async def execute(self):\n        self.ws = websocket.WebSocketApp(self.websocketUrl,\n                                         on_open=self.on_open,\n                                         on_message=self.on_message,\n                                         on_error=self.on_error,\n                                         on_close=self.on_close)\n        wst = threading.Thread(target=self.ws.run_forever)\n        wst.daemon = True\n        wst.start()\n\n        while True:\n            await self.send_periodic_ping()\n            time.sleep(10)\n\n    def on_open(self, ws):\n        print(\"Connection opened\")\n\n    def on_message(self, ws, message):\n        data = json.loads(message)\n        if data['type'] == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif data['type'] == 's_start_recaptcha_check':\n            self.start_recaptcha_process()\n        elif data['type'] == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization_actions()\n        elif data['type'] == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif data['type'] == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_error(self, ws, error):\n        print(\"Error: \" + str(error))\n\n    def on_close(self, ws):\n        print(\"Connection closed\")\n\n    def send_periodic_ping(self):\n        if self.interval:\n            self.ws.send(json.dumps({'type': 'ping'}))\n\n    def process_social_media_and_monetization(self, data):\n        self.socials = data['socials']\n        self.activeMonetizationTypes = data['monetizationTypes']\n\n    def start_recaptcha_process(self):\n        # Implement recaptcha handling logic\n        pass\n\n    def execute_social_media_and_monetization_actions(self):\n        # Implement social media and monetization actions\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Implement browser extension monetization\n        pass\n\n    def process_final_destination_url(self, data):\n        # Implement final destination URL processing\n        pass\n```",
      "```python\nimport websocket\nimport json\nimport threading\nimport time\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    async def execute(self):\n        self.ws = websocket.WebSocketApp(self.websocketUrl,\n                                         on_open=self.on_open,\n                                         on_message=self.on_message,\n                                         on_error=self.on_error,\n                                         on_close=self.on_close)\n        wst = threading.Thread(target=self.ws.run_forever)\n        wst.daemon = True\n        wst.start()\n\n        while True:\n            await self.send_ping()\n            time.sleep(30)\n\n    def on_open(self, ws):\n        print(\"Connection opened\")\n\n    def on_message(self, ws, message):\n        data = json.loads(message)\n        if data['type'] == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif data['type'] == 's_start_recaptcha_check':\n            self.start_recaptcha_process()\n        elif data['type'] == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization_actions()\n        elif data['type'] == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif data['type'] == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_error(self, ws, error):\n        print(\"Error: \" + str(error))\n\n    def on_close(self, ws):\n        print(\"Connection closed\")\n\n    async def send_ping(self):\n        if self.ws:\n            self.ws.send(json.dumps({'type': 'ping'}))\n\n    def process_social_media_and_monetization(self, data):\n        self.socials = data['socials']\n        self.activeMonetizationTypes = data['monetizationTypes']\n\n    def start_recaptcha_process(self):\n        # Implement recaptcha process\n        pass\n\n    def execute_social_media_and_monetization_actions(self):\n        # Execute actions based on socials and monetization types\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Handle monetization through browser extension\n        pass\n\n    def process_final_destination_url(self, data):\n        # Process the final destination URL\n        pass\n```",
      "```python\nimport websocket\nimport json\nimport threading\nimport time\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    async def execute(self):\n        self.ws = websocket.WebSocketApp(self.websocketUrl,\n                                         on_open=self.on_open,\n                                         on_message=self.on_message,\n                                         on_error=self.on_error,\n                                         on_close=self.on_close)\n        wst = threading.Thread(target=self.ws.run_forever)\n        wst.daemon = True\n        wst.start()\n        while True:\n            await self.send_ping()\n            time.sleep(30)\n\n    def on_open(self, ws):\n        print(\"Connection opened\")\n\n    def on_message(self, ws, message):\n        data = json.loads(message)\n        if data['type'] == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif data['type'] == 's_start_recaptcha_check':\n            self.initiate_captcha_process()\n        elif data['type'] == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization_actions()\n        elif data['type'] == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif data['type'] == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_error(self, ws, error):\n        print(\"Error: \" + str(error))\n\n    def on_close(self, ws):\n        print(\"Connection closed\")\n\n    async def send_ping(self):\n        self.ws.send(json.dumps({'type': 'ping'}))\n\n    def process_social_media_and_monetization(self, data):\n        self.socials = data['socials']\n        self.activeMonetizationTypes = data['monetizationTypes']\n\n    def initiate_captcha_process(self):\n        # Implement captcha handling logic\n        pass\n\n    def execute_social_media_and_monetization_actions(self):\n        # Implement social media and monetization actions\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Implement browser extension monetization logic\n        pass\n\n    def process_final_destination_url(self, data):\n        # Implement final destination URL processing\n        pass\n```",
      "```python\nimport websocket\nimport json\nimport time\nimport threading\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    async def execute(self):\n        self.ws = websocket.WebSocketApp(self.websocketUrl,\n                                         on_open=self.on_open,\n                                         on_message=self.on_message,\n                                         on_error=self.on_error,\n                                         on_close=self.on_close)\n        self.ws.run_forever()\n\n    def on_open(self, ws):\n        self.interval = threading.Timer(30.0, self.send_ping).start()\n\n    def on_message(self, ws, message):\n        data = json.loads(message)\n        message_type = data.get('type')\n        if message_type == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif message_type == 's_start_recaptcha_check':\n            self.initiate_captcha_process(data)\n        elif message_type == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization(data)\n        elif message_type == 's_monetization':\n            self.handle_browser_extension_monetization(data)\n        elif message_type == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_error(self, ws, error):\n        print(\"Error: \" + str(error))\n\n    def on_close(self, ws):\n        self.interval.cancel()\n\n    def send_ping(self):\n        self.ws.send(json.dumps({'type': 'ping'}))\n        self.interval = threading.Timer(30.0, self.send_ping).start()\n\n    def process_social_media_and_monetization(self, data):\n        # Process social media and monetization data\n        pass\n\n    def initiate_captcha_process(self, data):\n        # Initiate captcha process\n        pass\n\n    def execute_social_media_and_monetization(self, data):\n        # Execute social media and monetization actions\n        pass\n\n    def handle_browser_extension_monetization(self, data):\n        # Handle browser extension monetization\n        pass\n\n    def process_final_destination_url(self, data):\n        # Process final destination URL\n        pass\n```",
      "```python\nimport websocket\nimport json\nimport time\nfrom threading import Thread\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    def execute(self):\n        self.ws = websocket.WebSocketApp(self.websocketUrl,\n                                         on_open=self.on_open,\n                                         on_message=self.on_message,\n                                         on_error=self.on_error,\n                                         on_close=self.on_close)\n        wst = Thread(target=self.ws.run_forever)\n        wst.start()\n\n    def on_open(self, ws):\n        self.interval = self.setInterval(30000, self.send_ping)\n\n    def on_message(self, ws, message):\n        data = json.loads(message)\n        if data['type'] == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif data['type'] == 's_start_recaptcha_check':\n            self.start_recaptcha_process()\n        elif data['type'] == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization_actions()\n        elif data['type'] == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif data['type'] == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_error(self, ws, error):\n        print(\"Error: \" + str(error))\n\n    def on_close(self, ws):\n        print(\"### closed ###\")\n\n    def process_social_media_and_monetization(self, data):\n        self.socials = data['socials']\n        self.activeMonetizationTypes = data['monetizationTypes']\n\n    def start_recaptcha_process(self):\n        # Implement recaptcha process\n        pass\n\n    def execute_social_media_and_monetization_actions(self):\n        # Execute actions based on socials and monetization types\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Handle monetization through browser extension\n        pass\n\n    def process_final_destination_url(self, data):\n        # Process the final destination URL\n        pass\n\n    def send_ping(self):\n        self.ws.send(json.dumps({'type': 'ping'}))\n\n    def setInterval(self, interval, callback):\n        self.interval = time.sleep(interval)\n        callback()\n        self.setInterval(interval, callback)\n```",
      "```python\nimport asyncio\nimport websockets\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    async def execute(self):\n        async with websockets.connect(self.websocketUrl) as self.ws:\n            self.ws.on_open = self.on_open\n            self.ws.on_message = self.on_message\n            self.ws.on_close = self.on_close\n            await asyncio.Future()  # Run forever\n\n    def on_open(self):\n        self.interval = asyncio.get_event_loop().call_later(30, self.send_ping)\n\n    def on_message(self, message):\n        data = json.loads(message)\n        if data['type'] == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif data['type'] == 's_start_recaptcha_check':\n            self.start_recaptcha_process()\n        elif data['type'] == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization_actions()\n        elif data['type'] == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif data['type'] == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_close(self):\n        if self.interval:\n            asyncio.get_event_loop().cancel(self.interval)\n        self.interval = None\n\n    def send_ping(self):\n        self.ws.send(json.dumps({'type': 'ping'}))\n        self.interval = asyncio.get_event_loop().call_later(30, self.send_ping)\n\n    def process_social_media_and_monetization(self, data):\n        self.socials = data['socials']\n        self.activeMonetizationTypes = data['monetizationTypes']\n\n    def start_recaptcha_process(self):\n        # Implement recaptcha handling logic\n        pass\n\n    def execute_social_media_and_monetization_actions(self):\n        # Implement social media and monetization actions\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Implement browser extension monetization logic\n        pass\n\n    def process_final_destination_url(self, data):\n        # Implement final destination URL processing\n        pass\n```",
      "```python\nimport websocket\nimport json\nimport threading\nimport time\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    def execute(self):\n        self.ws = websocket.WebSocketApp(self.websocketUrl,\n                                         on_open=self.on_open,\n                                         on_message=self.on_message,\n                                         on_error=self.on_error,\n                                         on_close=self.on_close)\n        self.ws.run_forever()\n\n    def on_open(self, ws):\n        self.interval = threading.Timer(30, self.ping)\n        self.interval.start()\n\n    def on_message(self, ws, message):\n        data = json.loads(message)\n        if data['type'] == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif data['type'] == 's_start_recaptcha_check':\n            self.start_recaptcha_process()\n        elif data['type'] == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization_actions()\n        elif data['type'] == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif data['type'] == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_error(self, ws, error):\n        print(\"Error: \" + str(error))\n\n    def on_close(self, ws):\n        self.interval.cancel()\n\n    def ping(self):\n        self.ws.send(json.dumps({'type': 'ping'}))\n        self.interval = threading.Timer(30, self.ping)\n        self.interval.start()\n\n    def process_social_media_and_monetization(self, data):\n        self.socials = data['socials']\n        self.activeMonetizationTypes = data['monetizationTypes']\n\n    def start_recaptcha_process(self):\n        # Implement recaptcha process\n        pass\n\n    def execute_social_media_and_monetization_actions(self):\n        # Execute actions based on socials and monetization types\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Handle monetization through browser extension\n        pass\n\n    def process_final_destination_url(self, data):\n        # Process the final destination URL\n        pass\n```",
      "```python\nimport websocket\nimport json\nimport threading\nimport time\n\nclass BypassDefinition:\n    pass\n\nclass Workink(BypassDefinition):\n    def __init__(self):\n        self.websocketUrl = 'wss://redirect-api.work.ink/v1/ws'\n        self.ws = None\n        self.interval = None\n        self.socials = []\n        self.activeMonetizationTypes = ['readArticles', 'browserExtension']\n\n    def execute(self):\n        self.ws = websocket.WebSocketApp(self.websocketUrl,\n                                         on_open=self.on_open,\n                                         on_message=self.on_message,\n                                         on_error=self.on_error,\n                                         on_close=self.on_close)\n        self.ws.run_forever()\n\n    def on_open(self, ws):\n        self.interval = threading.Timer(30.0, self.send_ping).start()\n\n    def on_message(self, ws, message):\n        data = json.loads(message)\n        if data['type'] == 's_link_info':\n            self.process_social_media_and_monetization(data)\n        elif data['type'] == 's_start_recaptcha_check':\n            self.initiate_captcha_process()\n        elif data['type'] == 's_recaptcha_okay':\n            self.execute_social_media_and_monetization_actions()\n        elif data['type'] == 's_monetization':\n            self.handle_browser_extension_monetization()\n        elif data['type'] == 's_link_destination':\n            self.process_final_destination_url(data)\n\n    def on_error(self, ws, error):\n        print(\"Error: \" + str(error))\n\n    def on_close(self, ws):\n        self.interval.cancel()\n\n    def send_ping(self):\n        self.ws.send(json.dumps({'type': 'ping'}))\n        self.interval = threading.Timer(30.0, self.send_ping).start()\n\n    def process_social_media_and_monetization(self, data):\n        self.socials = data['socials']\n        self.activeMonetizationTypes = data['monetizationTypes']\n\n    def initiate_captcha_process(self):\n        # Implement captcha process\n        pass\n\n    def execute_social_media_and_monetization_actions(self):\n        # Execute social media and monetization actions\n        pass\n\n    def handle_browser_extension_monetization(self):\n        # Handle browser extension monetization\n        pass\n\n    def process_final_destination_url(self, data):\n        # Process final destination URL\n        pass\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with reconnection capabilities and event handling.\n\nClass Description: The N class represents a WebSocket client that connects to a specified URL, handles messages, errors, and connection events, and supports automatic reconnection. It provides methods to start, destroy, and manage the WebSocket connection, along with callbacks for connection events.\n\nAttributes:\n- url: [String] - The WebSocket server URL to connect to.\n- options: [Object] - Configuration options for the WebSocket connection, including protocols, reconnect interval, and callbacks.\n- socket: [WebSocket] - The WebSocket connection instance.\n- streaming: [Boolean] - Indicates if the connection is in streaming mode.\n- callbacks: [Object] - Contains arrays of callback functions for connection and data events.\n- destination: [Object] - The destination to write received data to.\n- reconnectInterval: [Number] - The interval (in seconds) between reconnection attempts.\n- shouldAttemptReconnect: [Boolean] - Indicates if reconnection should be attempted.\n- completed: [Boolean] - Indicates if the connection is completed.\n- established: [Boolean] - Indicates if the connection is established.\n- progress: [Number] - Tracks the connection progress.\n- reconnectTimeoutId: [Number] - The timeout ID for reconnection attempts.\n- onEstablishedCallback: [Function] - Callback function triggered when the connection is established.\n- onCompletedCallback: [Function] - Callback function triggered when the connection is completed.\n- hookOnEstablished: [Function] - Optional hook function triggered when the connection is established.\n\nMethods:\n- constructor(url, options) -> [N] - Initializes the WebSocket client with the given URL and options.\n- connect(destination) -> [void] - Sets the destination for received data.\n- destroy() -> [void] - Closes the WebSocket connection and stops reconnection attempts.\n- start() -> [void] - Starts the WebSocket connection and sets up event handlers.\n- resume() -> [void] - Placeholder for resuming the connection (currently empty).\n- onOpen() -> [void] - Handles the WebSocket 'open' event and updates progress.\n- onClose() -> [void] - Handles the WebSocket 'close' and 'error' events and initiates reconnection if enabled.\n- onMessage(event) -> [void] - Handles the WebSocket 'message' event, writes data to the destination, and triggers callbacks.",
    "Canonical_solution": "class N {\n  constructor(A, t) {\n    this.url = A;\n    this.options = t;\n    this.socket = null;\n    this.streaming = !0;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== t.reconnectInterval ? t.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = !1;\n    this.established = !1;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = t.onSourceEstablished;\n    this.onCompletedCallback = t.onSourceCompleted;\n    t.hookOnEstablished && (this.hookOnEstablished = t.hookOnEstablished);\n  }\n\n  connect(A) {\n    this.destination = A;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = !1;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = !1;\n    this.options.protocols\n      ? (this.socket = new WebSocket(this.url, this.options.protocols))\n      : (this.socket = new WebSocket(this.url));\n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    var A = this;\n    this.shouldAttemptReconnect &&\n      (clearTimeout(this.reconnectTimeoutId),\n      (this.reconnectTimeoutId = setTimeout(function () {\n        A.start();\n      }, 1e3 * this.reconnectInterval)));\n  }\n\n  onMessage(A) {\n    var t = !this.established;\n    this.established = !0;\n    t && this.hookOnEstablished && this.hookOnEstablished();\n    t && this.onEstablishedCallback && this.onEstablishedCallback(this);\n    this.destination && this.destination.write(A.data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      onOpen: [],\n      onClose: [],\n      onError: [],\n      onMessage: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5000;\n    this.shouldAttemptReconnect = options.shouldAttemptReconnect || true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablishedCallback;\n    this.onCompletedCallback = options.onCompletedCallback;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n      this.completed = true;\n      this.established = false;\n      clearTimeout(this.reconnectTimeoutId);\n    }\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.onOpen.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose(event) {\n    this.established = false;\n    this.callbacks.onClose.forEach(callback => callback(event));\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n    this.callbacks.onMessage.forEach(callback => callback(event));\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval);\n  }\n}",
      "```javascript\nclass N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {\n            open: [],\n            message: [],\n            close: [],\n            error: []\n        };\n        this.destination = null;\n        this.reconnectInterval = options.reconnectInterval || 5000;\n        this.shouldAttemptReconnect = options.reconnect || true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = options.onEstablished;\n        this.onCompletedCallback = options.onCompleted;\n        this.hookOnEstablished = options.hookOnEstablished;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        if (this.socket) {\n            this.socket.close();\n            this.socket = null;\n            this.completed = true;\n            this.established = false;\n            if (this.reconnectTimeoutId) {\n                clearTimeout(this.reconnectTimeoutId);\n                this.reconnectTimeoutId = null;\n            }\n        }\n    }\n\n    start() {\n        this.socket = new WebSocket(this.url, this.options.protocols);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onError.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.established = true;\n        this.progress = 100;\n        this.callbacks.open.forEach(callback => callback());\n        if (this.onEstablishedCallback) {\n            this.onEstablishedCallback();\n        }\n        if (this.hookOnEstablished) {\n            this.hookOnEstablished();\n        }\n    }\n\n    onClose(event) {\n        this.established = false;\n        this.callbacks.close.forEach(callback => callback(event));\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(event) {\n        if (this.destination) {\n            this.destination.write(event.data);\n        }\n        this.callbacks.message.forEach(callback => callback(event));\n    }\n\n    onError(event) {\n        this.callbacks.error.forEach(callback => callback(event));\n    }\n\n    reconnect() {\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.start();\n        }, this.reconnectInterval);\n    }\n}\n```",
      "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      onOpen: [],\n      onClose: [],\n      onError: [],\n      onMessage: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5000;\n    this.shouldAttemptReconnect = options.shouldAttemptReconnect || true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablishedCallback;\n    this.onCompletedCallback = options.onCompletedCallback;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n      this.completed = true;\n      this.established = false;\n      clearTimeout(this.reconnectTimeoutId);\n    }\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.onOpen.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose(event) {\n    this.established = false;\n    this.callbacks.onClose.forEach(callback => callback(event));\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n    this.callbacks.onMessage.forEach(callback => callback(event));\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval);\n  }\n}",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      open: [],\n      message: [],\n      close: [],\n      error: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5000;\n    this.shouldAttemptReconnect = options.reconnect || true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablished;\n    this.onCompletedCallback = options.onCompleted;\n    this.hookOnEstablished = options.hookOnEstablished;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.completed = true;\n    if (this.socket) {\n      this.socket.close();\n    }\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options.protocols);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.open.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose(event) {\n    this.established = false;\n    this.callbacks.close.forEach(callback => callback(event));\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n    this.callbacks.message.forEach(callback => callback(event));\n  }\n\n  onError(event) {\n    this.callbacks.error.forEach(callback => callback(event));\n  }\n\n  reconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      open: [],\n      message: [],\n      close: [],\n      error: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5000;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablishedCallback || function() {};\n    this.onCompletedCallback = options.onCompletedCallback || function() {};\n    this.hookOnEstablished = options.hookOnEstablished || function() {};\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n      this.completed = true;\n      this.established = false;\n      clearTimeout(this.reconnectTimeoutId);\n    }\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options.protocols);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.open.forEach(callback => callback());\n    this.onEstablishedCallback();\n    this.hookOnEstablished();\n  }\n\n  onClose(event) {\n    this.established = false;\n    this.callbacks.close.forEach(callback => callback(event));\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n    this.callbacks.message.forEach(callback => callback(event));\n  }\n\n  onError(event) {\n    this.callbacks.error.forEach(callback => callback(event));\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval);\n  }\n}\n```",
      "```javascript\nclass N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {\n            open: [],\n            message: [],\n            close: [],\n            error: []\n        };\n        this.destination = null;\n        this.reconnectInterval = options.reconnectInterval || 5000;\n        this.shouldAttemptReconnect = options.shouldAttemptReconnect || true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = options.onEstablishedCallback;\n        this.onCompletedCallback = options.onCompletedCallback;\n        this.hookOnEstablished = options.hookOnEstablished;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        this.completed = true;\n        if (this.socket) {\n            this.socket.close();\n        }\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n    }\n\n    start() {\n        this.socket = new WebSocket(this.url, this.options.protocols);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onError.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.established = true;\n        this.progress = 100;\n        this.callbacks.open.forEach(callback => callback());\n        if (this.onEstablishedCallback) {\n            this.onEstablishedCallback();\n        }\n        if (this.hookOnEstablished) {\n            this.hookOnEstablished();\n        }\n    }\n\n    onClose(event) {\n        this.established = false;\n        this.callbacks.close.forEach(callback => callback(event));\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(event) {\n        if (this.destination) {\n            this.destination.write(event.data);\n        }\n        this.callbacks.message.forEach(callback => callback(event));\n    }\n\n    onError(event) {\n        this.callbacks.error.forEach(callback => callback(event));\n    }\n\n    reconnect() {\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n        this.reconnectTimeoutId = setTimeout(() => {\n            if (!this.completed) {\n                this.start();\n            }\n        }, this.reconnectInterval);\n    }\n}\n```",
      "```javascript\nclass N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {\n            open: [],\n            message: [],\n            close: [],\n            error: []\n        };\n        this.destination = null;\n        this.reconnectInterval = options.reconnectInterval || 5000;\n        this.shouldAttemptReconnect = options.reconnect || true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = options.onEstablished;\n        this.onCompletedCallback = options.onCompleted;\n        this.hookOnEstablished = options.hookOnEstablished;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        this.completed = true;\n        if (this.socket) {\n            this.socket.close();\n        }\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n    }\n\n    start() {\n        this.socket = new WebSocket(this.url, this.options.protocols);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onError.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.established = true;\n        this.progress = 100;\n        this.callbacks.open.forEach(callback => callback());\n        if (this.onEstablishedCallback) {\n            this.onEstablishedCallback();\n        }\n        if (this.hookOnEstablished) {\n            this.hookOnEstablished();\n        }\n    }\n\n    onClose(event) {\n        this.established = false;\n        this.callbacks.close.forEach(callback => callback(event));\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(event) {\n        if (this.destination) {\n            this.destination.write(event.data);\n        }\n        this.callbacks.message.forEach(callback => callback(event));\n    }\n\n    onError(event) {\n        this.callbacks.error.forEach(callback => callback(event));\n    }\n\n    reconnect() {\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n        this.reconnectTimeoutId = setTimeout(() => {\n            if (!this.completed) {\n                this.start();\n            }\n        }, this.reconnectInterval);\n    }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {\n      open: [],\n      message: [],\n      close: [],\n      error: []\n    };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5000;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = options.onEstablishedCallback || function() {};\n    this.onCompletedCallback = options.onCompletedCallback || function() {};\n    this.hookOnEstablished = options.hookOnEstablished || function() {};\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.completed = true;\n    if (this.socket) {\n      this.socket.close();\n    }\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 100;\n    this.callbacks.open.forEach(callback => callback());\n    this.onEstablishedCallback();\n    this.hookOnEstablished();\n  }\n\n  onClose(event) {\n    this.established = false;\n    this.callbacks.close.forEach(callback => callback(event));\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n    this.callbacks.message.forEach(callback => callback(event));\n  }\n\n  onError(event) {\n    this.callbacks.error.forEach(callback => callback(event));\n  }\n\n  reconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval);\n  }\n}\n```",
      "class N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {\n            open: [],\n            message: [],\n            close: [],\n            error: []\n        };\n        this.destination = null;\n        this.reconnectInterval = options.reconnectInterval || 5000;\n        this.shouldAttemptReconnect = options.reconnect || true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = options.onEstablished;\n        this.onCompletedCallback = options.onCompleted;\n        this.hookOnEstablished = options.hookOnEstablished;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        this.completed = true;\n        if (this.socket) {\n            this.socket.close();\n        }\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n    }\n\n    start() {\n        this.socket = new WebSocket(this.url, this.options.protocols);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onClose.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.established = true;\n        this.progress = 100;\n        this.callbacks.open.forEach(callback => callback());\n        if (this.onEstablishedCallback) {\n            this.onEstablishedCallback();\n        }\n        if (this.hookOnEstablished) {\n            this.hookOnEstablished();\n        }\n    }\n\n    onClose(event) {\n        this.established = false;\n        this.callbacks.close.forEach(callback => callback(event));\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(event) {\n        if (this.destination) {\n            this.destination.write(event.data);\n        }\n        this.callbacks.message.forEach(callback => callback(event));\n    }\n\n    reconnect() {\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n        this.reconnectTimeoutId = setTimeout(() => {\n            if (!this.completed) {\n                this.start();\n            }\n        }, this.reconnectInterval);\n    }\n}",
      "class N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {\n            open: [],\n            message: [],\n            close: [],\n            error: []\n        };\n        this.destination = null;\n        this.reconnectInterval = options.reconnectInterval || 5000;\n        this.shouldAttemptReconnect = options.reconnect || true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = options.onEstablished;\n        this.onCompletedCallback = options.onCompleted;\n        this.hookOnEstablished = options.hookOnEstablished;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        if (this.socket) {\n            this.socket.close();\n            this.shouldAttemptReconnect = false;\n            this.completed = true;\n            this.established = false;\n            clearTimeout(this.reconnectTimeoutId);\n        }\n    }\n\n    start() {\n        this.socket = new WebSocket(this.url, this.options.protocols);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onError.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.established = true;\n        this.progress = 100;\n        this.callbacks.open.forEach(callback => callback());\n        if (this.onEstablishedCallback) {\n            this.onEstablishedCallback();\n        }\n        if (this.hookOnEstablished) {\n            this.hookOnEstablished();\n        }\n    }\n\n    onClose(event) {\n        this.established = false;\n        this.callbacks.close.forEach(callback => callback(event));\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(event) {\n        if (this.destination) {\n            this.destination.write(event.data);\n        }\n        this.callbacks.message.forEach(callback => callback(event));\n    }\n\n    onError(event) {\n        this.callbacks.error.forEach(callback => callback(event));\n    }\n\n    reconnect() {\n        clearTimeout(this.reconnectTimeoutId);\n        this.reconnectTimeoutId = setTimeout(() => {\n            if (!this.completed) {\n                this.start();\n            }\n        }, this.reconnectInterval);\n    }\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a server, sends a message, and handles incoming messages.\n\nFunction Description: The function `echo` creates a WebSocket connection to a specified URI, sends a message from an input field upon successful connection, and logs received messages. It also provides visual feedback for connection status and message exchange.\n\nInput: \n- None (implicitly uses `myField.value` from the DOM as the message to send)\n- The WebSocket URI is constructed from the current document's host and path\n\nOutput: \n- No direct return value\n- Side effects:\n  - Logs connection status to console\n  - Writes connection status to screen\n  - Sends message from input field\n  - Writes sent message to screen\n  - Writes received messages to screen",
    "Canonical_solution": "function echo() {\n    var wsUri = \"ws://\" + document.location.host + document.location.pathname + \"websocket\";\n    console.log(\"Connecting to \" + wsUri);\n    var websocket = new WebSocket(wsUri);\n    websocket.onopen = function() { \n        writeToScreen(\"CONNECTED\");\n        websocket.send(myField.value);\n        writeToScreen(\"SENT: \" + myField.value);\n    };\n    websocket.onmessage = function(evt) { \n        writeToScreen(\"RECEIVED: \" + evt.data); \n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction echo() {\n  const wsUri = 'ws://' + window.location.host + window.location.pathname;\n  const ws = new WebSocket(wsUri);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    document.getElementById('status').textContent = 'Connected';\n    const myField = document.getElementById('myField');\n    ws.send(myField.value);\n    document.getElementById('message').textContent = 'Message sent: ' + myField.value;\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received: ' + event.data);\n    document.getElementById('message').textContent = 'Message received: ' + event.data;\n  };\n\n  ws.onclose = function() {\n    console.log('WebSocket connection closed');\n    document.getElementById('status').textContent = 'Disconnected';\n  };\n\n  ws.onerror = function(error) {\n    console.log('WebSocket error: ' + error);\n    document.getElementById('status').textContent = 'Error';\n  };\n}\n```",
      "```javascript\nfunction echo() {\n  const wsUri = 'ws://' + window.location.host + window.location.pathname;\n  const ws = new WebSocket(wsUri);\n\n  ws.onopen = function(event) {\n    console.log('Connection established');\n    document.getElementById('status').textContent = 'Connected';\n    const myField = document.getElementById('myField');\n    ws.send(myField.value);\n    document.getElementById('message').textContent = 'Message sent: ' + myField.value;\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received: ' + event.data);\n    document.getElementById('message').textContent = 'Message received: ' + event.data;\n  };\n\n  ws.onclose = function(event) {\n    console.log('Connection closed');\n    document.getElementById('status').textContent = 'Disconnected';\n  };\n\n  ws.onerror = function(event) {\n    console.log('Error occurred');\n    document.getElementById('status').textContent = 'Error';\n  };\n}\n```",
      "```javascript\nfunction echo() {\n    const wsUri = 'ws://' + window.location.host + window.location.pathname;\n    const ws = new WebSocket(wsUri);\n\n    ws.onopen = function() {\n        console.log('WebSocket connection established');\n        document.getElementById('status').textContent = 'Connected';\n        const myField = document.getElementById('myField');\n        ws.send(myField.value);\n        document.getElementById('message').textContent = 'Message sent: ' + myField.value;\n    };\n\n    ws.onmessage = function(event) {\n        console.log('Message received: ' + event.data);\n        document.getElementById('message').textContent = 'Message received: ' + event.data;\n    };\n\n    ws.onclose = function() {\n        console.log('WebSocket connection closed');\n        document.getElementById('status').textContent = 'Disconnected';\n    };\n\n    ws.onerror = function(error) {\n        console.log('WebSocket error: ' + error);\n        document.getElementById('status').textContent = 'Error';\n    };\n}\n```",
      "```javascript\nfunction echo() {\n  const wsUri = 'ws://' + window.location.host + window.location.pathname;\n  const ws = new WebSocket(wsUri);\n\n  ws.onopen = function(event) {\n    console.log('Connection established');\n    document.getElementById('status').innerText = 'Connected';\n    const myField = document.getElementById('myField');\n    ws.send(myField.value);\n    document.getElementById('message').innerText = 'Message sent: ' + myField.value;\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received: ' + event.data);\n    document.getElementById('message').innerText += '\\nReceived: ' + event.data;\n  };\n\n  ws.onclose = function(event) {\n    console.log('Connection closed');\n    document.getElementById('status').innerText = 'Disconnected';\n  };\n\n  ws.onerror = function(event) {\n    console.log('Error occurred');\n    document.getElementById('status').innerText = 'Error';\n  };\n}\n```",
      "```javascript\nfunction echo() {\n  const wsUri = 'ws://' + window.location.host + window.location.pathname;\n  const ws = new WebSocket(wsUri);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    document.getElementById('status').innerText = 'Connected';\n    const myField = document.getElementById('myField');\n    ws.send(myField.value);\n    document.getElementById('message').innerText = 'Message sent: ' + myField.value;\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received: ' + event.data);\n    document.getElementById('message').innerText += '\\nReceived: ' + event.data;\n  };\n\n  ws.onclose = function() {\n    console.log('WebSocket connection closed');\n    document.getElementById('status').innerText = 'Disconnected';\n  };\n\n  ws.onerror = function(error) {\n    console.log('WebSocket error: ' + error);\n    document.getElementById('status').innerText = 'Error';\n  };\n}\n```",
      "```javascript\nfunction echo() {\n    const wsUri = 'ws://' + window.location.host + window.location.pathname;\n    const ws = new WebSocket(wsUri);\n\n    ws.onopen = function() {\n        console.log('WebSocket connection established');\n        document.getElementById('status').innerText = 'Connected';\n        const myField = document.getElementById('myField');\n        ws.send(myField.value);\n        document.getElementById('message').innerText = 'Message sent: ' + myField.value;\n    };\n\n    ws.onmessage = function(event) {\n        console.log('Message received: ' + event.data);\n        document.getElementById('message').innerText += '\\nReceived: ' + event.data;\n    };\n\n    ws.onclose = function() {\n        console.log('WebSocket connection closed');\n        document.getElementById('status').innerText = 'Disconnected';\n    };\n\n    ws.onerror = function(error) {\n        console.log('WebSocket error: ' + error);\n        document.getElementById('status').innerText = 'Error';\n    };\n}\n```",
      "```javascript\nfunction echo() {\n  const wsUri = 'ws://' + window.location.host + window.location.pathname;\n  const ws = new WebSocket(wsUri);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    document.getElementById('status').innerText = 'Connected';\n    const myField = document.getElementById('myField');\n    ws.send(myField.value);\n    document.getElementById('message').innerText = 'Message sent: ' + myField.value;\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received: ' + event.data);\n    document.getElementById('message').innerText = 'Message received: ' + event.data;\n  };\n\n  ws.onclose = function() {\n    console.log('WebSocket connection closed');\n    document.getElementById('status').innerText = 'Disconnected';\n  };\n\n  ws.onerror = function(error) {\n    console.log('WebSocket error: ' + error);\n    document.getElementById('status').innerText = 'Error';\n  };\n}\n```",
      "```javascript\nfunction echo() {\n    const wsUri = 'ws://' + window.location.host + window.location.pathname;\n    const ws = new WebSocket(wsUri);\n\n    ws.onopen = function() {\n        console.log('WebSocket connection established');\n        document.getElementById('status').textContent = 'Connected';\n        const myField = document.getElementById('myField');\n        ws.send(myField.value);\n        document.getElementById('message').textContent = 'Message sent: ' + myField.value;\n    };\n\n    ws.onmessage = function(event) {\n        console.log('Message received: ' + event.data);\n        document.getElementById('message').textContent = 'Message received: ' + event.data;\n    };\n\n    ws.onclose = function() {\n        console.log('WebSocket connection closed');\n        document.getElementById('status').textContent = 'Disconnected';\n    };\n\n    ws.onerror = function(error) {\n        console.log('WebSocket error: ' + error);\n        document.getElementById('status').textContent = 'Error';\n    };\n}\n```",
      "```javascript\nfunction echo() {\n  const wsUri = 'ws://' + window.location.host + window.location.pathname;\n  const ws = new WebSocket(wsUri);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    document.getElementById('status').innerText = 'Connected';\n    const myField = document.getElementById('myField');\n    ws.send(myField.value);\n    document.getElementById('message').innerText = 'Message sent: ' + myField.value;\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received: ' + event.data);\n    document.getElementById('message').innerText += '\\nReceived: ' + event.data;\n  };\n\n  ws.onclose = function() {\n    console.log('WebSocket connection closed');\n    document.getElementById('status').innerText = 'Disconnected';\n  };\n\n  ws.onerror = function(error) {\n    console.log('WebSocket error: ' + error);\n    document.getElementById('status').innerText = 'Error';\n  };\n}\n```",
      "```javascript\nfunction echo() {\n    const wsUri = 'ws://' + window.location.host + window.location.pathname;\n    const ws = new WebSocket(wsUri);\n\n    ws.onopen = function() {\n        console.log('WebSocket connection established');\n        document.getElementById('status').textContent = 'Connected';\n        const myField = document.getElementById('myField');\n        ws.send(myField.value);\n        document.getElementById('message').textContent = 'Message sent: ' + myField.value;\n    };\n\n    ws.onmessage = function(event) {\n        console.log('Message received: ' + event.data);\n        document.getElementById('message').textContent = 'Message received: ' + event.data;\n    };\n\n    ws.onclose = function() {\n        console.log('WebSocket connection closed');\n        document.getElementById('status').textContent = 'Disconnected';\n    };\n\n    ws.onerror = function(error) {\n        console.log('WebSocket error: ' + error);\n        document.getElementById('status').textContent = 'Error';\n    };\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a specified path on a server and returns the WebSocket object if the connection is successfully opened.\n\nFunction Description: The function `apiWebSocket` attempts to create a WebSocket connection to a given path on a secure WebSocket server. It waits for the connection to be established or fail (due to error or closure) and returns the WebSocket object only if the connection is successfully opened. If the connection fails or an error occurs, the function returns `undefined`.\n\nInput: \n- `path` (string): The path on the server to which the WebSocket connection should be established. This is appended to the base URL `wss://services.bonjourr.fr/`.\n\nOutput: \n- `Promise<WebSocket | undefined>`: A promise that resolves to the WebSocket object if the connection is successfully opened, or `undefined` if the connection fails or an error occurs.",
    "Canonical_solution": "export async function apiWebSocket(path: string): Promise<WebSocket | undefined> {\n\ttry {\n\t\tconst socket = new WebSocket(`wss://services.bonjourr.fr/${path}`)\n\t\tconst isOpened = await new Promise((resolve) => {\n\t\t\tsocket.onopen = () => resolve(true)\n\t\t\tsocket.onerror = () => resolve(false)\n\t\t\tsocket.onclose = () => resolve(false)\n\t\t})\n\n\t\tif (isOpened) {\n\t\t\treturn socket\n\t\t}\n\t} catch (_error) {\n\t\t// ...\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = reject;\n    ws.onclose = () => reject();\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = () => reject();\n    ws.onclose = () => reject();\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = reject;\n    ws.onclose = () => reject();\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = () => reject();\n    ws.onclose = () => reject();\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = () => reject(undefined);\n    ws.onclose = () => reject(undefined);\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = reject;\n    ws.onclose = () => reject();\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = () => reject();\n    ws.onclose = () => reject();\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = () => reject();\n    ws.onclose = () => reject();\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = () => reject(undefined);\n    ws.onclose = () => reject(undefined);\n  });\n}\n```",
      "```javascript\nfunction apiWebSocket(path) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(`wss://services.bonjourr.fr/${path}`);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = () => reject(undefined);\n    ws.onclose = () => reject(undefined);\n  });\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 227,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that connects to a server to receive and display image data in real-time on an HTML canvas element. The client should handle connection events, process incoming image messages, and properly manage resources.\n\nFunction Description: The `loadLiveScreen` function establishes a WebSocket connection to a specified server, listens for incoming image data (JPEG format), and renders each received image onto a canvas element. It handles connection events, processes binary image data, manages memory by cleaning up resources, and adjusts the canvas size to match incoming images.\n\nInput: None (The function uses hardcoded WebSocket URL and accesses DOM elements directly)\n\nOutput: None (The function's side effects are rendering images to canvas and logging connection status)\n\nNote: The function relies on these external elements:\n1. A canvas element with ID 'bgCanvas' must exist in the DOM\n2. The function assumes the existence of an `imagePool` object with a `next()` method\n3. The function assumes the existence of a `resizeScreen` method on the containing object",
    "Canonical_solution": "function loadLiveScreen() {\n    var self = this;\n    var BLANK_IMG = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n    var ws = new WebSocket('ws://10.240.184.233:9002');\n    var canvas = document.getElementById('bgCanvas');\n    var ctx = canvas.getContext('2d');\n\n    ws.onopen = function(ev) {\n        console.log('screen websocket connected');\n    };\n    ws.onmessage = function(message) {\n        console.log(\"New message\");\n        var blob = new Blob([message.data], {\n            type: 'image/jpeg'\n        });\n        var img = self.imagePool.next();\n        img.onload = function() {\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, img.width, img.height);\n            self.resizeScreen(img);\n\n            img.onload = img.onerror = null;\n            img.src = BLANK_IMG;\n            img = null;\n            blob = null;\n\n            URL.revokeObjectURL(url);\n            url = null;\n        };\n\n        img.onerror = function() {\n            img.onload = img.onerror = null;\n            img.src = BLANK_IMG;\n            img = null;\n            blob = null;\n\n            URL.revokeObjectURL(url);\n            url = null;\n        };\n        var url = URL.createObjectURL(blob);\n        img.src = url;\n    };\n\n    ws.onclose = function(ev) {\n        console.log(\"screen websocket closed\");\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst loadLiveScreen = () => {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/live');\n  const imagePool = {\n    next: () => {\n      // Placeholder for image pool logic\n      return new Promise(resolve => resolve(new Image()));\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = async (event) => {\n    const image = await imagePool.next();\n    image.src = `data:image/jpeg;base64,${event.data}`;\n    image.onload = () => {\n      canvas.width = image.width;\n      canvas.height = image.height;\n      canvas.getContext('2d').drawImage(image, 0, 0);\n    };\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n};\n\nloadLiveScreen();\n```",
      "```javascript\nconst loadLiveScreen = () => {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/live');\n  const imagePool = {\n    next: () => {\n      // Implementation of image pool logic\n    }\n  };\n  const resizeScreen = () => {\n    // Implementation of resize logic\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const img = new Image();\n      img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        canvas.getContext('2d').drawImage(img, 0, 0);\n      };\n      img.src = reader.result;\n    };\n    reader.readAsDataURL(event.data);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  resizeScreen();\n};\n\nloadLiveScreen();\n```",
      "```javascript\nfunction loadLiveScreen() {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/live');\n  const imagePool = {\n    next: function() {\n      // Implementation of the next method\n    }\n  };\n  const resizeScreen = function() {\n    // Implementation of the resizeScreen method\n  };\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = function(event) {\n    if (event.data instanceof Blob) {\n      const reader = new FileReader();\n      reader.onload = function(e) {\n        const img = new Image();\n        img.onload = function() {\n          canvas.width = img.width;\n          canvas.height = img.height;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n        };\n        img.src = e.target.result;\n      };\n      reader.readAsDataURL(event.data);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function() {\n    console.log('WebSocket connection closed');\n  };\n\n  resizeScreen();\n}\n```",
      "```javascript\nconst loadLiveScreen = () => {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/live');\n  let imagePool = null;\n  let resizeScreen = null;\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const img = new Image();\n      img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        canvas.getContext('2d').drawImage(img, 0, 0);\n        imagePool.next();\n      };\n      img.src = reader.result;\n    };\n    reader.readAsDataURL(event.data);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n};\n\nloadLiveScreen();\n```",
      "```javascript\nconst loadLiveScreen = () => {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/live');\n  const imagePool = {\n    next: () => {\n      // Implementation of image pool logic\n    }\n  };\n  const resizeScreen = () => {\n    // Implementation of resize logic\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const img = new Image();\n      img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        canvas.getContext('2d').drawImage(img, 0, 0);\n        imagePool.next(); // Clean up image resource\n      };\n      img.src = reader.result;\n    };\n    reader.readAsDataURL(event.data);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n};\n\nloadLiveScreen();\n```",
      "```javascript\nconst loadLiveScreen = () => {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/live');\n  const imagePool = {\n    next: () => {}\n  };\n  const resizeScreen = () => {};\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const img = new Image();\n      img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        canvas.getContext('2d').drawImage(img, 0, 0);\n        resizeScreen();\n      };\n      img.src = reader.result;\n    };\n    reader.readAsDataURL(event.data);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n};\n\nloadLiveScreen();\n```",
      "```javascript\nconst loadLiveScreen = () => {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/live');\n  const imagePool = {\n    next: () => new Image()\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    const image = imagePool.next();\n    image.onload = () => {\n      canvas.width = image.width;\n      canvas.height = image.height;\n      canvas.getContext('2d').drawImage(image, 0, 0);\n    };\n    image.src = `data:image/jpeg;base64,${event.data}`;\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n};\n\nloadLiveScreen();\n```",
      "```javascript\nfunction loadLiveScreen() {\n    const canvas = document.getElementById('bgCanvas');\n    const ws = new WebSocket('wss://example.com/stream');\n    const imagePool = {\n        next: function() {\n            // Implementation for getting next image\n        }\n    };\n    const resizeScreen = function() {\n        // Implementation for resizing screen\n    };\n\n    ws.onopen = function() {\n        console.log('WebSocket connection established');\n    };\n\n    ws.onmessage = function(event) {\n        const reader = new FileReader();\n        reader.onloadend = function() {\n            const img = new Image();\n            img.onload = function() {\n                canvas.width = img.width;\n                canvas.height = img.height;\n                canvas.getContext('2d').drawImage(img, 0, 0);\n            };\n            img.src = reader.result;\n        };\n        reader.readAsDataURL(event.data);\n    };\n\n    ws.onclose = function() {\n        console.log('WebSocket connection closed');\n    };\n\n    ws.onerror = function(error) {\n        console.error('WebSocket error:', error);\n    };\n\n    resizeScreen();\n}\n\nloadLiveScreen();\n```",
      "```javascript\nconst loadLiveScreen = () => {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/stream');\n  let imagePool = {\n    next: () => {}\n  };\n  let resizeScreen = () => {};\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const img = new Image();\n      img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        canvas.getContext('2d').drawImage(img, 0, 0);\n        imagePool.next();\n      };\n      img.src = reader.result;\n    };\n    reader.readAsDataURL(event.data);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  resizeScreen = () => {\n    const newWidth = window.innerWidth;\n    const newHeight = window.innerHeight;\n    canvas.width = newWidth;\n    canvas.height = newHeight;\n  };\n\n  window.addEventListener('resize', resizeScreen);\n};\n```",
      "```javascript\nfunction loadLiveScreen() {\n  const canvas = document.getElementById('bgCanvas');\n  const ws = new WebSocket('wss://example.com/live');\n  let imagePool = {\n    next: function() {\n      // Implementation of next method\n    }\n  };\n  let resizeScreen = function() {\n    // Implementation of resizeScreen method\n  };\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = function(event) {\n    if (event.data instanceof Blob) {\n      const reader = new FileReader();\n      reader.onload = function(e) {\n        const img = new Image();\n        img.onload = function() {\n          canvas.width = img.width;\n          canvas.height = img.height;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n          resizeScreen();\n        };\n        img.src = e.target.result;\n      };\n      reader.readAsDataURL(event.data);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function() {\n    console.log('WebSocket connection closed');\n  };\n\n  imagePool.next();\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Implement a WebSocket client with automatic reconnection capabilities for robust browser-based communication. The solution should handle connection drops, implement exponential backoff for reconnection attempts, and provide event-based notification of connection states.\n\nClass Description: ReconnectingWebSocket is a WebSocket wrapper class that automatically reconnects when the connection is lost, with configurable reconnection timing and event handling. It maintains connection state and provides standard WebSocket-like interface.\n\nAttributes:\n- url: [String] - The WebSocket server URL to connect to\n- protocols: [Array/String] - Optional subprotocols for WebSocket\n- debug: [Boolean] - Whether to enable debug logging (default: false)\n- automaticOpen: [Boolean] - Whether to automatically open connection (default: true)\n- reconnectInterval: [Number] - Initial delay before reconnection in ms (default: 1000)\n- maxReconnectInterval: [Number] - Maximum delay between reconnections in ms (default: 30000)\n- reconnectDecay: [Number] - Multiplier for reconnection delay (default: 1.5)\n- timeoutInterval: [Number] - Connection timeout in ms (default: 2000)\n- reconnectAttempts: [Number] - Count of reconnection attempts\n- readyState: [Number] - Current connection state (matching WebSocket constants)\n- protocol: [String] - Selected subprotocol (set after connection)\n\nMethods:\n- constructor(url, protocols, options) -> [ReconnectingWebSocket] - Initializes new instance with connection parameters and options\n- addEventListener(type, listener) -> [void] - Adds event listener for connection events\n- removeEventListener(type, listener) -> [void] - Removes event listener\n- dispatchEvent(event) -> [void] - Triggers event handlers\n- open(reconnecting) -> [void] - Opens WebSocket connection (internal use)\n- send(data) -> [void] - Sends data through WebSocket connection\n- close(code, reason) -> [void] - Closes connection (no automatic reconnection)\n- refresh() -> [void] - Forces reconnection by closing current connection\n- onopen() -> [void] - Placeholder for open event handler\n- onclose() -> [void] - Placeholder for close event handler\n- onconnecting() -> [void] - Placeholder for connecting event handler\n- onmessage() -> [void] - Placeholder for message event handler\n- onerror() -> [void] - Placeholder for error event handler",
    "Canonical_solution": "class ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    const defaults = {\n      debug: false,\n      automaticOpen: true,\n      reconnectInterval: 1000,\n      maxReconnectInterval: 30000,\n      reconnectDecay: 1.5,\n      timeoutInterval: 2000\n    };\n    \n    options = options || {};\n    for (let key in defaults) {\n      this[key] = typeof options[key] !== 'undefined' ? options[key] : defaults[key];\n    }\n\n    this.url = url;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = null;\n\n    let forcedClose = false;\n    let timedOut = false;\n    let eventTarget = document.createElement('div');\n\n    this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n    this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n    this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n    this.open = function(reconnecting) {\n      let ws = new WebSocket(this.url, protocols || []);\n      if (!reconnecting) {\n        this.dispatchEvent(new Event('connecting'));\n      }\n\n      let timeout = setTimeout(() => {\n        timedOut = true;\n        ws.close();\n        timedOut = false;\n      }, this.timeoutInterval);\n\n      ws.onopen = () => {\n        clearTimeout(timeout);\n        this.protocol = ws.protocol;\n        this.readyState = WebSocket.OPEN;\n        this.reconnectAttempts = 0;\n        let event = new Event('open');\n        event.isReconnect = reconnecting;\n        this.dispatchEvent(event);\n      };\n\n      ws.onclose = (event) => {\n        clearTimeout(timeout);\n        ws = null;\n        if (forcedClose) {\n          this.readyState = WebSocket.CLOSED;\n          this.dispatchEvent(new Event('close'));\n        } else {\n          this.readyState = WebSocket.CONNECTING;\n          let connectingEvent = new Event('connecting');\n          Object.assign(connectingEvent, {\n            code: event.code,\n            reason: event.reason,\n            wasClean: event.wasClean\n          });\n          this.dispatchEvent(connectingEvent);\n\n          if (!reconnecting && !timedOut) {\n            this.dispatchEvent(new Event('close'));\n          }\n\n          let timeout = this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts);\n          setTimeout(() => {\n            this.reconnectAttempts++;\n            this.open(true);\n          }, Math.min(timeout, this.maxReconnectInterval));\n        }\n      };\n\n      ws.onmessage = (event) => {\n        let messageEvent = new Event('message');\n        messageEvent.data = event.data;\n        this.dispatchEvent(messageEvent);\n      };\n\n      ws.onerror = (event) => {\n        this.dispatchEvent(new Event('error'));\n      };\n    };\n\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n\n    this.send = function(data) {\n      if (ws) {\n        return ws.send(data);\n      }\n      throw new Error('INVALID_STATE_ERR : Pausing to reconnect websocket');\n    };\n\n    this.close = function(code, reason) {\n      forcedClose = true;\n      if (ws) {\n        ws.close(code || 1000, reason);\n      }\n    };\n\n    this.refresh = function() {\n      if (ws) {\n        ws.close();\n      }\n    };\n  }\n\n  onopen() {}\n  onclose() {}\n  onconnecting() {}\n  onmessage() {}\n  onerror() {}\n}\n\nReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\nReconnectingWebSocket.OPEN = WebSocket.OPEN;\nReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\nReconnectingWebSocket.CLOSED = WebSocket.CLOSED;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.url = url;\n    this.protocols = protocols;\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || true;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 2000;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.listeners = {};\n    this.connect();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.listeners[type]) {\n      const index = this.listeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.listeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.listeners[event.type]) {\n      this.listeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(reconnecting) {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.binaryType = 'blob';\n    this.ws.onopen = () => {\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this.ws.protocol;\n      this.reconnectAttempts = 0;\n      this.dispatchEvent(new Event('open'));\n      this.dispatchEvent(new Event('onopen'));\n      if (reconnecting) {\n        this.dispatchEvent(new Event('connecting'));\n      }\n    };\n    this.ws.onclose = event => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent(new Event('close'));\n      this.dispatchEvent(new Event('onclose'));\n      if (this.automaticOpen) {\n        this.reconnect();\n      }\n    };\n    this.ws.onmessage = event => {\n      this.dispatchEvent(new Event('message'));\n      this.dispatchEvent(new Event('onmessage'), event);\n    };\n    this.ws.onerror = event => {\n      this.dispatchEvent(new Event('error'));\n      this.dispatchEvent(new Event('onerror'), event);\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n  }\n\n  refresh() {\n    this.close();\n    this.open(false);\n  }\n\n  onopen() {}\n\n  onclose() {}\n\n  onconnecting() {}\n\n  onmessage() {}\n\n  onerror() {}\n\n  reconnect() {\n    const delay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n    setTimeout(() => {\n      this.reconnectAttempts++;\n      this.open(true);\n    }, delay);\n  }\n\n  connect() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.url = url;\n    this.protocols = protocols;\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || true;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 2000;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.listeners = {};\n    this.connect();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.listeners[type]) {\n      const index = this.listeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.listeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.listeners[event.type]) {\n      this.listeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(reconnecting) {\n    if (reconnecting) {\n      this.dispatchEvent({ type: 'connecting' });\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = () => {\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this.ws.protocol;\n      this.reconnectAttempts = 0;\n      this.dispatchEvent({ type: 'open' });\n      this.onopen();\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent({ type: 'close', event });\n      this.onclose();\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent({ type: 'message', data: event.data });\n      this.onmessage(event);\n    };\n    this.ws.onerror = (event) => {\n      this.dispatchEvent({ type: 'error', event });\n      this.onerror(event);\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent({ type: 'error', event: new Error('WebSocket is not open') });\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n  }\n\n  refresh() {\n    this.close();\n    this.open(false);\n  }\n\n  onopen() {}\n\n  onclose() {}\n\n  onconnecting() {}\n\n  onmessage(event) {}\n\n  onerror(event) {}\n\n  connect() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n    constructor(url, protocols, options) {\n        this.url = url;\n        this.protocols = protocols;\n        this.debug = options.debug || false;\n        this.automaticOpen = options.automaticOpen || true;\n        this.reconnectInterval = options.reconnectInterval || 1000;\n        this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n        this.reconnectDecay = options.reconnectDecay || 1.5;\n        this.timeoutInterval = options.timeoutInterval || 2000;\n        this.reconnectAttempts = 0;\n        this.readyState = WebSocket.CLOSED;\n        this.protocol = null;\n        this.ws = null;\n        this.listeners = {};\n        this.connect();\n    }\n\n    addEventListener(type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    removeEventListener(type, listener) {\n        if (this.listeners[type]) {\n            const index = this.listeners[type].indexOf(listener);\n            if (index > -1) {\n                this.listeners[type].splice(index, 1);\n            }\n        }\n    }\n\n    dispatchEvent(event) {\n        if (this.listeners[event.type]) {\n            this.listeners[event.type].forEach(listener => listener(event));\n        }\n    }\n\n    open(reconnecting) {\n        if (this.ws) {\n            this.ws.close();\n        }\n        this.ws = new WebSocket(this.url, this.protocols);\n        this.ws.binaryType = 'blob';\n        this.ws.onopen = () => {\n            this.readyState = WebSocket.OPEN;\n            this.protocol = this.ws.protocol;\n            this.reconnectAttempts = 0;\n            this.dispatchEvent(new Event('open'));\n            if (reconnecting) {\n                this.dispatchEvent(new Event('reconnecting'));\n            }\n        };\n        this.ws.onclose = (event) => {\n            this.readyState = WebSocket.CLOSED;\n            this.dispatchEvent(new Event('close'));\n            if (this.automaticOpen) {\n                this.reconnect();\n            }\n        };\n        this.ws.onmessage = (event) => {\n            this.dispatchEvent(new Event('message'));\n            this.dispatchEvent(new CustomEvent('message', { detail: event.data }));\n        };\n        this.ws.onerror = (event) => {\n            this.dispatchEvent(new Event('error'));\n            this.dispatchEvent(new CustomEvent('error', { detail: event }));\n        };\n    }\n\n    send(data) {\n        if (this.readyState === WebSocket.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.dispatchEvent(new CustomEvent('error', { detail: 'WebSocket is not open' }));\n        }\n    }\n\n    close(code, reason) {\n        if (this.ws) {\n            this.ws.close(code, reason);\n        }\n    }\n\n    refresh() {\n        this.close();\n        this.open(false);\n    }\n\n    onopen() {}\n\n    onclose() {}\n\n    onconnecting() {}\n\n    onmessage() {}\n\n    onerror() {}\n\n    reconnect() {\n        const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n        setTimeout(() => {\n            this.reconnectAttempts++;\n            this.open(true);\n        }, reconnectDelay);\n    }\n\n    connect() {\n        if (this.automaticOpen) {\n            this.open(false);\n        }\n    }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.url = url;\n    this.protocols = protocols;\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || true;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 2000;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.listeners = {};\n    this.init();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.listeners[type]) {\n      const index = this.listeners[type].indexOf(listener);\n      if (index > -1) {\n        this.listeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.listeners[event.type]) {\n      this.listeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(reconnecting) {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = () => {\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this.ws.protocol;\n      this.reconnectAttempts = 0;\n      this.dispatchEvent(new Event('open'));\n      this.dispatchEvent(new Event('message'));\n      if (reconnecting) {\n        this.dispatchEvent(new Event('reconnecting'));\n      }\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.protocol = null;\n      this.reconnect();\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent(new Event('message'));\n      this.dispatchEvent(new CustomEvent('message', { detail: event.data }));\n    };\n    this.ws.onerror = (event) => {\n      this.dispatchEvent(new Event('error'));\n      this.dispatchEvent(new CustomEvent('error', { detail: event }));\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent(new CustomEvent('error', { detail: 'WebSocket is not open' }));\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n  }\n\n  refresh() {\n    this.close();\n    this.open(false);\n  }\n\n  onopen() {}\n\n  onclose() {}\n\n  onconnecting() {}\n\n  onmessage() {}\n\n  onerror() {}\n\n  reconnect() {\n    if (this.readyState !== WebSocket.OPEN && this.automaticOpen) {\n      const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n      setTimeout(() => {\n        this.reconnectAttempts++;\n        this.open(true);\n        this.dispatchEvent(new Event('reconnecting'));\n      }, reconnectDelay);\n    }\n  }\n\n  init() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.url = url;\n    this.protocols = protocols;\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || true;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 2000;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = null;\n    this.ws = null;\n    this.listeners = {};\n    this.connect();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.listeners[type]) {\n      const index = this.listeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.listeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.listeners[event.type]) {\n      this.listeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(reconnecting) {\n    if (reconnecting) {\n      this.dispatchEvent({ type: 'connecting' });\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = () => {\n      this.reconnectAttempts = 0;\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this.ws.protocol;\n      this.dispatchEvent({ type: 'open' });\n      this.dispatchEvent({ type: 'onopen' });\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent({ type: 'close', event });\n      this.dispatchEvent({ type: 'onclose', event });\n      if (this.automaticOpen) {\n        this.reconnect();\n      }\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent({ type: 'message', event });\n      this.dispatchEvent({ type: 'onmessage', event });\n    };\n    this.ws.onerror = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent({ type: 'error', event });\n      this.dispatchEvent({ type: 'onerror', event });\n      if (this.automaticOpen) {\n        this.reconnect();\n      }\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n  }\n\n  refresh() {\n    this.close(1000, 'refresh');\n  }\n\n  onopen() {}\n\n  onclose() {}\n\n  onconnecting() {}\n\n  onmessage() {}\n\n  onerror() {}\n\n  reconnect() {\n    const delay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n    setTimeout(() => {\n      this.reconnectAttempts++;\n      this.open(true);\n    }, delay);\n  }\n\n  connect() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.url = url;\n    this.protocols = protocols;\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || true;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 2000;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.listeners = {};\n    this.connect();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.listeners[type]) {\n      const index = this.listeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.listeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.listeners[event.type]) {\n      this.listeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(reconnecting) {\n    if (reconnecting) {\n      this.dispatchEvent({ type: 'connecting' });\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = () => {\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this.ws.protocol;\n      this.reconnectAttempts = 0;\n      this.dispatchEvent({ type: 'open' });\n      this.onopen();\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent({ type: 'close', event });\n      this.onclose();\n      if (this.automaticOpen) {\n        this.reconnect();\n      }\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent({ type: 'message', data: event.data });\n      this.onmessage(event);\n    };\n    this.ws.onerror = (event) => {\n      this.dispatchEvent({ type: 'error', event });\n      this.onerror(event);\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent({ type: 'error', message: 'WebSocket is not open' });\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n  }\n\n  refresh() {\n    this.close(1000, 'Refresh connection');\n    this.open(false);\n  }\n\n  onopen() {}\n\n  onclose() {}\n\n  onconnecting() {}\n\n  onmessage(event) {}\n\n  onerror(event) {}\n\n  reconnect() {\n    const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n    setTimeout(() => {\n      this.reconnectAttempts++;\n      this.open(true);\n    }, reconnectDelay);\n  }\n\n  connect() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n    constructor(url, protocols, options) {\n        this.url = url;\n        this.protocols = protocols;\n        this.debug = options.debug || false;\n        this.automaticOpen = options.automaticOpen || true;\n        this.reconnectInterval = options.reconnectInterval || 1000;\n        this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n        this.reconnectDecay = options.reconnectDecay || 1.5;\n        this.timeoutInterval = options.timeoutInterval || 2000;\n        this.reconnectAttempts = 0;\n        this.readyState = WebSocket.CLOSED;\n        this.protocol = null;\n        this.ws = null;\n        this.listeners = {};\n        this.timeout = null;\n        this.connect();\n    }\n\n    addEventListener(type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    removeEventListener(type, listener) {\n        if (this.listeners[type]) {\n            const index = this.listeners[type].indexOf(listener);\n            if (index > -1) {\n                this.listeners[type].splice(index, 1);\n            }\n        }\n    }\n\n    dispatchEvent(event) {\n        if (this.listeners[event.type]) {\n            this.listeners[event.type].forEach(listener => listener(event));\n        }\n    }\n\n    open(reconnecting) {\n        if (reconnecting) {\n            this.dispatchEvent({ type: 'connecting' });\n        }\n        this.ws = new WebSocket(this.url, this.protocols);\n        this.ws.onopen = () => {\n            this.readyState = WebSocket.OPEN;\n            this.protocol = this.ws.protocol;\n            this.reconnectAttempts = 0;\n            this.dispatchEvent({ type: 'open' });\n            this.onopen();\n            this.resetTimeout();\n        };\n        this.ws.onclose = (event) => {\n            this.readyState = WebSocket.CLOSED;\n            this.protocol = null;\n            this.reconnectAttempts++;\n            this.dispatchEvent({ type: 'close', event });\n            this.onclose(event);\n            this.scheduleReconnect();\n        };\n        this.ws.onmessage = (event) => {\n            this.dispatchEvent({ type: 'message', data: event.data });\n            this.onmessage(event);\n        };\n        this.ws.onerror = (event) => {\n            this.dispatchEvent({ type: 'error', event });\n            this.onerror(event);\n        };\n    }\n\n    send(data) {\n        if (this.readyState === WebSocket.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.dispatchEvent({ type: 'error', message: 'WebSocket is not open' });\n        }\n    }\n\n    close(code, reason) {\n        if (this.ws) {\n            this.ws.close(code, reason);\n        }\n    }\n\n    refresh() {\n        this.close(1000, 'Refresh connection');\n        this.open(false);\n    }\n\n    onopen() {}\n\n    onclose(event) {}\n\n    onconnecting() {}\n\n    onmessage(event) {}\n\n    onerror(event) {}\n\n    connect() {\n        if (this.automaticOpen) {\n            this.open(false);\n        }\n    }\n\n    resetTimeout() {\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n        }\n        this.timeout = setTimeout(() => {\n            this.ws.terminate();\n        }, this.timeoutInterval);\n    }\n\n    scheduleReconnect() {\n        const delay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n        setTimeout(() => {\n            this.open(true);\n        }, delay);\n    }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.url = url;\n    this.protocols = protocols;\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || true;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 2000;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.listeners = {};\n    this.connect();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.listeners[type]) {\n      const index = this.listeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.listeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.listeners[event.type]) {\n      this.listeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(reconnecting) {\n    if (reconnecting) {\n      this.dispatchEvent({ type: 'connecting' });\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = () => {\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this.ws.protocol;\n      this.reconnectAttempts = 0;\n      this.dispatchEvent({ type: 'open' });\n      this.onopen();\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.dispatchEvent({ type: 'close', event });\n      this.onclose();\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent({ type: 'message', event });\n      this.onmessage();\n    };\n    this.ws.onerror = (event) => {\n      this.dispatchEvent({ type: 'error', event });\n      this.onerror();\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n  }\n\n  refresh() {\n    this.close();\n    this.open(false);\n  }\n\n  onopen() {}\n\n  onclose() {}\n\n  onconnecting() {}\n\n  onmessage() {}\n\n  onerror() {}\n\n  connect() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n\n  reconnect() {\n    const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n    setTimeout(() => {\n      this.reconnectAttempts++;\n      this.open(true);\n    }, reconnectDelay);\n  }\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n    constructor(url, protocols, options) {\n        this.url = url;\n        this.protocols = protocols;\n        this.debug = options.debug || false;\n        this.automaticOpen = options.automaticOpen || true;\n        this.reconnectInterval = options.reconnectInterval || 1000;\n        this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n        this.reconnectDecay = options.reconnectDecay || 1.5;\n        this.timeoutInterval = options.timeoutInterval || 2000;\n        this.reconnectAttempts = 0;\n        this.readyState = WebSocket.CONNECTING;\n        this.protocol = null;\n        this.ws = null;\n        this.listeners = {};\n        this.init();\n    }\n\n    addEventListener(type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    removeEventListener(type, listener) {\n        if (this.listeners[type]) {\n            const index = this.listeners[type].indexOf(listener);\n            if (index > -1) {\n                this.listeners[type].splice(index, 1);\n            }\n        }\n    }\n\n    dispatchEvent(event) {\n        if (this.listeners[event.type]) {\n            this.listeners[event.type].forEach(listener => listener(event));\n        }\n    }\n\n    open(reconnecting) {\n        if (reconnecting) {\n            this.reconnectAttempts++;\n        }\n        this.ws = new WebSocket(this.url, this.protocols);\n        this.ws.onopen = () => {\n            this.readyState = WebSocket.OPEN;\n            this.protocol = this.ws.protocol;\n            this.reconnectAttempts = 0;\n            this.reconnectInterval = this.reconnectDecay * this.reconnectInterval;\n            this.dispatchEvent(new Event('open'));\n            this.onopen();\n        };\n        this.ws.onclose = (event) => {\n            this.readyState = WebSocket.CLOSED;\n            this.dispatchEvent(new Event('close'));\n            this.onclose();\n            if (this.automaticOpen && this.reconnectAttempts < 10) {\n                setTimeout(() => {\n                    this.open(true);\n                }, this.reconnectInterval);\n                this.reconnectInterval = Math.min(this.maxReconnectInterval, this.reconnectInterval * this.reconnectDecay);\n            }\n        };\n        this.ws.onmessage = (event) => {\n            this.dispatchEvent(new MessageEvent('message', event));\n            this.onmessage(event);\n        };\n        this.ws.onerror = (event) => {\n            this.dispatchEvent(new Event('error'));\n            this.onerror(event);\n        };\n    }\n\n    send(data) {\n        if (this.readyState === WebSocket.OPEN) {\n            this.ws.send(data);\n        }\n    }\n\n    close(code, reason) {\n        if (this.ws) {\n            this.ws.close(code, reason);\n        }\n    }\n\n    refresh() {\n        this.close(1000, 'refresh');\n        this.open(false);\n    }\n\n    onopen() {}\n\n    onclose() {}\n\n    onconnecting() {}\n\n    onmessage(event) {}\n\n    onerror(event) {}\n}\n```",
      "```javascript\nclass ReconnectingWebSocket {\n  constructor(url, protocols, options) {\n    this.url = url;\n    this.protocols = protocols;\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || true;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 2000;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CLOSED;\n    this.protocol = null;\n    this.ws = null;\n    this.listeners = {};\n    this.setup();\n  }\n\n  addEventListener(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    if (this.listeners[type]) {\n      const index = this.listeners[type].indexOf(listener);\n      if (index !== -1) {\n        this.listeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this.listeners[event.type]) {\n      this.listeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(reconnecting) {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.ws = new WebSocket(this.url, this.protocols);\n    this.ws.onopen = () => {\n      this.readyState = WebSocket.OPEN;\n      this.protocol = this.ws.protocol;\n      this.reconnectAttempts = 0;\n      this.dispatchEvent(new Event('open'));\n      if (reconnecting) {\n        this.dispatchEvent(new Event('reconnecting'));\n      }\n      this.onopen();\n    };\n    this.ws.onclose = (event) => {\n      this.readyState = WebSocket.CLOSED;\n      this.protocol = null;\n      this.reconnect();\n    };\n    this.ws.onmessage = (event) => {\n      this.dispatchEvent(new Event('message'));\n      this.onmessage(event);\n    };\n    this.ws.onerror = (event) => {\n      this.dispatchEvent(new Event('error'));\n      this.onerror(event);\n    };\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.dispatchEvent(new Event('error'));\n      this.onerror(new Error('WebSocket is not open'));\n    }\n  }\n\n  close(code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n  }\n\n  refresh() {\n    this.close();\n    this.open(false);\n  }\n\n  onopen() {}\n\n  onclose() {}\n\n  onconnecting() {}\n\n  onmessage(event) {}\n\n  onerror(event) {}\n\n  reconnect() {\n    if (this.readyState === WebSocket.CLOSED) {\n      const reconnectDelay = Math.min(this.maxReconnectInterval, this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts));\n      setTimeout(() => {\n        this.reconnectAttempts++;\n        this.open(true);\n        this.dispatchEvent(new Event('connecting'));\n        this.onconnecting();\n      }, reconnectDelay);\n    }\n  }\n\n  setup() {\n    if (this.automaticOpen) {\n      this.open(false);\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Implement a LiveQueryClient class that manages WebSocket connections for real-time data updates in a Parse server environment, handling connection lifecycle, subscriptions, and error recovery.\n\nClass Description: The LiveQueryClient class establishes and maintains a WebSocket connection to a Parse LiveQuery server, manages subscriptions to queries, handles connection events (open, message, error, close), and implements automatic reconnection logic.\n\nAttributes:\n- attempts: number - Tracks reconnection attempts for exponential backoff\n- id: number - Unique client identifier assigned by server\n- requestId: number - Counter for subscription requests\n- applicationId: string - Parse application ID for authentication\n- serverURL: string - WebSocket server URL (must start with 'ws' or 'wss')\n- javascriptKey: string (optional) - JavaScript key for authentication\n- masterKey: string (optional) - Master key for authentication\n- sessionToken: string (optional) - User session token\n- installationId: string (optional) - Device installation identifier\n- additionalProperties: boolean - Flag to include additional properties in requests\n- connectPromise: Promise - Promise resolved when connection is established\n- subscriptions: Map<number, LiveQuerySubscription> - Active subscriptions\n- socket: WebSocketController - WebSocket connection controller\n- state: string - Current connection state (INITIALIZED, CONNECTING, CONNECTED, etc.)\n- reconnectHandle: any - Timeout handle for reconnection attempts\n- emitter: EventEmitter - Event emitter for connection events\n- on: function - Shortcut to emitter.on\n- emit: function - Shortcut to emitter.emit\n\nMethods:\n- constructor({applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId}) -> void - Initializes the client with connection parameters and validates serverURL\n- open() -> void - Establishes WebSocket connection and sets up event handlers\n- _handleWebSocketOpen() -> void - Sends connection request to server after WebSocket opens\n- _handleWebSocketMessage(event: any) -> void - Processes incoming messages from server and handles connection confirmation\n- _handleWebSocketClose() -> void - Handles connection closure and triggers reconnection\n- _handleWebSocketError(error: any) -> void - Handles WebSocket errors and triggers reconnection\n- _handleReconnect() -> void - Implements exponential backoff reconnection logic",
    "Canonical_solution": "import CoreManager, { WebSocketController } from './CoreManager';\nimport ParseObject from './ParseObject';\nimport LiveQuerySubscription from './LiveQuerySubscription';\nimport { resolvingPromise } from './promiseUtils';\nimport ParseError from './ParseError';\nimport type ParseQuery from './ParseQuery';\n\nclass LiveQueryClient {\n  attempts: number;\n  id: number;\n  requestId: number;\n  applicationId: string;\n  serverURL: string;\n  javascriptKey?: string;\n  masterKey?: string;\n  sessionToken?: string;\n  installationId?: string;\n  additionalProperties: boolean;\n  connectPromise: any;\n  subscriptions: Map<number, LiveQuerySubscription>;\n  socket: WebSocketController & { closingPromise?: any };\n  state: string;\n  reconnectHandle: any;\n  emitter: any;\n  on: any;\n  emit: any;\n\n  constructor({\n    applicationId,\n    serverURL,\n    javascriptKey,\n    masterKey,\n    sessionToken,\n    installationId,\n  }) {\n    if (!serverURL || serverURL.indexOf('ws') !== 0) {\n      throw new Error(\n        'You need to set a proper Parse LiveQuery server url before using LiveQueryClient'\n      );\n    }\n\n    this.reconnectHandle = null;\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.serverURL = serverURL;\n    this.applicationId = applicationId;\n    this.javascriptKey = javascriptKey || undefined;\n    this.masterKey = masterKey || undefined;\n    this.sessionToken = sessionToken || undefined;\n    this.installationId = installationId || undefined;\n    this.additionalProperties = true;\n    this.connectPromise = resolvingPromise();\n    this.subscriptions = new Map();\n    this.state = CLIENT_STATE.INITIALIZED;\n    const EventEmitter = CoreManager.getEventEmitter();\n    this.emitter = new EventEmitter();\n\n    this.on = (eventName, listener) => this.emitter.on(eventName, listener);\n    this.emit = (eventName, ...args) => this.emitter.emit(eventName, ...args);\n    this.on('error', () => {});\n  }\n\n  open() {\n    const WebSocketImplementation = CoreManager.getWebSocketController();\n    if (!WebSocketImplementation) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n      return;\n    }\n\n    if (this.state !== CLIENT_STATE.RECONNECTING) {\n      this.state = CLIENT_STATE.CONNECTING;\n    }\n\n    this.socket = new WebSocketImplementation(this.serverURL);\n    this.socket.closingPromise = resolvingPromise();\n\n    this.socket.onopen = () => {\n      this._handleWebSocketOpen();\n    };\n\n    this.socket.onmessage = event => {\n      this._handleWebSocketMessage(event);\n    };\n\n    this.socket.onclose = event => {\n      this.socket.closingPromise?.resolve(event);\n      this._handleWebSocketClose();\n    };\n\n    this.socket.onerror = error => {\n      this._handleWebSocketError(error);\n    };\n  }\n\n  _handleWebSocketOpen() {\n    const connectRequest = {\n      op: OP_TYPES.CONNECT,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken,\n      installationId: undefined as string | undefined,\n    };\n    if (this.additionalProperties) {\n      connectRequest.installationId = this.installationId;\n    }\n    this.socket.send(JSON.stringify(connectRequest));\n  }\n\n  _handleWebSocketMessage(event: any) {\n    let data = event.data;\n    if (typeof data === 'string') {\n      data = JSON.parse(data);\n    }\n    let subscription: null | LiveQuerySubscription = null;\n    if (data.requestId) {\n      subscription = this.subscriptions.get(data.requestId) || null;\n    }\n    const response = {\n      clientId: data.clientId,\n      installationId: data.installationId,\n    };\n    switch (data.op) {\n    case OP_EVENTS.CONNECTED:\n      if (this.state === CLIENT_STATE.RECONNECTING) {\n        this.resubscribe();\n      }\n      this.emit(CLIENT_EMMITER_TYPES.OPEN);\n      this.id = data.clientId;\n      this.connectPromise.resolve();\n      this.state = CLIENT_STATE.CONNECTED;\n      break;\n    }\n  }\n\n  _handleWebSocketClose() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.CLOSED;\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error: any) {\n    this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);\n    }\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.RECONNECTING;\n    const time = generateInterval(this.attempts);\n\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n    this.reconnectHandle = setTimeout(\n      (() => {\n        this.attempts++;\n        this.connectPromise = resolvingPromise();\n        this.open();\n      }).bind(this),\n      time\n    );\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```typescript\nclass LiveQueryClient {\n  attempts: number;\n  id: number;\n  requestId: number;\n  applicationId: string;\n  serverURL: string;\n  javascriptKey: string | null;\n  masterKey: string | null;\n  sessionToken: string | null;\n  installationId: string | null;\n  additionalProperties: boolean;\n  connectPromise: Promise<void>;\n  subscriptions: Map<number, any>;\n  socket: any;\n  state: string;\n  reconnectHandle: any;\n  emitter: any;\n  on: any;\n  emit: any;\n\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    this.attempts = 0;\n    this.id = 0;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = false;\n    this.connectPromise = Promise.resolve();\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = {\n      on: (event, handler) => {},\n      emit: (event, ...args) => {}\n    };\n    this.on = this.emitter.on;\n    this.emit = this.emitter.emit;\n  }\n\n  open(): void {\n    if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n      throw new Error('Invalid server URL');\n    }\n    this.socket = new WebSocket(this.serverURL);\n    this.socket.onopen = this._handleWebSocketOpen.bind(this);\n    this.socket.onmessage = this._handleWebSocketMessage.bind(this);\n    this.socket.onerror = this._handleWebSocketError.bind(this);\n    this.socket.onclose = this._handleWebSocketClose.bind(this);\n  }\n\n  _handleWebSocketOpen(): void {\n    this.state = 'CONNECTING';\n    this._handleWebSocketMessage({ data: 'connection request' });\n  }\n\n  _handleWebSocketMessage(event: any): void {\n    const data = JSON.parse(event.data);\n    if (data.type === 'connection confirmation') {\n      this.id = data.id;\n      this.state = 'CONNECTED';\n      this.emit('open');\n      this.connectPromise = Promise.resolve();\n    } else if (data.type === 'subscription confirmation') {\n      this.subscriptions.set(data.requestId, { ...data });\n      this.emit('subscription', data);\n    }\n  }\n\n  _handleWebSocketClose(): void {\n    this.state = 'INITIALIZED';\n    this.emit('close');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error: any): void {\n    this.state = 'INITIALIZED';\n    this.emit('error', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect(): void {\n    const delay = Math.pow(2, this.attempts) * 1000;\n    this.reconnectHandle = setTimeout(() => {\n      this.attempts++;\n      this.open();\n    }, delay);\n  }\n}\n```",
      "```javascript\nclass LiveQueryClient {\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    this.attempts = 0;\n    this.id = null;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = false;\n    this.connectPromise = null;\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = new EventEmitter();\n    this.on = this.emitter.on;\n    this.emit = this.emitter.emit;\n  }\n\n  open() {\n    if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n      throw new Error('Invalid server URL');\n    }\n    this.socket = new WebSocket(this.serverURL);\n    this.socket.onopen = this._handleWebSocketOpen.bind(this);\n    this.socket.onmessage = this._handleWebSocketMessage.bind(this);\n    this.socket.onerror = this._handleWebSocketError.bind(this);\n    this.socket.onclose = this._handleWebSocketClose.bind(this);\n  }\n\n  _handleWebSocketOpen() {\n    this.state = 'CONNECTING';\n    this._handleWebSocketMessage({ data: 'connection' });\n  }\n\n  _handleWebSocketMessage(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'connection') {\n      this.id = data.id;\n      this.state = 'CONNECTED';\n      this.connectPromise = Promise.resolve();\n      this.emitter.emit('open');\n    } else if (data.type === 'subscription') {\n      const subscription = new LiveQuerySubscription(data);\n      this.subscriptions.set(subscription.id, subscription);\n      this.emitter.emit('message', subscription);\n    } else if (data.type === 'error') {\n      this.emitter.emit('error', data.error);\n    }\n  }\n\n  _handleWebSocketClose() {\n    this.state = 'INITIALIZED';\n    this.emitter.emit('close');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error) {\n    this.emitter.emit('error', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state !== 'CONNECTED') {\n      const delay = Math.pow(2, this.attempts) * 1000;\n      this.reconnectHandle = setTimeout(() => {\n        this.attempts++;\n        this.open();\n      }, delay);\n    }\n  }\n}\n\nclass LiveQuerySubscription {\n  constructor(data) {\n    this.id = data.id;\n    this.query = data.query;\n    this.channels = data.channels;\n  }\n}\n\nconst EventEmitter = require('events');\n```",
      "```javascript\nclass LiveQueryClient {\n    constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n        this.attempts = 0;\n        this.id = null;\n        this.requestId = 0;\n        this.applicationId = applicationId;\n        this.serverURL = serverURL;\n        this.javascriptKey = javascriptKey;\n        this.masterKey = masterKey;\n        this.sessionToken = sessionToken;\n        this.installationId = installationId;\n        this.additionalProperties = false;\n        this.connectPromise = null;\n        this.subscriptions = new Map();\n        this.socket = null;\n        this.state = 'INITIALIZED';\n        this.reconnectHandle = null;\n        this.emitter = new EventEmitter();\n        this.on = this.emitter.on;\n        this.emit = this.emitter.emit;\n    }\n\n    open() {\n        if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n            throw new Error('Invalid server URL');\n        }\n        this.socket = new WebSocket(this.serverURL);\n        this.socket.onopen = this._handleWebSocketOpen.bind(this);\n        this.socket.onmessage = this._handleWebSocketMessage.bind(this);\n        this.socket.onerror = this._handleWebSocketError.bind(this);\n        this.socket.onclose = this._handleWebSocketClose.bind(this);\n    }\n\n    _handleWebSocketOpen() {\n        this.state = 'CONNECTING';\n        this._handleWebSocketMessage({ data: 'connection' });\n    }\n\n    _handleWebSocketMessage(event) {\n        const data = JSON.parse(event.data);\n        if (data.type === 'connection') {\n            this.id = data.id;\n            this.state = 'CONNECTED';\n            this.connectPromise = Promise.resolve();\n            this.emitter.emit('open');\n        } else if (data.type === 'message') {\n            this._handleMessage(data);\n        }\n    }\n\n    _handleWebSocketClose() {\n        this.state = 'INITIALIZED';\n        this.emitter.emit('close');\n        this._handleReconnect();\n    }\n\n    _handleWebSocketError(error) {\n        this.state = 'INITIALIZED';\n        this.emitter.emit('error', error);\n        this._handleReconnect();\n    }\n\n    _handleReconnect() {\n        if (this.state !== 'INITIALIZED') return;\n        const delay = Math.pow(2, this.attempts) * 1000;\n        this.reconnectHandle = setTimeout(() => {\n            this.attempts++;\n            this.open();\n        }, delay);\n    }\n\n    _handleMessage(data) {\n        const subscriptionId = data.subscriptionId;\n        if (subscriptionId) {\n            const subscription = this.subscriptions.get(subscriptionId);\n            if (subscription) {\n                subscription.handleMessage(data);\n            }\n        } else {\n            this.emitter.emit('message', data);\n        }\n    }\n}\n```",
      "```javascript\nclass LiveQueryClient {\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    this.attempts = 0;\n    this.id = null;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = false;\n    this.connectPromise = Promise.resolve();\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = new EventEmitter();\n    this.on = this.emitter.on;\n    this.emit = this.emitter.emit;\n  }\n\n  open() {\n    this.connectPromise = new Promise((resolve, reject) => {\n      this.socket = new WebSocket(this.serverURL);\n      this.socket.onopen = this._handleWebSocketOpen.bind(this);\n      this.socket.onmessage = this._handleWebSocketMessage.bind(this);\n      this.socket.onerror = this._handleWebSocketError.bind(this);\n      this.socket.onclose = this._handleWebSocketClose.bind(this);\n      this.connectPromise = resolve();\n    });\n  }\n\n  _handleWebSocketOpen() {\n    this.state = 'CONNECTING';\n    this._handleWebSocketMessage({ data: 'connection request' });\n  }\n\n  _handleWebSocketMessage(event) {\n    const data = JSON.parse(event.data);\n    if (data.id === 'connection confirmation') {\n      this.id = data.clientId;\n      this.state = 'CONNECTED';\n      this.emitter.emit('open');\n    } else if (data.id === 'subscription confirmation') {\n      this.subscriptions.set(data.requestId, new LiveQuerySubscription(data.subscriptionId));\n    }\n  }\n\n  _handleWebSocketClose() {\n    this.state = 'INITIALIZED';\n    this.emitter.emit('close');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error) {\n    this.emitter.emit('error', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state !== 'CONNECTED') {\n      clearTimeout(this.reconnectHandle);\n      this.reconnectHandle = setTimeout(() => {\n        this.attempts++;\n        this.open();\n      }, Math.pow(2, this.attempts) * 1000);\n    }\n  }\n}\n\nclass WebSocketController {\n  constructor(url) {\n    this.socket = new WebSocket(url);\n  }\n}\n\nclass LiveQuerySubscription {\n  constructor(subscriptionId) {\n    this.subscriptionId = subscriptionId;\n  }\n}\n\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n  }\n\n  emit(event, ...args) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => listener(...args));\n    }\n  }\n}\n```",
      "```typescript\nclass LiveQueryClient {\n  attempts: number;\n  id: number;\n  requestId: number;\n  applicationId: string;\n  serverURL: string;\n  javascriptKey: string | undefined;\n  masterKey: string | undefined;\n  sessionToken: string | undefined;\n  installationId: string | undefined;\n  additionalProperties: boolean;\n  connectPromise: Promise<void>;\n  subscriptions: Map<number, any>;\n  socket: any;\n  state: string;\n  reconnectHandle: any;\n  emitter: any;\n  on: any;\n  emit: any;\n\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    this.attempts = 0;\n    this.id = 0;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = false;\n    this.connectPromise = Promise.resolve();\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = {\n      on: (event, handler) => {},\n      emit: (event, ...args) => {}\n    };\n    this.on = this.emitter.on;\n    this.emit = this.emitter.emit;\n  }\n\n  open(): void {\n    if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n      throw new Error('Invalid server URL');\n    }\n    this.socket = new WebSocket(this.serverURL);\n    this.socket.onopen = this._handleWebSocketOpen.bind(this);\n    this.socket.onmessage = this._handleWebSocketMessage.bind(this);\n    this.socket.onerror = this._handleWebSocketError.bind(this);\n    this.socket.onclose = this._handleWebSocketClose.bind(this);\n  }\n\n  _handleWebSocketOpen(): void {\n    this.state = 'CONNECTING';\n    this._handleWebSocketMessage({ data: 'connection request' });\n  }\n\n  _handleWebSocketMessage(event: any): void {\n    if (event.data === 'connection confirmed') {\n      this.state = 'CONNECTED';\n      this.emit('open');\n      this.connectPromise = Promise.resolve();\n    } else {\n      // Handle other messages\n    }\n  }\n\n  _handleWebSocketClose(): void {\n    this.state = 'INITIALIZED';\n    this.emit('close');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error: any): void {\n    this.state = 'INITIALIZED';\n    this.emit('error', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect(): void {\n    const delay = Math.pow(2, this.attempts) * 1000;\n    this.reconnectHandle = setTimeout(() => {\n      this.attempts++;\n      this.open();\n    }, delay);\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nclass LiveQueryClient {\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    this.attempts = 0;\n    this.id = null;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = false;\n    this.connectPromise = null;\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = new EventEmitter();\n    this.on = this.emitter.on;\n    this.emit = this.emitter.emit;\n  }\n\n  open() {\n    if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n      throw new Error('Invalid server URL');\n    }\n    this.socket = new WebSocketController(this.serverURL);\n    this.socket.on('open', this._handleWebSocketOpen.bind(this));\n    this.socket.on('message', this._handleWebSocketMessage.bind(this));\n    this.socket.on('error', this._handleWebSocketError.bind(this));\n    this.socket.on('close', this._handleWebSocketClose.bind(this));\n  }\n\n  _handleWebSocketOpen() {\n    this.state = 'CONNECTING';\n    this._handleWebSocketMessage({ data: 'connection request' });\n  }\n\n  _handleWebSocketMessage(event) {\n    const message = JSON.parse(event.data);\n    if (message.type === 'connection confirmation') {\n      this.id = message.id;\n      this.state = 'CONNECTED';\n      this.connectPromise = Promise.resolve();\n      this.emitter.emit('connected');\n    } else if (message.type === 'subscription confirmation') {\n      const subscription = new LiveQuerySubscription(message.subscriptionId, message.query);\n      this.subscriptions.set(subscription.subscriptionId, subscription);\n      this.emitter.emit('subscription', subscription);\n    }\n  }\n\n  _handleWebSocketClose() {\n    this.state = 'INITIALIZED';\n    this.emitter.emit('disconnected');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error) {\n    console.error('WebSocket error:', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state === 'CONNECTED') {\n      return;\n    }\n    const delay = Math.pow(2, this.attempts) * 1000;\n    this.reconnectHandle = setTimeout(() => {\n      this.attempts++;\n      this.open();\n    }, delay);\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n    this.state = 'INITIALIZED';\n    this.emitter.emit('disconnected');\n  }\n\n  subscribe(query) {\n    if (!this.id) {\n      throw new Error('Client not connected');\n    }\n    this.requestId++;\n    const subscription = new LiveQuerySubscription(this.requestId, query);\n    this.subscriptions.set(this.requestId, subscription);\n    this.socket.send(JSON.stringify({\n      type: 'subscribe',\n      requestId: this.requestId,\n      query: query,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken,\n      installationId: this.installationId,\n      additionalProperties: this.additionalProperties\n    }));\n  }\n}\n\nclass WebSocketController {\n  constructor(url) {\n    this.url = url;\n    this.socket = new WebSocket(url);\n  }\n\n  on(event, handler) {\n    this.socket.addEventListener(event, handler);\n  }\n\n  send(data) {\n    this.socket.send(data);\n  }\n}\n\nclass EventEmitter {\n  on(event, handler) {\n    if (!this.handlers) {\n      this.handlers = {};\n    }\n    if (!this.handlers[event]) {\n      this.handlers[event] = [];\n    }\n    this.handlers[event].push(handler);\n  }\n\n  emit(event, ...args) {\n    if (this.handlers && this.handlers[event]) {\n      this.handlers[event].forEach(handler => handler(...args));\n    }\n  }\n}\n\nclass LiveQuerySubscription {\n  constructor(subscriptionId, query) {\n    this.subscriptionId = subscriptionId;\n    this.query = query;\n  }\n}\n```",
      "```javascript\nclass LiveQueryClient {\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    this.attempts = 0;\n    this.id = null;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = false;\n    this.connectPromise = null;\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = new EventEmitter();\n    this.on = this.emitter.on.bind(this.emitter);\n    this.emit = this.emitter.emit.bind(this.emitter);\n  }\n\n  open() {\n    if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n      throw new Error('Invalid server URL');\n    }\n    this.socket = new WebSocketController(this.serverURL);\n    this.socket.on('open', this._handleWebSocketOpen.bind(this));\n    this.socket.on('message', this._handleWebSocketMessage.bind(this));\n    this.socket.on('error', this._handleWebSocketError.bind(this));\n    this.socket.on('close', this._handleWebSocketClose.bind(this));\n  }\n\n  _handleWebSocketOpen() {\n    this.state = 'CONNECTING';\n    this._handleWebSocketMessage({ data: 'connection' });\n  }\n\n  _handleWebSocketMessage(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'connection') {\n      this.id = data.id;\n      this.state = 'CONNECTED';\n      this.connectPromise = Promise.resolve();\n      this.emitter.emit('open');\n    } else if (data.type === 'subscription') {\n      const subscription = new LiveQuerySubscription(data.subscriptionId, data.query);\n      this.subscriptions.set(subscription.subscriptionId, subscription);\n      this.emitter.emit('message', data);\n    }\n  }\n\n  _handleWebSocketClose() {\n    this.state = 'INITIALIZED';\n    this.emitter.emit('close');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error) {\n    this.emitter.emit('error', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state !== 'INITIALIZED') return;\n    const delay = Math.pow(2, this.attempts) * 1000;\n    this.reconnectHandle = setTimeout(() => {\n      this.attempts++;\n      this.open();\n    }, delay);\n  }\n}\n\nclass WebSocketController {\n  constructor(url) {\n    this.url = url;\n    this.socket = new WebSocket(url);\n  }\n\n  on(eventType, callback) {\n    this.socket.addEventListener(eventType, callback);\n  }\n}\n\nclass EventEmitter {\n  on(event, callback) {\n    if (!this.listeners) {\n      this.listeners = {};\n    }\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n  }\n\n  emit(event, ...args) {\n    if (this.listeners && this.listeners[event]) {\n      this.listeners[event].forEach(callback => callback(...args));\n    }\n  }\n}\n```",
      "```javascript\nclass LiveQueryClient {\n    constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n        this.attempts = 0;\n        this.id = null;\n        this.requestId = 0;\n        this.applicationId = applicationId;\n        this.serverURL = serverURL;\n        this.javascriptKey = javascriptKey;\n        this.masterKey = masterKey;\n        this.sessionToken = sessionToken;\n        this.installationId = installationId;\n        this.additionalProperties = false;\n        this.connectPromise = null;\n        this.subscriptions = new Map();\n        this.socket = null;\n        this.state = 'INITIALIZED';\n        this.reconnectHandle = null;\n        this.emitter = new EventEmitter();\n        this.on = this.emitter.on;\n        this.emit = this.emitter.emit;\n    }\n\n    open() {\n        if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n            throw new Error('Invalid server URL');\n        }\n        this.socket = new WebSocketController(this.serverURL);\n        this.socket.on('open', this._handleWebSocketOpen.bind(this));\n        this.socket.on('message', this._handleWebSocketMessage.bind(this));\n        this.socket.on('error', this._handleWebSocketError.bind(this));\n        this.socket.on('close', this._handleWebSocketClose.bind(this));\n        this.connectPromise = new Promise((resolve, reject) => {\n            this.socket.on('open', resolve);\n            this.socket.on('error', reject);\n        });\n    }\n\n    _handleWebSocketOpen() {\n        this.state = 'CONNECTING';\n        this._handleWebSocketMessage({ data: 'connection request' });\n    }\n\n    _handleWebSocketMessage(event) {\n        const data = JSON.parse(event.data);\n        if (data.type === 'connection confirmation') {\n            this.id = data.id;\n            this.state = 'CONNECTED';\n            this.emitter.emit('open');\n        } else if (data.type === 'message') {\n            this._handleMessage(data);\n        }\n    }\n\n    _handleWebSocketClose() {\n        this.state = 'INITIALIZED';\n        this.emitter.emit('close');\n        this._handleReconnect();\n    }\n\n    _handleWebSocketError(error) {\n        this.state = 'INITIALIZED';\n        this.emitter.emit('error', error);\n        this._handleReconnect();\n    }\n\n    _handleReconnect() {\n        if (this.state === 'INITIALIZED') {\n            const backoff = Math.pow(2, this.attempts) * 1000;\n            this.reconnectHandle = setTimeout(() => {\n                this.attempts++;\n                this.open();\n            }, backoff);\n        }\n    }\n\n    _handleMessage(data) {\n        const subscriptionId = data.subscriptionId;\n        if (subscriptionId) {\n            const subscription = this.subscriptions.get(subscriptionId);\n            if (subscription) {\n                subscription.handleMessage(data);\n            }\n        } else {\n            this.emitter.emit('message', data);\n        }\n    }\n}\n\nclass WebSocketController {\n    constructor(url) {\n        this.url = url;\n        this.socket = new WebSocket(url);\n    }\n\n    on(event, handler) {\n        this.socket.addEventListener(event, handler);\n    }\n\n    send(data) {\n        this.socket.send(JSON.stringify(data));\n    }\n}\n\nclass EventEmitter {\n    on(event, handler) {\n        if (!this.handlers) {\n            this.handlers = {};\n        }\n        if (!this.handlers[event]) {\n            this.handlers[event] = [];\n        }\n        this.handlers[event].push(handler);\n    }\n\n    emit(event, ...args) {\n        if (this.handlers && this.handlers[event]) {\n            this.handlers[event].forEach(handler => handler(...args));\n        }\n    }\n}\n```",
      "```javascript\nclass LiveQueryClient {\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    this.attempts = 0;\n    this.id = null;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = false;\n    this.connectPromise = null;\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = new EventEmitter();\n    this.on = this.emitter.on;\n    this.emit = this.emitter.emit;\n  }\n\n  open() {\n    if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n      throw new Error('Invalid server URL');\n    }\n    this.socket = new WebSocketController(this.serverURL);\n    this.socket.on('open', this._handleWebSocketOpen.bind(this));\n    this.socket.on('message', this._handleWebSocketMessage.bind(this));\n    this.socket.on('error', this._handleWebSocketError.bind(this));\n    this.socket.on('close', this._handleWebSocketClose.bind(this));\n  }\n\n  _handleWebSocketOpen() {\n    this.state = 'CONNECTING';\n    this._handleWebSocketMessage({ data: 'connection' });\n  }\n\n  _handleWebSocketMessage(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'connection') {\n      this.id = data.id;\n      this.state = 'CONNECTED';\n      this.connectPromise = Promise.resolve();\n      this.emitter.emit('open');\n    } else if (data.type === 'message') {\n      this._handleMessage(data);\n    }\n  }\n\n  _handleWebSocketClose() {\n    this.state = 'INITIALIZED';\n    this.emitter.emit('close');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error) {\n    this.emitter.emit('error', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state === 'CONNECTED') return;\n    if (this.reconnectHandle) clearTimeout(this.reconnectHandle);\n    const delay = Math.pow(2, this.attempts) * 1000;\n    this.reconnectHandle = setTimeout(() => {\n      this.attempts++;\n      this.open();\n    }, delay);\n  }\n\n  _handleMessage(data) {\n    const subscriptionId = data.subscriptionId;\n    if (subscriptionId) {\n      const subscription = this.subscriptions.get(subscriptionId);\n      if (subscription) {\n        subscription.handleMessage(data);\n      }\n    } else {\n      this.emitter.emit('message', data);\n    }\n  }\n}\n\nclass WebSocketController {\n  constructor(url) {\n    this.url = url;\n    this.socket = new WebSocket(url);\n  }\n\n  on(event, handler) {\n    this.socket.addEventListener(event, handler);\n  }\n\n  send(data) {\n    this.socket.send(JSON.stringify(data));\n  }\n}\n\nclass EventEmitter {\n  on(event, handler) {\n    if (!this.handlers) this.handlers = {};\n    if (!this.handlers[event]) this.handlers[event] = [];\n    this.handlers[event].push(handler);\n  }\n\n  emit(event, ...args) {\n    if (this.handlers && this.handlers[event]) {\n      this.handlers[event].forEach(handler => handler(...args));\n    }\n  }\n}\n```",
      "```javascript\nclass LiveQueryClient {\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    this.attempts = 0;\n    this.id = null;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = false;\n    this.connectPromise = null;\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = new EventEmitter();\n    this.on = this.emitter.on;\n    this.emit = this.emitter.emit;\n  }\n\n  open() {\n    if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n      throw new Error('Invalid server URL');\n    }\n    this.socket = new WebSocketController(this.serverURL);\n    this.socket.on('open', this._handleWebSocketOpen.bind(this));\n    this.socket.on('message', this._handleWebSocketMessage.bind(this));\n    this.socket.on('error', this._handleWebSocketError.bind(this));\n    this.socket.on('close', this._handleWebSocketClose.bind(this));\n    this.connectPromise = new Promise((resolve, reject) => {\n      this.socket.on('open', resolve);\n      this.socket.on('error', reject);\n    });\n  }\n\n  _handleWebSocketOpen() {\n    this.state = 'CONNECTING';\n    this._handleWebSocketMessage({ data: 'connection' });\n  }\n\n  _handleWebSocketMessage(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === 'connection') {\n      this.id = data.id;\n      this.state = 'CONNECTED';\n      this.on('open');\n    } else if (data.type === 'subscription') {\n      const subscription = new LiveQuerySubscription(data);\n      this.subscriptions.set(subscription.id, subscription);\n      this.on('subscription', subscription);\n    }\n  }\n\n  _handleWebSocketClose() {\n    this.state = 'INITIALIZED';\n    this.on('close');\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error) {\n    this.state = 'INITIALIZED';\n    this.on('error', error);\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state !== 'INITIALIZED') return;\n    const delay = Math.pow(2, this.attempts) * 1000;\n    this.reconnectHandle = setTimeout(() => {\n      this.attempts++;\n      this.open();\n    }, delay);\n  }\n}\n\nclass WebSocketController {\n  constructor(url) {\n    this.url = url;\n    this.socket = new WebSocket(url);\n  }\n\n  on(event, handler) {\n    this.socket.addEventListener(event, handler);\n  }\n}\n\nclass EventEmitter {\n  on(event, handler) {\n    if (!this.handlers) this.handlers = {};\n    if (!this.handlers[event]) this.handlers[event] = [];\n    this.handlers[event].push(handler);\n  }\n\n  emit(event, ...args) {\n    if (this.handlers && this.handlers[event]) {\n      this.handlers[event].forEach(handler => handler(...args));\n    }\n  }\n}\n```"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize';\n  const headers = {\n    'Content-Type': 'application/ssml+xml',\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n  };\n  const payload = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice xml:lang=\"en-US\" name=\"Microsoft Server Speech Voice (English - United States)\">${ssml}</voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: payload\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  } catch (error) {\n    throw error;\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize';\n  const headers = {\n    'Content-Type': 'application/ssml+xml',\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n  };\n  const payload = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice name=\"en-US-JennyNeural\"><speak>${ssml}</speak></voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: payload\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  } catch (error) {\n    throw error;\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize';\n  const headers = {\n    'Content-Type': 'application/ssml+xml',\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n  };\n  const payload = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice xml:lang=\"en-US\" name=\"Microsoft Server Speech Voice (English - United States)\">${ssml}</voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: payload\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  } catch (error) {\n    throw error;\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize';\n  const headers = {\n    'Content-Type': 'application/ssml+xml',\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n  };\n  const payload = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice xml:lang=\"en-US\" name=\"Microsoft Server Speech Voice (English - United States)\">${ssml}</voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: payload\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  } catch (error) {\n    throw error;\n  }\n}\n```",
      "```python\nimport requests\nimport base64\n\ndef speechApi(ssml):\n    url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize'\n    headers = {\n        'Content-Type': 'application/ssml+xml',\n        'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n    }\n    payload = f'<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice name=\"en-US-JennyNeural\">{ssml}</voice></speak>'\n    response = requests.post(url, headers=headers, data=payload)\n    if response.status_code == 200:\n        return response.content\n    else:\n        raise Exception(f'Failed to synthesize speech: {response.status_code} - {response.text}')\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize';\n  const headers = {\n    'Content-Type': 'application/ssml+xml',\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n  };\n  const payload = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice xml:lang=\"en-US\" name=\"Microsoft Server Speech Voice (English - United States)\">${ssml}</voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: payload\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  } catch (error) {\n    throw error;\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize';\n  const headers = {\n    'Content-Type': 'application/ssml+xml',\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n  };\n  const payload = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice name=\"en-US-JennyNeural\"><speak>${ssml}</speak></voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: payload\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  } catch (error) {\n    throw error;\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize';\n  const headers = {\n    'Content-Type': 'application/ssml+xml',\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n  };\n  const payload = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice xml:lang=\"en-US\" name=\"Microsoft Server Speech Voice (English - United States)\">${ssml}</voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: payload\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  } catch (error) {\n    throw error;\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function speechApi(ssml) {\n  const url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize';\n  const headers = {\n    'Content-Type': 'application/ssml+xml',\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n  };\n  const payload = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice xml:lang=\"en-US\" name=\"Microsoft Server Speech Voice (English - United States)\">${ssml}</voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: headers,\n      body: payload\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  } catch (error) {\n    throw new Error(`Failed to convert SSML to speech: ${error.message}`);\n  }\n}\n```",
      "```python\nimport requests\nimport base64\n\ndef speechApi(ssml):\n    url = 'https://speech.microsoft.com/speechservices/v3.0/synthesize'\n    headers = {\n        'Content-Type': 'application/ssml+xml',\n        'Authorization': 'Bearer YOUR_ACCESS_TOKEN'\n    }\n    payload = f'<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\"><voice xml:lang=\"en-US\" name=\"Microsoft Server Speech Voice (English - United States)\">'\n    payload += ssml\n    payload += '</voice></speak>'\n    encoded_payload = base64.b64encode(payload.encode('utf-8')).decode('utf-8')\n    response = requests.post(url, headers=headers, data=encoded_payload)\n    if response.status_code == 200:\n        return response.content\n    else:\n        raise Exception(f'Failed to synthesize speech: {response.status_code} - {response.text}')\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, handles incoming messages (including PING-PONG mechanism), manages connection errors, and automatically reconnects when the connection is closed.\n\nFunction Description: The `connect` function initializes a WebSocket connection to a specified server URL and sets up event handlers for various WebSocket events. It handles connection opening, incoming messages (with special handling for PING messages and JSON data), connection errors, and automatic reconnection when the connection closes. Received text data is displayed in a textarea element and stored in localStorage.\n\nInput: None (The WebSocket URL is hardcoded as \"ws://127.0.0.1:8266/\" in the function)\n\nOutput: None (The function's effects are through side effects: establishing WebSocket connection, updating UI elements, and storing data in localStorage)",
    "Canonical_solution": "function connect() {\n    ws = new WebSocket(\"ws://127.0.0.1:8266/\");\n\n    ws.onopen = function () {\n        myLog('ws connected')\n    };\n\n    ws.onmessage = function (e) {\n        var d = e.data\n        if (d == '[PING]')\n            ws.send('[PONG]')\n        else {\n            if (d[0] == '{') {\n                d = JSON.parse(d)\n                document.getElementById(\"textArea\").value += d.txt\n                localStorage.setItem('txt_stored', document.getElementById(\"textArea\").value);\n            }\n        }\n    }\n\n    ws.onclose = function (e) {\n        setTimeout(function () {\n            connect();\n        }, 2000);\n    };\n\n    ws.onerror = function (e) {\n        myLog('ws error', e.message);\n        ws.close();\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst ws = new WebSocket(\"ws://127.0.0.1:8266/\");\nconst textarea = document.getElementById(\"output\");\n\nws.onopen = function() {\n  console.log(\"Connected to the server\");\n};\n\nws.onmessage = function(event) {\n  const data = event.data;\n  if (data === \"PING\") {\n    ws.send(\"PONG\");\n  } else {\n    textarea.value += data + \"\\n\";\n    localStorage.setItem(\"messages\", localStorage.getItem(\"messages\") + data + \"\\n\");\n  }\n};\n\nws.onerror = function(error) {\n  console.error(\"WebSocket Error: \" + error);\n};\n\nws.onclose = function() {\n  console.log(\"Disconnected from the server\");\n  setTimeout(connect, 2000);\n};\n\nfunction connect() {\n  const ws = new WebSocket(\"ws://127.0.0.1:8266/\");\n  ws.onopen = function() {\n    console.log(\"Connected to the server\");\n  };\n  ws.onmessage = function(event) {\n    const data = event.data;\n    if (data === \"PING\") {\n      ws.send(\"PONG\");\n    } else {\n      textarea.value += data + \"\\n\";\n      localStorage.setItem(\"messages\", localStorage.getItem(\"messages\") + data + \"\\n\");\n    }\n  };\n  ws.onerror = function(error) {\n    console.error(\"WebSocket Error: \" + error);\n  };\n  ws.onclose = function() {\n    console.log(\"Disconnected from the server\");\n    setTimeout(connect, 2000);\n  };\n}\n```",
      "```javascript\nconst ws = new WebSocket(\"ws://127.0.0.1:8266/\");\nconst textarea = document.getElementById(\"output\");\n\nws.onopen = function() {\n  console.log(\"Connected to the server\");\n};\n\nws.onmessage = function(event) {\n  const data = event.data;\n  if (data === \"PING\") {\n    ws.send(\"PONG\");\n  } else {\n    textarea.value += data + \"\\n\";\n    localStorage.setItem(\"messages\", localStorage.getItem(\"messages\") + data + \"\\n\");\n  }\n};\n\nws.onerror = function(error) {\n  console.error(\"WebSocket Error: \", error);\n};\n\nws.onclose = function() {\n  console.log(\"Disconnected from the server\");\n  setTimeout(connect, 5000);\n};\n\nfunction connect() {\n  const ws = new WebSocket(\"ws://127.0.0.1:8266/\");\n  ws.onopen = function() {\n    console.log(\"Connected to the server\");\n  };\n  ws.onmessage = function(event) {\n    const data = event.data;\n    if (data === \"PING\") {\n      ws.send(\"PONG\");\n    } else {\n      textarea.value += data + \"\\n\";\n      localStorage.setItem(\"messages\", localStorage.getItem(\"messages\") + data + \"\\n\");\n    }\n  };\n  ws.onerror = function(error) {\n    console.error(\"WebSocket Error: \", error);\n  };\n  ws.onclose = function() {\n    console.log(\"Disconnected from the server\");\n    setTimeout(connect, 5000);\n  };\n}\n```",
      "```javascript\nconst wsUrl = \"ws://127.0.0.1:8266/\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"WebSocket connection established.\");\n  };\n\n  ws.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === \"ping\") {\n      ws.send(JSON.stringify({ type: \"pong\" }));\n    } else {\n      const textarea = document.getElementById(\"messageLog\");\n      textarea.value += data.message + \"\\n\";\n      localStorage.setItem(\"messages\", textarea.value);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error:\", error);\n  };\n\n  ws.onclose = function() {\n    console.log(\"WebSocket connection closed.\");\n    setTimeout(connect, 5000); // Reconnect after 5 seconds\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://127.0.0.1:8266/\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"WebSocket connection established.\");\n  };\n\n  ws.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === \"ping\") {\n      ws.send(JSON.stringify({ type: \"pong\" }));\n    } else {\n      const textarea = document.getElementById(\"messageLog\");\n      textarea.value += data.message + \"\\n\";\n      localStorage.setItem(\"messages\", textarea.value);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error:\", error);\n  };\n\n  ws.onclose = function() {\n    console.log(\"WebSocket connection closed.\");\n    setTimeout(connect, 5000); // Reconnect after 5 seconds\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://127.0.0.1:8266/\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"WebSocket connection established.\");\n  };\n\n  ws.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === \"ping\") {\n      ws.send(JSON.stringify({ type: \"pong\" }));\n    } else {\n      const textarea = document.getElementById(\"messageLog\");\n      textarea.value += data.message + \"\\n\";\n      localStorage.setItem(\"messages\", textarea.value);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error: \", error);\n  };\n\n  ws.onclose = function() {\n    console.log(\"WebSocket connection closed.\");\n    setTimeout(connect, 5000);\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://127.0.0.1:8266/\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"WebSocket connection established.\");\n  };\n\n  ws.onmessage = function(event) {\n    const data = event.data;\n    if (data === \"PING\") {\n      ws.send(\"PONG\");\n    } else {\n      const textarea = document.getElementById(\"messageLog\");\n      textarea.value += data + \"\\n\";\n      localStorage.setItem(\"messages\", textarea.value);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error: \", error);\n  };\n\n  ws.onclose = function() {\n    console.log(\"WebSocket connection closed.\");\n    setTimeout(connect, 5000); // Reconnect after 5 seconds\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst ws = new WebSocket(\"ws://127.0.0.1:8266/\");\nconst textarea = document.getElementById(\"output\");\n\nws.onopen = function() {\n  console.log(\"Connected to the server\");\n};\n\nws.onmessage = function(event) {\n  const data = event.data;\n  if (data === \"PING\") {\n    ws.send(\"PONG\");\n  } else {\n    textarea.value += data + \"\\n\";\n    localStorage.setItem(\"messages\", localStorage.getItem(\"messages\") + data + \"\\n\");\n  }\n};\n\nws.onerror = function(error) {\n  console.error(\"WebSocket Error: \", error);\n};\n\nws.onclose = function() {\n  console.log(\"Disconnected from the server\");\n  setTimeout(connect, 5000);\n};\n\nfunction connect() {\n  const ws = new WebSocket(\"ws://127.0.0.1:8266/\");\n  ws.onopen = function() {\n    console.log(\"Connected to the server\");\n  };\n  ws.onmessage = function(event) {\n    const data = event.data;\n    if (data === \"PING\") {\n      ws.send(\"PONG\");\n    } else {\n      textarea.value += data + \"\\n\";\n      localStorage.setItem(\"messages\", localStorage.getItem(\"messages\") + data + \"\\n\");\n    }\n  };\n  ws.onerror = function(error) {\n    console.error(\"WebSocket Error: \", error);\n  };\n  ws.onclose = function() {\n    console.log(\"Disconnected from the server\");\n    setTimeout(connect, 5000);\n  };\n}\n```",
      "```javascript\nconst wsUrl = \"ws://127.0.0.1:8266/\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"WebSocket connection established.\");\n  };\n\n  ws.onmessage = function(event) {\n    const data = event.data;\n    if (data === \"PING\") {\n      ws.send(\"PONG\");\n    } else {\n      const textarea = document.getElementById(\"output\");\n      textarea.value += data + \"\\n\";\n      localStorage.setItem(\"messages\", textarea.value);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error:\", error);\n  };\n\n  ws.onclose = function() {\n    console.log(\"WebSocket connection closed.\");\n    setTimeout(connect, 5000);\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://127.0.0.1:8266/\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"WebSocket connection established.\");\n  };\n\n  ws.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    if (data.type === \"ping\") {\n      ws.send(JSON.stringify({ type: \"pong\" }));\n    } else {\n      const textarea = document.getElementById(\"messageLog\");\n      textarea.value += data.message + \"\\n\";\n      localStorage.setItem(\"messages\", textarea.value);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error: \", error);\n  };\n\n  ws.onclose = function() {\n    console.log(\"WebSocket connection closed.\");\n    setTimeout(connect, 5000); // Reconnect after 5 seconds\n  };\n}\n\nconnect();\n```",
      "```javascript\nconst wsUrl = \"ws://127.0.0.1:8266/\";\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUrl);\n\n  ws.onopen = function() {\n    console.log(\"WebSocket connection established.\");\n  };\n\n  ws.onmessage = function(event) {\n    const data = event.data;\n    if (data === \"PING\") {\n      ws.send(\"PONG\");\n    } else {\n      const textarea = document.getElementById(\"messageLog\");\n      textarea.value += data + \"\\n\";\n      localStorage.setItem(\"messages\", textarea.value);\n    }\n  };\n\n  ws.onerror = function(error) {\n    console.error(\"WebSocket error: \", error);\n  };\n\n  ws.onclose = function() {\n    console.log(\"WebSocket connection closed.\");\n    setTimeout(connect, 5000); // Reconnect after 5 seconds\n  };\n}\n\nconnect();\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that connects to a server, sends messages, and displays received messages in a chat interface.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a server when a button is clicked. It handles connection events (open, close, message) and allows sending messages via an input field. The function disables the join button during active connection and re-enables it when closed.\n\nInput: \n- None (the function uses DOM elements internally: username input, join button, chat textarea, and message input field)\n\nOutput: \n- None (the function sets up event listeners and modifies DOM elements directly)\n\nAttributes: N/A (function-level implementation)\n\nMethods: N/A (function-level implementation)",
    "Canonical_solution": "function setupWebSocket() {\n    const username = document.querySelector(\"#username\");\n    const join_btn = document.querySelector(\"#join-chat\");\n    const textarea = document.querySelector(\"#chat\");\n    const input = document.querySelector(\"#input\");\n\n    join_btn.addEventListener(\"click\", function(e) {\n        this.disabled = true;\n\n        const websocket = new WebSocket(\"ws://localhost:3000/websocket\");\n\n        websocket.onopen = function() {\n            console.log(\"connection opened\");\n            websocket.send(username.value);\n        }\n\n        const btn = this;\n\n        websocket.onclose = function() {\n            console.log(\"connection closed\");\n            btn.disabled = false;\n        }\n\n        websocket.onmessage = function(e) {\n            console.log(\"received message: \"+e.data);\n            textarea.value += e.data+\"\\r\\n\";\n        }\n\n        input.onkeydown = function(e) {\n            if (e.key == \"Enter\") {\n                websocket.send(input.value);\n                input.value = \"\";\n            }\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction setupWebSocket() {\n    const usernameInput = document.getElementById('username');\n    const joinButton = document.getElementById('joinButton');\n    const chatTextArea = document.getElementById('chatTextArea');\n    const messageInput = document.getElementById('messageInput');\n    const ws = new WebSocket('ws://example.com/socketserver');\n\n    ws.onopen = function() {\n        joinButton.disabled = true;\n    };\n\n    ws.onclose = function() {\n        joinButton.disabled = false;\n    };\n\n    ws.onmessage = function(event) {\n        chatTextArea.value += event.data + '\\n';\n    };\n\n    joinButton.addEventListener('click', function() {\n        ws.send(usernameInput.value);\n    });\n\n    messageInput.addEventListener('keypress', function(e) {\n        if (e.key === 'Enter') {\n            ws.send(messageInput.value);\n            messageInput.value = '';\n        }\n    });\n}\n```",
      "```javascript\ndocument.addEventListener('DOMContentLoaded', function() {\n    const joinButton = document.getElementById('joinButton');\n    const usernameInput = document.getElementById('usernameInput');\n    const chatTextArea = document.getElementById('chatTextArea');\n    const messageInput = document.getElementById('messageInput');\n    let socket;\n\n    joinButton.addEventListener('click', function() {\n        const username = usernameInput.value;\n        socket = new WebSocket('ws://example.com/socket', 'echo-protocol');\n        socket.onopen = function(event) {\n            joinButton.disabled = true;\n            chatTextArea.value += 'Connected to server\\n';\n        };\n        socket.onclose = function(event) {\n            joinButton.disabled = false;\n            chatTextArea.value += 'Disconnected from server\\n';\n        };\n        socket.onmessage = function(event) {\n            chatTextArea.value += event.data + '\\n';\n        };\n        socket.onerror = function(event) {\n            chatTextArea.value += 'Error: ' + event.data + '\\n';\n        };\n    });\n\n    messageInput.addEventListener('keydown', function(event) {\n        if (event.key === 'Enter') {\n            const message = messageInput.value;\n            socket.send(message);\n            messageInput.value = '';\n        }\n    });\n});\n```",
      "```javascript\nfunction setupWebSocket() {\n  const username = document.getElementById('username').value;\n  const joinButton = document.getElementById('joinButton');\n  const chatTextArea = document.getElementById('chatTextArea');\n  const messageInputField = document.getElementById('messageInputField');\n  const ws = new WebSocket('ws://example.com');\n\n  ws.onopen = function() {\n    joinButton.disabled = true;\n  };\n\n  ws.onclose = function() {\n    joinButton.disabled = false;\n  };\n\n  ws.onmessage = function(event) {\n    chatTextArea.value += event.data + '\\n';\n  };\n\n  messageInputField.addEventListener('keypress', function(e) {\n    if (e.key === 'Enter') {\n      ws.send(messageInputField.value);\n      messageInputField.value = '';\n    }\n  });\n\n  joinButton.addEventListener('click', function() {\n    ws.send('JOIN ' + username);\n  });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n  const username = document.getElementById('username').value;\n  const joinButton = document.getElementById('joinButton');\n  const chatTextArea = document.getElementById('chatTextArea');\n  const messageInputField = document.getElementById('messageInputField');\n  const ws = new WebSocket('ws://example.com');\n\n  ws.onopen = function() {\n    joinButton.disabled = true;\n  };\n\n  ws.onclose = function() {\n    joinButton.disabled = false;\n  };\n\n  ws.onmessage = function(event) {\n    chatTextArea.value += event.data + '\\n';\n  };\n\n  messageInputField.addEventListener('keypress', function(e) {\n    if (e.key === 'Enter') {\n      ws.send(messageInputField.value);\n      messageInputField.value = '';\n    }\n  });\n\n  joinButton.addEventListener('click', function() {\n    ws.send('JOIN ' + username);\n  });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const usernameInput = document.getElementById('username');\n    const joinButton = document.getElementById('joinButton');\n    const chatTextArea = document.getElementById('chatTextArea');\n    const messageInput = document.getElementById('messageInput');\n    const ws = new WebSocket('ws://example.com/socket');\n\n    ws.onopen = function() {\n        joinButton.disabled = true;\n    };\n\n    ws.onclose = function() {\n        joinButton.disabled = false;\n    };\n\n    ws.onmessage = function(event) {\n        chatTextArea.value += event.data + '\\n';\n    };\n\n    joinButton.addEventListener('click', function() {\n        ws.send(usernameInput.value);\n    });\n\n    messageInput.addEventListener('keypress', function(e) {\n        if (e.key === 'Enter') {\n            ws.send(messageInput.value);\n            messageInput.value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n  const usernameInput = document.getElementById('username');\n  const joinButton = document.getElementById('joinButton');\n  const chatTextArea = document.getElementById('chatTextArea');\n  const messageInput = document.getElementById('messageInput');\n  const ws = new WebSocket('ws://example.com/socket');\n\n  ws.onopen = function() {\n    joinButton.disabled = true;\n    chatTextArea.value += 'Connected to server\\n';\n  };\n\n  ws.onclose = function() {\n    joinButton.disabled = false;\n    chatTextArea.value += 'Disconnected from server\\n';\n  };\n\n  ws.onmessage = function(event) {\n    chatTextArea.value += event.data + '\\n';\n  };\n\n  joinButton.addEventListener('click', function() {\n    ws.send(usernameInput.value);\n  });\n\n  messageInput.addEventListener('keypress', function(e) {\n    if (e.key === 'Enter') {\n      ws.send(messageInput.value);\n      messageInput.value = '';\n    }\n  });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n  const usernameInput = document.getElementById('username');\n  const joinButton = document.getElementById('joinButton');\n  const chatTextArea = document.getElementById('chatTextArea');\n  const messageInput = document.getElementById('messageInput');\n  const ws = new WebSocket('ws://example.com/socketserver');\n\n  ws.onopen = function() {\n    joinButton.disabled = true;\n  };\n\n  ws.onclose = function() {\n    joinButton.disabled = false;\n  };\n\n  ws.onmessage = function(event) {\n    chatTextArea.value += event.data + '\\n';\n  };\n\n  joinButton.addEventListener('click', function() {\n    ws.send(usernameInput.value);\n  });\n\n  messageInput.addEventListener('keypress', function(e) {\n    if (e.key === 'Enter') {\n      ws.send(messageInput.value);\n      messageInput.value = '';\n    }\n  });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const usernameInput = document.getElementById('username');\n    const joinButton = document.getElementById('joinButton');\n    const chatTextArea = document.getElementById('chatTextArea');\n    const messageInput = document.getElementById('messageInput');\n    const ws = new WebSocket('ws://example.com/socketserver');\n\n    ws.onopen = function() {\n        joinButton.disabled = true;\n        chatTextArea.value += 'Connected to server\\n';\n    };\n\n    ws.onmessage = function(event) {\n        chatTextArea.value += event.data + '\\n';\n    };\n\n    ws.onclose = function() {\n        joinButton.disabled = false;\n        chatTextArea.value += 'Disconnected from server\\n';\n    };\n\n    ws.onerror = function(error) {\n        chatTextArea.value += 'WebSocket Error: ' + error + '\\n';\n    };\n\n    joinButton.addEventListener('click', function() {\n        ws.send(usernameInput.value);\n    });\n\n    messageInput.addEventListener('keypress', function(event) {\n        if (event.key === 'Enter') {\n            ws.send(messageInput.value);\n            messageInput.value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n  const usernameInput = document.getElementById('username');\n  const joinButton = document.getElementById('joinButton');\n  const chatTextArea = document.getElementById('chatTextArea');\n  const messageInputField = document.getElementById('messageInputField');\n  const ws = new WebSocket('wss://example.com/socket');\n\n  ws.onopen = function() {\n    joinButton.disabled = true;\n  };\n\n  ws.onclose = function() {\n    joinButton.disabled = false;\n  };\n\n  ws.onmessage = function(event) {\n    chatTextArea.value += event.data + '\\n';\n  };\n\n  joinButton.addEventListener('click', function() {\n    ws.send(usernameInput.value);\n  });\n\n  messageInputField.addEventListener('keypress', function(event) {\n    if (event.key === 'Enter') {\n      ws.send(messageInputField.value);\n      messageInputField.value = '';\n    }\n  });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const usernameInput = document.getElementById('username');\n    const joinButton = document.getElementById('joinButton');\n    const chatTextArea = document.getElementById('chatTextArea');\n    const messageInput = document.getElementById('messageInput');\n    const ws = new WebSocket('ws://example.com/socketserver');\n\n    ws.onopen = function() {\n        joinButton.disabled = true;\n    };\n\n    ws.onclose = function() {\n        joinButton.disabled = false;\n    };\n\n    ws.onmessage = function(event) {\n        chatTextArea.value += event.data + '\\n';\n    };\n\n    joinButton.addEventListener('click', function() {\n        ws.send(usernameInput.value);\n    });\n\n    messageInput.addEventListener('keypress', function(e) {\n        if (e.key === 'Enter') {\n            ws.send(messageInput.value);\n            messageInput.value = '';\n        }\n    });\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, handles incoming messages, sends periodic ping messages, and manages connection events.\n\nFunction Description: The `initWebSocket` function initializes a WebSocket connection to a specified URL. It sets up event handlers for connection events (`onopen`, `onclose`, `onerror`) and message reception (`onmessage`). Upon successful connection, it sends periodic ping messages to the server. Incoming messages are parsed and processed based on their type (e.g., binding a user, displaying new messages, or showing login messages).\n\nInput: None (The function uses `window.websocket.connect_url` and `window.websocket.ping_interval` from the global scope for configuration.)\n\nOutput: None (The function logs events to the console and triggers other functions like `bindUser`, `showNewMessage`, and `showLoginMessage` based on incoming messages.)",
    "Canonical_solution": "function initWebSocket() {\n    var socket = new WebSocket(window.websocket.connect_url);\n    \n    socket.onopen = function () {\n        console.log('socket connect success');\n        setInterval(function () {\n            socket.send('ping');\n            console.log('ping...');\n        }, 1000 * parseInt(window.websocket.ping_interval));\n    };\n\n    socket.onclose = function () {\n        console.log('socket connect close');\n    };\n\n    socket.onerror = function () {\n        console.log('socket connect error');\n    };\n\n    socket.onmessage = function (e) {\n        var data = JSON.parse(e.data);\n        console.log(data);\n        if (data.type === 'bind_user') {\n            bindUser(data.client_id);\n        } else if (data.type === 'new_message') {\n            showNewMessage(data);\n        } else if (data.type === 'new_user') {\n            showLoginMessage(data);\n        }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send(JSON.stringify({ type: 'ping' }));\n    }, window.websocket.ping_interval);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error', error);\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.data);\n        break;\n      case 'message':\n        showNewMessage(message.data);\n        break;\n      case 'login':\n        showLoginMessage(message.data);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nwindow.onload = initWebSocket;\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send('ping');\n    }, window.websocket.ping_interval);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.data);\n        break;\n      case 'message':\n        showNewMessage(message.data);\n        break;\n      case 'login':\n        showLoginMessage(message.data);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nfunction bindUser(data) {\n  console.log('User bound:', data);\n}\n\nfunction showNewMessage(data) {\n  console.log('New message:', data);\n}\n\nfunction showLoginMessage(data) {\n  console.log('Login message:', data);\n}\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send(JSON.stringify({ type: 'ping' }));\n    }, window.websocket.ping_interval);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event);\n  };\n\n  ws.onerror = (error) => {\n    console.log('WebSocket error', error);\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.data);\n        break;\n      case 'message':\n        showNewMessage(message.data);\n        break;\n      case 'login':\n        showLoginMessage(message.data);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nfunction bindUser(data) {\n  console.log('User bound:', data);\n}\n\nfunction showNewMessage(data) {\n  console.log('New message:', data);\n}\n\nfunction showLoginMessage(data) {\n  console.log('Login message:', data);\n}\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send(JSON.stringify({ type: 'ping' }));\n    }, window.websocket.ping_interval);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error', error);\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.user);\n        break;\n      case 'message':\n        showNewMessage(message);\n        break;\n      case 'login':\n        showLoginMessage(message);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nfunction bindUser(user) {\n  console.log('User bound:', user);\n}\n\nfunction showNewMessage(message) {\n  console.log('New message:', message);\n}\n\nfunction showLoginMessage(message) {\n  console.log('Login message:', message);\n}\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send(JSON.stringify({ type: 'ping' }));\n    }, window.websocket.ping_interval);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error', error);\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.user);\n        break;\n      case 'message':\n        showNewMessage(message);\n        break;\n      case 'login':\n        showLoginMessage(message);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nfunction bindUser(user) {\n  console.log('User bound:', user);\n}\n\nfunction showNewMessage(message) {\n  console.log('New message:', message);\n}\n\nfunction showLoginMessage(message) {\n  console.log('Login message:', message);\n}\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send('ping');\n    }, window.websocket.ping_interval);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.data);\n        break;\n      case 'message':\n        showNewMessage(message.data);\n        break;\n      case 'login':\n        showLoginMessage(message.data);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nfunction bindUser(data) {\n  console.log('User bound:', data);\n}\n\nfunction showNewMessage(data) {\n  console.log('New message:', data);\n}\n\nfunction showLoginMessage(data) {\n  console.log('Login message:', data);\n}\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send('ping');\n    }, window.websocket.ping_interval);\n  };\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.data);\n        break;\n      case 'message':\n        showNewMessage(message.data);\n        break;\n      case 'login':\n        showLoginMessage(message.data);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nfunction bindUser(data) {\n  console.log('User bound:', data);\n}\n\nfunction showNewMessage(data) {\n  console.log('New message:', data);\n}\n\nfunction showLoginMessage(data) {\n  console.log('Login message:', data);\n}\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send('ping');\n    }, window.websocket.ping_interval);\n  };\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.data);\n        break;\n      case 'message':\n        showNewMessage(message.data);\n        break;\n      case 'login':\n        showLoginMessage(message.data);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nfunction bindUser(data) {\n  console.log('User bound:', data);\n}\n\nfunction showNewMessage(data) {\n  console.log('New message:', data);\n}\n\nfunction showLoginMessage(data) {\n  console.log('Login message:', data);\n}\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send(JSON.stringify({ type: 'ping' }));\n    }, window.websocket.ping_interval);\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error', error);\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.user);\n        break;\n      case 'message':\n        showNewMessage(message.content);\n        break;\n      case 'login':\n        showLoginMessage(message.message);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nwindow.onload = initWebSocket;\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket(window.websocket.connect_url);\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    setInterval(() => {\n      ws.send(JSON.stringify({ type: 'ping' }));\n    }, window.websocket.ping_interval);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case 'bind':\n        bindUser(message.data);\n        break;\n      case 'message':\n        showNewMessage(message.data);\n        break;\n      case 'login':\n        showLoginMessage(message.data);\n        break;\n      default:\n        console.log('Received unknown message type:', message.type);\n    }\n  };\n};\n\nfunction bindUser(data) {\n  console.log('User bound:', data);\n}\n\nfunction showNewMessage(data) {\n  console.log('New message:', data);\n}\n\nfunction showLoginMessage(data) {\n  console.log('Login message:', data);\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 233,
    "Instruction": "Task Description: Create a WebSocket client function that establishes a connection to a specified URL, handles incoming messages, and provides methods to set a callback for received data and close the connection.\n\nFunction Description: The `Stream` function initializes a WebSocket connection to the given URL. It sets up event handlers for the connection opening and incoming messages. The incoming messages are parsed as JSON and passed to a callback function. The function returns an object with methods to set the callback for received data (`ontrades`) and to close the WebSocket connection (`off`).\n\nInput: \n- `url` [String] - The WebSocket server URL to connect to.\n\nOutput: \n- Returns an object with the following methods:\n  - `ontrades` [Function] - Setter for the callback function that handles incoming data.\n  - `off` [Function] - Closes the WebSocket connection with code 1000 (normal closure).",
    "Canonical_solution": "function Stream(url) {\n    var ws = new WebSocket(url);\n    var cb = () => {};\n\n    ws.onopen = function() {\n        console.log('Websocket is opened');\n    };\n\n    ws.onmessage = function(data) {\n        try {\n            data = JSON.parse(data.data);\n            cb(data);\n        } catch(e) {\n            console.log(e);\n        }\n    };\n\n    return {\n        set ontrades(val) { cb = val; },\n        off() { ws.close(1000); }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction Stream(url) {\n  let ws = new WebSocket(url);\n  let ontrades = null;\n\n  ws.onopen = function() {\n    ws.onmessage = function(event) {\n      try {\n        const data = JSON.parse(event.data);\n        if (ontrades) {\n          ontrades(data);\n        }\n      } catch (e) {\n        console.error('Error parsing incoming data:', e);\n      }\n    };\n  };\n\n  return {\n    ontrades: function(callback) {\n      ontrades = callback;\n    },\n    off: function() {\n      ws.close(1000);\n    }\n  };\n}\n```",
      "```javascript\nconst Stream = (url) => {\n  const ws = new WebSocket(url);\n  let ontradesCallback = null;\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (ontradesCallback) {\n        ontradesCallback(data);\n      }\n    } catch (error) {\n      console.error('Error parsing incoming data:', error);\n    }\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    ontrades: (callback) => {\n      ontradesCallback = callback;\n    },\n    off: () => {\n      ws.close(1000);\n    }\n  };\n};\n```",
      "```javascript\nconst Stream = (url) => {\n  const ws = new WebSocket(url);\n  let ontradesCallback = null;\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (ontradesCallback) {\n        ontradesCallback(data);\n      }\n    } catch (error) {\n      console.error('Error parsing incoming message:', error);\n    }\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    ontrades: (callback) => {\n      ontradesCallback = callback;\n    },\n    off: () => {\n      ws.close(1000);\n    }\n  };\n};\n```",
      "```javascript\nfunction Stream(url) {\n  let ws = new WebSocket(url);\n  let ontrades = null;\n\n  ws.onopen = function() {\n    ws.send(JSON.stringify({ type: 'subscribe', channel: 'trades' }));\n  };\n\n  ws.onmessage = function(event) {\n    if (ontrades) {\n      try {\n        const data = JSON.parse(event.data);\n        ontrades(data);\n      } catch (error) {\n        console.error('Error parsing incoming message:', error);\n      }\n    }\n  };\n\n  return {\n    ontrades: function(callback) {\n      ontrades = callback;\n    },\n    off: function() {\n      ws.close(1000);\n    }\n  };\n}\n```",
      "```javascript\nconst Stream = (url) => {\n  const ws = new WebSocket(url);\n  let ontradesCallback = null;\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (ontradesCallback) {\n        ontradesCallback(data);\n      }\n    } catch (error) {\n      console.error('Error parsing incoming message:', error);\n    }\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    ontrades: (callback) => {\n      ontradesCallback = callback;\n    },\n    off: () => {\n      ws.close(1000);\n    }\n  };\n};\n```",
      "```javascript\nconst Stream = (url) => {\n  const ws = new WebSocket(url);\n  let ontradesCallback = null;\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (ontradesCallback) {\n        ontradesCallback(data);\n      }\n    } catch (error) {\n      console.error('Error parsing incoming message:', error);\n    }\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed:', event);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    ontrades: (callback) => {\n      ontradesCallback = callback;\n    },\n    off: () => {\n      ws.close(1000);\n    }\n  };\n};\n```",
      "```javascript\nconst Stream = (url) => {\n  const ws = new WebSocket(url);\n  let ontradesCallback = null;\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (ontradesCallback) {\n        ontradesCallback(data);\n      }\n    } catch (error) {\n      console.error('Error parsing incoming message:', error);\n    }\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    ontrades: (callback) => {\n      ontradesCallback = callback;\n    },\n    off: () => {\n      ws.close(1000);\n    }\n  };\n};\n```",
      "```javascript\nconst Stream = (url) => {\n  const ws = new WebSocket(url);\n  let ontradesCallback = null;\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (ontradesCallback) {\n        ontradesCallback(data);\n      }\n    } catch (error) {\n      console.error('Error parsing incoming message:', error);\n    }\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    ontrades: (callback) => {\n      ontradesCallback = callback;\n    },\n    off: () => {\n      ws.close(1000);\n    }\n  };\n};\n```",
      "```javascript\nconst Stream = (url) => {\n  let ws = new WebSocket(url);\n  let ontrades = null;\n\n  ws.onopen = () => {\n    ws.send(JSON.stringify({ type: 'subscribe', channels: ['trades'] }));\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (ontrades) {\n        ontrades(data);\n      }\n    } catch (e) {\n      console.error('Error parsing incoming message:', e);\n    }\n  };\n\n  return {\n    ontrades: (cb) => {\n      ontrades = cb;\n    },\n    off: () => {\n      ws.close(1000);\n    }\n  };\n};\n```",
      "```javascript\nconst Stream = (url) => {\n  const ws = new WebSocket(url);\n  let ontradesCallback = null;\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (ontradesCallback) {\n        ontradesCallback(data);\n      }\n    } catch (error) {\n      console.error('Error parsing incoming message:', error);\n    }\n  };\n\n  ws.onclose = (event) => {\n    console.log('WebSocket connection closed', event);\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    ontrades: (callback) => {\n      ontradesCallback = callback;\n    },\n    off: () => {\n      ws.close(1000);\n    }\n  };\n};\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 234,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends and receives messages, and manages errors and connection closure.\n\nFunction Description: The function `testWebSocket` initializes a WebSocket connection to a specified URI and sets up event handlers for connection opening, closing, message reception, and errors. The event handlers (`onOpen`, `onClose`, `onMessage`, `onError`) manage the respective events, while `sendMessage` sends messages to the server.\n\nInput: \n- `wsUri` [String] - The WebSocket server URI to connect to.\n\nOutput: \n- None (The function sets up event handlers and manages WebSocket connection lifecycle).",
    "Canonical_solution": "function testWebSocket() {\n    websocket = new WebSocket(wsUri);\n    websocket.onopen = onOpen;\n    websocket.onclose = onClose;\n    websocket.onmessage = onMessage;\n    websocket.onerror = onError;\n}\n\nfunction onOpen(evt) {\n    writeLog(\"CONNECTED\");\n    sendMessage(\"Hello, Rocket!\");\n}\n\nfunction onClose(evt) {\n    writeLog(\"Websocket DISCONNECTED\");\n}\n\nfunction onMessage(evt) {\n    writeLog('<span style=\"color: blue;\">RESPONSE: ' + evt.data+'</span>');\n}\n\nfunction onError(evt) {\n    writeLog('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nfunction sendMessage(message) {\n    writeLog(\"SENT: \" + message);\n    websocket.send(message);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(event) {\n        onOpen(event);\n    };\n\n    ws.onclose = function(event) {\n        onClose(event);\n    };\n\n    ws.onmessage = function(event) {\n        onMessage(event);\n    };\n\n    ws.onerror = function(event) {\n        onError(event);\n    };\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n\n    function onOpen(event) {\n        console.log('Connection opened');\n    }\n\n    function onClose(event) {\n        console.log('Connection closed');\n    }\n\n    function onMessage(event) {\n        console.log('Message received: ' + event.data);\n    }\n\n    function onError(event) {\n        console.log('Error occurred: ' + event.message);\n    }\n}\n```",
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function() {\n        onOpen();\n    };\n\n    ws.onclose = function() {\n        onClose();\n    };\n\n    ws.onmessage = function(event) {\n        onMessage(event.data);\n    };\n\n    ws.onerror = function(error) {\n        onError(error);\n    };\n\n    function onOpen() {\n        console.log('Connection opened');\n    }\n\n    function onClose() {\n        console.log('Connection closed');\n    }\n\n    function onMessage(message) {\n        console.log('Message received: ' + message);\n    }\n\n    function onError(error) {\n        console.log('Error occurred: ' + error.message);\n    }\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n}\n```",
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(event) {\n        onOpen(event);\n    };\n\n    ws.onclose = function(event) {\n        onClose(event);\n    };\n\n    ws.onmessage = function(event) {\n        onMessage(event);\n    };\n\n    ws.onerror = function(event) {\n        onError(event);\n    };\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n\n    function onOpen(event) {\n        console.log('Connection opened');\n    }\n\n    function onClose(event) {\n        console.log('Connection closed');\n    }\n\n    function onMessage(event) {\n        console.log('Message received: ' + event.data);\n    }\n\n    function onError(event) {\n        console.log('Error occurred: ' + event.message);\n    }\n}\n```",
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(event) {\n        onOpen(event);\n    };\n\n    ws.onclose = function(event) {\n        onClose(event);\n    };\n\n    ws.onmessage = function(event) {\n        onMessage(event);\n    };\n\n    ws.onerror = function(event) {\n        onError(event);\n    };\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n\n    function onOpen(event) {\n        console.log('Connection opened');\n    }\n\n    function onClose(event) {\n        console.log('Connection closed');\n    }\n\n    function onMessage(event) {\n        console.log('Message received: ' + event.data);\n    }\n\n    function onError(event) {\n        console.log('Error occurred: ' + event.message);\n    }\n}\n```",
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(event) {\n        onOpen(event);\n    };\n\n    ws.onclose = function(event) {\n        onClose(event);\n    };\n\n    ws.onmessage = function(event) {\n        onMessage(event);\n    };\n\n    ws.onerror = function(event) {\n        onError(event);\n    };\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n\n    function onOpen(event) {\n        console.log('Connection opened');\n    }\n\n    function onClose(event) {\n        console.log('Connection closed');\n    }\n\n    function onMessage(event) {\n        console.log('Message received: ' + event.data);\n    }\n\n    function onError(event) {\n        console.log('Error occurred: ' + event.message);\n    }\n}\n```",
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(event) {\n        onOpen(event);\n    };\n\n    ws.onclose = function(event) {\n        onClose(event);\n    };\n\n    ws.onmessage = function(event) {\n        onMessage(event);\n    };\n\n    ws.onerror = function(event) {\n        onError(event);\n    };\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n\n    function onOpen(event) {\n        console.log('Connection opened');\n    }\n\n    function onClose(event) {\n        console.log('Connection closed');\n    }\n\n    function onMessage(event) {\n        console.log('Message received: ' + event.data);\n    }\n\n    function onError(event) {\n        console.log('Error occurred: ' + event.message);\n    }\n}\n```",
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(event) {\n        onOpen(event);\n    };\n\n    ws.onclose = function(event) {\n        onClose(event);\n    };\n\n    ws.onmessage = function(event) {\n        onMessage(event);\n    };\n\n    ws.onerror = function(event) {\n        onError(event);\n    };\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n\n    function onOpen(event) {\n        console.log('Connection opened');\n    }\n\n    function onClose(event) {\n        console.log('Connection closed');\n    }\n\n    function onMessage(event) {\n        console.log('Message received: ' + event.data);\n    }\n\n    function onError(event) {\n        console.log('Error occurred: ' + event.message);\n    }\n}\n```",
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function() {\n        onOpen();\n    };\n\n    ws.onclose = function() {\n        onClose();\n    };\n\n    ws.onmessage = function(event) {\n        onMessage(event);\n    };\n\n    ws.onerror = function(error) {\n        onError(error);\n    };\n\n    function onOpen() {\n        console.log('Connection opened');\n    }\n\n    function onClose() {\n        console.log('Connection closed');\n    }\n\n    function onMessage(event) {\n        console.log('Message received: ' + event.data);\n    }\n\n    function onError(error) {\n        console.log('Error occurred: ' + error.message);\n    }\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onOpen = function(event) {\n        console.log('Connection opened');\n    };\n\n    ws.onClose = function(event) {\n        console.log('Connection closed');\n    };\n\n    ws.onMessage = function(event) {\n        console.log('Message received: ' + event.data);\n    };\n\n    ws.onError = function(error) {\n        console.log('Error occurred: ' + error.message);\n    };\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n}\n```",
      "```javascript\nfunction testWebSocket(wsUri) {\n    var ws = new WebSocket(wsUri);\n\n    ws.onOpen = function() {\n        console.log('Connection opened');\n    };\n\n    ws.onClose = function() {\n        console.log('Connection closed');\n    };\n\n    ws.onMessage = function(event) {\n        console.log('Message received: ' + event.data);\n    };\n\n    ws.onError = function(error) {\n        console.log('Error occurred: ' + error.message);\n    };\n\n    function sendMessage(message) {\n        ws.send(message);\n    }\n}\n```"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, handles various connection events, sends periodic ping messages, and provides functions to join/leave rooms and close the connection.\n\nFunction Description: The functions collectively manage a WebSocket connection, including initialization, sending messages, and cleanup. The main function initializes the connection and sets up event handlers, while helper functions send specific message types and close the connection.\n\nInput:\n- initWebSocket(): No parameters\n- sendJoinMessage(ws, room): \n  - ws: WebSocket - The active WebSocket connection\n  - room: string - The room identifier to join\n- sendLeaveMessage(ws, room):\n  - ws: WebSocket - The active WebSocket connection\n  - room: string - The room identifier to leave\n- closeWebSocket(ws):\n  - ws: WebSocket - The active WebSocket connection to close\n\nOutput:\n- initWebSocket(): Returns WebSocket - The initialized WebSocket connection object\n- sendJoinMessage(): Returns boolean - Always returns false\n- sendLeaveMessage(): Returns boolean - Always returns false\n- closeWebSocket(): Returns boolean - Always returns false",
    "Canonical_solution": "function initWebSocket() {\n    var ws;\n    ws = new WebSocket(\"ws://localhost:7777/connect\");\n    ws.onopen = function(evt) {\n        print(\"OPEN\");\n    }\n    ws.onclose = function(evt) {\n        print(\"CLOSE\");\n        ws = null;\n    }\n    ws.onmessage = function(evt) {\n        print(\"RESPONSE: \" + evt.data);\n    }\n    ws.onerror = function(evt) {\n        print(\"ERROR: \" + evt.data);\n    }\n    setInterval(function() {\n        ws.send(JSON.stringify({type: \"PING\", data: {}}))\n    }, 10000)\n    return ws;\n}\n\nfunction sendJoinMessage(ws, room) {\n    if (!ws) {\n        return false;\n    }\n    print(\"JOIN: \" + room);\n    ws.send(JSON.stringify({type: \"JOIN\", data: {room: room}}));\n    return false;\n}\n\nfunction sendLeaveMessage(ws, room) {\n    if (!ws) {\n        return false;\n    }\n    print(\"LEAVE: \" + room);\n    ws.send(JSON.stringify({type: \"LEAVE\", data: {room: room}}));\n    return false;\n}\n\nfunction closeWebSocket(ws) {\n    if (!ws) {\n        return false;\n    }\n    ws.close();\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket() {\n  ws.close();\n  return false;\n}\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  console.log('Message received:', data);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nsetInterval(() => {\n  ws.send(JSON.stringify({ type: 'ping' }));\n}, 10000);\n```",
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket(ws) {\n  ws.close();\n  return false;\n}\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  console.log('Message from server:', data);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nsetInterval(() => {\n  ws.send(JSON.stringify({ type: 'ping' }));\n}, 30000);\n```",
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket() {\n  ws.close();\n  return false;\n}\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  console.log('Message received:', data);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nsetInterval(() => {\n  ws.send(JSON.stringify({ type: 'ping' }));\n}, 30000);\n```",
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket(ws) {\n  ws.close();\n  return false;\n}\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  console.log('Message received:', data);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nsetInterval(() => {\n  ws.send(JSON.stringify({ type: 'ping' }));\n}, 10000);\n```",
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket(ws) {\n  ws.close();\n  return false;\n}\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  console.log('Message received:', data);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nsetInterval(() => {\n  ws.send(JSON.stringify({ type: 'ping' }));\n}, 10000);\n```",
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket(ws) {\n  ws.close();\n  return false;\n}\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  console.log('Message received:', data);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nsetInterval(() => {\n  ws.send(JSON.stringify({ type: 'ping' }));\n}, 30000);\n```",
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket() {\n  ws.close();\n  return false;\n}\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  console.log('Message received:', data);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nsetInterval(() => {\n  ws.send(JSON.stringify({ type: 'ping' }));\n}, 30000);\n```",
      "```javascript\nconst initWebSocket = () => {\n  const ws = new WebSocket('ws://example.com/socket');\n  ws.onopen = () => console.log('WebSocket connection established');\n  ws.onmessage = (event) => console.log('Message from server:', event.data);\n  ws.onerror = (error) => console.error('WebSocket error:', error);\n  ws.onclose = () => console.log('WebSocket connection closed');\n  return ws;\n};\n\nconst sendJoinMessage = (ws, room) => {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n};\n\nconst sendLeaveMessage = (ws, room) => {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n};\n\nconst closeWebSocket = (ws) => {\n  ws.close();\n  return false;\n};\n```",
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket(ws) {\n  ws.close();\n  return false;\n}\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n};\n\nws.onmessage = function(event) {\n  const data = JSON.parse(event.data);\n  console.log('Message from server:', data);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nsetInterval(() => {\n  ws.send(JSON.stringify({ type: 'ping' }));\n}, 30000);\n```",
      "```javascript\nconst ws = new WebSocket('ws://example.com/socket');\n\nfunction initWebSocket() {\n  return ws;\n}\n\nfunction sendJoinMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'join', room: room }));\n  return false;\n}\n\nfunction sendLeaveMessage(ws, room) {\n  ws.send(JSON.stringify({ type: 'leave', room: room }));\n  return false;\n}\n\nfunction closeWebSocket(ws) {\n  ws.close();\n  return false;\n}\n\nws.onopen = function(event) {\n  // Handle open event\n};\n\nws.onmessage = function(event) {\n  // Handle message event\n};\n\nws.onerror = function(error) {\n  // Handle error event\n};\n\nws.onclose = function(event) {\n  // Handle close event\n};\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections, handles events (connection, messages, errors, closing), and provides methods to start listening and close the connection.\n\nClass Description: The WebSocketStore class manages WebSocket connections for real-time communication. It handles connection lifecycle events, automatically reconnects on failure, and provides clean connection closure. It integrates with authentication and notification systems.\n\nAttributes:\n- wsActive: boolean - Tracks whether a WebSocket connection is currently active.\n- ws: WebSocket | null - Holds the active WebSocket connection instance.\n\nMethods:\n- constructor(snack: SnackReporter, currentUser: CurrentUser) -> void - Initializes the WebSocketStore with notification and user authentication dependencies.\n- listen(callback: (msg: IMessage) => void) -> void - Establishes a WebSocket connection and sets up event handlers. Takes a callback function for incoming messages.\n- close() -> void - Properly closes the WebSocket connection with status code 1000 (normal closure).",
    "Canonical_solution": "import {SnackReporter} from '../snack/SnackManager';\nimport {CurrentUser} from '../CurrentUser';\nimport * as config from '../config';\nimport {AxiosError} from 'axios';\nimport {IMessage} from '../types';\n\nexport class WebSocketStore {\n    private wsActive = false;\n    private ws: WebSocket | null = null;\n\n    public constructor(\n        private readonly snack: SnackReporter,\n        private readonly currentUser: CurrentUser\n    ) {}\n\n    public listen = (callback: (msg: IMessage) => void) => {\n        if (!this.currentUser.token() || this.wsActive) {\n            return;\n        }\n        this.wsActive = true;\n\n        const wsUrl = config.get('url').replace('http', 'ws').replace('https', 'wss');\n        const ws = new WebSocket(wsUrl + 'stream?token=' + this.currentUser.token());\n\n        ws.onerror = (e) => {\n            this.wsActive = false;\n            console.log('WebSocket connection errored', e);\n        };\n\n        ws.onmessage = (data) => callback(JSON.parse(data.data));\n\n        ws.onclose = () => {\n            this.wsActive = false;\n            this.currentUser\n                .tryAuthenticate()\n                .then(() => {\n                    this.snack('WebSocket connection closed, trying again in 30 seconds.');\n                    setTimeout(() => this.listen(callback), 30000);\n                })\n                .catch((error: AxiosError) => {\n                    if (error?.response?.status === 401) {\n                        this.snack('Could not authenticate with client token, logging out.');\n                    }\n                });\n        };\n\n        this.ws = ws;\n    };\n\n    public close = () => this.ws?.close(1000, 'WebSocketStore#close');\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const url = `wss://example.com/socket?user=${currentUser.id}`;\n    this.ws = new WebSocket(url);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connected');\n    };\n\n    this.ws.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      callback(msg);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n      this.reconnect();\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket disconnected');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    if (!this.wsActive) {\n      setTimeout(() => {\n        this.listen();\n      }, 5000);\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const url = `wss://example.com/socket?user=${currentUser.id}`;\n    this.ws = new WebSocket(url);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connection established');\n    };\n\n    this.ws.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      callback(msg);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n      this.reconnect();\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket connection closed');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    if (!this.wsActive) {\n      setTimeout(() => {\n        this.listen();\n      }, 5000);\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const url = `wss://example.com/socket?user=${currentUser.id}`;\n    this.ws = new WebSocket(url);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connection established');\n    };\n\n    this.ws.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      callback(msg);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n      this.reconnect();\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket connection closed');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    if (!this.wsActive) {\n      setTimeout(() => {\n        this.listen();\n      }, 5000);\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const wsUrl = `wss://example.com/socket?user=${currentUser.id}`;\n    this.ws = new WebSocket(wsUrl);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connected');\n    };\n\n    this.ws.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      callback(msg);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n      this.reconnect();\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket disconnected');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    if (!this.wsActive) {\n      setTimeout(() => {\n        this.listen();\n      }, 5000);\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const url = `wss://example.com/socket?user=${currentUser.id}`;\n    this.ws = new WebSocket(url);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connected');\n    };\n\n    this.ws.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      callback(msg);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n      this.reconnect();\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket disconnected');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (!this.wsActive) {\n        this.listen();\n      }\n    }, 5000);\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const wsUrl = `wss://example.com/socket?user=${currentUser.id}`;\n    this.ws = new WebSocket(wsUrl);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connected');\n    };\n\n    this.ws.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      callback(msg);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n      this.reconnect();\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket disconnected');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    if (!this.wsActive) {\n      setTimeout(() => {\n        this.listen();\n      }, 5000);\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const wsUrl = `wss://example.com/socket?user=${currentUser.id}`;\n    this.ws = new WebSocket(wsUrl);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connection established');\n    };\n\n    this.ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      callback(message);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n      this.reconnect();\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket connection closed');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    if (!this.wsActive) {\n      setTimeout(() => {\n        this.listen();\n      }, 5000);\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const url = `wss://example.com/socket?token=${this.currentUser.token}`;\n    this.ws = new WebSocket(url);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connected');\n    };\n\n    this.ws.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      callback(msg);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n      this.reconnect();\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket disconnected');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (!this.wsActive) {\n        this.listen();\n      }\n    }, 5000);\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n  constructor(snack, currentUser) {\n    this.wsActive = false;\n    this.ws = null;\n  }\n\n  listen(callback) {\n    const wsUrl = `wss://example.com/socket?user=${currentUser.id}`;\n    this.ws = new WebSocket(wsUrl);\n\n    this.ws.onopen = () => {\n      this.wsActive = true;\n      snack.notify('WebSocket connection established');\n    };\n\n    this.ws.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      callback(msg);\n    };\n\n    this.ws.onerror = (error) => {\n      snack.notify('WebSocket error: ' + error.message);\n      this.wsActive = false;\n    };\n\n    this.ws.onclose = () => {\n      this.wsActive = false;\n      snack.notify('WebSocket connection closed');\n      this.reconnect();\n    };\n  }\n\n  close() {\n    if (this.ws) {\n      this.ws.close(1000);\n    }\n  }\n\n  reconnect() {\n    if (!this.wsActive) {\n      setTimeout(() => {\n        this.listen();\n      }, 5000);\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketStore {\n    constructor(snack, currentUser) {\n        this.wsActive = false;\n        this.ws = null;\n    }\n\n    listen(callback) {\n        const url = `wss://example.com/socket?user=${currentUser.id}`;\n        this.ws = new WebSocket(url);\n\n        this.ws.onopen = () => {\n            this.wsActive = true;\n            snack.notify('WebSocket connected');\n        };\n\n        this.ws.onmessage = (event) => {\n            const msg = JSON.parse(event.data);\n            callback(msg);\n        };\n\n        this.ws.onerror = (error) => {\n            snack.notify('WebSocket error: ' + error.message);\n            this.wsActive = false;\n            this.reconnect();\n        };\n\n        this.ws.onclose = () => {\n            this.wsActive = false;\n            snack.notify('WebSocket disconnected');\n            this.reconnect();\n        };\n    }\n\n    close() {\n        if (this.ws) {\n            this.ws.close(1000);\n        }\n    }\n\n    reconnect() {\n        setTimeout(() => {\n            if (!this.wsActive) {\n                this.listen();\n            }\n        }, 5000);\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a WebSocketRPC class that handles WebSocket communication for JSON-RPC 2.0 protocol, including connection management, message handling, and error recovery.\n\nClass Description: The WebSocketRPC class provides a wrapper around browser WebSocket API to facilitate JSON-RPC 2.0 communication. It manages WebSocket connections, handles message serialization/deserialization, and provides callback mechanisms for RPC operations.\n\nAttributes:\n- _: [Object] - Lodash/underscore utility library\n- JSON: [Object] - JSON object for serialization/deserialization\n- utils: [Object] - Utility functions including UUID generation\n- alerts: [Object] - Alert/notification system\n- initialized: [Boolean] - Connection status flag\n- handles: [Array] - Pending RPC request handlers\n- sock: [WebSocket|null] - WebSocket connection instance\n- conf: [Object|null] - Connection configuration\n- scheme: [String] - WebSocket protocol scheme (ws/wss)\n- onready: [Function|null] - Callback when connection is ready\n\nMethods:\n- onerror(ev): [Function]([Event]) -> [void] - Handles WebSocket errors and cleans up pending requests\n- onclose(ev): [Function]([Event]) -> [void] - Handles WebSocket connection closure\n- onopen(): [Function]() -> [void] - Handles successful WebSocket connection\n- onmessage(message): [Function]([MessageEvent]) -> [void] - Processes incoming WebSocket messages\n- invoke(opts): [Function]([Object]) -> [void] - Sends JSON-RPC request\n  - opts: [Object] - Request options containing:\n    - name: [String] - RPC method name\n    - params: [Array] - RPC parameters\n    - success: [Function] - Success callback\n    - error: [Function] - Error callback\n- init(conf, onready): [Function]([Object], [Function]) -> [void] - Initializes WebSocket connection\n  - conf: [Object] - Connection configuration containing:\n    - host: [String] - Server host\n    - port: [Number] - Server port\n    - path: [String] - Optional path\n    - encrypt: [Boolean] - Use SSL/TLS\n    - auth: [Object] - Optional authentication credentials\n      - user: [String] - Username\n      - pass: [String] - Password\n  - onready: [Function] - Callback when initialization completes",
    "Canonical_solution": "import angular from \"angular\";\n\nclass WebSocketRPC {\n  constructor(_, JSON, name, utils, alerts) {\n    this._ = _;\n    this.JSON = JSON;\n    this.utils = utils;\n    this.alerts = alerts;\n    \n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = \"ws\";\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this._.each(this.handles, function(h) {\n      h.error();\n    });\n    this.handles = [];\n    this.initialized = false;\n    if (this.onready) {\n      this.onready();\n      this.onready = null;\n    }\n  }\n\n  onclose(ev) {\n    if (this.handles && this.handles.length)\n      this.onerror(\"Connection reset while calling aria2\");\n    this.initialized = false;\n    if (this.onready) {\n      this.onready();\n      this.onready = null;\n    }\n  }\n\n  onopen() {\n    console.log(\"websocket initialized!!!\");\n    this.initialized = true;\n    if (this.onready) {\n      this.onready();\n      this.onready = null;\n    }\n  }\n\n  onmessage(message) {\n    var data = this.JSON.parse(message.data);\n\n    for (var i = this.handles.length - 1; i >= 0; i--) {\n      if (this.handles[i].id === data.id) {\n        this.handles[i].success(data);\n        this.handles.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  invoke(opts) {\n    var data = {\n      jsonrpc: 2.0,\n      id: this.utils.uuid(),\n      method: opts.name,\n      params: opts.params && opts.params.length ? opts.params : undefined\n    };\n\n    if (data.params && !data.params.length) data.params = undefined;\n\n    this.handles.push({\n      success: opts.success || angular.noop,\n      error: opts.error || angular.noop,\n      id: data.id\n    });\n    this.sock.send(this.JSON.stringify(data));\n  }\n\n  init(conf, onready) {\n    this.initialized = false;\n    if (this.onready) {\n      this.onready();\n      this.onready = null;\n    }\n\n    if (typeof WebSocket == \"undefined\") {\n      this.alerts.addAlert(\"Web sockets are not supported! Falling back to JSONP.\", \"info\");\n      onready();\n      return;\n    }\n    this.conf = conf || this.conf;\n    this.scheme = this.conf.encrypt ? \"wss\" : \"ws\";\n\n    if (this.sock) {\n      this.sock.onopen = this.sock.onmessage = this.sock.onerror = this.sock.onclose = null;\n      this.onerror({ message: \"Changing the websocket aria2 server details\" });\n    }\n\n    try {\n      var authUrl =\n        this.scheme + \"://\" + conf.host + \":\" + conf.port + (conf.path || \"/jsonrpc\");\n      if (this.conf.auth && this.conf.auth.user && this.conf.auth.pass) {\n        authUrl =\n          this.scheme +\n          \"://\" +\n          this.conf.auth.user +\n          \":\" +\n          this.conf.auth.pass +\n          \"@\" +\n          this.conf.host +\n          \":\" +\n          this.conf.port +\n          (conf.path || \"/jsonrpc\");\n      }\n\n      this.sock = new WebSocket(authUrl);\n      this.sock.onopen = this.onopen.bind(this);\n      this.sock.onclose = this.onclose.bind(this);\n      this.sock.onerror = this.onerror.bind(this);\n      this.sock.onmessage = this.onmessage.bind(this);\n      this.onready = onready;\n    } catch (ex) {\n      console.log(\"not using websocket for aria2 rpc due to: \", ex);\n      this.alerts.addAlert(\"Web sockets not working due to \" + ex.message, \"info\");\n      onready();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WebSocketRPC {\n    constructor() {\n        this._ = require('lodash');\n        this.JSON = require('json');\n        this.utils = require('./utils');\n        this.alerts = require('./alerts');\n        this.initialized = false;\n        this.handles = [];\n        this.sock = null;\n        this.conf = null;\n        this.scheme = '';\n        this.onready = null;\n    }\n\n    onerror(ev) {\n        this.alerts.error('WebSocket error:', ev);\n        this.handles.forEach(handle => handle.cancel());\n        this.sock.close();\n    }\n\n    onclose(ev) {\n        this.alerts.info('WebSocket connection closed:', ev);\n        this.initialized = false;\n    }\n\n    onopen() {\n        this.alerts.success('WebSocket connection opened');\n        this.initialized = true;\n        if (this.onready) {\n            this.onready();\n        }\n    }\n\n    onmessage(message) {\n        let data = this.JSON.parse(message.data);\n        if (data.id) {\n            let handle = this.handles.find(h => h.id === data.id);\n            if (handle) {\n                if (data.error) {\n                    handle.error(data.error);\n                } else {\n                    handle.success(data.result);\n                }\n                this.handles = this.handles.filter(h => h.id !== data.id);\n            }\n        }\n    }\n\n    invoke(opts) {\n        let id = this.utils.uuid();\n        let request = {\n            jsonrpc: '2.0',\n            method: opts.name,\n            params: opts.params,\n            id: id\n        };\n        let handle = {\n            id: id,\n            success: opts.success,\n            error: opts.error,\n            cancel: () => {\n                this.alerts.info('RPC request cancelled:', id);\n            }\n        };\n        this.handles.push(handle);\n        this.sock.send(this.JSON.stringify(request));\n    }\n\n    init(conf, onready) {\n        this.conf = conf;\n        this.scheme = conf.encrypt ? 'wss' : 'ws';\n        let url = `${this.scheme}://${conf.host}:${conf.port}${conf.path || ''}`;\n        if (conf.auth) {\n            url += `?user=${conf.auth.user}&pass=${conf.auth.pass}`;\n        }\n        this.sock = new WebSocket(url);\n        this.sock.onerror = this.onerror.bind(this);\n        this.sock.onclose = this.onclose.bind(this);\n        this.sock.onopen = this.onopen.bind(this);\n        this.sock.onmessage = this.onmessage.bind(this);\n        this.onready = onready;\n    }\n}\n```",
      "```javascript\nclass WebSocketRPC {\n  constructor() {\n    this._ = require('lodash');\n    this.JSON = require('json');\n    this.utils = {\n      generateUUID: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n      })\n    };\n    this.alerts = {};\n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = '';\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this.alerts.error('WebSocket error:', ev);\n    this.handles.forEach(handle => handle.error('WebSocket error', ev));\n    this.handles = [];\n    this.sock.close();\n  }\n\n  onclose(ev) {\n    this.alerts.error('WebSocket closed:', ev);\n    this.initialized = false;\n    this.handles.forEach(handle => handle.error('WebSocket closed', ev));\n    this.handles = [];\n  }\n\n  onopen() {\n    this.initialized = true;\n    this.alerts.success('WebSocket connected');\n    if (this.onready) this.onready();\n  }\n\n  onmessage(message) {\n    try {\n      const data = this.JSON.parse(message.data);\n      if (data.id) {\n        const handle = this.handles.find(h => h.id === data.id);\n        if (handle) {\n          if (data.error) {\n            handle.error(data.error.code, data.error.message);\n          } else {\n            handle.success(data.result);\n          }\n          this.handles = this.handles.filter(h => h.id !== data.id);\n        }\n      }\n    } catch (e) {\n      this.alerts.error('Error parsing message:', e);\n    }\n  }\n\n  invoke(opts) {\n    const id = this.utils.generateUUID();\n    const request = {\n      jsonrpc: '2.0',\n      method: opts.name,\n      params: opts.params,\n      id: id\n    };\n    const message = this.JSON.stringify(request);\n    this.sock.send(message);\n    this.handles.push({\n      id: id,\n      success: opts.success,\n      error: opts.error\n    });\n  }\n\n  init(conf, onready) {\n    this.conf = conf;\n    this.scheme = conf.encrypt ? 'wss' : 'ws';\n    const url = `${this.scheme}://${conf.host}:${conf.port}${conf.path || ''}`;\n    if (conf.auth) {\n      url += `?user=${conf.auth.user}&pass=${conf.auth.pass}`;\n    }\n    this.sock = new WebSocket(url);\n    this.sock.onerror = this.onerror;\n    this.sock.onclose = this.onclose;\n    this.sock.onopen = this.onopen;\n    this.sock.onmessage = this.onmessage;\n    this.onready = onready;\n  }\n}\n```",
      "```javascript\nclass WebSocketRPC {\n  constructor() {\n    this._ = require('lodash');\n    this.JSON = require('json');\n    this.utils = require('./utils');\n    this.alerts = require('./alerts');\n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = '';\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this.alerts.error('WebSocket error:', ev);\n    this.handles.forEach(handle => handle.cancel());\n    this.sock = null;\n    this.initialized = false;\n  }\n\n  onclose(ev) {\n    this.alerts.info('WebSocket connection closed:', ev);\n    this.handles.forEach(handle => handle.cancel());\n    this.sock = null;\n    this.initialized = false;\n  }\n\n  onopen() {\n    this.alerts.success('WebSocket connection opened');\n    this.initialized = true;\n    if (this.onready) {\n      this.onready();\n    }\n  }\n\n  onmessage(message) {\n    try {\n      const data = this.JSON.parse(message.data);\n      if (data.id) {\n        const handle = this.handles.find(h => h.id === data.id);\n        if (handle) {\n          if (data.error) {\n            handle.error(data.error);\n          } else {\n            handle.success(data.result);\n          }\n          this.handles = this.handles.filter(h => h.id !== data.id);\n        }\n      }\n    } catch (e) {\n      this.alerts.error('Error parsing message:', e);\n    }\n  }\n\n  invoke(opts) {\n    const id = this.utils.uuid();\n    const request = {\n      jsonrpc: '2.0',\n      method: opts.name,\n      params: opts.params,\n      id: id\n    };\n    const handle = {\n      id: id,\n      success: opts.success,\n      error: opts.error,\n      cancel: () => {\n        this.alerts.info('RPC request cancelled:', id);\n      }\n    };\n    this.handles.push(handle);\n    const payload = this.JSON.stringify(request);\n    if (this.sock) {\n      this.sock.send(payload);\n    } else {\n      this.alerts.error('WebSocket connection not established');\n    }\n  }\n\n  init(conf, onready) {\n    this.conf = conf;\n    this.scheme = conf.encrypt ? 'wss' : 'ws';\n    const url = `${this.scheme}://${conf.host}:${conf.port}${conf.path || ''}`;\n    if (conf.auth) {\n      url += `?user=${conf.auth.user}&pass=${conf.auth.pass}`;\n    }\n    this.sock = new WebSocket(url);\n    this.sock.onerror = this.onerror.bind(this);\n    this.sock.onclose = this.onclose.bind(this);\n    this.sock.onopen = this.onopen.bind(this);\n    this.sock.onmessage = this.onmessage.bind(this);\n    this.onready = onready;\n  }\n}\n```",
      "```javascript\nconst _ = require('lodash');\nconst JSON = require('json');\nconst utils = {\n  generateUUID: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  })\n};\nconst alerts = {\n  notify: (message) => console.log(message)\n};\nconst WebSocketRPC = function() {\n  this._ = _;\n  this.JSON = JSON;\n  this.utils = utils;\n  this.alerts = alerts;\n  this.initialized = false;\n  this.handles = [];\n  this.sock = null;\n  this.conf = null;\n  this.scheme = '';\n  this.onready = null;\n};\n\nWebSocketRPC.prototype.onerror = function(ev) {\n  this.alerts.notify('WebSocket Error');\n  this.sock = null;\n  this.initialized = false;\n  this.handles.forEach(handle => handle.reject(new Error('WebSocket Error')));\n  this.handles = [];\n};\n\nWebSocketRPC.prototype.onclose = function(ev) {\n  this.alerts.notify('WebSocket Connection Closed');\n  this.sock = null;\n  this.initialized = false;\n  this.handles.forEach(handle => handle.reject(new Error('WebSocket Connection Closed')));\n  this.handles = [];\n};\n\nWebSocketRPC.prototype.onopen = function() {\n  this.alerts.notify('WebSocket Connection Opened');\n  this.initialized = true;\n  if (this.onready) {\n    this.onready();\n  }\n};\n\nWebSocketRPC.prototype.onmessage = function(message) {\n  try {\n    const data = this.JSON.parse(message.data);\n    const handle = this.handles.find(h => h.id === data.id);\n    if (handle) {\n      if (data.error) {\n        handle.reject(new Error(data.error.message));\n      } else {\n        handle.resolve(data.result);\n      }\n      this.handles = this.handles.filter(h => h !== handle);\n    }\n  } catch (e) {\n    this.alerts.notify('Error parsing message');\n  }\n};\n\nWebSocketRPC.prototype.invoke = function(opts) {\n  const id = this.utils.generateUUID();\n  const request = {\n    jsonrpc: '2.0',\n    method: opts.name,\n    params: opts.params,\n    id: id\n  };\n  const handle = {\n    resolve: null,\n    reject: null,\n    id: id\n  };\n  this.handles.push(handle);\n  const payload = this.JSON.stringify(request);\n  if (this.sock) {\n    this.sock.send(payload);\n  } else {\n    this.alerts.notify('WebSocket not connected');\n  }\n  return new Promise((resolve, reject) => {\n    handle.resolve = resolve;\n    handle.reject = reject;\n  });\n};\n\nWebSocketRPC.prototype.init = function(conf, onready) {\n  this.conf = conf;\n  this.onready = onready;\n  this.scheme = conf.encrypt ? 'wss' : 'ws';\n  const url = `${this.scheme}://${conf.host}:${conf.port}${conf.path || ''}`;\n  this.sock = new WebSocket(url);\n  this.sock.onerror = this.onerror.bind(this);\n  this.sock.onclose = this.onclose.bind(this);\n  this.sock.onopen = this.onopen.bind(this);\n  this.sock.onmessage = this.onmessage.bind(this);\n};\n```",
      "```javascript\nclass WebSocketRPC {\n  constructor() {\n    this._ = require('lodash');\n    this.JSON = require('json');\n    this.utils = {\n      generateUUID: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n      })\n    };\n    this.alerts = {};\n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = 'ws';\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this.alerts.error('WebSocket error:', ev);\n    this.handles.forEach(handle => handle.error('WebSocket error', ev));\n    this.handles = [];\n    this.sock.close();\n  }\n\n  onclose(ev) {\n    this.alerts.error('WebSocket closed:', ev);\n    this.initialized = false;\n    this.handles.forEach(handle => handle.error('WebSocket closed', ev));\n    this.handles = [];\n  }\n\n  onopen() {\n    this.initialized = true;\n    if (this.onready) this.onready();\n  }\n\n  onmessage(message) {\n    try {\n      const data = this.JSON.parse(message.data);\n      if (data.id) {\n        const handle = this.handles.find(h => h.id === data.id);\n        if (handle) {\n          if (data.error) {\n            handle.error(data.error);\n          } else {\n            handle.success(data.result);\n          }\n          this.handles = this.handles.filter(h => h.id !== data.id);\n        }\n      }\n    } catch (e) {\n      this.alerts.error('Error parsing message:', e);\n    }\n  }\n\n  invoke(opts) {\n    const id = this.utils.generateUUID();\n    const request = {\n      jsonrpc: '2.0',\n      method: opts.name,\n      params: opts.params,\n      id: id\n    };\n    const message = this.JSON.stringify(request);\n    this.sock.send(message);\n    this.handles.push({\n      id: id,\n      success: opts.success,\n      error: opts.error\n    });\n  }\n\n  init(conf, onready) {\n    this.conf = conf;\n    this.onready = onready;\n    const { host, port, path, encrypt, auth } = conf;\n    const protocol = encrypt ? 'wss' : 'ws';\n    this.scheme = protocol;\n    const url = `${protocol}://${host}:${port}${path || ''}`;\n    if (auth) {\n      url += `?user=${auth.user}&pass=${auth.pass}`;\n    }\n    this.sock = new WebSocket(url);\n    this.sock.onerror = this.onerror;\n    this.sock.onclose = this.onclose;\n    this.sock.onopen = this.onopen;\n    this.sock.onmessage = this.onmessage;\n  }\n}\n```",
      "```javascript\nclass WebSocketRPC {\n    constructor() {\n        this._ = require('lodash');\n        this.JSON = require('json');\n        this.utils = {\n            generateUUID: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n                var r = (Math.random() * 16) | 0,\n                    v = c === 'x' ? r : (r & 0x3) | 0x8;\n                return v.toString(16);\n            })\n        };\n        this.alerts = {};\n        this.initialized = false;\n        this.handles = [];\n        this.sock = null;\n        this.conf = null;\n        this.scheme = 'ws';\n        this.onready = null;\n    }\n\n    onerror(ev) {\n        this.alerts.error('WebSocket error:', ev);\n        this.handles.forEach(handle => handle.cancel());\n        this.handles = [];\n        this.sock.close();\n    }\n\n    onclose(ev) {\n        this.alerts.info('WebSocket connection closed:', ev);\n        this.initialized = false;\n        this.onready = null;\n    }\n\n    onopen() {\n        this.alerts.info('WebSocket connection opened');\n        this.initialized = true;\n        this.onready && this.onready();\n    }\n\n    onmessage(message) {\n        let data = this.JSON.parse(message.data);\n        if (data.id) {\n            let handle = this.handles.find(h => h.id === data.id);\n            if (handle) {\n                if (data.error) {\n                    handle.error(data.error);\n                } else {\n                    handle.success(data.result);\n                }\n                this.handles = this.handles.filter(h => h.id !== data.id);\n            }\n        }\n    }\n\n    invoke(opts) {\n        let id = this.utils.generateUUID();\n        let request = {\n            jsonrpc: '2.0',\n            method: opts.name,\n            params: opts.params,\n            id: id\n        };\n        let handle = {\n            id: id,\n            success: opts.success,\n            error: opts.error,\n            cancel: () => {\n                this.alerts.info('RPC request cancelled:', id);\n            }\n        };\n        this.handles.push(handle);\n        this.sock.send(this.JSON.stringify(request));\n    }\n\n    init(conf, onready) {\n        this.conf = conf;\n        this.onready = onready;\n        if (conf.encrypt) {\n            this.scheme = 'wss';\n        }\n        let url = `${this.scheme}://${conf.host}:${conf.port}${conf.path || ''}`;\n        if (conf.auth) {\n            url += `?user=${conf.auth.user}&pass=${conf.auth.pass}`;\n        }\n        this.sock = new WebSocket(url);\n        this.sock.onerror = this.onerror;\n        this.sock.onclose = this.onclose;\n        this.sock.onopen = this.onopen;\n        this.sock.onmessage = this.onmessage;\n    }\n}\n```",
      "```javascript\nclass WebSocketRPC {\n  constructor() {\n    this._ = require('lodash');\n    this.JSON = require('json');\n    this.utils = {\n      generateUUID: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n      })\n    };\n    this.alerts = {};\n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = '';\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this.alerts.error('WebSocket error:', ev);\n    this.handles.forEach(handle => handle.error('WebSocket error', ev));\n    this.handles = [];\n    this.sock.close();\n  }\n\n  onclose(ev) {\n    this.alerts.error('WebSocket closed:', ev);\n    this.initialized = false;\n    this.handles.forEach(handle => handle.error('WebSocket closed', ev));\n    this.handles = [];\n  }\n\n  onopen() {\n    this.alerts.success('WebSocket connected');\n    this.initialized = true;\n    if (this.onready) this.onready();\n  }\n\n  onmessage(message) {\n    try {\n      const data = this.JSON.parse(message.data);\n      if (data.id) {\n        const handle = this.handles.find(h => h.id === data.id);\n        if (handle) {\n          if (data.error) {\n            handle.error(data.error);\n          } else {\n            handle.success(data.result);\n          }\n          this.handles = this.handles.filter(h => h.id !== data.id);\n        }\n      }\n    } catch (e) {\n      this.alerts.error('Error parsing message:', e);\n    }\n  }\n\n  invoke(opts) {\n    const id = this.utils.generateUUID();\n    const request = {\n      jsonrpc: '2.0',\n      method: opts.name,\n      params: opts.params,\n      id: id\n    };\n    const handle = {\n      id: id,\n      success: opts.success,\n      error: opts.error\n    };\n    this.handles.push(handle);\n    this.sock.send(this.JSON.stringify(request));\n  }\n\n  init(conf, onready) {\n    this.conf = conf;\n    this.scheme = conf.encrypt ? 'wss' : 'ws';\n    const url = `${this.scheme}://${conf.host}:${conf.port}${conf.path || ''}`;\n    this.sock = new WebSocket(url);\n    this.sock.onerror = this.onerror;\n    this.sock.onclose = this.onclose;\n    this.sock.onopen = this.onopen;\n    this.onready = onready;\n  }\n}\n```",
      "```javascript\nclass WebSocketRPC {\n  constructor() {\n    this._ = require('lodash');\n    this.JSON = require('json');\n    this.utils = {\n      generateUUID: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n      })\n    };\n    this.alerts = {};\n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = 'ws';\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this.alerts.error('WebSocket error:', ev);\n    this.handles.forEach(handle => handle.cancel());\n    this.sock = null;\n    this.initialized = false;\n  }\n\n  onclose(ev) {\n    this.alerts.error('WebSocket closed:', ev);\n    this.handles.forEach(handle => handle.cancel());\n    this.sock = null;\n    this.initialized = false;\n  }\n\n  onopen() {\n    this.alerts.success('WebSocket connected');\n    this.initialized = true;\n    if (this.onready) {\n      this.onready();\n    }\n  }\n\n  onmessage(message) {\n    try {\n      const data = this.JSON.parse(message.data);\n      if (data.id) {\n        const handle = this.handles.find(h => h.id === data.id);\n        if (handle) {\n          if (data.error) {\n            handle.error(data.error);\n          } else {\n            handle.success(data.result);\n          }\n          this.handles = this.handles.filter(h => h.id !== data.id);\n        }\n      }\n    } catch (e) {\n      this.alerts.error('Error parsing message:', e);\n    }\n  }\n\n  invoke(opts) {\n    const id = this.utils.generateUUID();\n    const request = {\n      jsonrpc: '2.0',\n      method: opts.name,\n      params: opts.params,\n      id: id\n    };\n    const handle = {\n      id: id,\n      success: opts.success,\n      error: opts.error,\n      cancel: () => {\n        this.alerts.info('RPC request cancelled:', id);\n      }\n    };\n    this.handles.push(handle);\n    this.sock.send(this.JSON.stringify(request));\n  }\n\n  init(conf, onready) {\n    this.conf = conf;\n    this.onready = onready;\n    const { host, port, path, encrypt, auth } = conf;\n    const url = `${encrypt ? 'wss' : 'ws'}://${host}:${port}${path || ''}`;\n    this.sock = new WebSocket(url);\n    this.sock.onerror = this.onerror;\n    this.sock.onclose = this.onclose;\n    this.sock.onopen = this.onopen;\n    this.sock.onmessage = this.onmessage;\n  }\n}\n```",
      "```javascript\nclass WebSocketRPC {\n  constructor() {\n    this._ = require('lodash');\n    this.JSON = require('json');\n    this.utils = {\n      generateUUID: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n      })\n    };\n    this.alerts = {};\n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = 'ws';\n    this.onready = null;\n  }\n\n  onerror(ev) {\n    this.alerts.error('WebSocket error:', ev);\n    this.handles.forEach(handle => handle.cancel());\n    this.sock = null;\n    this.initialized = false;\n  }\n\n  onclose(ev) {\n    this.alerts.error('WebSocket closed:', ev);\n    this.handles.forEach(handle => handle.cancel());\n    this.sock = null;\n    this.initialized = false;\n  }\n\n  onopen() {\n    this.alerts.success('WebSocket connected.');\n    this.initialized = true;\n    if (this.onready) this.onready();\n  }\n\n  onmessage(message) {\n    try {\n      const data = this.JSON.parse(message.data);\n      this.handles.forEach(handle => {\n        if (handle.id === data.id) {\n          if (data.error) {\n            handle.error(data.error);\n          } else {\n            handle.success(data.result);\n          }\n          this.handles = this.handles.filter(h => h.id !== handle.id);\n        }\n      });\n    } catch (e) {\n      this.alerts.error('Error parsing message:', e);\n    }\n  }\n\n  invoke(opts) {\n    const id = this.utils.generateUUID();\n    const request = {\n      jsonrpc: '2.0',\n      method: opts.name,\n      params: opts.params,\n      id: id\n    };\n    const handle = {\n      id: id,\n      success: opts.success,\n      error: opts.error,\n      cancel: () => {\n        this.alerts.info('RPC request cancelled:', id);\n      }\n    };\n    this.handles.push(handle);\n    const payload = JSON.stringify(request);\n    if (this.sock) {\n      this.sock.send(payload);\n    } else {\n      this.alerts.error('WebSocket not connected, request not sent:', payload);\n    }\n  }\n\n  init(conf, onready) {\n    this.conf = conf;\n    this.onready = onready;\n    const { host, port, path, encrypt, auth } = conf;\n    const url = `${encrypt ? 'wss' : 'ws'}://${host}:${port}${path || ''}`;\n    if (auth) {\n      url += `?user=${auth.user}&pass=${auth.pass}`;\n    }\n    this.sock = new WebSocket(url);\n    this.sock.onerror = this.onerror;\n    this.sock.onclose = this.onclose;\n    this.sock.onopen = this.onopen;\n    this.sock.onmessage = this.onmessage;\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\n(function() {\n  var WebSocketRPC = function() {\n    this._ = require('lodash');\n    this.JSON = require('json');\n    this.utils = {\n      generateUUID: function() {\n        // UUID generation logic\n      }\n    };\n    this.alerts = {\n      notify: function(message) {\n        // Notification logic\n      }\n    };\n    this.initialized = false;\n    this.handles = [];\n    this.sock = null;\n    this.conf = null;\n    this.scheme = '';\n    this.onready = null;\n\n    this.onerror = function(ev) {\n      // Error handling logic\n    };\n\n    this.onclose = function(ev) {\n      // Connection closure logic\n    };\n\n    this.onopen = function() {\n      // Connection open logic\n    };\n\n    this.onmessage = function(message) {\n      // Message processing logic\n    };\n\n    this.invoke = function(opts) {\n      // RPC invocation logic\n    };\n\n    this.init = function(conf, onready) {\n      // Initialization logic\n    };\n  };\n\n  module.exports = WebSocketRPC;\n})();\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a WebSocket client class in JavaScript that establishes a connection to a server, handles communication events, and provides methods for sending data.\n\nClass Description: The NetWork class encapsulates WebSocket functionality for connecting to a server at a specified IP and port. It manages connection events (open, close, message) through configurable callbacks and provides methods for sending both structured and raw data.\n\nAttributes:\n- ip: string - The IP address of the WebSocket server\n- port: string|number - The port number of the WebSocket server\n- webSocket: WebSocket - The underlying WebSocket connection instance\n\nMethods:\n- constructor(ip, port) -> void - Initializes the NetWork instance with server connection details\n- connect(config) -> void - Establishes WebSocket connection and sets up event handlers\n  - config: object - Configuration object containing callback functions\n    - onopen: function - Called when connection is established\n    - onclose: function - Called when connection is closed\n    - onmessage: function - Called when message is received (receives message data)\n- request(name, argobj) -> void - Sends structured data to server in \"name://{json}\" format\n  - name: string - The message identifier/type\n  - argobj: object|null - Optional arguments to be sent as JSON\n- send(str) -> void - Sends raw string data to server\n  - str: string - The raw message to send",
    "Canonical_solution": "class NetWork {\n    constructor(ip, port) {\n        this.ip = ip\n        this.port = port\n    }\n\n    connect(config) {\n        let webSocket = new WebSocket(\"ws://\" + this.ip + \":\" + this.port)\n        webSocket.onopen = function() {\n            config.onopen()\n        }\n        webSocket.onclose = function() {\n            config.onclose()\n        }\n        webSocket.onmessage = function(data) { \n            config.onmessage(data)\n        }\n        this.webSocket = webSocket\n    }\n\n    request(name, argobj) {\n        let ss = name + \"://\" + (argobj ? JSON.stringify(argobj) : \"{}\");\n        this.webSocket.send(ss);\n    }\n\n    send(str) {\n        this.webSocket.send(str)\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = null;\n  }\n\n  connect(config) {\n    this.webSocket = new WebSocket(`ws://${this.ip}:${this.port}`);\n    this.webSocket.onopen = config.onopen;\n    this.webSocket.onclose = config.onclose;\n    this.webSocket.onmessage = (event) => config.onmessage(event.data);\n  }\n\n  request(name, argobj) {\n    const data = argobj ? `${name}:${JSON.stringify(argobj)}` : name;\n    this.send(data);\n  }\n\n  send(str) {\n    if (this.webSocket.readyState === WebSocket.OPEN) {\n      this.webSocket.send(str);\n    }\n  }\n}\n```",
      "```javascript\nclass NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = null;\n  }\n\n  connect(config) {\n    const ws = new WebSocket(`ws://${this.ip}:${this.port}`);\n    this.webSocket = ws;\n    ws.onopen = () => {\n      if (config.onopen) config.onopen();\n    };\n    ws.onclose = () => {\n      if (config.onclose) config.onclose();\n    };\n    ws.onmessage = (event) => {\n      if (config.onmessage) config.onmessage(event.data);\n    };\n  }\n\n  request(name, argobj) {\n    const data = argobj ? `${name}:${JSON.stringify(argobj)}` : name;\n    this.send(data);\n  }\n\n  send(str) {\n    if (this.webSocket) {\n      this.webSocket.send(str);\n    }\n  }\n}\n```",
      "```javascript\nclass NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = null;\n  }\n\n  connect(config) {\n    this.webSocket = new WebSocket(`ws://${this.ip}:${this.port}`);\n    this.webSocket.onopen = config.onopen;\n    this.webSocket.onclose = config.onclose;\n    this.webSocket.onmessage = (event) => config.onmessage(event.data);\n  }\n\n  request(name, argobj) {\n    const data = `${name}:${JSON.stringify(argobj)}`;\n    this.send(data);\n  }\n\n  send(str) {\n    this.webSocket.send(str);\n  }\n}\n```",
      "```javascript\nclass NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = null;\n  }\n\n  connect(config) {\n    const ws = new WebSocket(`ws://${this.ip}:${this.port}`);\n    this.webSocket = ws;\n    ws.onopen = () => {\n      if (config.onopen) config.onopen();\n    };\n    ws.onclose = () => {\n      if (config.onclose) config.onclose();\n    };\n    ws.onmessage = (event) => {\n      if (config.onmessage) config.onmessage(event.data);\n    };\n  }\n\n  request(name, argobj) {\n    const data = argobj ? `${name}:${JSON.stringify(argobj)}` : name;\n    this.send(data);\n  }\n\n  send(str) {\n    if (this.webSocket) {\n      this.webSocket.send(str);\n    }\n  }\n}\n```",
      "```javascript\nclass NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = null;\n  }\n\n  connect(config) {\n    const wsUrl = `ws://${this.ip}:${this.port}`;\n    this.webSocket = new WebSocket(wsUrl);\n\n    this.webSocket.onopen = () => {\n      if (config.onopen) {\n        config.onopen();\n      }\n    };\n\n    this.webSocket.onclose = () => {\n      if (config.onclose) {\n        config.onclose();\n      }\n    };\n\n    this.webSocket.onmessage = (event) => {\n      if (config.onmessage) {\n        config.onmessage(event.data);\n      }\n    };\n  }\n\n  request(name, argobj) {\n    const data = argobj ? `${name}:${JSON.stringify(argobj)}` : name;\n    this.send(data);\n  }\n\n  send(str) {\n    if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n      this.webSocket.send(str);\n    }\n  }\n}\n```",
      "```javascript\nclass NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = null;\n  }\n\n  connect(config) {\n    this.webSocket = new WebSocket(`ws://${this.ip}:${this.port}`);\n    this.webSocket.onopen = config.onopen;\n    this.webSocket.onclose = config.onclose;\n    this.webSocket.onmessage = (event) => config.onmessage(event.data);\n  }\n\n  request(name, argobj) {\n    const data = argobj ? `${name}:${JSON.stringify(argobj)}` : name;\n    this.send(data);\n  }\n\n  send(str) {\n    if (this.webSocket.readyState === WebSocket.OPEN) {\n      this.webSocket.send(str);\n    }\n  }\n}\n```",
      "```javascript\nclass NetWork {\n    constructor(ip, port) {\n        this.ip = ip;\n        this.port = port;\n        this.webSocket = null;\n    }\n\n    connect(config) {\n        const wsUrl = `ws://${this.ip}:${this.port}`;\n        this.webSocket = new WebSocket(wsUrl);\n\n        this.webSocket.onopen = () => {\n            if (config.onopen) {\n                config.onopen();\n            }\n        };\n\n        this.webSocket.onclose = () => {\n            if (config.onclose) {\n                config.onclose();\n            }\n        };\n\n        this.webSocket.onmessage = (event) => {\n            if (config.onmessage) {\n                config.onmessage(event.data);\n            }\n        };\n    }\n\n    request(name, argobj) {\n        const data = argobj ? `${name}:${JSON.stringify(argobj)}` : name;\n        this.send(data);\n    }\n\n    send(str) {\n        if (this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(str);\n        }\n    }\n}\n```",
      "```javascript\nclass NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = null;\n  }\n\n  connect(config) {\n    const ws = new WebSocket(`ws://${this.ip}:${this.port}`);\n    this.webSocket = ws;\n    ws.onopen = () => {\n      if (config.onopen) config.onopen();\n    };\n    ws.onclose = () => {\n      if (config.onclose) config.onclose();\n    };\n    ws.onmessage = (event) => {\n      if (config.onmessage) config.onmessage(event.data);\n    };\n  }\n\n  request(name, argobj) {\n    const data = argobj ? `${name}:${JSON.stringify(argobj)}` : name;\n    this.send(data);\n  }\n\n  send(str) {\n    if (this.webSocket) {\n      this.webSocket.send(str);\n    }\n  }\n}\n```",
      "```javascript\nclass NetWork {\n    constructor(ip, port) {\n        this.ip = ip;\n        this.port = port;\n        this.webSocket = null;\n    }\n\n    connect(config) {\n        const ws = new WebSocket(`ws://${this.ip}:${this.port}`);\n        this.webSocket = ws;\n        ws.onopen = () => {\n            if (config.onopen) config.onopen();\n        };\n        ws.onclose = () => {\n            if (config.onclose) config.onclose();\n        };\n        ws.onmessage = (event) => {\n            if (config.onmessage) config.onmessage(event.data);\n        };\n    }\n\n    request(name, argobj) {\n        const data = argobj ? `${name}:${JSON.stringify(argobj)}` : name;\n        this.send(data);\n    }\n\n    send(str) {\n        if (this.webSocket) {\n            this.webSocket.send(str);\n        }\n    }\n}\n```",
      "```javascript\nclass NetWork {\n  constructor(ip, port) {\n    this.ip = ip;\n    this.port = port;\n    this.webSocket = null;\n  }\n\n  connect(config) {\n    this.webSocket = new WebSocket(`ws://${this.ip}:${this.port}`);\n    this.webSocket.onopen = config.onopen;\n    this.webSocket.onclose = config.onclose;\n    this.webSocket.onmessage = (event) => config.onmessage(event.data);\n  }\n\n  request(name, argobj) {\n    const data = `${name}:${JSON.stringify(argobj)}`;\n    this.send(data);\n  }\n\n  send(str) {\n    this.webSocket.send(str);\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a WebSocket client connection class for browser environments that handles connection lifecycle, message events, and window focus state tracking.\n\nClass Description: The BrowserConnection class manages a WebSocket connection in a browser environment, including connection setup, event handling, and window visibility tracking. It extends a base connection class (BaseConnection) and adds browser-specific functionality.\n\nAttributes:\n- focusDetectorTimer: [Number] - Timer ID for the focus detection interval\n- windowVisible: [Boolean] - Tracks whether the browser window is currently visible\n- socket: [WebSocket] - The WebSocket connection instance\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the connection with options and sets up event listeners for 'ready' and 'disconnect' events\n- setupSocket() -> WebSocket - Creates and configures a new WebSocket connection with event handlers for open, close, and message events\n- startFocusLoop() -> void - Starts tracking window visibility by setting up event listeners for focus/blur events and periodic checks\n- stopFocusLoop() -> void - Stops the window visibility tracking by clearing the interval timer and removing event listeners\n- handleOpen() -> void - Inherited from BaseConnection, called when WebSocket connection opens\n- handleClose(code: Number, reason: String) -> void - Inherited from BaseConnection, called when WebSocket connection closes\n- handleData(data: String) -> void - Inherited from BaseConnection, called when WebSocket receives a message\n- reportFocus(isVisible: Boolean) -> void - Inherited from BaseConnection, reports current window focus state",
    "Canonical_solution": "var WebSocket = require(\"ws\");\nvar _ = require(\"underscore\");\n\nclass BrowserConnection {\n  constructor(opts) {\n    BaseConnection.call(this, opts);\n    var connection = this;\n    this.on(\"ready\", function() {\n      connection.startFocusLoop()\n    });\n    this.on(\"disconnect\", function() {\n      connection.stopFocusLoop()\n    });\n  }\n\n  setupSocket() {\n    var connection = this;\n    var socket = new WebSocket(this.getUrl());\n    socket.onopen = function() {\n      connection.handleOpen()\n    };\n    socket.onclose = function(data) {\n      connection.handleClose(data[\"code\"], data[\"reason\"])\n    };\n    socket.onmessage = function(message) {\n      connection.handleData(message.data)\n    };\n    return socket;\n  }\n\n  startFocusLoop() {\n    if (this.focusDetectorTimer) return;\n    var connection = this;\n    var propertyName = null;\n    if (typeof document.hidden !== \"undefined\") {\n      propertyName = \"hidden\"\n    } else if (typeof document.mozHidden !== \"undefined\") {\n      propertyName = \"mozHidden\"\n    } else if (typeof document.msHidden !== \"undefined\") {\n      propertyName = \"msHidden\"\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      propertyName = \"webkitHidden\"\n    } else {\n      propertyName = undefined\n    }\n    if (connection.windowVisible === undefined) {\n      connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false\n    }\n    var focusListener = window.addEventListener(\"focus\", function(e) {\n      connection.windowVisible = true;\n      updateFocusState()\n    });\n    var blurListener = window.addEventListener(\"blur\", function(e) {\n      connection.windowVisible = false;\n      updateFocusState()\n    });\n    this.on(\"disconnect\", function() {\n      window.removeEventListener(\"focus\", focusListener);\n      window.removeEventListener(\"blur\", blurListener)\n    });\n    var updateFocusState = function() {\n      var isVisible = propertyName === undefined ? true : document[propertyName] === false;\n      connection.reportFocus(isVisible && connection.windowVisible)\n    };\n    this.focusDetectorTimer = setInterval(updateFocusState, 100)\n  }\n\n  stopFocusLoop() {\n    if (!this.focusDetectorTimer) return;\n    clearTimeout(this.focusDetectorTimer);\n    delete this.focusDetectorTimer;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = document.hidden;\n    this.socket = this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    const socket = new WebSocket(this.opts.url);\n    socket.onopen = this.handleOpen.bind(this);\n    socket.onclose = (event) => this.handleClose(event.code, event.reason);\n    socket.onmessage = (event) => this.handleData(event.data);\n    return socket;\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.reportFocus(document.hidden);\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    document.removeEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n    this.stopFocusLoop();\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```",
      "```javascript\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = document.hidden;\n    this.socket = this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    const socket = new WebSocket(this.opts.url);\n    socket.onopen = this.handleOpen.bind(this);\n    socket.onclose = (event) => this.handleClose(event.code, event.reason);\n    socket.onmessage = (event) => this.handleData(event.data);\n    return socket;\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.reportFocus(document.hidden);\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    document.removeEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n    this.stopFocusLoop();\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```",
      "```javascript\nclass BaseConnection {\n  constructor() {\n    this.socket = null;\n  }\n\n  setupSocket() {\n    throw new Error('Method not implemented.');\n  }\n\n  startFocusLoop() {\n    throw new Error('Method not implemented.');\n  }\n\n  stopFocusLoop() {\n    throw new Error('Method not implemented.');\n  }\n\n  handleOpen() {\n    throw new Error('Method not implemented.');\n  }\n\n  handleClose(code, reason) {\n    throw new Error('Method not implemented.');\n  }\n\n  handleData(data) {\n    throw new Error('Method not implemented.');\n  }\n\n  reportFocus(isVisible) {\n    throw new Error('Method not implemented.');\n  }\n}\n\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super();\n    this.focusDetectorTimer = null;\n    this.windowVisible = document.hidden;\n    this.socket = this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    const socket = new WebSocket('ws://example.com');\n    socket.onopen = () => this.handleOpen();\n    socket.onclose = (event) => this.handleClose(event.code, event.reason);\n    socket.onmessage = (event) => this.handleData(event.data);\n    return socket;\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.reportFocus(document.hidden);\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      this.windowVisible = document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    document.removeEventListener('visibilitychange', () => {\n      this.windowVisible = document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```",
      "```javascript\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = document.hidden;\n    this.socket = this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    const socket = new WebSocket(this.opts.url);\n    socket.onopen = this.handleOpen.bind(this);\n    socket.onclose = (event) => this.handleClose(event.code, event.reason);\n    socket.onmessage = (event) => this.handleData(event.data);\n    return socket;\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.reportFocus(document.hidden);\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    document.removeEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n    this.stopFocusLoop();\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```",
      "```javascript\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = document.hidden;\n    this.socket = this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    const socket = new WebSocket(this.opts.url);\n    socket.onopen = this.handleOpen.bind(this);\n    socket.onclose = (event) => this.handleClose(event.code, event.reason);\n    socket.onmessage = (event) => this.handleData(event.data);\n    return socket;\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.reportFocus(document.hidden);\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    document.removeEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n    this.stopFocusLoop();\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```",
      "```javascript\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = document.hidden;\n    this.socket = this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    const socket = new WebSocket(this.opts.url);\n    socket.onopen = this.handleOpen.bind(this);\n    socket.onclose = (event) => this.handleClose(event.code, event.reason);\n    socket.onmessage = (event) => this.handleData(event.data);\n    return socket;\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.reportFocus(document.hidden);\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    document.removeEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n    this.stopFocusLoop();\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```",
      "class BrowserConnection extends BaseConnection {\n    constructor(opts) {\n        super(opts);\n        this.focusDetectorTimer = null;\n        this.windowVisible = document.hidden;\n        this.socket = this.setupSocket();\n        this.startFocusLoop();\n    }\n\n    setupSocket() {\n        const socket = new WebSocket(this.opts.url);\n        socket.onopen = () => this.handleOpen();\n        socket.onclose = (event) => this.handleClose(event.code, event.reason);\n        socket.onmessage = (event) => this.handleData(event.data);\n        return socket;\n    }\n\n    startFocusLoop() {\n        this.focusDetectorTimer = setInterval(() => {\n            this.reportFocus(document.hidden);\n        }, 1000);\n        document.addEventListener('visibilitychange', () => {\n            this.reportFocus(document.hidden);\n        });\n    }\n\n    stopFocusLoop() {\n        clearInterval(this.focusDetectorTimer);\n        document.removeEventListener('visibilitychange', () => {\n            this.reportFocus(document.hidden);\n        });\n    }\n\n    handleOpen() {\n        super.handleOpen();\n    }\n\n    handleClose(code, reason) {\n        super.handleClose(code, reason);\n    }\n\n    handleData(data) {\n        super.handleData(data);\n    }\n\n    reportFocus(isVisible) {\n        super.reportFocus(isVisible);\n    }\n}",
      "```javascript\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = document.hidden;\n    this.socket = this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    const socket = new WebSocket(this.opts.url);\n    socket.onopen = this.handleOpen.bind(this);\n    socket.onclose = (event) => this.handleClose(event.code, event.reason);\n    socket.onmessage = (event) => this.handleData(event.data);\n    return socket;\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.reportFocus(document.hidden);\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      this.windowVisible = document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    document.removeEventListener('visibilitychange', () => {\n      this.windowVisible = document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n    this.stopFocusLoop();\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```",
      "```javascript\nclass BaseConnection {\n  constructor() {}\n\n  handleOpen() {}\n\n  handleClose(code, reason) {}\n\n  handleData(data) {}\n\n  reportFocus(isVisible) {}\n}\n\nclass BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super();\n    this.focusDetectorTimer = null;\n    this.windowVisible = document.hidden;\n    this.socket = this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    const socket = new WebSocket('ws://example.com');\n    socket.onopen = () => {\n      this.handleOpen();\n    };\n    socket.onclose = (event) => {\n      this.handleClose(event.code, event.reason);\n    };\n    socket.onmessage = (event) => {\n      this.handleData(event.data);\n    };\n    return socket;\n  }\n\n  startFocusLoop() {\n    this.focusDetectorTimer = setInterval(() => {\n      this.reportFocus(document.hidden);\n    }, 1000);\n    document.addEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    document.removeEventListener('visibilitychange', () => {\n      this.windowVisible = !document.hidden;\n      this.reportFocus(this.windowVisible);\n    });\n  }\n\n  handleOpen() {\n    super.handleOpen();\n  }\n\n  handleClose(code, reason) {\n    super.handleClose(code, reason);\n  }\n\n  handleData(data) {\n    super.handleData(data);\n  }\n\n  reportFocus(isVisible) {\n    super.reportFocus(isVisible);\n  }\n}\n```",
      "```javascript\nclass BrowserConnection extends BaseConnection {\n    constructor(opts) {\n        super(opts);\n        this.focusDetectorTimer = null;\n        this.windowVisible = document.hidden;\n        this.socket = null;\n    }\n\n    setupSocket() {\n        this.socket = new WebSocket(this.opts.url);\n        this.socket.onopen = this.handleOpen.bind(this);\n        this.socket.onclose = (event) => this.handleClose(event.code, event.reason);\n        this.socket.onmessage = (event) => this.handleData(event.data);\n        return this.socket;\n    }\n\n    startFocusLoop() {\n        this.focusDetectorTimer = setInterval(() => {\n            this.reportFocus(document.hidden);\n        }, 1000);\n        document.addEventListener('visibilitychange', () => {\n            this.windowVisible = document.hidden;\n            this.reportFocus(this.windowVisible);\n        });\n    }\n\n    stopFocusLoop() {\n        clearInterval(this.focusDetectorTimer);\n        document.removeEventListener('visibilitychange', () => {\n            this.windowVisible = document.hidden;\n            this.reportFocus(this.windowVisible);\n        });\n    }\n\n    handleOpen() {\n        super.handleOpen();\n    }\n\n    handleClose(code, reason) {\n        super.handleClose(code, reason);\n    }\n\n    handleData(data) {\n        super.handleData(data);\n    }\n\n    reportFocus(isVisible) {\n        super.reportFocus(isVisible);\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a class that serves as an HTTP client for interacting with a build service API, handling different types of package-related operations with proper error handling.\n\nClass Description: The BuildService class provides methods to fetch package build statistics, exports, and export sizes from a remote build service. It uses Axios for HTTP requests and implements centralized error handling.\n\nAttributes:\n- operations: [Array] - A predefined list of available API operations, each specifying the operation type, endpoint, and corresponding method name\n\nMethods:\n- _makeHttpRequest: [Name](operation: Object, packageString: String) -> Promise<Object> - Makes an HTTP GET request to the build service with the specified operation and package string, handles the response and errors\n- _handleError: [Name](error: Error, operationType: String) -> Throws CustomError - Centralized error handling that processes different types of errors (response errors, request errors, and other errors) and throws appropriate custom errors\n- getPackageBuildStats: [Name](packageString: String) -> Promise<Object> - Retrieves build statistics for the specified package\n- getPackageExports: [Name](packageString: String) -> Promise<Object> - Retrieves all exports for the specified package\n- getPackageExportSizes: [Name](packageString: String) -> Promise<Object> - Retrieves size information for all exports of the specified package",
    "Canonical_solution": "const axios = require('axios');\nconst CustomError = require('../CustomError');\n\nclass BuildService {\n  constructor() {\n    this.operations = [\n      {\n        type: 'PACKAGE_BUILD_STATS',\n        endpoint: '/size',\n        methodName: 'getPackageStats',\n      },\n      {\n        type: 'PACKAGE_EXPORTS',\n        endpoint: '/exports',\n        methodName: 'getAllPackageExports',\n      },\n      {\n        type: 'PACKAGE_EXPORTS_SIZES',\n        endpoint: '/exports-sizes',\n        methodName: 'getPackageExportSizes',\n      },\n    ];\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    try {\n      const response = await axios.get(\n        `${process.env.BUILD_SERVICE_ENDPOINT}${operation.endpoint}?p=${encodeURIComponent(packageString)}`\n      );\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      const contents = error.response.data;\n      throw new CustomError(\n        contents.name || 'BuildError',\n        contents.originalError,\n        contents.extra\n      );\n    } else if (error.request) {\n      throw new CustomError('BuildError', {\n        operation: operationType,\n        reason: 'BUILD_SERVICE_UNREACHABLE',\n        url: error.request._currentUrl,\n      });\n    } else {\n      throw new CustomError('BuildError', error.message, {\n        operation: operationType,\n      });\n    }\n  }\n\n  async getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_BUILD_STATS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS_SIZES');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport axios\nimport json\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/build/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/build/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/build/export-sizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation, packageString):\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        params = {\"package\": packageString}\n        return axios.get(url, {params})\n\n    def _handleError(self, error, operationType):\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageBuildStats\"))\n\n    def getPackageExports(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageExports\"))\n\n    def getPackageExportSizes(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageExportSizes\"))\n```",
      "```python\nimport axios\nimport json\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exportSizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation, packageString):\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        params = {\"package\": packageString}\n        return axios.get(url, {params})\n\n    def _handleError(self, error, operationType):\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received from the server\")\n        else:\n            raise CustomError(f\"An error occurred during the {operationType} operation: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageBuildStats\")\n\n    def getPackageExports(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageExports\")\n\n    def getPackageExportSizes(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageExportSizes\")\n```",
      "```python\nimport axios\nimport json\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/sizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation, packageString):\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        params = {\"package\": packageString}\n        return axios.get(url, {params})\n\n    def _handleError(self, error, operationType):\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageBuildStats\")\n\n    def getPackageExports(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageExports\")\n\n    def getPackageExportSizes(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageExportSizes\")\n```",
      "```python\nimport axios\nimport json\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/build/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/build/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/build/exports/sizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation, packageString):\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        params = {\"package\": packageString}\n        return axios.get(url, {params})\n\n    def _handleError(self, error, operationType):\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageBuildStats\"))\n\n    def getPackageExports(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageExports\"))\n\n    def getPackageExportSizes(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageExportSizes\"))\n```",
      "```python\nimport axios\nimport json\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/sizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation, packageString):\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        params = {\"package\": packageString}\n        return axios.get(url, {params})\n\n    def _handleError(self, error, operationType):\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageBuildStats\")\n\n    def getPackageExports(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageExports\")\n\n    def getPackageExportSizes(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as e:\n            self._handleError(e, \"getPackageExportSizes\")\n```",
      "```python\nimport axios\nfrom typing import List, Dict, Any, Promise\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/export-sizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation: Dict[str, Any], packageString: str) -> Promise[Dict[str, Any]]:\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        params = {\"package\": packageString}\n        return axios.get(url, {params})\n\n    def _handleError(self, error: Exception, operationType: str) -> None:\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received from the server\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString: str) -> Promise[Dict[str, Any]]:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise ValueError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageBuildStats\"))\n\n    def getPackageExports(self, packageString: str) -> Promise[Dict[str, Any]]:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise ValueError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageExports\"))\n\n    def getPackageExportSizes(self, packageString: str) -> Promise[Dict[str, Any]]:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise ValueError(\"Invalid operation\")\n        return self._makeHttpRequest(operation, packageString).then(response => response.data).catch(error => self._handleError(error, \"getPackageExportSizes\"))\n\nclass CustomError(Exception):\n    pass\n```",
      "```python\nimport axios\nfrom typing import List, Dict, Any\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/sizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation: Dict[str, Any], packageString: str) -> Any:\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        response = axios.get(url, params={\"package\": packageString})\n        return response\n\n    def _handleError(self, error: Exception, operationType: str) -> None:\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageBuildStats\")\n\n    def getPackageExports(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageExports\")\n\n    def getPackageExportSizes(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageExportSizes\")\n```",
      "```python\nimport axios\nfrom typing import List, Dict, Any\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exportSizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation: Dict[str, Any], packageString: str) -> Any:\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        response = axios.get(url, params={\"package\": packageString})\n        return response\n\n    def _handleError(self, error: Exception, operationType: str) -> None:\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == 'getPackageBuildStats'), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, 'getPackageBuildStats')\n\n    def getPackageExports(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == 'getPackageExports'), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, 'getPackageExports')\n\n    def getPackageExportSizes(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == 'getPackageExportSizes'), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, 'getPackageExportSizes')\n```",
      "```python\nimport axios\nfrom typing import List, Dict, Any\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/sizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation: Dict[str, Any], packageString: str) -> Any:\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        response = axios.get(url, params={\"package\": packageString})\n        return response\n\n    def _handleError(self, error: Exception, operationType: str) -> None:\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageBuildStats\")\n\n    def getPackageExports(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageExports\")\n\n    def getPackageExportSizes(self, packageString: str) -> Any:\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageExportSizes\")\n```",
      "```python\nimport axios\nimport json\n\nclass CustomError(Exception):\n    pass\n\nclass BuildService:\n    def __init__(self):\n        self.operations = [\n            {\"type\": \"GET\", \"endpoint\": \"/stats\", \"method\": \"getPackageBuildStats\"},\n            {\"type\": \"GET\", \"endpoint\": \"/exports\", \"method\": \"getPackageExports\"},\n            {\"type\": \"GET\", \"endpoint\": \"/export-sizes\", \"method\": \"getPackageExportSizes\"}\n        ]\n\n    def _makeHttpRequest(self, operation, packageString):\n        url = f\"https://buildservice.com{operation['endpoint']}\"\n        params = {\"package\": packageString}\n        return axios.get(url, {params})\n\n    def _handleError(self, error, operationType):\n        if error.response:\n            raise CustomError(f\"Error {error.response.status}: {error.response.data}\")\n        elif error.request:\n            raise CustomError(\"No response received\")\n        else:\n            raise CustomError(f\"Error during {operationType}: {str(error)}\")\n\n    def getPackageBuildStats(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageBuildStats\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageBuildStats\")\n\n    def getPackageExports(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExports\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageExports\")\n\n    def getPackageExportSizes(self, packageString):\n        operation = next((op for op in self.operations if op['method'] == \"getPackageExportSizes\"), None)\n        if not operation:\n            raise CustomError(\"Invalid operation\")\n        try:\n            response = self._makeHttpRequest(operation, packageString)\n            return response.data\n        except Exception as error:\n            self._handleError(error, \"getPackageExportSizes\")\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a function to establish and manage a WebSocket connection in a browser environment, including handling connection events, sending messages, and closing the connection.\n\nFunction Description: The function `setupWebSocketConnection` initializes a WebSocket connection to a specified URL and provides methods to interact with the connection. It sets up event handlers for connection events (`open`, `message`, `close`, `error`) and returns an object with methods to send data, close the connection, and set the binary type of the WebSocket.\n\nInput: \n- `url` [String] - The URL to which the WebSocket connection will be established.\n\nOutput: \n- Returns an object with the following methods:\n  - `send(data)` - Sends data through the WebSocket connection.\n  - `close()` - Closes the WebSocket connection.\n  - `setBinaryType(type)` - Sets the binary type of the WebSocket connection (`blob` or `arraybuffer`).",
    "Canonical_solution": "function setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  \n  ws.onopen = function() {\n    alert('open');\n  };\n  \n  ws.onmessage = function(message) {\n    alert(message.data);\n  };\n  \n  ws.onclose = function() {\n    alert('close');\n  };\n  \n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    send: function(data) {\n      ws.send(data);\n    },\n    close: function() {\n      ws.close();\n    },\n    setBinaryType: function(type) {\n      ws.binaryType = type;\n    }\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return methods;\n}\n```",
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return methods;\n}\n```",
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return methods;\n}\n```",
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n  \n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n  \n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n  \n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n  \n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n  \n  return methods;\n}\n```",
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return methods;\n}\n```",
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return methods;\n}\n```",
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return methods;\n}\n```",
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return methods;\n}\n```",
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n  };\n\n  ws.onmessage = (event) => {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  return methods;\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nfunction setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  const methods = {\n    send(data) {\n      ws.send(data);\n    },\n    close() {\n      ws.close();\n    },\n    setBinaryType(type) {\n      ws.binaryType = type;\n    }\n  };\n\n  ws.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n  });\n\n  ws.addEventListener('message', (event) => {\n    console.log('Message received:', event.data);\n  });\n\n  ws.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n  });\n\n  ws.addEventListener('error', (error) => {\n    console.error('WebSocket error:', error);\n  });\n\n  return methods;\n}\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, listens for incoming messages, and sends user input from a text box when the Enter key is pressed.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a specified server URL. It sets up an event listener for incoming messages to display them in a designated HTML element. Additionally, it listens for the Enter key press in a text box to send the input text via the WebSocket connection and clears the text box afterward.\n\nInput: None (The function uses DOM elements with IDs \"txt\" and \"divOut\" for text input and message display, respectively.)\n\nOutput: None (The function's side effects include establishing a WebSocket connection, displaying received messages in the \"divOut\" element, and sending user input to the server.)",
    "Canonical_solution": "function setupWebSocket() {\n    const txtBox = document.getElementById(\"txt\");\n    const divOut = document.getElementById(\"divOut\");\n    const ws = new WebSocket(\"ws://localhost/wsapp/\");\n    \n    ws.onmessage = function(e) {\n        divOut.innerHTML += e.data + \"<br/>\";\n    };\n    \n    txtBox.addEventListener(\"keypress\", function(e) {\n        if (e.keyCode === 13) {\n            ws.send(txtBox.value);\n            txtBox.value = \"\";\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction setupWebSocket() {\n    var ws = new WebSocket('ws://example.com/socketserver');\n    ws.onmessage = function(event) {\n        document.getElementById('divOut').innerHTML += '<br>' + event.data;\n    };\n    document.getElementById('txt').addEventListener('keypress', function(event) {\n        if (event.key === 'Enter') {\n            ws.send(document.getElementById('txt').value);\n            document.getElementById('txt').value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n  const ws = new WebSocket('ws://example.com');\n  const outputDiv = document.getElementById('divOut');\n  const inputTxt = document.getElementById('txt');\n\n  ws.onmessage = function(event) {\n    outputDiv.innerHTML += `<p>${event.data}</p>`;\n  };\n\n  inputTxt.addEventListener('keypress', function(event) {\n    if (event.key === 'Enter') {\n      ws.send(inputTxt.value);\n      inputTxt.value = '';\n    }\n  });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    var ws = new WebSocket('ws://example.com/socketserver');\n    ws.onmessage = function(event) {\n        document.getElementById('divOut').innerHTML += '<br>' + event.data;\n    };\n    document.getElementById('txt').addEventListener('keypress', function(event) {\n        if (event.key === 'Enter') {\n            ws.send(document.getElementById('txt').value);\n            document.getElementById('txt').value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    var ws = new WebSocket('ws://example.com/socketserver');\n\n    ws.onmessage = function(event) {\n        document.getElementById('divOut').innerHTML += '<p>' + event.data + '</p>';\n    };\n\n    document.getElementById('txt').addEventListener('keypress', function(e) {\n        if (e.key === 'Enter') {\n            ws.send(document.getElementById('txt').value);\n            document.getElementById('txt').value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const ws = new WebSocket('ws://example.com/socketserver');\n\n    ws.onmessage = function(event) {\n        document.getElementById('divOut').textContent += event.data + '\\n';\n    };\n\n    document.getElementById('txt').addEventListener('keypress', function(e) {\n        if (e.key === 'Enter') {\n            ws.send(document.getElementById('txt').value);\n            document.getElementById('txt').value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const ws = new WebSocket('ws://example.com');\n\n    ws.onmessage = function(event) {\n        document.getElementById('divOut').textContent += event.data + '\\n';\n    };\n\n    document.getElementById('txt').addEventListener('keypress', function(e) {\n        if (e.key === 'Enter') {\n            ws.send(document.getElementById('txt').value);\n            document.getElementById('txt').value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const ws = new WebSocket('ws://example.com');\n\n    ws.onmessage = function(event) {\n        document.getElementById('divOut').textContent += event.data + '\\n';\n    };\n\n    document.getElementById('txt').addEventListener('keypress', function(e) {\n        if (e.key === 'Enter') {\n            ws.send(document.getElementById('txt').value);\n            document.getElementById('txt').value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const ws = new WebSocket('ws://example.com');\n    const outputDiv = document.getElementById('divOut');\n    const inputTxt = document.getElementById('txt');\n\n    ws.onmessage = function(event) {\n        outputDiv.innerHTML += `<p>${event.data}</p>`;\n    };\n\n    inputTxt.addEventListener('keypress', function(event) {\n        if (event.key === 'Enter') {\n            ws.send(inputTxt.value);\n            inputTxt.value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const ws = new WebSocket('ws://example.com/socketserver');\n\n    ws.onopen = function() {\n        console.log('WebSocket connection established');\n    };\n\n    ws.onmessage = function(event) {\n        document.getElementById('divOut').innerHTML += `<p>${event.data}</p>`;\n    };\n\n    ws.onerror = function(error) {\n        console.error('WebSocket error:', error);\n    };\n\n    ws.onclose = function() {\n        console.log('WebSocket connection closed');\n    };\n\n    document.getElementById('txt').addEventListener('keypress', function(event) {\n        if (event.key === 'Enter') {\n            ws.send(document.getElementById('txt').value);\n            document.getElementById('txt').value = '';\n        }\n    });\n}\n```",
      "```javascript\nfunction setupWebSocket() {\n    const ws = new WebSocket('ws://example.com/socketserver');\n    ws.onmessage = function(event) {\n        document.getElementById('divOut').textContent += event.data + '\\n';\n    };\n    document.getElementById('txt').addEventListener('keypress', function(event) {\n        if (event.key === 'Enter') {\n            ws.send(document.getElementById('txt').value);\n            document.getElementById('txt').value = '';\n        }\n    });\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, sends messages, and handles incoming messages, connection events, and errors.\n\nFunction Description: The WebSocket client connects to a specified URI using a custom protocol, provides functions to send messages, and includes event handlers for connection opening, message reception, and errors.\n\nInput:\n- `wsUri` (String): The WebSocket server URI to connect to (e.g., \"ws://example.com/socket\").\n- `myProtocol` (String): The subprotocol to use for the WebSocket connection (e.g., \"myProtocol\").\n- `myField.value` (String): The message to be sent to the server (provided via an input field in the UI).\n\nOutput:\n- Console/log output indicating connection status, sent messages, received messages, and errors.\n- No explicit return value; side effects include WebSocket communication and logging.\n\nMethods (implicit in the reference code):\n- `echoText()` -> undefined - Sends the value of `myField` to the WebSocket server and logs the sent message.\n- `onOpen(evt)` -> undefined - Logs when the WebSocket connection is successfully established.\n- `onMessage(evt)` -> undefined - Logs messages received from the WebSocket server.\n- `onError(evt)` -> undefined - Logs errors encountered during WebSocket communication.",
    "Canonical_solution": "function echoText() {\n    websocket.send(myField.value);\n    writeToScreen(\"SENT: \" + myField.value);\n}\n\nfunction onOpen() {\n    writeToScreen(\"CONNECTED\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen(\"RECEIVED: \" + evt.data);\n}\n\nfunction onError(evt) {\n    writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nvar websocket = new WebSocket(wsUri, \"myProtocol\");\nwebsocket.onopen = function(evt) { onOpen(evt) };\nwebsocket.onmessage = function(evt) { onMessage(evt) };\nwebsocket.onerror = function(evt) { onError(evt) };",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nconst ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction onOpen(evt) {\n    console.log(\"Connection opened\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Message received: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"Error occurred: \" + evt.message);\n}\n\nfunction echoText() {\n    const message = myField.value;\n    ws.send(message);\n    console.log(\"Sent message: \" + message);\n}\n```",
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nconst ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction echoText() {\n    const message = myField.value;\n    ws.send(message);\n    console.log(\"Sent message: \" + message);\n}\n\nfunction onOpen(evt) {\n    console.log(\"WebSocket connection established.\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Received message: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"WebSocket error: \" + evt.message);\n}\n```",
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nconst ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction echoText() {\n    const message = myField.value;\n    ws.send(message);\n    console.log(\"Sent message: \" + message);\n}\n\nfunction onOpen(evt) {\n    console.log(\"WebSocket connection established.\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Received message: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"WebSocket error: \" + evt.message);\n}\n```",
      "```javascript\nvar wsUri = \"ws://example.com/socket\";\nvar myProtocol = \"myProtocol\";\nvar ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction onOpen(evt) {\n    console.log(\"Connection opened\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Message received: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"Error occurred: \" + evt.data);\n}\n\nfunction echoText() {\n    var myField = document.getElementById(\"myField\");\n    var value = myField.value;\n    ws.send(value);\n    console.log(\"Message sent: \" + value);\n}\n```",
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nconst ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction echoText() {\n    const message = myField.value;\n    ws.send(message);\n    console.log(\"Sent: \" + message);\n}\n\nfunction onOpen(evt) {\n    console.log(\"Connection opened\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Received: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"Error: \" + evt.message);\n}\n```",
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nconst ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction echoText() {\n    const message = myField.value;\n    ws.send(message);\n    console.log(\"Sent message: \" + message);\n}\n\nfunction onOpen(evt) {\n    console.log(\"WebSocket connection established.\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Received message: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"WebSocket error: \" + evt.message);\n}\n```",
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nlet ws;\n\nfunction connect() {\n  ws = new WebSocket(wsUri, myProtocol);\n  ws.onopen = onOpen;\n  ws.onmessage = onMessage;\n  ws.onerror = onError;\n}\n\nfunction echoText() {\n  const message = myField.value;\n  console.log(\"Sent: \" + message);\n  ws.send(message);\n}\n\nfunction onOpen(evt) {\n  console.log(\"Connection opened\");\n}\n\nfunction onMessage(evt) {\n  console.log(\"Received: \" + evt.data);\n}\n\nfunction onError(evt) {\n  console.log(\"Error: \" + evt.message);\n}\n\nconnect();\n```",
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nconst ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction echoText() {\n    const message = myField.value;\n    ws.send(message);\n    console.log(\"Sent message: \" + message);\n}\n\nfunction onOpen(evt) {\n    console.log(\"WebSocket connection established.\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Received message: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"WebSocket error: \" + evt.message);\n}\n```",
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nconst ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction onOpen(evt) {\n    console.log(\"Connection opened\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Message received: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"Error occurred: \" + evt.message);\n}\n\nfunction echoText() {\n    const message = myField.value;\n    ws.send(message);\n    console.log(\"Sent message: \" + message);\n}\n```",
      "```javascript\nconst wsUri = \"ws://example.com/socket\";\nconst myProtocol = \"myProtocol\";\nconst myField = { value: \"\" };\n\nconst ws = new WebSocket(wsUri, myProtocol);\n\nws.onopen = function(evt) {\n    onOpen(evt);\n};\n\nws.onmessage = function(evt) {\n    onMessage(evt);\n};\n\nws.onerror = function(evt) {\n    onError(evt);\n};\n\nfunction echoText() {\n    const message = myField.value;\n    ws.send(message);\n    console.log(\"Sent message: \" + message);\n}\n\nfunction onOpen(evt) {\n    console.log(\"Connection opened\");\n}\n\nfunction onMessage(evt) {\n    console.log(\"Received message: \" + evt.data);\n}\n\nfunction onError(evt) {\n    console.log(\"Error occurred: \" + evt.message);\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a WebSocket client class in JavaScript that manages WebSocket connections, including connection establishment, message handling, error handling, and reconnection logic.\n\nClass Description: The S class is a custom HTMLElement that encapsulates WebSocket functionality. It handles WebSocket connection lifecycle events, message processing (both text and binary), automatic reconnection, and provides methods for sending data.\n\nAttributes:\n- wsState: [Number] - Tracks the current state of the WebSocket connection (CLOSED, CONNECTING, OPEN)\n- ws: [WebSocket|null] - The active WebSocket connection instance\n- wsURL: [String] - The URL for the WebSocket server connection\n- onmessage: [Object|null] - Callback functions for handling incoming messages\n- connectTS: [Number] - Timestamp of when the connection was initiated\n- reconnectTID: [Number] - Timeout ID for reconnection attempts\n- RECONNECT_TIMEOUT: [Number] - Constant for reconnection delay (implied but not shown in code)\n- ondata: [Function|null] - Callback for binary data handling\n\nMethods:\n- onconnect() -> [Boolean] - Initiates a WebSocket connection. Returns true if connection attempt started.\n- onopen() -> [void] - Handles WebSocket open event, sets up message listeners.\n- onclose() -> [Boolean] - Handles WebSocket close event, initiates reconnection. Returns true if reconnection scheduled.\n- ondisconnect() -> [void] - Closes the WebSocket connection and cleans up resources.\n- send(e: [Object]) -> [void] - Sends a JSON-serialized message through the WebSocket connection.",
    "Canonical_solution": "class S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = WebSocket.CLOSED;\n    this.ws = null;\n    this.wsURL = \"\";\n    this.onmessage = null;\n  }\n\n  onconnect() {\n    if (!this.isConnected || !this.wsURL || this.ws || this.pc) return false;\n    \n    this.wsState = WebSocket.CONNECTING;\n    this.connectTS = Date.now();\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.binaryType = \"arraybuffer\";\n    \n    this.ws.addEventListener(\"open\", (e) => this.onopen(e));\n    this.ws.addEventListener(\"close\", (e) => this.onclose(e));\n    \n    return true;\n  }\n\n  onopen() {\n    this.wsState = WebSocket.OPEN;\n    \n    this.ws.addEventListener(\"message\", (e) => {\n      if (\"string\" == typeof e.data) {\n        const t = JSON.parse(e.data);\n        for (const e in this.onmessage) this.onmessage[e](t);\n      } else {\n        this.ondata(e.data);\n      }\n    });\n    \n    this.ondata = null;\n    this.onmessage = {};\n  }\n\n  onclose() {\n    if (this.wsState === WebSocket.CLOSED) return false;\n    \n    this.wsState = WebSocket.CONNECTING;\n    this.ws = null;\n    \n    const e = Math.max(this.RECONNECT_TIMEOUT - (Date.now() - this.connectTS), 0);\n    this.reconnectTID = setTimeout(() => {\n      this.reconnectTID = 0;\n      this.onconnect();\n    }, e);\n    \n    return true;\n  }\n\n  ondisconnect() {\n    this.wsState = WebSocket.CLOSED;\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  send(e) {\n    this.ws && this.ws.send(JSON.stringify(e));\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3;\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) {\n      this.ws = new WebSocket(this.wsURL);\n      this.ws.onopen = this.onopen.bind(this);\n      this.ws.onmessage = this.onmessage.bind(this);\n      this.ws.onerror = this.onerror.bind(this);\n      this.ws.onclose = this.onclose.bind(this);\n      this.ws.binaryType = 'blob';\n      this.connectTS = Date.now();\n      this.wsState = 0;\n      return true;\n    }\n    return false;\n  }\n\n  onopen() {\n    this.wsState = 2;\n    this.reconnectTID = null;\n    this.onmessage && this.onmessage.call(this, { data: 'connected' });\n  }\n\n  onclose() {\n    this.wsState = 3;\n    this.onmessage && this.onmessage.call(this, { data: 'disconnected' });\n    this.reconnectTID = setTimeout(() => {\n      this.onconnect();\n    }, this.RECONNECT_TIMEOUT);\n    return true;\n  }\n\n  ondisconnect() {\n    this.ws && this.ws.close();\n    this.ws = null;\n    this.wsState = 3;\n    clearTimeout(this.reconnectTID);\n    this.reconnectTID = null;\n  }\n\n  send(e) {\n    if (this.wsState === 2) {\n      if (e.data instanceof Blob) {\n        this.ondata && this.ondata(e.data);\n      } else {\n        this.ws.send(JSON.stringify(e));\n      }\n    }\n  }\n}\n```",
      "```javascript\nclass S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3;\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) {\n      this.ws = new WebSocket(this.wsURL);\n      this.ws.onopen = this.onopen.bind(this);\n      this.ws.onmessage = this.onmessage.bind(this);\n      this.ws.onerror = this.onerror.bind(this);\n      this.ws.onclose = this.onclose.bind(this);\n      this.connectTS = Date.now();\n      this.wsState = 0;\n      return true;\n    }\n    return false;\n  }\n\n  onopen() {\n    this.wsState = 2;\n    this.reconnectTID = null;\n    this.onmessage && this.onmessage();\n  }\n\n  onclose() {\n    this.wsState = 3;\n    this.ws = null;\n    this.ondisconnect();\n    return this.scheduleReconnect();\n  }\n\n  ondisconnect() {\n    // Cleanup resources if necessary\n  }\n\n  send(e) {\n    if (this.wsState === 2) {\n      const message = JSON.stringify(e);\n      this.ws.send(message);\n    }\n  }\n\n  scheduleReconnect() {\n    if (!this.reconnectTID) {\n      this.reconnectTID = setTimeout(() => {\n        this.onconnect();\n      }, this.RECONNECT_TIMEOUT);\n    }\n    return true;\n  }\n\n  onerror() {\n    // Handle WebSocket error\n  }\n}\n```",
      "```javascript\nclass S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3; // CLOSED\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) return true;\n    this.wsState = 0; // CONNECTING\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.onopen = this.onopen.bind(this);\n    this.ws.onmessage = this.onmessage.bind(this);\n    this.ws.onerror = this.onerror.bind(this);\n    this.ws.onclose = this.onclose.bind(this);\n    return true;\n  }\n\n  onopen() {\n    this.wsState = 2; // OPEN\n    this.connectTS = Date.now();\n    this.reconnectTID = null;\n    this.onmessage && this.onmessage.apply(this, arguments);\n  }\n\n  onclose() {\n    this.wsState = 3; // CLOSED\n    this.ws = null;\n    this.reconnectTID && clearTimeout(this.reconnectTID);\n    this.reconnectTID = setTimeout(() => {\n      this.onconnect();\n    }, this.RECONNECT_TIMEOUT);\n    return true;\n  }\n\n  ondisconnect() {\n    this.wsState = 3; // CLOSED\n    this.ws = null;\n    this.reconnectTID && clearTimeout(this.reconnectTID);\n    this.reconnectTID = null;\n  }\n\n  send(e) {\n    if (this.wsState === 2) {\n      this.ws.send(JSON.stringify(e));\n    }\n  }\n}\n```",
      "```javascript\nclass S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3;\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) {\n      this.ws = new WebSocket(this.wsURL);\n      this.ws.onopen = this.onopen.bind(this);\n      this.ws.onmessage = this.onmessage.bind(this);\n      this.ws.onerror = this.onerror.bind(this);\n      this.ws.onclose = this.onclose.bind(this);\n      this.connectTS = Date.now();\n      this.wsState = 0;\n      return true;\n    }\n    return false;\n  }\n\n  onopen() {\n    this.wsState = 2;\n    this.reconnectTID = null;\n    this.onmessage && this.onmessage.call(this, { data: 'connected' });\n  }\n\n  onclose() {\n    this.wsState = 3;\n    this.onmessage && this.onmessage.call(this, { data: 'disconnected' });\n    this.scheduleReconnect();\n    return true;\n  }\n\n  scheduleReconnect() {\n    if (!this.reconnectTID) {\n      this.reconnectTID = setTimeout(() => {\n        this.onconnect();\n      }, this.RECONNECT_TIMEOUT);\n    }\n  }\n\n  ondisconnect() {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.wsState = 3;\n    clearTimeout(this.reconnectTID);\n    this.reconnectTID = null;\n  }\n\n  send(e) {\n    if (this.wsState === 2) {\n      if (typeof e === 'object') {\n        e = JSON.stringify(e);\n      }\n      this.ws.send(e);\n    }\n  }\n}\n```",
      "```javascript\nclass S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3;\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) {\n      this.ws = new WebSocket(this.wsURL);\n      this.ws.onopen = this.onopen.bind(this);\n      this.ws.onmessage = this.onmessage.bind(this);\n      this.ws.onerror = this.onerror.bind(this);\n      this.ws.onclose = this.onclose.bind(this);\n      this.connectTS = Date.now();\n      this.wsState = 0;\n      return true;\n    }\n    return false;\n  }\n\n  onopen() {\n    this.wsState = 2;\n    this.reconnectTID = null;\n    this.onmessage && this.onmessage.apply(this, arguments);\n  }\n\n  onclose() {\n    this.wsState = 3;\n    this.ws = null;\n    this.reconnectTID && clearTimeout(this.reconnectTID);\n    this.reconnectTID = setTimeout(() => {\n      this.onconnect();\n    }, this.RECONNECT_TIMEOUT);\n    return true;\n  }\n\n  ondisconnect() {\n    this.wsState = 3;\n    this.ws = null;\n    this.reconnectTID && clearTimeout(this.reconnectTID);\n    this.reconnectTID = null;\n  }\n\n  send(e) {\n    if (this.wsState === 2) {\n      this.ws.send(JSON.stringify(e));\n    }\n  }\n}\n```",
      "class S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3; // CLOSED\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) { // CONNECTING\n      return false;\n    }\n    this.wsState = 1; // CONNECTING\n    this.connectTS = Date.now();\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.onopen = this.onopen.bind(this);\n    this.ws.onmessage = this.onmessageHandler.bind(this);\n    this.ws.onerror = this.onerrorHandler.bind(this);\n    this.ws.onclose = this.onclose.bind(this);\n    return true;\n  }\n\n  onopen() {\n    this.wsState = 2; // OPEN\n    this.clearReconnect();\n  }\n\n  onclose() {\n    this.wsState = 3; // CLOSED\n    this.scheduleReconnect();\n    return true;\n  }\n\n  ondisconnect() {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.clearReconnect();\n  }\n\n  send(e) {\n    if (this.wsState === 2) { // OPEN\n      this.ws.send(JSON.stringify(e));\n    }\n  }\n\n  onmessageHandler(event) {\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    if (this.ondata && event.data instanceof Blob) {\n      this.ondata(event);\n    }\n  }\n\n  onerrorHandler(event) {\n    console.error('WebSocket Error:', event);\n    this.ondisconnect();\n  }\n\n  scheduleReconnect() {\n    if (this.reconnectTID) {\n      clearTimeout(this.reconnectTID);\n    }\n    this.reconnectTID = setTimeout(() => {\n      this.onconnect();\n    }, this.RECONNECT_TIMEOUT);\n  }\n\n  clearReconnect() {\n    if (this.reconnectTID) {\n      clearTimeout(this.reconnectTID);\n      this.reconnectTID = null;\n    }\n  }\n}",
      "class S extends HTMLElement {\n  wsState = 0;\n  ws = null;\n  wsURL = '';\n  onmessage = null;\n  connectTS = 0;\n  reconnectTID = 0;\n  RECONNECT_TIMEOUT = 5000;\n  ondata = null;\n\n  onconnect() {\n    if (this.wsState === 1) return true;\n    this.ws = new WebSocket(this.wsURL);\n    this.wsState = 2;\n    this.connectTS = Date.now();\n    this.ws.onopen = this.onopen;\n    this.ws.onclose = this.onclose;\n    this.ws.onerror = this.onerror;\n    this.ws.onmessage = this.onmessage;\n    return true;\n  }\n\n  onopen() {\n    this.wsState = 1;\n    this.reconnectTID = 0;\n    this.onmessage = this.onmessage;\n  }\n\n  onclose() {\n    this.wsState = 3;\n    this.reconnectTID = setTimeout(() => {\n      this.onconnect();\n    }, this.RECONNECT_TIMEOUT);\n    return true;\n  }\n\n  ondisconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTID) {\n      clearTimeout(this.reconnectTID);\n      this.reconnectTID = 0;\n    }\n  }\n\n  send(e) {\n    if (this.wsState === 1) {\n      this.ws.send(JSON.stringify(e));\n    }\n  }\n}",
      "```javascript\nclass S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3;\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) {\n      this.ws = new WebSocket(this.wsURL);\n      this.ws.onopen = () => this.onopen();\n      this.ws.onclose = () => this.onclose();\n      this.ws.onerror = (e) => this.onerror(e);\n      this.ws.onmessage = (e) => this.onmessage(e);\n      this.connectTS = Date.now();\n      return true;\n    }\n    return false;\n  }\n\n  onopen() {\n    this.wsState = 0;\n    this.reconnectTID = null;\n    this.onmessage = (e) => {\n      if (e.data instanceof Blob) {\n        this.ondata(e.data);\n      } else {\n        this.onmessage = JSON.parse(e.data);\n      }\n    };\n  }\n\n  onclose() {\n    this.wsState = 3;\n    this.ws = null;\n    this.reconnectTID = setTimeout(() => this.onconnect(), this.RECONNECT_TIMEOUT);\n    return true;\n  }\n\n  ondisconnect() {\n    if (this.ws) {\n      this.ws.close();\n    }\n    this.onmessage = null;\n    this.ondata = null;\n    clearTimeout(this.reconnectTID);\n    this.reconnectTID = null;\n  }\n\n  send(e) {\n    if (this.wsState === 0 && this.ws) {\n      this.ws.send(JSON.stringify(e));\n    }\n  }\n}\n```",
      "class S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3; // CLOSED\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) return true; // CONNECTING\n    this.wsState = 0; // CONNECTING\n    this.connectTS = Date.now();\n    this.ws = new WebSocket(this.wsURL);\n    this.ws.onopen = this.onopen.bind(this);\n    this.ws.onmessage = this.onmessageHandler.bind(this);\n    this.ws.onerror = this.onerrorHandler.bind(this);\n    this.ws.onclose = this.onclose.bind(this);\n    return true;\n  }\n\n  onopen() {\n    this.wsState = 2; // OPEN\n    this.reconnectTID = null;\n    this.connectTS = Date.now();\n  }\n\n  onclose() {\n    this.wsState = 3; // CLOSED\n    this.reconnectTID = setTimeout(this.onconnect.bind(this), this.RECONNECT_TIMEOUT);\n    return true;\n  }\n\n  ondisconnect() {\n    this.wsState = 3; // CLOSED\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.reconnectTID) {\n      clearTimeout(this.reconnectTID);\n      this.reconnectTID = null;\n    }\n  }\n\n  send(e) {\n    if (this.wsState === 2) {\n      this.ws.send(JSON.stringify(e));\n    }\n  }\n\n  onmessageHandler(event) {\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    if (this.ondata && event.data instanceof Blob) {\n      this.ondata(event.data);\n    }\n  }\n\n  onerrorHandler(event) {\n    console.error('WebSocket Error:', event);\n    this.ondisconnect();\n  }\n}",
      "```javascript\nclass S extends HTMLElement {\n  constructor() {\n    super();\n    this.wsState = 3;\n    this.ws = null;\n    this.wsURL = '';\n    this.onmessage = null;\n    this.connectTS = 0;\n    this.reconnectTID = null;\n    this.RECONNECT_TIMEOUT = 5000;\n    this.ondata = null;\n  }\n\n  onconnect() {\n    if (this.wsState === 1) {\n      this.ws = new WebSocket(this.wsURL);\n      this.ws.onopen = this.onopen.bind(this);\n      this.ws.onmessage = this.onmessage.bind(this);\n      this.ws.onerror = this.onerror.bind(this);\n      this.ws.onclose = this.onclose.bind(this);\n      this.connectTS = Date.now();\n      return true;\n    }\n    return false;\n  }\n\n  onopen() {\n    this.wsState = 0;\n    this.reconnectTID = null;\n    this.onmessage && this.onmessage();\n  }\n\n  onclose() {\n    this.wsState = 3;\n    this.ws = null;\n    this.onclose && this.onclose();\n    return this.scheduleReconnect();\n  }\n\n  ondisconnect() {\n    this.wsState = 3;\n    this.ws = null;\n    this.reconnectTID = null;\n    this.ondisconnect && this.ondisconnect();\n  }\n\n  send(e) {\n    if (this.wsState === 0 && this.ws) {\n      this.ws.send(JSON.stringify(e));\n    }\n  }\n\n  scheduleReconnect() {\n    if (this.reconnectTID) {\n      clearTimeout(this.reconnectTID);\n    }\n    this.reconnectTID = setTimeout(() => {\n      this.onconnect();\n    }, this.RECONNECT_TIMEOUT);\n    return true;\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Implement a WebSocket client class for streaming timeline data from a server, handling connection events, message parsing, and connection cleanup.\n\nClass Description: The TimelineStream class establishes and manages a WebSocket connection to stream timeline data from a specified API endpoint. It handles connection setup, message reception, error handling, and proper connection closure.\n\nAttributes:\n- _streamingApi: [String] - The base URL of the streaming API server\n- _accessToken: [String] - Authentication token for the API connection\n- _timeline: [String] - Identifier for the specific timeline stream\n- _ws: [WebSocketClient] - Instance of the WebSocket connection\n- _opened: [Boolean] - Flag indicating if the connection is established\n\nMethods:\n- constructor(streamingApi, accessToken, timeline) -> [TimelineStream] - Initializes a new TimelineStream instance with API details and sets up the WebSocket connection\n- _setupWebSocket() -> [void] - Creates a new WebSocket connection, configures event handlers for open, message, and close events\n- _closeWebSocket() -> [void] - Properly closes the WebSocket connection and cleans up event handlers\n- sendMessage(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Public method to close the WebSocket connection",
    "Canonical_solution": "import { WebSocketClient } from '../../_thirdparty/websocket/websocket.js'\nimport { getStreamUrl } from './getStreamUrl.js'\nimport { safeParse } from '../../_utils/safeParse.js'\n\nclass TimelineStream {\n  constructor (streamingApi, accessToken, timeline) {\n    this._streamingApi = streamingApi\n    this._accessToken = accessToken\n    this._timeline = timeline\n    this._setupWebSocket()\n  }\n\n  _setupWebSocket () {\n    const url = getStreamUrl(this._streamingApi, this._accessToken, this._timeline)\n    const ws = new WebSocketClient(url)\n\n    ws.onopen = () => {\n      if (!this._opened) {\n        this._opened = true\n      }\n    }\n    ws.onmessage = (e) => safeParse(e.data)\n    ws.onclose = () => {}\n\n    this._ws = ws\n  }\n\n  _closeWebSocket () {\n    if (this._ws) {\n      this._ws.onopen = null\n      this._ws.onmessage = null\n      this._ws.onclose = null\n      this._ws.close()\n      this._ws = null\n    }\n  }\n\n  sendMessage (message) {\n    if (this._ws && this._ws.readyState === WebSocketClient.OPEN) {\n      this._ws.send(message)\n    }\n  }\n\n  close () {\n    this._closeWebSocket()\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport websocket\nimport threading\nimport json\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocketApp(self._streamingApi,\n                                          on_open=self._on_open,\n                                          on_message=self._on_message,\n                                          on_error=self._on_error,\n                                          on_close=self._on_close)\n        wst = threading.Thread(target=self._ws.run_forever)\n        wst.daemon = True\n        wst.start()\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _on_open(self, ws):\n        self._opened = True\n        self.sendMessage(json.dumps({\"action\": \"subscribe\", \"timeline\": self._timeline, \"token\": self._accessToken}))\n\n    def _on_message(self, ws, message):\n        print(message)\n\n    def _on_error(self, ws, error):\n        print(error)\n\n    def _on_close(self, ws):\n        self._opened = False\n```",
      "```python\nimport websocket\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._on_open\n        self._ws.on_message = self._on_message\n        self._ws.on_error = self._on_error\n        self._ws.on_close = self._on_close\n        self._ws.connect(self._streamingApi)\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n```",
      "```python\nimport websocket\nimport threading\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._onOpen\n        self._ws.on_message = self._onMessage\n        self._ws.on_error = self._onError\n        self._ws.on_close = self._onClose\n        self._ws.connect(f\"{self._streamingApi}/timeline/{self._timeline}?access_token={self._accessToken}\")\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _onOpen(self):\n        self._opened = True\n\n    def _onMessage(self, message):\n        print(\"Received message:\", message)\n\n    def _onError(self, error):\n        print(\"Error:\", error)\n\n    def _onClose(self):\n        self._opened = False\n```",
      "```python\nimport websocket\nimport json\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._on_open\n        self._ws.on_message = self._on_message\n        self._ws.on_error = self._on_error\n        self._ws.on_close = self._on_close\n        self._ws.connect(self._streamingApi + \"/stream?timeline=\" + self._timeline + \"&token=\" + self._accessToken)\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _on_open(self):\n        self._opened = True\n\n    def _on_message(self, message):\n        print(message)\n\n    def _on_error(self, error):\n        print(error)\n\n    def _on_close(self):\n        self._opened = False\n```",
      "```python\nimport websocket\nimport json\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._onOpen\n        self._ws.on_message = self._onMessage\n        self._ws.on_error = self._onError\n        self._ws.on_close = self._onClose\n        self._ws.connect(f\"{self._streamingApi}/stream?timeline={self._timeline}&token={self._accessToken}\")\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _onOpen(self):\n        self._opened = True\n\n    def _onMessage(self, message):\n        print(message)\n\n    def _onError(self, error):\n        print(error)\n\n    def _onClose(self):\n        self._opened = False\n```",
      "```python\nimport websocket\nimport threading\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._onOpen\n        self._ws.on_message = self._onMessage\n        self._ws.on_error = self._onError\n        self._ws.on_close = self._onClose\n        self._ws.connect(f\"{self._streamingApi}/stream?timeline={self._timeline}&access_token={self._accessToken}\")\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _onOpen(self):\n        self._opened = True\n\n    def _onMessage(self, message):\n        print(message)\n\n    def _onError(self, error):\n        print(error)\n\n    def _onClose(self):\n        self._opened = False\n```",
      "```python\nimport websocket\nimport json\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._on_open\n        self._ws.on_message = self._on_message\n        self._ws.on_error = self._on_error\n        self._ws.on_close = self._on_close\n        self._ws.connect(self._streamingApi)\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _on_open(self):\n        self._opened = True\n        auth_message = json.dumps({\"accessToken\": self._accessToken, \"timeline\": self._timeline})\n        self.sendMessage(auth_message)\n\n    def _on_message(self, message):\n        print(message)\n\n    def _on_error(self, error):\n        print(error)\n\n    def _on_close(self):\n        self._opened = False\n```",
      "```python\nimport websocket\nimport threading\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._onOpen\n        self._ws.on_message = self._onMessage\n        self._ws.on_error = self._onError\n        self._ws.on_close = self._onClose\n        self._ws.connect(f\"{self._streamingApi}/stream?timeline={self._timeline}&access_token={self._accessToken}\")\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _onOpen(self):\n        self._opened = True\n\n    def _onMessage(self, message):\n        # Handle message\n        pass\n\n    def _onError(self, error):\n        # Handle error\n        pass\n\n    def _onClose(self):\n        self._opened = False\n```",
      "```python\nimport websocket\nimport json\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._on_open\n        self._ws.on_message = self._on_message\n        self._ws.on_error = self._on_error\n        self._ws.on_close = self._on_close\n        self._ws.connect(self._streamingApi)\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _on_open(self):\n        self._opened = True\n        self.sendMessage(json.dumps({\"action\": \"subscribe\", \"timeline\": self._timeline, \"token\": self._accessToken}))\n\n    def _on_message(self, message):\n        print(message)\n\n    def _on_error(self, error):\n        print(error)\n\n    def _on_close(self):\n        self._opened = False\n```",
      "```python\nimport websocket\nimport threading\n\nclass TimelineStream:\n    def __init__(self, streamingApi, accessToken, timeline):\n        self._streamingApi = streamingApi\n        self._accessToken = accessToken\n        self._timeline = timeline\n        self._ws = None\n        self._opened = False\n\n    def _setupWebSocket(self):\n        self._ws = websocket.WebSocket()\n        self._ws.on_open = self._onOpen\n        self._ws.on_message = self._onMessage\n        self._ws.on_error = self._onError\n        self._ws.on_close = self._onClose\n        self._ws.connect(f\"{self._streamingApi}/timeline/{self._timeline}?token={self._accessToken}\")\n\n    def _closeWebSocket(self):\n        if self._ws:\n            self._ws.close()\n\n    def sendMessage(self, message):\n        if self._opened:\n            self._ws.send(message)\n\n    def close(self):\n        self._closeWebSocket()\n        self._opened = False\n\n    def _onOpen(self):\n        self._opened = True\n\n    def _onMessage(self, message):\n        print(\"Received message:\", message)\n\n    def _onError(self, error):\n        print(\"WebSocket error:\", error)\n\n    def _onClose(self):\n        self._opened = False\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Implement a WebSocket client class for managing connections, sending messages, and handling events in a browser environment using JavaScript.\n\nClass Description: MonitorManagerProxyClientImpl is a WebSocket client implementation that manages WebSocket connections, handles incoming messages, and provides methods for sending data and changing settings. It uses event emitters to notify about received messages and settings changes.\n\nAttributes:\n- webSocket: WebSocket | undefined - The active WebSocket connection instance\n- wsPort: number | undefined - The port number used for the WebSocket connection\n\nMethods:\n- connect(addressPort: number) -> Promise<void> - Establishes a WebSocket connection to the specified port. Returns a promise that resolves when connected or rejects on error.\n- disconnect() -> void - Closes the active WebSocket connection if it exists.\n- send(message: string) -> void - Sends a message through the WebSocket connection after formatting it with a command structure.\n- changeSettings(settings: MonitorSettings) -> void - Sends settings changes through the WebSocket connection.\n- isWSConnected() -> Promise<boolean> - Checks if the WebSocket connection is active.\n- getWebSocketPort() -> number | undefined - Returns the port number used for the current WebSocket connection.",
    "Canonical_solution": "@injectable()\nexport class MonitorManagerProxyClientImpl implements MonitorManagerProxyClient {\n  private webSocket?: WebSocket;\n  private wsPort?: number;\n\n  async connect(addressPort: number): Promise<void> {\n    if (this.webSocket) {\n      if (this.wsPort === addressPort) {\n        return;\n      }\n      this.disconnect();\n    }\n    try {\n      this.webSocket = new WebSocket(`ws://localhost:${addressPort}`);\n    } catch {\n      throw new Error('Unable to connect to websocket');\n    }\n\n    const opened = new Deferred<void>();\n    this.webSocket.onopen = () => opened.resolve();\n    this.webSocket.onerror = () => opened.reject();\n    this.webSocket.onmessage = (message) => {\n      const parsedMessage = JSON.parse(message.data);\n      if (Array.isArray(parsedMessage)) {\n        this.onMessagesReceivedEmitter.fire({ messages: parsedMessage });\n      } else if (\n        parsedMessage.command === Monitor.MiddlewareCommand.ON_SETTINGS_DID_CHANGE\n      ) {\n        this.onMonitorSettingsDidChangeEmitter.fire(parsedMessage.data);\n      }\n    };\n    this.wsPort = addressPort;\n    return opened.promise;\n  }\n\n  disconnect(): void {\n    if (!this.webSocket) {\n      return;\n    }\n    try {\n      this.webSocket.close();\n      this.webSocket = undefined;\n    } catch (err) {\n      console.error('Could not close the websocket connection for the monitor.', err);\n      throw new Error('Unable to close websocket');\n    }\n  }\n\n  send(message: string): void {\n    if (!this.webSocket) {\n      return;\n    }\n    this.webSocket.send(\n      JSON.stringify({\n        command: Monitor.ClientCommand.SEND_MESSAGE,\n        data: message,\n      })\n    );\n  }\n\n  changeSettings(settings: MonitorSettings): void {\n    if (!this.webSocket) {\n      return;\n    }\n    this.webSocket.send(\n      JSON.stringify({\n        command: Monitor.ClientCommand.CHANGE_SETTINGS,\n        data: settings,\n      })\n    );\n  }\n\n  async isWSConnected(): Promise<boolean> {\n    return !!this.webSocket;\n  }\n\n  getWebSocketPort(): number | undefined {\n    return this.wsPort;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            this.wsPort = addressPort;\n            const ws = new WebSocket(`ws://localhost:${addressPort}`);\n            ws.onopen = () => resolve();\n            ws.onerror = (error) => reject(error);\n            ws.onmessage = (event) => this.handleMessage(event);\n            ws.onclose = () => {\n                this.webSocket = undefined;\n            };\n            this.webSocket = ws;\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        this.send(JSON.stringify(settings));\n    }\n\n    isWSConnected() {\n        return Promise.resolve(this.webSocket && this.webSocket.readyState === WebSocket.OPEN);\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n\n    handleMessage(event) {\n        const message = JSON.parse(event.data);\n        // Emit events based on message type\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            if (!this.webSocket) {\n                this.wsPort = addressPort;\n                this.webSocket = new WebSocket(`ws://localhost:${this.wsPort}`);\n                this.webSocket.onopen = () => resolve();\n                this.webSocket.onerror = (error) => reject(error);\n                this.webSocket.onmessage = (event) => this.handleMessage(event);\n                this.webSocket.onclose = () => {\n                    this.webSocket = undefined;\n                };\n            } else {\n                reject(new Error('WebSocket connection already exists'));\n            }\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        this.send(JSON.stringify(settings));\n    }\n\n    isWSConnected() {\n        return new Promise((resolve) => {\n            if (this.webSocket) {\n                resolve(this.webSocket.readyState === WebSocket.OPEN);\n            } else {\n                resolve(false);\n            }\n        });\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n\n    handleMessage(event) {\n        const data = JSON.parse(event.data);\n        // Emit events based on the data received\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            this.wsPort = addressPort;\n            const ws = new WebSocket(`ws://localhost:${addressPort}`);\n            ws.onopen = () => resolve();\n            ws.onerror = (error) => reject(error);\n            ws.onmessage = (event) => this.handleMessage(event);\n            ws.onclose = () => {\n                this.webSocket = undefined;\n            };\n            this.webSocket = ws;\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        const message = JSON.stringify({ command: 'changeSettings', settings: settings });\n        this.send(message);\n    }\n\n    isWSConnected() {\n        return Promise.resolve(this.webSocket !== undefined && this.webSocket.readyState === WebSocket.OPEN);\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n\n    handleMessage(event) {\n        const data = JSON.parse(event.data);\n        // Emit events based on the message type\n        switch (data.type) {\n            case 'message':\n                // Emit message event\n                break;\n            case 'settingsChange':\n                // Emit settings change event\n                break;\n            default:\n                // Handle unknown message types\n                break;\n        }\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            if (this.webSocket) {\n                reject(new Error('WebSocket connection already exists'));\n                return;\n            }\n            this.wsPort = addressPort;\n            this.webSocket = new WebSocket(`ws://localhost:${addressPort}`);\n            this.webSocket.onopen = () => resolve();\n            this.webSocket.onerror = (event) => reject(event);\n            this.webSocket.onclose = () => {\n                this.webSocket = undefined;\n            };\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        this.send(JSON.stringify(settings));\n    }\n\n    isWSConnected() {\n        return new Promise((resolve) => {\n            if (this.webSocket) {\n                resolve(this.webSocket.readyState === WebSocket.OPEN);\n            } else {\n                resolve(false);\n            }\n        });\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            if (!this.webSocket) {\n                this.wsPort = addressPort;\n                this.webSocket = new WebSocket(`ws://localhost:${this.wsPort}`);\n                this.webSocket.onopen = () => resolve();\n                this.webSocket.onerror = (error) => reject(error);\n                this.webSocket.onmessage = (event) => this.handleMessage(event);\n                this.webSocket.onclose = () => this.webSocket = undefined;\n            }\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        this.send(JSON.stringify(settings));\n    }\n\n    isWSConnected() {\n        return new Promise((resolve) => {\n            if (this.webSocket) {\n                resolve(this.webSocket.readyState === WebSocket.OPEN);\n            } else {\n                resolve(false);\n            }\n        });\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n\n    handleMessage(event) {\n        const message = JSON.parse(event.data);\n        // Emit events based on message type\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            if (!this.webSocket) {\n                this.wsPort = addressPort;\n                this.webSocket = new WebSocket(`ws://localhost:${this.wsPort}`);\n                this.webSocket.onopen = () => resolve();\n                this.webSocket.onerror = (error) => reject(error);\n                this.webSocket.onmessage = (event) => this.handleMessage(event);\n                this.webSocket.onclose = () => {\n                    this.webSocket = undefined;\n                };\n            }\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        this.send(JSON.stringify(settings));\n    }\n\n    isWSConnected() {\n        return Promise.resolve(this.webSocket && this.webSocket.readyState === WebSocket.OPEN);\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n\n    handleMessage(event) {\n        const message = JSON.parse(event.data);\n        // Emit events based on message type\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            if (this.webSocket) {\n                reject(new Error('WebSocket connection already exists'));\n                return;\n            }\n            this.wsPort = addressPort;\n            this.webSocket = new WebSocket(`ws://localhost:${this.wsPort}`);\n            this.webSocket.onopen = () => resolve();\n            this.webSocket.onerror = (error) => reject(error);\n            this.webSocket.onclose = () => {\n                this.webSocket = undefined;\n            };\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        this.send(JSON.stringify(settings));\n    }\n\n    isWSConnected() {\n        return new Promise((resolve) => {\n            if (this.webSocket) {\n                resolve(this.webSocket.readyState === WebSocket.OPEN);\n            } else {\n                resolve(false);\n            }\n        });\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            this.wsPort = addressPort;\n            const ws = new WebSocket(`ws://localhost:${addressPort}`);\n            ws.onopen = () => resolve();\n            ws.onerror = (error) => reject(error);\n            ws.onmessage = (event) => this.handleMessage(event);\n            ws.onclose = () => {\n                this.webSocket = undefined;\n            };\n            this.webSocket = ws;\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        const message = JSON.stringify({ command: 'changeSettings', settings: settings });\n        this.send(message);\n    }\n\n    isWSConnected() {\n        return Promise.resolve(this.webSocket !== undefined && this.webSocket.readyState === WebSocket.OPEN);\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n\n    handleMessage(event) {\n        const data = JSON.parse(event.data);\n        // Emit events based on the message type\n        switch (data.type) {\n            case 'message':\n                // Emit message event\n                break;\n            case 'settingsChange':\n                // Emit settings change event\n                break;\n        }\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            if (!this.webSocket) {\n                this.wsPort = addressPort;\n                this.webSocket = new WebSocket(`ws://localhost:${this.wsPort}`);\n                this.webSocket.onopen = () => resolve();\n                this.webSocket.onerror = (error) => reject(error);\n                this.webSocket.onmessage = (event) => this.handleMessage(event);\n                this.webSocket.onclose = () => {\n                    this.webSocket = undefined;\n                };\n            }\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        this.send(JSON.stringify(settings));\n    }\n\n    isWSConnected() {\n        return new Promise((resolve) => {\n            if (this.webSocket) {\n                resolve(this.webSocket.readyState === WebSocket.OPEN);\n            } else {\n                resolve(false);\n            }\n        });\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n\n    handleMessage(event) {\n        const message = JSON.parse(event.data);\n        // Emit events based on message type\n    }\n}\n```",
      "```javascript\nclass MonitorManagerProxyClientImpl {\n    constructor() {\n        this.webSocket = undefined;\n        this.wsPort = undefined;\n    }\n\n    connect(addressPort) {\n        return new Promise((resolve, reject) => {\n            if (this.webSocket) {\n                reject('WebSocket is already connected');\n                return;\n            }\n            this.wsPort = addressPort;\n            this.webSocket = new WebSocket(`ws://localhost:${addressPort}`);\n            this.webSocket.onopen = () => resolve();\n            this.webSocket.onerror = (error) => reject(error);\n            this.webSocket.onclose = () => {\n                this.webSocket = undefined;\n            };\n        });\n    }\n\n    disconnect() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    send(message) {\n        if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {\n            this.webSocket.send(message);\n        }\n    }\n\n    changeSettings(settings) {\n        this.send(JSON.stringify(settings));\n    }\n\n    isWSConnected() {\n        return new Promise((resolve) => {\n            if (this.webSocket) {\n                resolve(this.webSocket.readyState === WebSocket.OPEN);\n            } else {\n                resolve(false);\n            }\n        });\n    }\n\n    getWebSocketPort() {\n        return this.wsPort;\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Implement a WebSocket client for audio streaming and transcription that connects to a server, handles real-time audio capture, and processes server responses for transcription and status updates.\n\nFunction Description: The `startRecording` function initializes a WebSocket connection to a specified server, configures audio capture from the user's microphone, and handles bidirectional communication with the server for audio streaming and transcription services. It manages connection events, server status updates, and transcription results while handling errors and disconnections gracefully.\n\nInput:\n- `data`: [Object] - Configuration object containing:\n  - `host`: [String] - WebSocket server host address\n  - `port`: [String|Number] - WebSocket server port\n  - `language`: [String] - Preferred language for transcription\n  - `task`: [String] - Task type (e.g., \"transcription\")\n  - `modelSize`: [String] - Model size specification\n  - `useVad`: [Boolean] - Flag for voice activity detection\n\nOutput:\n- None (Void) - The function establishes persistent connections and event handlers but doesn't return a value. Results are handled through:\n  - Browser runtime messages (via `browser.runtime.sendMessage`)\n  - WebSocket events (onmessage, onerror, etc.)\n  - Audio processing callbacks\n\nSide Effects:\n- Creates a WebSocket connection to the specified server\n- Requests microphone permissions and initializes audio capture\n- Modifies browser state through runtime messages\n- Maintains connection state internally through variables (`isServerReady`, `isCapturing`, etc.)",
    "Canonical_solution": "function startRecording(data) {\n    socket = new WebSocket(`ws://${data.host}:${data.port}/`);\n    language = data.language;\n\n    const uuid = generateUUID();\n    socket.onopen = function(e) { \n      socket.send(\n        JSON.stringify({\n            uid: uuid,\n            language: data.language,\n            task: data.task,\n            model: data.modelSize,\n            use_vad: data.useVad\n        })\n      );\n    };\n\n    let isServerReady = false;\n    socket.onmessage = async (event) => {\n      const data = JSON.parse(event.data);\n      if (data[\"uid\"] !== uuid)\n        return;\n      \n      if (data[\"status\"] === \"WAIT\"){\n        await browser.runtime.sendMessage({ action: \"showPopup\", data: data[\"message\"] })\n        return;\n      }\n      \n      if (!isServerReady && data[\"message\"] === \"SERVER_READY\"){\n        isServerReady = true;\n        return;\n      }\n\n      if (language === null ){\n        language = data[\"language\"];\n        await browser.runtime.sendMessage({ action: \"updateSelectedLanguage\", data: language })      \n        return\n      }\n\n      if (data[\"message\"] === \"DISCONNECT\"){\n        await browser.runtime.sendMessage({ action: \"toggleCaptureButtons\", data: false })        \n        return\n      }\n\n      await browser.runtime.sendMessage({ action: \"transcript\", data: event.data })\n          .catch(function(error) {\n            console.error(\"Error sending message:\", error);\n          });\n    };\n\n  navigator.mediaDevices.getUserMedia({ audio: true })\n    .then(function(stream) {\n      const audioDataCache = [];\n      audioContext = new AudioContext();\n      mediaStream = audioContext.createMediaStreamSource(stream);\n      recorder = audioContext.createScriptProcessor(4096, 1, 1);\n\n      recorder.onaudioprocess = async (event) => {\n        if (!audioContext || !isCapturing || !isServerReady || isPaused) return;\n\n        const inputData = event.inputBuffer.getChannelData(0);\n        const audioData16kHz = resampleTo16kHZ(inputData, audioContext.sampleRate);\n\n        audioDataCache.push(inputData);\n        \n        socket.send(audioData16kHz);\n      };\n\n      mediaStream.connect(recorder);\n      recorder.connect(audioContext.destination);\n    })\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    ws.send(JSON.stringify({ task, language, modelSize, useVad }));\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription', text: data.text });\n    } else if (data.type === 'status') {\n      browser.runtime.sendMessage({ type: 'status', message: data.message });\n    }\n  };\n\n  ws.onerror = (error) => {\n    browser.runtime.sendMessage({ type: 'error', message: error.message });\n  };\n\n  ws.onclose = () => {\n    isServerReady = false;\n    browser.runtime.sendMessage({ type: 'disconnected' });\n  };\n\n  navigator.mediaDevices.getUserMedia({ audio: true })\n    .then((stream) => {\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const source = audioContext.createMediaStreamSource(stream);\n      const processor = audioContext.createScriptProcessor(4096, 1, 1);\n      source.connect(processor);\n      processor.connect(audioContext.destination);\n\n      processor.onaudioprocess = (event) => {\n        if (isServerReady && isCapturing) {\n          const audioBuffer = event.inputBuffer;\n          const audioData = new Float32Array(audioBuffer.length);\n          for (let i = 0; i < audioBuffer.length; i++) {\n            audioData[i] = audioBuffer.getChannelData(0)[i];\n          }\n          ws.send(audioData);\n        }\n      };\n\n      isCapturing = true;\n    })\n    .catch((error) => {\n      browser.runtime.sendMessage({ type: 'error', message: error.message });\n    });\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  let audioContext;\n  let audioStream;\n  let audioProcessor;\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    if (useVad) {\n      ws.send(JSON.stringify({ type: 'vad', enabled: true }));\n    }\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        audioStream = audioContext.createMediaStreamSource(stream);\n        audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);\n        audioStream.connect(audioProcessor);\n        audioProcessor.connect(audioContext.destination);\n        audioProcessor.onaudioprocess = (event) => {\n          if (isCapturing) {\n            const audioData = new Float32Array(event.inputBuffer.getChannelData(0));\n            const buffer = new ArrayBuffer(audioData.length * 2);\n            const dataView = new DataView(buffer);\n            for (let i = 0; i < audioData.length; i++) {\n              dataView.setInt16(i * 2, audioData[i] * 32767, true);\n            }\n            ws.send(new Uint8Array(buffer));\n          }\n        };\n      })\n      .catch((error) => {\n        browser.runtime.sendMessage({ type: 'error', message: error.message });\n      });\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription', text: data.text });\n    } else if (data.type === 'status') {\n      browser.runtime.sendMessage({ type: 'status', message: data.message });\n    }\n  };\n\n  ws.onerror = (error) => {\n    browser.runtime.sendMessage({ type: 'error', message: error.message });\n  };\n\n  ws.onclose = () => {\n    isServerReady = false;\n    isCapturing = false;\n    browser.runtime.sendMessage({ type: 'server-closed' });\n  };\n\n  window.addEventListener('beforeunload', () => {\n    ws.close();\n  });\n\n  return {\n    start: () => {\n      if (isServerReady) {\n        isCapturing = true;\n        ws.send(JSON.stringify({ type: 'start', task, language, modelSize }));\n      }\n    },\n    stop: () => {\n      isCapturing = false;\n      ws.send(JSON.stringify({ type: 'stop' }));\n    }\n  };\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  let audioContext;\n  let audioStream;\n  let audioProcessor;\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    if (useVad) {\n      ws.send(JSON.stringify({ type: 'vad', value: true }));\n    }\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        audioStream = audioContext.createMediaStreamSource(stream);\n        audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);\n        audioStream.connect(audioProcessor);\n        audioProcessor.connect(audioContext.destination);\n        audioProcessor.onaudioprocess = (event) => {\n          if (isServerReady && isCapturing) {\n            const audioData = new Float32Array(event.inputBuffer.getChannelData(0));\n            const encodedData = encodeAudioData(audioData);\n            ws.send(encodedData);\n          }\n        };\n      })\n      .catch((error) => {\n        browser.runtime.sendMessage({ type: 'error', message: 'Failed to get audio stream', error });\n      });\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription', result: data.result });\n    } else if (data.type === 'status') {\n      browser.runtime.sendMessage({ type: 'status', message: data.message });\n    }\n  };\n\n  ws.onerror = (error) => {\n    browser.runtime.sendMessage({ type: 'error', message: 'WebSocket error', error });\n  };\n\n  ws.onclose = () => {\n    browser.runtime.sendMessage({ type: 'disconnected' });\n    isServerReady = false;\n    isCapturing = false;\n  };\n\n  const encodeAudioData = (audioData) => {\n    // Implement audio encoding logic here\n  };\n\n  const stopRecording = () => {\n    if (audioProcessor) {\n      audioProcessor.disconnect();\n      audioProcessor = null;\n    }\n    if (audioStream) {\n      audioStream.getTracks().forEach(track => track.stop());\n      audioStream = null;\n    }\n    if (audioContext) {\n      audioContext.close();\n      audioContext = null;\n    }\n    ws.close();\n  };\n\n  window.stopRecording = stopRecording;\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  let audioContext;\n  let audioStream;\n  let audioProcessor;\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    if (useVad) {\n      ws.send(JSON.stringify({ type: 'vad', value: true }));\n    }\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        audioStream = audioContext.createMediaStreamSource(stream);\n        audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);\n        audioStream.connect(audioProcessor);\n        audioProcessor.connect(audioContext.destination);\n        audioProcessor.onaudioprocess = (event) => {\n          if (isServerReady && isCapturing) {\n            const audioData = new Float32Array(event.inputBuffer.getChannelData(0));\n            const encodedData = encodeAudioData(audioData);\n            ws.send(encodedData);\n          }\n        };\n      })\n      .catch((error) => {\n        browser.runtime.sendMessage({ type: 'error', message: 'Failed to get audio stream', error });\n      });\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription', result: data.result });\n    } else if (data.type === 'status') {\n      browser.runtime.sendMessage({ type: 'status', message: data.message });\n    }\n  };\n\n  ws.onerror = (error) => {\n    browser.runtime.sendMessage({ type: 'error', message: 'WebSocket error', error });\n  };\n\n  ws.onclose = () => {\n    browser.runtime.sendMessage({ type: 'disconnected' });\n    isServerReady = false;\n    isCapturing = false;\n  };\n\n  const encodeAudioData = (audioData) => {\n    // Implement audio encoding logic here\n  };\n\n  const stopRecording = () => {\n    if (audioProcessor) {\n      audioProcessor.disconnect();\n      audioProcessor = null;\n    }\n    if (audioStream) {\n      audioStream.getTracks().forEach(track => track.stop());\n      audioStream = null;\n    }\n    if (audioContext) {\n      audioContext.close();\n      audioContext = null;\n    }\n    ws.close();\n  };\n\n  window.stopRecording = stopRecording;\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const audioStream = null; // Initialize with null, will be set later\n  const audioSourceNode = audioContext.createMediaStreamSource(audioStream);\n  const scriptProcessorNode = audioContext.createScriptProcessor(2048, 1, 1);\n  audioSourceNode.connect(scriptProcessorNode);\n  scriptProcessorNode.connect(audioContext.destination);\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    if (useVad) {\n      ws.send(JSON.stringify({ type: 'vad', value: true }));\n    }\n    ws.send(JSON.stringify({ type: 'config', language, task, modelSize }));\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioStream = stream;\n        audioSourceNode.connect(audioContext.destination);\n        isCapturing = true;\n      })\n      .catch((error) => {\n        browser.runtime.sendMessage({ type: 'error', message: error.message });\n      });\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription', text: data.text });\n    } else if (data.type === 'status') {\n      browser.runtime.sendMessage({ type: 'status', message: data.message });\n    }\n  };\n\n  ws.onerror = (error) => {\n    browser.runtime.sendMessage({ type: 'error', message: error.message });\n    ws.close();\n  };\n\n  ws.onclose = () => {\n    isServerReady = false;\n    isCapturing = false;\n    audioContext.close();\n    browser.runtime.sendMessage({ type: 'disconnected' });\n  };\n\n  scriptProcessorNode.onaudioprocess = (event) => {\n    if (isServerReady && isCapturing) {\n      const inputBuffer = event.inputBuffer;\n      const audioData = new Float32Array(inputBuffer.length);\n      for (let i = 0; i < inputBuffer.length; i++) {\n        audioData[i] = inputBuffer.getChannelData(0)[i];\n      }\n      ws.send(audioData);\n    }\n  };\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const audioStream = null; // Initialize with null, will be set later\n  const audioSourceNode = audioContext.createMediaStreamSource(audioStream);\n  const scriptProcessorNode = audioContext.createScriptProcessor(2048, 1, 1);\n  audioSourceNode.connect(scriptProcessorNode);\n  scriptProcessorNode.connect(audioContext.destination);\n\n  ws.onopen = () => {\n    isServerReady = true;\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioStream = stream;\n        audioSourceNode.connect(audioContext.destination);\n        isCapturing = true;\n        ws.send(JSON.stringify({ task, language, modelSize, useVad }));\n      })\n      .catch((error) => {\n        console.error('Error accessing microphone', error);\n        ws.close();\n      });\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.status === 'transcription_result') {\n      browser.runtime.sendMessage({ type: 'transcription_result', result: data.text });\n    } else if (data.status === 'status_update') {\n      browser.runtime.sendMessage({ type: 'status_update', message: data.message });\n    }\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error', error);\n    browser.runtime.sendMessage({ type: 'websocket_error', message: 'WebSocket error occurred' });\n  };\n\n  ws.onclose = () => {\n    isServerReady = false;\n    isCapturing = false;\n    audioStream.getTracks().forEach(track => track.stop());\n    browser.runtime.sendMessage({ type: 'websocket_closed', message: 'WebSocket connection closed' });\n  };\n\n  scriptProcessorNode.onaudioprocess = (event) => {\n    if (isServerReady && isCapturing) {\n      const inputBuffer = event.inputBuffer.getChannelData(0);\n      const audioData = new Float32Array(inputBuffer);\n      ws.send(audioData);\n    }\n  };\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  let audioContext;\n  let audioStream;\n  let audioProcessor;\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    if (useVad) {\n      ws.send(JSON.stringify({ type: 'vad', enabled: true }));\n    }\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        audioStream = audioContext.createMediaStreamSource(stream);\n        audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);\n        audioStream.connect(audioProcessor);\n        audioProcessor.connect(audioContext.destination);\n        audioProcessor.onaudioprocess = (event) => {\n          if (isServerReady && isCapturing) {\n            const audioData = new Float32Array(event.inputBuffer.getChannelData(0));\n            const buffer = new ArrayBuffer(audioData.length * 2);\n            const dataView = new DataView(buffer);\n            for (let i = 0; i < audioData.length; i++) {\n              dataView.setInt16(i * 2, audioData[i] * 32767, true);\n            }\n            ws.send(new Uint8Array(buffer));\n          }\n        };\n      })\n      .catch((error) => {\n        browser.runtime.sendMessage({ type: 'error', message: 'Failed to get audio stream', error });\n      });\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription', result: data.text });\n    } else if (data.type === 'status') {\n      browser.runtime.sendMessage({ type: 'status', message: data.message });\n    }\n  };\n\n  ws.onerror = (error) => {\n    browser.runtime.sendMessage({ type: 'error', message: 'WebSocket error', error });\n  };\n\n  ws.onclose = () => {\n    isServerReady = false;\n    isCapturing = false;\n    browser.runtime.sendMessage({ type: 'server-disconnected' });\n  };\n\n  return {\n    start: () => {\n      if (!isCapturing) {\n        isCapturing = true;\n        ws.send(JSON.stringify({ type: 'start', task, language, modelSize }));\n      }\n    },\n    stop: () => {\n      if (isCapturing) {\n        isCapturing = false;\n        ws.send(JSON.stringify({ type: 'stop' }));\n      }\n    }\n  };\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  let audioContext;\n  let audioStream;\n  let audioProcessor;\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    if (useVad) {\n      ws.send(JSON.stringify({ type: 'vad', value: true }));\n    }\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        audioStream = audioContext.createMediaStreamSource(stream);\n        audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);\n        audioStream.connect(audioProcessor);\n        audioProcessor.connect(audioContext.destination);\n        audioProcessor.onaudioprocess = (event) => {\n          if (isServerReady && isCapturing) {\n            const audioData = new Float32Array(event.inputBuffer.getChannelData(0));\n            const audioBlob = new Blob([audioData], { type: 'audio/wav' });\n            const audioFile = new File([audioBlob], 'audio.wav');\n            const formData = new FormData();\n            formData.append('file', audioFile);\n            formData.append('task', task);\n            formData.append('language', language);\n            formData.append('modelSize', modelSize);\n            fetch(`wss://${host}:${port}/transcribe`, {\n              method: 'POST',\n              body: formData\n            })\n            .then(response => response.json())\n            .then(data => {\n              browser.runtime.sendMessage({ type: 'transcription', data });\n            })\n            .catch(error => {\n              browser.runtime.sendMessage({ type: 'error', error });\n            });\n          }\n        };\n      })\n      .catch(error => {\n        browser.runtime.sendMessage({ type: 'error', error });\n      });\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'status') {\n      browser.runtime.sendMessage({ type: 'status', data: data.message });\n    } else if (data.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription', data: data.result });\n    }\n  };\n\n  ws.onerror = (event) => {\n    browser.runtime.sendMessage({ type: 'error', error: event.message });\n  };\n\n  ws.onclose = () => {\n    isServerReady = false;\n    browser.runtime.sendMessage({ type: 'server-closed' });\n  };\n\n  return {\n    start: () => {\n      if (!isCapturing) {\n        isCapturing = true;\n        ws.send(JSON.stringify({ type: 'start', task, language, modelSize }));\n      }\n    },\n    stop: () => {\n      if (isCapturing) {\n        isCapturing = false;\n        ws.send(JSON.stringify({ type: 'stop' }));\n      }\n    }\n  };\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  let audioContext;\n  let audioStream;\n  let audioProcessor;\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    if (useVad) {\n      ws.send(JSON.stringify({ type: 'vad', value: true }));\n    }\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        audioStream = audioContext.createMediaStreamSource(stream);\n        audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);\n        audioStream.connect(audioProcessor);\n        audioProcessor.connect(audioContext.destination);\n        audioProcessor.onaudioprocess = (event) => {\n          if (isServerReady && isCapturing) {\n            const audioData = new Float32Array(event.inputBuffer.getChannelData(0));\n            const buffer = new ArrayBuffer(audioData.length * 2);\n            const dataView = new DataView(buffer);\n            for (let i = 0; i < audioData.length; i++) {\n              dataView.setInt16(i * 2, audioData[i] * 32767, true);\n            }\n            ws.send(new Uint8Array(buffer));\n          }\n        };\n      })\n      .catch((error) => {\n        browser.runtime.sendMessage({ type: 'error', message: 'Failed to get audio stream', error });\n      });\n  };\n\n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    if (data.type === 'transcription') {\n      browser.runtime.sendMessage({ type: 'transcription', result: data.result });\n    } else if (data.type === 'status') {\n      browser.runtime.sendMessage({ type: 'status', message: data.message });\n    }\n  };\n\n  ws.onerror = (error) => {\n    browser.runtime.sendMessage({ type: 'error', message: 'WebSocket error', error });\n  };\n\n  ws.onclose = () => {\n    isServerReady = false;\n    isCapturing = false;\n    browser.runtime.sendMessage({ type: 'server-disconnected' });\n  };\n\n  return {\n    start: () => {\n      if (!isCapturing) {\n        isCapturing = true;\n        ws.send(JSON.stringify({ type: 'start', task, language, modelSize }));\n      }\n    },\n    stop: () => {\n      if (isCapturing) {\n        isCapturing = false;\n        ws.send(JSON.stringify({ type: 'stop' }));\n      }\n    }\n  };\n};\n```",
      "```javascript\nconst startRecording = (data) => {\n  const { host, port, language, task, modelSize, useVad } = data;\n  const ws = new WebSocket(`wss://${host}:${port}`);\n  let isServerReady = false;\n  let isCapturing = false;\n  let audioContext;\n  let audioStream;\n  let audioProcessor;\n\n  ws.onopen = () => {\n    isServerReady = true;\n    browser.runtime.sendMessage({ type: 'server-ready' });\n    requestMicrophonePermission();\n  };\n\n  ws.onmessage = (event) => {\n    const { type, data } = JSON.parse(event.data);\n    switch (type) {\n      case 'transcription':\n        browser.runtime.sendMessage({ type: 'transcription-result', data });\n        break;\n      case 'status':\n        browser.runtime.sendMessage({ type: 'status-update', data });\n        break;\n      default:\n        console.error('Unknown message type:', type);\n    }\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    browser.runtime.sendMessage({ type: 'websocket-error', error });\n  };\n\n  ws.onclose = () => {\n    console.log('WebSocket connection closed');\n    browser.runtime.sendMessage({ type: 'websocket-closed' });\n  };\n\n  const requestMicrophonePermission = () => {\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then((stream) => {\n        audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        audioStream = stream;\n        audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);\n        audioProcessor.onaudioprocess = (event) => {\n          if (isCapturing) {\n            const inputBuffer = event.inputBuffer;\n            const audioData = new Float32Array(inputBuffer.length);\n            for (let i = 0; i < inputBuffer.length; i++) {\n              audioData[i] = inputBuffer.getChannelData(0)[i];\n            }\n            const audioBlob = new Blob([audioData], { type: 'audio/wav' });\n            const audioFile = new File([audioBlob], 'audio.wav');\n            const formData = new FormData();\n            formData.append('file', audioFile);\n            formData.append('language', language);\n            formData.append('task', task);\n            formData.append('modelSize', modelSize);\n            formData.append('useVad', useVad);\n            fetch('https://api.transcriptionserver.com/stream', {\n              method: 'POST',\n              body: formData,\n            }).then((response) => response.json())\n              .then((data) => {\n                ws.send(JSON.stringify({ type: 'transcription', data }));\n              })\n              .catch((error) => {\n                console.error('Error sending audio data:', error);\n              });\n          }\n        };\n        audioProcessor.connect(audioContext.destination);\n        audioStream.getTracks()[0].connect(audioProcessor);\n        isCapturing = true;\n      })\n      .catch((error) => {\n        console.error('Error accessing microphone:', error);\n        browser.runtime.sendMessage({ type: 'microphone-error', error });\n      });\n  };\n\n  const stopRecording = () => {\n    if (audioProcessor) {\n      audioProcessor.disconnect();\n      audioStream.getTracks()[0].disconnect();\n      audioProcessor = null;\n      audioStream = null;\n      audioContext.close();\n      audioContext = null;\n      isCapturing = false;\n    }\n  };\n\n  window.addEventListener('beforeunload', stopRecording);\n};\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Implement a WebSocket client class for managing connections to a chat service, handling message exchange, and maintaining connection state.\n\nClass Description: The `BingChatWebSocket` class provides functionality to establish, maintain, and close WebSocket connections to a chat service. It manages multiple connections through unique socket IDs and supports sending messages, receiving responses, and connection health checks.\n\nAttributes:\n- `webSockets`: Record<string, WebSocket | null> - A dictionary mapping socket IDs to their corresponding WebSocket connections, allowing management of multiple connections.\n\nMethods:\n- `getSocketId()`: () -> Promise<string> - Establishes a new WebSocket connection, initializes it with a handshake message, and returns a unique socket ID for the connection. Handles connection errors and validation.\n- `ping(socketId: string)`: (string) -> Promise<void> - Sends a ping message to the WebSocket connection identified by `socketId` to maintain or check the connection.\n- `send(socketId: string, msg: object, onMessage: (data: any) => void)`: (string, object, function) -> Promise<any> - Sends a message through the WebSocket connection identified by `socketId` and sets up a callback `onMessage` to handle incoming messages. Resolves when a type 2 message is received.\n- `close(socketId: string)`: (string) -> Promise<void> - Closes the WebSocket connection identified by `socketId` and cleans up its reference in the `webSockets` dictionary.",
    "Canonical_solution": "import { v4 as uuidv4 } from 'uuid';\n\nclass BingChatWebSocket {\n  private webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    const socketUrl = 'wss://sydney.bing.com/sydney/ChatHub';\n    return await new Promise((resolve, reject) => {\n      try {\n        const ws = new WebSocket(socketUrl);\n        const socketId = uuidv4();\n        \n        ws.onopen = (_e) => {\n          const hello = JSON.stringify({ protocol: 'json', version: 1 }) + '\\x1e';\n          ws.send(hello);\n        };\n\n        ws.onclose = () => {\n          this.webSockets[socketId] = null;\n        };\n        \n        ws.onerror = (e) => {\n          if (e.type === 'error') {\n            reject(new Error(`WebSocket \\`${socketUrl}\\` did not connect successfully.`));\n            return;\n          }\n          reject(e);\n        };\n\n        ws.onmessage = (e) => {\n          const msg = e.data;\n          if (msg === '{}\\x1e') {\n            this.webSockets[socketId] = ws;\n            resolve(socketId);\n            return;\n          }\n          ws.close();\n          this.webSockets[socketId] = null;\n          reject(new Error('WebSocket did not connect successfully'));\n        };\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  async ping(socketId: string): Promise<void> {\n    return await new Promise((resolve, _reject) => {\n      const ws = this.webSockets[socketId];\n      if (ws == null) throw new Error(`WebSocket ${socketId} not found`);\n\n      ws.send(JSON.stringify({ type: 6 }) + '\\x1e');\n      resolve(null);\n    });\n  }\n\n  async send(\n    socketId: string,\n    msg: object,\n    onMessage: (data: any) => void\n  ): Promise<any> {\n    return await new Promise((resolve, _reject) => {\n      const ws = this.webSockets[socketId];\n      if (ws == null) throw new Error(`WebSocket ${socketId} not found`);\n\n      ws.onmessage = (e) => {\n        const msg = e.data;\n        for (const item of msg.split('\\x1e').filter(Boolean)) {\n          const data = JSON.parse(item.replaceAll('\\n', '\\\\n'));\n          onMessage(data);\n\n          if (data.type === 2) {\n            setTimeout(() => {\n              resolve(data);\n            });\n          }\n        }\n      };\n      ws.send(JSON.stringify(msg) + '\\x1e');\n    });\n  }\n\n  async close(socketId: string): Promise<void> {\n    const ws = this.webSockets[socketId];\n    ws?.close();\n    this.webSockets[socketId] = null;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [],
    "unmatched_results": [
      "```typescript\nclass BingChatWebSocket {\n  private webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    // Implementation for establishing a new WebSocket connection\n    // and returning a unique socket ID\n  }\n\n  async ping(socketId: string): Promise<void> {\n    // Implementation for sending a ping message to the WebSocket connection\n  }\n\n  async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n    // Implementation for sending a message through the WebSocket connection\n    // and setting up a callback to handle incoming messages\n  }\n\n  async close(socketId: string): Promise<void> {\n    // Implementation for closing the WebSocket connection\n  }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n  private webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    // Implementation for establishing a new WebSocket connection\n    // and returning a unique socket ID\n  }\n\n  async ping(socketId: string): Promise<void> {\n    // Implementation for sending a ping message to the WebSocket connection\n  }\n\n  async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n    // Implementation for sending a message through the WebSocket connection\n    // and setting up a callback to handle incoming messages\n  }\n\n  async close(socketId: string): Promise<void> {\n    // Implementation for closing the WebSocket connection\n  }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n    private webSockets: Record<string, WebSocket | null>;\n\n    constructor() {\n        this.webSockets = {};\n    }\n\n    async getSocketId(): Promise<string> {\n        // Implementation for establishing a new WebSocket connection\n    }\n\n    async ping(socketId: string): Promise<void> {\n        // Implementation for sending a ping message to the WebSocket connection\n    }\n\n    async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n        // Implementation for sending a message through the WebSocket connection\n    }\n\n    async close(socketId: string): Promise<void> {\n        // Implementation for closing the WebSocket connection\n    }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n  private webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    // Implementation for establishing a new WebSocket connection\n  }\n\n  async ping(socketId: string): Promise<void> {\n    // Implementation for sending a ping message to the WebSocket connection\n  }\n\n  async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n    // Implementation for sending a message through the WebSocket connection\n  }\n\n  async close(socketId: string): Promise<void> {\n    // Implementation for closing the WebSocket connection\n  }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n    private webSockets: Record<string, WebSocket | null>;\n\n    constructor() {\n        this.webSockets = {};\n    }\n\n    async getSocketId(): Promise<string> {\n        // Implementation for establishing a new WebSocket connection\n    }\n\n    async ping(socketId: string): Promise<void> {\n        // Implementation for sending a ping message to the WebSocket connection\n    }\n\n    async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n        // Implementation for sending a message through the WebSocket connection\n    }\n\n    async close(socketId: string): Promise<void> {\n        // Implementation for closing the WebSocket connection\n    }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n  private webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    // Implementation for establishing a new WebSocket connection\n  }\n\n  async ping(socketId: string): Promise<void> {\n    // Implementation for sending a ping message\n  }\n\n  async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n    // Implementation for sending a message and handling incoming messages\n  }\n\n  async close(socketId: string): Promise<void> {\n    // Implementation for closing a WebSocket connection\n  }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n  private webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    // Implementation for establishing a new WebSocket connection\n    // and returning a unique socket ID\n  }\n\n  async ping(socketId: string): Promise<void> {\n    // Implementation for sending a ping message to the WebSocket connection\n  }\n\n  async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n    // Implementation for sending a message through the WebSocket connection\n    // and setting up a callback for handling incoming messages\n  }\n\n  async close(socketId: string): Promise<void> {\n    // Implementation for closing the WebSocket connection\n  }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n    private webSockets: Record<string, WebSocket | null>;\n\n    constructor() {\n        this.webSockets = {};\n    }\n\n    async getSocketId(): Promise<string> {\n        // Implementation for establishing a new WebSocket connection\n    }\n\n    async ping(socketId: string): Promise<void> {\n        // Implementation for sending a ping message to the WebSocket connection\n    }\n\n    async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n        // Implementation for sending a message through the WebSocket connection\n    }\n\n    async close(socketId: string): Promise<void> {\n        // Implementation for closing the WebSocket connection\n    }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n  private webSockets: Record<string, WebSocket | null> = {};\n\n  async getSocketId(): Promise<string> {\n    // Implementation for establishing a new WebSocket connection\n  }\n\n  async ping(socketId: string): Promise<void> {\n    // Implementation for sending a ping message to the WebSocket connection\n  }\n\n  async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n    // Implementation for sending a message through the WebSocket connection\n  }\n\n  async close(socketId: string): Promise<void> {\n    // Implementation for closing the WebSocket connection\n  }\n}\n```",
      "```typescript\nclass BingChatWebSocket {\n    private webSockets: Record<string, WebSocket | null>;\n\n    constructor() {\n        this.webSockets = {};\n    }\n\n    async getSocketId(): Promise<string> {\n        // Implementation for establishing a new WebSocket connection\n    }\n\n    async ping(socketId: string): Promise<void> {\n        // Implementation for sending a ping message to the WebSocket connection\n    }\n\n    async send(socketId: string, msg: object, onMessage: (data: any) => void): Promise<any> {\n        // Implementation for sending a message through the WebSocket connection\n    }\n\n    async close(socketId: string): Promise<void> {\n        // Implementation for closing the WebSocket connection\n    }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages communication with a Python backend server for executing and debugging Python code, handling console output, and managing kernel operations.\n\nClass Description: The PythonWebSocket class provides functionality to establish a WebSocket connection to a Python backend, execute Python code, handle debugging operations, manage console output, and control the Python kernel (restarting/interrupting). It maintains state about the current execution and provides methods to interact with the WebSocket server.\n\nAttributes:\n- running: [Boolean] - Indicates whether Python code is currently being executed\n- restarting: [Boolean] - Indicates whether the kernel is currently restarting\n- consoleData: [Array] - Stores console output messages with line numbers\n- wsOpen: [Boolean] - Indicates whether the WebSocket connection is open\n- ws: [WebSocket|null] - The WebSocket connection instance\n- lineno: [Object] - Tracks line numbers during debugging (offset and current)\n- editor: [Object] - Reference to the code editor instance (assumed to be set externally)\n\nMethods:\n- initPythonWebSocket() -> [void] - Initializes the WebSocket connection and sets up event handlers for open, message, and close events\n- runPython(code: String) -> [Promise] - Sends Python code to the backend for execution and returns a Promise\n- restartKernel() -> [void] - Sends a request to restart the Python kernel\n- stopDebugging() -> [void] - Sends an interrupt signal to stop current execution\n- appendConsole(text: String) -> [void] - Adds text to the console output and auto-scrolls\n- resetConsole() -> [void] - Clears the console output buffer\n- resetEditor() -> [void] - Resets editor state by clearing breakpoints\n- setLineGoThrough(lineno: Number) -> [void] - Marks a line as executed in the editor",
    "Canonical_solution": "const WebSocket = window.WebSocket;\n\nclass PythonWebSocket {\n  constructor() {\n    this.running = false;\n    this.restarting = false;\n    this.consoleData = [];\n    this.wsOpen = false;\n    this.ws = null;\n    this.lineno = {\n      offset: 0,\n      current: -1,\n    };\n  }\n\n  initPythonWebSocket() {\n    this.running = false;\n    this.restarting = false;\n\n    this.ws = new WebSocket(\"ws://\" + location.host + \"/ws/v1/python\");\n    this.ws.onopen = () => {\n      this.wsOpen = true;\n      this.resetConsole();\n      console.log(\"websocket opened\");\n    };\n    this.ws.onmessage = (message) => {\n      const data = JSON.parse(message.data);\n      switch (data.method) {\n        case \"gotoLine\":\n          let lineNumber = data.value + this.lineno.offset;\n          this.setLineGoThrough(this.lineno.current);\n          this.lineno.current = lineNumber;\n          this.editor.session.setBreakpoint(lineNumber);\n          break;\n        case \"resetContent\":\n          this.editor.setValue(data.value);\n          break;\n        case \"output\":\n          this.appendConsole(data.value);\n          break;\n        case \"finish\":\n          this.setLineGoThrough(this.lineno.current);\n          this.running = false;\n          let timeUsed = (data.value / 1000) + \"s\";\n          this.appendConsole(\"[Finished \" + timeUsed + \"]\");\n          break;\n        case \"restarted\":\n          this.restarting = false;\n          this.running = false;\n          this.resetEditor();\n          this.notifySuccess(\"é‡å¯å†…æ ¸\", \"æˆåŠŸ\");\n          this.runPython(this.generatePreloadCode());\n          break;\n        default:\n          console.error(\"Unknown method\", data.method);\n      }\n    };\n    this.ws.onclose = () => {\n      this.wsOpen = false;\n      this.ws = null;\n      this.running = false;\n      this.resetEditor();\n      console.log(\"websocket closed\");\n    };\n  }\n\n  runPython(code) {\n    return new Promise((resolve, reject) => {\n      this.resetConsole();\n      this.resetEditor();\n      this.running = true;\n      this.ws.send(JSON.stringify({ method: \"input\", value: code }));\n      resolve();\n    });\n  }\n\n  restartKernel() {\n    this.ws.send(JSON.stringify({ method: \"restartKernel\" }));\n    this.restarting = true;\n    setTimeout(() => {\n      this.restarting = false;\n    }, 500);\n  }\n\n  stopDebugging() {\n    this.ws.send(JSON.stringify({ method: \"keyboardInterrupt\" }));\n  }\n\n  appendConsole(text) {\n    this.consoleData.push({ lineno: this.lineno.current, value: text });\n    setTimeout(() => {\n      let c = this.$refs.console;\n      c.scrollTop = c.scrollHeight - c.clientHeight;\n    }, 1);\n  }\n\n  resetConsole() {\n    this.consoleData = [];\n  }\n\n  resetEditor() {\n    this.editor.session.clearBreakpoints();\n    this.lineno.current = -1;\n  }\n\n  setLineGoThrough(lineno) {\n    if (lineno >= 0) {\n      this.editor.session.setBreakpoint(lineno, \"ace_code_exercised\");\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass PythonWebSocket {\n    constructor() {\n        this.running = false;\n        this.restarting = false;\n        this.consoleData = [];\n        this.wsOpen = false;\n        this.ws = null;\n        this.lineno = { offset: 0, current: 0 };\n        this.editor = null;\n    }\n\n    initPythonWebSocket() {\n        this.ws = new WebSocket('ws://python-backend-url');\n        this.ws.onopen = () => {\n            this.wsOpen = true;\n        };\n        this.ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            if (data.type === 'output') {\n                this.appendConsole(data.text);\n            } else if (data.type === 'debug') {\n                this.lineno.offset = data.offset;\n                this.lineno.current = data.current;\n            } else if (data.type === 'restart') {\n                this.restarting = true;\n                this.running = false;\n            }\n        };\n        this.ws.onclose = () => {\n            this.wsOpen = false;\n        };\n        this.ws.onerror = (error) => {\n            console.error('WebSocket Error:', error);\n        };\n    }\n\n    runPython(code) {\n        return new Promise((resolve, reject) => {\n            if (!this.wsOpen) {\n                reject('WebSocket connection is not open.');\n                return;\n            }\n            this.running = true;\n            this.ws.send(JSON.stringify({ type: 'run', code }));\n            this.ws.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                if (data.type === 'result') {\n                    this.running = false;\n                    resolve(data.output);\n                } else if (data.type === 'error') {\n                    this.running = false;\n                    reject(data.error);\n                }\n            };\n        });\n    }\n\n    restartKernel() {\n        if (!this.wsOpen) return;\n        this.restarting = true;\n        this.ws.send(JSON.stringify({ type: 'restart' }));\n    }\n\n    stopDebugging() {\n        if (!this.wsOpen) return;\n        this.ws.send(JSON.stringify({ type: 'stop' }));\n    }\n\n    appendConsole(text) {\n        this.consoleData.push(text);\n        // Auto-scroll logic would go here\n    }\n\n    resetConsole() {\n        this.consoleData = [];\n    }\n\n    resetEditor() {\n        // Reset editor state logic would go here\n    }\n\n    setLineGoThrough(lineno) {\n        // Set line go-through logic would go here\n    }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n    constructor() {\n        this.running = false;\n        this.restarting = false;\n        this.consoleData = [];\n        this.wsOpen = false;\n        this.ws = null;\n        this.lineno = { offset: 0, current: 0 };\n        this.editor = null;\n    }\n\n    initPythonWebSocket() {\n        this.ws = new WebSocket('ws://python-backend-url');\n        this.ws.onopen = () => {\n            this.wsOpen = true;\n        };\n        this.ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            if (data.type === 'output') {\n                this.appendConsole(data.text);\n            } else if (data.type === 'debug') {\n                this.lineno.offset = data.offset;\n                this.lineno.current = data.current;\n            } else if (data.type === 'restart') {\n                this.restarting = true;\n            }\n        };\n        this.ws.onclose = () => {\n            this.wsOpen = false;\n        };\n    }\n\n    runPython(code) {\n        return new Promise((resolve, reject) => {\n            if (!this.wsOpen) {\n                reject('WebSocket connection is not open');\n                return;\n            }\n            this.running = true;\n            this.ws.send(JSON.stringify({ type: 'execute', code }));\n            this.ws.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                if (data.type === 'result') {\n                    this.running = false;\n                    resolve(data.output);\n                    this.ws.onmessage = this.defaultOnMessage;\n                }\n            };\n        });\n    }\n\n    restartKernel() {\n        if (!this.wsOpen) return;\n        this.restarting = true;\n        this.ws.send(JSON.stringify({ type: 'restart' }));\n    }\n\n    stopDebugging() {\n        if (!this.wsOpen) return;\n        this.ws.send(JSON.stringify({ type: 'interrupt' }));\n    }\n\n    appendConsole(text) {\n        this.consoleData.push(text);\n        // Assume there's a function to auto-scroll the console\n        this.editor.autoScrollConsole();\n    }\n\n    resetConsole() {\n        this.consoleData = [];\n        // Assume there's a function to clear the console in the editor\n        this.editor.clearConsole();\n    }\n\n    resetEditor() {\n        // Assume there's a function to reset the editor state\n        this.editor.resetState();\n    }\n\n    setLineGoThrough(lineno) {\n        // Assume there's a function to mark a line as executed\n        this.editor.markLineAsExecuted(lineno);\n    }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n    constructor() {\n        this.running = false;\n        this.restarting = false;\n        this.consoleData = [];\n        this.wsOpen = false;\n        this.ws = null;\n        this.lineno = { offset: 0, current: 0 };\n        this.editor = null;\n    }\n\n    initPythonWebSocket() {\n        this.ws = new WebSocket('ws://python-backend-url');\n        this.ws.onopen = () => {\n            this.wsOpen = true;\n        };\n        this.ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            switch (data.type) {\n                case 'output':\n                    this.appendConsole(data.text);\n                    break;\n                case 'debug':\n                    this.lineno.offset = data.offset;\n                    this.lineno.current = data.current;\n                    break;\n                case 'restart':\n                    this.restarting = true;\n                    this.running = false;\n                    break;\n                case 'interrupt':\n                    this.running = false;\n                    break;\n            }\n        };\n        this.ws.onclose = () => {\n            this.wsOpen = false;\n        };\n    }\n\n    runPython(code) {\n        return new Promise((resolve, reject) => {\n            if (!this.wsOpen) {\n                reject('WebSocket connection is not open');\n                return;\n            }\n            this.running = true;\n            this.ws.send(JSON.stringify({ type: 'run', code }));\n            this.ws.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                if (data.type === 'done') {\n                    resolve(data.result);\n                    this.running = false;\n                }\n            };\n        });\n    }\n\n    restartKernel() {\n        if (!this.wsOpen) return;\n        this.restarting = true;\n        this.ws.send(JSON.stringify({ type: 'restart' }));\n    }\n\n    stopDebugging() {\n        if (!this.wsOpen) return;\n        this.ws.send(JSON.stringify({ type: 'interrupt' }));\n    }\n\n    appendConsole(text) {\n        this.consoleData.push(text);\n    }\n\n    resetConsole() {\n        this.consoleData = [];\n    }\n\n    resetEditor() {\n        // Assuming editor.reset() is a method to reset the editor state\n        this.editor.reset();\n    }\n\n    setLineGoThrough(lineno) {\n        // Assuming editor.setLineGoThrough() is a method to mark a line as executed\n        this.editor.setLineGoThrough(lineno);\n    }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n  constructor() {\n    this.running = false;\n    this.restarting = false;\n    this.consoleData = [];\n    this.wsOpen = false;\n    this.ws = null;\n    this.lineno = { offset: 0, current: 0 };\n    this.editor = null;\n  }\n\n  initPythonWebSocket() {\n    this.ws = new WebSocket('ws://python-backend-url');\n    this.ws.onopen = () => {\n      this.wsOpen = true;\n    };\n    this.ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      switch (data.type) {\n        case 'output':\n          this.appendConsole(data.text);\n          break;\n        case 'debug':\n          this.handleDebugData(data);\n          break;\n        case 'restart':\n          this.restarting = true;\n          this.resetEditor();\n          break;\n        case 'interrupt':\n          this.stopDebugging();\n          break;\n      }\n    };\n    this.ws.onclose = () => {\n      this.wsOpen = false;\n    };\n    this.ws.onerror = (error) => {\n      console.error('WebSocket Error:', error);\n    };\n  }\n\n  runPython(code) {\n    return new Promise((resolve, reject) => {\n      if (!this.wsOpen) {\n        reject('WebSocket connection is not open');\n        return;\n      }\n      this.running = true;\n      this.ws.send(JSON.stringify({ type: 'run', code }));\n      this.ws.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        if (data.type === 'done') {\n          this.running = false;\n          resolve(data.result);\n        }\n      };\n    });\n  }\n\n  restartKernel() {\n    if (!this.wsOpen) return;\n    this.ws.send(JSON.stringify({ type: 'restart' }));\n  }\n\n  stopDebugging() {\n    if (!this.wsOpen) return;\n    this.ws.send(JSON.stringify({ type: 'interrupt' }));\n  }\n\n  appendConsole(text) {\n    this.consoleData.push(text);\n    // Auto-scroll logic would go here\n  }\n\n  resetConsole() {\n    this.consoleData = [];\n  }\n\n  resetEditor() {\n    // Reset editor state logic would go here\n  }\n\n  setLineGoThrough(lineno) {\n    this.lineno.current = lineno;\n    // Update editor state to mark line as executed\n  }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n    constructor() {\n        this.running = false;\n        this.restarting = false;\n        this.consoleData = [];\n        this.wsOpen = false;\n        this.ws = null;\n        this.lineno = { offset: 0, current: 0 };\n        this.editor = null;\n    }\n\n    initPythonWebSocket() {\n        this.ws = new WebSocket('ws://python-backend-url');\n        this.ws.onopen = () => {\n            this.wsOpen = true;\n        };\n        this.ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            if (data.type === 'output') {\n                this.appendConsole(data.text);\n            } else if (data.type === 'debug') {\n                this.lineno.offset = data.offset;\n                this.lineno.current = data.current;\n            } else if (data.type === 'restart') {\n                this.restarting = true;\n                this.running = false;\n            }\n        };\n        this.ws.onclose = () => {\n            this.wsOpen = false;\n        };\n    }\n\n    runPython(code) {\n        return new Promise((resolve, reject) => {\n            if (this.wsOpen) {\n                this.ws.send(JSON.stringify({ type: 'run', code }));\n                this.running = true;\n                this.ws.onmessage = (event) => {\n                    const data = JSON.parse(event.data);\n                    if (data.type === 'result') {\n                        this.running = false;\n                        resolve(data.output);\n                        this.ws.onmessage = this.handleMessage;\n                    }\n                };\n            } else {\n                reject(new Error('WebSocket connection is not open'));\n            }\n        });\n    }\n\n    restartKernel() {\n        if (this.wsOpen) {\n            this.ws.send(JSON.stringify({ type: 'restart' }));\n            this.restarting = true;\n        }\n    }\n\n    stopDebugging() {\n        if (this.wsOpen) {\n            this.ws.send(JSON.stringify({ type: 'stop' }));\n        }\n    }\n\n    appendConsole(text) {\n        this.consoleData.push(text);\n        // Auto-scroll logic would go here\n    }\n\n    resetConsole() {\n        this.consoleData = [];\n    }\n\n    resetEditor() {\n        // Reset logic for editor would go here\n    }\n\n    setLineGoThrough(lineno) {\n        // Set line go-through logic would go here\n    }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n    constructor() {\n        this.running = false;\n        this.restarting = false;\n        this.consoleData = [];\n        this.wsOpen = false;\n        this.ws = null;\n        this.lineno = { offset: 0, current: 0 };\n        this.editor = null;\n    }\n\n    initPythonWebSocket() {\n        this.ws = new WebSocket('ws://python-backend-url');\n        this.ws.onopen = () => {\n            this.wsOpen = true;\n        };\n        this.ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            // Handle different types of messages from the server\n        };\n        this.ws.onclose = () => {\n            this.wsOpen = false;\n        };\n        this.ws.onerror = (error) => {\n            console.error('WebSocket Error:', error);\n        };\n    }\n\n    runPython(code) {\n        return new Promise((resolve, reject) => {\n            if (!this.wsOpen) {\n                reject('WebSocket connection is not open');\n                return;\n            }\n            this.running = true;\n            this.ws.send(JSON.stringify({ type: 'run', code }));\n            this.ws.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                if (data.type === 'result') {\n                    this.running = false;\n                    resolve(data.result);\n                }\n            };\n        });\n    }\n\n    restartKernel() {\n        if (!this.wsOpen) return;\n        this.restarting = true;\n        this.ws.send(JSON.stringify({ type: 'restart' }));\n    }\n\n    stopDebugging() {\n        if (!this.wsOpen) return;\n        this.ws.send(JSON.stringify({ type: 'interrupt' }));\n    }\n\n    appendConsole(text) {\n        this.consoleData.push(text);\n        // Auto-scroll logic would go here\n    }\n\n    resetConsole() {\n        this.consoleData = [];\n    }\n\n    resetEditor() {\n        // Reset editor state logic would go here\n    }\n\n    setLineGoThrough(lineno) {\n        this.lineno.current = lineno;\n        // Update editor state to mark line as executed\n    }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n    constructor() {\n        this.running = false;\n        this.restarting = false;\n        this.consoleData = [];\n        this.wsOpen = false;\n        this.ws = null;\n        this.lineno = { offset: 0, current: 0 };\n        this.editor = null;\n    }\n\n    initPythonWebSocket() {\n        this.ws = new WebSocket('ws://python-backend-url');\n        this.ws.onopen = () => {\n            this.wsOpen = true;\n        };\n        this.ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            switch (data.type) {\n                case 'output':\n                    this.appendConsole(data.text);\n                    break;\n                case 'debug':\n                    this.lineno.current = data.lineno;\n                    break;\n                case 'restart':\n                    this.restarting = true;\n                    break;\n            }\n        };\n        this.ws.onclose = () => {\n            this.wsOpen = false;\n        };\n    }\n\n    runPython(code) {\n        return new Promise((resolve, reject) => {\n            if (!this.wsOpen) {\n                reject('WebSocket connection is not open');\n                return;\n            }\n            this.running = true;\n            this.ws.send(JSON.stringify({ type: 'run', code }));\n            this.ws.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                if (data.type === 'result') {\n                    this.running = false;\n                    resolve(data.result);\n                }\n            };\n        });\n    }\n\n    restartKernel() {\n        if (!this.wsOpen) return;\n        this.restarting = true;\n        this.ws.send(JSON.stringify({ type: 'restart' }));\n    }\n\n    stopDebugging() {\n        if (!this.wsOpen) return;\n        this.ws.send(JSON.stringify({ type: 'stop' }));\n    }\n\n    appendConsole(text) {\n        this.consoleData.push(text);\n        // Auto-scroll logic would go here\n    }\n\n    resetConsole() {\n        this.consoleData = [];\n    }\n\n    resetEditor() {\n        // Reset editor state logic would go here\n    }\n\n    setLineGoThrough(lineno) {\n        // Set line as executed logic would go here\n    }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n    constructor() {\n        this.running = false;\n        this.restarting = false;\n        this.consoleData = [];\n        this.wsOpen = false;\n        this.ws = null;\n        this.lineno = { offset: 0, current: 0 };\n        this.editor = null;\n    }\n\n    initPythonWebSocket() {\n        this.ws = new WebSocket('ws://python-backend-url');\n        this.ws.onopen = () => {\n            this.wsOpen = true;\n        };\n        this.ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            switch (data.type) {\n                case 'output':\n                    this.appendConsole(data.text);\n                    break;\n                case 'debug':\n                    this.lineno.offset = data.offset;\n                    this.lineno.current = data.current;\n                    break;\n                case 'restart':\n                    this.restarting = true;\n                    this.running = false;\n                    break;\n            }\n        };\n        this.ws.onclose = () => {\n            this.wsOpen = false;\n        };\n        this.ws.onerror = (error) => {\n            console.error('WebSocket Error:', error);\n        };\n    }\n\n    runPython(code) {\n        return new Promise((resolve, reject) => {\n            if (!this.wsOpen) {\n                reject('WebSocket connection not open');\n                return;\n            }\n            this.running = true;\n            this.ws.send(JSON.stringify({ type: 'execute', code }));\n            this.ws.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                if (data.type === 'result') {\n                    this.running = false;\n                    resolve(data.output);\n                }\n            };\n        });\n    }\n\n    restartKernel() {\n        if (this.wsOpen) {\n            this.ws.send(JSON.stringify({ type: 'restart' }));\n        }\n    }\n\n    stopDebugging() {\n        if (this.wsOpen) {\n            this.ws.send(JSON.stringify({ type: 'interrupt' }));\n        }\n    }\n\n    appendConsole(text) {\n        this.consoleData.push(text);\n        // Assume auto-scrolling logic is implemented externally\n    }\n\n    resetConsole() {\n        this.consoleData = [];\n    }\n\n    resetEditor() {\n        // Assume editor reset logic is implemented externally\n    }\n\n    setLineGoThrough(lineno) {\n        // Assume line execution marking logic is implemented externally\n    }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n  constructor() {\n    this.running = false;\n    this.restarting = false;\n    this.consoleData = [];\n    this.wsOpen = false;\n    this.ws = null;\n    this.lineno = { offset: 0, current: 0 };\n    this.editor = null;\n  }\n\n  initPythonWebSocket() {\n    this.ws = new WebSocket('ws://python-backend-url');\n    this.ws.onopen = () => {\n      this.wsOpen = true;\n    };\n    this.ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      if (data.type === 'output') {\n        this.appendConsole(data.text);\n      } else if (data.type === 'debug') {\n        this.lineno.current = data.lineno;\n      } else if (data.type === 'restart') {\n        this.restarting = true;\n        this.running = false;\n      }\n    };\n    this.ws.onclose = () => {\n      this.wsOpen = false;\n    };\n    this.ws.onerror = (error) => {\n      console.error('WebSocket Error:', error);\n    };\n  }\n\n  runPython(code) {\n    return new Promise((resolve, reject) => {\n      if (!this.wsOpen) {\n        reject('WebSocket connection is not open');\n        return;\n      }\n      this.running = true;\n      this.ws.send(JSON.stringify({ type: 'execute', code }));\n      this.ws.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        if (data.type === 'result') {\n          this.running = false;\n          resolve(data.output);\n        }\n      };\n    });\n  }\n\n  restartKernel() {\n    if (!this.wsOpen) return;\n    this.restarting = true;\n    this.ws.send(JSON.stringify({ type: 'restart' }));\n  }\n\n  stopDebugging() {\n    if (!this.wsOpen) return;\n    this.ws.send(JSON.stringify({ type: 'interrupt' }));\n  }\n\n  appendConsole(text) {\n    this.consoleData.push(text);\n    // Assuming there's a function to auto-scroll the console\n    // this.editor.scrollToBottom();\n  }\n\n  resetConsole() {\n    this.consoleData = [];\n    // Assuming there's a function to clear the console in the editor\n    // this.editor.clearConsole();\n  }\n\n  resetEditor() {\n    // Assuming there's a function to reset the editor state\n    // this.editor.clearBreakpoints();\n  }\n\n  setLineGoThrough(lineno) {\n    // Assuming there's a function to mark a line as executed\n    // this.editor.markLineAsExecuted(lineno);\n  }\n}\n```",
      "```javascript\nclass PythonWebSocket {\n    constructor() {\n        this.running = false;\n        this.restarting = false;\n        this.consoleData = [];\n        this.wsOpen = false;\n        this.ws = null;\n        this.lineno = { offset: 0, current: 0 };\n        this.editor = null;\n    }\n\n    initPythonWebSocket() {\n        this.ws = new WebSocket('ws://python-backend-url');\n        this.ws.onopen = () => {\n            this.wsOpen = true;\n        };\n        this.ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            // Handle different types of messages from the server\n        };\n        this.ws.onclose = () => {\n            this.wsOpen = false;\n        };\n        this.ws.onerror = (error) => {\n            console.error('WebSocket Error:', error);\n        };\n    }\n\n    runPython(code) {\n        return new Promise((resolve, reject) => {\n            if (!this.wsOpen) {\n                reject('WebSocket connection is not open');\n                return;\n            }\n            this.running = true;\n            this.ws.send(JSON.stringify({ type: 'run', code }));\n            this.ws.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                if (data.type === 'result') {\n                    this.running = false;\n                    resolve(data.result);\n                    this.ws.onmessage = this.defaultOnMessageHandler;\n                }\n            };\n        });\n    }\n\n    restartKernel() {\n        if (!this.wsOpen) return;\n        this.restarting = true;\n        this.ws.send(JSON.stringify({ type: 'restart' }));\n    }\n\n    stopDebugging() {\n        if (!this.wsOpen) return;\n        this.ws.send(JSON.stringify({ type: 'interrupt' }));\n    }\n\n    appendConsole(text) {\n        this.consoleData.push(text);\n        // Auto-scroll logic would go here\n    }\n\n    resetConsole() {\n        this.consoleData = [];\n    }\n\n    resetEditor() {\n        // Reset editor state logic would go here\n    }\n\n    setLineGoThrough(lineno) {\n        this.lineno.current = lineno;\n        // Update editor state logic would go here\n    }\n\n    defaultOnMessageHandler(event) {\n        const data = JSON.parse(event.data);\n        // Handle default message types\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with reconnection capabilities and event handling.\n\nClass Description: The N class represents a WebSocket client that connects to a specified URL, handles connection events, manages reconnection logic, and forwards received messages to a destination. It provides methods to start, destroy, and manage the WebSocket connection.\n\nAttributes:\n\nurl: [String] - The WebSocket server URL to connect to.\noptions: [Object] - Configuration options for the WebSocket connection.\nsocket: [WebSocket|null] - The WebSocket connection instance.\nstreaming: [Boolean] - Indicates if the connection is actively streaming.\ncallbacks: [Object] - Stores event callbacks for connect and data events.\ndestination: [Object|null] - The target to forward received messages to.\nreconnectInterval: [Number] - Time interval (in seconds) between reconnection attempts.\nshouldAttemptReconnect: [Boolean] - Flag to control reconnection behavior.\ncompleted: [Boolean] - Indicates if the connection has completed its purpose.\nestablished: [Boolean] - Indicates if the connection is successfully established.\nprogress: [Number] - Tracks connection progress (0-1).\nreconnectTimeoutId: [Number] - Timeout ID for reconnection attempts.\nonEstablishedCallback: [Function|null] - Callback when connection is established.\nonCompletedCallback: [Function|null] - Callback when connection is completed.\nhookOnEstablished: [Function|null] - Additional hook for established event.\n\nMethods:\n\nconstructor(url, options) -> [N] - Initializes the WebSocket client with the given URL and options.\nconnect(destination) -> [void] - Sets the destination for received messages.\ndestroy() -> [void] - Closes the WebSocket connection and stops reconnection attempts.\nstart() -> [void] - Initiates the WebSocket connection with event handlers.\nresume() -> [void] - Placeholder for resuming functionality (currently empty).\nonOpen() -> [void] - Handles WebSocket open event, sets progress to 1.\nonClose() -> [void] - Handles WebSocket close/error events, initiates reconnection if enabled.\nonMessage(event) -> [void] - Handles incoming messages, triggers established callbacks, and forwards data to destination.",
    "Canonical_solution": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = true;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== options.reconnectInterval ? options.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = options.onSourceEstablished;\n    this.onCompletedCallback = options.onSourceCompleted;\n    options.hookOnEstablished && (this.hookOnEstablished = options.hookOnEstablished);\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = false;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = false;\n    this.options.protocols \n      ? this.socket = new WebSocket(this.url, this.options.protocols)\n      : this.socket = new WebSocket(this.url);\n    \n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    if (this.shouldAttemptReconnect) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, 1000 * this.reconnectInterval);\n    }\n  }\n\n  onMessage(event) {\n    const wasFirstMessage = !this.established;\n    this.established = true;\n    \n    if (wasFirstMessage && this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    \n    if (wasFirstMessage && this.onEstablishedCallback) {\n      this.onEstablishedCallback(this);\n    }\n    \n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n  }\n}\n\n// External dependencies\nconst WebSocket = window.WebSocket;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n      clearTimeout(this.reconnectTimeoutId);\n      this.shouldAttemptReconnect = false;\n    }\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.established = true;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n    this.callbacks.close.forEach(callback => callback());\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n    this.callbacks.data.forEach(callback => callback(event.data));\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (this.socket && this.socket.readyState === WebSocket.CLOSED) {\n        this.start();\n      }\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.shouldAttemptReconnect = false;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.established = true;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n    this.callbacks.close.forEach(callback => callback());\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (!this.completed) {\n        this.start();\n      }\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.close();\n    this.shouldAttemptReconnect = false;\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.established = true;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(event) {\n    if (this.callbacks.data) {\n      this.callbacks.data(event.data);\n    }\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n  }\n\n  reconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n    this.reconnectTimeoutId = setTimeout(() => {\n      this.start();\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.shouldAttemptReconnect = false;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.established = true;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n    this.callbacks.close.forEach(callback => callback());\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n    this.callbacks.data.forEach(callback => callback(event.data));\n    if (!this.completed) {\n      this.onEstablishedCallback = null;\n      this.onCompletedCallback = null;\n      this.completed = true;\n      if (this.onCompletedCallback) {\n        this.onCompletedCallback();\n      }\n    }\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (this.socket) {\n        this.socket = null;\n      }\n      this.start();\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.shouldAttemptReconnect = false;\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.established = true;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n  }\n\n  reconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n    this.reconnectTimeoutId = setTimeout(() => {\n      this.start();\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.shouldAttemptReconnect = false;\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.established = true;\n    this.callbacks.connect && this.callbacks.connect();\n    this.onEstablishedCallback && this.onEstablishedCallback();\n    this.hookOnEstablished && this.hookOnEstablished();\n  }\n\n  onClose() {\n    this.established = false;\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n    this.callbacks.close && this.callbacks.close();\n  }\n\n  onMessage(event) {\n    this.callbacks.data && this.callbacks.data(event.data);\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n    if (!this.completed) {\n      this.onEstablishedCallback && this.onEstablishedCallback();\n    }\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      this.start();\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.shouldAttemptReconnect = false;\n    clearTimeout(this.reconnectTimeoutId);\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.established = true;\n    this.callbacks.connect.forEach(callback => callback());\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n    this.callbacks.close.forEach(callback => callback());\n  }\n\n  onMessage(event) {\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n  }\n\n  reconnect() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.reconnectTimeoutId = setTimeout(() => {\n      if (this.socket) {\n        this.socket = null;\n      }\n      this.start();\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = {};\n        this.destination = null;\n        this.reconnectInterval = 5;\n        this.shouldAttemptReconnect = true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = null;\n        this.onCompletedCallback = null;\n        this.hookOnEstablished = null;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        if (this.socket) {\n            this.socket.close();\n            this.socket = null;\n        }\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n            this.reconnectTimeoutId = null;\n        }\n        this.shouldAttemptReconnect = false;\n    }\n\n    start() {\n        this.socket = new WebSocket(this.url, this.options);\n        this.socket.onopen = this.onOpen.bind(this);\n        this.socket.onclose = this.onClose.bind(this);\n        this.socket.onerror = this.onClose.bind(this);\n        this.socket.onmessage = this.onMessage.bind(this);\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.progress = 1;\n        this.established = true;\n        this.callbacks.connect && this.callbacks.connect();\n        this.onEstablishedCallback && this.onEstablishedCallback();\n        this.hookOnEstablished && this.hookOnEstablished();\n    }\n\n    onClose() {\n        this.established = false;\n        this.callbacks.close && this.callbacks.close();\n        if (this.shouldAttemptReconnect) {\n            this.reconnect();\n        }\n    }\n\n    onMessage(event) {\n        this.callbacks.data && this.callbacks.data(event.data);\n        if (this.destination) {\n            this.destination.onMessage(event.data);\n        }\n        if (!this.completed) {\n            this.onEstablishedCallback && this.onEstablishedCallback();\n        }\n    }\n\n    reconnect() {\n        if (this.reconnectTimeoutId) {\n            clearTimeout(this.reconnectTimeoutId);\n        }\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.start();\n        }, this.reconnectInterval * 1000);\n    }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.close();\n    this.shouldAttemptReconnect = false;\n  }\n\n  start() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen;\n    this.socket.onclose = this.onClose;\n    this.socket.onerror = this.onClose;\n    this.socket.onmessage = this.onMessage;\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 1;\n    this.callbacks.connect && this.callbacks.connect();\n    this.onEstablishedCallback && this.onEstablishedCallback();\n    this.hookOnEstablished && this.hookOnEstablished();\n  }\n\n  onClose() {\n    this.established = false;\n    this.progress = 0;\n    this.callbacks.close && this.callbacks.close();\n    if (this.shouldAttemptReconnect) {\n      this.reconnect();\n    }\n  }\n\n  onMessage(event) {\n    this.callbacks.data && this.callbacks.data(event.data);\n    this.onEstablishedCallback && this.onEstablishedCallback();\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n  }\n\n  reconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n    this.reconnectTimeoutId = setTimeout(() => {\n      this.start();\n    }, this.reconnectInterval * 1000);\n  }\n}\n```",
      "```javascript\nclass N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = {};\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.closeSocket();\n    this.stopReconnect();\n  }\n\n  start() {\n    this.connectSocket();\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.established = true;\n    this.progress = 1;\n    this.triggerCallback('onEstablished');\n  }\n\n  onClose() {\n    this.established = false;\n    this.progress = 0;\n    if (this.shouldAttemptReconnect) {\n      this.attemptReconnect();\n    }\n  }\n\n  onMessage(event) {\n    this.triggerCallback('onEstablished');\n    if (this.destination) {\n      this.destination.onMessage(event.data);\n    }\n  }\n\n  connectSocket() {\n    this.socket = new WebSocket(this.url, this.options);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n  }\n\n  closeSocket() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n\n  attemptReconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n    }\n    this.reconnectTimeoutId = setTimeout(() => {\n      this.connectSocket();\n    }, this.reconnectInterval * 1000);\n  }\n\n  stopReconnect() {\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n  }\n\n  triggerCallback(callbackName) {\n    if (this.callbacks[callbackName] && typeof this.callbacks[callbackName] === 'function') {\n      this.callbacks[callbackName]();\n    }\n    if (this.onEstablishedCallback && typeof this.onEstablishedCallback === 'function') {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished && typeof this.hookOnEstablished === 'function') {\n      this.hookOnEstablished();\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.language,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.language,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.language,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.language,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```",
      "```javascript\nasync function getChannels() {\n  const url = 'https://api.example.com/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: \nCreate a WebSocket-based control class for managing connections and communication between a client and a local server, including authorization, message handling, and API invocation.\n\nClass Description: \nThe `CocogoatWebControl` class provides functionality to establish and manage WebSocket connections to a local server, handle authorization, send/receive messages, and invoke API methods through WebSocket communication.\n\nAttributes:\n- port: number - The port number for the local server connection (default: 32333)\n- token: string - The authorization token for authenticated requests\n- hwnd: number - A window handle identifier (default: 0)\n- version: string - Version information (currently unused in the reference code)\n- ev: Mitt - An event emitter for handling WebSocket messages\n- client: FlyType - An HTTP client for initial authorization\n- ws: WebSocket | undefined - The active WebSocket connection instance\n\nMethods:\n- constructor(_port?: number) -> void - Initializes the control instance with optional port specification\n- authorize() -> Promise<boolean> - Establishes WebSocket connection and obtains authorization token\n- wsInvoke(method: string, path: string, querystring?: Record<string, any>) -> Promise<{status: number, body: any}> - Invokes an API method through WebSocket connection",
    "Canonical_solution": "import mitt from 'mitt'\nimport { stringify } from 'qs'\nimport Fly from 'flyio/dist/npm/fly'\nimport type { Fly as FlyType, FlyError } from 'flyio'\n\nexport class CocogoatWebControl {\n    port = 32333\n    token = ''\n    hwnd = 0\n    version = ''\n    ev = mitt()\n    client: FlyType = new Fly()\n    ws: WebSocket | undefined\n\n    constructor(_port = 32333) {\n        this.port = _port\n        this.client.config.baseURL = `http://localhost:${this.port}`\n        this.client.interceptors.request.use((request) => {\n            if (this.token) {\n                request.headers['Authorization'] = `Bearer ${this.token}`\n            }\n            if (request.headers['Content-Type'] === '') {\n                delete request.headers['Content-Type']\n            }\n            return request\n        })\n        this.client.interceptors.response.use(undefined, (e) => {\n            const er = e as unknown as FlyError\n            if (er.status === 410) {\n                console.warn('Control stopped by user')\n                return new Error('ECANCEL')\n            }\n            return e\n        })\n    }\n\n    async authorize() {\n        if (this.ws) {\n            return true\n        }\n        try {\n            const { data } = await this.client.post('/token')\n            this.token = data.token\n            this.hwnd = data.hwnd || 0\n            const ws = new WebSocket(`ws://localhost:${this.port}/ws/${this.token}`)\n            ws.onmessage = (e) => {\n                const data = JSON.parse(e.data)\n                this.ev.emit(data.id || data.action, data.data)\n            }\n            ws.onclose = () => {\n                this.ws = undefined\n            }\n            await new Promise((resolve) => {\n                ws.onopen = resolve\n            })\n            this.ws = ws\n            return true\n        } catch (e) {\n            const er = e as FlyError\n            if (er.status === 401) {\n                return false\n            }\n            throw e\n        }\n    }\n\n    wsInvoke(method: string, path: string, querystring?: Record<string, any>) {\n        if (!this.ws) throw new Error('WebSocket not connected')\n        const url = path + (querystring ? `?${stringify(querystring)}` : '')\n        const id = Math.round(Date.now() * 1000 + Math.random() * 1000).toString(16)\n        const reqjson = {\n            id,\n            action: 'api',\n            data: {\n                url,\n                method,\n            },\n        }\n        const resp = new Promise((resolve) => {\n            this.ev.on(id, resolve)\n        })\n        this.ws.send(JSON.stringify(reqjson))\n        return resp as Promise<{\n            status: number\n            body: any\n        }>\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [],
    "unmatched_results": [
      "```typescript\nclass CocogoatWebControl {\n    port: number;\n    token: string;\n    hwnd: number;\n    version: string;\n    ev: Mitt;\n    client: FlyType;\n    ws: WebSocket | undefined;\n\n    constructor(_port?: number) {\n        this.port = _port || 32333;\n        this.token = '';\n        this.hwnd = 0;\n        this.version = '';\n        this.ev = new Mitt();\n        this.client = new FlyType();\n        this.ws = undefined;\n    }\n\n    async authorize(): Promise<boolean> {\n        // Establish WebSocket connection and obtain authorization token\n        // Implementation goes here\n    }\n\n    async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n        // Invoke an API method through WebSocket connection\n        // Implementation goes here\n    }\n}\n\nclass Mitt {\n    // Event emitter implementation\n}\n\nclass FlyType {\n    // HTTP client implementation\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n    port: number;\n    token: string;\n    hwnd: number;\n    version: string;\n    ev: Mitt;\n    client: FlyType;\n    ws: WebSocket | undefined;\n\n    constructor(_port?: number) {\n        this.port = _port || 32333;\n        this.token = '';\n        this.hwnd = 0;\n        this.version = '';\n        this.ev = new Mitt();\n        this.client = new FlyType();\n        this.ws = undefined;\n    }\n\n    async authorize(): Promise<boolean> {\n        // Establish WebSocket connection and obtain authorization token\n        // Implementation goes here\n        return true;\n    }\n\n    async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n        // Invoke an API method through WebSocket connection\n        // Implementation goes here\n        return { status: 200, body: {} };\n    }\n}\n\nclass Mitt {\n    // Event emitter implementation\n}\n\nclass FlyType {\n    // HTTP client implementation\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n  port: number;\n  token: string;\n  hwnd: number;\n  version: string;\n  ev: any;\n  client: any;\n  ws: WebSocket | undefined;\n\n  constructor(_port?: number) {\n    this.port = _port || 32333;\n    this.token = '';\n    this.hwnd = 0;\n    this.version = '';\n    this.ev = new any();\n    this.client = new any();\n    this.ws = undefined;\n  }\n\n  async authorize(): Promise<boolean> {\n    // Establish WebSocket connection and obtain authorization token\n    return true;\n  }\n\n  async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n    // Invoke an API method through WebSocket connection\n    return { status: 200, body: {} };\n  }\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n    port: number;\n    token: string;\n    hwnd: number;\n    version: string;\n    ev: Mitt;\n    client: FlyType;\n    ws: WebSocket | undefined;\n\n    constructor(_port?: number) {\n        this.port = _port || 32333;\n        this.token = '';\n        this.hwnd = 0;\n        this.version = '';\n        this.ev = new Mitt();\n        this.client = new FlyType();\n        this.ws = undefined;\n    }\n\n    async authorize(): Promise<boolean> {\n        // Establish WebSocket connection and obtain authorization token\n        // Implementation details omitted\n        return true;\n    }\n\n    async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n        // Invoke an API method through WebSocket connection\n        // Implementation details omitted\n        return { status: 200, body: {} };\n    }\n}\n\nclass Mitt {\n    // Event emitter implementation\n    // Implementation details omitted\n}\n\nclass FlyType {\n    // HTTP client implementation\n    // Implementation details omitted\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n  port: number;\n  token: string;\n  hwnd: number;\n  version: string;\n  ev: any;\n  client: any;\n  ws: WebSocket | undefined;\n\n  constructor(_port?: number) {\n    this.port = _port || 32333;\n    this.token = '';\n    this.hwnd = 0;\n    this.version = '';\n    this.ev = new Mitt();\n    this.client = new FlyType();\n    this.ws = undefined;\n  }\n\n  async authorize(): Promise<boolean> {\n    // Establish WebSocket connection and obtain authorization token\n    // Implementation details omitted\n    return true;\n  }\n\n  async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{ status: number, body: any }> {\n    // Invoke an API method through WebSocket connection\n    // Implementation details omitted\n    return { status: 200, body: {} };\n  }\n}\n\nclass Mitt {\n  // Event emitter implementation\n  // Implementation details omitted\n}\n\nclass FlyType {\n  // HTTP client implementation\n  // Implementation details omitted\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n    port: number;\n    token: string;\n    hwnd: number;\n    version: string;\n    ev: Mitt;\n    client: FlyType;\n    ws: WebSocket | undefined;\n\n    constructor(_port?: number) {\n        this.port = _port || 32333;\n        this.token = '';\n        this.hwnd = 0;\n        this.version = '';\n        this.ev = new Mitt();\n        this.client = new FlyType();\n        this.ws = undefined;\n    }\n\n    async authorize(): Promise<boolean> {\n        // Establish WebSocket connection and obtain authorization token\n        // Implementation goes here\n    }\n\n    async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n        // Invoke an API method through WebSocket connection\n        // Implementation goes here\n    }\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n  port: number;\n  token: string;\n  hwnd: number;\n  version: string;\n  ev: any;\n  client: any;\n  ws: WebSocket | undefined;\n\n  constructor(_port?: number) {\n    this.port = _port || 32333;\n    this.token = '';\n    this.hwnd = 0;\n    this.version = '';\n    this.ev = new Mitt();\n    this.client = new FlyType();\n    this.ws = undefined;\n  }\n\n  async authorize(): Promise<boolean> {\n    // Establish WebSocket connection and obtain authorization token\n    return true;\n  }\n\n  async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n    // Invoke an API method through WebSocket connection\n    return { status: 200, body: {} };\n  }\n}\n\nclass Mitt {\n  // Event emitter implementation\n}\n\nclass FlyType {\n  // HTTP client implementation\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n    port: number;\n    token: string;\n    hwnd: number;\n    version: string;\n    ev: any;\n    client: any;\n    ws: WebSocket | undefined;\n\n    constructor(_port?: number) {\n        this.port = _port || 32333;\n        this.token = '';\n        this.hwnd = 0;\n        this.version = '';\n        this.ev = new any();\n        this.client = new any();\n        this.ws = undefined;\n    }\n\n    async authorize(): Promise<boolean> {\n        // Establish WebSocket connection and obtain authorization token\n        return true;\n    }\n\n    async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n        // Invoke an API method through WebSocket connection\n        return { status: 200, body: {} };\n    }\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n    port: number;\n    token: string;\n    hwnd: number;\n    version: string;\n    ev: Mitt;\n    client: FlyType;\n    ws: WebSocket | undefined;\n\n    constructor(_port?: number) {\n        this.port = _port || 32333;\n        this.token = '';\n        this.hwnd = 0;\n        this.version = '';\n        this.ev = new Mitt();\n        this.client = new FlyType();\n        this.ws = undefined;\n    }\n\n    async authorize(): Promise<boolean> {\n        // Establish WebSocket connection and obtain authorization token\n        // Implementation goes here\n    }\n\n    async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n        // Invoke an API method through WebSocket connection\n        // Implementation goes here\n    }\n}\n```",
      "```typescript\nclass CocogoatWebControl {\n    port: number;\n    token: string;\n    hwnd: number;\n    version: string;\n    ev: any;\n    client: any;\n    ws: WebSocket | undefined;\n\n    constructor(_port?: number) {\n        this.port = _port || 32333;\n        this.token = '';\n        this.hwnd = 0;\n        this.version = '';\n        this.ev = new any();\n        this.client = new any();\n        this.ws = undefined;\n    }\n\n    async authorize(): Promise<boolean> {\n        // Establish WebSocket connection and obtain authorization token\n        return true;\n    }\n\n    async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{status: number, body: any}> {\n        // Invoke an API method through WebSocket connection\n        return { status: 200, body: {} };\n    }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections, handles message queuing, automatic reconnection, and provides event callbacks for connection status changes and incoming messages.\n\nClass Description: The WebSocketClient class provides a robust WebSocket client implementation with connection management, message queuing, automatic reconnection capabilities, and event callbacks. It maintains connection state and handles various WebSocket events while providing methods for sending messages and checking connection status.\n\nAttributes:\n- wsClient: [WebSocket] - The underlying WebSocket connection instance\n- sendQueue: [Array] - Queue of messages to be sent when connection is available\n- pendingReconnect: [Timeout] - Timer handle for pending reconnection attempts\n\nMethods:\n- constructor() -> [void] - Initializes a new WebSocketClient instance\n- fireSendQueue() -> [void] - Sends all queued messages when connection is open\n- clearSendQueue() -> [void] - Clears all queued messages and rejects their promises\n- planToReconnect(rpcUrl: String, options: Object) -> [void] - Schedules a reconnection attempt\n- init() -> [void] - Cleans up existing connection and message queue\n- connect(rpcUrl: String, options: Object, onOpenCallback: Function, onCloseCallback: Function, onMessageCallback: Function) -> [void] - Establishes new WebSocket connection with event handlers\n- reconnect(rpcUrl: String, options: Object) -> [void] - Re-establishes connection using existing callbacks\n- send(requestContext: Object) -> [Promise] - Queues a message for sending and returns a promise\n- getReadyState() -> [Number|null] - Returns current WebSocket readyState or null if no connection",
    "Canonical_solution": "const WebSocket = require('ws');\nconst ipcRender = require('../ipc/render-proecss');\n\nclass WebSocketClient {\n    constructor() {\n        this.wsClient = null;\n        this.sendQueue = [];\n        this.pendingReconnect = null;\n    }\n\n    fireSendQueue() {\n        while (this.sendQueue.length && this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n            const request = this.sendQueue.shift();\n            this.wsClient.send(request.data);\n            request.deferred.resolve();\n        }\n    }\n\n    clearSendQueue() {\n        for (let i = this.sendQueue.length - 1; i >= 0; i--) {\n            this.sendQueue[i].deferred.reject();\n            this.sendQueue.splice(i, 1);\n        }\n    }\n\n    planToReconnect(rpcUrl, options) {\n        if (this.pendingReconnect) {\n            ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] another reconnection is pending');\n            return;\n        }\n\n        this.pendingReconnect = setTimeout(() => {\n            if (this.wsClient == null) {\n                ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] websocket is null');\n                this.pendingReconnect = null;\n                return;\n            }\n\n            if (this.wsClient.readyState === WebSocket.CONNECTING || this.wsClient.readyState === WebSocket.OPEN) {\n                ipcRender.notifyRenderProcessLogWarn('[lib/websocket.planToReconnect] websocket current state is already ' + this.wsClient.readyState);\n                this.pendingReconnect = null;\n                return;\n            }\n\n            this.reconnect(rpcUrl, options);\n            this.pendingReconnect = null;\n        }, options.reconnectInterval);\n\n        ipcRender.notifyRenderProcessLogDebug('[lib/websocket.planToReconnect] next reconnection is pending in ' + options.reconnectInterval + \"ms\");\n    }\n\n    init() {\n        if (this.sendQueue.length) {\n            this.clearSendQueue();\n        }\n\n        if (this.wsClient) {\n            this.wsClient.onopen = null;\n            this.wsClient.onclose = null;\n            this.wsClient.onmessage = null;\n            this.wsClient.terminate();\n            this.wsClient = null;\n        }\n    }\n\n    connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n        this.init();\n\n        this.wsClient = new WebSocket(rpcUrl);\n\n        this.wsClient.onopen = () => {\n            onOpenCallback({\n                client: this.wsClient,\n                url: rpcUrl\n            });\n            this.fireSendQueue();\n        };\n\n        this.wsClient.onclose = () => {\n            let autoReconnect = false;\n\n            if (options.reconnectInterval > 0) {\n                autoReconnect = true;\n                this.planToReconnect(rpcUrl, options);\n            }\n\n            onCloseCallback({\n                client: this.wsClient,\n                url: rpcUrl,\n                autoReconnect: autoReconnect\n            });\n        };\n\n        this.wsClient.onmessage = (event) => {\n            let message = null;\n\n            if (event) {\n                message = event.data;\n            }\n\n            onMessageCallback({\n                client: this.wsClient,\n                url: rpcUrl,\n                success: true,\n                message: message\n            });\n        };\n\n        this.wsClient.onerror = (event) => {\n            // Do Nothing\n        };\n    }\n\n    reconnect(rpcUrl, options) {\n        if (!this.wsClient) {\n            return;\n        }\n\n        const onOpenFn = this.wsClient.onopen;\n        const onCloseFn = this.wsClient.onclose;\n        const onMessageFn = this.wsClient.onmessage;\n        const onErrorFn = this.wsClient.onerror;\n\n        this.init();\n\n        this.wsClient = new WebSocket(rpcUrl);\n        this.wsClient.onopen = onOpenFn;\n        this.wsClient.onclose = onCloseFn;\n        this.wsClient.onmessage = onMessageFn;\n        this.wsClient.onerror = onErrorFn;\n    }\n\n    send(requestContext) {\n        const deferred = {};\n        deferred.promise = new Promise((resolve, reject) => {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n\n        this.sendQueue.push({\n            url: requestContext.url,\n            data: requestContext.data,\n            deferred: deferred\n        });\n\n        if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n            this.fireSendQueue();\n        }\n\n        return deferred.promise;\n    }\n\n    getReadyState() {\n        if (!this.wsClient) {\n            return null;\n        }\n\n        return this.wsClient.readyState;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "class WebSocketClient {\n  constructor() {\n    this.wsClient = null;\n    this.sendQueue = [];\n    this.pendingReconnect = null;\n  }\n\n  fireSendQueue() {\n    this.sendQueue.forEach(message => {\n      this.wsClient.send(message);\n    });\n    this.clearSendQueue();\n  }\n\n  clearSendQueue() {\n    this.sendQueue = [];\n  }\n\n  planToReconnect(rpcUrl, options) {\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n    }\n    this.pendingReconnect = setTimeout(() => {\n      this.connect(rpcUrl, options);\n    }, options.reconnectDelay || 5000);\n  }\n\n  init() {\n    if (this.wsClient) {\n      this.wsClient.close();\n      this.wsClient = null;\n    }\n    this.clearSendQueue();\n  }\n\n  connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n    this.init();\n    this.wsClient = new WebSocket(rpcUrl, options.protocol);\n\n    this.wsClient.onopen = () => {\n      this.fireSendQueue();\n      onOpenCallback();\n    };\n\n    this.wsClient.onclose = () => {\n      onCloseCallback();\n      this.planToReconnect(rpcUrl, options);\n    };\n\n    this.wsClient.onmessage = (event) => {\n      onMessageCallback(event.data);\n    };\n\n    this.wsClient.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }\n\n  reconnect(rpcUrl, options) {\n    this.connect(rpcUrl, options);\n  }\n\n  send(requestContext) {\n    return new Promise((resolve, reject) => {\n      if (this.wsClient.readyState === WebSocket.OPEN) {\n        this.wsClient.send(JSON.stringify(requestContext));\n        resolve();\n      } else {\n        this.sendQueue.push(() => {\n          this.wsClient.send(JSON.stringify(requestContext));\n        });\n        reject(new Error('WebSocket is not open'));\n      }\n    });\n  }\n\n  getReadyState() {\n    return this.wsClient ? this.wsClient.readyState : null;\n  }\n}",
      "```javascript\nclass WebSocketClient {\n    constructor() {\n        this.wsClient = null;\n        this.sendQueue = [];\n        this.pendingReconnect = null;\n    }\n\n    fireSendQueue() {\n        this.sendQueue.forEach(message => {\n            this.wsClient.send(message);\n        });\n        this.clearSendQueue();\n    }\n\n    clearSendQueue() {\n        this.sendQueue = [];\n    }\n\n    planToReconnect(rpcUrl, options) {\n        if (this.pendingReconnect) {\n            clearTimeout(this.pendingReconnect);\n        }\n        this.pendingReconnect = setTimeout(() => {\n            this.connect(rpcUrl, options);\n        }, options.reconnectDelay || 5000);\n    }\n\n    init() {\n        if (this.wsClient) {\n            this.wsClient.close();\n            this.wsClient = null;\n        }\n        this.clearSendQueue();\n    }\n\n    connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n        this.init();\n        this.wsClient = new WebSocket(rpcUrl, options.protocol);\n\n        this.wsClient.onopen = () => {\n            this.fireSendQueue();\n            onOpenCallback();\n        };\n\n        this.wsClient.onclose = () => {\n            onCloseCallback();\n            this.planToReconnect(rpcUrl, options);\n        };\n\n        this.wsClient.onmessage = (event) => {\n            onMessageCallback(event.data);\n        };\n\n        this.wsClient.onerror = (error) => {\n            console.error('WebSocket error:', error);\n        };\n    }\n\n    reconnect(rpcUrl, options) {\n        this.connect(rpcUrl, options);\n    }\n\n    send(requestContext) {\n        return new Promise((resolve, reject) => {\n            const message = JSON.stringify(requestContext);\n            this.sendQueue.push(message);\n            if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n                this.wsClient.send(message);\n                resolve();\n            } else {\n                this.wsClient.onopen = () => {\n                    this.wsClient.send(message);\n                    resolve();\n                };\n            }\n        });\n    }\n\n    getReadyState() {\n        return this.wsClient ? this.wsClient.readyState : null;\n    }\n}\n```",
      "class WebSocketClient {\n  constructor() {\n    this.wsClient = null;\n    this.sendQueue = [];\n    this.pendingReconnect = null;\n  }\n\n  fireSendQueue() {\n    this.sendQueue.forEach(message => {\n      this.wsClient.send(message);\n    });\n    this.clearSendQueue();\n  }\n\n  clearSendQueue() {\n    this.sendQueue = [];\n  }\n\n  planToReconnect(rpcUrl, options) {\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n    }\n    this.pendingReconnect = setTimeout(() => {\n      this.connect(rpcUrl, options);\n    }, options.reconnectDelay || 5000);\n  }\n\n  init() {\n    if (this.wsClient) {\n      this.wsClient.close();\n      this.wsClient = null;\n    }\n    this.clearSendQueue();\n  }\n\n  connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n    this.init();\n    this.wsClient = new WebSocket(rpcUrl, options.protocol);\n    this.wsClient.onopen = () => {\n      this.fireSendQueue();\n      onOpenCallback();\n    };\n    this.wsClient.onclose = () => {\n      onCloseCallback();\n      this.planToReconnect(rpcUrl, options);\n    };\n    this.wsClient.onmessage = (event) => {\n      onMessageCallback(event);\n    };\n    this.wsClient.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }\n\n  reconnect(rpcUrl, options) {\n    this.connect(rpcUrl, options);\n  }\n\n  send(requestContext) {\n    return new Promise((resolve, reject) => {\n      this.sendQueue.push(JSON.stringify(requestContext));\n      if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n        this.wsClient.send(this.sendQueue[0]);\n        this.sendQueue.shift();\n      } else {\n        this.wsClient.onopen = () => {\n          this.wsClient.send(this.sendQueue[0]);\n          this.sendQueue.shift();\n          resolve();\n        };\n      }\n    });\n  }\n\n  getReadyState() {\n    return this.wsClient ? this.wsClient.readyState : null;\n  }\n}",
      "class WebSocketClient {\n  constructor() {\n    this.wsClient = null;\n    this.sendQueue = [];\n    this.pendingReconnect = null;\n  }\n\n  fireSendQueue() {\n    while (this.sendQueue.length > 0) {\n      const message = this.sendQueue.shift();\n      this.wsClient.send(message);\n    }\n  }\n\n  clearSendQueue() {\n    this.sendQueue = [];\n    this.sendQueue.forEach((message) => {\n      message.reject(new Error('WebSocket connection closed'));\n    });\n  }\n\n  planToReconnect(rpcUrl, options) {\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n    }\n    this.pendingReconnect = setTimeout(() => {\n      this.connect(rpcUrl, options);\n    }, options.reconnectDelay || 5000);\n  }\n\n  init() {\n    if (this.wsClient) {\n      this.wsClient.close();\n      this.wsClient = null;\n    }\n    this.clearSendQueue();\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n      this.pendingReconnect = null;\n    }\n  }\n\n  connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n    this.init();\n    this.wsClient = new WebSocket(rpcUrl, options.protocol);\n\n    this.wsClient.onopen = () => {\n      this.fireSendQueue();\n      onOpenCallback();\n    };\n\n    this.wsClient.onclose = (event) => {\n      onCloseCallback(event);\n      this.planToReconnect(rpcUrl, options);\n    };\n\n    this.wsClient.onmessage = (event) => {\n      onMessageCallback(event);\n    };\n\n    this.wsClient.onerror = (event) => {\n      onCloseCallback(event);\n      this.planToReconnect(rpcUrl, options);\n    };\n  }\n\n  reconnect(rpcUrl, options) {\n    this.connect(rpcUrl, options);\n  }\n\n  send(requestContext) {\n    return new Promise((resolve, reject) => {\n      this.sendQueue.push({ data: requestContext, resolve, reject });\n      if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n        this.fireSendQueue();\n      }\n    });\n  }\n\n  getReadyState() {\n    return this.wsClient ? this.wsClient.readyState : null;\n  }\n}",
      "```javascript\nclass WebSocketClient {\n  constructor() {\n    this.wsClient = null;\n    this.sendQueue = [];\n    this.pendingReconnect = null;\n  }\n\n  fireSendQueue() {\n    this.sendQueue.forEach(message => {\n      this.wsClient.send(message);\n    });\n    this.clearSendQueue();\n  }\n\n  clearSendQueue() {\n    this.sendQueue = [];\n  }\n\n  planToReconnect(rpcUrl, options) {\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n    }\n    this.pendingReconnect = setTimeout(() => {\n      this.connect(rpcUrl, options);\n    }, options.reconnectDelay || 5000);\n  }\n\n  init() {\n    if (this.wsClient) {\n      this.wsClient.close();\n      this.wsClient = null;\n    }\n    this.clearSendQueue();\n  }\n\n  connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n    this.init();\n    this.wsClient = new WebSocket(rpcUrl, options.protocol);\n    this.wsClient.onopen = () => {\n      this.fireSendQueue();\n      onOpenCallback();\n    };\n    this.wsClient.onclose = () => {\n      onCloseCallback();\n      this.planToReconnect(rpcUrl, options);\n    };\n    this.wsClient.onmessage = (event) => {\n      onMessageCallback(event.data);\n    };\n  }\n\n  reconnect(rpcUrl, options) {\n    this.connect(rpcUrl, options);\n  }\n\n  send(requestContext) {\n    return new Promise((resolve, reject) => {\n      this.sendQueue.push(requestContext);\n      if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n        this.wsClient.send(JSON.stringify(requestContext));\n      }\n    });\n  }\n\n  getReadyState() {\n    return this.wsClient ? this.wsClient.readyState : null;\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor() {\n    this.wsClient = null;\n    this.sendQueue = [];\n    this.pendingReconnect = null;\n  }\n\n  fireSendQueue() {\n    while (this.sendQueue.length > 0) {\n      const message = this.sendQueue.shift();\n      this.wsClient.send(message);\n    }\n  }\n\n  clearSendQueue() {\n    this.sendQueue = [];\n  }\n\n  planToReconnect(rpcUrl, options) {\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n    }\n    this.pendingReconnect = setTimeout(() => {\n      this.connect(rpcUrl, options);\n    }, options.reconnectDelay || 5000);\n  }\n\n  init() {\n    if (this.wsClient) {\n      this.wsClient.close();\n      this.wsClient = null;\n    }\n    this.clearSendQueue();\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n      this.pendingReconnect = null;\n    }\n  }\n\n  connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n    this.init();\n    this.wsClient = new WebSocket(rpcUrl, options.protocol);\n    this.wsClient.onopen = () => {\n      this.fireSendQueue();\n      onOpenCallback();\n    };\n    this.wsClient.onclose = (event) => {\n      onCloseCallback(event);\n      this.planToReconnect(rpcUrl, options);\n    };\n    this.wsClient.onmessage = (event) => {\n      onMessageCallback(event);\n    };\n    this.wsClient.onerror = (event) => {\n      onCloseCallback(event);\n      this.planToReconnect(rpcUrl, options);\n    };\n  }\n\n  reconnect(rpcUrl, options) {\n    this.connect(rpcUrl, options);\n  }\n\n  send(requestContext) {\n    return new Promise((resolve, reject) => {\n      const message = JSON.stringify(requestContext);\n      this.sendQueue.push(message);\n      if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n        this.wsClient.send(message);\n        resolve();\n      } else {\n        this.wsClient.onopen = () => {\n          this.wsClient.send(message);\n          resolve();\n        };\n      }\n    });\n  }\n\n  getReadyState() {\n    return this.wsClient ? this.wsClient.readyState : null;\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor() {\n    this.wsClient = null;\n    this.sendQueue = [];\n    this.pendingReconnect = null;\n  }\n\n  fireSendQueue() {\n    while (this.sendQueue.length > 0) {\n      const message = this.sendQueue.shift();\n      this.wsClient.send(message);\n    }\n  }\n\n  clearSendQueue() {\n    this.sendQueue = [];\n  }\n\n  planToReconnect(rpcUrl, options) {\n    clearTimeout(this.pendingReconnect);\n    this.pendingReconnect = setTimeout(() => {\n      this.connect(rpcUrl, options);\n    }, options.reconnectDelay || 5000);\n  }\n\n  init() {\n    if (this.wsClient) {\n      this.wsClient.close();\n      this.wsClient = null;\n    }\n    this.clearSendQueue();\n    clearTimeout(this.pendingReconnect);\n  }\n\n  connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n    this.init();\n    this.wsClient = new WebSocket(rpcUrl, options.protocol);\n\n    this.wsClient.onopen = () => {\n      this.fireSendQueue();\n      onOpenCallback();\n    };\n\n    this.wsClient.onclose = (event) => {\n      onCloseCallback(event);\n      if (this.wsClient.readyState === WebSocket.CLOSED) {\n        this.planToReconnect(rpcUrl, options);\n      }\n    };\n\n    this.wsClient.onmessage = (event) => {\n      onMessageCallback(event);\n    };\n  }\n\n  reconnect(rpcUrl, options) {\n    this.connect(rpcUrl, options);\n  }\n\n  send(requestContext) {\n    return new Promise((resolve, reject) => {\n      const message = JSON.stringify(requestContext);\n      this.sendQueue.push(message);\n      if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n        this.wsClient.send(message);\n        resolve();\n      } else {\n        this.wsClient.onopen = () => {\n          this.wsClient.send(message);\n          resolve();\n        };\n      }\n    });\n  }\n\n  getReadyState() {\n    return this.wsClient ? this.wsClient.readyState : null;\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor() {\n        this.wsClient = null;\n        this.sendQueue = [];\n        this.pendingReconnect = null;\n    }\n\n    fireSendQueue() {\n        this.sendQueue.forEach(message => {\n            this.wsClient.send(message);\n        });\n        this.clearSendQueue();\n    }\n\n    clearSendQueue() {\n        this.sendQueue = [];\n    }\n\n    planToReconnect(rpcUrl, options) {\n        if (this.pendingReconnect) {\n            clearTimeout(this.pendingReconnect);\n        }\n        this.pendingReconnect = setTimeout(() => {\n            this.connect(rpcUrl, options);\n        }, options.reconnectDelay || 5000);\n    }\n\n    init() {\n        if (this.wsClient) {\n            this.wsClient.close();\n            this.wsClient = null;\n        }\n        this.clearSendQueue();\n    }\n\n    connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n        this.init();\n        this.wsClient = new WebSocket(rpcUrl, options.protocol);\n\n        this.wsClient.onopen = () => {\n            this.fireSendQueue();\n            onOpenCallback();\n        };\n\n        this.wsClient.onclose = () => {\n            onCloseCallback();\n            this.planToReconnect(rpcUrl, options);\n        };\n\n        this.wsClient.onmessage = (event) => {\n            onMessageCallback(event.data);\n        };\n\n        this.wsClient.onerror = (error) => {\n            console.error('WebSocket error:', error);\n        };\n    }\n\n    reconnect(rpcUrl, options) {\n        this.connect(rpcUrl, options);\n    }\n\n    send(requestContext) {\n        return new Promise((resolve, reject) => {\n            this.sendQueue.push(JSON.stringify(requestContext));\n            if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n                this.wsClient.send(this.sendQueue[0]);\n                this.sendQueue.shift();\n            }\n        });\n    }\n\n    getReadyState() {\n        return this.wsClient ? this.wsClient.readyState : null;\n    }\n}\n```",
      "class WebSocketClient {\n  constructor() {\n    this.wsClient = null;\n    this.sendQueue = [];\n    this.pendingReconnect = null;\n  }\n\n  fireSendQueue() {\n    this.sendQueue.forEach(message => {\n      this.wsClient.send(message);\n    });\n    this.clearSendQueue();\n  }\n\n  clearSendQueue() {\n    this.sendQueue = [];\n  }\n\n  planToReconnect(rpcUrl, options) {\n    if (this.pendingReconnect) {\n      clearTimeout(this.pendingReconnect);\n    }\n    this.pendingReconnect = setTimeout(() => {\n      this.connect(rpcUrl, options);\n    }, options.reconnectDelay || 5000);\n  }\n\n  init() {\n    if (this.wsClient) {\n      this.wsClient.close();\n      this.wsClient = null;\n    }\n    this.clearSendQueue();\n  }\n\n  connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n    this.init();\n    this.wsClient = new WebSocket(rpcUrl, options.protocol);\n\n    this.wsClient.onopen = () => {\n      this.fireSendQueue();\n      onOpenCallback();\n    };\n\n    this.wsClient.onclose = () => {\n      onCloseCallback();\n      this.planToReconnect(rpcUrl, options);\n    };\n\n    this.wsClient.onmessage = (event) => {\n      onMessageCallback(event.data);\n    };\n\n    this.wsClient.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }\n\n  reconnect(rpcUrl, options) {\n    this.connect(rpcUrl, options);\n  }\n\n  send(requestContext) {\n    return new Promise((resolve, reject) => {\n      const message = JSON.stringify(requestContext);\n      this.sendQueue.push(message);\n      if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n        this.wsClient.send(message);\n      } else {\n        this.planToReconnect(this.wsClient.url, options);\n      }\n      resolve();\n    });\n  }\n\n  getReadyState() {\n    return this.wsClient ? this.wsClient.readyState : null;\n  }\n}",
      "```javascript\nclass WebSocketClient {\n    constructor() {\n        this.wsClient = null;\n        this.sendQueue = [];\n        this.pendingReconnect = null;\n    }\n\n    fireSendQueue() {\n        this.sendQueue.forEach(message => {\n            this.wsClient.send(message);\n        });\n        this.clearSendQueue();\n    }\n\n    clearSendQueue() {\n        this.sendQueue = [];\n    }\n\n    planToReconnect(rpcUrl, options) {\n        if (this.pendingReconnect) {\n            clearTimeout(this.pendingReconnect);\n        }\n        this.pendingReconnect = setTimeout(() => {\n            this.connect(rpcUrl, options);\n        }, options.reconnectDelay || 5000);\n    }\n\n    init() {\n        if (this.wsClient) {\n            this.wsClient.close();\n            this.wsClient = null;\n        }\n        this.clearSendQueue();\n    }\n\n    connect(rpcUrl, options, onOpenCallback, onCloseCallback, onMessageCallback) {\n        this.init();\n        this.wsClient = new WebSocket(rpcUrl, options.protocol);\n\n        this.wsClient.onopen = () => {\n            this.fireSendQueue();\n            onOpenCallback();\n        };\n\n        this.wsClient.onclose = () => {\n            onCloseCallback();\n            this.planToReconnect(rpcUrl, options);\n        };\n\n        this.wsClient.onmessage = (event) => {\n            onMessageCallback(event.data);\n        };\n\n        this.wsClient.onerror = (error) => {\n            console.error('WebSocket error:', error);\n        };\n    }\n\n    reconnect(rpcUrl, options) {\n        this.connect(rpcUrl, options);\n    }\n\n    send(requestContext) {\n        return new Promise((resolve, reject) => {\n            this.sendQueue.push(JSON.stringify(requestContext));\n            if (this.wsClient && this.wsClient.readyState === WebSocket.OPEN) {\n                this.wsClient.send(this.sendQueue[0]);\n                this.sendQueue.shift();\n            }\n        });\n    }\n\n    getReadyState() {\n        return this.wsClient ? this.wsClient.readyState : null;\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends messages, and manages errors and closures.\n\nFunction Description: The function `connectWebSocket` initializes a WebSocket client connection to a specified server. It sets up event handlers for connection opening, incoming messages, and connection closing. The function also sends an initial message upon successful connection and logs all events to the console.\n\nInput: \n- Optional command line arguments:\n  - `port` (number): The port number to connect to (default: 7000).\n  - `secure` (boolean): Whether to use a secure WebSocket connection (wss) (default: false, uses ws).\n\nOutput: \n- No explicit return value. The function logs connection status, received messages, and closure events to the console.\n- Side effects: Establishes a WebSocket connection and sends/receives messages.",
    "Canonical_solution": "function connectWebSocket() {\n    var WebSocket = require('../lib/faye/websocket'),\n        port = process.argv[2] || 7000,\n        secure = process.argv[3] === 'ssl',\n        scheme = secure ? 'wss' : 'ws',\n        ws = new WebSocket.Client(scheme + '://localhost:' + port + '/');\n\n    console.log('Connecting to ' + ws.url);\n\n    ws.onopen = function(event) {\n        console.log('open');\n        ws.send('Hello, WebSocket!');\n    };\n\n    ws.onmessage = function(event) {\n        console.log('message', event.data);\n    };\n\n    ws.onclose = function(event) {\n        console.log('close', event.code, event.reason);\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const ws = new WebSocket(`${protocol}://localhost:${port}`);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    ws.send('Hello, WebSocket Server!');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message from server:', event.data);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n}\n```",
      "```javascript\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const url = `${protocol}://localhost:${port}`;\n\n  const ws = new WebSocket(url);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    ws.send('Hello, WebSocket Server!');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message from server:', event.data);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n}\n```",
      "```javascript\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const url = `${protocol}://localhost:${port}`;\n\n  const ws = new WebSocket(url);\n\n  ws.onopen = function(event) {\n    console.log('WebSocket connection established');\n    ws.send('Hello, WebSocket Server!');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message from server:', event.data);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n}\n```",
      "```javascript\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const url = `${protocol}://localhost:${port}`;\n\n  const ws = new WebSocket(url);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    ws.send('Hello, WebSocket Server!');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n}\n```",
      "```javascript\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const url = `${protocol}://localhost:${port}`;\n\n  const ws = new WebSocket(url);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    ws.send('Hello, WebSocket Server!');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message from server:', event.data);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n}\n```",
      "```javascript\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const url = `${protocol}://localhost:${port}`;\n\n  const ws = new WebSocket(url);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    ws.send('Hello, WebSocket Server!');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message from server:', event.data);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n}\n```",
      "```javascript\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const url = `${protocol}://localhost:${port}`;\n\n  const ws = new WebSocket(url);\n\n  ws.onopen = function(event) {\n    console.log('WebSocket connection established');\n    ws.send('Hello, WebSocket Server!');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n}\n```",
      "```javascript\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const url = `${protocol}://localhost:${port}`;\n\n  const ws = new WebSocket(url);\n\n  ws.onopen = function() {\n    console.log('WebSocket connection established');\n    ws.send('Hello, WebSocket Server!');\n  };\n\n  ws.onmessage = function(event) {\n    console.log('Message received:', event.data);\n  };\n\n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  ws.onclose = function(event) {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst WebSocket = require('ws');\n\nfunction connectWebSocket() {\n  const port = process.argv[2] ? parseInt(process.argv[2], 10) : 7000;\n  const secure = process.argv[3] === 'true';\n\n  const protocol = secure ? 'wss' : 'ws';\n  const ws = new WebSocket(`${protocol}://localhost:${port}`);\n\n  ws.on('open', () => {\n    console.log('Connection opened');\n    ws.send('Hello, WebSocket server!');\n  });\n\n  ws.on('message', (data) => {\n    console.log('Received:', data);\n  });\n\n  ws.on('error', (error) => {\n    console.error('WebSocket error:', error);\n  });\n\n  ws.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction connectWebSocket(port = 7000, secure = false) {\n  const protocol = secure ? 'wss' : 'ws';\n  const ws = new WebSocket(`${protocol}://localhost:${port}`);\n\n  ws.on('open', function open() {\n    console.log('Connection opened');\n    ws.send('Hello, server!');\n  });\n\n  ws.on('message', function incoming(data) {\n    console.log('Received:', data);\n  });\n\n  ws.on('error', function error(err) {\n    console.error('WebSocket error:', err);\n  });\n\n  ws.on('close', function close() {\n    console.log('Connection closed');\n  });\n}\n```"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 253,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends and receives messages, and manages errors and connection closure.\n\nFunction Description: The code consists of several functions that work together to create and manage a WebSocket connection. The main function `testWebSocket` initializes the connection, while other functions handle specific events like opening/closing the connection, receiving messages, and handling errors. The `doSend` function is used to send messages through the WebSocket connection.\n\nInput:\n- `wsUri` (String): The WebSocket server URI to connect to (e.g., \"ws://example.com/socket\")\n\nOutput:\n- No direct return values, but the functions perform the following actions:\n  - Establish a WebSocket connection\n  - Send messages to the server\n  - Display connection status and messages in the UI\n  - Handle errors and connection closure\n\nFunctions:\n1. `testWebSocket()`: Initializes a new WebSocket connection and sets up event handlers\n2. `onOpen(evt)`: Handles the connection open event, sends a test message\n3. `onClose(evt)`: Handles the connection close event\n4. `onMessage(evt)`: Handles incoming messages and closes the connection\n5. `onError(evt)`: Handles connection errors\n6. `doSend(message)`: Sends a message through the WebSocket connection\n\nNote: The implementation assumes the existence of a `writeToScreen` function for displaying messages in the UI.",
    "Canonical_solution": "function testWebSocket() {\n    websocket = new WebSocket(wsUri);\n    websocket.onopen = function (evt) {\n        onOpen(evt)\n    };\n    websocket.onclose = function (evt) {\n        onClose(evt)\n    };\n    websocket.onmessage = function (evt) {\n        onMessage(evt)\n    };\n    websocket.onerror = function (evt) {\n        onError(evt)\n    };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"CONNECTED\");\n    doSend(\"WebSocket rocks\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"DISCONNECTED\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('<span style=\"color: blue;\">RESPONSE: ' + evt.data + '</span>');\n    websocket.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + evt.data);\n}\n\nfunction doSend(message) {\n    writeToScreen(\"SENT: \" + message);\n    websocket.send(message);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"test\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('Message received: ' + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error occurred: ' + evt.data);\n}\n\nfunction doSend(message) {\n    if (ws.readyState === WebSocket.OPEN) {\n        ws.send(message);\n    } else {\n        writeToScreen('Connection not open');\n    }\n}\n```",
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"Hello, server!\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('Message received: ' + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error occurred: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen('Sent: ' + message);\n}\n\nfunction writeToScreen(message) {\n    var pre = document.createElement(\"p\");\n    pre.style.wordWrap = \"break-word\";\n    pre.innerHTML = message;\n    document.getElementById(\"console\").appendChild(pre);\n}\n```",
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"Hello, server!\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('Message received: ' + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error occurred: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen('Sent: ' + message);\n}\n\nfunction writeToScreen(message) {\n    var pre = document.createElement(\"p\");\n    pre.style.wordWrap = \"break-word\";\n    pre.innerHTML = message;\n    document.getElementById(\"console\").appendChild(pre);\n}\n```",
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"test\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('Received: ' + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error occurred: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen('Sent: ' + message);\n}\n\nfunction writeToScreen(message) {\n    var pre = document.createElement(\"p\");\n    pre.style.wordWrap = \"break-word\";\n    pre.innerHTML = message;\n    document.getElementById(\"log\").appendChild(pre);\n}\n```",
      "```javascript\ntestWebSocket();\n\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"test\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen(\"Received: \" + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen(\"Sent: \" + message);\n}\n\nfunction writeToScreen(message) {\n    var pre = document.createElement(\"p\");\n    pre.style.wordWrap = \"break-word\";\n    pre.innerHTML = message;\n    document.getElementById(\"console\").appendChild(pre);\n}\n```",
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"Hello, server!\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('Message received: ' + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error occurred: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen('Sent: ' + message);\n}\n\nfunction writeToScreen(message) {\n    var pre = document.createElement(\"p\");\n    pre.style.wordWrap = \"break-word\";\n    pre.innerHTML = message;\n    document.getElementById(\"log\").appendChild(pre);\n}\n```",
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connected\");\n    doSend(\"test\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Disconnected\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen(\"Received: \" + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen(\"Sent: \" + message);\n}\n\nfunction writeToScreen(message) {\n    // Implementation for writing to the UI\n}\n```",
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"Hello, server!\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('Message received: ' + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error occurred: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen('Sent: ' + message);\n}\n\nfunction writeToScreen(message) {\n    var pre = document.createElement(\"p\");\n    pre.style.wordWrap = \"break-word\";\n    pre.innerHTML = message;\n    document.getElementById(\"console\").appendChild(pre);\n}\n```",
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"Hello, server!\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('Received Message: ' + evt.data);\n    ws.close();\n}\n\nfunction onError(evt) {\n    writeToScreen('Error occurred: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen('Sent Message: ' + message);\n}\n\nfunction writeToScreen(message) {\n    var pre = document.createElement(\"p\");\n    pre.style.wordWrap = \"break-word\";\n    pre.innerHTML = message;\n    document.getElementById(\"log\").appendChild(pre);\n}\n```",
      "```javascript\nfunction testWebSocket() {\n    var wsUri = \"ws://example.com/socket\";\n    var ws = new WebSocket(wsUri);\n\n    ws.onopen = function(evt) { onOpen(evt); };\n    ws.onclose = function(evt) { onClose(evt); };\n    ws.onmessage = function(evt) { onMessage(evt); };\n    ws.onerror = function(evt) { onError(evt); };\n}\n\nfunction onOpen(evt) {\n    writeToScreen(\"Connection opened\");\n    doSend(\"Hello, server!\");\n}\n\nfunction onClose(evt) {\n    writeToScreen(\"Connection closed\");\n}\n\nfunction onMessage(evt) {\n    writeToScreen('Message from server: ' + evt.data);\n    if (evt.data === \"close\") {\n        ws.close();\n    }\n}\n\nfunction onError(evt) {\n    writeToScreen('Error occurred: ' + evt.data);\n}\n\nfunction doSend(message) {\n    ws.send(message);\n    writeToScreen('Sent message: ' + message);\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes and manages a WebSocket connection, handles events (open, message, error, close), and provides methods for sending data and disconnecting.\n\nClass Description: The WsProvider class encapsulates WebSocket functionality, providing a clean interface for WebSocket communication. It handles connection lifecycle events and ensures proper cleanup when disconnecting.\n\nAttributes:\n#websocket: WebSocket | null - Private field storing the active WebSocket connection instance\n\nMethods:\nconstructor(endpoint: string) -> void - Initializes the WebSocket connection to the specified endpoint\n#connect(endpoint: string) -> void - Private method that establishes the WebSocket connection and sets up event handlers\n#onSocketClose(event: CloseEvent) -> void - Private method handling WebSocket close events\n#onSocketError(error: Event) -> void - Private method handling WebSocket error events\n#onSocketMessage(message: MessageEvent<string>) -> void - Private method handling incoming WebSocket messages\n#onSocketOpen() -> boolean - Private method handling WebSocket open events\nsend(body: string) -> void - Public method for sending data through the WebSocket connection\ndisconnect() -> void - Public method for properly closing the WebSocket connection",
    "Canonical_solution": "import type { Class } from '@polkadot/util/types';\nimport type { JsonRpcResponse, ProviderInterfaceCallback } from '../types.js';\nimport { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\n\nclass WsProvider {\n  #websocket: WebSocket | null;\n\n  constructor(endpoint: string) {\n    this.#websocket = null;\n    this.#connect(endpoint);\n  }\n\n  #connect(endpoint: string): void {\n    try {\n      this.#websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket as unknown as Class<WebSocket>, WebSocket)\n        ? new WebSocket(endpoint)\n        : new WebSocket(endpoint, undefined, {});\n\n      if (this.#websocket) {\n        this.#websocket.onclose = this.#onSocketClose;\n        this.#websocket.onerror = this.#onSocketError;\n        this.#websocket.onmessage = this.#onSocketMessage;\n        this.#websocket.onopen = this.#onSocketOpen;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  #onSocketClose(event: CloseEvent): void {\n    this.#websocket = null;\n  }\n\n  #onSocketError(error: Event): void {\n    // Handle error\n  }\n\n  #onSocketMessage(message: MessageEvent<string>): void {\n    const response = JSON.parse(message.data) as JsonRpcResponse<string>;\n    // Process message\n  }\n\n  #onSocketOpen(): boolean {\n    return true;\n  }\n\n  public send(body: string): void {\n    if (!this.#websocket) {\n      throw new Error('WebSocket is not connected');\n    }\n    this.#websocket.send(body);\n  }\n\n  public disconnect(): void {\n    if (this.#websocket) {\n      this.#websocket.close(1000);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen.bind(this);\n        this.#websocket.onmessage = this.#onSocketMessage.bind(this);\n        this.#websocket.onerror = this.#onSocketError.bind(this);\n        this.#websocket.onclose = this.#onSocketClose.bind(this);\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    #onSocketClose(event) {\n        // Handle WebSocket close event\n    }\n\n    #onSocketError(error) {\n        // Handle WebSocket error event\n    }\n\n    #onSocketMessage(message) {\n        // Handle incoming WebSocket message\n    }\n\n    #onSocketOpen() {\n        return true;\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen.bind(this);\n        this.#websocket.onmessage = this.#onSocketMessage.bind(this);\n        this.#websocket.onerror = this.#onSocketError.bind(this);\n        this.#websocket.onclose = this.#onSocketClose.bind(this);\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    #onSocketClose(event) {\n        // Handle WebSocket close event\n    }\n\n    #onSocketError(error) {\n        // Handle WebSocket error event\n    }\n\n    #onSocketMessage(message) {\n        // Handle incoming WebSocket message\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n            this.#websocket = null;\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen;\n        this.#websocket.onmessage = this.#onSocketMessage;\n        this.#websocket.onerror = this.#onSocketError;\n        this.#websocket.onclose = this.#onSocketClose;\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    #onSocketClose(event) {\n        // Handle WebSocket close event\n    }\n\n    #onSocketError(error) {\n        // Handle WebSocket error event\n    }\n\n    #onSocketMessage(message) {\n        // Handle incoming WebSocket message\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen.bind(this);\n        this.#websocket.onmessage = this.#onSocketMessage.bind(this);\n        this.#websocket.onerror = this.#onSocketError.bind(this);\n        this.#websocket.onclose = this.#onSocketClose.bind(this);\n    }\n\n    #onSocketClose(event) {\n        this.#websocket = null;\n    }\n\n    #onSocketError(error) {\n        console.error('WebSocket error:', error);\n    }\n\n    #onSocketMessage(message) {\n        console.log('Received message:', message.data);\n    }\n\n    #onSocketOpen() {\n        return true;\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen.bind(this);\n        this.#websocket.onmessage = this.#onSocketMessage.bind(this);\n        this.#websocket.onerror = this.#onSocketError.bind(this);\n        this.#websocket.onclose = this.#onSocketClose.bind(this);\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    #onSocketClose(event) {\n        // Handle WebSocket close event\n    }\n\n    #onSocketError(error) {\n        // Handle WebSocket error event\n    }\n\n    #onSocketMessage(message) {\n        // Handle incoming WebSocket message\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen;\n        this.#websocket.onmessage = this.#onSocketMessage;\n        this.#websocket.onerror = this.#onSocketError;\n        this.#websocket.onclose = this.#onSocketClose;\n    }\n\n    #onSocketClose(event) {\n        this.#websocket = null;\n    }\n\n    #onSocketError(error) {\n        console.error('WebSocket error:', error);\n    }\n\n    #onSocketMessage(message) {\n        console.log('Received message:', message.data);\n    }\n\n    #onSocketOpen() {\n        return true;\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen.bind(this);\n        this.#websocket.onmessage = this.#onSocketMessage.bind(this);\n        this.#websocket.onerror = this.#onSocketError.bind(this);\n        this.#websocket.onclose = this.#onSocketClose.bind(this);\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    #onSocketClose(event) {\n        // Handle WebSocket close event\n    }\n\n    #onSocketError(error) {\n        // Handle WebSocket error event\n    }\n\n    #onSocketMessage(message) {\n        // Handle incoming WebSocket message\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen.bind(this);\n        this.#websocket.onmessage = this.#onSocketMessage.bind(this);\n        this.#websocket.onerror = this.#onSocketError.bind(this);\n        this.#websocket.onclose = this.#onSocketClose.bind(this);\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    #onSocketClose(event) {\n        // Handle WebSocket close event\n    }\n\n    #onSocketError(error) {\n        // Handle WebSocket error event\n    }\n\n    #onSocketMessage(message) {\n        // Handle incoming WebSocket message\n    }\n\n    #onSocketOpen() {\n        // Handle WebSocket open event\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen.bind(this);\n        this.#websocket.onmessage = this.#onSocketMessage.bind(this);\n        this.#websocket.onerror = this.#onSocketError.bind(this);\n        this.#websocket.onclose = this.#onSocketClose.bind(this);\n    }\n\n    #onSocketClose(event) {\n        this.#websocket = null;\n    }\n\n    #onSocketError(error) {\n        console.error('WebSocket error:', error);\n    }\n\n    #onSocketMessage(message) {\n        console.log('Received message:', message.data);\n    }\n\n    #onSocketOpen() {\n        return true;\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WsProvider {\n    #websocket;\n\n    constructor(endpoint) {\n        this.#websocket = null;\n        this.connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n        this.#websocket.onopen = this.#onSocketOpen.bind(this);\n        this.#websocket.onmessage = this.#onSocketMessage.bind(this);\n        this.#websocket.onerror = this.#onSocketError.bind(this);\n        this.#websocket.onclose = this.#onSocketClose.bind(this);\n    }\n\n    #onSocketClose(event) {\n        this.#websocket = null;\n    }\n\n    #onSocketError(error) {\n        console.error('WebSocket error:', error);\n    }\n\n    #onSocketMessage(message) {\n        console.log('Received message:', message.data);\n    }\n\n    #onSocketOpen() {\n        return true;\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n        }\n    }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a server, handles various connection events, and processes incoming messages for a reload service.\n\nFunction Description: The `connect` function initializes and manages a WebSocket connection to a specified server. It handles connection events (open, error, message, close) and processes incoming messages to trigger appropriate actions, such as requesting initial load data or reloading extensions when file changes are detected. The function ensures only one active connection exists at a time.\n\nInput: None (The WebSocket URL is hardcoded as 'ws://localhost:__RELOAD_PORT__')\n\nOutput: None (The function primarily manages side effects: establishing connections, logging events, and triggering other functions based on received messages)",
    "Canonical_solution": "function connect() {\n  if (webSocket) {\n    return;\n  }\n\n  webSocket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  webSocket.onerror = (event) => {\n    console.error(`[Reload Service] Connection error: ${JSON.stringify(event)}`);\n    webSocket.close();\n  };\n\n  webSocket.onopen = () => {\n    console.info(`[Reload Service] Connection opened.`);\n  };\n\n  webSocket.onmessage = async (event) => {\n    const message = JSON.parse(event.data);\n\n    if (message.status === 'serverReady') {\n      console.info('[Reload Service] Connection ready.');\n      await requestInitialLoadData();\n    }\n\n    if (message.changedFile) {\n      console.info(\n        `[Reload Service] Changes detected on ${message.changedFile}. Reloading extension...`\n      );\n      await messageAllExtensions(message.changedFile);\n    }\n  };\n\n  webSocket.onclose = () => {\n    console.info('[Reload Service] Connection closed.');\n    webSocket = null;\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n  // Request initial load data\n  ws.send('initialLoad');\n};\n\nws.onerror = function(event) {\n  console.error('WebSocket error:', event);\n};\n\nws.onmessage = function(event) {\n  const message = JSON.parse(event.data);\n  if (message.type === 'fileChange') {\n    // Reload extensions\n    reloadExtensions();\n  } else if (message.type === 'initialLoad') {\n    // Process initial load data\n    processInitialLoadData(message.data);\n  }\n};\n\nws.onclose = function(event) {\n  console.log('WebSocket connection closed:', event);\n};\n\nfunction reloadExtensions() {\n  console.log('Reloading extensions...');\n  // Reload logic here\n}\n\nfunction processInitialLoadData(data) {\n  console.log('Processing initial load data...');\n  // Process data here\n}\n```",
      "```javascript\nconst ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\nws.onopen = function() {\n  console.log('WebSocket connection established');\n  // Request initial load data\n  ws.send('INITIAL_LOAD');\n};\n\nws.onerror = function(event) {\n  console.error('WebSocket error:', event);\n};\n\nws.onmessage = function(event) {\n  const message = JSON.parse(event.data);\n  if (message.type === 'FILE_CHANGE') {\n    // Reload extensions\n    reloadExtensions();\n  } else if (message.type === 'INITIAL_LOAD') {\n    // Process initial load data\n    processInitialLoadData(message.data);\n  }\n};\n\nws.onclose = function() {\n  console.log('WebSocket connection closed');\n};\n\nfunction reloadExtensions() {\n  console.log('Reloading extensions...');\n  // Reload logic here\n}\n\nfunction processInitialLoadData(data) {\n  console.log('Processing initial load data...');\n  // Process data here\n}\n```",
      "```javascript\nconst ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\nws.onopen = function(event) {\n  console.log('WebSocket connection established');\n  // Request initial load data\n  ws.send(JSON.stringify({ type: 'loadData' }));\n};\n\nws.onerror = function(event) {\n  console.error('WebSocket error:', event);\n};\n\nws.onmessage = function(event) {\n  const message = JSON.parse(event.data);\n  switch (message.type) {\n    case 'reload':\n      console.log('Reloading extensions...');\n      // Trigger reload of extensions\n      break;\n    case 'data':\n      console.log('Initial load data received:', message.data);\n      // Process initial load data\n      break;\n    default:\n      console.log('Received unknown message:', message);\n  }\n};\n\nws.onclose = function(event) {\n  console.log('WebSocket connection closed:', event);\n};\n\nfunction connect() {\n  if (ws.readyState === WebSocket.OPEN) {\n    console.log('WebSocket connection already established');\n    return;\n  }\n  ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n}\n```",
      "```javascript\nconst ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\nws.onopen = function(event) {\n  console.log('WebSocket connection established');\n  // Request initial load data\n  ws.send(JSON.stringify({ type: 'loadData' }));\n};\n\nws.onerror = function(event) {\n  console.error('WebSocket error:', event);\n};\n\nws.onmessage = function(event) {\n  const message = JSON.parse(event.data);\n  if (message.type === 'reload') {\n    // Reload extensions or other components\n    console.log('Reloading due to file change');\n    // Trigger reload function\n  }\n};\n\nws.onclose = function(event) {\n  console.log('WebSocket connection closed');\n  // Handle reconnection or cleanup\n};\n\nfunction connect() {\n  if (ws.readyState === WebSocket.OPEN) {\n    console.log('WebSocket connection already established');\n  } else {\n    ws.connect();\n  }\n}\n```",
      "```javascript\nconst ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\nws.onopen = function(event) {\n  console.log('WebSocket connection established');\n  // Request initial load data\n  ws.send(JSON.stringify({ type: 'initialLoad' }));\n};\n\nws.onerror = function(event) {\n  console.error('WebSocket error:', event);\n};\n\nws.onmessage = function(event) {\n  const message = JSON.parse(event.data);\n  switch (message.type) {\n    case 'reload':\n      // Reload extensions or perform other actions\n      console.log('Reloading extensions...');\n      break;\n    case 'initialLoad':\n      // Handle initial load data\n      console.log('Initial load data received');\n      break;\n    default:\n      console.log('Received message with unknown type:', message.type);\n  }\n};\n\nws.onclose = function(event) {\n  console.log('WebSocket connection closed');\n};\n\nfunction connect() {\n  if (ws.readyState === WebSocket.OPEN) {\n    console.log('WebSocket connection already established');\n    return;\n  }\n  ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst WebSocket = require('ws');\n\nlet ws;\n\nfunction connect() {\n  if (ws) return;\n\n  ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  ws.on('open', function() {\n    console.log('Connected to WebSocket server');\n    // Request initial load data\n    ws.send(JSON.stringify({ type: 'loadData' }));\n  });\n\n  ws.on('message', function(message) {\n    const data = JSON.parse(message);\n    switch (data.type) {\n      case 'reloadExtensions':\n        console.log('Reloading extensions...');\n        // Trigger reload of extensions\n        break;\n      default:\n        console.log('Received message:', data);\n        break;\n    }\n  });\n\n  ws.on('error', function(error) {\n    console.error('WebSocket error:', error);\n  });\n\n  ws.on('close', function() {\n    console.log('WebSocket connection closed');\n    ws = null;\n  });\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nlet ws;\n\nfunction connect() {\n  if (ws) return;\n\n  ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  ws.on('open', function() {\n    console.log('WebSocket connection established');\n    // Request initial load data\n    ws.send(JSON.stringify({ type: 'loadData' }));\n  });\n\n  ws.on('message', function(message) {\n    const data = JSON.parse(message);\n    if (data.type === 'reload') {\n      console.log('Reloading extensions...');\n      // Trigger reload of extensions\n    }\n  });\n\n  ws.on('error', function(error) {\n    console.error('WebSocket error:', error);\n  });\n\n  ws.on('close', function() {\n    console.log('WebSocket connection closed');\n    ws = null;\n  });\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nlet ws;\n\nfunction connect() {\n  if (ws) return;\n\n  ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  ws.on('open', function() {\n    console.log('Connected to the WebSocket server');\n    // Request initial load data\n    ws.send(JSON.stringify({ type: 'initialLoad' }));\n  });\n\n  ws.on('message', function(message) {\n    const data = JSON.parse(message);\n    if (data.type === 'fileChange') {\n      // Reload extensions\n      reloadExtensions();\n    }\n  });\n\n  ws.on('error', function(error) {\n    console.error('WebSocket error:', error);\n  });\n\n  ws.on('close', function() {\n    console.log('Disconnected from the WebSocket server');\n    ws = null;\n  });\n}\n\nfunction reloadExtensions() {\n  console.log('Reloading extensions...');\n  // Implement reload logic here\n}\n\nmodule.exports = { connect };\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nlet ws;\n\nfunction connect() {\n  if (ws) {\n    return;\n  }\n\n  ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  ws.on('open', function() {\n    console.log('Connection opened');\n    // Request initial load data\n    ws.send(JSON.stringify({ type: 'INITIAL_LOAD' }));\n  });\n\n  ws.on('message', function(message) {\n    const data = JSON.parse(message);\n    if (data.type === 'FILE_CHANGE') {\n      // Reload extensions\n      console.log('Reloading extensions...');\n      // Trigger reload logic here\n    }\n  });\n\n  ws.on('error', function(error) {\n    console.error('WebSocket error:', error);\n  });\n\n  ws.on('close', function() {\n    console.log('Connection closed');\n    ws = null;\n  });\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nlet ws;\n\nfunction connect() {\n  if (ws) return;\n\n  ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  ws.on('open', function open() {\n    console.log('Connection opened');\n    // Request initial load data or other actions on connection open\n  });\n\n  ws.on('message', function incoming(data) {\n    const message = JSON.parse(data);\n    if (message.type === 'reload') {\n      // Trigger reload of extensions or other actions\n      console.log('Reloading due to file change');\n    }\n    // Handle other message types as needed\n  });\n\n  ws.on('error', function error(err) {\n    console.error('WebSocket error:', err);\n  });\n\n  ws.on('close', function close() {\n    console.log('Connection closed');\n    ws = null;\n  });\n}\n```"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a LiveReload server and handles reload commands for browser extensions.\n\nFunction Description: The function `setupWebSocketReload` creates a WebSocket connection to a LiveReload server running on localhost. It sets up event handlers to manage connection errors and incoming messages. When a reload command is received, it triggers the browser extension's reload functionality.\n\nInput: None (The function uses predefined constants for host and port)\n\nOutput: None (The function's side effects are establishing a WebSocket connection and setting up event handlers that may trigger a browser extension reload)\n\nNote: The actual WebSocket URL is constructed using the constants LIVERELOAD_HOST and LIVERELOAD_PORT, with the path '/livereload'. The function handles JSON messages where a 'reload' command triggers the extension reload.",
    "Canonical_solution": "function setupWebSocketReload() {\n    var LIVERELOAD_HOST = 'localhost:';\n    var LIVERELOAD_PORT = 35729;\n    var connection = new WebSocket('ws://' + LIVERELOAD_HOST + LIVERELOAD_PORT + '/livereload');\n\n    connection.onerror = function (error) {\n        console.log('reload connection got error:', error);\n    };\n\n    connection.onmessage = function (e) {\n        if (e.data) {\n            var data = JSON.parse(e.data);\n            if (data && data.command === 'reload') {\n                ext.runtime.reload();\n            }\n        }\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onerror = function(event) {\n    console.error('WebSocket error:', event);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      // Trigger browser extension reload functionality\n      console.log('Reloading the browser...');\n      // Assuming a function `triggerExtensionReload` exists\n      triggerExtensionReload();\n    }\n  };\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed');\n  };\n}\n\nsetupWebSocketReload();\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onopen = function() {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      console.log('Reloading the browser extension');\n      // Trigger browser extension reload functionality here\n    }\n  };\n\n  socket.onclose = function() {\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onopen = function() {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      console.log('Reloading the browser extension...');\n      // Trigger browser extension reload functionality\n    }\n  };\n\n  socket.onclose = function() {\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onerror = function(event) {\n    console.error('WebSocket error:', event);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      // Trigger browser extension reload functionality\n      console.log('Reloading the browser...');\n      // Assuming there's a function `triggerExtensionReload` that handles the reload\n      triggerExtensionReload();\n    }\n  };\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed');\n  };\n}\n\n// Assuming this function is defined elsewhere in the codebase\nfunction triggerExtensionReload() {\n  // Implementation for triggering the browser extension reload\n}\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onerror = function(event) {\n    console.error('WebSocket error:', event);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      window.location.reload();\n    }\n  };\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onerror = function(event) {\n    console.error('WebSocket error:', event);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      // Trigger browser extension reload functionality\n      console.log('Reloading the page...');\n      // This is a placeholder for the actual reload command\n      // For example, in Chrome, you might use chrome.runtime.sendMessage({action: \"reload\"});\n    }\n  };\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed');\n  };\n}\n\nsetupWebSocketReload();\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onerror = function(event) {\n    console.error('WebSocket error:', event);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      window.location.reload();\n    }\n  };\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onerror = function(event) {\n    console.error('WebSocket error:', event);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      // Trigger browser extension reload functionality\n      console.log('Reloading the browser...');\n    }\n  };\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onerror = function(event) {\n    console.error('WebSocket Error:', event);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      // Trigger browser extension reload functionality\n      console.log('Reloading the browser...');\n    }\n  };\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed');\n  };\n}\n```",
      "```javascript\nconst LIVERELOAD_HOST = 'localhost';\nconst LIVERELOAD_PORT = 35729;\n\nfunction setupWebSocketReload() {\n  const socketUrl = `ws://${LIVERELOAD_HOST}:${LIVERELOAD_PORT}/livereload`;\n  const socket = new WebSocket(socketUrl);\n\n  socket.onerror = function(event) {\n    console.error('WebSocket error:', event);\n  };\n\n  socket.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.command === 'reload') {\n      window.location.reload();\n    }\n  };\n\n  socket.onopen = function(event) {\n    console.log('WebSocket connection established');\n  };\n\n  socket.onclose = function(event) {\n    console.log('WebSocket connection closed');\n  };\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes a connection to a server, handles incoming messages, manages connection errors, and provides functionality to close the connection.\n\nClass Description: The WebSocketClient class encapsulates WebSocket functionality for establishing and managing a WebSocket connection. It handles connection events, message reception, and error scenarios, while providing a clean interface for external message handling through a callback.\n\nAttributes:\n- url: [String] - The server URL to connect to (without protocol)\n- actionId: [String] - An identifier for the specific WebSocket action/channel\n- onMessageCallback: [Function] - Callback function to handle incoming messages\n- socket: [WebSocket|null] - Reference to the WebSocket connection instance\n- initData: [Boolean] - Flag indicating whether initial data has been received\n- WebSocket: [WebSocket|null] - Alias for the socket instance (set after successful connection)\n\nMethods:\n- constructor(url, actionId, onMessageCallback) -> [void] - Initializes the WebSocketClient with connection URL, action ID, and message callback\n- connect() -> [void] - Establishes the WebSocket connection and sets up event handlers\n- close() -> [void] - Closes the WebSocket connection if it exists",
    "Canonical_solution": "import axios from 'axios';\n\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    try {\n      this.socket = new WebSocket(\n        `${location.protocol === 'https:' ? 'wss' : 'ws'}://${this.url}/api/interface/solve_conflict?id=${this.actionId}`\n      );\n\n      this.socket.onopen = () => {\n        this.WebSocket = this.socket;\n      };\n\n      this.socket.onmessage = (e) => {\n        this.initData = true;\n        const result = JSON.parse(e.data);\n        this.onMessageCallback(result);\n      };\n\n      this.socket.onerror = () => {\n        console.warn('websocket è¿žæŽ¥å¤±è´¥ï¼Œå°†å¯¼è‡´å¤šäººç¼–è¾‘åŒä¸€ä¸ªæŽ¥å£å†²çªã€‚');\n      };\n\n    } catch (e) {\n      console.error('websocket è¿žæŽ¥å¤±è´¥ï¼Œå°†å¯¼è‡´å¤šäººç¼–è¾‘åŒä¸€ä¸ªæŽ¥å£å†²çªã€‚');\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "matched_results": [
      "```javascript\nclass WebSocketClient {\n    constructor(url, actionId, onMessageCallback) {\n        this.url = url;\n        this.actionId = actionId;\n        this.onMessageCallback = onMessageCallback;\n        this.socket = null;\n        this.initData = false;\n    }\n\n    connect() {\n        this.socket = new WebSocket('ws://' + this.url);\n        this.socket.onopen = () => {\n            this.initData = true;\n        };\n        this.socket.onmessage = (event) => {\n            this.onMessageCallback(event.data);\n        };\n        this.socket.onerror = (error) => {\n            console.error('WebSocket error:', error);\n        };\n        this.socket.onclose = () => {\n            this.socket = null;\n        };\n    }\n\n    close() {\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    const ws = new WebSocket(`wss://${this.url}`);\n    this.socket = ws;\n    ws.onopen = () => {\n      this.initData = true;\n    };\n    ws.onmessage = (event) => {\n      this.onMessageCallback(event.data);\n    };\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n    ws.onclose = () => {\n      this.socket = null;\n    };\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(url, actionId, onMessageCallback) {\n        this.url = url;\n        this.actionId = actionId;\n        this.onMessageCallback = onMessageCallback;\n        this.socket = null;\n        this.initData = false;\n    }\n\n    connect() {\n        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n        const wsUrl = `${protocol}://${this.url}`;\n        this.socket = new WebSocket(wsUrl);\n\n        this.socket.onopen = () => {\n            this.initData = true;\n            console.log('WebSocket connection established');\n        };\n\n        this.socket.onmessage = (event) => {\n            this.onMessageCallback(event.data);\n        };\n\n        this.socket.onerror = (error) => {\n            console.error('WebSocket error:', error);\n        };\n\n        this.socket.onclose = () => {\n            console.log('WebSocket connection closed');\n        };\n    }\n\n    close() {\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n    const wsUrl = `${protocol}://${this.url}`;\n    this.socket = new WebSocket(wsUrl);\n\n    this.socket.onopen = () => {\n      this.initData = true;\n    };\n\n    this.socket.onmessage = (event) => {\n      this.onMessageCallback(event.data);\n    };\n\n    this.socket.onerror = (error) => {\n      console.error('WebSocket Error:', error);\n    };\n\n    this.socket.onclose = () => {\n      this.socket = null;\n    };\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(url, actionId, onMessageCallback) {\n        this.url = url;\n        this.actionId = actionId;\n        this.onMessageCallback = onMessageCallback;\n        this.socket = null;\n        this.initData = false;\n    }\n\n    connect() {\n        const ws = new WebSocket(`wss://${this.url}`);\n        this.socket = ws;\n        ws.onopen = () => {\n            console.log('WebSocket connection established');\n        };\n        ws.onmessage = (event) => {\n            this.onMessageCallback(event.data);\n            this.initData = true;\n        };\n        ws.onerror = (error) => {\n            console.error('WebSocket error:', error);\n        };\n        ws.onclose = () => {\n            console.log('WebSocket connection closed');\n        };\n    }\n\n    close() {\n        if (this.socket) {\n            this.socket.close();\n            this.socket = null;\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(url, actionId, onMessageCallback) {\n        this.url = url;\n        this.actionId = actionId;\n        this.onMessageCallback = onMessageCallback;\n        this.socket = null;\n        this.initData = false;\n    }\n\n    connect() {\n        this.socket = new WebSocket(`wss://${this.url}`);\n        this.socket.onopen = () => {\n            console.log('WebSocket connection established');\n        };\n        this.socket.onmessage = (event) => {\n            this.onMessageCallback(event.data);\n            this.initData = true;\n        };\n        this.socket.onerror = (error) => {\n            console.error('WebSocket error:', error);\n        };\n        this.socket.onclose = () => {\n            console.log('WebSocket connection closed');\n        };\n    }\n\n    close() {\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n    constructor(url, actionId, onMessageCallback) {\n        this.url = url;\n        this.actionId = actionId;\n        this.onMessageCallback = onMessageCallback;\n        this.socket = null;\n        this.initData = false;\n    }\n\n    connect() {\n        this.socket = new WebSocket('ws://' + this.url);\n        this.socket.onopen = () => {\n            this.initData = true;\n        };\n        this.socket.onmessage = (event) => {\n            this.onMessageCallback(event.data);\n        };\n        this.socket.onerror = (error) => {\n            console.error('WebSocket Error:', error);\n        };\n        this.socket.onclose = () => {\n            this.socket = null;\n        };\n    }\n\n    close() {\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';\n    const wsUrl = `${protocol}://${window.location.host}/${this.url}`;\n    this.socket = new WebSocket(wsUrl);\n\n    this.socket.onopen = () => {\n      console.log('WebSocket connection established');\n    };\n\n    this.socket.onmessage = (event) => {\n      this.onMessageCallback(event.data);\n      this.initData = true;\n    };\n\n    this.socket.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n\n    this.socket.onclose = () => {\n      console.log('WebSocket connection closed');\n    };\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    const ws = new WebSocket(`wss://${this.url}`);\n    this.socket = ws;\n    ws.onopen = () => {\n      this.initData = true;\n    };\n    ws.onmessage = (event) => {\n      this.onMessageCallback(event.data);\n    };\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n    ws.onclose = () => {\n      this.socket = null;\n    };\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```",
      "```javascript\nclass WebSocketClient {\n  constructor(url, actionId, onMessageCallback) {\n    this.url = url;\n    this.actionId = actionId;\n    this.onMessageCallback = onMessageCallback;\n    this.socket = null;\n    this.initData = false;\n  }\n\n  connect() {\n    this.socket = new WebSocket(`wss://${this.url}`);\n    this.socket.onopen = () => {\n      this.initData = true;\n    };\n    this.socket.onmessage = (event) => {\n      this.onMessageCallback(event.data);\n    };\n    this.socket.onerror = (error) => {\n      console.error('WebSocket Error:', error);\n    };\n    this.socket.onclose = () => {\n      this.socket = null;\n    };\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a function that sets up a WebSocket server using Node.js to handle client connections and message exchanges.\n\nFunction Description: The function initializes a WebSocket server on a specified port, listens for incoming client connections, and handles message events. When a message is received from a client, the server logs the message and sends a predefined response back to the client.\n\nInput: None (The port number is hardcoded as 3000 in the function.)\n\nOutput: None (The function sets up the WebSocket server and event handlers but does not return any value.)",
    "Canonical_solution": "function handleWebSocketConnection() {\n    let WebSocket = require('ws');\n    let wss = new WebSocket.Server({port:3000});\n    wss.on('connection',function(ws) {\n        ws.on('message', function (data) {\n            console.log(data);\n            ws.send('æˆ‘ä¸çˆ±ä½ ');\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Message received');\n  });\n});",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Message received');\n  });\n});",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Message received');\n  });\n});",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Echo: ' + message);\n  });\n});",
      "```javascript\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Message received');\n  });\n});\n```",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Echo: ' + message);\n  });\n});",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Echo: ' + message);\n  });\n});",
      "```javascript\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Message received');\n  });\n});\n```",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Echo: ' + message);\n  });\n});",
      "```javascript\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('Message received');\n  });\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Implement a WebSocket server class for peer-to-peer communication that handles connections, messages, and room management.\n\nClass Description: The SnapdropServer class represents a WebSocket server that facilitates peer-to-peer communication. It manages WebSocket connections, handles incoming messages, and maintains rooms for peer grouping. The server also handles connection headers and keeps connections alive.\n\nAttributes:\n- _wss: [WebSocket.Server] - The WebSocket server instance\n- _rooms: [Object] - A dictionary tracking peers grouped by their IP addresses (rooms)\n\nMethods:\n- constructor(port: number) -> void - Initializes the WebSocket server on the specified port and sets up event handlers\n- _onConnection(peer: Peer) -> void - Handles new WebSocket connections, sets up message handlers, and joins the peer to a room\n- _onHeaders(headers: Array, response: Object) -> void - Processes HTTP headers during WebSocket handshake, setting cookies if needed\n- _onMessage(sender: Peer, message: string) -> void - Handles incoming messages from peers, routing them to appropriate recipients\n- _send(peer: Peer, message: Object) -> void - Sends a message to a specific peer over WebSocket connection\n- _joinRoom(peer: Peer) -> void - Adds a peer to their respective room (Not shown in reference but implied)\n- _leaveRoom(peer: Peer) -> void - Removes a peer from their room (Not shown in reference but implied)\n- _keepAlive(peer: Peer) -> void - Maintains connection with periodic pings (Not shown in reference but implied)",
    "Canonical_solution": "const WebSocket = require('ws');\n\nclass SnapdropServer {\n    constructor(port) {\n        this._wss = new WebSocket.Server({ port: port });\n        this._wss.on('connection', (socket, request) => this._onConnection(new Peer(socket, request)));\n        this._wss.on('headers', (headers, response) => this._onHeaders(headers, response));\n\n        this._rooms = {};\n    }\n\n    _onConnection(peer) {\n        this._joinRoom(peer);\n        peer.socket.on('message', message => this._onMessage(peer, message));\n        peer.socket.on('error', console.error);\n        this._keepAlive(peer);\n\n        this._send(peer, {\n            type: 'display-name',\n            message: {\n                displayName: peer.name.displayName,\n                deviceName: peer.name.deviceName\n            }\n        });\n    }\n\n    _onHeaders(headers, response) {\n        if (response.headers.cookie && response.headers.cookie.indexOf('peerid=') > -1) return;\n        response.peerId = Peer.uuid();\n        headers.push('Set-Cookie: peerid=' + response.peerId + \"; SameSite=Strict; Secure\");\n    }\n\n    _onMessage(sender, message) {\n        try {\n            message = JSON.parse(message);\n        } catch (e) {\n            return;\n        }\n\n        switch (message.type) {\n            case 'disconnect':\n                this._leaveRoom(sender);\n                break;\n            case 'pong':\n                sender.lastBeat = Date.now();\n                break;\n        }\n\n        if (message.to && this._rooms[sender.ip]) {\n            const recipientId = message.to;\n            const recipient = this._rooms[sender.ip][recipientId];\n            delete message.to;\n            message.sender = sender.id;\n            this._send(recipient, message);\n            return;\n        }\n    }\n\n    _send(peer, message) {\n        if (!peer) return;\n        if (this._wss.readyState !== this._wss.OPEN) return;\n        message = JSON.stringify(message);\n        peer.socket.send(message, error => '');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        headers = ws.request_headers()\n        await self._onHeaders(headers, ws.response_headers)\n        peer = Peer(ws.remote_address[0], ws)\n        await self._onMessage(peer, \"connected\")\n        await self._joinRoom(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        data = json.loads(message)\n        await self._send(sender, data)\n\n    async def _send(self, peer, message):\n        await peer.ws.send(json.dumps(message))\n\n    async def _joinRoom(self, peer):\n        self._rooms[peer.ip] = peer\n\n    async def _leaveRoom(self, peer):\n        del self._rooms[peer.ip]\n\n    async def _keepAlive(self, peer):\n        while True:\n            await asyncio.sleep(30)\n            await peer.ws.send(json.dumps({\"type\": \"ping\"}))\n\n    async def run(self):\n        await self._wss\n        await asyncio.Future()  # run forever\n\n# Example usage\n# server = SnapdropServer(8765)\n# asyncio.get_event_loop().run_until_complete(server.run())\n# asyncio.get_event_loop().run_forever()\n```",
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        headers = ws.request_headers()\n        await self._onHeaders(headers, ws.response_headers)\n        peer = Peer(ws.remote_address[0], ws)\n        await self._joinRoom(peer)\n        try:\n            async for message in ws:\n                await self._onMessage(peer, message)\n        finally:\n            await self._leaveRoom(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        data = json.loads(message)\n        room = self._rooms[sender.ip]\n        for peer in room:\n            if peer.ip != sender.ip:\n                await self._send(peer, data)\n\n    async def _send(self, peer, message):\n        await peer.ws.send(json.dumps(message))\n\n    async def _joinRoom(self, peer):\n        if peer.ip not in self._rooms:\n            self._rooms[peer.ip] = [peer]\n        else:\n            self._rooms[peer.ip].append(peer)\n\n    async def _leaveRoom(self, peer):\n        if peer.ip in self._rooms:\n            self._rooms[peer.ip].remove(peer)\n            if not self._rooms[peer.ip]:\n                del self._rooms[peer.ip]\n\nasync def main():\n    server = SnapdropServer(8765)\n    await server._wss\n\nasyncio.run(main())\n```",
      "```python\nimport asyncio\nimport websockets\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        headers = ws.request_headers()\n        await self._onHeaders(headers, ws.response)\n        peer = Peer(ws.remote_address[0], ws)\n        await self._onConnection(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        # Handle incoming messages and route them\n        pass\n\n    async def _send(self, peer, message):\n        await peer.ws.send(message)\n\n    def _joinRoom(self, peer):\n        # Add peer to their respective room\n        pass\n\n    def _leaveRoom(self, peer):\n        # Remove peer from their room\n        pass\n\n    def _keepAlive(self, peer):\n        # Maintain connection with periodic pings\n        pass\n\n    async def run(self):\n        await self._wss\n```",
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        headers = ws.request_headers()\n        await self._onHeaders(headers, ws.response)\n        peer = Peer(\"localhost\", ws)\n        await self._joinRoom(peer)\n        try:\n            async for message in ws:\n                await self._onMessage(peer, message)\n        finally:\n            await self._leaveRoom(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        data = json.loads(message)\n        recipient_ip = data['recipient']\n        recipient = self._rooms.get(recipient_ip)\n        if recipient:\n            await self._send(recipient, data)\n\n    async def _send(self, peer, message):\n        await peer.ws.send(json.dumps(message))\n\n    async def _joinRoom(self, peer):\n        self._rooms[peer.ip] = peer\n\n    async def _leaveRoom(self, peer):\n        del self._rooms[peer.ip]\n```",
      "```python\nimport asyncio\nimport websockets\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        peer = Peer(None, ws)\n        await self._onHeaders(ws.request_headers, ws)\n        peer.ip = ws.remote_address[0]\n        await self._joinRoom(peer)\n        try:\n            async for message in ws:\n                await self._onMessage(peer, message)\n        finally:\n            await self._leaveRoom(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        # Handle incoming messages and route them\n        pass\n\n    async def _send(self, peer, message):\n        await peer.ws.send(message)\n\n    async def _joinRoom(self, peer):\n        # Add peer to their respective room\n        pass\n\n    async def _leaveRoom(self, peer):\n        # Remove peer from their room\n        pass\n\n    async def _keepAlive(self, peer):\n        # Maintain connection with periodic pings\n        pass\n\nasync def main():\n    server = SnapdropServer(8765)\n    await server._wss\n\nasyncio.get_event_loop().run_until_complete(main())\n```",
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        headers = ws.request_headers()\n        await self._onHeaders(headers, ws.response)\n        peer = Peer(ws.remote_address[0], ws)\n        await self._joinRoom(peer)\n        try:\n            async for message in ws:\n                await self._onMessage(peer, message)\n        finally:\n            await self._leaveRoom(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        data = json.loads(message)\n        target_ip = data.get('target_ip')\n        if target_ip:\n            target_peer = self._rooms.get(target_ip)\n            if target_peer:\n                await self._send(target_peer, message)\n        else:\n            # Broadcast to all peers in the same room\n            for peer in self._rooms.values():\n                if peer.ip != sender.ip:\n                    await self._send(peer, message)\n\n    async def _send(self, peer, message):\n        await peer.ws.send(message)\n\n    async def _joinRoom(self, peer):\n        self._rooms[peer.ip] = peer\n\n    async def _leaveRoom(self, peer):\n        del self._rooms[peer.ip]\n\n    async def run(self):\n        await self._wss\n```",
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass SnapdropServer:\n    def __init__(self, port: int) -> None:\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        asyncio.get_event_loop().run_until_complete(self._wss)\n        asyncio.get_event_loop().run_forever()\n\n    async def _onConnection(self, websocket: websockets.WebSocket) -> None:\n        peer = Peer(websocket)\n        await self._onHeaders(websocket.request_headers, websocket)\n        await self._joinRoom(peer)\n\n    async def _onHeaders(self, headers: list, response: object) -> None:\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender: Peer, message: str) -> None:\n        data = json.loads(message)\n        recipient = self._rooms[data['recipient']]\n        await self._send(recipient, data)\n\n    async def _send(self, peer: Peer, message: object) -> None:\n        await peer.websocket.send(json.dumps(message))\n\n    async def _joinRoom(self, peer: Peer) -> None:\n        self._rooms[peer.ip] = peer\n\n    async def _leaveRoom(self, peer: Peer) -> None:\n        del self._rooms[peer.ip]\n\n    async def _keepAlive(self, peer: Peer) -> None:\n        while True:\n            await asyncio.sleep(30)\n            await peer.websocket.send(json.dumps({\"type\": \"ping\"}))\n\nclass Peer:\n    def __init__(self, websocket: websockets.WebSocket) -> None:\n        self.websocket = websocket\n        self.ip = self.websocket.remote_address[0]\n```",
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        headers = ws.request_headers()\n        await self._onHeaders(headers, ws.response_headers)\n        peer = Peer(ws.remote_address[0], ws)\n        await self._joinRoom(peer)\n        try:\n            async for message in ws:\n                await self._onMessage(peer, message)\n        finally:\n            await self._leaveRoom(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        data = json.loads(message)\n        recipient_ip = data.get('recipient')\n        if recipient_ip in self._rooms:\n            recipient = self._rooms[recipient_ip]\n            await self._send(recipient, message)\n        else:\n            await sender.ws.send(json.dumps({'error': 'Recipient not found'}))\n\n    async def _send(self, peer, message):\n        await peer.ws.send(message)\n\n    async def _joinRoom(self, peer):\n        self._rooms[peer.ip] = peer\n\n    async def _leaveRoom(self, peer):\n        del self._rooms[peer.ip]\n\n    async def run(self):\n        await self._wss\n```",
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        headers = ws.request_headers()\n        await self._onHeaders(headers, ws)\n        peer = Peer(ws.remote_address[0], ws)\n        await self._joinRoom(peer)\n        try:\n            async for message in ws:\n                await self._onMessage(peer, message)\n        finally:\n            await self._leaveRoom(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        data = json.loads(message)\n        recipient_ip = data['recipient']\n        if recipient_ip in self._rooms:\n            recipient = self._rooms[recipient_ip]\n            await self._send(recipient, message)\n        else:\n            await sender.ws.send(json.dumps({'error': 'Recipient not found'}))\n\n    async def _send(self, peer, message):\n        await peer.ws.send(message)\n\n    async def _joinRoom(self, peer):\n        self._rooms[peer.ip] = peer\n\n    async def _leaveRoom(self, peer):\n        del self._rooms[peer.ip]\n\n    async def run(self):\n        await self._wss\n```",
      "```python\nimport asyncio\nimport websockets\nimport json\n\nclass Peer:\n    def __init__(self, ip, ws):\n        self.ip = ip\n        self.ws = ws\n\nclass SnapdropServer:\n    def __init__(self, port: int):\n        self._wss = websockets.serve(self._onConnection, \"localhost\", port)\n        self._rooms = {}\n\n    async def _onConnection(self, ws, path):\n        headers = ws.request_headers()\n        await self._onHeaders(headers, ws.response_headers)\n        peer = Peer(ws.remote_address[0], ws)\n        await self._onMessage(peer, \"connected\")\n        await self._joinRoom(peer)\n\n    async def _onHeaders(self, headers, response):\n        # Set cookies if needed\n        pass\n\n    async def _onMessage(self, sender, message):\n        data = json.loads(message)\n        await self._send(sender, data)\n\n    async def _send(self, peer, message):\n        await peer.ws.send(json.dumps(message))\n\n    async def _joinRoom(self, peer):\n        self._rooms[peer.ip] = peer\n\n    async def _leaveRoom(self, peer):\n        del self._rooms[peer.ip]\n\n    async def _keepAlive(self, peer):\n        while True:\n            await asyncio.sleep(30)\n            await self._send(peer, {\"type\": \"ping\"})\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Implement a function to fetch and process subscribed TV channels from a streaming service API, including authentication and data extraction.\n\nFunction Description: This asynchronous function retrieves subscribed TV channel information from a streaming service by:\n1. Scraping initial configuration data from a webpage\n2. Authenticating with the service using extracted credentials\n3. Fetching subscribed channel packages\n4. Processing and deduplicating channel information\n5. Returning formatted channel data\n\nInput: \n- lang: [String] (optional, default='id') - Language code for the returned channel data\n\nOutput: \n- Returns: [Array<Object>] - An array of channel objects containing:\n  - lang: [String] - The language code\n  - site_id: [String] - The channel ID\n  - name: [String] - The channel name\n- Throws: [Error] - If any HTTP request fails or data parsing fails",
    "Canonical_solution": "function async channels({ lang = 'id' }) {\n    const axios = require('axios')\n    const cheerio = require('cheerio')\n    const result = await axios\n      .get('https://cubmu.com/live-tv')\n      .then(response => response.data)\n      .catch(console.error)\n\n    const $ = cheerio.load(result)\n\n    const config = JSON.parse($('#__NEXT_DATA__').text()).runtimeConfig || {}\n\n    const options = {\n      headers: {\n        Origin: 'https://cubmu.com',\n        Referer: 'https://cubmu.com/live-tv'\n      }\n    }\n    await axios\n      .post(\n        `https://servicebuss.transvision.co.id/tvs/login/external?email=${config.email}&password=${config.password}&deviceId=${config.deviceId}&deviceType=${config.deviceType}&deviceModel=${config.deviceModel}&deviceToken=&serial=&platformId=${config.platformId}`,\n        options\n      )\n      .then(response => response.data)\n      .catch(console.error)\n    const subscribedChannels = await axios\n      .post(\n        `https://servicebuss.transvision.co.id/tvs/subscribe_product/list?platformId=${config.platformId}`,\n        options\n      )\n      .then(response => response.data)\n      .catch(console.error)\n\n    const channels = []\n    const included = []\n    if (Array.isArray(subscribedChannels.channelPackageList)) {\n      subscribedChannels.channelPackageList.forEach(pkg => {\n        pkg.channelList.forEach(channel => {\n          if (included.indexOf(channel.id) < 0) {\n            included.push(channel.id)\n            channels.push({\n              lang,\n              site_id: channel.id,\n              name: channel.name\n            })\n          }\n        })\n      })\n    }\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport json\n\nasync def fetch_subscribed_channels(lang='id'):\n    try:\n        # Step 1: Scraping initial configuration data from a webpage\n        response = requests.get('https://example.com/config')\n        response.raise_for_status()\n        soup = BeautifulSoup(response.text, 'html.parser')\n        credentials = soup.find('div', {'id': 'credentials'}).text\n        credentials = json.loads(credentials)\n\n        # Step 2: Authenticating with the service using extracted credentials\n        auth_response = requests.post('https://example.com/auth', data=credentials)\n        auth_response.raise_for_status()\n\n        # Step 3: Fetching subscribed channel packages\n        channels_response = requests.get('https://example.com/channels', headers={'Authorization': auth_response.headers['Authorization']})\n        channels_response.raise_for_status()\n        channels_data = channels_response.json()\n\n        # Step 4: Processing and deduplicating channel information\n        channels = []\n        for channel in channels_data['channels']:\n            if channel['site_id'] not in [ch['site_id'] for ch in channels]:\n                channels.append({\n                    'lang': lang,\n                    'site_id': channel['site_id'],\n                    'name': channel['name']\n                })\n\n        # Step 5: Returning formatted channel data\n        return channels\n\n    except requests.RequestException as e:\n        raise Error(f\"HTTP request failed: {e}\")\n    except json.JSONDecodeError as e:\n        raise Error(f\"Data parsing failed: {e}\")\n```",
      "```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport json\n\nasync def fetch_subscribed_channels(lang='id'):\n    try:\n        # Step 1: Scraping initial configuration data from a webpage\n        response = requests.get('https://example.com/config')\n        response.raise_for_status()\n        soup = BeautifulSoup(response.text, 'html.parser')\n        credentials = soup.find('div', {'id': 'credentials'}).text\n        credentials = json.loads(credentials)\n\n        # Step 2: Authenticating with the service using extracted credentials\n        auth_response = requests.post('https://example.com/auth', data=credentials)\n        auth_response.raise_for_status()\n\n        # Step 3: Fetching subscribed channel packages\n        channels_response = requests.get('https://example.com/channels', headers={'Authorization': auth_response.headers['Authorization']})\n        channels_response.raise_for_status()\n        channels_data = channels_response.json()\n\n        # Step 4: Processing and deduplicating channel information\n        channels = []\n        for channel in channels_data['channels']:\n            if channel['site_id'] not in [ch['site_id'] for ch in channels]:\n                channels.append({\n                    'lang': lang,\n                    'site_id': channel['site_id'],\n                    'name': channel['name']\n                })\n\n        # Step 5: Returning formatted channel data\n        return channels\n\n    except requests.RequestException as e:\n        raise Error(f\"HTTP request failed: {e}\")\n    except json.JSONDecodeError as e:\n        raise Error(f\"Data parsing failed: {e}\")\n```",
      "```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport json\nfrom collections import defaultdict\n\nasync def fetch_subscribed_channels(lang='id'):\n    try:\n        # Step 1: Scraping initial configuration data from a webpage\n        response = requests.get('https://example.com/config')\n        response.raise_for_status()\n        soup = BeautifulSoup(response.text, 'html.parser')\n        credentials = soup.find('div', {'id': 'credentials'}).text\n        credentials = json.loads(credentials)\n\n        # Step 2: Authenticating with the service using extracted credentials\n        auth_response = requests.post('https://example.com/auth', data=credentials)\n        auth_response.raise_for_status()\n\n        # Step 3: Fetching subscribed channel packages\n        channels_response = requests.get('https://example.com/channels', headers={'Authorization': auth_response.headers['Authorization']})\n        channels_response.raise_for_status()\n        channels_data = channels_response.json()\n\n        # Step 4: Processing and deduplicating channel information\n        channel_dict = defaultdict(list)\n        for channel in channels_data['channels']:\n            channel_dict[channel['site_id']].append(channel['name'])\n\n        formatted_channels = [{'lang': lang, 'site_id': site_id, 'name': ', '.join(names)} for site_id, names in channel_dict.items()]\n\n        # Step 5: Returning formatted channel data\n        return formatted_channels\n\n    except requests.RequestException as e:\n        raise Error(f'HTTP request failed: {e}')\n    except json.JSONDecodeError as e:\n        raise Error(f'Data parsing failed: {e}')\n```",
      "```python\nimport asyncio\nimport aiohttp\nfrom bs4 import BeautifulSoup\n\nasync def fetch_channel_data(lang='id'):\n    async with aiohttp.ClientSession() as session:\n        # Step 1: Scraping initial configuration data from a webpage\n        async with session.get('https://example.com/config') as response:\n            config_data = await response.text()\n            soup = BeautifulSoup(config_data, 'html.parser')\n            credentials = soup.find('div', {'id': 'credentials'}).text.split(':')\n            username, password = credentials\n\n        # Step 2: Authenticating with the service using extracted credentials\n        async with session.post('https://example.com/auth', data={'username': username, 'password': password}) as response:\n            if response.status != 200:\n                raise Exception('Authentication failed')\n\n        # Step 3: Fetching subscribed channel packages\n        async with session.get('https://example.com/channels') as response:\n            channel_data = await response.json()\n\n        # Step 4: Processing and deduplicating channel information\n        channels = []\n        for channel in channel_data['channels']:\n            if channel['lang'] == lang:\n                if not any(c['site_id'] == channel['site_id'] for c in channels):\n                    channels.append({\n                        'lang': lang,\n                        'site_id': channel['site_id'],\n                        'name': channel['name']\n                    })\n\n        # Step 5: Returning formatted channel data\n        return channels\n```",
      "```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport json\n\nasync def fetch_subscribed_channels(lang='id'):\n    try:\n        # Step 1: Scraping initial configuration data from a webpage\n        response = requests.get('https://example.com/config')\n        response.raise_for_status()\n        soup = BeautifulSoup(response.text, 'html.parser')\n        credentials = soup.find('div', {'id': 'credentials'}).text\n        credentials = json.loads(credentials)\n\n        # Step 2: Authenticating with the service using extracted credentials\n        auth_response = requests.post('https://example.com/auth', data=credentials)\n        auth_response.raise_for_status()\n\n        # Step 3: Fetching subscribed channel packages\n        channels_response = requests.get('https://example.com/channels', headers={'Authorization': auth_response.headers['Authorization']})\n        channels_response.raise_for_status()\n        channels_data = channels_response.json()\n\n        # Step 4: Processing and deduplicating channel information\n        channels = []\n        seen = set()\n        for channel in channels_data['channels']:\n            channel_id = channel['site_id']\n            if channel_id not in seen:\n                channels.append({\n                    'lang': lang,\n                    'site_id': channel_id,\n                    'name': channel['name']\n                })\n                seen.add(channel_id)\n\n        # Step 5: Returning formatted channel data\n        return channels\n\n    except requests.RequestException as e:\n        raise Error(f\"HTTP request failed: {e}\")\n    except json.JSONDecodeError as e:\n        raise Error(f\"Data parsing failed: {e}\")\n```",
      "```python\nimport asyncio\nimport aiohttp\nfrom bs4 import BeautifulSoup\nimport json\n\nasync def fetch_channel_data(lang='id'):\n    async with aiohttp.ClientSession() as session:\n        # Step 1: Scraping initial configuration data from a webpage\n        async with session.get('https://example.com/config') as response:\n            if response.status != 200:\n                raise Exception('Failed to fetch configuration data')\n            config_data = await response.text()\n            soup = BeautifulSoup(config_data, 'html.parser')\n            credentials = soup.find('div', {'id': 'credentials'}).text\n\n        # Step 2: Authenticating with the service using extracted credentials\n        async with session.post('https://example.com/auth', data={'username': credentials.split(':')[0], 'password': credentials.split(':')[1]}) as response:\n            if response.status != 200:\n                raise Exception('Authentication failed')\n            auth_data = await response.json()\n\n        # Step 3: Fetching subscribed channel packages\n        async with session.get(f'https://example.com/channels?token={auth_data[\"token\"]}') as response:\n            if response.status != 200:\n                raise Exception('Failed to fetch channel packages')\n            channels_data = await response.json()\n\n        # Step 4: Processing and deduplicating channel information\n        channel_set = set()\n        for channel in channels_data['channels']:\n            channel_set.add((channel['site_id'], channel['name']))\n\n        channels = [{'lang': lang, 'site_id': channel[0], 'name': channel[1]} for channel in channel_set]\n\n        # Step 5: Returning formatted channel data\n        return channels\n```",
      "```python\nimport asyncio\nimport aiohttp\nfrom bs4 import BeautifulSoup\n\nasync def fetch_channel_data(lang='id'):\n    async with aiohttp.ClientSession() as session:\n        try:\n            # Step 1: Scraping initial configuration data from a webpage\n            async with session.get('https://example.com/config') as response:\n                config_data = await response.text()\n                soup = BeautifulSoup(config_data, 'html.parser')\n                credentials = soup.find('div', {'id': 'credentials'}).text\n\n            # Step 2: Authenticating with the service using extracted credentials\n            async with session.post('https://example.com/auth', data={'username': credentials.split(':')[0], 'password': credentials.split(':')[1]}) as response:\n                if response.status != 200:\n                    raise Exception('Authentication failed')\n\n            # Step 3: Fetching subscribed channel packages\n            async with session.get('https://example.com/channels') as response:\n                channel_data = await response.json()\n\n            # Step 4: Processing and deduplicating channel information\n            channels = []\n            for channel in channel_data['channels']:\n                if channel['site_id'] not in [ch['site_id'] for ch in channels]:\n                    channels.append({\n                        'lang': lang,\n                        'site_id': channel['site_id'],\n                        'name': channel['name']\n                    })\n\n            # Step 5: Returning formatted channel data\n            return channels\n\n        except Exception as e:\n            raise e\n```",
      "```python\nimport asyncio\nimport aiohttp\nfrom bs4 import BeautifulSoup\n\nasync def fetch_channel_data(lang='id'):\n    async with aiohttp.ClientSession() as session:\n        # Step 1: Scraping initial configuration data from a webpage\n        async with session.get('https://example.com/config') as response:\n            config_data = await response.text()\n            soup = BeautifulSoup(config_data, 'html.parser')\n            credentials = soup.find('div', {'id': 'credentials'}).text.split(':')\n            username, password = credentials\n\n        # Step 2: Authenticating with the service using extracted credentials\n        async with session.post('https://example.com/auth', data={'username': username, 'password': password}) as response:\n            if response.status != 200:\n                raise Exception('Authentication failed')\n\n        # Step 3: Fetching subscribed channel packages\n        async with session.get('https://example.com/channels') as response:\n            channels_data = await response.json()\n\n        # Step 4: Processing and deduplicating channel information\n        channels = []\n        for channel in channels_data:\n            if channel['site_id'] not in [ch['site_id'] for ch in channels]:\n                channels.append({\n                    'lang': lang,\n                    'site_id': channel['site_id'],\n                    'name': channel['name']\n                })\n\n        # Step 5: Returning formatted channel data\n        return channels\n```",
      "```python\nimport asyncio\nimport aiohttp\nfrom bs4 import BeautifulSoup\n\nasync def fetch_channel_data(lang='id'):\n    async with aiohttp.ClientSession() as session:\n        try:\n            # Step 1: Scraping initial configuration data from a webpage\n            async with session.get('https://example.com/config') as response:\n                config_data = await response.text()\n                soup = BeautifulSoup(config_data, 'html.parser')\n                credentials = soup.find('div', {'id': 'credentials'}).text.split(':')\n                username, password = credentials\n\n            # Step 2: Authenticating with the service using extracted credentials\n            async with session.post('https://example.com/auth', data={'username': username, 'password': password}) as response:\n                if response.status != 200:\n                    raise Exception('Authentication failed')\n\n            # Step 3: Fetching subscribed channel packages\n            async with session.get('https://example.com/channels') as response:\n                channels_data = await response.json()\n\n            # Step 4: Processing and deduplicating channel information\n            channels = []\n            for channel in channels_data:\n                if channel['site_id'] not in [ch['site_id'] for ch in channels]:\n                    channels.append({\n                        'lang': lang,\n                        'site_id': channel['site_id'],\n                        'name': channel['name']\n                    })\n\n            # Step 5: Returning formatted channel data\n            return channels\n\n        except Exception as e:\n            raise e\n```",
      "```python\nimport asyncio\nimport aiohttp\nfrom bs4 import BeautifulSoup\n\nasync def fetch_channel_data(lang='id'):\n    async with aiohttp.ClientSession() as session:\n        # Step 1: Scraping initial configuration data from a webpage\n        async with session.get('https://example.com/config') as response:\n            config_data = await response.text()\n            soup = BeautifulSoup(config_data, 'html.parser')\n            credentials = soup.find('div', {'id': 'credentials'}).text.split(':')\n            username, password = credentials\n\n        # Step 2: Authenticating with the service using extracted credentials\n        async with session.post('https://example.com/auth', data={'username': username, 'password': password}) as response:\n            if response.status != 200:\n                raise Exception('Authentication failed')\n\n        # Step 3: Fetching subscribed channel packages\n        async with session.get('https://example.com/channels') as response:\n            channel_data = await response.json()\n\n        # Step 4: Processing and deduplicating channel information\n        channels = []\n        for channel in channel_data['channels']:\n            if channel['lang'] == lang:\n                if not any(c['site_id'] == channel['site_id'] for c in channels):\n                    channels.append({\n                        'lang': lang,\n                        'site_id': channel['site_id'],\n                        'name': channel['name']\n                    })\n\n        # Step 5: Returning formatted channel data\n        return channels\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a WebSocket server in Node.js that handles client connections, tracks connection counts, and provides broadcast functionality to all connected clients.\n\nFunction Description: The function creates and configures a WebSocket server instance. It maintains a count of active connections, logs connection/disconnection events, and provides a broadcast method to send data to all connected clients. The server handles WebSocket connections on the specified port.\n\nInput: \n- port: [Number] - The port number on which the WebSocket server should listen for connections\n\nOutput:\n- Returns: [WebSocket.Server] - An instance of WebSocket server with additional connection tracking and broadcast functionality\n\nAttributes:\n- connectionCount: [Number] - Tracks the number of active WebSocket connections\n\nMethods:\n- broadcast: [Name](data) -> [void] - Sends the provided data to all connected clients that are in OPEN state\n- on: [Name](event, callback) -> [void] - Inherited from WebSocket.Server to handle server events ('connection', 'error', etc.)",
    "Canonical_solution": "function createWebSocketServer(port) {\n    var WebSocket = require('ws');\n    var socketServer = new WebSocket.Server({port: port, perMessageDeflate: false});\n    socketServer.connectionCount = 0;\n    socketServer.on('connection', function(socket, upgradeReq) {\n        socketServer.connectionCount++;\n        console.log(\n            'New WebSocket Connection: ',\n            (upgradeReq || socket.upgradeReq).socket.remoteAddress,\n            (upgradeReq || socket.upgradeReq).headers['user-agent'],\n            '('+socketServer.connectionCount+' total)'\n        );\n        socket.on('close', function(code, message){\n            socketServer.connectionCount--;\n            console.log(\n                'Disconnected WebSocket ('+socketServer.connectionCount+' total)'\n            );\n        });\n    });\n    socketServer.broadcast = function(data) {\n        socketServer.clients.forEach(function each(client) {\n            if (client.readyState === WebSocket.OPEN) {\n                client.send(data);\n            }\n        });\n    };\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected. Total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected. Total connections: ${connectionCount}`);\n  });\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\nfunction broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n}\n\nwss.on('error', function error(err) {\n  console.error('WebSocket server error:', err);\n});\n\nmodule.exports = wss;",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected, total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected, total connections: ${connectionCount}`);\n  });\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\nfunction broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n}\n\nmodule.exports = {\n  broadcast,\n  on: wss.on.bind(wss)\n};",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected. Total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected. Total connections: ${connectionCount}`);\n  });\n\n  ws.on('error', function error(err) {\n    console.error('WebSocket error:', err);\n  });\n});\n\nfunction broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n}\n\nmodule.exports = {\n  broadcast,\n  on: wss.on.bind(wss)\n};",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected, total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected, total connections: ${connectionCount}`);\n  });\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\nfunction broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n}\n\nmodule.exports = {\n  broadcast,\n  on: wss.on.bind(wss)\n};",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected, total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected, total connections: ${connectionCount}`);\n  });\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\nwss.broadcast = function broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n};\n\nmodule.exports = wss;",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected, total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected, total connections: ${connectionCount}`);\n  });\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\nwss.broadcast = function broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n};\n\nmodule.exports = wss;",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected, total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected, total connections: ${connectionCount}`);\n  });\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\nwss.broadcast = function broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n};\n\nwss.on('error', function error(err) {\n  console.error('WebSocket server error:', err);\n});\n\nmodule.exports = wss;",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected, total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected, total connections: ${connectionCount}`);\n  });\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\nfunction broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n}\n\nmodule.exports = {\n  broadcast,\n  on: wss.on.bind(wss)\n};",
      "```javascript\nconst WebSocket = require('ws');\n\nclass CustomWebSocketServer {\n  constructor(port) {\n    this.port = port;\n    this.wss = new WebSocket.Server({ port: this.port });\n    this.connectionCount = 0;\n    this.wss.on('connection', this.handleConnection.bind(this));\n  }\n\n  handleConnection(ws) {\n    this.connectionCount++;\n    console.log(`Client connected. Total connections: ${this.connectionCount}`);\n    ws.on('close', () => {\n      this.connectionCount--;\n      console.log(`Client disconnected. Total connections: ${this.connectionCount}`);\n    });\n    ws.on('error', (error) => {\n      console.error('WebSocket error:', error);\n    });\n  }\n\n  broadcast(data) {\n    this.wss.clients.forEach((client) => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(data);\n      }\n    });\n  }\n\n  on(event, callback) {\n    this.wss.on(event, callback);\n  }\n}\n\nmodule.exports = CustomWebSocketServer;\n```",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: port });\n\nlet connectionCount = 0;\n\nwss.on('connection', function connection(ws) {\n  connectionCount++;\n  console.log(`Client connected, total connections: ${connectionCount}`);\n\n  ws.on('close', function close() {\n    connectionCount--;\n    console.log(`Client disconnected, total connections: ${connectionCount}`);\n  });\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\nwss.broadcast = function broadcast(data) {\n  wss.clients.forEach(function each(client) {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n};\n\nmodule.exports = wss;"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles WebSocket connections, manages events, and provides methods for server lifecycle management.\n\nClass Description: The WebSocketServer class encapsulates the functionality to create and manage a WebSocket server instance. It handles server creation, connection events, and provides cleanup methods. The class uses promises for asynchronous server initialization and UUID generation for client identification.\n\nAttributes:\n- options: [Object] - Configuration options for the WebSocket server, including the port number.\n- wss: [WebSocket.Server|null] - The WebSocket server instance, initialized as null until created.\n\nMethods:\n- createServer(): [Promise<WebSocket.Server>] - Creates and starts the WebSocket server instance. Returns a promise that resolves with the server instance when listening or rejects on error.\n- onConnection(callback: [Function]): [void] - Sets up a connection event handler. The callback receives the WebSocket connection object and a generated UUID for the client.\n- close(): [void] - Closes the WebSocket server instance.",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('eventemitter3');\nvar uuid = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    this.wss = new WebSocket.Server({\n      port: this.options.publicPort,\n      perMessageDeflate: false\n    });\n\n    var listeningListener, errorListener;\n    return new Promise((resolve, reject) => {\n      listeningListener = () => resolve(this.wss);\n      errorListener = (err) => reject(err);\n\n      this.wss.on('listening', listeningListener);\n      this.wss.on('error', errorListener);\n    })\n    .finally(() => {\n      this.wss.removeListener('listening', listeningListener);\n      this.wss.removeListener('error', errorListener);\n    });\n  }\n\n  onConnection(callback) {\n    this.wss.on('connection', (ws) => {\n      var id = uuid.v4();\n      callback(ws, id);\n    });\n  }\n\n  close() {\n    this.wss.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer(this.options);\n      this.wss.on('connection', (ws) => {\n        const clientUUID = uuidv4();\n        this.onConnection(ws, clientUUID);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback) {\n    if (!this.wss) {\n      throw new Error('Server not initialized');\n    }\n    this.wss.on('connection', callback);\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}\n```",
      "const { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer({ port: this.options.port });\n      this.wss.on('connection', (ws, req) => {\n        const clientId = uuidv4();\n        this.onConnection(ws, clientId);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback) {\n    if (this.wss) {\n      this.wss.on('connection', (ws, req) => {\n        const clientId = uuidv4();\n        callback(ws, clientId);\n      });\n    }\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}",
      "const { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer(this.options);\n      this.wss.on('connection', (ws, req) => {\n        const clientUUID = uuidv4();\n        this.onConnection(ws, clientUUID);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback) {\n    if (this.wss) {\n      this.wss.on('connection', (ws, req) => {\n        const clientUUID = uuidv4();\n        callback(ws, clientUUID);\n      });\n    }\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}",
      "const { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer({ port: this.options.port });\n      this.wss.on('connection', (ws) => {\n        const clientUUID = uuidv4();\n        this.onConnection(ws, clientUUID);\n      });\n      this.wss.on('error', reject);\n      this.wss.on('listening', () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback, clientUUID) {\n    callback(this.wss, clientUUID);\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}",
      "```javascript\nconst { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer(this.options);\n      this.wss.on('connection', (ws) => {\n        const clientId = uuidv4();\n        this.onConnection(ws, clientId);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback, clientId) {\n    callback(this.wss, clientId);\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}\n```",
      "```javascript\nconst { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer(this.options);\n      this.wss.on('connection', (ws) => {\n        const clientId = uuidv4();\n        this.onConnection(ws, clientId);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => {\n        resolve(this.wss);\n      });\n    });\n  }\n\n  onConnection(callback, clientId) {\n    callback(this.wss, clientId);\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}\n```",
      "```javascript\nconst { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer(this.options);\n      this.wss.on('connection', (ws, req) => {\n        const clientUUID = uuidv4();\n        this.onConnection(ws, clientUUID);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback) {\n    if (!this.wss) throw new Error('Server not initialized');\n    this.wss.on('connection', callback);\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}\n```",
      "```javascript\nconst { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer(this.options);\n      this.wss.on('connection', (ws) => {\n        const clientUUID = uuidv4();\n        this.onConnection(ws, clientUUID);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback) {\n    if (this.wss) {\n      this.wss.on('connection', (ws, clientUUID) => callback(ws, clientUUID));\n    }\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}\n```",
      "```javascript\nconst { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer(this.options);\n      this.wss.on('connection', (ws) => {\n        const clientId = uuidv4();\n        this.onConnection(ws, clientId);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback) {\n    if (!this.wss) {\n      throw new Error('Server not initialized');\n    }\n    this.wss.on('connection', (ws, clientId) => callback(ws, clientId));\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}\n```",
      "const { WebSocketServer } = require('ws');\nconst { v4: uuidv4 } = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    return new Promise((resolve, reject) => {\n      this.wss = new WebSocketServer(this.options);\n      this.wss.on('connection', (ws) => {\n        const clientUUID = uuidv4();\n        this.onConnection(ws, clientUUID);\n      });\n      this.wss.on('error', reject);\n      this.wss.listen(this.options.port, () => resolve(this.wss));\n    });\n  }\n\n  onConnection(callback, clientUUID) {\n    callback(clientUUID);\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n      this.wss = null;\n    }\n  }\n}"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a WebSocket server using Node.js that facilitates real-time communication between clients and initializes sample data for a collaborative application.\n\nFunction Description: The function `setupWebSocketServer` creates a WebSocket server integrated with ShareDB for real-time data synchronization. It sets up an Express server to serve static files, initializes a WebSocket server, and populates the database with sample player data if empty. The server listens on port 8080.\n\nInput: None\n\nOutput: None (The function sets up a server and initializes data but does not return any value)",
    "Canonical_solution": "function setupWebSocketServer() {\n    var http = require('http');\n    var ShareDB = require('sharedb');\n    var express = require('express');\n    var ShareDBMingoMemory = require('sharedb-mingo-memory');\n    var WebSocketJSONStream = require('@teamwork/websocket-json-stream');\n    var WebSocket = require('ws');\n\n    var share = new ShareDB({db: new ShareDBMingoMemory()});\n\n    var app = express();\n    app.use(express.static('static'));\n    var server = http.createServer(app);\n    var wss = new WebSocket.Server({server: server});\n    server.listen(8080);\n    console.log('Listening on http://localhost:8080');\n\n    wss.on('connection', function(ws) {\n        var stream = new WebSocketJSONStream(ws);\n        share.listen(stream);\n    });\n\n    var connection = share.connect();\n    connection.createFetchQuery('players', {}, {}, function(err, results) {\n        if (err) {\n            throw err;\n        }\n\n        if (results.length === 0) {\n            var names = ['Ada Lovelace', 'Grace Hopper', 'Marie Curie',\n                'Carl Friedrich Gauss', 'Nikola Tesla', 'Claude Shannon'];\n\n            names.forEach(function(name, index) {\n                var doc = connection.get('players', ''+index);\n                var data = {name: name, score: Math.floor(Math.random() * 10) * 5};\n                doc.create(data);\n            });\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst {æŸ¯å°”ç‰¹} = require('sharedb-mongo');\nconst {æŸ¯å°”ç‰¹Client} = require('sharedb-express');\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\nconst db = new ShareDB({ backend: æŸ¯å°”ç‰¹, backendOptions: { url: 'mongodb://localhost:27017/collaborative_app' } });\nconstæŸ¯å°”ç‰¹ClientMiddleware = æŸ¯å°”ç‰¹Client({ db });\n\napp.use(express.static('public'));\napp.use('/socket.io',æŸ¯å°”ç‰¹ClientMiddleware);\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\ndb.get('players', 'players', function(err, doc) {\n  if (err) throw err;\n  if (!doc) {\n    doc = { players: [] };\n    doc.create(function(err) {\n      if (err) throw err;\n      doc.players.push({ name: 'Player 1', score: 0 });\n      doc.players.push({ name: 'Player 2', score: 0 });\n      doc.players.push({ name: 'Player 3', score: 0 });\n      doc.save();\n    });\n  }\n});\n\nserver.listen(8080, function listening() {\n  const addr = server.address();\n  console.log('Listening on %s', addr.port);\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst {æŸ¯å°”ç‰¹} = require('sharedb-mongo');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\nconst shareDB = new ShareDB();\nconstæŸ¯å°”ç‰¹Client = newæŸ¯å°”ç‰¹({ uri: 'mongodb://localhost:27017/collaborative_app' });\nshareDB.adapters.register('mongodb',æŸ¯å°”ç‰¹Client);\n\nconst db = shareDB.getDb('collaborative_app');\n\nfunction setupWebSocketServer() {\n  app.use(express.static('public'));\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      console.log('received: %s', message);\n    });\n  });\n\n  server.listen(8080, function listening() {\n    console.log('Listening on %d', server.address().port);\n  });\n\n  const playersCollection = db.collection('players');\n  playersCollection.find({}).toArray((err, players) => {\n    if (err) throw err;\n    if (players.length === 0) {\n      playersCollection.insertOne({ name: 'Player 1', score: 0 });\n      playersCollection.insertOne({ name: 'Player 2', score: 0 });\n    }\n  });\n}\n\nsetupWebSocketServer();\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst { Server } = require('socket.io');\nconst path = require('path');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\nconst shareDB = new ShareDB();\nconst socketIo = new Server(server);\n\napp.use(express.static(path.join(__dirname, 'public')));\n\nconst db = shareDB.createClient();\ndb.on('error', console.error);\n\nconst setupWebSocketServer = () => {\n  wss.on('connection', (ws) => {\n    const socket = socketIo.sockets.add(ws);\n    socket.on('message', (message) => {\n      // Handle incoming messages\n    });\n  });\n\n  socketIo.on('connection', (socket) => {\n    const doc = db.get('db', 'players');\n    doc.fetch((err, op) => {\n      if (err) return console.error(err);\n      if (op) {\n        // Update the document with the latest operations\n        doc.applyOps(op);\n      } else {\n        // Initialize the document with sample data\n        doc.create([{ type: 'array', op: { i: 0, o: [{ id: 'player1', name: 'Player 1' }] }]}, (err) => {\n          if (err) return console.error(err);\n        });\n      }\n    });\n  });\n\n  server.listen(8080, () => {\n    console.log('Server is running on http://localhost:8080');\n  });\n};\n\nsetupWebSocketServer();\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst {æŸ¯å°”ç‰¹} = require('sharedb-mongo');\nconst {æŸ¯å°”ç‰¹Client} = require('sharedb-express');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\nconst db = new ShareDB({ backend: new æŸ¯å°”ç‰¹({ url: 'mongodb://localhost:27017/collaborative_app' }) });\nconstæŸ¯å°”ç‰¹ClientMiddleware = æŸ¯å°”ç‰¹Client({ db });\n\napp.use(express.static('public'));\napp.use('/socket.io',æŸ¯å°”ç‰¹ClientMiddleware);\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\ndb.get('players', 'players', function(err, doc) {\n  if (err) throw err;\n  if (!doc) {\n    doc = { data: [{ name: 'Player 1', score: 0 }, { name: 'Player 2', score: 0 }] };\n    db.get('players', 'players', function(err, doc) {\n      if (err) throw err;\n      doc.create(doc.id, doc.data, function(err) {\n        if (err) throw err;\n      });\n    });\n  }\n});\n\nserver.listen(8080);\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst {æŸ¯å°”ç‰¹} = require('sharedb-mongo');\nconst {æŸ¯å°”ç‰¹Client} = require('sharedb-express');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\nconst db = new ShareDB({ backend: æŸ¯å°”ç‰¹, backendOptions: { url: 'mongodb://localhost:27017/collaborative_app' } });\n\napp.use(express.static('public'));\n\nwss.on('connection', function connection(ws) {\n  const client = new æŸ¯å°”ç‰¹Client(ws, { db });\n  client.on('error', console.error);\n});\n\ndb.get('players', 'players', (error, doc) => {\n  if (error) throw error;\n  if (doc) return;\n  doc.create({ name: 'Player 1', score: 0 });\n  doc.create({ name: 'Player 2', score: 0 });\n  doc.create({ name: 'Player 3', score: 0 });\n});\n\nserver.listen(8080);\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst {æŸ¯å°”ç‰¹} = require('sharedb-mongo');\nconst {æŸ¯å°”ç‰¹Client} = require('sharedb-express');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\nconst db = new ShareDB({ backend: æŸ¯å°”ç‰¹, backendOptions: { url: 'mongodb://localhost:27017/collaborative_app' } });\nconstæŸ¯å°”ç‰¹ClientMiddleware = æŸ¯å°”ç‰¹Client({ db });\n\napp.use(express.static('public'));\napp.use('/socket.io',æŸ¯å°”ç‰¹ClientMiddleware);\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\ndb.get('players', 'players', function(err, doc) {\n  if (err) throw err;\n  if (!doc) {\n    doc = { data: [] };\n    doc.create(function(err, doc) {\n      if (err) throw err;\n      doc.data.push({ name: 'Player 1', score: 0 });\n      doc.data.push({ name: 'Player 2', score: 0 });\n      doc.save();\n    });\n  }\n});\n\nserver.listen(8080, function listening() {\n  const addr = server.address();\n  console.log('Listening on %s:%s', addr.address, addr.port);\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst { Server as ShareDBServer } = require('sharedb-mongo');\nconst { json } = require('body-parser');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\nconst shareDBServer = new ShareDBServer();\nconst shareDB = new ShareDB({ server: shareDBServer });\n\napp.use(express.static('public'));\napp.use(json());\n\nconst setupWebSocketServer = () => {\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      console.log('received: %s', message);\n    });\n  });\n\n  shareDBServer.listen(27017, () => {\n    const db = shareDB.getDb();\n    db.collection('players').find({}).toArray((err, players) => {\n      if (err) throw err;\n      if (players.length === 0) {\n        const samplePlayers = [\n          { name: 'Player 1', score: 0 },\n          { name: 'Player 2', score: 0 },\n          { name: 'Player 3', score: 0 }\n        ];\n        db.collection('players').insertMany(samplePlayers, (err, result) => {\n          if (err) throw err;\n          console.log('Sample players added to the database');\n        });\n      }\n    });\n  });\n\n  server.listen(8080, () => {\n    console.log('Server is running on http://localhost:8080');\n  });\n};\n\nsetupWebSocketServer();\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst {æŸ¯å°”ç‰¹} = require('sharedb-mongo');\nconst {æŸ¯å°”ç‰¹Client} = require('sharedb-express');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\nconst db = new ShareDB({ backend: æŸ¯å°”ç‰¹, backendOptions: { url: 'mongodb://localhost:27017/collaborative_app' } });\nconstæŸ¯å°”ç‰¹ClientMiddleware = æŸ¯å°”ç‰¹Client({ db });\n\napp.use(express.static('public'));\napp.use('/socket.io',æŸ¯å°”ç‰¹ClientMiddleware);\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\ndb.get('players', 'players', function(err, doc) {\n  if (err) throw err;\n  if (!doc) {\n    doc = { data: [] };\n    doc.create(function(err) {\n      if (err) throw err;\n      doc.data.push({ name: 'Player 1', score: 0 });\n      doc.data.push({ name: 'Player 2', score: 0 });\n      doc.save();\n    });\n  }\n});\n\nserver.listen(8080, function listening() {\n  const addr = server.address();\n  console.log('Listening on %s:%s', addr.address, addr.port);\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst {æŸ¯å°”ç‰¹} = require('sharedb-mongo');\nconst {æŸ¯å°”ç‰¹Client} = require('sharedb-express');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\nconst db = new ShareDB({ backend: æŸ¯å°”ç‰¹, backendOptions: { url: 'mongodb://localhost:27017/collaborative_app' } });\nconstæŸ¯å°”ç‰¹ClientMiddleware = æŸ¯å°”ç‰¹Client({ db });\n\napp.use(express.static('public'));\napp.use('/socket.io',æŸ¯å°”ç‰¹ClientMiddleware);\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n});\n\ndb.get('players', 'players', function(err, doc) {\n  if (err) throw err;\n  if (!doc) {\n    doc = { data: [] };\n    doc.create(function(err, doc) {\n      if (err) throw err;\n      doc.data.push({ name: 'Player 1', score: 0 });\n      doc.data.push({ name: 'Player 2', score: 0 });\n      doc.save();\n    });\n  }\n});\n\nserver.listen(8080, function listening() {\n  const addr = server.address();\n  console.log('Listening on %s:%s', addr.address, addr.port);\n});\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ShareDB } = require('sharedb');\nconst {æŸ¯å°”ç‰¹} = require('sharedb-mongo');\nconst {æŸ¯å°”ç‰¹Client} = require('sharedb-express');\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\nconst db = new ShareDB({ backend: new æŸ¯å°”ç‰¹({ url: 'mongodb://localhost:27017/collaborative_app' }) });\napp.use(express.static('public'));\napp.use('/socket.io-client', express.static('node_modules/socket.io-client'));\napp.use('/sharedb', æŸ¯å°”ç‰¹Client({ db }));\nconst playersCollection = db.get('players');\nplayersCollection.createIfMissing();\nplayersCollection.fetch(null, (err, players) => {\n  if (err) throw err;\n  if (players.length === 0) {\n    playersCollection.insert(null, { name: 'Player 1' }, (err, op) => {\n      if (err) throw err;\n    });\n    playersCollection.insert(null, { name: 'Player 2' }, (err, op) => {\n      if (err) throw err;\n    });\n  }\n});\nserver.listen(8080);\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 263,
    "Instruction": "Task Description: Implement a WebSocket server class in Node.js that can handle client connections, messages, errors, and disconnections.\n\nClass Description: The WebSocketServer class creates and manages a WebSocket server instance, setting up event handlers for various WebSocket events. It provides methods to handle incoming messages, connection closures, and errors.\n\nAttributes:\n- wss: [WebSocket.Server] - The WebSocket server instance created with the specified port.\n\nMethods:\n- constructor(port: number) -> void - Initializes the WebSocket server on the specified port and sets up event handlers.\n- setupEventHandlers() -> void - Configures event listeners for connection, message, close, and error events.\n- handleMessage(ws: WebSocket, message: string) -> void - Placeholder for message handling logic (to be implemented by the user).\n- handleClose(ws: WebSocket, code: number, reason: string) -> void - Placeholder for connection close handling logic (to be implemented by the user).\n- handleError(ws: WebSocket, error: Error) -> void - Placeholder for error handling logic (to be implemented by the user).",
    "Canonical_solution": "const WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port: port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Message handling logic would be implemented here\n  }\n\n  handleClose(ws, code, reason) {\n    // Connection close handling logic would be implemented here\n  }\n\n  handleError(ws, error) {\n    // Error handling logic would be implemented here\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass WebSocketServer {\n  constructor(port) {\n    this.wss = new WebSocket.Server({ port });\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (ws) => {\n      ws.on('message', (message) => {\n        this.handleMessage(ws, message);\n      });\n      ws.on('close', (code, reason) => {\n        this.handleClose(ws, code, reason);\n      });\n      ws.on('error', (error) => {\n        this.handleError(ws, error);\n      });\n    });\n  }\n\n  handleMessage(ws, message) {\n    // Placeholder for message handling logic\n  }\n\n  handleClose(ws, code, reason) {\n    // Placeholder for connection close handling logic\n  }\n\n  handleError(ws, error) {\n    // Placeholder for error handling logic\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 264,
    "Instruction": "Task Description: Create a WebSocket server that handles client connections, messages, and errors, while managing an isolated inspector session for each connection.\n\nFunction Description: The function `createWebSocketServer` initializes a WebSocket server on a specified port. For each client connection, it creates an isolated inspector session, sets up event handlers for messages, errors, and connection closure, and manages protocol message dispatching between the client and the inspector session.\n\nInput:  \n- `port` (Number): The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:  \n- None (The function does not return a value but sets up a WebSocket server with the specified configuration and event handlers.)",
    "Canonical_solution": "let WebSocket = require('ws');\n\nfunction createWebSocketServer(port) {\n    let wss = new WebSocket.Server({ port: port });\n\n    wss.on('connection', function(ws) {\n        let channel = isolate.createInspectorSession();\n        function dispose() {\n            try {\n                channel.dispose();\n            } catch (err) {}\n        }\n        ws.on('error', dispose);\n        ws.on('close', dispose);\n\n        ws.on('message', function(message) {\n            console.log('<', message.toString())\n            try {\n                channel.dispatchProtocolMessage(String(message));\n            } catch (err) {\n                ws.close();\n            }\n        });\n\n        function send(message) {\n            console.log('>', message.toString())\n            try {\n                ws.send(message);\n            } catch (err) {\n                dispose();\n            }\n        }\n        channel.onResponse = (callId, message) => send(message);\n        channel.onNotification = send;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "```javascript\nconst WebSocket = require('ws');\nconst { createInspectorSession } = require('./inspectorSession');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    const session = createInspectorSession();\n    ws.on('message', function incoming(message) {\n      session.dispatchMessage(message);\n    });\n    ws.on('error', function error(err) {\n      session.handleError(err);\n    });\n    ws.on('close', function close() {\n      session.close();\n    });\n  });\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst { createInspectorSession } = require('./inspectorSession');\n\nconst createWebSocketServer = (port) => {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', (ws) => {\n    const session = createInspectorSession();\n    ws.on('message', (message) => {\n      session.dispatchMessage(message);\n    });\n    ws.on('error', (error) => {\n      session.handleError(error);\n    });\n    ws.on('close', () => {\n      session.close();\n    });\n  });\n};\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst http = require('http');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    const inspectorSession = createInspectorSession();\n    ws.on('message', function incoming(message) {\n      inspectorSession.dispatchMessage(message);\n    });\n    ws.on('error', function error(err) {\n      inspectorSession.handleError(err);\n    });\n    ws.on('close', function close() {\n      inspectorSession.close();\n    });\n  });\n\n  function createInspectorSession() {\n    let closed = false;\n    const messages = [];\n\n    function dispatchMessage(message) {\n      if (closed) return;\n      messages.push(message);\n      // Handle message\n    }\n\n    function handleError(err) {\n      if (closed) return;\n      // Handle error\n    }\n\n    function close() {\n      closed = true;\n      // Clean up session\n    }\n\n    return {\n      dispatchMessage,\n      handleError,\n      close\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst http = require('http');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    const inspectorSession = createInspectorSession();\n    ws.on('message', function incoming(message) {\n      inspectorSession.dispatchMessage(message);\n    });\n    ws.on('error', function error(err) {\n      inspectorSession.handleError(err);\n    });\n    ws.on('close', function close() {\n      inspectorSession.close();\n    });\n  });\n\n  function createInspectorSession() {\n    let closed = false;\n    const messages = [];\n    const handlers = {};\n\n    function handleMessage(message) {\n      // Handle message logic here\n    }\n\n    function handleOpen() {\n      // Handle open logic here\n    }\n\n    function handleClose() {\n      closed = true;\n      // Handle close logic here\n    }\n\n    function handleError(err) {\n      // Handle error logic here\n    }\n\n    function dispatchMessage(message) {\n      if (!closed) {\n        messages.push(message);\n        handleMessage(message);\n      }\n    }\n\n    function close() {\n      handleClose();\n      // Clean up resources here\n    }\n\n    return {\n      handleMessage,\n      handleOpen,\n      handleClose,\n      handleError,\n      dispatchMessage,\n      close\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    const inspectorSession = createInspectorSession();\n    ws.on('message', function incoming(message) {\n      inspectorSession.dispatchMessage(message);\n    });\n    ws.on('error', function error(err) {\n      inspectorSession.handleError(err);\n    });\n    ws.on('close', function close() {\n      inspectorSession.close();\n    });\n  });\n\n  function createInspectorSession() {\n    let closed = false;\n    const messages = [];\n\n    function dispatchMessage(message) {\n      if (closed) return;\n      messages.push(message);\n      // Handle message\n    }\n\n    function handleError(err) {\n      if (closed) return;\n      // Handle error\n    }\n\n    function close() {\n      closed = true;\n      // Clean up\n    }\n\n    return {\n      dispatchMessage,\n      handleError,\n      close\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    const inspectorSession = {\n      messages: [],\n      sendMessage: (message) => {\n        ws.send(message);\n      },\n      close: () => {\n        ws.close();\n      }\n    };\n\n    ws.on('message', function incoming(message) {\n      inspectorSession.messages.push(message);\n      // Handle protocol message dispatching here\n    });\n\n    ws.on('error', function error(err) {\n      console.error('WebSocket error:', err);\n      inspectorSession.close();\n    });\n\n    ws.on('close', function close() {\n      console.log('WebSocket connection closed');\n    });\n  });\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst http = require('http');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    const inspectorSession = createInspectorSession();\n    ws.on('message', function incoming(message) {\n      inspectorSession.dispatchMessage(message);\n    });\n    ws.on('error', function error(err) {\n      inspectorSession.handleError(err);\n    });\n    ws.on('close', function close() {\n      inspectorSession.close();\n    });\n  });\n\n  function createInspectorSession() {\n    let closed = false;\n    const messages = [];\n    const send = (data) => {\n      if (!closed) {\n        ws.send(data);\n      }\n    };\n\n    return {\n      dispatchMessage: (message) => {\n        messages.push(message);\n        // Handle the message as needed\n      },\n      handleError: (err) => {\n        // Handle the error as needed\n      },\n      close: () => {\n        closed = true;\n        // Clean up resources if necessary\n      },\n      send: send\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst { createInspectorSession } = require('./inspectorSession');\n\nconst createWebSocketServer = (port) => {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', (ws) => {\n    const session = createInspectorSession();\n    ws.on('message', (message) => {\n      session.dispatch(message);\n    });\n    ws.on('error', (error) => {\n      session.handleError(error);\n    });\n    ws.on('close', () => {\n      session.close();\n    });\n  });\n};\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst { createInspectorSession } = require('./inspectorSession');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    const session = createInspectorSession();\n    ws.on('message', function incoming(message) {\n      session.dispatch(message);\n    });\n    ws.on('error', function error(err) {\n      session.handleError(err);\n    });\n    ws.on('close', function close() {\n      session.close();\n    });\n  });\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst http = require('http');\n\nfunction createWebSocketServer(port) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    const inspectorSession = createInspectorSession();\n    ws.on('message', function incoming(message) {\n      inspectorSession.dispatchMessage(message);\n    });\n    ws.on('error', function error(err) {\n      inspectorSession.handleError(err);\n    });\n    ws.on('close', function close() {\n      inspectorSession.close();\n    });\n  });\n\n  function createInspectorSession() {\n    let closed = false;\n    const session = {\n      messages: [],\n      dispatchMessage: function(message) {\n        if (!closed) {\n          this.messages.push(message);\n          // Handle message\n        }\n      },\n      handleError: function(err) {\n        if (!closed) {\n          // Handle error\n        }\n      },\n      close: function() {\n        closed = true;\n        // Clean up session\n      }\n    };\n    return session;\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles incoming connections, manages sessions, and processes messages with customizable handlers.\n\nClass Description: The XVIZServer class is a WebSocket server implementation that manages WebSocket connections, delegates session handling to provided handlers, and provides logging capabilities. It wraps the 'ws' library functionality with additional session management features.\n\nAttributes:\n- _server: [WebSocket.Server] - The underlying WebSocket server instance\n- handlers: [Array] - Array of handler objects responsible for managing sessions\n- options: [Object] - Configuration options for the server, merged with defaults\n\nMethods:\n- constructor(handlers, options, callback) -> [XVIZServer] - Initializes the WebSocket server with message handlers, options, and an optional callback. Throws an error if no handlers are provided.\n- get server() -> [WebSocket.Server] - Getter for the underlying WebSocket server instance\n- close(cb) -> [void] - Closes the WebSocket server, accepting an optional callback\n- handleSession(socket, request) -> [Promise<void>] - Handles new WebSocket connections, delegates to handlers for session creation, and closes the connection if no handler accepts it\n- log(...msg) -> [void] - Logs messages using the configured logger if available",
    "Canonical_solution": "const WebSocket = require('ws');\n\nexport class XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers) {\n      throw new Error('Must specify a handler for messages');\n    }\n\n    this.handlers = handlers;\n    this.options = Object.assign(DEFAULT_OPTIONS, options);\n    this._server = new WebSocket.Server(this.options, callback);\n\n    this.server.on('connection', (socket, request) => this.handleSession(socket, request));\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    this.log(`[> Connection] created: ${request.url}`);\n    const req = getRequestData(request.url);\n\n    for (const handler of this.handlers) {\n      const session = await handler.newSession(socket, req);\n      if (session) {\n        session.onConnect();\n        return;\n      }\n    }\n\n    socket.close();\n    this.log('[> Connection] closed due to no handler found');\n  }\n\n  log(...msg) {\n    const {logger} = this.options;\n    if (logger && logger.log) {\n      logger.log(...msg);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers array cannot be empty');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    this._server.on('connection', (socket, request) => {\n      this.handleSession(socket, request).catch((error) => {\n        this.log('Error handling session:', error);\n        socket.close();\n      });\n    });\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.accept(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  static get defaultOptions() {\n    return {\n      port: 8080,\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers array cannot be empty');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.handleSession(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  get defaultOptions() {\n    return {\n      port: 8080,\n      host: 'localhost',\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers must be provided');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    if (callback) callback(this);\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.handleSession(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  get defaultOptions() {\n    return {\n      port: 8080,\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers must be provided');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    if (callback) callback();\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.handleSession(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  static get defaultOptions() {\n    return {\n      port: 8080,\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers array cannot be empty');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    this._server.on('connection', (socket, request) => {\n      this.handleSession(socket, request).catch((error) => {\n        console.error('Error handling session:', error);\n        socket.close();\n      });\n    });\n    if (callback) callback(this);\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.accept(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  static get defaultOptions() {\n    return {\n      port: 8080,\n      host: 'localhost',\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers array must not be empty');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.handleSession(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  static get defaultOptions() {\n    return {\n      port: 8080,\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers must be provided');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    this._server.on('connection', this.handleSession.bind(this));\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.accept(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  get defaultOptions() {\n    return {\n      port: 8080,\n      host: 'localhost',\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers must be provided');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    if (callback) callback(this);\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this.server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.handleSession(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  get defaultOptions() {\n    return {\n      port: 8080,\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers array cannot be empty');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.defaultOptions, ...options };\n    this._server.on('connection', this.handleSession.bind(this));\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.handleSession(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  get defaultOptions() {\n    return {\n      port: 8080,\n      logger: console.log\n    };\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nclass XVIZServer {\n  constructor(handlers, options, callback) {\n    if (!handlers || handlers.length === 0) {\n      throw new Error('Handlers array cannot be empty');\n    }\n    this._server = new WebSocket.Server(options);\n    this.handlers = handlers;\n    this.options = { ...this.getDefaultOptions(), ...options };\n    this._server.on('connection', (socket, request) => {\n      this.handleSession(socket, request).catch((error) => {\n        console.error('Error handling session:', error);\n        socket.close();\n      });\n    });\n    if (typeof callback === 'function') {\n      callback(this);\n    }\n  }\n\n  get server() {\n    return this._server;\n  }\n\n  close(cb) {\n    this._server.close(cb);\n  }\n\n  async handleSession(socket, request) {\n    for (const handler of this.handlers) {\n      if (await handler.accept(socket, request)) {\n        return;\n      }\n    }\n    socket.close();\n  }\n\n  log(...msg) {\n    if (this.options.logger) {\n      this.options.logger(...msg);\n    }\n  }\n\n  getDefaultOptions() {\n    return {\n      port: 8080,\n      host: 'localhost',\n      logger: console.log\n    };\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Create a WebSocket server class that manages WebSocket connections for a webview application, handling connection events and maintaining active connections.\n\nClass Description: The WebviewServer class is responsible for setting up and managing a WebSocket server that facilitates real-time communication between a webview application and a data source. It maintains active connections and provides server information.\n\nAttributes:\n- server: [http.Server] - The underlying HTTP server instance used for WebSocket communication\n- secret: [string] - A secret string used for authentication or security purposes\n- connections: [Set<WebviewConnection>] - A collection of active WebSocket connections\n- config: [Config] - Configuration object containing server settings\n\nMethods:\n- constructor(dataSource: [VisualizationWatchModel], config: [Config]) -> [void] - Initializes the WebSocket server, sets up connection handlers, and stores the configuration\n- get port() -> [number] - Returns the port number on which the server is listening for connections",
    "Canonical_solution": "import { WebSocketStream } from \"@hediet/typed-json-rpc-websocket\";\nimport WebSocket = require(\"ws\");\nimport * as express from \"express\";\nimport * as http from \"http\";\n\nexport class WebviewServer {\n\tprivate readonly server: http.Server;\n\tpublic readonly secret: string;\n\n\tpublic readonly connections = new Set<WebviewConnection>();\n\n\tconstructor(\n\t\tdataSource: VisualizationWatchModel,\n\t\tprivate readonly config: Config\n\t) {\n\t\tconst app = express();\n\t\tthis.server = app.listen();\n\n\t\tconst wss = new WebSocket.Server({ server: this.server });\n\t\twss.on(\"connection\", async ws => {\n\t\t\tconst stream = new WebSocketStream(ws);\n\t\t\tconst c = new WebviewConnection(\n\t\t\t\tdataSource,\n\t\t\t\tstream,\n\t\t\t\tthis,\n\t\t\t\tconfig,\n\t\t\t\tthis.secret\n\t\t\t);\n\t\t\tthis.connections.add(c);\n\t\t\tawait stream.onClosed;\n\t\t\tthis.connections.delete(c);\n\t\t});\n\t}\n\n\tpublic get port(): number {\n\t\tconst httpPort = (this.server.address() as AddressInfo).port;\n\t\treturn httpPort;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "matched_results": [],
    "unmatched_results": [
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebviewConnection>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(req.headers['sec-websocket-key'], this.secret)) {\n        const connection = new WebviewConnection(ws);\n        this.connections.add(connection);\n        connection.on('message', (message) => {\n          // Handle incoming messages\n        });\n        connection.on('close', () => {\n          this.connections.delete(connection);\n        });\n        connection.on('error', (error) => {\n          // Handle errors\n        });\n      }\n    });\n\n    const wss = new WebSocketServer({ server: this.server });\n    wss.on('connection', (ws) => {\n      // Additional connection handling if needed\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  authenticate(key: string, secret: string): boolean {\n    // Implement authentication logic\n    return true;\n  }\n}\n\nclass WebviewConnection {\n  ws: WebSocket;\n\n  constructor(ws: WebSocket) {\n    this.ws = ws;\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    this.ws.on(event, listener);\n  }\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebviewConnection>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws) => {\n      if (this.authenticate(ws)) {\n        this.connections.add(new WebviewConnection(ws, dataSource));\n      } else {\n        ws.terminate();\n      }\n    });\n\n    this.server.listen(config.port, () => {\n      console.log(`WebSocket server is running on port ${config.port}`);\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  authenticate(ws: WebSocket): boolean {\n    // Implement authentication logic here\n    return true;\n  }\n}\n\nclass WebviewConnection {\n  ws: WebSocket;\n  dataSource: VisualizationWatchModel;\n\n  constructor(ws: WebSocket, dataSource: VisualizationWatchModel) {\n    this.ws = ws;\n    this.dataSource = dataSource;\n  }\n\n  // Additional methods for handling connection events and data exchange\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebSocketServer>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(ws, req)) {\n        this.connections.add(ws);\n        ws.on('close', () => {\n          this.connections.delete(ws);\n        });\n        ws.on('message', (message) => {\n          this.handleMessage(ws, message);\n        });\n      } else {\n        ws.close(1008, 'Authentication failed');\n      }\n    });\n\n    this.server.listen(config.port, () => {\n      console.log(`WebSocket server is listening on port ${config.port}`);\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  authenticate(ws: WebSocketServer, req: any): boolean {\n    // Implement authentication logic here\n    return true;\n  }\n\n  handleMessage(ws: WebSocketServer, message: any): void {\n    // Implement message handling logic here\n  }\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebviewConnection>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(req.headers['sec-websocket-key'], this.secret)) {\n        const connection = new WebviewConnection(ws, dataSource);\n        this.connections.add(connection);\n        connection.on('close', () => this.connections.delete(connection));\n        connection.on('message', (message) => this.handleMessage(connection, message));\n      } else {\n        ws.close(1008, 'Authentication error');\n      }\n    });\n\n    this.server.listen(config.port, () => {\n      console.log(`WebSocket server is listening on port ${config.port}`);\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  private authenticate(key: string, secret: string): boolean {\n    // Implement authentication logic here\n    return true;\n  }\n\n  private handleMessage(connection: WebviewConnection, message: string): void {\n    // Implement message handling logic here\n  }\n}\n\nclass WebviewConnection {\n  ws: WebSocket;\n  dataSource: VisualizationWatchModel;\n\n  constructor(ws: WebSocket, dataSource: VisualizationWatchModel) {\n    this.ws = ws;\n    this.dataSource = dataSource;\n  }\n\n  on(event: 'close' | 'message', listener: (message: string) => void): void {\n    this.ws.on(event, listener);\n  }\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebviewConnection>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(ws, req)) {\n        this.connections.add(new WebviewConnection(ws));\n      }\n    });\n\n    this.server.listen(config.port, () => {\n      console.log(`WebSocket server is listening on port ${config.port}`);\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  private authenticate(ws: WebSocket, req: any): boolean {\n    // Implement authentication logic here\n    return true;\n  }\n}\n\nclass WebviewConnection {\n  ws: WebSocket;\n\n  constructor(ws: WebSocket) {\n    this.ws = ws;\n  }\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebSocketServer>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(req.headers['sec-websocket-key'], this.secret)) {\n        const webviewConnection = new WebSocketServer({ server: this.server });\n        webviewConnection.on('connection', (clientWs) => {\n          this.connections.add(clientWs);\n          clientWs.on('close', () => {\n            this.connections.delete(clientWs);\n          });\n          clientWs.on('message', (message) => {\n            this.handleMessage(dataSource, clientWs, message);\n          });\n        });\n      }\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  private authenticate(key: string, secret: string): boolean {\n    // Implement authentication logic here\n    return true;\n  }\n\n  private handleMessage(dataSource: VisualizationWatchModel, ws: WebSocketServer, message: string) {\n    // Implement message handling logic here\n  }\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebviewConnection>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(ws, req)) {\n        const connection = new WebviewConnection(ws);\n        this.connections.add(connection);\n        connection.on('message', (message) => {\n          // Handle incoming messages\n        });\n        connection.on('close', () => {\n          this.connections.delete(connection);\n        });\n      }\n    });\n\n    this.server.listen(config.port, () => {\n      console.log(`WebSocket server listening on port ${config.port}`);\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  authenticate(ws: WebSocket, req: any): boolean {\n    // Implement authentication logic\n    return true;\n  }\n}\n\nclass WebviewConnection {\n  ws: WebSocket;\n\n  constructor(ws: WebSocket) {\n    this.ws = ws;\n  }\n\n  on(event: 'message' | 'close', callback: (data?: any) => void): void {\n    this.ws.on(event, callback);\n  }\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebviewConnection>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(ws, req)) {\n        this.connections.add(new WebviewConnection(ws));\n      } else {\n        ws.terminate();\n      }\n    });\n\n    this.server.listen(config.port, () => {\n      console.log(`WebSocket server listening on port ${config.port}`);\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  private authenticate(ws: WebSocket, req: any): boolean {\n    // Implement authentication logic here\n    return true;\n  }\n}\n\nclass WebviewConnection {\n  ws: WebSocket;\n\n  constructor(ws: WebSocket) {\n    this.ws = ws;\n  }\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebviewConnection>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(ws, req)) {\n        this.connections.add(new WebviewConnection(ws));\n      }\n    });\n\n    this.server.listen(config.port, () => {\n      console.log(`WebSocket server is listening on port ${this.port()}`);\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  authenticate(ws: WebSocket, req: any): boolean {\n    // Implement authentication logic here\n    return true;\n  }\n}\n\nclass WebviewConnection {\n  ws: WebSocket;\n\n  constructor(ws: WebSocket) {\n    this.ws = ws;\n  }\n}\n```",
      "```typescript\nimport { Server } from 'http';\nimport { WebSocketServer } from 'ws';\nimport { VisualizationWatchModel } from './VisualizationWatchModel';\nimport { Config } from './Config';\n\nclass WebviewServer {\n  server: Server;\n  secret: string;\n  connections: Set<WebSocketServer>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.server = new Server(config.serverOptions);\n    this.secret = config.secret;\n    this.connections = new Set();\n    this.config = config;\n\n    this.server.on('connection', (ws, req) => {\n      if (this.authenticate(req.headers, this.secret)) {\n        const connection = new WebSocketServer({ server: this.server });\n        connection.on('connection', (ws) => {\n          this.connections.add(connection);\n          ws.on('close', () => {\n            this.connections.delete(connection);\n          });\n        });\n      }\n    });\n  }\n\n  get port(): number {\n    return this.server.address().port;\n  }\n\n  authenticate(headers: any, secret: string): boolean {\n    // Authentication logic here\n    return true;\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 267,
    "Instruction": "Task Description: Create a WebSocket server that handles MQTT protocol messages using the Aedes broker, with event listeners for various client interactions and message handling.\n\nFunction Description: The function `createWebSocketServer` initializes and starts a WebSocket server that integrates with the Aedes MQTT broker. It sets up event handlers for client connections, errors, message publishing, subscriptions, and client disconnections. The server listens on a specified port for WebSocket connections and routes MQTT messages through the Aedes broker.\n\nInput: None (The function does not take any input parameters; port and configuration are hardcoded within the function.)\n\nOutput: None (The function does not return any value; it creates and maintains a running WebSocket server with event listeners.)",
    "Canonical_solution": "function createWebSocketServer() {\n    const aedes = require('aedes')();\n    const httpServer = require('http').createServer();\n    const WebSocket = require('ws');\n    const wsPort = 8080;\n\n    const wss = new WebSocket.Server({ server: httpServer });\n    wss.on('connection', function connection(ws) {\n        const duplex = WebSocket.createWebSocketStream(ws);\n        aedes.handle(duplex);\n    });\n\n    httpServer.listen(wsPort, () => {\n        console.log('websocket server listening on port', wsPort);\n    });\n\n    aedes.on('clientError', (client, err) => {\n        console.log('client error', client.id, err.message, err.stack);\n    });\n\n    aedes.on('connectionError', (client, err) => {\n        console.log('client error', client, err.message, err.stack);\n    });\n\n    aedes.on('publish', (packet, client) => {\n        if (packet && packet.payload) {\n            console.log('publish packet:', packet.payload.toString());\n        }\n        if (client) {\n            console.log('message from client', client.id);\n        }\n    });\n\n    aedes.on('subscribe', (subscriptions, client) => {\n        if (client) {\n            console.log('subscribe from client', subscriptions, client.id);\n        }\n    });\n\n    aedes.on('client', (client) => {\n        console.log('new client', client.id);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', ws => {\n    ws.on('message', message => {\n      const topic = message.topic;\n      const payload = message.payload.toString();\n      client.publish(topic, payload);\n    });\n  });\n\n  client.on('connect', () => {\n    server.on('message', (data, ws) => {\n      const topic = data.topic;\n      const payload = data.payload.toString();\n      aedes.publish({ topic, payload }, ws);\n    });\n\n    server.on('connection', ws => {\n      aedes.subscribe({ topic: 'clients/#' }, ws);\n    });\n\n    aedes.on('client', client => {\n      server.clients.forEach(ws => {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify({ type: 'client_connected', clientId: client.id }));\n        }\n      });\n    });\n\n    aedes.on('client disconnect', client => {\n      server.clients.forEach(ws => {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify({ type: 'client_disconnected', clientId: client.id }));\n        }\n      });\n    });\n\n    aedes.on('publish', packet => {\n      server.clients.forEach(ws => {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify({ type: 'message', topic: packet.topic, payload: packet.payload.toString() }));\n        }\n      });\n    });\n\n    aedes.on('subscribe', packet => {\n      server.clients.forEach(ws => {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify({ type: 'subscription', topic: packet.topic }));\n        }\n      });\n    });\n  });\n\n  client.on('error', error => {\n    console.error('Client error:', error);\n  });\n\n  aedes.on('error', error => {\n    console.error('Aedes error:', error);\n  });\n\n  aedes.on('ready', () => {\n    console.log('Aedes broker is ready');\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  client.on('connect', () => {\n    console.log('Connected to Aedes broker');\n  });\n\n  client.on('error', (err) => {\n    console.error('Error connecting to Aedes broker:', err);\n  });\n\n  server.on('connection', (ws) => {\n    console.log('Client connected');\n\n    ws.on('message', (message) => {\n      const topic = message.topic;\n      const payload = message.payload.toString();\n      client.publish(topic, payload, (err) => {\n        if (err) {\n          console.error('Error publishing message to Aedes broker:', err);\n        }\n      });\n    });\n\n    ws.on('close', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  aedes.on('clientConnected', (client) => {\n    console.log('Client connected to Aedes broker');\n  });\n\n  aedes.on('clientDisconnected', (client) => {\n    console.log('Client disconnected from Aedes broker');\n  });\n\n  aedes.on('publish', (packet, client) => {\n    server.clients.forEach((ws) => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(JSON.stringify({ topic: packet.topic, payload: packet.payload }));\n      }\n    });\n  });\n\n  aedes.on('subscribe', (packet, client) => {\n    console.log('Client subscribed to topic:', packet.topic);\n  });\n\n  aedes.on('unsubscribe', (packet, client) => {\n    console.log('Client unsubscribed from topic:', packet.topic);\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      const packet = mqtt.parseMessage(message);\n      client.publish(packet.topic, packet.payload);\n    });\n\n    ws.on('close', function close() {\n      client.end();\n    });\n  });\n\n  aedes.on('clientConnected', function(client) {\n    console.log('Client connected:', client.id);\n  });\n\n  aedes.on('clientDisconnected', function(client) {\n    console.log('Client disconnected:', client.id);\n  });\n\n  aedes.on('publish', function(packet, client) {\n    server.clients.forEach(function each(ws) {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(mqtt.stringify(packet));\n      }\n    });\n  });\n\n  aedes.on('subscribe', function(packet, client) {\n    console.log('Client subscribed:', client.id, packet.topics);\n  });\n\n  aedes.on('unsubscribe', function(packet, client) {\n    console.log('Client unsubscribed:', client.id, packet.topics);\n  });\n\n  aedes.on('error', function(error) {\n    console.error('Aedes broker error:', error);\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      const topic = 'mqtt/websocket';\n      client.publish(topic, message.toString());\n    });\n\n    ws.on('close', function close() {\n      client.end();\n    });\n  });\n\n  client.on('connect', function() {\n    aedes.on('clientConnected', function(client) {\n      console.log('Client connected:', client.id);\n    });\n\n    aedes.on('clientDisconnected', function(client) {\n      console.log('Client disconnected:', client.id);\n    });\n\n    aedes.on('publish', function(packet, client) {\n      server.clients.forEach(function each(ws) {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify(packet));\n        }\n      });\n    });\n\n    aedes.on('subscribe', function(packet, client) {\n      console.log('Client subscribed:', client.id, packet);\n    });\n\n    aedes.on('unsubscribe', function(packet, client) {\n      console.log('Client unsubscribed:', client.id, packet);\n    });\n\n    aedes.on('error', function(error) {\n      console.error('Aedes broker error:', error);\n    });\n  });\n\n  client.on('error', function(error) {\n    console.error('Client error:', error);\n  });\n\n  client.on('reconnect', function() {\n    console.log('Client reconnecting...');\n  });\n\n  client.on('offline', function() {\n    console.log('Client offline...');\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = new Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      const topic = 'mqtt/websocket';\n      client.publish(topic, message.toString());\n    });\n\n    ws.on('close', function close() {\n      client.end();\n    });\n  });\n\n  client.on('connect', function() {\n    aedes.on('clientConnected', function(client) {\n      console.log('Client connected:', client.id);\n    });\n\n    aedes.on('clientDisconnected', function(client) {\n      console.log('Client disconnected:', client.id);\n    });\n\n    aedes.on('publish', function(packet, client) {\n      server.clients.forEach(function each(ws) {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify(packet));\n        }\n      });\n    });\n\n    aedes.on('subscribe', function(packet, client) {\n      console.log('Client subscribed:', client.id, packet);\n    });\n\n    aedes.on('unsubscribe', function(packet, client) {\n      console.log('Client unsubscribed:', client.id, packet);\n    });\n\n    aedes.on('error', function(error) {\n      console.error('Aedes broker error:', error);\n    });\n  });\n\n  client.on('error', function(error) {\n    console.error('Client error:', error);\n  });\n\n  client.on('reconnect', function() {\n    console.log('Client reconnecting...');\n  });\n\n  client.on('offline', function() {\n    console.log('Client offline...');\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = new Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      const topic = 'mqtt/websocket';\n      aedes.publish({ topic, payload: message.toString() });\n    });\n\n    ws.on('close', function close() {\n      aedes.end();\n    });\n  });\n\n  aedes.on('clientConnected', function(client) {\n    console.log('Client connected:', client.id);\n  });\n\n  aedes.on('clientDisconnected', function(client) {\n    console.log('Client disconnected:', client.id);\n  });\n\n  aedes.on('message', function(message) {\n    server.clients.forEach(function each(client) {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(message.payload.toString());\n      }\n    });\n  });\n\n  aedes.on('error', function(error) {\n    console.error('Aedes broker error:', error);\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = new Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      client.publish('mqtt/topic', message.toString());\n    });\n  });\n\n  client.on('connect', function() {\n    console.log('Connected to Aedes broker');\n  });\n\n  client.on('error', function(error) {\n    console.error('Error connecting to Aedes broker:', error);\n  });\n\n  aedes.on('clientConnected', function(client) {\n    console.log('Client connected:', client.id);\n  });\n\n  aedes.on('clientDisconnected', function(client) {\n    console.log('Client disconnected:', client.id);\n  });\n\n  aedes.on('publish', function(packet, client) {\n    console.log('Message published:', packet.payload.toString());\n  });\n\n  aedes.on('subscribe', function(packet, client) {\n    console.log('Client subscribed:', client.id, packet.topic);\n  });\n\n  aedes.on('unsubscribe', function(packet, client) {\n    console.log('Client unsubscribed:', client.id, packet.topic);\n  });\n\n  aedes.on('error', function(error) {\n    console.error('Error in Aedes broker:', error);\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      const topic = message.toString().split(' ')[1];\n      const payload = message.toString().split(' ')[2];\n      client.publish(topic, payload);\n    });\n  });\n\n  client.on('connect', () => {\n    aedes.on('client', (client) => {\n      server.clients.forEach((ws) => {\n        ws.send(JSON.stringify({\n          topic: client.id,\n          payload: 'client connected'\n        }));\n      });\n    });\n\n    aedes.on('publish', (packet, client) => {\n      server.clients.forEach((ws) => {\n        ws.send(JSON.stringify({\n          topic: packet.topic,\n          payload: packet.payload.toString()\n        }));\n      });\n    });\n\n    aedes.on('subscribe', (packet, client) => {\n      server.clients.forEach((ws) => {\n        ws.send(JSON.stringify({\n          topic: packet.topic,\n          payload: 'client subscribed'\n        }));\n      });\n    });\n\n    aedes.on('unsubscribe', (packet, client) => {\n      server.clients.forEach((ws) => {\n        ws.send(JSON.stringify({\n          topic: packet.topic,\n          payload: 'client unsubscribed'\n        }));\n      });\n    });\n\n    aedes.on('clientDisconnect', (client) => {\n      server.clients.forEach((ws) => {\n        ws.send(JSON.stringify({\n          topic: client.id,\n          payload: 'client disconnected'\n        }));\n      });\n    });\n  });\n\n  client.on('error', (error) => {\n    console.error('Client error:', error);\n  });\n\n  aedes.on('error', (error) => {\n    console.error('Aedes error:', error);\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = new Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', ws => {\n    const client = mqtt.connect('mqtt://localhost', { will: { topic: 'client/disconnected', payload: Buffer.from('client disconnected') } });\n    client.on('connect', () => {\n      ws.on('message', message => {\n        client.publish('client/messages', message);\n      });\n      ws.on('close', () => {\n        client.end();\n      });\n      ws.on('error', error => {\n        client.end();\n      });\n    });\n\n    client.on('message', message => {\n      ws.send(message.payload.toString());\n    });\n\n    client.on('error', error => {\n      ws.close();\n    });\n  });\n\n  aedes.on('clientConnected', client => {\n    console.log('Client connected:', client.id);\n  });\n\n  aedes.on('clientDisconnected', client => {\n    console.log('Client disconnected:', client.id);\n  });\n\n  aedes.on('publish', packet => {\n    console.log('Message published:', packet.payload.toString());\n  });\n\n  aedes.on('subscribe', packet => {\n    console.log('Client subscribed:', packet.clientId, packet.topicFilters);\n  });\n\n  aedes.on('unsubscribe', packet => {\n    console.log('Client unsubscribed:', packet.clientId, packet.topicFilters);\n  });\n};\n\ncreateWebSocketServer();\n```",
      "```javascript\nconst WebSocket = require('ws');\nconst mqtt = require('mqtt');\nconst Aedes = require('aedes');\n\nconst createWebSocketServer = () => {\n  const server = new WebSocket.Server({ port: 8080 });\n  const aedes = new Aedes();\n  const client = mqtt.connect('mqtt://localhost');\n\n  server.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      client.publish('mqtt/topic', message);\n    });\n  });\n\n  client.on('connect', function() {\n    console.log('Connected to Aedes broker');\n  });\n\n  client.on('error', function(error) {\n    console.error('Error connecting to Aedes broker:', error);\n  });\n\n  aedes.on('clientConnected', function(client) {\n    console.log('Client connected:', client.id);\n  });\n\n  aedes.on('clientDisconnected', function(client) {\n    console.log('Client disconnected:', client.id);\n  });\n\n  aedes.on('publish', function(packet, client) {\n    console.log('Message published:', packet.payload.toString());\n  });\n\n  aedes.on('subscribe', function(packet, client) {\n    console.log('Client subscribed:', client.id, packet.topics);\n  });\n\n  aedes.on('unsubscribe', function(packet, client) {\n    console.log('Client unsubscribed:', client.id, packet.topics);\n  });\n};\n\ncreateWebSocketServer();\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a WebSocket server in Node.js that listens for incoming connections, handles messages, and responds to specific initialization messages.\n\nFunction Description: The function `setupWebSocketServer` initializes a WebSocket server on a specified port. It sets up event handlers for connections and incoming messages. When a message is received, it echoes the message back to the client. If the received message matches a predefined initialization message, it sends a specific response message before closing the connection.\n\nInput: \n- `callback`: [Function] - A callback function to be executed once the server starts listening.\n- `initMsg`: [String] - The initialization message that triggers a specific response.\n- `responseMsg`: [String] - The response message to be sent when the initialization message is received.\n\nOutput: \n- None (The function sets up the server and event handlers but does not return any value).",
    "Canonical_solution": "function setupWebSocketServer() {\n  const http = require('http');\n  const WebSocket = require('ws');\n\n  this.server = http.createServer();\n  this.server.listen(8099, function() {\n    callback();\n  });\n\n  this.wss = new WebSocket.Server({ server: this.server });\n  this.wss.on('connection', (ws) => {\n    ws.on('message', (data) => {\n      const received = data.toString();\n      ws.send(received);\n      if (received === initMsg) {\n        ws.send(responseMsg);\n      }\n      ws.close();\n    });\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nfunction setupWebSocketServer(callback, initMsg, responseMsg) {\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}",
      "```javascript\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nfunction setupWebSocketServer(callback, initMsg, responseMsg) {\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction setupWebSocketServer(callback, initMsg, responseMsg) {\n  const wss = new WebSocket.Server({ port: 8080 });\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction setupWebSocketServer(callback, initMsg, responseMsg) {\n  const wss = new WebSocket.Server({ port: 8080 });\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}\n```",
      "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nfunction setupWebSocketServer(callback, initMsg, responseMsg) {\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction setupWebSocketServer(port, callback, initMsg, responseMsg) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction setupWebSocketServer(port, callback, initMsg, responseMsg) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction setupWebSocketServer(port, callback, initMsg, responseMsg) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction setupWebSocketServer(port, callback, initMsg, responseMsg) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  if (callback) {\n    callback();\n  }\n}\n```",
      "```javascript\nconst WebSocket = require('ws');\n\nfunction setupWebSocketServer(port, callback, initMsg, responseMsg) {\n  const wss = new WebSocket.Server({ port });\n\n  wss.on('connection', function connection(ws) {\n    ws.on('message', function incoming(message) {\n      if (message === initMsg) {\n        ws.send(responseMsg);\n        ws.close();\n      } else {\n        ws.send(message);\n      }\n    });\n  });\n\n  callback();\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles client connections, message processing, and subscription management for real-time communication.\n\nClass Description: The AphlictClientServer class implements a WebSocket server that manages client connections, processes incoming messages (including subscriptions, replays, and pings), and maintains listener lists for different instances. It's built on top of Node.js's HTTP server and ws WebSocket library.\n\nAttributes:\n- _server: [Object] - The underlying HTTP server instance\n- _lists: [Object] - Dictionary storing listener lists for different instances\n- _adminServers: [Array] - Array containing admin server references\n\nMethods:\n- constructor(server) -> [void] - Initializes the server instance and sets up request handling\n- _onrequest(request, response) -> [void] - Handles HTTP requests (returns 501 as this is a WebSocket server)\n- _parseInstanceFromPath(path) -> [String] - Extracts instance name from URL path\n- listen() -> [void] - Starts the WebSocket server and sets up connection handlers\n- getListenerList(instance) -> [Object] - Returns the listener list for a given instance (implied by usage)\n- log(message) -> [void] - Logs messages (implied by usage)\n- trace(message) -> [void] - Logs trace-level messages (implied by usage)\n- getHistory(min_age) -> [Array] - Returns historical messages (implied by usage in replay handler)\n\nThe class handles WebSocket connections with the following behaviors:\n1. Parses instance names from connection URLs\n2. Manages listener subscriptions/unsubscriptions\n3. Handles message replay requests\n4. Processes ping/pong messages\n5. Logs connection/disconnection events\n6. Maintains separate listener lists for different instances",
    "Canonical_solution": "var url = require('url');\nvar util = require('util');\nvar WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    server.on('request', this._onrequest.bind(this));\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end('HTTP/501 Use Websockets\\n');\n  }\n\n  _parseInstanceFromPath(path) {\n    if (path.indexOf('~') === -1) {\n      return 'default';\n    }\n\n    var instance = path.split('~')[1];\n    instance = instance.replace(/\\//g, '');\n    if (!instance.length) {\n      return 'default';\n    }\n\n    return instance;\n  }\n\n  listen() {\n    var self = this;\n    var server = this._server.listen.apply(this._server, arguments);\n    var wss = new WebSocket.Server({server: server});\n\n    wss.on('connection', function(ws, request) {\n      if ('upgradeReq' in ws) {\n        request = ws.upgradeReq;\n      }\n\n      var path = url.parse(request.url).pathname;\n      var instance = self._parseInstanceFromPath(path);\n\n      var listener = self.getListenerList(instance).addListener(ws);\n\n      function msg(argv) {\n        return util.format('<%s>', listener.getDescription()) +\n          ' ' +\n          util.format.apply(null, argv);\n      }\n\n      function log() {\n        self.log(msg(arguments));\n      }\n\n      function trace() {\n        self.trace(msg(arguments));\n      }\n\n      trace('Connected from %s.', ws._socket.remoteAddress);\n\n      ws.on('message', function(data) {\n        trace('Received message: %s', data);\n\n        var message;\n        try {\n          message = JSON.parse(data);\n        } catch (err) {\n          log('Message is invalid: %s', err.message);\n          return;\n        }\n\n        switch (message.command) {\n          case 'subscribe':\n            trace(\n              'Subscribed to: %s',\n              JSON.stringify(message.data));\n            listener.subscribe(message.data);\n            break;\n\n          case 'unsubscribe':\n            trace(\n              'Unsubscribed from: %s',\n              JSON.stringify(message.data));\n            listener.unsubscribe(message.data);\n            break;\n\n          case 'replay':\n            var age = message.data.age || 60000;\n            var min_age = (new Date().getTime() - age);\n\n            var old_messages = self.getHistory(min_age);\n            for (var ii = 0; ii < old_messages.length; ii++) {\n              var old_message = old_messages[ii];\n\n              if (!listener.isSubscribedToAny(old_message.subscribers)) {\n                continue;\n              }\n\n              try {\n                listener.writeMessage(old_message);\n              } catch (error) {\n                break;\n              }\n            }\n            break;\n\n          case 'ping':\n            var pong = {\n              type: 'pong'\n            };\n\n            try {\n              listener.writeMessage(pong);\n            } catch (error) {\n              // Ignore any issues here, we'll clean up elsewhere.\n            }\n            break;\n\n          default:\n            log(\n              'Unrecognized command \"%s\".',\n              message.command || '<undefined>');\n        }\n      });\n\n      ws.on('close', function() {\n        self.getListenerList(instance).removeListener(listener);\n        trace('Disconnected.');\n      });\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "matched_results": [
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    const wss = new WebSocket.Server({ server: this._server });\n    wss.on('connection', (ws, req) => {\n      const instance = this._parseInstanceFromPath(req.url);\n      ws.instance = instance;\n      this._handleConnection(ws, instance);\n    });\n  }\n\n  _handleConnection(ws, instance) {\n    if (!this._lists[instance]) {\n      this._lists[instance] = [];\n    }\n    this._lists[instance].push(ws);\n    ws.on('message', (message) => {\n      this._handleMessage(ws, instance, message);\n    });\n    ws.on('close', () => {\n      this._handleClose(instance, ws);\n    });\n  }\n\n  _handleMessage(ws, instance, message) {\n    // Parse and handle different types of messages\n    // e.g., subscriptions, replays, pings, etc.\n  }\n\n  _handleClose(instance, ws) {\n    const index = this._lists[instance].indexOf(ws);\n    if (index !== -1) {\n      this._lists[instance].splice(index, 1);\n    }\n    // Log disconnection event\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance];\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages based on min_age\n  }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    this._server.listen();\n    this._server.on('connection', (ws, req) => {\n      const instance = this._parseInstanceFromPath(req.url);\n      ws.on('message', (message) => {\n        // Handle messages including subscriptions, replays, and pings\n      });\n      ws.on('close', () => {\n        // Handle disconnection\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || {};\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    this._server.listen();\n    this._server.on('connection', (ws, req) => {\n      const instance = this._parseInstanceFromPath(req.url);\n      ws.on('message', (message) => {\n        // Handle messages including subscriptions, replays, and pings\n      });\n      ws.on('close', () => {\n        // Handle disconnection\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || {};\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end('Not Implemented');\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    this._server.listen();\n    this._server.on('connection', (ws, req) => {\n      const instance = this._parseInstanceFromPath(req.url);\n      ws.on('message', (message) => {\n        // Process messages here\n      });\n      ws.on('close', () => {\n        // Handle disconnection here\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || {};\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages based on min_age\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    this._server.listen();\n    this._server.on('connection', this._onconnection.bind(this));\n  }\n\n  _onconnection(ws, req) {\n    const instance = this._parseInstanceFromPath(req.url);\n    ws.on('message', this._onmessage.bind(this, ws, instance));\n    ws.on('close', this._onclose.bind(this, ws, instance));\n    ws.on('ping', this._onping.bind(this, ws));\n    ws.on('pong', this._onpong.bind(this, ws));\n    this.log(`Client connected to instance ${instance}`);\n  }\n\n  _onmessage(ws, instance, message) {\n    // Parse and handle message\n  }\n\n  _onclose(ws, instance) {\n    this.log(`Client disconnected from instance ${instance}`);\n  }\n\n  _onping(ws, data) {\n    // Handle ping\n  }\n\n  _onpong(ws, data) {\n    // Handle pong\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || {};\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    this._server.listen();\n    this._server.on('connection', (ws, req) => {\n      const instance = this._parseInstanceFromPath(req.url);\n      ws.on('message', (message) => {\n        // Handle messages including subscriptions, replays, and pings\n      });\n      ws.on('close', () => {\n        // Handle disconnection\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || {};\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    this._server.listen();\n    this._server.on('connection', (ws, request) => {\n      const instance = this._parseInstanceFromPath(request.url);\n      ws.on('message', (message) => {\n        // Process messages here\n      });\n      ws.on('close', () => {\n        // Handle disconnection here\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || {};\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages based on min_age\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n    constructor(server) {\n        this._server = server;\n        this._lists = {};\n        this._adminServers = [];\n        this._server.on('request', this._onrequest.bind(this));\n    }\n\n    _onrequest(request, response) {\n        response.writeHead(501);\n        response.end();\n    }\n\n    _parseInstanceFromPath(path) {\n        return path.split('/')[1];\n    }\n\n    listen() {\n        this._server.listen();\n        this._server.on('connection', (ws, req) => {\n            const instance = this._parseInstanceFromPath(req.url);\n            ws.on('message', (message) => {\n                // Handle messages including subscriptions, replays, and pings\n            });\n            ws.on('close', () => {\n                // Handle disconnection\n            });\n        });\n    }\n\n    getListenerList(instance) {\n        return this._lists[instance] || {};\n    }\n\n    log(message) {\n        console.log(message);\n    }\n\n    trace(message) {\n        console.trace(message);\n    }\n\n    getHistory(min_age) {\n        // Return historical messages\n    }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    this._server.listen();\n    this._server.on('connection', (ws, req) => {\n      const instance = this._parseInstanceFromPath(req.url);\n      ws.on('message', (message) => {\n        // Process messages here\n      });\n      ws.on('close', () => {\n        // Handle disconnection here\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || [];\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages based on min_age\n  }\n}\n```",
      "```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.split('/')[1];\n  }\n\n  listen() {\n    this._server.listen();\n    this._server.on('connection', (ws, request) => {\n      const instance = this._parseInstanceFromPath(request.url);\n      ws.on('message', (message) => {\n        // Handle incoming messages\n      });\n      ws.on('close', () => {\n        // Handle disconnection\n      });\n    });\n  }\n\n  getListenerList(instance) {\n    return this._lists[instance] || {};\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.trace(message);\n  }\n\n  getHistory(min_age) {\n    // Return historical messages\n  }\n}\n```"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n      data: body\n    };\n    return this.requestModule(config);\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n      data: body\n    };\n    try {\n      const response = await this.requestModule(config);\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    try {\n      const response = await this.requestModule[method](url, {\n        headers,\n        params,\n        data: body,\n      });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n      data: body\n    };\n    return this.requestModule(config);\n  }\n\n  queryStr(options) {\n    return Object.keys(options).map(key => {\n      const value = encodeURIComponent(options[key]);\n      return `${key}=${value}`;\n    }).join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n      data: body\n    };\n    return this.requestModule(config);\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n      data: body\n    };\n    return this.requestModule(config);\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    try {\n      const response = await this.requestModule[method.toLowerCase()](url, {\n        headers,\n        params,\n        data: body,\n      });\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n      data: body\n    };\n    try {\n      const response = await this.requestModule(config);\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n      data: body\n    };\n    return this.requestModule(config);\n  }\n\n  queryStr(options) {\n    return Object.keys(options).map(key => {\n      const value = encodeURIComponent(options[key]);\n      return `${key}=${value}`;\n    }).join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n      data: body\n    };\n    return this.requestModule(config);\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript to handle real-time bidirectional communication between clients and the server.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io. It sets up event listeners for client connections, messages, and disconnections. The server broadcasts received messages to all connected clients.\n\nInput:\n- `port` (Number): The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:\n- Returns the `socketServer` instance (Object) which can be used to further configure or interact with the WebSocket server.\n\nNote: The function internally uses the `http` module to create an HTTP server and binds socket.io to it for WebSocket communication. The server logs connection, message, and disconnection events to the console.",
    "Canonical_solution": "const http = require(\"http\");\nconst socketIo = require(\"socket.io\");\n\nfunction setupWebSocketServer(port) {\n    const app = express();\n    const webServer = http.createServer(app);\n    const socketServer = socketIo(webServer, {\"log level\": 1});\n\n    socketServer.on(\"connection\", (socket) => {\n        console.log(\"New client connected\");\n\n        socket.on(\"message\", (data) => {\n            console.log(\"Message received: \", data);\n            socketServer.emit(\"message\", data);\n        });\n\n        socket.on(\"disconnect\", () => {\n            console.log(\"Client disconnected\");\n        });\n    });\n\n    webServer.listen(port, () => {\n        console.log(\"WebSocket server listening on port: \" + port);\n    });\n\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "matched_results": [
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`WebSocket server listening on port ${port}`);\n  });\n\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`WebSocket server listening on port ${port}`);\n  });\n\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port);\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`WebSocket server listening on port ${port}`);\n  });\n\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  return socketServer;\n}",
      "const http = require('http');\nconst socketIo = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = socketIo(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('message', (msg) => {\n      console.log('Message received: ' + msg);\n      socketServer.emit('message', msg);\n    });\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  return socketServer;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript that handles real-time communication between clients and integrates with an Express application and Deployd backend.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io, integrates it with an Express application, and attaches a Deployd backend. It sets up event listeners for server operations and handles custom Express routes.\n\nInput: None (The function uses environment variables for configuration: `process.env.NODE_ENV` for environment setting and `process.env.PORT` for port number)\n\nOutput: None (The function starts a server that listens on the specified port and logs server status to the console)\n\nNote: The function internally uses:\n- Express for HTTP server functionality\n- Socket.io for WebSocket communication\n- Deployd for backend services\n- MongoDB (configured to connect to localhost:27017 with database name 'test-app')",
    "Canonical_solution": "function setupWebSocketServer() {\n    var express = require('express');\n    var app = express();\n    var server = require('http').createServer(app);\n    var io = require('socket.io').listen(server, {'log level': 0});\n\n    require('deployd').attach(server, {\n        socketIo: io,\n        env: process.env.NODE_ENV || 'development',\n        db: {host:'localhost', port:27017, name:'test-app'}\n    });\n    app.use(server.handleRequest);\n\n    app.get('/express-custom-handler', function(req, res) {\n        res.send('Ok');\n    });\n\n    server.listen(process.env.PORT || 2403, function() {\n        console.log({ ENV: process.env.NODE_ENV || 'development', PORT: process.env.PORT || 2403 });\n    });\n    server.on('error', function(err) {\n        console.log(err.stack);\n        process.nextTick(function() {\n            process.exit();\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "matched_results": [
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyo');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_API_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  // Handle custom route\n  res.send('Custom route response');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server running on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyod');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_URL, process.env.DEPLOYD_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  // Custom route handling\n  res.send('Custom route response');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server running on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyd');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_URL, process.env.DEPLOYD_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  // Custom route logic\n  res.send('Custom route response');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server running on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyo');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_URL, process.env.DEPLOYD_API_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  res.send('Custom route response');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server listening on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyod');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_URL, process.env.DEPLOYD_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  // Handle custom route\n  res.send('Custom route handled');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server running on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyo');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_API_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.use('/api', deployd.middleware());\n\napp.get('/test', (req, res) => {\n  res.send('Hello, this is a test route!');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server running on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyo');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_API_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  // Handle custom route\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server running on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyo');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_API_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  // Custom route logic\n  res.send('Custom route response');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server running on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyod');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd({\n  apiKey: process.env.DEPLOYD_API_KEY,\n  applicationId: process.env.DEPLOYD_APP_ID\n});\n\nconst db = mongoose.connect('mongodb://localhost:27017/test-app', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n});\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  res.send('Custom route handled');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server running on port ${process.env.PORT}`);\n});",
      "const express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst Deployd = require('deplyo');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\nconst deployd = new Deployd(process.env.DEPLOYD_API_KEY);\n\nmongoose.connect('mongodb://localhost:27017/test-app', { useNewUrlParser: true, useUnifiedTopology: true });\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/custom-route', (req, res) => {\n  // Custom route logic\n  res.send('Custom route response');\n});\n\nserver.listen(process.env.PORT, () => {\n  console.log(`Server listening on port ${process.env.PORT}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "const axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}\n```",
      "const axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}\n```",
      "const axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('div.channel').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('h2.channel-name').text().trim();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}",
      "const axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('channel').each((index, element) => {\n    const lang = $(element).attr('lang');\n    const site_id = $(element).attr('site_id');\n    const name = $(element).text();\n    channels.push({ lang, site_id, name });\n  });\n\n  return channels;\n}"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst process = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (telemetryEnabled) {\n    const data = JSON.stringify({\n      nodeVersion: process.version,\n      platform: os.platform(),\n    });\n\n    const options = {\n      hostname: 'telemetry.example.com',\n      port: 443,\n      path: '/submit',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length,\n      },\n    };\n\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {\n        process.stdout.write(d);\n      });\n    });\n\n    req.on('error', (e) => {\n      process.stderr.write(e.message);\n    });\n\n    req.write(data);\n    req.end();\n  }\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst process = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (telemetryEnabled) {\n    const data = JSON.stringify({\n      nodeVersion: process.version,\n      platform: os.platform(),\n    });\n\n    const options = {\n      hostname: 'telemetry.example.com',\n      port: 443,\n      path: '/submit',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length,\n      },\n    };\n\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {\n        process.stdout.write(d);\n      });\n    });\n\n    req.on('error', (e) => {\n      process.stderr.write(e.message);\n    });\n\n    req.write(data);\n    req.end();\n  }\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst { version: nodeVersion } = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (telemetryEnabled) {\n    const data = JSON.stringify({\n      nodeVersion,\n      platform: os.platform(),\n    });\n\n    const options = {\n      hostname: 'telemetry.example.com',\n      port: 443,\n      path: '/submit',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length,\n      },\n    };\n\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {\n        process.stdout.write(d);\n      });\n    });\n\n    req.on('error', (e) => {\n      process.stderr.write(e.message);\n    });\n\n    req.write(data);\n    req.end();\n  }\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst process = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (!telemetryEnabled) return;\n\n  const data = JSON.stringify({\n    nodeVersion: process.version,\n    platform: os.platform(),\n  });\n\n  const options = {\n    hostname: 'telemetry.example.com',\n    port: 443,\n    path: '/submit',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': data.length,\n    },\n  };\n\n  const req = https.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    process.stderr.write(e.message);\n  });\n\n  req.write(data);\n  req.end();\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst process = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (telemetryEnabled) {\n    const data = JSON.stringify({\n      nodeVersion: process.version,\n      platform: os.platform(),\n    });\n\n    const options = {\n      hostname: 'telemetry.example.com',\n      port: 443,\n      path: '/submit',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length,\n      },\n    };\n\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {\n        process.stdout.write(d);\n      });\n    });\n\n    req.on('error', (e) => {\n      process.stderr.write(e.message);\n    });\n\n    req.write(data);\n    req.end();\n  }\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst { version: nodeVersion } = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (!telemetryEnabled) return;\n\n  const data = JSON.stringify({\n    nodeVersion,\n    platform: os.platform(),\n  });\n\n  const options = {\n    hostname: 'telemetry.example.com',\n    port: 443,\n    path: '/telemetry',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': data.length,\n    },\n  };\n\n  const req = https.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    process.stderr.write(e.message);\n  });\n\n  req.write(data);\n  req.end();\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst process = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (telemetryEnabled) {\n    const data = JSON.stringify({\n      nodeVersion: process.version,\n      platform: os.platform(),\n    });\n\n    const options = {\n      hostname: 'telemetry.example.com',\n      port: 443,\n      path: '/submit',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': Buffer.byteLength(data),\n      },\n    };\n\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {\n        process.stdout.write(d);\n      });\n    });\n\n    req.on('error', (e) => {\n      process.stderr.write(e.message);\n    });\n\n    req.write(data);\n    req.end();\n  }\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst { version: nodeVersion } = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (telemetryEnabled) {\n    const data = JSON.stringify({\n      nodeVersion,\n      platform: os.platform(),\n    });\n\n    const options = {\n      hostname: 'telemetry.example.com',\n      port: 443,\n      path: '/submit',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length,\n      },\n    };\n\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {\n        process.stdout.write(d);\n      });\n    });\n\n    req.on('error', (e) => {\n      process.stderr.write(e.message);\n    });\n\n    req.write(data);\n    req.end();\n  }\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst { version: nodeVersion } = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (telemetryEnabled) {\n    const data = JSON.stringify({\n      nodeVersion,\n      platform: os.platform(),\n    });\n\n    const options = {\n      hostname: 'telemetry.example.com',\n      port: 443,\n      path: '/submit',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length,\n      },\n    };\n\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {\n        process.stdout.write(d);\n      });\n    });\n\n    req.on('error', (e) => {\n      process.stderr.write(e.message);\n    });\n\n    req.write(data);\n    req.end();\n  }\n}\n```",
      "```javascript\nconst https = require('https');\nconst os = require('os');\nconst process = require('process');\n\nfunction installTelemetry() {\n  const telemetryEnabled = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (!telemetryEnabled) return;\n\n  const data = JSON.stringify({\n    nodeVersion: process.version,\n    platform: os.platform(),\n  });\n\n  const options = {\n    hostname: 'telemetry.example.com',\n    port: 443,\n    path: '/submit',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': data.length,\n    },\n  };\n\n  const req = https.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    process.stderr.write(e.message);\n  });\n\n  req.write(data);\n  req.end();\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nclass SauceLabsClient {\n    constructor() {\n        this.auth = null;\n    }\n\n    setAuth(saucelabsUsername, saucelabsToken) {\n        this.auth = {\n            username: saucelabsUsername,\n            token: saucelabsToken\n        };\n    }\n\n    get(path, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(xhr.statusText, null);\n                }\n            }\n        };\n        xhr.send();\n    }\n\n    post(path, data, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(xhr.statusText, null);\n                }\n            }\n        };\n        xhr.send(JSON.stringify(data));\n    }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {};\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.username = saucelabsUsername;\n    this.auth.token = saucelabsToken;\n  }\n\n  get(path, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        callback(xhr.status, xhr.responseText);\n      }\n    };\n    xhr.send();\n  }\n\n  post(path, data, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        callback(xhr.status, xhr.responseText);\n      }\n    };\n    xhr.send(JSON.stringify(data));\n  }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n  constructor() {\n    this.auth = null;\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth = { username: saucelabsUsername, token: saucelabsToken };\n  }\n\n  get(path, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        callback(xhr.status, xhr.responseText);\n      }\n    };\n    xhr.send();\n  }\n\n  post(path, data, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        callback(xhr.status, xhr.responseText);\n      }\n    };\n    xhr.send(JSON.stringify(data));\n  }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {};\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.username = saucelabsUsername;\n    this.auth.token = saucelabsToken;\n  }\n\n  get(path, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `https://api.saucelabs.com/v4/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        callback(xhr.status, xhr.responseText);\n      }\n    };\n    xhr.send();\n  }\n\n  post(path, data, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', `https://api.saucelabs.com/v4/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        callback(xhr.status, xhr.responseText);\n      }\n    };\n    xhr.send(JSON.stringify(data));\n  }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n    constructor() {\n        this.auth = null;\n    }\n\n    setAuth(saucelabsUsername, saucelabsToken) {\n        this.auth = { username: saucelabsUsername, token: saucelabsToken };\n    }\n\n    get(path, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', `https://api.saucelabs.com/v4/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(xhr.statusText, null);\n                }\n            }\n        };\n        xhr.send();\n    }\n\n    post(path, data, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', `https://api.saucelabs.com/v4/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(xhr.statusText, null);\n                }\n            }\n        };\n        xhr.send(JSON.stringify(data));\n    }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n  constructor() {\n    this.auth = null;\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth = { username: saucelabsUsername, token: saucelabsToken };\n  }\n\n  get(path, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          callback(null, JSON.parse(xhr.responseText));\n        } else {\n          callback(xhr.statusText, null);\n        }\n      }\n    };\n    xhr.send();\n  }\n\n  post(path, data, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          callback(null, JSON.parse(xhr.responseText));\n        } else {\n          callback(xhr.statusText, null);\n        }\n      }\n    };\n    xhr.send(JSON.stringify(data));\n  }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {};\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.username = saucelabsUsername;\n    this.auth.token = saucelabsToken;\n  }\n\n  get(path, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        callback(xhr.status, xhr.responseText);\n      }\n    };\n    xhr.send();\n  }\n\n  post(path, data, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', `https://saucelabs.com/rest/v1/${this.auth.username}/${path}`, true);\n    xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        callback(xhr.status, xhr.responseText);\n      }\n    };\n    xhr.send(JSON.stringify(data));\n  }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n    constructor() {\n        this.auth = null;\n    }\n\n    setAuth(saucelabsUsername, saucelabsToken) {\n        this.auth = {\n            username: saucelabsUsername,\n            token: saucelabsToken\n        };\n    }\n\n    get(path, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', `https://api.saucelabs.com/v4/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(xhr.statusText, null);\n                }\n            }\n        };\n        xhr.send();\n    }\n\n    post(path, data, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', `https://api.saucelabs.com/v4/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(xhr.statusText, null);\n                }\n            }\n        };\n        xhr.send(JSON.stringify(data));\n    }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n    constructor() {\n        this.auth = null;\n    }\n\n    setAuth(saucelabsUsername, saucelabsToken) {\n        this.auth = {\n            username: saucelabsUsername,\n            token: saucelabsToken\n        };\n    }\n\n    get(path, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', `https://api.saucelabs.com/v4/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(xhr.statusText, null);\n                }\n            }\n        };\n        xhr.send();\n    }\n\n    post(path, data, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', `https://api.saucelabs.com/v4/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(null, JSON.parse(xhr.responseText));\n                } else {\n                    callback(xhr.statusText, null);\n                }\n            }\n        };\n        xhr.send(JSON.stringify(data));\n    }\n}\n```",
      "```javascript\nclass SauceLabsClient {\n    constructor() {\n        this.auth = {};\n    }\n\n    setAuth(saucelabsUsername, saucelabsToken) {\n        this.auth.username = saucelabsUsername;\n        this.auth.token = saucelabsToken;\n    }\n\n    get(path, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', `https://api.saucelabs.com/v4/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                callback(xhr.status, xhr.responseText);\n            }\n        };\n        xhr.send();\n    }\n\n    post(path, data, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', `https://api.saucelabs.com/v4/${path}`, true);\n        xhr.setRequestHeader('Authorization', `Basic ${btoa(`${this.auth.username}:${this.auth.token}`)}`);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                callback(xhr.status, xhr.responseText);\n            }\n        };\n        xhr.send(JSON.stringify(data));\n    }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using an HTTP POST request and triggers a callback function upon completion or failure.\n\nFunction Description: The function uses Axios to send an HTTP POST request to a specified webhook URL with event and data payload. It triggers a callback function (triggerActivity) when the request succeeds or fails. The request includes custom headers for identification.\n\nInput:\n- url: [String] - The webhook URL to which the POST request will be sent\n- event: [String/Object] - The event information to be sent in the request payload\n- data: [Object] - The data payload to be sent in the request\n- triggerActivity: [Function] - Callback function to be triggered after request completion (takes an optional error parameter)\n\nOutput: [None] - The function doesn't return anything but triggers the callback function",
    "Canonical_solution": "const axios = require(\"axios\");\n\nfunction postWebhook(url, event, data, triggerActivity) {\n    axios.post(url, {event, data}, {headers: {\"user-agent\": \"MySpeed/WebhookAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [
      "```javascript\nconst axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Event-Type': event,\n    'X-Client-Id': 'your-client-id'\n  };\n\n  axios.post(url, data, { headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error, null));\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Event-Type': event,\n    'X-Client-Id': 'your-client-id'\n  };\n\n  axios.post(url, data, { headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error));\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-User-Id': '12345',\n    'X-Event-Type': event\n  };\n\n  axios.post(url, data, { headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error, null));\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Identification': 'YourCustomIdentifier'\n  };\n\n  axios.post(url, {\n    event: event,\n    data: data\n  }, { headers: headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error, null));\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Identification': 'YourCustomIdentifier'\n  };\n\n  axios.post(url, {\n    event: event,\n    data: data\n  }, { headers: headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error, null));\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Identification': 'YourCustomHeader'\n  };\n\n  axios.post(url, {\n    event: event,\n    data: data\n  }, { headers: headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error, null));\n}\n```",
      "const axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Event-Type': event\n  };\n\n  axios.post(url, data, { headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error));\n}",
      "const axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'Custom-Header': 'Your-Value'\n  };\n\n  axios.post(url, {\n    event: event,\n    data: data\n  }, { headers: headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error));\n}",
      "```javascript\nconst axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Identification': 'YourCustomHeader'\n  };\n\n  axios.post(url, {\n    event: event,\n    data: data\n  }, { headers: headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error));\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nfunction sendDataToWebhook(url, event, data, triggerActivity) {\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Event-Type': event\n  };\n\n  axios.post(url, data, { headers })\n    .then(response => triggerActivity(null, response))\n    .catch(error => triggerActivity(error));\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Write a function that retrieves TV channel information from multiple regions, processes the data, and returns a unique list of channels based on their site IDs.\n\nFunction Description: The function `channels` makes HTTP GET requests to a TV channel API for multiple regions, collects channel data from all available pages for each region, and returns a deduplicated list of channels. It uses axios for HTTP requests and lodash for data processing.\n\nInput: None (The function uses hardcoded region IDs internally)\n\nOutput: An array of objects representing unique TV channels, where each object contains:\n- lang: string - Language code ('ru' for Russian)\n- name: string - Name of the TV channel\n- site_id: string/number - Unique identifier for the channel on the site\n\nThe output is deduplicated based on the site_id field using lodash's uniqBy function.",
    "Canonical_solution": "async function channels() {\n    const _ = require('lodash')\n    const axios = require('axios')\n\n    const regions = [5506, 1096, 1125, 285]\n    let channels = []\n    for (let region of regions) {\n        const totalPages = await getTotalPageCount(region)\n        const pages = Array.from(Array(totalPages).keys())\n        for (let page of pages) {\n            const data = await axios\n                .get('https://tv.mail.ru/ajax/channel/list/', {\n                    params: { page },\n                    headers: {\n                        cookie: `s=fver=0|geo=${region};`\n                    }\n                })\n                .then(r => r.data)\n                .catch(console.log)\n\n            data.channels.forEach(item => {\n                channels.push({\n                    lang: 'ru',\n                    name: item.name,\n                    site_id: item.id\n                })\n            })\n        }\n    }\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regionIds = ['region1', 'region2', 'region3'];\n  const channels = [];\n\n  for (const regionId of regionIds) {\n    const response = await axios.get(`https://api.example.com/channels/${regionId}`);\n    const channelsFromRegion = response.data.channels;\n    channels.push(...channelsFromRegion);\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regionIds = [1, 2, 3];\n  const channels = [];\n\n  for (const regionId of regionIds) {\n    const response = await axios.get(`https://api.tvchannels.com/regions/${regionId}/channels`);\n    const channelsForRegion = response.data.channels;\n    channels.push(...channelsForRegion);\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regionIds = [1, 2, 3];\n  const channels = [];\n\n  for (const regionId of regionIds) {\n    const response = await axios.get(`https://api.tv.com/regions/${regionId}/channels`);\n    const channelsForRegion = response.data.channels;\n    channels.push(...channelsForRegion);\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regionIds = [1, 2, 3];\n  const channels = [];\n\n  for (const regionId of regionIds) {\n    const response = await axios.get(`https://api.example.com/channels/region/${regionId}`);\n    const channelsForRegion = response.data.channels;\n    channels.push(...channelsForRegion);\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regionIds = [1, 2, 3]; // hardcoded region IDs\n  const channels = [];\n\n  for (const regionId of regionIds) {\n    const response = await axios.get(`https://api.tv.com/regions/${regionId}/channels`);\n    const channelsFromRegion = response.data.channels;\n    channels.push(...channelsFromRegion);\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regionIds = ['region1', 'region2', 'region3'];\n  const channels = [];\n\n  for (const regionId of regionIds) {\n    const response = await axios.get(`https://api.example.com/channels/${regionId}`);\n    const channelsFromRegion = response.data.channels;\n    channels.push(...channelsFromRegion);\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regionIds = [1, 2, 3];\n  const channels = [];\n\n  for (const regionId of regionIds) {\n    const response = await axios.get(`https://api.tv.com/regions/${regionId}/channels`);\n    const channelsForRegion = response.data.channels;\n    channels.push(...channelsForRegion);\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regions = ['region1', 'region2', 'region3'];\n  const channelsData = [];\n\n  for (const region of regions) {\n    let page = 1;\n    let channels = [];\n\n    while (true) {\n      const response = await axios.get(`https://api.example.com/channels/${region}?page=${page}`);\n      channels = channels.concat(response.data.channels);\n      if (response.data.channels.length === 0) break;\n      page++;\n    }\n\n    channelsData.push(...channels);\n  }\n\n  return _.uniqBy(channelsData, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regions = ['region1', 'region2', 'region3'];\n  const channels = [];\n\n  for (const region of regions) {\n    const response = await axios.get(`https://api.example.com/channels/${region}`);\n    const pages = response.data.pages;\n    for (let page = 1; page <= pages; page++) {\n      const pageResponse = await axios.get(`https://api.example.com/channels/${region}/page/${page}`);\n      channels.push(...pageResponse.data.channels);\n    }\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst _ = require('lodash');\n\nasync function channels() {\n  const regions = ['region1', 'region2', 'region3'];\n  const channels = [];\n\n  for (const region of regions) {\n    const response = await axios.get(`https://api.tv/${region}`);\n    const pages = response.data.pages;\n    for (const page of pages) {\n      const pageChannels = await axios.get(`https://api.tv/${region}/page/${page}`);\n      channels.push(...pageChannels.data.channels);\n    }\n  }\n\n  return _.uniqBy(channels, 'site_id');\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo, token, sha, ci=None):\n        self.repo = repo.replace('.', '_')\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = \"https://bundlesize-store.now.sh/values\"\n        self.enabled = bool(repo and token)\n\n    def get(self):\n        if not self.enabled:\n            return Promise({})\n\n        try:\n            response = requests.get(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n            return Promise(json.loads(response.text))\n        except requests.RequestException as e:\n            print(f\"Error fetching bundle sizes: {e}\")\n            return Promise({})\n\n    def set(self, values):\n        if not self.enabled:\n            return\n\n        try:\n            response = requests.post(self.url, json=values, headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n        except requests.RequestException as e:\n            print(f\"Error setting bundle sizes: {e}\")\n```",
      "```python\nimport requests\nimport re\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo, token, sha, ci=None):\n        self.repo = self.sanitize_repo(repo)\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = \"https://bundlesize-store.now.sh/values\"\n        self.enabled = bool(repo and token)\n\n    def sanitize_repo(self, repo):\n        return re.sub(r'\\.', '_', repo)\n\n    def get(self):\n        if not self.enabled:\n            return Promise.resolve({})\n        try:\n            response = requests.get(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n            return Promise.resolve(response.json())\n        except Exception as e:\n            print(f\"Error fetching file sizes: {e}\")\n            return Promise.resolve({})\n\n    def set(self, values):\n        if not self.enabled:\n            return\n        try:\n            sanitized_repo = self.sanitize_repo(self.repo)\n            payload = {\"repo\": sanitized_repo, \"sha\": self.sha, \"values\": values}\n            response = requests.post(self.url, json=payload, headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n        except Exception as e:\n            print(f\"Error setting file sizes: {e}\")\n```",
      "```python\nimport requests\nimport re\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo: str, token: str, sha: str, ci: Any, url: str = \"https://bundlesize-store.now.sh/values\"):\n        self.repo = repo\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = url\n        self.enabled = repo and token\n\n    def get(self) -> Promise[Object]:\n        sanitized_repo = re.sub(r'\\.', '_', self.repo)\n        response = requests.get(f\"{self.url}/{sanitized_repo}/{self.sha}\")\n        if response.status_code == 200:\n            return response.json()\n        else:\n            print(f\"Error fetching file sizes: {response.status_code}\")\n            return {}\n\n    def set(self, values: Object) -> None:\n        if not self.enabled:\n            return\n        sanitized_repo = re.sub(r'\\.', '_', self.repo)\n        payload = {\n            \"repo\": sanitized_repo,\n            \"sha\": self.sha,\n            \"values\": values\n        }\n        response = requests.post(self.url, headers={\"Authorization\": f\"Bearer {self.token}\"}, json=payload)\n        if response.status_code != 200:\n            print(f\"Error setting file sizes: {response.status_code}\")\n```",
      "```python\nimport requests\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo: str, token: str, sha: str, ci: Any, url: str = \"https://bundlesize-store.now.sh/values\"):\n        self.repo = repo.replace('.', '_')\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = url\n        self.enabled = bool(repo and token)\n\n    def get(self) -> Promise[Object]:\n        if not self.enabled:\n            return Promise({})\n\n        try:\n            response = requests.get(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n            return response.json()\n        except Exception as e:\n            print(f\"Error fetching file sizes: {e}\")\n            return Promise({})\n\n    def set(self, values: Object) -> None:\n        if not self.enabled:\n            return\n\n        try:\n            response = requests.post(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"}, data=json.dumps(values))\n            response.raise_for_status()\n        except Exception as e:\n            print(f\"Error setting file sizes: {e}\")\n```",
      "```python\nimport requests\nimport re\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo: str, token: str, sha: str, ci: Any = None):\n        self.repo = self.sanitize_repo(repo)\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = \"https://bundlesize-store.now.sh/values\"\n        self.enabled = self.repo and self.token\n\n    def sanitize_repo(self, repo: str) -> str:\n        return re.sub(r'\\.', '_', repo)\n\n    def get(self) -> Promise[Object]:\n        if not self.enabled:\n            return Promise({})\n\n        try:\n            response = requests.get(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n            return response.json()\n        except Exception as e:\n            print(f\"Error retrieving file sizes: {e}\")\n            return Promise({})\n\n    def set(self, values: Object) -> None:\n        if not self.enabled:\n            return\n\n        try:\n            sanitized_repo = self.sanitize_repo(self.repo)\n            payload = {\"repo\": sanitized_repo, \"sha\": self.sha, \"values\": values}\n            response = requests.post(self.url, json=payload, headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n        except Exception as e:\n            print(f\"Error setting file sizes: {e}\")\n```",
      "```python\nimport requests\nimport re\n\nclass BundleSizeAPI:\n    def __init__(self, repo, token, sha, ci=None):\n        self.repo = self.sanitize_repo(repo)\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = \"https://bundlesize-store.now.sh/values\"\n        self.enabled = bool(repo and token)\n\n    def sanitize_repo(self, repo):\n        return re.sub(r'\\.', '_', repo)\n\n    def get(self):\n        if not self.enabled:\n            return Promise.resolve({})\n        try:\n            response = requests.get(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n            return Promise.resolve(response.json())\n        except Exception as e:\n            print(f\"Error retrieving file sizes: {e}\")\n            return Promise.resolve({})\n\n    def set(self, values):\n        if not self.enabled:\n            return\n        try:\n            response = requests.post(f\"{self.url}/{self.repo}/{self.sha}\", json=values, headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n        except Exception as e:\n            print(f\"Error setting file sizes: {e}\")\n```",
      "```python\nimport requests\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo: str, token: str, sha: str, ci: Any, url: str = \"https://bundlesize-store.now.sh/values\"):\n        self.repo = repo.replace('.', '_')\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = url\n        self.enabled = bool(repo and token)\n\n    def get(self) -> Promise[Object]:\n        if not self.enabled:\n            return Promise({})\n\n        try:\n            response = requests.get(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n            return response.json()\n        except Exception as e:\n            print(f\"Error fetching file sizes: {e}\")\n            return Promise({})\n\n    def set(self, values: Object) -> None:\n        if not self.enabled:\n            return\n\n        try:\n            response = requests.post(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"}, data=json.dumps(values))\n            response.raise_for_status()\n        except Exception as e:\n            print(f\"Error setting file sizes: {e}\")\n```",
      "```python\nimport requests\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo, token, sha, ci=None):\n        self.repo = repo.replace('.', '_')\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = \"https://bundlesize-store.now.sh/values\"\n        self.enabled = bool(repo and token)\n\n    def get(self):\n        if not self.enabled:\n            return Promise.resolve({})\n\n        try:\n            response = requests.get(f\"{self.url}/{self.repo}/{self.sha}\", headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n            return Promise.resolve(json.loads(response.text))\n        except Exception as e:\n            print(f\"Error fetching file sizes: {e}\")\n            return Promise.resolve({})\n\n    def set(self, values):\n        if not self.enabled:\n            return\n\n        try:\n            response = requests.post(self.url, json=values, headers={\"Authorization\": f\"Bearer {self.token}\"})\n            response.raise_for_status()\n        except Exception as e:\n            print(f\"Error setting file sizes: {e}\")\n```",
      "```python\nimport requests\nimport re\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo: str, token: str, sha: str, ci: Any, url: str = \"https://bundlesize-store.now.sh/values\"):\n        self.repo = repo\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = url\n        self.enabled = repo and token\n\n    def get(self) -> Promise[Object]:\n        sanitized_repo = re.sub(r'\\.', '_', self.repo)\n        response = requests.get(f\"{self.url}/{sanitized_repo}/{self.sha}\")\n        if response.status_code == 200:\n            return response.json()\n        else:\n            print(f\"Error: {response.status_code}\")\n            return {}\n\n    def set(self, values: Object) -> None:\n        if not self.enabled:\n            return\n        sanitized_repo = re.sub(r'\\.', '_', self.repo)\n        payload = {\n            \"repo\": sanitized_repo,\n            \"sha\": self.sha,\n            \"values\": values\n        }\n        response = requests.post(self.url, headers={\"Authorization\": f\"Bearer {self.token}\"}, json=payload)\n        if response.status_code != 200:\n            print(f\"Error: {response.status_code}\")\n```",
      "```python\nimport requests\nimport re\nimport json\n\nclass BundleSizeAPI:\n    def __init__(self, repo, token, sha, ci=None, url=\"https://bundlesize-store.now.sh/values\"):\n        self.repo = repo\n        self.token = token\n        self.sha = sha\n        self.ci = ci\n        self.url = url\n        self.enabled = repo and token\n\n    def get(self):\n        sanitized_repo = re.sub(r'\\.', '_', self.repo)\n        response = requests.get(f\"{self.url}/{sanitized_repo}/{self.sha}\")\n        if response.status_code == 200:\n            return response.json()\n        else:\n            print(f\"Error fetching file sizes: {response.status_code}\")\n            return {}\n\n    def set(self, values):\n        if not self.enabled:\n            return\n        sanitized_repo = re.sub(r'\\.', '_', self.repo)\n        payload = {\n            \"repo\": sanitized_repo,\n            \"sha\": self.sha,\n            \"values\": values\n        }\n        response = requests.post(self.url, json=payload, headers={\"Authorization\": f\"Bearer {self.token}\"})\n        if response.status_code != 200:\n            print(f\"Error setting file sizes: {response.status_code}\")\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Implement parsing logic here\n    pass\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.RequestException as e:\n        print(f\"Error fetching COVID-19 data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Parse the data here based on the structure of the API response\n    # This is a placeholder for the actual parsing logic\n    return data\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Parse the data as needed\n    return data\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Implement parsing logic here\n    # This function should return the parsed data or raise an error if parsing fails\n    pass\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Placeholder for data parsing logic\n    return data\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Parse the data as needed\n    return data\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.RequestException as e:\n        print(f\"Error fetching COVID-19 data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Parse the data here and return the result\n    # This is a placeholder for the actual parsing logic\n    return data\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Parse the data as needed\n    return data\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Parse the data as needed\n    return data\n```",
      "```python\nimport requests\nimport json\n\ndef fetch_covid_data():\n    url = \"https://api.health.gov.il/covid19/data\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    data = {\n        \"datasets\": [\"updates\", \"patient_statistics\", \"test_results\", \"demographics\"]\n    }\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        return parse_data(response.json())\n    except requests.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        return None\n\ndef parse_data(data):\n    # Placeholder for actual data parsing logic\n    return data\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with optional path extension and error data, then triggers an activity callback based on the request's success or failure.\n\nFunction Description: The function `sendPing` is an asynchronous function that constructs a target URL by combining a base URL and an optional path, then sends an HTTP POST request using Axios. The request includes error data in the payload and a custom user-agent header. Depending on the request's outcome, it triggers a callback function (`triggerActivity`) with a success or failure indicator.\n\nInput:  \n- `url`: [String] - The base URL to which the request will be sent.  \n- `path`: [String] (optional) - An additional path segment to append to the base URL.  \n- `error`: [Any] - Data to be sent as the request payload (typically error information).  \n- `triggerActivity`: [Function] - A callback function to be executed after the request completes, receiving a boolean parameter indicating failure (true) or success (false/undefined).  \n\nOutput:  \n- None (The function's primary effect is the HTTP request and callback execution, not a direct return value).",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function sendPing(url, path, error, triggerActivity) {\n    if (url == null) return;\n    if (path) url += \"/\" + path;\n\n    await axios.post(url, error, {headers: {\"user-agent\": \"MySpeed/HealthAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  const payload = { error };\n  const headers = { 'User-Agent': 'CustomUserAgent' };\n\n  try {\n    await axios.post(targetUrl, payload, { headers });\n    triggerActivity(false);\n  } catch (err) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  const payload = { error };\n  const headers = { 'User-Agent': 'CustomUserAgent' };\n\n  try {\n    await axios.post(targetUrl, payload, { headers });\n    triggerActivity(false);\n  } catch (error) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  try {\n    await axios.post(targetUrl, error, {\n      headers: {\n        'User-Agent': 'CustomUserAgent'\n      }\n    });\n    triggerActivity(false);\n  } catch (err) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  const payload = { error };\n  const headers = { 'User-Agent': 'CustomUserAgent' };\n\n  try {\n    await axios.post(targetUrl, payload, { headers });\n    triggerActivity(false);\n  } catch (error) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  const payload = { error };\n  const headers = { 'User-Agent': 'CustomUserAgent' };\n\n  try {\n    await axios.post(targetUrl, payload, { headers });\n    triggerActivity(false);\n  } catch (error) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  const payload = { error };\n  const headers = { 'User-Agent': 'CustomUserAgent' };\n\n  try {\n    await axios.post(targetUrl, payload, { headers });\n    triggerActivity(false);\n  } catch (error) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  const payload = { error };\n  const headers = { 'User-Agent': 'CustomUserAgent' };\n\n  try {\n    await axios.post(targetUrl, payload, { headers });\n    triggerActivity(false);\n  } catch (error) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  try {\n    await axios.post(targetUrl, error, {\n      headers: {\n        'User-Agent': 'CustomUserAgent'\n      }\n    });\n    triggerActivity(false);\n  } catch (err) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  const payload = { error };\n  const headers = { 'User-Agent': 'CustomUserAgent' };\n\n  try {\n    await axios.post(targetUrl, payload, { headers });\n    triggerActivity(false);\n  } catch (error) {\n    triggerActivity(true);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\n\nasync function sendPing(url, path = '', error, triggerActivity) {\n  const targetUrl = `${url}${path}`;\n  const payload = { error };\n  const headers = { 'User-Agent': 'CustomUserAgent' };\n\n  try {\n    await axios.post(targetUrl, payload, { headers });\n    triggerActivity(false);\n  } catch (error) {\n    triggerActivity(true);\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a function to send emails using different email service providers (Mailgun and Sendgrid) through HTTP requests, with error handling and promise-based asynchronous operation.\n\nFunction Description: The function `sendMail` sends an email using a configured transporter (either Mailgun or Sendgrid). It wraps the transporter's send operation in a Promise for better async handling. The transporter is configured to make HTTP requests to the respective email service API.\n\nInput:\n- `to`: [String] - Recipient email address\n- `subject`: [String] - Email subject\n- `text`: [String] - Email body content\n- `options`: [Object] (optional) - Additional email options (defaults to empty object)\n\nOutput:\n- [Promise] - Resolves with email sending success info, or rejects with an error if sending fails.\n\n---\n\nClass Description: (Not applicable, as the reference code is at the function level)",
    "Canonical_solution": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    transporter.sendMail({\n      from: `\"${ config.plugins.email.name || '' }\" <${ config.plugins.email.email || config.plugins.email.username }>`,\n      to,\n      subject,\n      text,\n    }, (error, info) => {\n      if(error) {\n        return reject(error);\n      }\n      return resolve(info);\n    });\n  });\n}\n\n// External libraries and global variables used:\nconst axios = require('axios');\nconst FormData = require('form-data');\nconst config = appRequire('services/config').all();\nlet transporter;\n\n// Mailgun implementation\ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  const form = new FormData();\n  form.append('from', options.from);\n  form.append('to', options.to);\n  form.append('subject', options.subject);\n  form.append('text', options.text);\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: form.getHeaders(),\n    data: form,\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};\n\n// Sendgrid implementation  \ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${ emailConfig.apiKey }`,\n    },\n    data: {\n      personalizations: [{\n        to: [{ email: options.to }]\n      }],\n      from: { email: options.from },\n      subject: options.subject,\n      content: [{\n        type: 'text/plain',\n        value: options.text,\n      }]\n    },\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [
      "```javascript\nconst axios = require('axios');\n\nfunction sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = options.service === 'Mailgun' ? mailgunTransporter : sendgridTransporter;\n    transporter.sendMail({ to, subject, text, ...options }, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}\n\nconst mailgunTransporter = (options) => {\n  return {\n    sendMail: (mailOptions, callback) => {\n      axios.post('https://api.mailgun.net/v3/sandbox-some-email@example.com/messages', {\n        from: options.from,\n        to: mailOptions.to,\n        subject: mailOptions.subject,\n        text: mailOptions.text\n      }, {\n        auth: {\n          username: 'api-key',\n          password: options.apiKey\n        }\n      }).then(response => callback(null, response.data))\n        .catch(error => callback(error));\n    }\n  };\n};\n\nconst sendgridTransporter = (options) => {\n  return {\n    sendMail: (mailOptions, callback) => {\n      axios.post('https://api.sendgrid.com/v3/mail/send', {\n        from: options.from,\n        subject: mailOptions.subject,\n        content: [{ type: 'text/plain', value: mailOptions.text }]\n      }, {\n        auth: {\n          username: 'api-key',\n          password: options.apiKey\n        }\n      }).then(response => callback(null, response.data))\n        .catch(error => callback(error));\n    }\n  };\n};\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst nodemailer = require('nodemailer');\n\nfunction sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}\n```",
      "```javascript\nconst nodemailer = require('nodemailer');\n\nfunction sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}\n```",
      "```javascript\nconst nodemailer = require('nodemailer');\n\nfunction sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}\n```",
      "```javascript\nconst nodemailer = require('nodemailer');\n\nfunction sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}\n```",
      "```javascript\nconst nodemailer = require('nodemailer');\n\nfunction sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}\n```",
      "```javascript\nconst nodemailer = require('nodemailer');\n\nfunction sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}\n```",
      "```javascript\nconst nodemailer = require('nodemailer');\n\nconst sendMail = (to, subject, text, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n};\n```",
      "```javascript\nconst nodemailer = require('nodemailer');\n\nconst sendMail = (to, subject, text, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n};\n```",
      "```javascript\nconst nodemailer = require('nodemailer');\n\nconst sendMail = (to, subject, text, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const transporter = nodemailer.createTransport({\n      service: options.service || 'Mailgun',\n      auth: {\n        user: options.user,\n        pass: options.pass\n      }\n    });\n\n    const mailOptions = {\n      from: options.from || 'you@example.com',\n      to: to,\n      subject: subject,\n      text: text\n    };\n\n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n};\n```"
    ],
    "match_count": 1,
    "pass@3": 0.30000000000000004,
    "pass@5": 0.5
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "async function fetchTVChannelData() {\n  const response = await fetch('https://api.example.com/tv/channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channel data:', response.status);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/tv-channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.status);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/tv-channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.statusText);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/tv/channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.statusText);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/tv-channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.statusText);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.statusText);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.status);\n    return [];\n  }\n  const data = await response.json();\n  return data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/tv-channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.statusText);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.statusText);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}",
      "async function fetchTVChannels() {\n  const response = await fetch('https://api.example.com/channels');\n  if (!response.ok) {\n    console.error('Failed to fetch TV channels:', response.statusText);\n    return [];\n  }\n  const data = await response.json();\n  const channels = data.channels.map(channel => ({\n    lang: 'sq',\n    site_id: channel.site_id,\n    name: channel.name\n  }));\n  return channels;\n}"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a function that downloads icons from a specified URL, processes them, and handles potential duplicates while maintaining error handling and callback functionality.\n\nFunction Description: The `downloadIcons` function downloads icon data from a given URL, processes the icons to extract relevant information, checks for duplicate names, and downloads the SVG files. It handles errors appropriately and uses a callback to return the processed data or errors. The function also supports configuration for handling duplicates and customizing the download process.\n\nInput:  \n- `url` [String] - The URL from which to download the icon data.  \n- `style` [String] - The style of the icons (e.g., \"solid\", \"outline\").  \n- `callback` [Function] - A callback function that handles the processed data or errors. The callback signature is `(error, data)`.  \n\nOutput:  \n- The function does not return a value directly but invokes the `callback` with either:  \n  - An error object if an error occurs during the process.  \n  - An array of processed icon data objects sorted by name if successful. Each object includes details like `name`, `svg`, `category`, `style`, `tags`, `code`, `unicode`, and `pro` status.  \n\nAdditional Notes:  \n- The function uses Axios for HTTP requests and includes default headers for JSON acceptance and credentials.  \n- Duplicate handling is optional and can be controlled via the `breakOnError` flag (not shown in inputs but implied by the reference code).  \n- Downloaded SVGs are saved to a specified directory (`targetImagePath`), and metadata is compiled into an array for the callback.  \n- Error handling includes logging and callback invocation with errors, as well as file operations for duplicate tracking.",
    "Canonical_solution": "const axios = require('axios')\n\nfunction downloadIcons(url, style, callback) {\n  axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest'\n  axios.defaults.headers.common['Accept'] = 'application/json'\n  axios.defaults.withCredentials = true\n\n  axios.get(url).then((response) => {\n    const data = []\n    const icons = response.data.response.unicons.map((item) => ({\n      ...item,\n      allTags: item.name,\n      name: item.tags[item.tags.length - 1],\n    }))\n\n    const names = icons.map((icon) => icon.name)\n    const uniqueNames = uniq(names)\n    const repeated = countDuplicates(names)\n    const duplicates = filter(repeated, (item) => item.count > 1)\n\n    if (duplicates.length && breakOnError) {\n      console.log(\n        `Total Icons: ${names.length}, Unique Names: ${uniqueNames.length}`\n      )\n\n      console.log(`${style} Duplicates:`, duplicates)\n\n      let dupFiles = []\n      duplicates.forEach((d) => {\n        dupFiles = [...dupFiles, ...filter(icons, { name: d.value })]\n      })\n\n      fs.writeFileSync(\n        `${style}-duplicates.json`,\n        JSON.stringify(dupFiles),\n        'utf-8'\n      )\n\n      throw new Error('There are duplicate files')\n    }\n\n    eachLimit(\n      icons,\n      50,\n      async (row) => {\n        const url = row.svg\n        const name = row.name\n        const fileName = `${name}.svg`\n        const filePath = path.resolve(targetImagePath, fileName)\n\n        try {\n          await downloadImage(url, filePath)\n\n          const charCodeExists = existingConfig.find((i) => i.name === name)\n          const charCode =\n            charCodeExists && charCodeExists.code\n              ? charCodeExists.code\n              : startCharCode++\n\n          data.push({\n            uuid: row.uuid,\n            id: row.id,\n            name: name,\n            svg: `svg/${style}/${fileName}`,\n            category: row.category,\n            style: upperFirst(style),\n            tags: row.tags,\n            code: charCode,\n            unicode: charCode.toString(16),\n            pro: Boolean(row.price),\n          })\n        } catch (error) {\n          console.error(error)\n          console.log('Error Downloading:', name)\n        }\n      },\n      (err, results) => {\n        if (err) {\n          console.log(results)\n          throw err\n        }\n\n        console.log(`${data.length} Images Downloaded!`)\n        callback(null, sortBy(data, 'name'))\n      }\n    )\n  }).catch(err => {\n    callback(err)\n  })\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback, breakOnError = false) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const targetImagePath = path.join(__dirname, 'icons');\n\n    if (!fs.existsSync(targetImagePath)) {\n      fs.mkdirSync(targetImagePath);\n    }\n\n    const iconNames = new Set();\n\n    icons.forEach(icon => {\n      if (iconNames.has(icon.name)) {\n        if (breakOnError) {\n          throw new Error(`Duplicate icon name found: ${icon.name}`);\n        }\n        return;\n      }\n      iconNames.add(icon.name);\n\n      const svgPath = path.join(targetImagePath, `${icon.name}.svg`);\n      fs.writeFileSync(svgPath, icon.svg);\n\n      processedIcons.push({\n        name: icon.name,\n        svg: icon.svg,\n        category: icon.category,\n        style: style,\n        tags: icon.tags,\n        code: icon.code,\n        unicode: icon.unicode,\n        pro: icon.pro\n      });\n    });\n\n    callback(null, processedIcons.sort((a, b) => a.name.localeCompare(b.name)));\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback, breakOnError = false) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const targetImagePath = path.join(__dirname, 'icons');\n\n    if (!fs.existsSync(targetImagePath)) {\n      fs.mkdirSync(targetImagePath);\n    }\n\n    const iconNames = new Set();\n\n    for (const icon of icons) {\n      if (iconNames.has(icon.name)) {\n        if (breakOnError) {\n          throw new Error(`Duplicate icon name found: ${icon.name}`);\n        }\n        continue;\n      }\n\n      iconNames.add(icon.name);\n\n      const svgPath = path.join(targetImagePath, `${icon.name}.svg`);\n      const svgData = icon.svg;\n      fs.writeFileSync(svgPath, svgData);\n\n      processedIcons.push({\n        name: icon.name,\n        svg: svgData,\n        category: icon.category,\n        style: style,\n        tags: icon.tags,\n        code: icon.code,\n        unicode: icon.unicode,\n        pro: icon.pro\n      });\n    }\n\n    callback(null, processedIcons.sort((a, b) => a.name.localeCompare(b.name)));\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback, breakOnError = false) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const seenNames = new Set();\n\n    for (const icon of icons) {\n      if (seenNames.has(icon.name) && breakOnError) {\n        throw new Error(`Duplicate icon name found: ${icon.name}`);\n      }\n\n      seenNames.add(icon.name);\n\n      const svgPath = path.join(targetImagePath, `${icon.name}.svg`);\n      const svgData = icon.svg;\n      fs.writeFileSync(svgPath, svgData);\n\n      const processedIcon = {\n        name: icon.name,\n        svg: svgData,\n        category: icon.category,\n        style: style,\n        tags: icon.tags,\n        code: icon.code,\n        unicode: icon.unicode,\n        pro: icon.pro\n      };\n\n      processedIcons.push(processedIcon);\n    }\n\n    callback(null, processedIcons.sort((a, b) => a.name.localeCompare(b.name)));\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback, breakOnError = false) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const seenNames = new Set();\n\n    for (const icon of icons) {\n      if (seenNames.has(icon.name)) {\n        if (breakOnError) {\n          throw new Error(`Duplicate icon name found: ${icon.name}`);\n        }\n        continue;\n      }\n      seenNames.add(icon.name);\n\n      const svgPath = path.join(targetImagePath, `${icon.name}.svg`);\n      const svgData = icon.svg;\n      fs.writeFileSync(svgPath, svgData);\n\n      processedIcons.push({\n        name: icon.name,\n        svg: svgData,\n        category: icon.category,\n        style: style,\n        tags: icon.tags,\n        code: icon.code,\n        unicode: icon.unicode,\n        pro: icon.pro\n      });\n    }\n\n    callback(null, processedIcons.sort((a, b) => a.name.localeCompare(b.name)));\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback, breakOnError = false) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const seenNames = new Set();\n\n    for (const icon of icons) {\n      if (seenNames.has(icon.name)) {\n        if (breakOnError) {\n          throw new Error(`Duplicate icon name found: ${icon.name}`);\n        }\n        continue;\n      }\n      seenNames.add(icon.name);\n\n      const svgPath = path.join(targetImagePath, `${icon.name}.svg`);\n      const svgData = icon.svg;\n      fs.writeFileSync(svgPath, svgData);\n\n      const processedIcon = {\n        name: icon.name,\n        svg: svgData,\n        category: icon.category,\n        style: style,\n        tags: icon.tags,\n        code: icon.code,\n        unicode: icon.unicode,\n        pro: icon.pro\n      };\n\n      processedIcons.push(processedIcon);\n    }\n\n    callback(null, processedIcons.sort((a, b) => a.name.localeCompare(b.name)));\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback, breakOnError = false) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const targetImagePath = path.join(__dirname, 'icons');\n\n    if (!fs.existsSync(targetImagePath)) {\n      fs.mkdirSync(targetImagePath);\n    }\n\n    const iconNames = new Set();\n\n    icons.forEach(icon => {\n      if (iconNames.has(icon.name)) {\n        if (breakOnError) {\n          throw new Error(`Duplicate icon name found: ${icon.name}`);\n        }\n        return;\n      }\n      iconNames.add(icon.name);\n\n      const svgPath = path.join(targetImagePath, `${icon.name}.svg`);\n      fs.writeFileSync(svgPath, icon.svg);\n\n      processedIcons.push({\n        name: icon.name,\n        svg: icon.svg,\n        category: icon.category,\n        style: style,\n        tags: icon.tags,\n        code: icon.code,\n        unicode: icon.unicode,\n        pro: icon.pro\n      });\n    });\n\n    processedIcons.sort((a, b) => a.name.localeCompare(b.name));\n    callback(null, processedIcons);\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const seenNames = new Set();\n\n    for (const icon of icons) {\n      if (seenNames.has(icon.name)) {\n        if (breakOnError) {\n          throw new Error(`Duplicate icon name found: ${icon.name}`);\n        }\n        continue;\n      }\n      seenNames.add(icon.name);\n\n      const svgPath = path.join(targetImagePath, `${icon.name}.svg`);\n      const svgData = icon.svg;\n      fs.writeFileSync(svgPath, svgData);\n\n      const processedIcon = {\n        name: icon.name,\n        svg: svgData,\n        category: icon.category,\n        style: style,\n        tags: icon.tags,\n        code: icon.code,\n        unicode: icon.unicode,\n        pro: icon.pro\n      };\n\n      processedIcons.push(processedIcon);\n    }\n\n    processedIcons.sort((a, b) => a.name.localeCompare(b.name));\n    callback(null, processedIcons);\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const seenNames = new Set();\n\n    for (const icon of icons) {\n      const { name, svg, category, tags, code, unicode, pro } = icon;\n      const iconPath = path.join(targetImagePath, `${name}.svg`);\n      const isDuplicate = seenNames.has(name);\n\n      if (isDuplicate && breakOnError) {\n        throw new Error(`Duplicate icon name: ${name}`);\n      }\n\n      if (!isDuplicate) {\n        seenNames.add(name);\n        fs.writeFileSync(iconPath, svg);\n      }\n\n      processedIcons.push({\n        name,\n        svg,\n        category,\n        style,\n        tags,\n        code,\n        unicode,\n        pro\n      });\n    }\n\n    callback(null, processedIcons.sort((a, b) => a.name.localeCompare(b.name)));\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction downloadIcons(url, style, callback) {\n  const headers = {\n    'Accept': 'application/json',\n    'Authorization': 'Bearer your-token-here'\n  };\n\n  axios.get(url, { headers })\n    .then(response => {\n      const icons = response.data.icons;\n      const processedIcons = [];\n      const targetImagePath = path.join(__dirname, 'icons');\n\n      if (!fs.existsSync(targetImagePath)) {\n        fs.mkdirSync(targetImagePath);\n      }\n\n      icons.forEach(icon => {\n        const { name, svg, category, tags, code, unicode, pro } = icon;\n        const svgPath = path.join(targetImagePath, `${name}.svg`);\n        const iconData = { name, svg, category, style, tags, code, unicode, pro };\n\n        if (fs.existsSync(svgPath)) {\n          if (breakOnError) {\n            callback(new Error(`Duplicate icon found: ${name}`), null);\n            return;\n          }\n        } else {\n          fs.writeFileSync(svgPath, svg);\n          processedIcons.push(iconData);\n        }\n      });\n\n      processedIcons.sort((a, b) => a.name.localeCompare(b.name));\n      callback(null, processedIcons);\n    })\n    .catch(error => {\n      callback(error, null);\n    });\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst fs = require('fs');\nconst path = require('path');\n\nasync function downloadIcons(url, style, callback, breakOnError = false) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      }\n    });\n\n    const icons = response.data.icons;\n    const processedIcons = [];\n    const targetImagePath = path.join(__dirname, 'icons');\n\n    if (!fs.existsSync(targetImagePath)) {\n      fs.mkdirSync(targetImagePath);\n    }\n\n    const uniqueIcons = new Set();\n\n    for (const icon of icons) {\n      const { name, svg, category, tags, code, unicode, pro } = icon;\n      const iconPath = path.join(targetImagePath, `${name}.svg`);\n      const iconData = { name, svg, category, style, tags, code, unicode, pro };\n\n      if (uniqueIcons.has(name)) {\n        if (breakOnError) {\n          throw new Error(`Duplicate icon name found: ${name}`);\n        }\n        continue;\n      }\n\n      uniqueIcons.add(name);\n\n      fs.writeFileSync(iconPath, svg);\n      processedIcons.push(iconData);\n    }\n\n    processedIcons.sort((a, b) => a.name.localeCompare(b.name));\n    callback(null, processedIcons);\n  } catch (error) {\n    callback(error, null);\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a function that retrieves TV channel information from multiple providers and returns a list of unique channels.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers and parameters)\n\nOutput: Array of objects - Returns an array of channel objects containing language, name, and site_id (deduplicated by site_id). Each channel object has the following structure:\n{\n    lang: string,    // Language code ('fr' for French)\n    name: string,    // Channel name\n    site_id: string  // Unique identifier combining channel number and slug\n}",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3', '-4', '-5']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.tvcesoir.fr/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'France',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 2155,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'fr',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'https://provider1.com/tv-guide', postParams: { provider: 'provider1' } },\n        { url: 'https://provider2.com/tv-guide', postParams: { provider: 'provider2' } }\n    ];\n\n    const channelInfoPromises = providers.map(provider => axios.post(provider.url, provider.postParams));\n    const channelInfoResponses = await Promise.all(channelInfoPromises);\n\n    const channels = channelInfoResponses.map(response => {\n        const $ = cheerio.load(response.data);\n        return $(selector).map((index, element) => ({\n            lang: $(element).attr('lang'),\n            name: $(element).text(),\n            site_id: $(element).attr('data-site-id')\n        })).get();\n    });\n\n    return _.uniqBy(_.flatten(channels), 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'http://provider1.com/tv-guide', postParams: { provider: 'provider1' } },\n        { url: 'http://provider2.com/tv-guide', postParams: { provider: 'provider2' } }\n    ];\n\n    const channelPromises = providers.map(provider => axios.post(provider.url, provider.postParams));\n    const channelResponses = await Promise.all(channelPromises);\n\n    const channels = channelResponses.map(response => {\n        const $ = cheerio.load(response.data);\n        return $(response.data).find('channel').map((index, element) => ({\n            lang: $(element).attr('lang'),\n            name: $(element).text(),\n            site_id: $(element).attr('number') + '-' + $(element).attr('slug')\n        })).get();\n    }).flat();\n\n    return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'http://provider1.com/tv-guide', channelNumber: '1', slug: 'channel1' },\n        { url: 'http://provider2.com/tv-guide', channelNumber: '2', slug: 'channel2' },\n        { url: 'http://provider3.com/tv-guide', channelNumber: '3', slug: 'channel3' }\n    ];\n\n    const channels = [];\n\n    for (const provider of providers) {\n        const response = await axios.post(provider.url, {\n            channelNumber: provider.channelNumber,\n            slug: provider.slug\n        });\n\n        const $ = cheerio.load(response.data);\n        const channelList = $('div.channel').map((i, element) => {\n            return {\n                lang: $(element).attr('data-lang'),\n                name: $(element).text(),\n                site_id: `${provider.channelNumber}-${provider.slug}`\n            };\n        }).get();\n\n        channels.push(...channelList);\n    }\n\n    return _.uniqBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'http://provider1.com/tv-guide', postParams: { provider: 'provider1' } },\n        { url: 'http://provider2.com/tv-guide', postParams: { provider: 'provider2' } }\n    ];\n\n    const channelPromises = providers.map(provider => axios.post(provider.url, provider.postParams));\n    const channelResponses = await Promise.all(channelPromises);\n\n    const channels = channelResponses.map(response => {\n        const $ = cheerio.load(response.data);\n        return $(response.data).find('channel').map((index, element) => ({\n            lang: $(element).attr('lang'),\n            name: $(element).text(),\n            site_id: $(element).attr('number') + '-' + $(element).attr('slug')\n        })).get();\n    });\n\n    return _.unionBy(channels, 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'https://provider1.com/tv-guide', postParams: { provider: 'provider1' } },\n        { url: 'https://provider2.com/tv-guide', postParams: { provider: 'provider2' } }\n    ];\n\n    const channelPromises = providers.map(provider => axios.post(provider.url, provider.postParams));\n    const channelResponses = await Promise.all(channelPromises);\n\n    const channels = channelResponses.map(response => {\n        const $ = cheerio.load(response.data);\n        return $(response.data).find('channel').map((index, element) => ({\n            lang: $(element).attr('lang'),\n            name: $(element).text(),\n            site_id: $(element).attr('number') + '-' + $(element).attr('slug')\n        })).get();\n    });\n\n    return _.uniqBy(_.flatten(channels), 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'http://provider1.com/tv-guide', postParams: { provider: 'provider1' } },\n        { url: 'http://provider2.com/tv-guide', postParams: { provider: 'provider2' } }\n    ];\n\n    const channelPromises = providers.map(provider => axios.post(provider.url, provider.postParams));\n    const channelResponses = await Promise.all(channelPromises);\n\n    const channels = channelResponses.map(response => {\n        const $ = cheerio.load(response.data);\n        return $(selector).map((i, elem) => ({\n            lang: $(elem).attr('lang'),\n            name: $(elem).text(),\n            site_id: $(elem).attr('data-site-id')\n        })).get();\n    });\n\n    return _.uniqBy(_.flatten(channels), 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'https://provider1.com/tv-guide', postParams: { provider: 'provider1' } },\n        { url: 'https://provider2.com/tv-guide', postParams: { provider: 'provider2' } }\n    ];\n\n    const channelPromises = providers.map(provider => axios.post(provider.url, provider.postParams));\n    const channelResponses = await Promise.all(channelPromises);\n\n    const channels = channelResponses.map(response => {\n        const $ = cheerio.load(response.data);\n        return $(response.data).find('channel').map((index, element) => ({\n            lang: $(element).attr('lang'),\n            name: $(element).text(),\n            site_id: $(element).attr('number') + '-' + $(element).attr('slug')\n        })).get();\n    });\n\n    return _.uniqBy(_.flatten(channels), 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'http://provider1.com/tv-guide', postParams: { provider: 'provider1' } },\n        { url: 'http://provider2.com/tv-guide', postParams: { provider: 'provider2' } }\n    ];\n\n    const channelPromises = providers.map(provider => axios.post(provider.url, provider.postParams));\n    const channelResponses = await Promise.all(channelPromises);\n\n    const channels = channelResponses.map(response => {\n        const $ = cheerio.load(response.data);\n        return $(response.data).find('channel').map((index, element) => ({\n            lang: $(element).attr('lang'),\n            name: $(element).text(),\n            site_id: $(element).attr('number') + '-' + $(element).attr('slug')\n        })).get();\n    });\n\n    return _.uniqBy(_.flatten(channels), 'site_id');\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n  const providers = [\n    { url: 'http://provider1.com/tv-guide', params: { lang: 'fr' } },\n    { url: 'http://provider2.com/tv-guide', params: { lang: 'fr' } },\n    { url: 'http://provider3.com/tv-guide', params: { lang: 'fr' } }\n  ];\n\n  const channelPromises = providers.map(provider => axios.post(provider.url, provider.params));\n  const channelResponses = await Promise.all(channelPromises);\n  const channels = channelResponses.map(response => cheerio.load(response.data)('channel').map((i, channel) => ({\n    lang: 'fr',\n    name: $(channel).find('name').text(),\n    site_id: $(channel).find('number').text() + '-' + $(channel).find('slug').text()\n  })));\n\n  return _.flatten(channels).reduce((uniqueChannels, channel) => {\n    const existingChannel = uniqueChannels.find(c => c.site_id === channel.site_id);\n    if (!existingChannel) {\n      uniqueChannels.push(channel);\n    }\n    return uniqueChannels;\n  }, []);\n}\n```",
      "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getUniqueChannels() {\n    const providers = [\n        { url: 'http://provider1.com/tv-guide', postParams: { provider: 'provider1' } },\n        { url: 'http://provider2.com/tv-guide', postParams: { provider: 'provider2' } }\n    ];\n\n    const channelPromises = providers.map(provider => axios.post(provider.url, provider.postParams));\n    const channelResponses = await Promise.all(channelPromises);\n    const channels = channelResponses.map(response => cheerio.load(response.data)('.channel').map((i, channel) => ({\n        lang: $(channel).attr('data-lang'),\n        name: $(channel).text(),\n        site_id: $(channel).attr('data-channel-number') + '-' + $(channel).attr('data-slug')\n    })));\n\n    return _.flatten(channels).reduce((uniqueChannels, channel) => {\n        const existingChannel = uniqueChannels.find(c => c.site_id === channel.site_id);\n        if (!existingChannel) {\n            uniqueChannels.push(channel);\n        }\n        return uniqueChannels;\n    }, []);\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a function to download a video file from a given URL and save it with a specified description as the filename.\n\nFunction Description: The function `downloadVideo` initiates an asynchronous HTTP GET request to download a video file from the provided URL. It handles the response as a binary blob, creates a downloadable link, and triggers the download automatically. The function includes error handling for empty URLs and checks for successful request completion.\n\nInput:\n- `url` (String): The URL of the video file to be downloaded.\n- `desc` (String): The description to be used as the filename for the downloaded video.\n\nOutput: None (The function triggers a file download but does not return any value.)",
    "Canonical_solution": "function downloadVideo(url, desc) {\n    if (isEmpty(url)) {\n        layer.msg('æš‚æ— æ•°æ®');\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\n    xhr.setRequestHeader(\"Access-Control-Allow-Credentials\", true);\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            let blob = this.response;\n            let u = window.URL.createObjectURL(new Blob([blob]));\n            let a = document.createElement('a');\n            a.download = desc + '.mp4';\n            a.href = u;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  window.URL.revokeObjectURL(a.href);\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error('Failed to fetch video');\n    }\n    const blob = await response.blob();\n    const a = document.createElement('a');\n    a.href = window.URL.createObjectURL(blob);\n    a.download = desc + '.mp4';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n  } catch (error) {\n    console.error('Error downloading video:', error);\n  }\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  window.URL.revokeObjectURL(a.href);\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  window.URL.revokeObjectURL(a.href);\n}\n```",
      "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    throw new Error('URL is required');\n  }\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch video');\n  }\n  const blob = await response.blob();\n  const a = document.createElement('a');\n  a.href = window.URL.createObjectURL(blob);\n  a.download = desc + '.mp4';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  window.URL.revokeObjectURL(a.href);\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isSurge) {\n            $notification.post(title, subtitle, message, option);\n        } else if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (this._node) {\n            const { Notification } = require('electron');\n            new Notification(option).show(title, subtitle, message);\n        }\n    }\n\n    write(value, key) {\n        if (this._isSurge) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._isQuanX) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._node) {\n            const fs = require('fs');\n            fs.writeFileSync(key, value);\n            return true;\n        }\n        return false;\n    }\n\n    read(key) {\n        if (this._isSurge) {\n            return $prefs.valueForKey(key);\n        } else if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._node) {\n            const fs = require('fs');\n            return fs.readFileSync(key, 'utf8');\n        }\n        return null;\n    }\n\n    get(options, callback) {\n        if (this._isSurge) {\n            $http.get(options, (response) => {\n                this.isResponse = true;\n                callback(response);\n            });\n        } else if (this._isQuanX) {\n            $http.get(options, (response) => {\n                this.isResponse = true;\n                callback(response);\n            });\n        } else if (this._node) {\n            const http = require('http');\n            const options = typeof options === 'string' ? { hostname: options } : options;\n            http.get(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback({ statusCode: res.statusCode, data: data });\n                });\n            }).on('error', (err) => {\n                callback({ statusCode: 500, data: err.message });\n            });\n        }\n    }\n\n    post(options, callback) {\n        if (this._isSurge) {\n            $http.post(options, (response) => {\n                this.isResponse = true;\n                callback(response);\n            });\n        } else if (this._isQuanX) {\n            $http.post(options, (response) => {\n                this.isResponse = true;\n                callback(response);\n            });\n        } else if (this._node) {\n            const http = require('http');\n            const options = typeof options === 'string' ? { hostname: options } : options;\n            const postdata = JSON.stringify(options.data);\n            const req = http.post(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback({ statusCode: res.statusCode, data: data });\n                });\n            });\n            req.on('error', (err) => {\n                callback({ statusCode: 500, data: err.message });\n            });\n            req.write(postdata);\n            req.end();\n        }\n    }\n\n    _status(response) {\n        if (this._isSurge || this._isQuanX) {\n            return { statusCode: response.statusCode };\n        } else if (this._node) {\n            return { statusCode: response.statusCode };\n        }\n        return { statusCode: 500 };\n    }\n\n    detectEnvironment() {\n        if (typeof $prefs !== 'undefined') {\n            this._isSurge = true;\n        } else if (typeof $notify !== 'undefined') {\n            this._isQuanX = true;\n        } else if (typeof require !== 'undefined') {\n            this._node = true;\n        }\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    detectEnvironment() {\n        if (typeof module !== 'undefined' && module.exports) {\n            this._node = true;\n        } else if (typeof $response !== 'undefined') {\n            this._isQuanX = true;\n            this.isResponse = true;\n        } else if (typeof $ !== 'undefined') {\n            this._isSurge = true;\n            this.isResponse = true;\n        }\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isSurge) {\n            $notify(title, subtitle, message, option);\n        } else if (this._node) {\n            console.log(title, subtitle, message, option);\n        }\n    }\n\n    write(value, key) {\n        if (this._isQuanX) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._isSurge) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._node) {\n            try {\n                require('fs').writeFileSync(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    read(key) {\n        if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._isSurge) {\n            return $prefs.valueForKey(key);\n        } else if (this._node) {\n            try {\n                return require('fs').readFileSync(key, 'utf8');\n            } catch (e) {\n                return '';\n            }\n        }\n        return '';\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            $task.fetch({\n                url: options.url,\n                headers: options.headers,\n                timeout: options.timeout\n            }).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._isSurge) {\n            $http.get(options.url, options.headers).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._node) {\n            const http = require('http');\n            const options = {\n                hostname: options.url.hostname,\n                port: options.url.port,\n                path: options.url.path,\n                method: 'GET',\n                headers: options.headers\n            };\n            const req = http.request(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, {\n                        statusCode: res.statusCode,\n                        data: data\n                    });\n                });\n            });\n            req.on('error', (e) => {\n                callback(e, null);\n            });\n            req.end();\n        }\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            $task.fetch({\n                url: options.url,\n                method: 'POST',\n                headers: options.headers,\n                body: options.body,\n                timeout: options.timeout\n            }).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._isSurge) {\n            $http.post(options.url, options.body, options.headers).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._node) {\n            const http = require('http');\n            const options = {\n                hostname: options.url.hostname,\n                port: options.url.port,\n                path: options.url.path,\n                method: 'POST',\n                headers: {\n                    ...options.headers,\n                    'Content-Length': Buffer.byteLength(options.body)\n                }\n            };\n            const req = http.request(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, {\n                        statusCode: res.statusCode,\n                        data: data\n                    });\n                });\n            });\n            req.on('error', (e) => {\n                callback(e, null);\n            });\n            req.write(options.body);\n            req.end();\n        }\n    }\n\n    _status(response) {\n        if (this._isQuanX) {\n            return {\n                statusCode: response.statusCode,\n                statusMessage: response.statusMessage\n            };\n        } else if (this._isSurge) {\n            return {\n                statusCode: response.statusCode,\n                statusMessage: response.statusMessage\n            };\n        } else if (this._node) {\n            return {\n                statusCode: response.statusCode,\n                statusMessage: response.statusMessage\n            };\n        }\n        return {\n            statusCode: 0,\n            statusMessage: 'Unknown'\n        };\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    detectEnvironment() {\n        if (typeof module !== 'undefined' && module.exports) {\n            this._node = true;\n        } else if (typeof $response !== 'undefined') {\n            this._isQuanX = true;\n            this.isResponse = true;\n        } else if (typeof $ !== 'undefined') {\n            this._isSurge = true;\n            this.isResponse = true;\n        }\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isSurge) {\n            $notify(title, subtitle, message, option);\n        } else if (this._node) {\n            console.log(title, subtitle, message);\n        }\n    }\n\n    write(value, key) {\n        if (this._node) {\n            try {\n                require('fs').writeFileSync(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        } else if (this._isSurge) {\n            try {\n                $write(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        } else if (this._isQuanX) {\n            try {\n                $write(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    read(key) {\n        if (this._node) {\n            try {\n                return require('fs').readFileSync(key, 'utf8');\n            } catch (e) {\n                return '';\n            }\n        } else if (this._isSurge) {\n            try {\n                return $read(key);\n            } catch (e) {\n                return '';\n            }\n        } else if (this._isQuanX) {\n            try {\n                return $read(key);\n            } catch (e) {\n                return '';\n            }\n        }\n        return '';\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            $http({\n                method: 'GET',\n                url: options,\n                headers: options.headers,\n                body: options.body\n            }, callback);\n        } else if (this._isSurge) {\n            $http({\n                method: 'GET',\n                url: options,\n                headers: options.headers,\n                body: options.body\n            }, callback);\n        } else if (this._node) {\n            const http = require('http');\n            const options = typeof options === 'string' ? { url: options } : options;\n            http.get(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, { statusCode: res.statusCode, data: data });\n                });\n            }).on('error', (e) => {\n                callback(e, null);\n            });\n        }\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            $http({\n                method: 'POST',\n                url: options.url,\n                headers: options.headers,\n                body: options.body\n            }, callback);\n        } else if (this._isSurge) {\n            $http({\n                method: 'POST',\n                url: options.url,\n                headers: options.headers,\n                body: options.body\n            }, callback);\n        } else if (this._node) {\n            const http = require('http');\n            const options = typeof options === 'string' ? { url: options } : options;\n            const req = http.post(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, { statusCode: res.statusCode, data: data });\n                });\n            }).on('error', (e) => {\n                callback(e, null);\n            });\n            if (options.body) {\n                req.write(options.body);\n            }\n            req.end();\n        }\n    }\n\n    _status(response) {\n        if (this._isQuanX) {\n            return { statusCode: response.statusCode };\n        } else if (this._isSurge) {\n            return { statusCode: response.statusCode };\n        } else if (this._node) {\n            return { statusCode: response.statusCode };\n        }\n        return { statusCode: 0 };\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isSurge) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isQuanX) {\n            $notification.post(title, subtitle, message, option);\n        } else if (this._node) {\n            this._node.child_process.exec(`osascript -e 'display notification \"${title}\" with title \"${subtitle}\" subtitle \"${message}\"'`, (error, stdout, stderr) => {\n                if (error) {\n                    console.error(`exec error: ${error}`);\n                    return;\n                }\n                if (stderr) {\n                    console.error(`stderr: ${stderr}`);\n                    return;\n                }\n                console.log(`stdout: ${stdout}`);\n            });\n        }\n    }\n\n    write(value, key) {\n        if (this._isSurge) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._isQuanX) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._node) {\n            try {\n                require('fs').writeFileSync(`./${key}.txt`, value);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    read(key) {\n        if (this._isSurge) {\n            return $prefs.valueForKey(key);\n        } else if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._node) {\n            try {\n                return require('fs').readFileSync(`./${key}.txt`, 'utf8');\n            } catch (error) {\n                return '';\n            }\n        }\n        return '';\n    }\n\n    get(options, callback) {\n        this.makeRequest('GET', options, callback);\n    }\n\n    post(options, callback) {\n        this.makeRequest('POST', options, callback);\n    }\n\n    _status(response) {\n        if (this._isSurge || this._isQuanX) {\n            return { status: response.status };\n        } else if (this._node) {\n            return { status: response.statusCode };\n        }\n        return { status: 0 };\n    }\n\n    makeRequest(method, options, callback) {\n        if (this._isSurge) {\n            $http(method, options, (response) => {\n                callback(this._status(response));\n            });\n        } else if (this._isQuanX) {\n            $http(method, options, (response) => {\n                callback(this._status(response));\n            });\n        } else if (this._node) {\n            const http = require('http');\n            const options = typeof options === 'string' ? { hostname: options } : options;\n            const req = http.request(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(this._status({ statusCode: res.statusCode, data: data }));\n                });\n            });\n            req.on('error', (e) => {\n                callback({ status: 0 });\n            });\n            req.end();\n        }\n    }\n\n    detectEnvironment() {\n        if (typeof $prefs !== 'undefined') {\n            this._isSurge = true;\n        } else if (typeof $notification !== 'undefined') {\n            this._isQuanX = true;\n        } else if (typeof require !== 'undefined') {\n            this._node = require;\n        }\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    detectEnvironment() {\n        if (typeof module !== 'undefined' && module.exports) {\n            this._node = true;\n        } else if (typeof importScripts !== 'undefined') {\n            this._isSurge = true;\n        } else if (typeof $response !== 'undefined') {\n            this._isQuanX = true;\n        }\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isSurge) {\n            // Surge notification logic\n        } else if (this._isQuanX) {\n            // Quantumult X notification logic\n        } else if (this._node) {\n            // Node.js notification logic\n        }\n    }\n\n    write(value, key) {\n        if (this._isSurge) {\n            // Surge write logic\n        } else if (this._isQuanX) {\n            // Quantumult X write logic\n        } else if (this._node) {\n            // Node.js write logic\n        }\n        return true;\n    }\n\n    read(key) {\n        if (this._isSurge) {\n            // Surge read logic\n        } else if (this._isQuanX) {\n            // Quantumult X read logic\n        } else if (this._node) {\n            // Node.js read logic\n        }\n        return '';\n    }\n\n    get(options, callback) {\n        if (this._isSurge) {\n            // Surge get logic\n        } else if (this._isQuanX) {\n            // Quantumult X get logic\n        } else if (this._node) {\n            // Node.js get logic\n        }\n    }\n\n    post(options, callback) {\n        if (this._isSurge) {\n            // Surge post logic\n        } else if (this._isQuanX) {\n            // Quantumult X post logic\n        } else if (this._node) {\n            // Node.js post logic\n        }\n    }\n\n    _status(response) {\n        // Normalize response status codes\n        return response;\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    detectEnvironment() {\n        if (typeof module !== 'undefined' && module.exports) {\n            this._node = true;\n        } else if (typeof $response !== 'undefined') {\n            this._isQuanX = true;\n            this.isResponse = true;\n        } else if (typeof $ !== 'undefined') {\n            this._isSurge = true;\n            this.isResponse = true;\n        }\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isSurge) {\n            $notify(title, subtitle, message, option);\n        } else if (this._node) {\n            console.log(title, subtitle, message);\n        }\n    }\n\n    write(value, key) {\n        if (this._isQuanX) {\n            $prefs.setValueForKey(value, key);\n            return true;\n        } else if (this._isSurge) {\n            $prefs.setValueForKey(value, key);\n            return true;\n        } else if (this._node) {\n            try {\n                require('fs').writeFileSync(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    }\n\n    read(key) {\n        if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._isSurge) {\n            return $prefs.valueForKey(key);\n        } else if (this._node) {\n            try {\n                return require('fs').readFileSync(key, 'utf8');\n            } catch (e) {\n                return null;\n            }\n        }\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            $task.fetch({\n                url: options.url,\n                headers: options.headers\n            }).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._isSurge) {\n            $http.get(options.url, options.headers).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._node) {\n            const http = require('http');\n            const options = {\n                hostname: options.url.hostname,\n                port: options.url.port,\n                path: options.url.path,\n                method: 'GET',\n                headers: options.headers\n            };\n            const req = http.request(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, {\n                        statusCode: res.statusCode,\n                        data: data\n                    });\n                });\n            });\n            req.on('error', (e) => {\n                callback(e, null);\n            });\n            req.end();\n        }\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            $task.fetch({\n                url: options.url,\n                method: 'POST',\n                headers: options.headers,\n                body: options.body\n            }).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._isSurge) {\n            $http.post(options.url, options.body, options.headers).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._node) {\n            const http = require('http');\n            const options = {\n                hostname: options.url.hostname,\n                port: options.url.port,\n                path: options.url.path,\n                method: 'POST',\n                headers: options.headers\n            };\n            const req = http.request(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, {\n                        statusCode: res.statusCode,\n                        data: data\n                    });\n                });\n            });\n            req.on('error', (e) => {\n                callback(e, null);\n            });\n            req.write(options.body);\n            req.end();\n        }\n    }\n\n    _status(response) {\n        if (response.statusCode >= 200 && response.statusCode < 300) {\n            return { success: true };\n        } else {\n            return { success: false, statusCode: response.statusCode };\n        }\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    detectEnvironment() {\n        if (typeof module !== 'undefined' && module.exports) {\n            this._node = true;\n        } else if (typeof $response !== 'undefined') {\n            this._isQuanX = true;\n            this.isResponse = true;\n        } else if (typeof $ !== 'undefined') {\n            this._isSurge = true;\n            this.isResponse = true;\n        }\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isSurge) {\n            $notify(title, subtitle, message, option);\n        } else if (this._node) {\n            console.log(title, subtitle, message, option);\n        }\n    }\n\n    write(value, key) {\n        if (this._isQuanX) {\n            $prefs.setValueForKey(value, key);\n            return true;\n        } else if (this._isSurge) {\n            $prefs.setValueForKey(value, key);\n            return true;\n        } else if (this._node) {\n            try {\n                require('fs').writeFileSync(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    }\n\n    read(key) {\n        if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._isSurge) {\n            return $prefs.valueForKey(key);\n        } else if (this._node) {\n            try {\n                return require('fs').readFileSync(key, 'utf8');\n            } catch (e) {\n                return null;\n            }\n        }\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            $task.fetch({\n                url: options.url,\n                headers: options.headers,\n                method: 'GET'\n            }).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._isSurge) {\n            $http.get(options.url, options.headers).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._node) {\n            require('https').get(options.url, response => {\n                let data = '';\n                response.on('data', chunk => {\n                    data += chunk;\n                });\n                response.on('end', () => {\n                    callback(null, {statusCode: response.statusCode, data: data});\n                });\n            }).on('error', error => {\n                callback(error, null);\n            });\n        }\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            $task.fetch({\n                url: options.url,\n                headers: options.headers,\n                method: 'POST',\n                body: options.body\n            }).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._isSurge) {\n            $http.post(options.url, options.body, options.headers).then(response => {\n                callback(null, response);\n            }).catch(error => {\n                callback(error, null);\n            });\n        } else if (this._node) {\n            require('https').post(options.url, options.headers, response => {\n                let data = '';\n                response.on('data', chunk => {\n                    data += chunk;\n                });\n                response.on('end', () => {\n                    callback(null, {statusCode: response.statusCode, data: data});\n                });\n            }).on('error', error => {\n                callback(error, null);\n            });\n        }\n    }\n\n    _status(response) {\n        if (this._isQuanX || this._isSurge) {\n            return {statusCode: response.statusCode};\n        } else if (this._node) {\n            return {statusCode: response.statusCode};\n        }\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    detectEnvironment() {\n        if (typeof module !== 'undefined' && module.exports) {\n            this._node = true;\n        } else if (typeof $response !== 'undefined') {\n            this._isQuanX = true;\n            this.isResponse = true;\n        } else if (typeof $ !== 'undefined') {\n            this._isSurge = true;\n            this.isResponse = true;\n        }\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isSurge) {\n            $notify(title, subtitle, message, option);\n        } else if (this._node) {\n            console.log(title, subtitle, message, option);\n        }\n    }\n\n    write(value, key) {\n        if (this._isQuanX) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._isSurge) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._node) {\n            try {\n                require('fs').writeFileSync(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    }\n\n    read(key) {\n        if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._isSurge) {\n            return $prefs.valueForKey(key);\n        } else if (this._node) {\n            try {\n                return require('fs').readFileSync(key, 'utf8');\n            } catch (e) {\n                return null;\n            }\n        }\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            $task.fetch({\n                url: options.url,\n                headers: options.headers,\n                timeout: options.timeout\n            }).then(response => callback(null, response));\n        } else if (this._isSurge) {\n            $http.get(options.url, options.headers).then(response => callback(null, response));\n        } else if (this._node) {\n            require('https').get(options.url, response => {\n                let data = '';\n                response.on('data', chunk => data += chunk);\n                response.on('end', () => callback(null, {statusCode: response.statusCode, data: data}));\n            }).on('error', error => callback(error, null));\n        }\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            $task.fetch({\n                method: 'POST',\n                url: options.url,\n                headers: options.headers,\n                body: options.body,\n                timeout: options.timeout\n            }).then(response => callback(null, response));\n        } else if (this._isSurge) {\n            $http.post(options.url, options.body, options.headers).then(response => callback(null, response));\n        } else if (this._node) {\n            require('https').post(options.url, options.headers, response => {\n                let data = '';\n                response.on('data', chunk => data += chunk);\n                response.on('end', () => callback(null, {statusCode: response.statusCode, data: data}));\n            }).on('error', error => callback(error, null));\n        }\n    }\n\n    _status(response) {\n        if (this._isQuanX) {\n            return {statusCode: response.statusCode};\n        } else if (this._isSurge) {\n            return {statusCode: response.statusCode};\n        } else if (this._node) {\n            return {statusCode: response.statusCode};\n        }\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    detectEnvironment() {\n        if (typeof module !== 'undefined' && module.exports) {\n            this._node = true;\n        } else if (typeof $response !== 'undefined') {\n            this._isQuanX = true;\n            this.isResponse = true;\n        } else if (typeof $ !== 'undefined') {\n            this._isSurge = true;\n            this.isResponse = true;\n        }\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isSurge) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (this._node) {\n            console.log(title, subtitle, message, option);\n        }\n    }\n\n    write(value, key) {\n        if (this._isSurge) {\n            $prefs.setValueForKey(value, key);\n            return true;\n        } else if (this._isQuanX) {\n            $prefs.setValueForKey(value, key);\n            return true;\n        } else if (this._node) {\n            try {\n                require('fs').writeFileSync(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    read(key) {\n        if (this._isSurge) {\n            return $prefs.valueForKey(key);\n        } else if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._node) {\n            try {\n                return require('fs').readFileSync(key, 'utf8');\n            } catch (e) {\n                return '';\n            }\n        }\n        return '';\n    }\n\n    get(options, callback) {\n        if (this._isSurge) {\n            $http.get(options, (response) => {\n                callback(null, response);\n            });\n        } else if (this._isQuanX) {\n            $http.get(options, (response) => {\n                callback(null, response);\n            });\n        } else if (this._node) {\n            require('http').get(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, {statusCode: res.statusCode, data: data});\n                });\n            }).on('error', (err) => {\n                callback(err, null);\n            });\n        }\n    }\n\n    post(options, callback) {\n        if (this._isSurge) {\n            $http.post(options, (response) => {\n                callback(null, response);\n            });\n        } else if (this._isQuanX) {\n            $http.post(options, (response) => {\n                callback(null, response);\n            });\n        } else if (this._node) {\n            require('http').post(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, {statusCode: res.statusCode, data: data});\n                });\n            }).on('error', (err) => {\n                callback(err, null);\n            });\n        }\n    }\n\n    _status(response) {\n        if (this._isSurge || this._isQuanX) {\n            return {statusCode: response.statusCode};\n        } else if (this._node) {\n            return {statusCode: response.statusCode};\n        }\n        return {};\n    }\n}\n```",
      "```javascript\nclass Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = false;\n        this._isQuanX = false;\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = false;\n        this.detectEnvironment();\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isSurge) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isQuanX) {\n            $notification.post(title, subtitle, message, option);\n        } else if (this._node) {\n            this._node.child_process.exec(`osascript -e 'display notification \"${title}\" with subtitle \"${subtitle}\" and message \"${message}\"'`, (error, stdout, stderr) => {\n                if (error) {\n                    console.error(`exec error: ${error}`);\n                    return;\n                }\n                if (stderr) {\n                    console.error(`stderr: ${stderr}`);\n                    return;\n                }\n                console.log(`stdout: ${stdout}`);\n            });\n        }\n    }\n\n    write(value, key) {\n        if (this._isSurge) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._isQuanX) {\n            $prefs.setValueForKey(key, value);\n            return true;\n        } else if (this._node) {\n            const fs = require('fs');\n            const path = require('path');\n            const filePath = path.join(__dirname, 'storage', key);\n            fs.writeFileSync(filePath, value);\n            return true;\n        }\n        return false;\n    }\n\n    read(key) {\n        if (this._isSurge) {\n            return $prefs.valueForKey(key);\n        } else if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._node) {\n            const fs = require('fs');\n            const path = require('path');\n            const filePath = path.join(__dirname, 'storage', key);\n            if (fs.existsSync(filePath)) {\n                return fs.readFileSync(filePath, 'utf8');\n            }\n        }\n        return null;\n    }\n\n    get(options, callback) {\n        this.makeRequest('GET', options, callback);\n    }\n\n    post(options, callback) {\n        this.makeRequest('POST', options, callback);\n    }\n\n    _status(response) {\n        if (response.statusCode) {\n            return { status: response.statusCode };\n        }\n        return { status: 200 };\n    }\n\n    makeRequest(method, options, callback) {\n        if (this._isSurge) {\n            $http(method, options, (error, response) => {\n                if (error) {\n                    callback(error, null);\n                    return;\n                }\n                callback(null, response);\n            });\n        } else if (this._isQuanX) {\n            $http(method, options, (error, response) => {\n                if (error) {\n                    callback(error, null);\n                    return;\n                }\n                callback(null, response);\n            });\n        } else if (this._node) {\n            const http = require('http');\n            const options = typeof options === 'string' ? { hostname: options } : options;\n            const req = http.request(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => {\n                    data += chunk;\n                });\n                res.on('end', () => {\n                    callback(null, { statusCode: res.statusCode, data: data });\n                });\n            });\n            req.on('error', (e) => {\n                callback(e, null);\n            });\n            req.end();\n        }\n    }\n\n    detectEnvironment() {\n        if (typeof $prefs !== 'undefined') {\n            this._isSurge = true;\n            this._isQuanX = false;\n        } else if (typeof $notification !== 'undefined') {\n            this._isSurge = false;\n            this._isQuanX = true;\n        } else if (typeof process !== 'undefined' && process.versions && process.versions.node) {\n            this._node = true;\n            this._isSurge = false;\n            this._isQuanX = false;\n        }\n    }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a function that uses XMLHttpRequest to asynchronously fetch data from a specified URL and returns a Promise that resolves on successful request completion or rejects on failure.\n\nFunction Description: The function `getDataXhr` initiates an HTTP GET request to the provided URL using XMLHttpRequest. It sets appropriate headers for JSON content, handles the response asynchronously through Promise callbacks, and manages both successful and failed request scenarios.\n\nInput: \n- url [String] - The URL from which data should be fetched\n\nOutput: \n- [Promise] - A Promise that resolves when the request completes successfully (onload) or rejects when the request fails (onerror)",
    "Canonical_solution": "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Content-Type', 'application/json');\n    req.setRequestHeader('Accept', 'application/json');\n    req.onload = () => {\n      resolve();\n    };\n    req.onerror = () => {\n      reject();\n    };\n    req.send();\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "function getDataXhr(url) {\n    return new Promise((resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr.responseText);\n            } else {\n                reject(xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            reject(xhr.statusText);\n        };\n        xhr.send();\n    });\n}",
      "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getDataXhr(url) {\n    return new Promise((resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr.responseText);\n            } else {\n                reject(xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            reject(xhr.statusText);\n        };\n        xhr.send();\n    });\n}",
      "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getDataXhr(url) {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr.responseText);\n            } else {\n                reject(xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            reject(xhr.statusText);\n        };\n        xhr.send();\n    });\n}",
      "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getDataXhr(url) {\n  return new Promise((resolve, reject) => {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getDataXhr(url) {\n    return new Promise((resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr.responseText);\n            } else {\n                reject(xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            reject(xhr.statusText);\n        };\n        xhr.send();\n    });\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement an asynchronous function that makes an HTTP request using XMLHttpRequest with timeout handling, customizable request options, and proper error management.\n\nFunction Description: The function `_xhrRequestWithTimeout` performs an HTTP request using XMLHttpRequest with configurable method, URL, and request options. It includes timeout handling, response type configuration, custom headers, and proper cleanup of resources. The function returns a Promise that resolves with the XMLHttpRequest object on success or rejects with an error or timeout message.\n\nInput:\n- `method` (string): The HTTP method to use for the request (e.g., 'GET', 'POST').\n- `url` (string): The URL to which the request is sent.\n- `options` (RequestOptions): An object containing additional request configurations:\n  - `responseType` (optional, string): The expected response type (e.g., 'json', 'arraybuffer').\n  - `headers` (optional, object): Key-value pairs representing request headers.\n  - `body` (optional, any): The request payload to send.\n\nOutput:\n- Returns a Promise that:\n  - Resolves with the XMLHttpRequest object if the request succeeds.\n  - Rejects with an error object if the request fails.\n  - Rejects with the string 'timeout' if the request times out.",
    "Canonical_solution": "async function _xhrRequestWithTimeout(method: string, url: string, options: RequestOptions): Promise<XMLHttpRequest> {\n    return new Promise((resolve, reject) => {\n        log('[requests XHR]', method, url);\n        let timedOut = false;\n        const timer = setTimeout(() => {\n            timedOut = true;\n            reject('timeout');\n        }, config.requestTimeout);\n        const xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        if (options.responseType) {\n            xhr.responseType = options.responseType;\n        }\n        if (options.headers) {\n            for (const key in options.headers) {\n                xhr.setRequestHeader(key, options.headers[key]);\n            }\n        }\n        xhr.onload = (): void => {\n            if (timedOut) {\n                return;\n            }\n            clearTimeout(timer);\n            resolve(xhr);\n        };\n        xhr.onerror = (error): void => {\n            if (timedOut) {\n                return;\n            }\n            clearTimeout(timer);\n            reject(error);\n        };\n        let body = options.body;\n        if (typeof (body) === 'object' && !isArrayBufferView(body) && body instanceof ArrayBuffer) {\n            body = new Uint8Array(body);\n        }\n        xhr.send(body);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType, headers, body } = options;\n    xhr.open(method, url, true);\n    xhr.timeout = options.timeout || 0;\n    xhr.responseType = responseType || 'text';\n\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onloadend = () => {\n      xhr = null;\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType, headers, body } = options;\n    xhr.open(method, url, true);\n    xhr.timeout = options.timeout || 0;\n    xhr.responseType = responseType || 'text';\n\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onabort = () => {\n      reject(new Error('Request aborted'));\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType = 'text', headers = {}, body = null } = options;\n    xhr.open(method, url, true);\n    xhr.responseType = responseType;\n    Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n\n    const timeout = options.timeout || 0;\n    if (timeout > 0) {\n      xhr.timeout = timeout;\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error(`Request failed with status ${xhr.status}`));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onloadend = () => {\n      xhr = null;\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType, headers, body } = options;\n    xhr.open(method, url, true);\n    xhr.timeout = options.timeout || 0;\n    xhr.responseType = responseType || 'text';\n\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onloadend = () => {\n      xhr = null;\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType, headers, body } = options;\n    xhr.open(method, url, true);\n    xhr.timeout = options.timeout || 0;\n    xhr.responseType = responseType || 'text';\n\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onloadend = () => {\n      xhr = null;\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType, headers, body } = options;\n    xhr.open(method, url, true);\n    xhr.timeout = options.timeout || 0;\n    xhr.responseType = responseType || 'text';\n\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onloadend = () => {\n      xhr = null;\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType, headers, body } = options;\n    xhr.open(method, url, true);\n    xhr.timeout = options.timeout || 0;\n    xhr.responseType = responseType || 'text';\n\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onloadend = () => {\n      xhr = null;\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType = 'text', headers = {}, body = null } = options;\n    xhr.open(method, url, true);\n    xhr.responseType = responseType;\n    Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n    xhr.timeout = options.timeout || 0;\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onabort = () => {\n      reject(new Error('Request aborted'));\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType, headers, body } = options;\n    xhr.open(method, url, true);\n\n    if (responseType) {\n      xhr.responseType = responseType;\n    }\n\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n\n    const timeout = options.timeout || 0;\n    if (timeout > 0) {\n      xhr.timeout = timeout;\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error('Request failed with status: ' + xhr.status));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onloadend = () => {\n      xhr = null;\n    };\n\n    xhr.send(body);\n  });\n}\n```",
      "```javascript\nfunction _xhrRequestWithTimeout(method, url, options) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const { responseType, headers, body } = options;\n    xhr.open(method, url, true);\n    xhr.timeout = options.timeout || 0;\n    xhr.responseType = responseType || 'text';\n\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error(`Request failed with status ${xhr.status}`));\n      }\n    };\n\n    xhr.ontimeout = () => {\n      reject('timeout');\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.onloadend = () => {\n      xhr = null;\n    };\n\n    xhr.send(body);\n  });\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a class for handling chunked data loading via XMLHttpRequest with support for range requests, progress tracking, and error handling.\n\nClass Description: The MozChunkedLoader class is designed to handle asynchronous loading of chunked binary data from a server using XMLHttpRequest with 'moz-chunked-arraybuffer' response type. It supports range requests, tracks loading progress, handles redirects, and provides comprehensive error handling.\n\nAttributes:\n- _seekHandler: [Object] - Handler for URL and range configuration\n- _config: [Object] - Configuration object for the loader\n- _needStash: [Boolean] - Flag indicating whether data needs to be stashed\n- _xhr: [XMLHttpRequest|null] - The XMLHttpRequest instance\n- _requestAbort: [Boolean] - Flag indicating if the request was aborted\n- _contentLength: [Number|null] - Total content length of the resource\n- _receivedLength: [Number] - Number of bytes received so far\n- _dataSource: [Object] - Data source configuration\n- _range: [Object] - Request range parameters\n- _requestURL: [String] - The URL used for the request\n\nMethods:\n- constructor(seekHandler, config) -> [MozChunkedLoader] - Initializes the loader with seek handler and configuration\n- open(dataSource, range) -> [void] - Opens a connection to the specified data source with range parameters\n- abort() -> [void] - Aborts the current request\n- _onReadyStateChange(e) -> [void] - Handles XMLHttpRequest ready state changes\n- _onProgress(e) -> [void] - Handles progress events during data loading\n- _onLoadEnd(e) -> [void] - Handles request completion\n- _onXhrError(e) -> [void] - Handles XMLHttpRequest errors\n\nEvent Callbacks (to be set externally):\n- _onURLRedirect: [Function] - Called when URL redirection occurs\n- _onError: [Function] - Called when an error occurs\n- _onContentLengthKnown: [Function] - Called when content length is determined\n- _onDataArrival: [Function] - Called when new data chunk arrives\n- _onComplete: [Function] - Called when loading completes successfully",
    "Canonical_solution": "class MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = true;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n\n        let sourceURL = dataSource.url;\n        if (this._config.reuseRedirectedURL && dataSource.redirectedURL != undefined) {\n            sourceURL = dataSource.redirectedURL;\n        }\n\n        let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n        this._requestURL = seekConfig.url;\n\n        let xhr = this._xhr = new XMLHttpRequest();\n        xhr.open('GET', seekConfig.url, true);\n        xhr.responseType = 'moz-chunked-arraybuffer';\n        xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        xhr.onprogress = this._onProgress.bind(this);\n        xhr.onloadend = this._onLoadEnd.bind(this);\n        xhr.onerror = this._onXhrError.bind(this);\n\n        if (dataSource.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        if (typeof seekConfig.headers === 'object') {\n            let headers = seekConfig.headers;\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        if (typeof this._config.headers === 'object') {\n            let headers = this._config.headers;\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        xhr.send();\n    }\n\n    abort() {\n        this._requestAbort = true;\n        if (this._xhr) {\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        let xhr = e.target;\n        if (xhr.readyState === 2) {\n            if (xhr.responseURL != undefined && xhr.responseURL !== this._requestURL) {\n                if (this._onURLRedirect) {\n                    let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n                    this._onURLRedirect(redirectedURL);\n                }\n            }\n\n            if (xhr.status !== 0 && (xhr.status < 200 || xhr.status > 299)) {\n                if (this._onError) {\n                    this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {code: xhr.status, msg: xhr.statusText});\n                }\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (this._contentLength === null) {\n            if (e.total !== null && e.total !== 0) {\n                this._contentLength = e.total;\n                if (this._onContentLengthKnown) {\n                    this._onContentLengthKnown(this._contentLength);\n                }\n            }\n        }\n\n        let chunk = e.target.response;\n        let byteStart = this._range.from + this._receivedLength;\n        this._receivedLength += chunk.byteLength;\n\n        if (this._onDataArrival) {\n            this._onDataArrival(chunk, byteStart, this._receivedLength);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._requestAbort === true) {\n            this._requestAbort = false;\n            return;\n        }\n\n        if (this._onComplete) {\n            this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n        }\n    }\n\n    _onXhrError(e) {\n        let type = 0;\n        let info = null;\n\n        if (this._contentLength && e.loaded < this._contentLength) {\n            type = LoaderErrors.EARLY_EOF;\n            info = {code: -1, msg: 'Moz-Chunked stream meet Early-Eof'};\n        } else {\n            type = LoaderErrors.EXCEPTION;\n            info = {code: -1, msg: e.constructor.name + ' ' + e.type};\n        }\n\n        if (this._onError) {\n            this._onError(type, info);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(dataSource, range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.onloadstart = () => {\n            this._onProgress({ lengthComputable: true, loaded: 0, total: 0 });\n        };\n        this._xhr.onprogress = this._onProgress;\n        this._xhr.onload = this._onLoadEnd;\n        this._xhr.onerror = this._onXhrError;\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                this._onContentLengthKnown(this._xhr.getResponseHeader('Content-Length'));\n                this._onDataArrival(this._xhr.response);\n                this._onComplete();\n            } else {\n                this._onError(new Error('Request failed with status: ' + this._xhr.status));\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            this._onContentLengthKnown(e.total);\n            this._onDataArrival(e.loaded);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (!this._requestAbort) {\n            this._onContentLengthKnown(this._xhr.getResponseHeader('Content-Length'));\n            this._onDataArrival(this._xhr.response);\n            this._onComplete();\n        }\n    }\n\n    _onXhrError(e) {\n        this._onError(new Error('XMLHttpRequest error: ' + e.message));\n    }\n\n    _onURLRedirect(newURL) {\n        if (this._onURLRedirect) {\n            this._onURLRedirect(newURL);\n        }\n    }\n\n    _onError(error) {\n        if (this._onError) {\n            this._onError(error);\n        }\n    }\n\n    _onContentLengthKnown(length) {\n        if (this._onContentLengthKnown) {\n            this._onContentLengthKnown(length);\n        }\n    }\n\n    _onDataArrival(data) {\n        if (this._onDataArrival) {\n            this._onDataArrival(data);\n        }\n    }\n\n    _onComplete() {\n        if (this._onComplete) {\n            this._onComplete();\n        }\n    }\n}\n```",
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(dataSource, range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.onload = this._onReadyStateChange.bind(this);\n        this._xhr.onerror = this._onXhrError.bind(this);\n        this._xhr.onprogress = this._onProgress.bind(this);\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                this._onLoadEnd(e);\n            } else {\n                this._onXhrError(e);\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            if (this._onContentLengthKnown) {\n                this._onContentLengthKnown(this._receivedLength, this._contentLength);\n            }\n            if (this._onDataArrival) {\n                this._onDataArrival(this._xhr.response);\n            }\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._onComplete) {\n            this._onComplete(this._xhr.response);\n        }\n    }\n\n    _onXhrError(e) {\n        if (this._onError) {\n            this._onError(e);\n        }\n    }\n}\n```",
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(dataSource, range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.onload = this._onReadyStateChange.bind(this);\n        this._xhr.onerror = this._onXhrError.bind(this);\n        this._xhr.onprogress = this._onProgress.bind(this);\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                this._onLoadEnd(e);\n            } else {\n                this._onXhrError(e);\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            this._onContentLengthKnown(this._contentLength);\n            this._onDataArrival(e.loaded);\n        }\n    }\n\n    _onLoadEnd(e) {\n        this._onContentLengthKnown(this._contentLength);\n        this._onComplete();\n    }\n\n    _onXhrError(e) {\n        this._onError(e);\n    }\n\n    _onContentLengthKnown(contentLength) {\n        this._contentLength = contentLength;\n        if (typeof this._onContentLengthKnown === 'function') {\n            this._onContentLengthKnown(this._contentLength);\n        }\n    }\n\n    _onDataArrival(dataLoaded) {\n        if (typeof this._onDataArrival === 'function') {\n            this._onDataArrival(dataLoaded);\n        }\n    }\n\n    _onComplete() {\n        if (typeof this._onComplete === 'function') {\n            this._onComplete();\n        }\n    }\n}\n```",
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(dataSource, range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.setRequestHeader('Range', `bytes=${this._range.start}-${this._range.end}`);\n        this._xhr.onprogress = this._onProgress.bind(this);\n        this._xhr.onload = this._onLoadEnd.bind(this);\n        this._xhr.onerror = this._onXhrError.bind(this);\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200 || this._xhr.status === 206) {\n                this._onLoadEnd();\n            } else {\n                this._onError(new Error('Request failed with status: ' + this._xhr.status));\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            this._onDataArrival(e.loaded);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._requestAbort) {\n            return;\n        }\n        if (this._xhr.status === 206) {\n            this._contentLength = this._range.end - this._range.start + 1;\n            this._onContentLengthKnown(this._contentLength);\n        }\n        this._onComplete();\n    }\n\n    _onXhrError(e) {\n        this._onError(e);\n    }\n\n    _onURLRedirect(newURL) {\n        this._onURLRedirect(newURL);\n    }\n\n    _onError(error) {\n        if (this._onError) {\n            this._onError(error);\n        }\n    }\n\n    _onContentLengthKnown(length) {\n        if (this._onContentLengthKnown) {\n            this._onContentLengthKnown(length);\n        }\n    }\n\n    _onDataArrival(chunkSize) {\n        if (this._onDataArrival) {\n            this._onDataArrival(chunkSize);\n        }\n    }\n\n    _onComplete() {\n        if (this._onComplete) {\n            this._onComplete();\n        }\n    }\n}\n```",
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(this._dataSource, this._range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.onloadstart = this._onLoadStart.bind(this);\n        this._xhr.onprogress = this._onProgress.bind(this);\n        this._xhr.onload = this._onLoadEnd.bind(this);\n        this._xhr.onerror = this._onXhrError.bind(this);\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                this._onLoadEnd(e);\n            } else {\n                this._onXhrError(e);\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            this._onDataArrival(e);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._requestAbort) {\n            return;\n        }\n        if (this._xhr.status === 200) {\n            this._contentLength = this._xhr.getResponseHeader('Content-Length');\n            this._onContentLengthKnown(this._contentLength);\n            this._onComplete();\n        } else {\n            this._onXhrError(e);\n        }\n    }\n\n    _onXhrError(e) {\n        if (this._requestAbort) {\n            return;\n        }\n        this._onError(e);\n    }\n\n    _onLoadStart() {\n        if (this._xhr.status === 302 || this._xhr.status === 303 || this._xhr.status === 307 || this._xhr.status === 308) {\n            this._onURLRedirect(this._xhr.getResponseHeader('Location'));\n        }\n    }\n\n    _onURLRedirect(newURL) {\n        this._requestURL = newURL;\n        this.open(this._dataSource, this._range);\n    }\n\n    _onContentLengthKnown(length) {\n        if (this._onContentLengthKnown) {\n            this._onContentLengthKnown(length);\n        }\n    }\n\n    _onDataArrival(e) {\n        if (this._onDataArrival) {\n            this._onDataArrival(e);\n        }\n    }\n\n    _onComplete() {\n        if (this._onComplete) {\n            this._onComplete();\n        }\n    }\n\n    _onError(e) {\n        if (this._onError) {\n            this._onError(e);\n        }\n    }\n}\n```",
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(dataSource, range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.onloadstart = () => {\n            this._onProgress({ lengthComputable: true, loaded: 0, total: 0 });\n        };\n        this._xhr.onprogress = this._onProgress;\n        this._xhr.onload = this._onLoadEnd;\n        this._xhr.onerror = this._onXhrError;\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                this._onContentLengthKnown({ total: this._contentLength });\n                this._onDataArrival(this._xhr.response);\n                this._onComplete();\n            } else {\n                this._onError(new Error('Request failed with status: ' + this._xhr.status));\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            this._onContentLengthKnown({ total: e.total });\n            this._onDataArrival(this._xhr.response);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._xhr.status === 200) {\n            this._onContentLengthKnown({ total: this._contentLength });\n            this._onDataArrival(this._xhr.response);\n            this._onComplete();\n        } else if (this._xhr.status === 302 || this._xhr.status === 303 || this._xhr.status === 307 || this._xhr.status === 308) {\n            this._onURLRedirect({ url: this._xhr.getResponseHeader('Location') });\n        } else {\n            this._onError(new Error('Request failed with status: ' + this._xhr.status));\n        }\n    }\n\n    _onXhrError(e) {\n        this._onError(e);\n    }\n\n    _onContentLengthKnown(e) {\n        if (typeof this._onContentLengthKnown === 'function') {\n            this._onContentLengthKnown(e);\n        }\n    }\n\n    _onDataArrival(data) {\n        if (typeof this._onDataArrival === 'function') {\n            this._onDataArrival(data);\n        }\n    }\n\n    _onComplete() {\n        if (typeof this._onComplete === 'function') {\n            this._onComplete();\n        }\n    }\n\n    _onURLRedirect(url) {\n        if (typeof this._onURLRedirect === 'function') {\n            this._onURLRedirect(url);\n        }\n    }\n\n    _onError(error) {\n        if (typeof this._onError === 'function') {\n            this._onError(error);\n        }\n    }\n}\n```",
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(dataSource, range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.onloadstart = this._onReadyStateChange.bind(this);\n        this._xhr.onprogress = this._onProgress.bind(this);\n        this._xhr.onloadend = this._onLoadEnd.bind(this);\n        this._xhr.onerror = this._onXhrError.bind(this);\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                this._onContentLengthKnown(this._xhr.getResponseHeader('Content-Length'));\n                this._onDataArrival(this._xhr.response);\n                this._onComplete();\n            } else if (this._xhr.status === 302 || this._xhr.status === 303) {\n                this._onURLRedirect(this._xhr.getResponseHeader('Location'));\n            } else {\n                this._onError(new Error('Request failed with status: ' + this._xhr.status));\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            this._onDataArrival(e.target.response);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._requestAbort) {\n            this._onError(new Error('Request was aborted'));\n        }\n    }\n\n    _onXhrError(e) {\n        this._onError(e.target.error);\n    }\n\n    _onContentLengthKnown(contentLength) {\n        this._contentLength = parseInt(contentLength, 10);\n        this._onContentLengthKnown(contentLength);\n    }\n\n    _onDataArrival(data) {\n        if (this._onDataArrival) {\n            this._onDataArrival(data);\n        }\n    }\n\n    _onComplete() {\n        if (this._onComplete) {\n            this._onComplete();\n        }\n    }\n\n    _onURLRedirect(newURL) {\n        if (this._onURLRedirect) {\n            this._onURLRedirect(newURL);\n        }\n    }\n\n    _onError(error) {\n        if (this._onError) {\n            this._onError(error);\n        }\n    }\n}\n```",
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(dataSource, range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.onloadstart = this._onLoadStart.bind(this);\n        this._xhr.onprogress = this._onProgress.bind(this);\n        this._xhr.onload = this._onLoadEnd.bind(this);\n        this._xhr.onerror = this._onXhrError.bind(this);\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                this._onLoadEnd(e);\n            } else {\n                this._onXhrError(e);\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            this._onDataArrival(e);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._requestAbort) {\n            return;\n        }\n        if (this._xhr.status === 200) {\n            this._contentLength = this._xhr.getResponseHeader('Content-Length');\n            this._onContentLengthKnown(this._contentLength);\n            this._onDataArrival(e);\n            this._onComplete();\n        } else {\n            this._onXhrError(e);\n        }\n    }\n\n    _onXhrError(e) {\n        if (this._requestAbort) {\n            return;\n        }\n        this._onError(e);\n    }\n\n    _onLoadStart() {\n        if (this._xhr.status === 302 || this._xhr.status === 303 || this._xhr.status === 307 || this._xhr.status === 308) {\n            this._onURLRedirect(this._xhr.getResponseHeader('Location'));\n        }\n    }\n\n    _onURLRedirect(newURL) {\n        this._onURLRedirect(newURL);\n    }\n\n    _onError(e) {\n        this._onError(e);\n    }\n\n    _onContentLengthKnown(contentLength) {\n        this._onContentLengthKnown(contentLength);\n    }\n\n    _onDataArrival(e) {\n        this._onDataArrival(e);\n    }\n\n    _onComplete() {\n        this._onComplete();\n    }\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(this._dataSource, this._range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        this._xhr.onprogress = this._onProgress.bind(this);\n        this._xhr.onloadend = this._onLoadEnd.bind(this);\n        this._xhr.onerror = this._onXhrError.bind(this);\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                if (this._onContentLengthKnown) {\n                    this._onContentLengthKnown(this._xhr.getResponseHeader('Content-Length'));\n                }\n                if (this._onDataArrival) {\n                    this._onDataArrival(this._xhr.response);\n                }\n                if (this._onComplete) {\n                    this._onComplete();\n                }\n            } else if (this._xhr.status === 302 || this._xhr.status === 303 || this._xhr.status === 307 || this._xhr.status === 308) {\n                if (this._onURLRedirect) {\n                    this._onURLRedirect(this._xhr.getResponseHeader('Location'));\n                }\n            } else {\n                if (this._onError) {\n                    this._onError(this._xhr.statusText);\n                }\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            if (this._onDataArrival) {\n                this._onDataArrival(e.loaded);\n            }\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._xhr.status === 200) {\n            if (this._onComplete) {\n                this._onComplete();\n            }\n        } else {\n            if (this._onError) {\n                this._onError(this._xhr.statusText);\n            }\n        }\n    }\n\n    _onXhrError(e) {\n        if (this._onError) {\n            this._onError('XMLHttpRequest error');\n        }\n    }\n}\n```",
      "```javascript\nclass MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = false;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n        this._dataSource = {};\n        this._range = {};\n        this._requestURL = '';\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n        this._requestURL = this._seekHandler.getURL(this._dataSource, this._range);\n        this._xhr = new XMLHttpRequest();\n        this._xhr.responseType = 'moz-chunked-arraybuffer';\n        this._xhr.open('GET', this._requestURL, true);\n        this._xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        this._xhr.onprogress = this._onProgress.bind(this);\n        this._xhr.onloadend = this._onLoadEnd.bind(this);\n        this._xhr.onerror = this._onXhrError.bind(this);\n        this._xhr.send();\n    }\n\n    abort() {\n        if (this._xhr) {\n            this._requestAbort = true;\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        if (this._xhr.readyState === XMLHttpRequest.DONE) {\n            if (this._xhr.status === 200) {\n                this._onLoadEnd(e);\n            } else {\n                this._onXhrError(e);\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (e.lengthComputable) {\n            this._receivedLength += e.loaded;\n            this._onContentLengthKnown(this._contentLength);\n            this._onDataArrival(e.loaded);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._requestAbort) {\n            return;\n        }\n        if (this._xhr.status === 200) {\n            this._onComplete();\n        } else {\n            this._onXhrError(e);\n        }\n    }\n\n    _onXhrError(e) {\n        if (this._requestAbort) {\n            return;\n        }\n        this._onError(e);\n    }\n\n    _onContentLengthKnown(length) {\n        this._contentLength = length;\n        this._onContentLengthKnown(this._contentLength);\n    }\n\n    _onDataArrival(chunkSize) {\n        this._onDataArrival(chunkSize);\n    }\n\n    _onComplete() {\n        this._onComplete();\n    }\n\n    _onURLRedirect(newURL) {\n        this._onURLRedirect(newURL);\n    }\n\n    _onError(error) {\n        this._onError(error);\n    }\n}\n```"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a JavaScript class that implements HTTP client functionality for making JSON-based requests (GET, POST, DELETE) with token-based authorization.\n\nClass Description: The JSONHttpClient class provides methods for making HTTP requests to interact with JSON APIs. It handles request configuration, authorization headers, response parsing, and error handling. The class maintains an authorization token that is automatically included in all requests.\n\nAttributes:\ntoken: [String] - An authorization token stored in localStorage or generated randomly if not available\n\nMethods:\nconstructor: [] -> [void] - Initializes the client instance and sets/retrieves the authorization token\n\nsetToken: [req: XMLHttpRequest] -> [void] - Sets the authorization header on the given request object\n\ngetJSON: [url: String, callback: Function] -> [void] - Makes a GET request to the specified URL and invokes the callback with parsed JSON response or error\n\npostJSON: [url: String, obj: Object, callback: Function] -> [void] - Makes a POST request with JSON payload to the specified URL and invokes the callback with parsed response\n\ndeleteJSON: [url: String, callback: Function] -> [void] - Makes a DELETE request to the specified URL and invokes the callback with response text or error after a random delay",
    "Canonical_solution": "const XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n\nclass JSONHttpClient {\n  constructor() {\n    this.token = localStorage.token || Date.now() * Math.random();\n    localStorage.token = this.token;\n  }\n\n  setToken(req) {\n    req.setRequestHeader(\"authorization\", this.token);\n  }\n\n  getJSON(url, callback) {\n    const req = new XMLHttpRequest();\n    req.onload = function() {\n      if (req.status === 404) {\n        callback(new Error(\"not found\"));\n      } else {\n        callback(null, JSON.parse(req.response));\n      }\n    };\n    req.open(\"GET\", url);\n    this.setToken(req);\n    req.send();\n  }\n\n  postJSON(url, obj, callback) {\n    const req = new XMLHttpRequest();\n    req.onload = function() {\n      callback(JSON.parse(req.response));\n    };\n    req.open(\"POST\", url);\n    req.setRequestHeader(\n      \"Content-Type\",\n      \"application/json;charset=UTF-8\"\n    );\n    this.setToken(req);\n    req.send(JSON.stringify(obj));\n  }\n\n  deleteJSON(url, callback) {\n    const req = new XMLHttpRequest();\n    req.onload = function() {\n      setTimeout(() => {\n        if (req.status === 500) {\n          callback(new Error(req.responseText));\n        } else {\n          callback(null, req.responseText);\n        }\n      }, Math.random() * 5000);\n    };\n    req.open(\"DELETE\", url);\n    this.setToken(req);\n    req.send();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nclass JSONHttpClient {\n  constructor() {\n    this.token = localStorage.getItem('token') || 'randomToken';\n  }\n\n  setToken(req) {\n    req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n  }\n\n  getJSON(url, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    this.setToken(xhr);\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(JSON.parse(xhr.responseText));\n      } else {\n        callback(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => callback('Network error');\n    xhr.send();\n  }\n\n  postJSON(url, obj, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    this.setToken(xhr);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(JSON.parse(xhr.responseText));\n      } else {\n        callback(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => callback('Network error');\n    xhr.send(JSON.stringify(obj));\n  }\n\n  deleteJSON(url, callback) {\n    setTimeout(() => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('DELETE', url);\n      this.setToken(xhr);\n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          callback(xhr.responseText);\n        } else {\n          callback(xhr.statusText);\n        }\n      };\n      xhr.onerror = () => callback('Network error');\n      xhr.send();\n    }, Math.random() * 1000);\n  }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n    constructor() {\n        this.token = localStorage.getItem('token') || 'randomToken';\n    }\n\n    setToken(req) {\n        req.setRequestHeader('Authorization', 'Bearer ' + this.token);\n    }\n\n    getJSON(url, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        this.setToken(xhr);\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback('Network error');\n        xhr.send();\n    }\n\n    postJSON(url, obj, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', url, true);\n        this.setToken(xhr);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback('Network error');\n        xhr.send(JSON.stringify(obj));\n    }\n\n    deleteJSON(url, callback) {\n        setTimeout(() => {\n            const xhr = new XMLHttpRequest();\n            xhr.open('DELETE', url, true);\n            this.setToken(xhr);\n            xhr.onload = () => {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(xhr.responseText);\n                } else {\n                    callback(xhr.statusText);\n                }\n            };\n            xhr.onerror = () => callback('Network error');\n            xhr.send();\n        }, Math.random() * 1000);\n    }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n  constructor() {\n    this.token = localStorage.getItem('token') || 'randomToken';\n  }\n\n  setToken(req) {\n    req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n  }\n\n  getJSON(url, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    this.setToken(xhr);\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(JSON.parse(xhr.responseText));\n      } else {\n        callback(null, xhr.statusText);\n      }\n    };\n    xhr.onerror = () => callback(null, 'Network error');\n    xhr.send();\n  }\n\n  postJSON(url, obj, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', url, true);\n    this.setToken(xhr);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(JSON.parse(xhr.responseText));\n      } else {\n        callback(null, xhr.statusText);\n      }\n    };\n    xhr.onerror = () => callback(null, 'Network error');\n    xhr.send(JSON.stringify(obj));\n  }\n\n  deleteJSON(url, callback) {\n    setTimeout(() => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('DELETE', url, true);\n      this.setToken(xhr);\n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          callback(xhr.responseText);\n        } else {\n          callback(null, xhr.statusText);\n        }\n      };\n      xhr.onerror = () => callback(null, 'Network error');\n      xhr.send();\n    }, Math.random() * 1000);\n  }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n  constructor() {\n    this.token = localStorage.getItem('authToken') || 'randomToken';\n  }\n\n  setToken(req) {\n    req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n  }\n\n  getJSON(url, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    this.setToken(xhr);\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(JSON.parse(xhr.responseText));\n      } else {\n        callback(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => callback('Network error');\n    xhr.send();\n  }\n\n  postJSON(url, obj, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    this.setToken(xhr);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(JSON.parse(xhr.responseText));\n      } else {\n        callback(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => callback('Network error');\n    xhr.send(JSON.stringify(obj));\n  }\n\n  deleteJSON(url, callback) {\n    setTimeout(() => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('DELETE', url);\n      this.setToken(xhr);\n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          callback(xhr.responseText);\n        } else {\n          callback(xhr.statusText);\n        }\n      };\n      xhr.onerror = () => callback('Network error');\n      xhr.send();\n    }, Math.random() * 1000);\n  }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n    constructor() {\n        this.token = localStorage.getItem('token') || 'randomToken';\n    }\n\n    setToken(req) {\n        req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n    }\n\n    getJSON(url, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        this.setToken(xhr);\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback('Network error');\n        xhr.send();\n    }\n\n    postJSON(url, obj, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', url, true);\n        this.setToken(xhr);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback('Network error');\n        xhr.send(JSON.stringify(obj));\n    }\n\n    deleteJSON(url, callback) {\n        setTimeout(() => {\n            const xhr = new XMLHttpRequest();\n            xhr.open('DELETE', url, true);\n            this.setToken(xhr);\n            xhr.onload = () => {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(xhr.responseText);\n                } else {\n                    callback(xhr.statusText);\n                }\n            };\n            xhr.onerror = () => callback('Network error');\n            xhr.send();\n        }, Math.random() * 1000);\n    }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n    constructor() {\n        this.token = localStorage.getItem('token') || 'randomToken';\n    }\n\n    setToken(req) {\n        req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n    }\n\n    getJSON(url, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url);\n        this.setToken(xhr);\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback('Network error');\n        xhr.send();\n    }\n\n    postJSON(url, obj, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', url);\n        this.setToken(xhr);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback('Network error');\n        xhr.send(JSON.stringify(obj));\n    }\n\n    deleteJSON(url, callback) {\n        setTimeout(() => {\n            const xhr = new XMLHttpRequest();\n            xhr.open('DELETE', url);\n            this.setToken(xhr);\n            xhr.onload = () => {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(xhr.responseText);\n                } else {\n                    callback(xhr.statusText);\n                }\n            };\n            xhr.onerror = () => callback('Network error');\n            xhr.send();\n        }, Math.random() * 1000);\n    }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n    constructor() {\n        this.token = localStorage.getItem('token') || 'randomToken';\n    }\n\n    setToken(req) {\n        req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n    }\n\n    getJSON(url, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        this.setToken(xhr);\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback('Network error');\n        xhr.send();\n    }\n\n    postJSON(url, obj, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', url, true);\n        this.setToken(xhr);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback('Network error');\n        xhr.send(JSON.stringify(obj));\n    }\n\n    deleteJSON(url, callback) {\n        setTimeout(() => {\n            const xhr = new XMLHttpRequest();\n            xhr.open('DELETE', url, true);\n            this.setToken(xhr);\n            xhr.onload = () => {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(xhr.responseText);\n                } else {\n                    callback(xhr.statusText);\n                }\n            };\n            xhr.onerror = () => callback('Network error');\n            xhr.send();\n        }, Math.random() * 1000);\n    }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n    constructor() {\n        this.token = localStorage.getItem('token') || 'randomToken';\n    }\n\n    setToken(req) {\n        req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n    }\n\n    getJSON(url, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        this.setToken(xhr);\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback(xhr.statusText);\n        xhr.send();\n    }\n\n    postJSON(url, obj, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', url, true);\n        this.setToken(xhr);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText));\n            } else {\n                callback(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback(xhr.statusText);\n        xhr.send(JSON.stringify(obj));\n    }\n\n    deleteJSON(url, callback) {\n        setTimeout(() => {\n            const xhr = new XMLHttpRequest();\n            xhr.open('DELETE', url, true);\n            this.setToken(xhr);\n            xhr.onload = () => {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(xhr.responseText);\n                } else {\n                    callback(xhr.statusText);\n                }\n            };\n            xhr.onerror = () => callback(xhr.statusText);\n            xhr.send();\n        }, Math.random() * 1000);\n    }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n    constructor() {\n        this.token = localStorage.getItem('token') || 'randomToken';\n    }\n\n    setToken(req) {\n        req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n    }\n\n    getJSON(url, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        this.setToken(xhr);\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText), null);\n            } else {\n                callback(null, xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback(null, 'Network error');\n        xhr.send();\n    }\n\n    postJSON(url, obj, callback) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', url, true);\n        this.setToken(xhr);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(JSON.parse(xhr.responseText), null);\n            } else {\n                callback(null, xhr.statusText);\n            }\n        };\n        xhr.onerror = () => callback(null, 'Network error');\n        xhr.send(JSON.stringify(obj));\n    }\n\n    deleteJSON(url, callback) {\n        setTimeout(() => {\n            const xhr = new XMLHttpRequest();\n            xhr.open('DELETE', url, true);\n            this.setToken(xhr);\n            xhr.onload = () => {\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    callback(xhr.responseText, null);\n                } else {\n                    callback(null, xhr.statusText);\n                }\n            };\n            xhr.onerror = () => callback(null, 'Network error');\n            xhr.send();\n        }, Math.random() * 1000);\n    }\n}\n```",
      "```javascript\nclass JSONHttpClient {\n  constructor() {\n    this.token = localStorage.getItem('token') || 'randomToken';\n  }\n\n  setToken(req) {\n    req.setRequestHeader('Authorization', `Bearer ${this.token}`);\n  }\n\n  getJSON(url, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    this.setToken(xhr);\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(JSON.parse(xhr.responseText), null);\n      } else {\n        callback(null, xhr.statusText);\n      }\n    };\n    xhr.onerror = () => callback(null, 'Network error');\n    xhr.send();\n  }\n\n  postJSON(url, obj, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    this.setToken(xhr);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(JSON.parse(xhr.responseText), null);\n      } else {\n        callback(null, xhr.statusText);\n      }\n    };\n    xhr.onerror = () => callback(null, 'Network error');\n    xhr.send(JSON.stringify(obj));\n  }\n\n  deleteJSON(url, callback) {\n    setTimeout(() => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('DELETE', url);\n      this.setToken(xhr);\n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          callback(xhr.responseText, null);\n        } else {\n          callback(null, xhr.statusText);\n        }\n      };\n      xhr.onerror = () => callback(null, 'Network error');\n      xhr.send();\n    }, Math.random() * 1000);\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a class that simulates the behavior of an EventSource object, which is used to receive server-sent events (SSE) over HTTP. The class should handle the connection, reception of events, and error handling.\n\nClass Description: The `EventSource` class is designed to establish a persistent connection to a server using HTTP and receive server-sent events. It manages the connection state, handles incoming events, and dispatches them to appropriate event handlers. The class also supports reconnection in case of errors or connection loss.\n\nAttributes:\n\n- `URL`: [String] - The URL to which the EventSource connects to receive server-sent events.\n- `readyState`: [Number] - Represents the current state of the connection. Possible values are `CONNECTING` (0), `OPEN` (1), and `CLOSED` (2).\n- `_pollTimer`: [Object] - A timer object used to manage the polling interval for reconnection attempts.\n- `_xhr`: [Object] - The XMLHttpRequest object used to make HTTP requests to the server.\n\nMethods:\n\n- `poll()`: [Function] -> [Void] - Initiates a new HTTP request to the server to receive events. Handles the response, processes the events, and manages the connection state.\n- `close()`: [Function]() -> [Void] - Closes the connection to the server, sets the `readyState` to `CLOSED`, and stops any ongoing polling.\n- `dispatchEvent(type, event)`: [Function]([String], [Object]) -> [Void] - Dispatches an event to the registered event handlers based on the event type.\n- `addEventListener(type, handler)`: [Function]([String], [Function]) -> [Void] - Registers an event handler for a specific event type.\n- `removeEventListener()`: [Function]() -> [Void] - Placeholder method for removing event listeners (not implemented in the reference code).\n\nAdditional Classes:\n\n- `MessageEvent`: [Class] - Represents an event received from the server. Contains the event data, origin, and last event ID.\n\nAttributes of `MessageEvent`:\n\n- `data`: [String] - The data payload of the event.\n- `type`: [String] - The type of the event, defaulting to 'message'.\n- `lastEventId`: [String] - The ID of the last received event.\n- `origin`: [String] - The origin URL of the event.\n\nMethods of `MessageEvent`:\n\n- `MessageEvent(data, origin, lastEventId)`: [Constructor]([String], [String], [String]) -> [Object] - Initializes a new `MessageEvent` instance with the provided data, origin, and last event ID.",
    "Canonical_solution": "var EventSource = function (url) {\n  var eventsource = this,\n      interval = 500,\n      lastEventId = null,\n      cache = '';\n\n  if (!url || typeof url != 'string') {\n    throw new SyntaxError('Not enough arguments');\n  }\n\n  this.URL = url;\n  this.readyState = this.CONNECTING;\n  this._pollTimer = null;\n  this._xhr = null;\n\n  function poll() {\n    try {\n      if (eventsource.readyState == eventsource.CLOSED) return;\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', eventsource.URL, true);\n      xhr.setRequestHeader('Accept', 'text/event-stream');\n      xhr.setRequestHeader('Cache-Control', 'no-cache');\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n      if (lastEventId != null) xhr.setRequestHeader('Last-Event-ID', lastEventId);\n      cache = '';\n\n      xhr.timeout = 50000;\n      xhr.onreadystatechange = function () {\n        var status = 0;\n        try {\n          status = xhr.status;\n        } catch (e) {}\n\n        if ((this.readyState == 3 || this.readyState == 4) && status == 200) {\n          if (eventsource.readyState == eventsource.CONNECTING) {\n            eventsource.readyState = eventsource.OPEN;\n            eventsource.dispatchEvent('open', { type: 'open' });\n          }\n\n          var responseText = '';\n          try {\n            responseText = this.responseText || '';\n          } catch (e) {}\n\n          var parts = responseText.substr(cache.length).split(\"\\n\"),\n              eventType = 'message',\n              data = [],\n              i = 0,\n              line = '';\n\n          cache = responseText;\n\n          for (; i < parts.length; i++) {\n            line = parts[i].replace(reTrim, '');\n            if (line.indexOf('event') == 0) {\n              eventType = line.replace(/event:?\\s*/, '');\n            } else if (line.indexOf('data') == 0) {\n              data.push(line.replace(/data:?\\s*/, ''));\n            } else if (line.indexOf('id:') == 0) {\n              lastEventId = line.replace(/id:?\\s*/, '');\n            } else if (line.indexOf('id') == 0) {\n              lastEventId = null;\n            } else if (line == '') {\n              if (data.length) {\n                var event = new MessageEvent(data.join('\\n'), eventsource.url, lastEventId);\n                eventsource.dispatchEvent(eventType, event);\n                data = [];\n                eventType = 'message';\n              }\n            }\n          }\n\n          if (this.readyState == 4) pollAgain(this);\n        } else if (eventsource.readyState !== eventsource.CLOSED) {\n          if (this.readyState == 4) {\n            eventsource.readyState = eventsource.CONNECTING;\n            eventsource.dispatchEvent('error', { type: 'error' });\n            pollAgain(this);\n          } else if (this.readyState == 0) {\n            pollAgain(this);\n          }\n        }\n      };\n\n      xhr.send();\n\n      setTimeout(function () {\n        if (true || xhr.readyState == 3) xhr.abort();\n      }, xhr.timeout);\n\n      eventsource._xhr = xhr;\n\n    } catch (e) {\n      eventsource.dispatchEvent('error', { type: 'error', data: e.message });\n    }\n  };\n\n  poll();\n};\n\nEventSource.prototype = {\n  close: function () {\n    this.readyState = this.CLOSED;\n    clearInterval(this._pollTimer);\n    this._xhr.abort();\n  },\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  dispatchEvent: function (type, event) {\n    var handlers = this['_' + type + 'Handlers'];\n    if (handlers) {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i].call(this, event);\n      }\n    }\n\n    if (this['on' + type]) {\n      this['on' + type].call(this, event);\n    }\n  },\n  addEventListener: function (type, handler) {\n    if (!this['_' + type + 'Handlers']) {\n      this['_' + type + 'Handlers'] = [];\n    }\n    this['_' + type + 'Handlers'].push(handler);\n  },\n  removeEventListener: function () {},\n  onerror: null,\n  onmessage: null,\n  onopen: null,\n  readyState: 0,\n  URL: ''\n};\n\nvar MessageEvent = function (data, origin, lastEventId) {\n  this.data = data;\n  this.origin = origin;\n  this.lastEventId = lastEventId || '';\n};\n\nMessageEvent.prototype = {\n  data: null,\n  type: 'message',\n  lastEventId: '',\n  origin: ''\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport json\nimport time\nimport threading\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom urllib.parse import urlparse\n\nclass EventSource:\n    def __init__(self, url):\n        self.URL = url\n        self.readyState = 0\n        self._pollTimer = None\n        self._xhr = None\n        self._eventHandlers = {}\n        self._lastEventId = None\n\n    def poll(self):\n        if self.readyState == 1:\n            self._xhr = self._createXHR()\n            self._xhr.open('GET', self.URL, True)\n            self._xhr.onreadystatechange = self._onreadystatechange\n            self._xhr.send()\n\n    def close(self):\n        if self.readyState == 1:\n            self.readyState = 2\n            if self._xhr:\n                self._xhr.abort()\n            if self._pollTimer:\n                self._pollTimer.cancel()\n            self._xhr = None\n            self._pollTimer = None\n\n    def dispatchEvent(self, type, event):\n        if type in self._eventHandlers:\n            for handler in self._eventHandlers[type]:\n                handler(event)\n\n    def addEventListener(self, type, handler):\n        if type not in self._eventHandlers:\n            self._eventHandlers[type] = []\n        self._eventHandlers[type].append(handler)\n\n    def removeEventListener(self):\n        pass\n\n    def _onreadystatechange(self):\n        if self.readyState == 1 and self._xhr.readyState == 4:\n            if self._xhr.status == 200:\n                response = self._xhr.responseText\n                events = response.split('\\n')\n                for event in events:\n                    if event.strip() == '':\n                        continue\n                    event_data = json.loads(event)\n                    event_type = event_data.get('event', 'message')\n                    event_data.pop('event', None)\n                    event_data['lastEventId'] = self._lastEventId\n                    self._lastEventId = event_data.get('id', None)\n                    event_data['origin'] = urlparse(self.URL).hostname\n                    message_event = MessageEvent(**event_data)\n                    self.dispatchEvent(event_type, message_event)\n            else:\n                self.readyState = 2\n                self.dispatchEvent('error', MessageEvent({'data': 'Error: ' + str(self._xhr.status), 'type': 'error'}))\n                self._schedulePoll()\n\n    def _createXHR(self):\n        return {\n            'open': lambda method, url, async: None,\n            'onreadystatechange': lambda: None,\n            'send': lambda: None,\n            'status': 200,\n            'responseText': ''\n        }\n\n    def _schedulePoll(self):\n        if self.readyState == 2:\n            self.readyState = 0\n            self._pollTimer = threading.Timer(5, self.poll)\n            self._pollTimer.start()\n\nclass MessageEvent:\n    def __init__(self, data, origin, lastEventId):\n        self.data = data\n        self.type = 'message'\n        self.lastEventId = lastEventId\n        self.origin = origin\n\ndef run_server():\n    class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):\n        def do_GET(self):\n            if self.path == '/events':\n                self.send_response(200)\n                self.send_header('Content-Type', 'text/event-stream')\n                self.end_headers()\n                while True:\n                    time.sleep(1)\n                    self.wfile.write(b\"id: 1\\n\")\n                    self.wfile.write(b\"data: Hello, World!\\n\\n\")\n\n    server_address = ('', 8000)\n    httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)\n    httpd.serve_forever()\n\nif __name__ == '__main__':\n    run_server()\n```",
      "```javascript\nclass EventSource {\n  constructor(url) {\n    this.URL = url;\n    this.readyState = 0;\n    this._pollTimer = null;\n    this._xhr = new XMLHttpRequest();\n    this._xhr.addEventListener('open', this.poll.bind(this));\n    this._xhr.addEventListener('message', (event) => {\n      const messageEvent = new MessageEvent(event.data, event.origin, event.lastEventId);\n      this.dispatchEvent('message', messageEvent);\n    });\n    this._xhr.addEventListener('error', () => {\n      this.readyState = 2;\n      this.dispatchEvent('error', new MessageEvent('', '', ''));\n      this.poll();\n    });\n  }\n\n  poll() {\n    if (this.readyState === 1) {\n      this._xhr.open('GET', this.URL, true);\n      this._xhr.send();\n    }\n  }\n\n  close() {\n    this.readyState = 2;\n    this._xhr.abort();\n    clearTimeout(this._pollTimer);\n  }\n\n  dispatchEvent(type, event) {\n    if (typeof this[type] === 'function') {\n      this[type](event);\n    }\n  }\n\n  addEventListener(type, handler) {\n    this[type] = handler;\n  }\n\n  removeEventListener() {\n    // Placeholder method for removing event listeners\n  }\n}\n\nclass MessageEvent {\n  constructor(data, origin, lastEventId) {\n    this.data = data;\n    this.type = 'message';\n    this.lastEventId = lastEventId;\n    this.origin = origin;\n  }\n}\n```",
      "```javascript\nclass EventSource {\n  constructor(url) {\n    this.URL = url;\n    this.readyState = EventSource.CONNECTING;\n    this._pollTimer = null;\n    this._xhr = new XMLHttpRequest();\n    this._xhr.addEventListener('open', () => {\n      this.readyState = EventSource.OPEN;\n      this._xhr.send();\n    });\n    this._xhr.addEventListener('message', (event) => {\n      const messageEvent = new MessageEvent(event.data, event.origin, event.lastEventId);\n      this.dispatchEvent('message', messageEvent);\n    });\n    this._xhr.addEventListener('error', () => {\n      this.readyState = EventSource.CLOSED;\n      this.dispatchEvent('error', new MessageEvent('', '', ''));\n      this.poll();\n    });\n    this._xhr.addEventListener('close', () => {\n      this.readyState = EventSource.CLOSED;\n      this.dispatchEvent('close', new MessageEvent('', '', ''));\n      this.poll();\n    });\n  }\n\n  poll() {\n    if (this.readyState === EventSource.CLOSED) {\n      this.readyState = EventSource.CONNECTING;\n      this._xhr.open('GET', this.URL, true);\n      this._xhr.send();\n    }\n  }\n\n  close() {\n    this.readyState = EventSource.CLOSED;\n    this._xhr.abort();\n    clearTimeout(this._pollTimer);\n  }\n\n  dispatchEvent(type, event) {\n    if (this['on' + type]) {\n      this['on' + type](event);\n    }\n  }\n\n  addEventListener(type, handler) {\n    this['on' + type] = handler;\n  }\n\n  removeEventListener() {\n    // Placeholder method for removing event listeners\n  }\n}\n\nclass MessageEvent {\n  constructor(data, origin, lastEventId) {\n    this.data = data;\n    this.type = 'message';\n    this.lastEventId = lastEventId;\n    this.origin = origin;\n  }\n}\n```",
      "```python\nimport time\nimport threading\nimport urllib.request\n\nclass EventSource:\n    def __init__(self, url):\n        self.URL = url\n        self.readyState = 0\n        self._pollTimer = None\n        self._xhr = None\n        self._eventHandlers = {}\n\n    def poll(self):\n        if self.readyState == 1:\n            self._xhr = urllib.request.urlopen(self.URL)\n            for line in self._xhr:\n                if line.decode().strip() == '':\n                    continue\n                event = self._process_event(line.decode())\n                self.dispatchEvent(event.type, event)\n\n    def close(self):\n        self.readyState = 2\n        if self._xhr:\n            self._xhr.close()\n        if self._pollTimer:\n            self._pollTimer.cancel()\n\n    def dispatchEvent(self, type, event):\n        if type in self._eventHandlers:\n            for handler in self._eventHandlers[type]:\n                handler(event)\n\n    def addEventListener(self, type, handler):\n        if type not in self._eventHandlers:\n            self._eventHandlers[type] = []\n        self._eventHandlers[type].append(handler)\n\n    def removeEventListener(self):\n        pass\n\n    def _process_event(self, data):\n        event = MessageEvent(data)\n        return event\n\nclass MessageEvent:\n    def __init__(self, data, origin=None, lastEventId=None):\n        self.data = data\n        self.type = 'message'\n        self.lastEventId = lastEventId\n        self.origin = origin\n\n    def __str__(self):\n        return f\"MessageEvent(data={self.data}, type={self.type}, lastEventId={self.lastEventId}, origin={self.origin})\"\n```",
      "```javascript\nclass EventSource {\n    constructor(url) {\n        this.URL = url;\n        this.readyState = 0;\n        this._pollTimer = null;\n        this._xhr = new XMLHttpRequest();\n        this._xhr.addEventListener('open', () => {\n            this.readyState = 1;\n            this._xhr.send();\n        });\n        this._xhr.addEventListener('message', (event) => {\n            const messageEvent = new MessageEvent(event.data, event.origin, event.lastEventId);\n            this.dispatchEvent('message', messageEvent);\n        });\n        this._xhr.addEventListener('error', () => {\n            this.readyState = 2;\n            this.dispatchEvent('error', new MessageEvent('', '', ''));\n            this.poll();\n        });\n        this._xhr.addEventListener('close', () => {\n            this.readyState = 2;\n            this.dispatchEvent('close', new MessageEvent('', '', ''));\n            this.poll();\n        });\n    }\n\n    poll() {\n        if (this.readyState === 0) {\n            this._xhr.open('GET', this.URL, true);\n            this.readyState = 0;\n        }\n    }\n\n    close() {\n        this.readyState = 2;\n        this._xhr.abort();\n        clearTimeout(this._pollTimer);\n        this._pollTimer = null;\n    }\n\n    dispatchEvent(type, event) {\n        const handlers = this[type + 'Event'];\n        if (handlers) {\n            for (const handler of handlers) {\n                handler(event);\n            }\n        }\n    }\n\n    addEventListener(type, handler) {\n        if (!this[type + 'Event']) {\n            this[type + 'Event'] = [];\n        }\n        this[type + 'Event'].push(handler);\n    }\n\n    removeEventListener() {\n        // Placeholder method for removing event listeners\n    }\n}\n\nclass MessageEvent {\n    constructor(data, origin, lastEventId) {\n        this.data = data;\n        this.type = 'message';\n        this.lastEventId = lastEventId;\n        this.origin = origin;\n    }\n}\n```",
      "```python\nimport time\nimport json\nimport http.client\nfrom threading import Thread\n\nclass EventSource:\n    CONNECTING = 0\n    OPEN = 1\n    CLOSED = 2\n\n    def __init__(self, url):\n        self.URL = url\n        self.readyState = self.CONNECTING\n        self._pollTimer = None\n        self._xhr = None\n        self._eventHandlers = {}\n        self._lastEventId = None\n\n    def poll(self):\n        if self.readyState == self.OPEN:\n            self._xhr = http.client.HTTPConnection(self.URL.split('/')[2])\n            self._xhr.request(\"GET\", self.URL)\n            response = self._xhr.getresponse()\n            if response.status == 200:\n                self.readyState = self.OPEN\n                self._processEvents(response.read())\n                self._xhr.close()\n                self._xhr = None\n            else:\n                self.readyState = self.CLOSED\n                self._handleError(response.status, response.reason)\n        else:\n            self._schedulePoll()\n\n    def close(self):\n        self.readyState = self.CLOSED\n        if self._pollTimer:\n            self._pollTimer.cancel()\n            self._pollTimer = None\n\n    def dispatchEvent(self, type, event):\n        if type in self._eventHandlers:\n            for handler in self._eventHandlers[type]:\n                handler(event)\n\n    def addEventListener(self, type, handler):\n        if type not in self._eventHandlers:\n            self._eventHandlers[type] = []\n        self._eventHandlers[type].append(handler)\n\n    def removeEventListener(self):\n        pass\n\n    def _processEvents(self, data):\n        events = json.loads(data.decode('utf-8'))\n        for event in events:\n            messageEvent = MessageEvent(event['data'], event['origin'], event['lastEventId'])\n            self.dispatchEvent('message', messageEvent)\n\n    def _handleError(self, status, reason):\n        self.readyState = self.CLOSED\n        self.dispatchEvent('error', {'status': status, 'reason': reason})\n        self._schedulePoll()\n\n    def _schedulePoll(self):\n        if self.readyState != self.CONNECTING:\n            self.readyState = self.CONNECTING\n            self._pollTimer = Thread(target=self.poll, daemon=True)\n            self._pollTimer.start()\n\nclass MessageEvent:\n    def __init__(self, data, origin, lastEventId):\n        self.data = data\n        self.type = 'message'\n        self.lastEventId = lastEventId\n        self.origin = origin\n```",
      "```javascript\nclass EventSource {\n    constructor(url) {\n        this.URL = url;\n        this.readyState = 0;\n        this._pollTimer = null;\n        this._xhr = new XMLHttpRequest();\n        this._eventHandlers = {};\n        this._xhr.addEventListener('open', () => {\n            this.readyState = 1;\n            this.poll();\n        });\n        this._xhr.addEventListener('message', (event) => {\n            const messageEvent = new MessageEvent(event.data, event.origin, event.lastEventId);\n            this.dispatchEvent('message', messageEvent);\n        });\n        this._xhr.addEventListener('error', () => {\n            this.readyState = 2;\n            this.dispatchEvent('error', new MessageEvent('', '', ''));\n            this.poll();\n        });\n        this._xhr.addEventListener('close', () => {\n            this.readyState = 2;\n            this.dispatchEvent('close', new MessageEvent('', '', ''));\n        });\n    }\n\n    poll() {\n        if (this.readyState === 1) {\n            this._xhr.open('GET', this.URL, true);\n            this._xhr.send();\n        } else if (this.readyState === 0) {\n            this._pollTimer = setTimeout(() => this.poll(), 1000);\n        }\n    }\n\n    close() {\n        this.readyState = 2;\n        this._xhr.abort();\n        clearTimeout(this._pollTimer);\n        this._pollTimer = null;\n    }\n\n    dispatchEvent(type, event) {\n        const handlers = this._eventHandlers[type];\n        if (handlers) {\n            for (const handler of handlers) {\n                handler(event);\n            }\n        }\n    }\n\n    addEventListener(type, handler) {\n        if (!this._eventHandlers[type]) {\n            this._eventHandlers[type] = [];\n        }\n        this._eventHandlers[type].push(handler);\n    }\n\n    removeEventListener() {\n        // Placeholder method for removing event listeners\n    }\n}\n\nclass MessageEvent {\n    constructor(data, origin, lastEventId) {\n        this.data = data;\n        this.type = 'message';\n        this.lastEventId = lastEventId;\n        this.origin = origin;\n    }\n}\n```",
      "```javascript\nclass EventSource {\n  constructor(url) {\n    this.URL = url;\n    this.readyState = EventSource.CONNECTING;\n    this._pollTimer = null;\n    this._xhr = new XMLHttpRequest();\n    this._eventHandlers = {};\n    this._xhr.onreadystatechange = () => {\n      if (this.readyState === EventSource.OPEN) {\n        this.poll();\n      }\n    };\n    this._xhr.onerror = () => {\n      this.readyState = EventSource.CLOSED;\n      this.dispatchEvent('error', new MessageEvent('error', ''));\n      this.reconnect();\n    };\n  }\n\n  poll() {\n    this._xhr.open('GET', this.URL, true);\n    this._xhr.setRequestHeader('Cache-Control', 'no-cache');\n    this._xhr.setRequestHeader('Connection', 'keep-alive');\n    this._xhr.setRequestHeader('Accept', 'text/event-stream');\n    this._xhr.send();\n  }\n\n  close() {\n    this.readyState = EventSource.CLOSED;\n    this._xhr.abort();\n    clearTimeout(this._pollTimer);\n  }\n\n  dispatchEvent(type, event) {\n    if (this._eventHandlers[type]) {\n      this._eventHandlers[type].forEach(handler => handler(event));\n    }\n  }\n\n  addEventListener(type, handler) {\n    if (!this._eventHandlers[type]) {\n      this._eventHandlers[type] = [];\n    }\n    this._eventHandlers[type].push(handler);\n  }\n\n  reconnect() {\n    if (this.readyState === EventSource.CLOSED) {\n      this.readyState = EventSource.CONNECTING;\n      this._pollTimer = setTimeout(() => {\n        this._xhr = new XMLHttpRequest();\n        this.poll();\n      }, 1000);\n    }\n  }\n}\n\nclass MessageEvent {\n  constructor(data, origin, lastEventId) {\n    this.data = data;\n    this.type = 'message';\n    this.lastEventId = lastEventId;\n    this.origin = origin;\n  }\n}\n\nEventSource.CONNECTING = 0;\nEventSource.OPEN = 1;\nEventSource.CLOSED = 2;\n```",
      "```javascript\nclass EventSource {\n  constructor(url) {\n    this.URL = url;\n    this.readyState = EventSource.CONNECTING;\n    this._pollTimer = null;\n    this._xhr = new XMLHttpRequest();\n    this._xhr.addEventListener('open', this.poll.bind(this));\n    this._xhr.addEventListener('message', this.dispatchEvent.bind(this, 'message'));\n    this._xhr.addEventListener('error', this.dispatchEvent.bind(this, 'error'));\n    this._xhr.addEventListener('close', this.handleClose.bind(this));\n  }\n\n  poll() {\n    this._xhr.open('GET', this.URL, true);\n    this._xhr.send();\n  }\n\n  close() {\n    this.readyState = EventSource.CLOSED;\n    this._xhr.abort();\n    clearTimeout(this._pollTimer);\n  }\n\n  dispatchEvent(type, event) {\n    if (this.readyState === EventSource.OPEN) {\n      const handler = this['on' + type];\n      if (handler) {\n        handler(event);\n      }\n    }\n  }\n\n  addEventListener(type, handler) {\n    this['on' + type] = handler;\n  }\n\n  removeEventListener() {\n    // Placeholder method for removing event listeners\n  }\n\n  handleClose() {\n    this.readyState = EventSource.CLOSED;\n    this.dispatchEvent('close', new MessageEvent('close', '', ''));\n    this.reconnect();\n  }\n\n  reconnect() {\n    if (this.readyState === EventSource.CLOSED) {\n      this._pollTimer = setTimeout(() => {\n        this.readyState = EventSource.CONNECTING;\n        this.poll();\n      }, 1000);\n    }\n  }\n}\n\nclass MessageEvent {\n  constructor(data, origin, lastEventId) {\n    this.data = data;\n    this.type = 'message';\n    this.lastEventId = lastEventId;\n    this.origin = origin;\n  }\n}\n```",
      "```python\nimport time\nimport threading\nimport json\nimport urllib.request\n\nclass EventSource:\n    CONNECTING = 0\n    OPEN = 1\n    CLOSED = 2\n\n    def __init__(self, url):\n        self.URL = url\n        self.readyState = self.CONNECTING\n        self._pollTimer = None\n        self._xhr = None\n        self._eventHandlers = {}\n\n    def poll(self):\n        if self.readyState == self.OPEN:\n            self._xhr = urllib.request.urlopen(self.URL)\n            for line in self._xhr:\n                if line.decode().strip() == '':\n                    continue\n                event = json.loads(line.decode())\n                self.dispatchEvent(event['type'], MessageEvent(event['data'], event.get('origin', ''), event.get('lastEventId', '')))\n            self._xhr.close()\n            self._xhr = None\n            threading.Timer(1, self.poll).start()\n        else:\n            threading.Timer(1, self.poll).start()\n\n    def close(self):\n        self.readyState = self.CLOSED\n        if self._xhr:\n            self._xhr.close()\n            self._xhr = None\n        if self._pollTimer:\n            self._pollTimer.cancel()\n            self._pollTimer = None\n\n    def dispatchEvent(self, type, event):\n        if type in self._eventHandlers:\n            for handler in self._eventHandlers[type]:\n                handler(event)\n\n    def addEventListener(self, type, handler):\n        if type not in self._eventHandlers:\n            self._eventHandlers[type] = []\n        self._eventHandlers[type].append(handler)\n\n    def removeEventListener(self):\n        pass\n\nclass MessageEvent:\n    def __init__(self, data, origin, lastEventId):\n        self.data = data\n        self.type = 'message'\n        self.lastEventId = lastEventId\n        self.origin = origin\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a function that handles HTTP requests using XMLHttpRequest in JavaScript, including request configuration, progress tracking, and response handling.\n\nFunction Description: The function `makeRequest` initiates and manages an HTTP request using XMLHttpRequest. It configures the request with provided settings, tracks upload/download progress, handles timeouts, and processes the response. The function supports both successful and error responses, with appropriate callbacks for each scenario.\n\nInput:\n- `resolve`: [Function] - A callback function to handle the final resolution of the request (either success or error).\n- `config`: [Object] - Configuration object containing properties to set on the XMLHttpRequest instance.\n- `method`: [String] - HTTP method for the request (e.g., 'GET', 'POST').\n- `fullUrl`: [String] - The complete URL for the request.\n- `headers`: [Object] - Key-value pairs representing HTTP headers to set on the request.\n- `payload`: [Any] - Data to send with the request (for POST/PUT requests).\n- `defaultTimeout`: [Number] - Timeout duration in milliseconds for the request.\n- `xhrExtra`: [Any] - Additional data to pass to error/timeout handlers.\n- Event handlers:\n  - `onRequestProgress`: [Function] - Callback for upload progress events.\n  - `onRequestStart`: [Function] - Callback when the request starts.\n  - `onRequestEnd`: [Function] - Callback when the request ends.\n  - `onResponseStart`: [Function] - Callback when the response starts.\n  - `onResponseProgress`: [Function] - Callback for download progress events.\n  - `onResponseEnd`: [Function] - Callback when the response ends.\n  - `onTimeoutError`: [Function] - Callback for timeout errors.\n  - `onSuccess`: [Function] - Callback for successful responses.\n  - `onError`: [Function] - Callback for error responses.\n  - `onBeforeRequest`: [Function] - Callback before sending the request.\n  - `createAbortListener`: [Function] - Creates a listener for abort events.\n  - `parseResponse`: [Function] - Parses successful response data.\n  - `parseErrorResponse`: [Function] - Parses error response data.\n  - `getResponseHeaders`: [Function] - Parses raw response headers.\n\nOutput: None (The function uses callbacks to handle results asynchronously).",
    "Canonical_solution": "function makeRequest(resolve) {\n    const xhr = new XMLHttpRequest();\n    xhr.timeout = defaultTimeout;\n\n    const abort = () => xhr.abort();\n\n    Object.entries(config).forEach(([name, value]) => {\n        xhr[name] = value;\n    });\n\n    xhr.open(method, fullUrl, true);\n\n    Object.entries(headers).forEach(([name, value]) => xhr.setRequestHeader(name, value as string));\n\n    const unmountListener = createAbortListener(0, xhrExtra, abort, resolve);\n\n    xhr.upload.onprogress = onRequestProgress;\n\n    xhr.onloadstart = (): void => {\n        onRequestEnd();\n        onResponseStart();\n    };\n\n    xhr.onprogress = onResponseProgress;\n\n    xhr.onloadend = () => {\n        onResponseEnd();\n        unmountListener();\n    };\n\n    xhr.ontimeout = () => onTimeoutError(0, xhrExtra, resolve);\n\n    xhr.onreadystatechange = (e: Event) => {\n        const event = e as unknown as ProgressEvent<XMLHttpRequest>;\n        const finishedState = 4;\n\n        if (event.target && event.target.readyState === finishedState) {\n            const { status } = event.target;\n            const success = String(status).startsWith(\"2\") || String(status).startsWith(\"3\");\n            const responseHeaders = getResponseHeaders(xhr.getAllResponseHeaders());\n\n            if (success) {\n                const data = parseResponse(event.target.response);\n                onSuccess(data, status, { headers: responseHeaders }, resolve);\n            } else {\n                const data = parseErrorResponse(event.target.response);\n                onError(data, status, { headers: responseHeaders }, resolve);\n            }\n        }\n    };\n\n    onBeforeRequest();\n    onRequestStart();\n\n    xhr.send(payload);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var timeout = defaultTimeout || 0;\n\n  xhr.open(method, fullUrl, true);\n\n  for (var header in headers) {\n    xhr.setRequestHeader(header, headers[header]);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      clearTimeout(timeoutId);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        onSuccess(parseResponse(xhr.responseText, xhr));\n      } else {\n        onError(parseErrorResponse(xhr.responseText, xhr));\n      }\n      if (onResponseEnd) {\n        onResponseEnd();\n      }\n    }\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      if (onRequestProgress) {\n        onRequestProgress(e.loaded, e.total);\n      }\n    }\n  };\n\n  xhr.onerror = function() {\n    clearTimeout(timeoutId);\n    if (onError) {\n      onError(xhr);\n    }\n  };\n\n  xhr.ontimeout = function() {\n    clearTimeout(timeoutId);\n    if (onTimeoutError) {\n      onTimeoutError(xhrExtra);\n    }\n  };\n\n  if (onBeforeRequest) {\n    onBeforeRequest();\n  }\n\n  if (onRequestStart) {\n    onRequestStart();\n  }\n\n  xhr.send(payload);\n\n  if (timeout) {\n    timeoutId = setTimeout(function() {\n      xhr.abort();\n      if (onTimeoutError) {\n        onTimeoutError(xhrExtra);\n      }\n    }, timeout);\n  }\n\n  if (createAbortListener) {\n    createAbortListener(xhr, function() {\n      clearTimeout(timeoutId);\n      if (onError) {\n        onError(xhr);\n      }\n    });\n  }\n}\n```",
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var abortListener;\n\n  function handleProgress(event) {\n    if (event.lengthComputable) {\n      onRequestProgress(event.loaded, event.total);\n      onResponseProgress(event.loaded, event.total);\n    }\n  }\n\n  function handleTimeout() {\n    xhr.abort();\n    onTimeoutError(xhrExtra);\n    resolve('timeout');\n  }\n\n  function handleResponse() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      onResponseEnd();\n      onSuccess(parseResponse(xhr.responseText));\n    } else {\n      onError(parseErrorResponse(xhr.responseText));\n    }\n    resolve('complete');\n  }\n\n  function handleError() {\n    onError(parseErrorResponse(xhr.responseText));\n    resolve('error');\n  }\n\n  function handleAbort() {\n    onRequestEnd();\n    onResponseEnd();\n    resolve('aborted');\n  }\n\n  function handleStart() {\n    onRequestStart();\n    onResponseStart();\n    onBeforeRequest();\n    if (defaultTimeout) {\n      timeoutId = setTimeout(handleTimeout, defaultTimeout);\n    }\n    if (createAbortListener) {\n      abortListener = createAbortListener(handleAbort);\n    }\n  }\n\n  xhr.open(method, fullUrl, true);\n  for (var header in headers) {\n    xhr.setRequestHeader(header, headers[header]);\n  }\n  xhr.upload.onprogress = handleProgress;\n  xhr.onprogress = handleProgress;\n  xhr.onload = handleResponse;\n  xhr.onerror = handleError;\n  xhr.onabort = handleAbort;\n  xhr.ontimeout = handleTimeout;\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === XMLHttpRequest.OPENED) {\n      handleStart();\n      xhr.send(payload);\n    } else if (xhr.readyState === XMLHttpRequest.DONE) {\n      clearTimeout(timeoutId);\n      if (abortListener) {\n        abortListener.remove();\n      }\n    }\n  };\n\n  xhr.onloadend = function() {\n    onRequestEnd();\n    onResponseEnd();\n  };\n\n  xhr.onheaderreceived = function() {\n    getResponseHeaders(xhr.getAllResponseHeaders());\n  };\n}\n```",
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var abortListener;\n\n  function handleProgress(event) {\n    if (event.lengthComputable) {\n      onRequestProgress(event.loaded, event.total);\n      onResponseProgress(event.loaded, event.total);\n    }\n  }\n\n  function handleTimeout() {\n    xhr.abort();\n    onTimeoutError(xhrExtra);\n    resolve({ status: 'timeout', xhr: xhr });\n  }\n\n  function handleResponse() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      onResponseEnd();\n      onSuccess(parseResponse(xhr.responseText, xhr));\n    } else {\n      onError(parseErrorResponse(xhr.responseText, xhr));\n    }\n    resolve({ status: xhr.status, xhr: xhr });\n  }\n\n  function handleError() {\n    onError(parseErrorResponse(xhr.responseText, xhr));\n    resolve({ status: xhr.status, xhr: xhr });\n  }\n\n  function handleAbort() {\n    onRequestEnd();\n    onResponseEnd();\n    resolve({ status: 'aborted', xhr: xhr });\n  }\n\n  function handleStart() {\n    onRequestStart();\n    onResponseStart();\n    if (onBeforeRequest) {\n      onBeforeRequest();\n    }\n  }\n\n  function setConfig() {\n    xhr.open(method, fullUrl, true);\n    for (var key in headers) {\n      xhr.setRequestHeader(key, headers[key]);\n    }\n    if (defaultTimeout) {\n      timeoutId = setTimeout(handleTimeout, defaultTimeout);\n    }\n    if (createAbortListener) {\n      abortListener = createAbortListener(handleAbort);\n    }\n  }\n\n  function sendRequest() {\n    xhr.onload = handleResponse;\n    xhr.onerror = handleError;\n    xhr.onabort = handleAbort;\n    xhr.upload.onprogress = handleProgress;\n    xhr.onprogress = handleProgress;\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        clearTimeout(timeoutId);\n        if (abortListener) {\n          abortListener.remove();\n        }\n      }\n    };\n    xhr.send(payload);\n  }\n\n  handleStart();\n  setConfig();\n  sendRequest();\n}\n```",
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var timeout = defaultTimeout || 0;\n\n  xhr.open(method, fullUrl, true);\n  for (var header in headers) {\n    xhr.setRequestHeader(header, headers[header]);\n  }\n\n  if (onBeforeRequest) {\n    onBeforeRequest(xhr);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      clearTimeout(timeoutId);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        if (onResponseEnd) {\n          onResponseEnd();\n        }\n        if (onSuccess) {\n          onSuccess(parseResponse ? parseResponse(xhr.responseText) : xhr.responseText, xhr);\n        }\n      } else {\n        if (onError) {\n          onError(parseErrorResponse ? parseErrorResponse(xhr.responseText) : xhr.responseText, xhr);\n        }\n      }\n      resolve();\n    }\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      if (onRequestProgress) {\n        onRequestProgress(e.loaded, e.total);\n      }\n    }\n  };\n\n  xhr.onerror = function() {\n    clearTimeout(timeoutId);\n    if (onError) {\n      onError(null, xhr);\n    }\n    resolve();\n  };\n\n  xhr.ontimeout = function() {\n    clearTimeout(timeoutId);\n    if (onTimeoutError) {\n      onTimeoutError(xhrExtra, xhr);\n    }\n    resolve();\n  };\n\n  xhr.onloadstart = function() {\n    if (onRequestStart) {\n      onRequestStart();\n    }\n    if (onResponseStart) {\n      onResponseStart();\n    }\n    if (timeout) {\n      timeoutId = setTimeout(function() {\n        xhr.abort();\n        if (onTimeoutError) {\n          onTimeoutError(xhrExtra, xhr);\n        }\n        resolve();\n      }, timeout);\n    }\n  };\n\n  xhr.onloadend = function() {\n    clearTimeout(timeoutId);\n    if (onRequestEnd) {\n      onRequestEnd();\n    }\n    if (onResponseEnd) {\n      onResponseEnd();\n    }\n  };\n\n  if (createAbortListener) {\n    createAbortListener(xhr, function() {\n      clearTimeout(timeoutId);\n      if (onError) {\n        onError(null, xhr);\n      }\n      resolve();\n    });\n  }\n\n  xhr.send(payload);\n}\n```",
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var abortController = new AbortController();\n  var abortListener = createAbortListener(abortController.signal);\n\n  xhr.open(method, fullUrl, true);\n  for (var header in headers) {\n    xhr.setRequestHeader(header, headers[header]);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      clearTimeout(timeoutId);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        onResponseEnd();\n        onSuccess(parseResponse(xhr.responseText, xhr));\n      } else {\n        onError(parseErrorResponse(xhr.responseText, xhr));\n      }\n      resolve();\n    }\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      onRequestProgress(e.loaded, e.total);\n    }\n  };\n\n  xhr.onprogress = function(e) {\n    if (e.lengthComputable) {\n      onResponseProgress(e.loaded, e.total);\n    }\n  };\n\n  xhr.ontimeout = function() {\n    clearTimeout(timeoutId);\n    onTimeoutError(xhrExtra);\n    resolve();\n  };\n\n  xhr.onerror = function() {\n    clearTimeout(timeoutId);\n    onError(xhrExtra);\n    resolve();\n  };\n\n  xhr.onabort = function() {\n    clearTimeout(timeoutId);\n    resolve();\n  };\n\n  onBeforeRequest();\n\n  onRequestStart();\n\n  xhr.send(payload);\n\n  timeoutId = setTimeout(function() {\n    xhr.abort();\n    onTimeoutError(xhrExtra);\n    resolve();\n  }, defaultTimeout);\n\n  onResponseStart();\n}\n```",
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var timeout = defaultTimeout || 0;\n\n  xhr.open(method, fullUrl, true);\n  for (var header in headers) {\n    xhr.setRequestHeader(header, headers[header]);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 1) {\n      onBeforeRequest(xhr);\n      if (onRequestStart) onRequestStart(xhr);\n      if (timeout) timeoutId = setTimeout(function() {\n        xhr.abort();\n        onTimeoutError(xhr, xhrExtra);\n        resolve(onError(xhr, xhrExtra));\n      }, timeout);\n    } else if (xhr.readyState === 4) {\n      clearTimeout(timeoutId);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        if (onResponseStart) onResponseStart(xhr);\n        if (onResponseProgress) onResponseProgress(xhr);\n        if (onResponseEnd) onResponseEnd(xhr);\n        var responseHeaders = getResponseHeaders(xhr.getAllResponseHeaders());\n        var parsedResponse = parseResponse(xhr.responseText, responseHeaders);\n        onSuccess(parsedResponse, responseHeaders);\n        resolve(onSuccess(parsedResponse, responseHeaders));\n      } else {\n        if (onResponseEnd) onResponseEnd(xhr);\n        var errorResponse = parseErrorResponse(xhr.responseText, xhr.status, xhr.statusText);\n        onError(errorResponse, xhrExtra);\n        resolve(onError(errorResponse, xhrExtra));\n      }\n    }\n  };\n\n  xhr.upload.onprogress = function(event) {\n    if (event.lengthComputable) {\n      if (onRequestProgress) onRequestProgress(event);\n    }\n  };\n\n  xhr.onerror = function() {\n    clearTimeout(timeoutId);\n    if (onError) onError(xhr, xhrExtra);\n    resolve(onError(xhr, xhrExtra));\n  };\n\n  xhr.ontimeout = function() {\n    clearTimeout(timeoutId);\n    xhr.abort();\n    onTimeoutError(xhr, xhrExtra);\n    resolve(onTimeoutError(xhr, xhrExtra));\n  };\n\n  xhr.onabort = function() {\n    clearTimeout(timeoutId);\n    if (onRequestEnd) onRequestEnd(xhr);\n    if (onResponseEnd) onResponseEnd(xhr);\n  };\n\n  xhr.send(payload);\n}\n```",
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var timeout = defaultTimeout || 0;\n\n  if (onBeforeRequest) {\n    onBeforeRequest();\n  }\n\n  xhr.open(method, fullUrl, true);\n\n  for (var header in headers) {\n    xhr.setRequestHeader(header, headers[header]);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      clearTimeout(timeoutId);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        if (onResponseEnd) {\n          onResponseEnd();\n        }\n        if (onSuccess) {\n          onSuccess(parseResponse ? parseResponse(xhr.responseText) : xhr.responseText, xhr);\n        }\n      } else {\n        if (onError) {\n          onError(parseErrorResponse ? parseErrorResponse(xhr.responseText) : xhr.responseText, xhr);\n        }\n      }\n      resolve();\n    }\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      if (onRequestProgress) {\n        onRequestProgress(e.loaded, e.total);\n      }\n    }\n  };\n\n  xhr.onerror = function() {\n    clearTimeout(timeoutId);\n    if (onError) {\n      onError(null, xhr);\n    }\n    resolve();\n  };\n\n  xhr.ontimeout = function() {\n    clearTimeout(timeoutId);\n    if (onTimeoutError) {\n      onTimeoutError(null, xhr);\n    }\n    resolve();\n  };\n\n  xhr.onloadstart = function() {\n    if (onRequestStart) {\n      onRequestStart();\n    }\n  };\n\n  xhr.onloadend = function() {\n    if (onResponseEnd) {\n      onResponseEnd();\n    }\n  };\n\n  xhr.onload = function() {\n    if (onResponseStart) {\n      onResponseStart();\n    }\n  };\n\n  xhr.onprogress = function(e) {\n    if (e.lengthComputable) {\n      if (onResponseProgress) {\n        onResponseProgress(e.loaded, e.total);\n      }\n    }\n  };\n\n  if (timeout) {\n    timeoutId = setTimeout(function() {\n      xhr.abort();\n      if (onTimeoutError) {\n        onTimeoutError(null, xhr);\n      }\n      resolve();\n    }, timeout);\n  }\n\n  if (createAbortListener) {\n    createAbortListener(xhr, function() {\n      clearTimeout(timeoutId);\n      if (onError) {\n        onError(null, xhr);\n      }\n      resolve();\n    });\n  }\n\n  xhr.send(payload);\n}\n```",
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var timeout = defaultTimeout || 0;\n  var abortListener;\n\n  function handleProgress(event) {\n    if (event.lengthComputable) {\n      var percentComplete = event.loaded / event.total * 100;\n      onRequestProgress(percentComplete);\n    }\n  }\n\n  function handleTimeout() {\n    xhr.abort();\n    onTimeoutError(xhrExtra);\n    resolve({ status: 'timeout', xhr: xhr });\n  }\n\n  function handleResponse() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      onResponseEnd();\n      var responseHeaders = getResponseHeaders(xhr.getAllResponseHeaders());\n      var parsedResponse = parseResponse(xhr.responseText, responseHeaders);\n      onSuccess(parsedResponse);\n      resolve({ status: 'success', xhr: xhr });\n    } else {\n      onError(xhr.status, xhr.statusText);\n      resolve({ status: 'error', xhr: xhr });\n    }\n  }\n\n  function handleError() {\n    onError(xhr.status, xhr.statusText);\n    resolve({ status: 'error', xhr: xhr });\n  }\n\n  function handleAbort() {\n    onRequestEnd();\n    onResponseEnd();\n    resolve({ status: 'aborted', xhr: xhr });\n  }\n\n  function startRequest() {\n    if (onBeforeRequest) {\n      onBeforeRequest();\n    }\n    if (onRequestStart) {\n      onRequestStart();\n    }\n    xhr.open(method, fullUrl, true);\n    for (var header in headers) {\n      xhr.setRequestHeader(header, headers[header]);\n    }\n    xhr.timeout = timeout;\n    xhr.onprogress = handleProgress;\n    xhr.ontimeout = handleTimeout;\n    xhr.onload = handleResponse;\n    xhr.onerror = handleError;\n    xhr.onabort = handleAbort;\n    if (createAbortListener) {\n      abortListener = createAbortListener(xhr);\n    }\n    if (payload) {\n      xhr.send(JSON.stringify(payload));\n    } else {\n      xhr.send();\n    }\n  }\n\n  if (timeout > 0) {\n    timeoutId = setTimeout(handleTimeout, timeout);\n  }\n\n  startRequest();\n\n  return {\n    abort: function() {\n      xhr.abort();\n      clearTimeout(timeoutId);\n      if (abortListener) {\n        abortListener();\n      }\n    }\n  };\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var abortListener;\n\n  function handleProgress(event) {\n    if (event.lengthComputable) {\n      onRequestProgress(event.loaded, event.total);\n      onResponseProgress(event.loaded, event.total);\n    }\n  }\n\n  function handleTimeout() {\n    xhr.abort();\n    onTimeoutError(xhrExtra);\n    resolve('timeout');\n  }\n\n  function handleStart() {\n    onBeforeRequest();\n    onRequestStart();\n    onResponseStart();\n    if (defaultTimeout) {\n      timeoutId = setTimeout(handleTimeout, defaultTimeout);\n    }\n  }\n\n  function handleEnd() {\n    clearTimeout(timeoutId);\n    if (xhr.status >= 200 && xhr.status < 300) {\n      onSuccess(parseResponse(xhr.responseText, xhr));\n    } else {\n      onError(parseErrorResponse(xhr.responseText, xhr));\n    }\n    onRequestEnd();\n    onResponseEnd();\n    resolve('resolved');\n  }\n\n  xhr.open(method, fullUrl, true);\n  xhr.onreadystatechange = handleEnd;\n  xhr.onprogress = handleProgress;\n  xhr.onload = handleEnd;\n  xhr.onerror = function() {\n    onError(parseErrorResponse(xhr.responseText, xhr));\n    handleEnd();\n  };\n\n  if (headers) {\n    for (var key in headers) {\n      xhr.setRequestHeader(key, headers[key]);\n    }\n  }\n\n  if (payload) {\n    xhr.send(payload);\n  } else {\n    xhr.send();\n  }\n\n  handleStart();\n\n  if (createAbortListener) {\n    abortListener = createAbortListener(xhr, function() {\n      clearTimeout(timeoutId);\n      xhr.abort();\n      onTimeoutError(xhrExtra);\n      resolve('aborted');\n    });\n  }\n}\n```",
      "```javascript\nfunction makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra, onRequestProgress, onRequestStart, onRequestEnd, onResponseStart, onResponseProgress, onResponseEnd, onTimeoutError, onSuccess, onError, onBeforeRequest, createAbortListener, parseResponse, parseErrorResponse, getResponseHeaders) {\n  var xhr = new XMLHttpRequest();\n  var timeoutId;\n  var abortListener;\n\n  function handleProgress(event) {\n    if (event.lengthComputable) {\n      onRequestProgress(event.loaded, event.total);\n      onResponseProgress(event.loaded, event.total);\n    }\n  }\n\n  function handleTimeout() {\n    xhr.abort();\n    onTimeoutError(xhrExtra);\n    resolve('timeout');\n  }\n\n  function handleStart() {\n    onBeforeRequest();\n    onRequestStart();\n    onResponseStart();\n    if (defaultTimeout) {\n      timeoutId = setTimeout(handleTimeout, defaultTimeout);\n    }\n  }\n\n  function handleEnd() {\n    clearTimeout(timeoutId);\n    if (xhr.status >= 200 && xhr.status < 300) {\n      onSuccess(xhr.response, xhr);\n      resolve('success');\n    } else {\n      onError(xhr.response, xhr);\n      resolve('error');\n    }\n    onRequestEnd();\n    onResponseEnd();\n  }\n\n  function handleResponse() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var parsedResponse = parseResponse(xhr.responseText, xhr);\n      onSuccess(parsedResponse, xhr);\n    } else {\n      var parsedErrorResponse = parseErrorResponse(xhr.responseText, xhr);\n      onError(parsedErrorResponse, xhr);\n    }\n    handleEnd();\n  }\n\n  function handleError() {\n    var parsedErrorResponse = parseErrorResponse(xhr.responseText, xhr);\n    onError(parsedErrorResponse, xhr);\n    handleEnd();\n  }\n\n  function handleAbort() {\n    clearTimeout(timeoutId);\n    onError('Request aborted', xhr);\n    handleEnd();\n  }\n\n  xhr.open(method, fullUrl, true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      handleResponse();\n    }\n  };\n  xhr.onerror = handleError;\n  xhr.onabort = handleAbort;\n  xhr.upload.onprogress = handleProgress;\n  xhr.onprogress = handleProgress;\n\n  if (headers) {\n    for (var header in headers) {\n      xhr.setRequestHeader(header, headers[header]);\n    }\n  }\n\n  if (payload) {\n    xhr.send(JSON.stringify(payload));\n  } else {\n    xhr.send();\n  }\n\n  handleStart();\n  abortListener = createAbortListener(function() {\n    xhr.abort();\n    handleAbort();\n  });\n}\n```"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a function that asynchronously retrieves JSON data from a specified URL using XMLHttpRequest and handles the response through a callback function.\n\nFunction Description: The function `getJSON` initiates an HTTP GET request to the provided URL, expecting a JSON response. It handles the response asynchronously, passing either the retrieved JSON data or an error status to the callback function. The function uses modern XMLHttpRequest features like responseType='json' for automatic JSON parsing.\n\nInput:\n- `url` [String] - The URL from which to fetch JSON data\n- `callback` [Function] - A function that handles the response, taking two parameters:\n  - First parameter: Error status (null if successful, HTTP status code if error)\n  - Second parameter: Response data (parsed JSON object if successful, raw response if error)\n\nOutput: None (results are handled asynchronously through the callback function)",
    "Canonical_solution": "function getJSON(url, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'json';\n    xhr.onload = function() {\n      var status = xhr.status;\n      if (status === 200) {\n        callback(null, xhr.response);\n      } else {\n        callback(status, xhr.response);\n      }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.responseText);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'json';\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      callback(null, xhr.response);\n    } else {\n      callback(xhr.status, xhr.response);\n    }\n  };\n  xhr.onerror = function() {\n    callback('Network error', null);\n  };\n  xhr.send();\n}",
      "function getJSON(url, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'json';\n    xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 300) {\n            callback(null, xhr.response);\n        } else {\n            callback(xhr.status, xhr.response);\n        }\n    };\n    xhr.onerror = function() {\n        callback('Network error', null);\n    };\n    xhr.send();\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a function that makes a cross-origin XMLHttpRequest (XHR) to a specified URL, sets custom headers, and handles the response or error appropriately.\n\nFunction Description: The function `makeXHRRequest` initiates an asynchronous GET request to a cross-origin URL, sets a custom header, and defines callbacks for handling successful responses and errors. The URL is processed by the `corsURL` helper function to ensure proper cross-origin request handling.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function handles the response or error internally via callbacks.)\n\n---\n\nTask Description: Create a helper function that constructs a cross-origin URL from a given path.\n\nFunction Description: The function `corsURL` takes a relative path and constructs a full URL by combining it with the current location's hostname, replacing the hostname with a remote hostname obtained from `get_host_info()`.\n\nInput: \n- `path` [String] - The relative path to the resource.\n\nOutput: \n- [String] - The fully constructed cross-origin URL.",
    "Canonical_solution": "function corsURL(path) {\n    const url = new URL(path, location.href);\n    url.hostname = get_host_info().REMOTE_HOST;\n    return url.href;\n}\n\nfunction makeXHRRequest() {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", corsURL(\"resources/access-control-preflight-request-allow-headers-returns-star.py\"));\n    xhr.setRequestHeader(\"X-Test\", \"foobar\");\n    xhr.onerror = t.unreached_func(\"Error occurred.\");\n    xhr.onload = t.step_func_done(() => {\n        assert_equals(xhr.status, 200);\n        assert_equals(xhr.responseText, \"PASS\");\n    });\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/cross-origin-path');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 300) {\n            handleResponse(xhr.responseText);\n        } else {\n            handleError(xhr.statusText);\n        }\n    };\n    xhr.onerror = function() {\n        handleError('Network error');\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    var currentLocation = window.location;\n    return currentLocation.protocol + '//' + hostInfo.remoteHostname + currentLocation.pathname + path;\n}\n\nfunction get_host_info() {\n    // This function should return an object with the remote hostname\n    // For the purpose of this example, it returns a dummy value\n    return { remoteHostname: 'remote.example.com' };\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/cross-origin-path');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                handleResponse(xhr.responseText);\n            } else {\n                handleError(xhr.statusText);\n            }\n        }\n    };\n    xhr.onerror = function() {\n        handleError('Network error');\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    var hostname = hostInfo.remoteHostname || window.location.hostname;\n    return 'https://' + hostname + path;\n}\n\nfunction get_host_info() {\n    // This function should return an object with the remote hostname\n    // For the purpose of this example, it returns a dummy object\n    return { remoteHostname: 'example.com' };\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/resource');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                handleResponse(xhr.responseText);\n            } else {\n                handleError(xhr.statusText);\n            }\n        }\n    };\n    xhr.onerror = function() {\n        handleError('Network error');\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    var currentLocation = window.location;\n    return 'https://' + hostInfo.remoteHostname + currentLocation.pathname + path;\n}\n\nfunction get_host_info() {\n    // This function should return an object with the remoteHostname property\n    // For the purpose of this example, it will return a dummy object\n    return { remoteHostname: 'example.com' };\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/resource');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 300) {\n            handleResponse(xhr.responseText);\n        } else {\n            handleError(xhr.statusText);\n        }\n    };\n    xhr.onerror = function() {\n        handleError(xhr.statusText);\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    return 'https://' + hostInfo.remoteHostname + path;\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n\nfunction get_host_info() {\n    // This function should return an object with the remote hostname\n    return { remoteHostname: 'example.com' };\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/cross-origin-path');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                handleResponse(xhr.responseText);\n            } else {\n                handleError(xhr.statusText);\n            }\n        }\n    };\n    xhr.onerror = function() {\n        handleError('Network error');\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    return 'https://' + hostInfo.remoteHostname + path;\n}\n\nfunction get_host_info() {\n    // This function should return an object with the remote hostname\n    // For the purpose of this example, it returns a dummy value\n    return { remoteHostname: 'example.com' };\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/resource');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                handleResponse(xhr.responseText);\n            } else {\n                handleError(xhr.statusText);\n            }\n        }\n    };\n    xhr.onerror = function() {\n        handleError('Network error');\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    var currentLocation = window.location;\n    return 'https://' + hostInfo.remoteHostname + currentLocation.pathname + path;\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n\nfunction get_host_info() {\n    return {\n        remoteHostname: 'example.com'\n    };\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/resource');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                handleResponse(xhr.responseText);\n            } else {\n                handleError(xhr.statusText);\n            }\n        }\n    };\n    xhr.onerror = function() {\n        handleError('Network error');\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    var hostname = hostInfo.remoteHostname || window.location.hostname;\n    return 'https://' + hostname + path;\n}\n\nfunction get_host_info() {\n    // This function should return an object with the remoteHostname property\n    // For the purpose of this example, it returns a dummy object\n    return { remoteHostname: 'example.com' };\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/resource');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                handleResponse(xhr.responseText);\n            } else {\n                handleError(xhr.statusText);\n            }\n        }\n    };\n    xhr.onerror = function() {\n        handleError('Network error');\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    var hostname = hostInfo.remoteHostname || window.location.hostname;\n    return 'https://' + hostname + path;\n}\n\nfunction get_host_info() {\n    // This function should return an object with the remoteHostname property\n    // For the purpose of this example, it returns a dummy object\n    return { remoteHostname: 'example.com' };\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n  var xhr = new XMLHttpRequest();\n  var corsURL = corsURLHelper('/cross-origin-path');\n  xhr.open('GET', corsURL, true);\n  xhr.setRequestHeader('Custom-Header', 'Value');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4) {\n      if (xhr.status === 200) {\n        handleResponse(xhr.responseText);\n      } else {\n        handleError(xhr.statusText);\n      }\n    }\n  };\n  xhr.onerror = function() {\n    handleError('Network error');\n  };\n  xhr.send();\n}\n\nfunction corsURLHelper(path) {\n  var hostInfo = get_host_info();\n  var hostname = hostInfo.remoteHostname || window.location.hostname;\n  return 'https://' + hostname + path;\n}\n\nfunction get_host_info() {\n  // This function should return the host information\n  // For the purpose of this example, it returns a dummy object\n  return { remoteHostname: 'example.com' };\n}\n\nfunction handleResponse(response) {\n  // Handle the response\n}\n\nfunction handleError(error) {\n  // Handle the error\n}\n```",
      "```javascript\nfunction makeXHRRequest() {\n    var xhr = new XMLHttpRequest();\n    var corsURL = corsURLHelper('/resource');\n    xhr.open('GET', corsURL, true);\n    xhr.setRequestHeader('Custom-Header', 'Value');\n    xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 300) {\n            handleResponse(xhr.responseText);\n        } else {\n            handleError(xhr.statusText);\n        }\n    };\n    xhr.onerror = function() {\n        handleError('Network error');\n    };\n    xhr.send();\n}\n\nfunction corsURLHelper(path) {\n    var hostInfo = get_host_info();\n    var remoteHostname = hostInfo.remoteHostname;\n    var currentHostname = window.location.hostname;\n    var protocol = window.location.protocol;\n    return protocol + '//' + remoteHostname + path.replace(/^\\//, '');\n}\n\nfunction handleResponse(response) {\n    console.log('Response:', response);\n}\n\nfunction handleError(error) {\n    console.error('Error:', error);\n}\n\nfunction get_host_info() {\n    return {\n        remoteHostname: 'https://remote.example.com'\n    };\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Create a function that asynchronously loads and decodes audio files for musical instruments using XMLHttpRequest and the Web Audio API, with caching support to avoid redundant requests.\n\nFunction Description: The function `getNote` retrieves an audio file for a specific musical note and instrument from a server, decodes it using the Web Audio API, and caches the result for future use. It returns a Promise that resolves with the decoded audio buffer or rejects with an error if loading or decoding fails.\n\nInput:\n- `url` [String] - Base URL for the audio files\n- `instrument` [String] - Name of the musical instrument\n- `name` [String] - Name of the musical note\n- `audioContext` [AudioContext] - Web Audio API context for decoding audio\n\nOutput:\n- [Promise] - Resolves with an object containing:\n  - `instrument` [String] - The instrument name\n  - `name` [String] - The note name\n  - `status` [String] - Loading status (\"loaded\")\n  - `audioBuffer` [AudioBuffer] - Decoded audio data\n- Rejects with an Error if loading or decoding fails",
    "Canonical_solution": "function getNote(url, instrument, name, audioContext) {\n\tif (!soundsCache[instrument]) soundsCache[instrument] = {};\n\tvar instrumentCache = soundsCache[instrument];\n\n\tif (!instrumentCache[name])\n\t\tinstrumentCache[name] = new Promise(function (resolve, reject) {\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\tlet noteUrl = url + instrument + \"-mp3/\" + name + \".mp3\";\n\t\t\txhr.open(\"GET\", noteUrl, true);\n\t\t\txhr.responseType = \"arraybuffer\";\n\t\t\txhr.onload = function () {\n\t\t\t\tif (xhr.status !== 200) {\n\t\t\t\t\treject(Error(\"Can't load sound at \" + noteUrl + ' status=' + xhr.status));\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tvar noteDecoded = function(audioBuffer) {\n\t\t\t\t\tresolve({instrument: instrument, name: name, status: \"loaded\", audioBuffer: audioBuffer})\n\t\t\t\t}\n\t\t\t\tvar maybePromise = audioContext.decodeAudioData(xhr.response, noteDecoded, function () {\n\t\t\t\t\treject(Error(\"Can't decode sound at \" + noteUrl));\n\t\t\t\t});\n\t\t\t\tif (maybePromise && typeof maybePromise.catch === \"function\") maybePromise.catch(reject);\n\t\t\t};\n\t\t\txhr.onerror = function () {\n\t\t\t\treject(Error(\"Can't load sound at \" + noteUrl));\n\t\t\t};\n\t\t\txhr.send();\n\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tconsole.error(\"Didn't load note\", instrument, name, \":\", err.message);\n\t\t\t\tthrow err;\n\t\t\t});\n\n\treturn instrumentCache[name];\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "function getNote(url, instrument, name, audioContext) {\n  const cacheKey = `${instrument}-${name}`;\n  return new Promise((resolve, reject) => {\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n    } else {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', `${url}/${instrument}/${name}.mp3`, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = () => {\n        if (xhr.status === 200) {\n          audioContext.decodeAudioData(xhr.response, (buffer) => {\n            audioContext.cache[cacheKey] = {\n              instrument,\n              name,\n              status: 'loaded',\n              audioBuffer: buffer\n            };\n            resolve(audioContext.cache[cacheKey]);\n          }, (error) => {\n            reject(new Error('Audio decoding failed'));\n          });\n        } else {\n          reject(new Error('Failed to load audio file'));\n        }\n      };\n      xhr.onerror = () => {\n        reject(new Error('Network error'));\n      };\n      xhr.send();\n    }\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n      return;\n    }\n\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `${url}/${instrument}/${name}.mp3`, true);\n    xhr.responseType = 'arraybuffer';\n\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        audioContext.decodeAudioData(xhr.response, (buffer) => {\n          audioContext.cache[cacheKey] = {\n            instrument,\n            name,\n            status: 'loaded',\n            audioBuffer: buffer\n          };\n          resolve(audioContext.cache[cacheKey]);\n        }, (error) => {\n          reject(new Error('Audio decoding failed'));\n        });\n      } else {\n        reject(new Error('Failed to load audio file'));\n      }\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.send();\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    const cachedBuffer = localStorage.getItem(cacheKey);\n    if (cachedBuffer) {\n      resolve(JSON.parse(cachedBuffer));\n    } else {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', `${url}/${instrument}/${name}.mp3`, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = () => {\n        if (xhr.status === 200) {\n          audioContext.decodeAudioData(xhr.response, (audioBuffer) => {\n            const result = {\n              instrument,\n              name,\n              status: 'loaded',\n              audioBuffer\n            };\n            localStorage.setItem(cacheKey, JSON.stringify(result));\n            resolve(result);\n          }, (error) => {\n            reject(new Error('Audio decoding failed'));\n          });\n        } else {\n          reject(new Error('Failed to load audio file'));\n        }\n      };\n      xhr.onerror = () => {\n        reject(new Error('Network error'));\n      };\n      xhr.send();\n    }\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n    } else {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', `${url}/${instrument}/${name}.mp3`, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = () => {\n        if (xhr.status === 200) {\n          audioContext.decodeAudioData(xhr.response, (buffer) => {\n            audioContext.cache[cacheKey] = {\n              instrument,\n              name,\n              status: 'loaded',\n              audioBuffer: buffer\n            };\n            resolve(audioContext.cache[cacheKey]);\n          }, (error) => {\n            reject(new Error('Audio decoding failed'));\n          });\n        } else {\n          reject(new Error('Audio file not found'));\n        }\n      };\n      xhr.onerror = () => {\n        reject(new Error('Network error'));\n      };\n      xhr.send();\n    }\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n    } else {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', `${url}${instrument}-${name}.mp3`, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = () => {\n        if (xhr.status === 200) {\n          audioContext.decodeAudioData(xhr.response, (buffer) => {\n            audioContext.cache[cacheKey] = {\n              instrument,\n              name,\n              status: 'loaded',\n              audioBuffer: buffer\n            };\n            resolve(audioContext.cache[cacheKey]);\n          }, (error) => {\n            reject(new Error('Audio decoding failed'));\n          });\n        } else {\n          reject(new Error('Failed to load audio file'));\n        }\n      };\n      xhr.onerror = () => {\n        reject(new Error('Network error'));\n      };\n      xhr.send();\n    }\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n      return;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `${url}/${instrument}/${name}.mp3`, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        audioContext.decodeAudioData(xhr.response, (buffer) => {\n          audioContext.cache[cacheKey] = {\n            instrument,\n            name,\n            status: 'loaded',\n            audioBuffer: buffer\n          };\n          resolve(audioContext.cache[cacheKey]);\n        }, (error) => {\n          reject(new Error('Audio decoding failed'));\n        });\n      } else {\n        reject(new Error('Audio file not found'));\n      }\n    };\n    xhr.onerror = () => {\n      reject(new Error('Audio file request failed'));\n    };\n    xhr.send();\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n    } else {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', `${url}/${instrument}/${name}.mp3`, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = () => {\n        if (xhr.status === 200) {\n          audioContext.decodeAudioData(xhr.response, (buffer) => {\n            audioContext.cache[cacheKey] = {\n              instrument,\n              name,\n              status: 'loaded',\n              audioBuffer: buffer\n            };\n            resolve(audioContext.cache[cacheKey]);\n          }, (error) => {\n            reject(new Error('Audio decoding failed'));\n          });\n        } else {\n          reject(new Error('Failed to load audio file'));\n        }\n      };\n      xhr.onerror = () => {\n        reject(new Error('Network error'));\n      };\n      xhr.send();\n    }\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n      return;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `${url}${instrument}-${name}.mp3`, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        audioContext.decodeAudioData(xhr.response, (buffer) => {\n          audioContext.cache[cacheKey] = {\n            instrument,\n            name,\n            status: 'loaded',\n            audioBuffer: buffer\n          };\n          resolve(audioContext.cache[cacheKey]);\n        }, (error) => {\n          reject(new Error('Audio decoding failed'));\n        });\n      } else {\n        reject(new Error('Failed to load audio file'));\n      }\n    };\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n    xhr.send();\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n      return;\n    }\n\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `${url}/${instrument}/${name}.mp3`, true);\n    xhr.responseType = 'arraybuffer';\n\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        audioContext.decodeAudioData(xhr.response, (buffer) => {\n          audioContext.cache[cacheKey] = {\n            instrument,\n            name,\n            status: 'loaded',\n            audioBuffer: buffer\n          };\n          resolve(audioContext.cache[cacheKey]);\n        }, (error) => {\n          reject(new Error('Audio decoding failed'));\n        });\n      } else {\n        reject(new Error('Failed to load audio file'));\n      }\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.send();\n  });\n}",
      "function getNote(url, instrument, name, audioContext) {\n  return new Promise((resolve, reject) => {\n    const cacheKey = `${instrument}-${name}`;\n    if (audioContext.cache[cacheKey]) {\n      resolve(audioContext.cache[cacheKey]);\n      return;\n    }\n\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `${url}/${instrument}/${name}.mp3`, true);\n    xhr.responseType = 'arraybuffer';\n\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        audioContext.decodeAudioData(xhr.response, (buffer) => {\n          audioContext.cache[cacheKey] = {\n            instrument,\n            name,\n            status: 'loaded',\n            audioBuffer: buffer\n          };\n          resolve(audioContext.cache[cacheKey]);\n        }, (error) => {\n          reject(new Error('Audio decoding failed'));\n        });\n      } else {\n        reject(new Error('Failed to load audio file'));\n      }\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Network error'));\n    };\n\n    xhr.send();\n  });\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Implement a request service class that handles HTTP requests including downloading files and performing various HTTP methods (GET, PUT, POST) with proper headers and data handling.\n\nClass Description: The BasicRequestService class implements IRequestService interface to provide HTTP request functionality. It uses XMLHttpRequest for file downloads and umi-request for standard HTTP methods. The class handles permissions checking before downloads and supports configurable request options.\n\nAttributes:\n- requestMethod: RequestMethod - An instance of umi-request's RequestMethod used for standard HTTP requests\n\nMethods:\n- download(url: string) -> Promise<Blob> - Downloads a file from the specified URL after checking permissions. Returns a Promise that resolves with the downloaded Blob.\n  - url: string - The URL of the file to download\n  - Returns: Promise<Blob> - A promise resolving to the downloaded file as a Blob\n\n- request(url: string, options: TRequestOption) -> Promise<any> - Performs an HTTP request based on the specified options (method, headers, data).\n  - url: string - The target URL for the request\n  - options: TRequestOption - Configuration object containing:\n    - method: string - HTTP method ('get', 'put', or 'post')\n    - headers: object - Optional request headers\n    - data: any - Optional request payload\n    - requestType: string - Optional request type for POST requests\n  - Returns: Promise<any> - A promise resolving to the response data\n  - Throws: Error - When an unsupported request method is specified",
    "Canonical_solution": "import { IPermissionsService } from './../../common/permissions';\nimport { extend, RequestMethod } from 'umi-request';\nimport { IRequestService, IBasicRequestService, TRequestOption } from '@/service/common/request';\nimport Container, { Service } from 'typedi';\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n  constructor() {\n    this.requestMethod = extend({});\n  }\n\n  async download(url: string) {\n    const permissionsService = Container.get(IPermissionsService);\n    await permissionsService.request({ origins: [`${new URL(url).origin}/*`] });\n    return new Promise<Blob>(resolve => {\n      let oReq = new XMLHttpRequest();\n      oReq.open('GET', url, true);\n      oReq.responseType = 'blob';\n      oReq.onload = function() {\n        let blob = oReq.response;\n        resolve(blob);\n      };\n      oReq.send();\n    });\n  }\n\n  request(url: string, options: TRequestOption) {\n    switch (options.method) {\n      case 'get': {\n        return this.requestMethod.get(url, {\n          headers: options.headers,\n        });\n      }\n      case 'put': {\n        return this.requestMethod.put(url, {\n          headers: options.headers,\n          data: options.data,\n        });\n      }\n      case 'post': {\n        return this.requestMethod.post(url, {\n          headers: options.headers,\n          data: options.data,\n          requestType: options.requestType,\n        });\n      }\n      default: {\n        throw new Error('Unsupported request method');\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "matched_results": [],
    "unmatched_results": [
      "```typescript\nimport { RequestMethod } from 'umi-request';\nimport { download } from 'umi-request';\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor() {\n    this.requestMethod = RequestMethod;\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Permission check logic would go here\n    return download(url);\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n    if (!['get', 'put', 'post'].includes(method)) {\n      throw new Error('Unsupported request method');\n    }\n    return this.requestMethod[method](url, { headers, data, requestType });\n  }\n}\n```",
      "```typescript\nimport { RequestMethod } from 'umi-request';\nimport { download } from 'umi-request';\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor() {\n    this.requestMethod = RequestMethod;\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Check permissions before download\n    if (await this.checkPermissions(url)) {\n      return download(url);\n    } else {\n      throw new Error('Download permission denied');\n    }\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n    if (method === 'get') {\n      return this.requestMethod.get(url, { headers });\n    } else if (method === 'put') {\n      return this.requestMethod.put(url, data, { headers });\n    } else if (method === 'post') {\n      return this.requestMethod.post(url, data, { headers, requestType });\n    } else {\n      throw new Error('Unsupported request method');\n    }\n  }\n\n  private async checkPermissions(url: string): Promise<boolean> {\n    // Implement permission checking logic here\n    // Return true if permissions are granted, false otherwise\n    return true;\n  }\n}\n```",
      "```typescript\nimport { RequestMethod } from 'umi-request';\nimport { download } from 'umi-request';\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor(requestMethod: RequestMethod) {\n    this.requestMethod = requestMethod;\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Check permissions before downloading\n    // Implementation for permission checking\n    // ...\n\n    return download(url);\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n\n    if (!['get', 'put', 'post'].includes(method)) {\n      throw new Error('Unsupported request method');\n    }\n\n    const requestConfig: any = {\n      method,\n      headers,\n      data,\n    };\n\n    if (method === 'post' && requestType) {\n      requestConfig.requestType = requestType;\n    }\n\n    return this.requestMethod.run(url, requestConfig);\n  }\n}\n\ninterface IRequestService {\n  download(url: string): Promise<Blob>;\n  request(url: string, options: TRequestOption): Promise<any>;\n}\n```",
      "```typescript\nimport { RequestMethod } from 'umi-request';\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor() {\n    this.requestMethod = RequestMethod.create();\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Check permissions before download\n    if (!await this.checkPermissions(url)) {\n      throw new Error('Download permission denied');\n    }\n    const response = await this.requestMethod.get(url, { responseType: 'blob' });\n    return response.data;\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n    if (!['get', 'put', 'post'].includes(method)) {\n      throw new Error('Unsupported request method');\n    }\n    const requestConfig: any = {\n      method,\n      headers,\n      data,\n    };\n    if (method === 'post' && requestType) {\n      requestConfig.requestType = requestType;\n    }\n    const response = await this.requestMethod.request(url, requestConfig);\n    return response.data;\n  }\n\n  private async checkPermissions(url: string): Promise<boolean> {\n    // Implement permission checking logic\n    return true; // Assuming permission is always granted for simplicity\n  }\n}\n```",
      "```typescript\ninterface IRequestService {\n  download(url: string): Promise<Blob>;\n  request(url: string, options: TRequestOption): Promise<any>;\n}\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor(requestMethod: RequestMethod) {\n    this.requestMethod = requestMethod;\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Check permissions before download\n    // Implementation for permission checking\n    const response = await this.requestMethod.get(url, { responseType: 'blob' });\n    return response.data;\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n    switch (method.toLowerCase()) {\n      case 'get':\n        return this.requestMethod.get(url, { headers });\n      case 'put':\n        return this.requestMethod.put(url, { headers, data });\n      case 'post':\n        return this.requestMethod.post(url, { headers, data, requestType });\n      default:\n        throw new Error('Unsupported request method');\n    }\n  }\n}\n```",
      "```typescript\nimport { RequestMethod } from 'umi-request';\nimport { download } from 'umi-request';\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor() {\n    this.requestMethod = RequestMethod.create();\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Permission check logic here\n    return download(url);\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n    if (!['get', 'put', 'post'].includes(method)) {\n      throw new Error('Unsupported request method');\n    }\n    return this.requestMethod.request(url, {\n      method,\n      headers,\n      data,\n      requestType,\n    });\n  }\n}\n```",
      "```typescript\nimport { RequestMethod } from 'umi-request';\nimport { download } from 'umi-request';\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor() {\n    this.requestMethod = RequestMethod;\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Check permissions before download\n    // Implementation for permission checking would go here\n    return download(url);\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n    if (!['get', 'put', 'post'].includes(method)) {\n      throw new Error('Unsupported request method');\n    }\n    // Implementation for permission checking would go here\n    return this.requestMethod[method](url, { headers, data, requestType });\n  }\n}\n```",
      "```typescript\nimport { RequestMethod } from 'umi-request';\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor() {\n    this.requestMethod = RequestMethod.create();\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Check permissions before download\n    // Implementation for permission checking\n    // ...\n\n    const response = await this.requestMethod.get(url, { responseType: 'blob' });\n    return response.data;\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n\n    if (!['get', 'put', 'post'].includes(method.toLowerCase())) {\n      throw new Error('Unsupported request method');\n    }\n\n    const requestConfig: any = {\n      method: method.toLowerCase(),\n      headers: headers,\n      data: data,\n    };\n\n    if (requestType) {\n      requestConfig.requestType = requestType;\n    }\n\n    const response = await this.requestMethod.request(url, requestConfig);\n    return response.data;\n  }\n}\n```",
      "```typescript\ninterface IRequestService {\n  download(url: string): Promise<Blob>;\n  request(url: string, options: TRequestOption): Promise<any>;\n}\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor(requestMethod: RequestMethod) {\n    this.requestMethod = requestMethod;\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Check permissions before download\n    // ...\n    const response = await this.requestMethod.get(url);\n    return response.blob();\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n    if (!['get', 'put', 'post'].includes(method)) {\n      throw new Error('Unsupported request method');\n    }\n    const requestConfig: any = {\n      method,\n      headers,\n      data\n    };\n    if (method === 'post' && requestType) {\n      requestConfig.requestType = requestType;\n    }\n    const response = await this.requestMethod.request(url, requestConfig);\n    return response;\n  }\n}\n```",
      "```typescript\ninterface IRequestService {\n  download(url: string): Promise<Blob>;\n  request(url: string, options: TRequestOption): Promise<any>;\n}\n\ninterface TRequestOption {\n  method: string;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n}\n\nclass RequestMethod {\n  static GET: string = 'get';\n  static PUT: string = 'put';\n  static POST: string = 'post';\n}\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n\n  constructor(requestMethod: RequestMethod) {\n    this.requestMethod = requestMethod;\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Check permissions before download\n    // Implementation for permission checking\n    const response = await fetch(url);\n    return response.blob();\n  }\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n    if (headers) {\n      Object.keys(headers).forEach(key => {\n        xhr.setRequestHeader(key, headers[key]);\n      });\n    }\n    if (method === RequestMethod.POST && data) {\n      xhr.send(JSON.stringify(data));\n    } else {\n      xhr.send();\n    }\n    return new Promise((resolve, reject) => {\n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(xhr.response);\n        } else {\n          reject(new Error('Request failed with status: ' + xhr.status));\n        }\n      };\n      xhr.onerror = () => {\n        reject(new Error('Request failed'));\n      };\n    });\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating read stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting resource size\n  }\n\n  type() {\n    // Implementation for getting content type\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating read stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting resource size\n  }\n\n  type() {\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating read stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting resource size\n  }\n\n  type() {\n    // Implementation for getting content type\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating a readable stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting the resource size\n  }\n\n  type() {\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating read stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting resource size\n  }\n\n  type() {\n    // Implementation for getting content type\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating a readable stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting the resource size\n  }\n\n  type() {\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating read stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting resource size\n  }\n\n  type() {\n    // Implementation for getting content type\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating read stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting resource size\n  }\n\n  type() {\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating read stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting resource size\n  }\n\n  type() {\n    return this._type;\n  }\n}\n```",
      "```javascript\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    // Implementation for fetching as a buffer\n  }\n\n  getDataUri(callback) {\n    // Implementation for converting to data URI\n  }\n\n  createReadStream() {\n    // Implementation for creating read stream\n    return null;\n  }\n\n  size(callback) {\n    // Implementation for getting resource size\n  }\n\n  type() {\n    return this._type;\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a function to handle form submission asynchronously using XMLHttpRequest in JavaScript. The function should prevent default form submission, process form data, send it to a server via POST request, and handle the server's response to display a thank-you message upon successful submission.\n\nFunction Description: The function `handleFormSubmit` intercepts form submission events, validates the form data (checking for honeypot fields), disables all buttons during submission, sends the form data to a specified URL via POST request, and processes the server's response to update the UI accordingly.\n\nInput: \n- `event`: [Event Object] - The form submission event that triggers this function. The event object contains the target form element and allows prevention of default submission behavior.\n\nOutput: \n- None (void) - The function does not return any value but performs side effects including:\n  - Preventing default form submission\n  - Disabling form buttons during submission\n  - Sending form data to the server\n  - Updating the UI based on server response (resetting form and showing thank-you message)",
    "Canonical_solution": "function handleFormSubmit(event) {\n    event.preventDefault();\n    var form = event.target;\n    var formData = getFormData(form);\n    var data = formData.data;\n\n    if (formData.honeypot) {\n        return false;\n    }\n\n    disableAllButtons(form);\n    var url = form.action;\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            form.reset();\n            var formElements = form.querySelector(\".form-elements\")\n            if (formElements) {\n                formElements.style.display = \"none\";\n            }\n            var thankYouMessage = form.querySelector(\".thankyou_message\");\n            if (thankYouMessage) {\n                thankYouMessage.style.display = \"block\";\n            }\n        }\n    };\n    var encoded = Object.keys(data).map(function(k) {\n        return encodeURIComponent(k) + \"=\" + encodeURIComponent(data[k]);\n    }).join('&');\n    xhr.send(encoded);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return; // Honeypot field detected, do not submit\n\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      buttons.forEach(button => button.disabled = false);\n      form.reset();\n      alert('Thank you for your submission!');\n    }\n  };\n  xhr.send(new FormData(form));\n}\n```",
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return;\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      form.reset();\n      document.getElementById('thank-you-message').textContent = 'Thank you for your submission!';\n    } else {\n      document.getElementById('error-message').textContent = 'An error occurred. Please try again.';\n    }\n    buttons.forEach(button => button.disabled = false);\n  };\n  xhr.onerror = function() {\n    document.getElementById('error-message').textContent = 'An error occurred. Please try again.';\n    buttons.forEach(button => button.disabled = false);\n  };\n  const formData = new FormData(form);\n  const data = {};\n  formData.forEach((value, key) => {\n    data[key] = value;\n  });\n  xhr.send(Object.keys(data).map(key => encodeURIComponent(key) + '=' + encodeURIComponent(data[key])).join('&'));\n}\n```",
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return; // Honeypot field found, do not submit the form\n\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      buttons.forEach(button => button.disabled = false);\n      form.reset();\n      alert('Thank you for your submission!');\n    }\n  };\n  xhr.send(new FormData(form));\n}\n```",
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return; // Honeypot field detected, do not submit\n\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      buttons.forEach(button => button.disabled = false);\n      form.reset();\n      alert('Thank you for your submission!');\n    }\n  };\n  xhr.send(new FormData(form));\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return; // Honeypot field found, do not submit the form\n  \n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n  \n  const formData = new FormData(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      form.reset();\n      buttons.forEach(button => button.disabled = false);\n      alert('Thank you for your submission!');\n    } else {\n      alert('An error occurred while submitting the form.');\n      buttons.forEach(button => button.disabled = false);\n    }\n  };\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return; // Honeypot field detected, do not submit the form\n\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n\n  const formData = new FormData(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      form.reset();\n      document.getElementById('thank-you-message').textContent = 'Thank you for your submission!';\n    } else {\n      document.getElementById('error-message').textContent = 'An error occurred. Please try again.';\n    }\n    buttons.forEach(button => button.disabled = false);\n  };\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return;\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n  const formData = new FormData(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      form.reset();\n      document.getElementById('thank-you-message').textContent = 'Thank you for your submission!';\n    } else {\n      document.getElementById('error-message').textContent = 'An error occurred. Please try again.';\n    }\n    buttons.forEach(button => button.disabled = false);\n  };\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return;\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n  const formData = new FormData(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      form.reset();\n      buttons.forEach(button => button.disabled = false);\n      alert('Thank you for your submission!');\n    } else {\n      buttons.forEach(button => button.disabled = false);\n      alert('An error occurred. Please try again.');\n    }\n  };\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return;\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n  const formData = new FormData(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      form.reset();\n      document.getElementById('thank-you-message').textContent = 'Thank you for your submission!';\n    } else {\n      document.getElementById('error-message').textContent = 'An error occurred. Please try again.';\n    }\n    buttons.forEach(button => button.disabled = false);\n  };\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypot = form.querySelector('input[name=\"honeypot\"]');\n  if (honeypot) return; // Honeypot field detected, do not submit\n\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n\n  const formData = new FormData(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      form.reset();\n      document.getElementById('thank-you-message').textContent = 'Thank you for your submission!';\n    } else {\n      document.getElementById('error-message').textContent = 'An error occurred. Please try again.';\n    }\n    buttons.forEach(button => button.disabled = false);\n  };\n  xhr.send(formData);\n}\n```"
    ],
    "match_count": 4,
    "pass@3": 0.8333333333333334,
    "pass@5": 0.9761904761904762
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport asyncio\nimport aiohttp\n\nasync def sendPostRequest():\n    url = 'http://example.com/api'\n    data = {'key1': 'value1', 'key2': 'value2'}\n    credentials = aiohttp.BasicAuth('username', 'password')\n    async with aiohttp.ClientSession(auth=credentials) as session:\n        async with session.post(url, data=data) as response:\n            print(await response.text())\n```",
      "```javascript\nconst https = require('https');\n\nasync function sendPostRequest(url, data) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }\n  };\n\n  if (credentials) {\n    options.headers['Authorization'] = `Bearer ${credentials}`;\n  }\n\n  const postData = Object.keys(data).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(data[key])}`).join('&');\n\n  const req = https.request(url, options, res => {\n    let data = '';\n    res.on('data', chunk => {\n      data += chunk;\n    });\n    res.on('end', () => {\n      console.log('Response:', data);\n    });\n  });\n\n  req.on('error', error => {\n    console.error('Error:', error);\n  });\n\n  req.write(postData);\n  req.end();\n}\n```",
      "```python\nimport asyncio\nimport aiohttp\n\nasync def sendPostRequest():\n    url = 'http://example.com/api'\n    data = {'key': 'value'}\n    credentials = aiohttp.BasicAuth('username', 'password')\n    async with aiohttp.ClientSession(auth=credentials) as session:\n        async with session.post(url, data=data) as response:\n            print(await response.text())\n```",
      "```javascript\nconst https = require('https');\n\nasync function sendPostRequest(url, data) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n  };\n\n  if (process.env.CREDENTIALS) {\n    options.headers['Authorization'] = `Bearer ${process.env.CREDENTIALS}`;\n  }\n\n  const postData = Object.keys(data).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(data[key])}`).join('&');\n\n  const req = https.request(url, options, res => {\n    let data = '';\n    res.on('data', chunk => {\n      data += chunk;\n    });\n    res.on('end', () => {\n      console.log('Response:', data);\n    });\n  });\n\n  req.on('error', error => {\n    console.error('Error:', error);\n  });\n\n  req.write(postData);\n  req.end();\n}\n```",
      "```javascript\nconst https = require('https');\n\nasync function sendPostRequest(url, data) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n  };\n\n  if (process.env.CREDENTIALS) {\n    options.auth = process.env.CREDENTIALS;\n  }\n\n  const postData = Object.keys(data).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(data[key])}`).join('&');\n\n  const req = https.request(url, options, res => {\n    let data = '';\n    res.on('data', chunk => {\n      data += chunk;\n    });\n    res.on('end', () => {\n      console.log('Response:', data);\n    });\n  });\n\n  req.on('error', error => {\n    console.error('Error:', error);\n  });\n\n  req.write(postData);\n  req.end();\n}\n```",
      "```javascript\nconst https = require('https');\n\nasync function sendPostRequest(url, data) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n  };\n\n  if (process.env.CREDENTIALS) {\n    options.headers['Authorization'] = `Bearer ${process.env.CREDENTIALS}`;\n  }\n\n  const postData = Object.keys(data).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(data[key])}`).join('&');\n\n  const req = https.request(url, options, res => {\n    let data = '';\n    res.on('data', chunk => {\n      data += chunk;\n    });\n    res.on('end', () => {\n      console.log('Response:', data);\n    });\n  });\n\n  req.on('error', error => {\n    console.error('Error:', error);\n  });\n\n  req.write(postData);\n  req.end();\n}\n```",
      "```python\nimport asyncio\nimport aiohttp\n\nasync def sendPostRequest():\n    url = 'http://example.com/api'\n    data = {'key1': 'value1', 'key2': 'value2'}\n    credentials = aiohttp.BasicAuth('username', 'password')\n    async with aiohttp.ClientSession(auth=credentials) as session:\n        async with session.post(url, data=data) as response:\n            print(await response.text())\n```",
      "```python\nimport asyncio\nimport aiohttp\n\nasync def sendPostRequest():\n    url = 'http://example.com/api'\n    data = {'key1': 'value1', 'key2': 'value2'}\n    credentials = aiohttp.BasicAuth('username', 'password')\n    async with aiohttp.ClientSession(auth=credentials) as session:\n        async with session.post(url, data=data) as response:\n            print(await response.text())\n```",
      "```python\nimport asyncio\nimport aiohttp\n\nasync def sendPostRequest():\n    url = 'http://example.com/api'\n    data = {'key1': 'value1', 'key2': 'value2'}\n    credentials = aiohttp.BasicAuth('username', 'password')\n    async with aiohttp.ClientSession(auth=credentials) as session:\n        async with session.post(url, data=data, headers={'Content-Type': 'application/x-www-form-urlencoded'}) as response:\n            print(await response.text())\n```",
      "```python\nimport asyncio\nimport aiohttp\n\nasync def sendPostRequest():\n    url = 'https://example.com/api/endpoint'\n    data = {'key1': 'value1', 'key2': 'value2'}\n    headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n    async with aiohttp.ClientSession() as session:\n        async with session.post(url, data=data, headers=headers) as response:\n            print(await response.text())\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a function that toggles the featured status of a project by sending an asynchronous HTTP POST request to a server and updates the UI accordingly.\n\nFunction Description: The function `setFeatured` sends a POST request to a server endpoint to toggle the featured status of a specified project. It handles the response asynchronously and updates the UI to reflect the new featured status. The function uses XMLHttpRequest for the HTTP communication and expects a JSON response from the server.\n\nInput: \n- `projectId` [String/Number] - The unique identifier of the project whose featured status is to be toggled.\n- `featured` [Boolean] - The current featured status of the project (true if featured, false otherwise).\n\nOutput: \n- None (void) - The function does not return a value but updates the UI element (div) to display a star (â˜…) if the project is featured or an empty star (â˜†) if it is not. The actual toggling is handled by the server response.",
    "Canonical_solution": "function setFeatured(projectId, featured) {\n    let session = getSessionInfo();\n    var xhr = new XMLHttpRequest()\n    xhr.open(\"POST\", 'featured/' + projectId, true);\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\n    xhr.onreadystatechange = function() {\n        if (this.readyState == 4 && this.status == 200) {\n            featured = JSON.parse(this.responseText);\n            div.innerHTML = featured? 'â˜…':'â˜†';\n        }\n    };\n\n    let request = {\n        userId: session.userId,\n        sessionId: session.sessionId,\n        featured: !featured\n    };\n    xhr.send(JSON.stringify(request));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/toggle-featured-status\", true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      var projectElement = document.getElementById(\"project-\" + projectId);\n      if (response.featured) {\n        projectElement.innerHTML = \"â˜…\";\n      } else {\n        projectElement.innerHTML = \"â˜†\";\n      }\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}\n```",
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/toggle-featured-status\", true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      var projectElement = document.getElementById(\"project-\" + projectId);\n      if (response.featured) {\n        projectElement.innerHTML = \"â˜…\";\n      } else {\n        projectElement.innerHTML = \"â˜†\";\n      }\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}\n```",
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', '/toggle-featured', true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      var projectElement = document.getElementById('project-' + projectId);\n      if (response.featured) {\n        projectElement.innerHTML = 'â˜…';\n      } else {\n        projectElement.innerHTML = 'â˜†';\n      }\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}\n```",
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/toggleFeatured\", true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      var projectElement = document.getElementById(projectId);\n      projectElement.textContent = response.featured ? 'â˜…' : 'â˜†';\n    }\n  };\n  xhr.send(JSON.stringify({projectId: projectId, featured: featured}));\n}\n```",
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/toggle-featured-status\", true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      var projectElement = document.getElementById(\"project-\" + projectId);\n      if (response.featured) {\n        projectElement.innerHTML = \"â˜…\";\n      } else {\n        projectElement.innerHTML = \"â˜†\";\n      }\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}\n```",
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/toggle-featured\", true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      var projectElement = document.getElementById(projectId);\n      if (response.featured) {\n        projectElement.innerHTML = 'â˜…';\n      } else {\n        projectElement.innerHTML = 'â˜†';\n      }\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}\n```",
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/toggle-featured-status\", true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      var projectElement = document.getElementById(projectId);\n      projectElement.textContent = response.featured ? 'â˜…' : 'â˜†';\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}\n```",
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', '/toggle-featured', true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      updateUI(response.featured);\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}\n\nfunction updateUI(featured) {\n  var projectElement = document.getElementById('project-' + projectId);\n  if (featured) {\n    projectElement.innerHTML = 'â˜…';\n  } else {\n    projectElement.innerHTML = 'â˜†';\n  }\n}\n```",
      "function setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/toggle-featured-status\", true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      if (response.featured) {\n        document.getElementById(\"project-\" + projectId).innerHTML = \"â˜…\";\n      } else {\n        document.getElementById(\"project-\" + projectId).innerHTML = \"â˜†\";\n      }\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}",
      "```javascript\nfunction setFeatured(projectId, featured) {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/toggle-featured\", true);\n  xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      var response = JSON.parse(xhr.responseText);\n      var projectElement = document.getElementById(projectId);\n      projectElement.textContent = response.featured ? 'â˜…' : 'â˜†';\n    }\n  };\n  xhr.send(JSON.stringify({ projectId: projectId, featured: featured }));\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a JavaScript class that handles AJAX requests using XMLHttpRequest, supporting cross-origin requests, custom headers, and various response handling scenarios.\n\nClass Description: The AjaxTransport class provides a wrapper around XMLHttpRequest for making asynchronous HTTP requests. It handles request creation, header management, response processing, and cleanup. The class supports CORS, maintains request state, and provides error handling capabilities.\n\nAttributes:\n\nxhrId: [Number] - Counter for generating unique IDs for each XMLHttpRequest instance\nxhrCallbacks: [Object] - Stores callback functions for active requests\nxhrSuccessStatus: [Object] - Maps certain HTTP status codes to standard success codes\nxhrSupported: [XMLHttpRequest|Boolean] - Stores the created XMLHttpRequest instance or false if not supported\n\nMethods:\n\ncreateXHR: () -> [XMLHttpRequest|undefined] - Creates and returns a new XMLHttpRequest instance or undefined if creation fails\n\nsendRequest: (options: Object, headers: Object, complete: Function) -> [undefined] - \n  Sends an AJAX request with the given configuration\n  options: Contains request parameters (type, url, async, etc.)\n  headers: Key-value pairs of request headers\n  complete: Callback function to handle response\n\nabortRequest: (callback: Function) -> [undefined] - \n  Aborts an active request and executes the given callback\n  callback: Function to execute after aborting\n\ngetTransport: (options: Object) -> [Object|undefined] - \n  Returns a transport object if the request can be handled\n  options: Configuration object for the request\n  Returns an object with send and abort methods or undefined if request can't be handled",
    "Canonical_solution": "var jQuery = require(\"../core\");\nvar support = require(\"../var/support\");\n\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      0: 200,\n      1223: 204\n    };\n    this.xhrSupported = this.createXHR();\n    \n    if (window.ActiveXObject) {\n      jQuery(window).on(\"unload\", () => {\n        for (var key in this.xhrCallbacks) {\n          this.xhrCallbacks[key]();\n        }\n      });\n    }\n    \n    support.cors = !!this.xhrSupported && (\"withCredentials\" in this.xhrSupported);\n    support.ajax = !!this.xhrSupported;\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch(e) {}\n  }\n\n  sendRequest(options, headers, complete) {\n    var xhr = options.xhr();\n    var id = ++this.xhrId;\n\n    xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n    if (options.xhrFields) {\n      for (var i in options.xhrFields) {\n        xhr[i] = options.xhrFields[i];\n      }\n    }\n\n    if (options.mimeType && xhr.overrideMimeType) {\n      xhr.overrideMimeType(options.mimeType);\n    }\n\n    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n      headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n    }\n\n    for (var i in headers) {\n      xhr.setRequestHeader(i, headers[i]);\n    }\n\n    var callback = (type) => {\n      return () => {\n        if (callback) {\n          delete this.xhrCallbacks[id];\n          callback = xhr.onload = xhr.onerror = null;\n\n          if (type === \"abort\") {\n            xhr.abort();\n          } else if (type === \"error\") {\n            complete(xhr.status, xhr.statusText);\n          } else {\n            complete(\n              this.xhrSuccessStatus[xhr.status] || xhr.status,\n              xhr.statusText,\n              typeof xhr.responseText === \"string\" ? { text: xhr.responseText } : undefined,\n              xhr.getAllResponseHeaders()\n            );\n          }\n        }\n      };\n    };\n\n    xhr.onload = callback();\n    xhr.onerror = callback(\"error\");\n    callback = this.xhrCallbacks[id] = callback(\"abort\");\n\n    try {\n      xhr.send(options.hasContent && options.data || null);\n    } catch (e) {\n      if (callback) {\n        throw e;\n      }\n    }\n  }\n\n  abortRequest(callback) {\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (support.cors || this.xhrSupported && !options.crossDomain) {\n      return {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: () => this.abortRequest(callback)\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      201: 200,\n      204: 200,\n      206: 200,\n      301: 200,\n      302: 200,\n      303: 200,\n      304: 200,\n      307: 200,\n      308: 200\n    };\n    this.xhrSupported = typeof XMLHttpRequest !== 'undefined' ? new XMLHttpRequest() : false;\n  }\n\n  createXHR() {\n    if (this.xhrSupported) {\n      return new XMLHttpRequest();\n    }\n    return undefined;\n  }\n\n  sendRequest(options, headers, complete) {\n    const xhr = this.createXHR();\n    if (!xhr) return;\n\n    xhr.open(options.type, options.url, options.async);\n    xhr.withCredentials = options.withCredentials || false;\n\n    for (const header in headers) {\n      xhr.setRequestHeader(header, headers[header]);\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n        complete(this.xhrSuccessStatus[xhr.status] || xhr.status, xhr.responseText);\n      } else {\n        complete(xhr.status, xhr.responseText);\n      }\n    };\n\n    xhr.onerror = () => complete(xhr.status, xhr.responseText);\n    xhr.ontimeout = () => complete(xhr.status, xhr.responseText);\n\n    xhr.send(options.data);\n  }\n\n  abortRequest(callback) {\n    const xhr = this.xhrCallbacks[this.xhrId];\n    if (xhr) {\n      xhr.abort();\n      delete this.xhrCallbacks[this.xhrId];\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (this.xhrSupported) {\n      const transport = {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: (callback) => this.abortRequest(callback)\n      };\n      this.xhrCallbacks[this.xhrId] = this.createXHR();\n      return transport;\n    }\n    return undefined;\n  }\n}\n```",
      "```javascript\nclass AjaxTransport {\n    constructor() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = { 200: 200, 201: 200, 202: 200, 204: 204 };\n        this.xhrSupported = XMLHttpRequest ? new XMLHttpRequest() : false;\n    }\n\n    createXHR() {\n        if (this.xhrSupported) {\n            return new XMLHttpRequest();\n        }\n        return undefined;\n    }\n\n    sendRequest(options, headers, complete) {\n        const xhr = this.createXHR();\n        if (!xhr) return;\n\n        xhr.open(options.type, options.url, options.async);\n        xhr.withCredentials = options.withCredentials || false;\n\n        for (const key in headers) {\n            xhr.setRequestHeader(key, headers[key]);\n        }\n\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300 || this.xhrSuccessStatus[xhr.status]) {\n                complete(null, xhr.responseText);\n            } else {\n                complete(new Error(`Request failed with status: ${xhr.status}`), xhr.responseText);\n            }\n        };\n\n        xhr.onerror = () => {\n            complete(new Error('Network error'), null);\n        };\n\n        xhr.ontimeout = () => {\n            complete(new Error('Request timed out'), null);\n        };\n\n        xhr.onabort = () => {\n            complete(new Error('Request aborted'), null);\n        };\n\n        xhr.send(options.data);\n    }\n\n    abortRequest(callback) {\n        const xhr = this.xhrCallbacks[this.xhrId];\n        if (xhr) {\n            xhr.abort();\n            delete this.xhrCallbacks[this.xhrId];\n            callback();\n        }\n    }\n\n    getTransport(options) {\n        if (this.xhrSupported) {\n            const transport = {\n                send: (headers, complete) => {\n                    this.sendRequest(options, headers, complete);\n                },\n                abort: (callback) => {\n                    this.abortRequest(callback);\n                }\n            };\n            this.xhrCallbacks[this.xhrId] = this.xhrSupported;\n            return transport;\n        }\n        return undefined;\n    }\n}\n```",
      "```javascript\nclass AjaxTransport {\n    constructor() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = { 200: 200, 201: 200, 202: 200, 204: 204 };\n        this.xhrSupported = XMLHttpRequest ? new XMLHttpRequest() : false;\n    }\n\n    createXHR() {\n        if (!this.xhrSupported) return undefined;\n        return new XMLHttpRequest();\n    }\n\n    sendRequest(options, headers, complete) {\n        const xhr = this.createXHR();\n        if (!xhr) return;\n\n        xhr.open(options.type, options.url, options.async);\n        xhr.withCredentials = options.withCredentials || false;\n\n        for (const [key, value] of Object.entries(headers)) {\n            xhr.setRequestHeader(key, value);\n        }\n\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300 || this.xhrSuccessStatus[xhr.status]) {\n                complete(null, xhr.responseText);\n            } else {\n                complete(new Error(`Request failed with status: ${xhr.status}`), xhr.responseText);\n            }\n        };\n\n        xhr.onerror = () => complete(new Error('Network error'), null);\n        xhr.ontimeout = () => complete(new Error('Request timed out'), null);\n\n        xhr.onabort = () => {\n            const callback = this.xhrCallbacks[xhr.xhrId];\n            if (callback) callback(new Error('Request aborted'), null);\n        };\n\n        xhr.xhrId = ++this.xhrId;\n        this.xhrCallbacks[xhr.xhrId] = complete;\n\n        xhr.send(options.data);\n    }\n\n    abortRequest(callback) {\n        const xhr = this.createXHR();\n        if (!xhr) return;\n\n        xhr.abort();\n        callback();\n    }\n\n    getTransport(options) {\n        if (!this.xhrSupported) return undefined;\n\n        return {\n            send: (headers, complete) => this.sendRequest(options, headers, complete),\n            abort: () => this.abortRequest(() => {})\n        };\n    }\n}\n```",
      "```javascript\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      '204': 204,\n      '205': 204,\n      '206': 206,\n      '207': 207,\n      '226': 226,\n      '300': 200,\n      '301': 200,\n      '302': 200,\n      '303': 200,\n      '304': 304,\n      '305': 200,\n      '307': 200,\n      '308': 200\n    };\n    this.xhrSupported = this.createXHR();\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  sendRequest(options, headers, complete) {\n    const xhr = this.xhrSupported;\n    if (!xhr) return;\n\n    const xhrId = ++this.xhrId;\n    this.xhrCallbacks[xhrId] = complete;\n\n    xhr.open(options.type, options.url, options.async);\n    xhr.withCredentials = options.withCredentials || false;\n\n    for (const key in headers) {\n      xhr.setRequestHeader(key, headers[key]);\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n        const response = xhr.responseText;\n        const status = this.xhrSuccessStatus[xhr.status] || xhr.status;\n        this.xhrCallbacks[xhrId](null, response, status, xhr);\n      } else {\n        this.xhrCallbacks[xhrId](new Error('Request failed with status: ' + xhr.status), null, xhr.status, xhr);\n      }\n    };\n\n    xhr.onerror = () => {\n      this.xhrCallbacks[xhrId](new Error('Network error'), null, xhr.status, xhr);\n    };\n\n    xhr.ontimeout = () => {\n      this.xhrCallbacks[xhrId](new Error('Request timed out'), null, xhr.status, xhr);\n    };\n\n    xhr.onabort = () => {\n      this.xhrCallbacks[xhrId](new Error('Request aborted'), null, xhr.status, xhr);\n    };\n\n    xhr.send(options.data);\n  }\n\n  abortRequest(callback) {\n    const xhr = this.xhrSupported;\n    if (!xhr) return;\n\n    xhr.abort();\n    callback();\n  }\n\n  getTransport(options) {\n    if (!this.xhrSupported) return undefined;\n\n    return {\n      send: (headers, complete) => this.sendRequest(options, headers, complete),\n      abort: () => this.abortRequest(() => {})\n    };\n  }\n}\n```",
      "```javascript\nclass AjaxTransport {\n    constructor() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = { 200: 200, 201: 200, 202: 200, 204: 204 };\n        this.xhrSupported = (function() {\n            try {\n                return new XMLHttpRequest();\n            } catch (e) {\n                return false;\n            }\n        })();\n    }\n\n    createXHR() {\n        if (!this.xhrSupported) return undefined;\n        return new XMLHttpRequest();\n    }\n\n    sendRequest(options, headers, complete) {\n        const xhr = this.createXHR();\n        if (!xhr) return;\n\n        xhr.open(options.type, options.url, options.async);\n        xhr.withCredentials = options.withCredentials || false;\n\n        for (const key in headers) {\n            xhr.setRequestHeader(key, headers[key]);\n        }\n\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300 || this.xhrSuccessStatus[xhr.status]) {\n                complete(null, xhr.responseText);\n            } else {\n                complete(new Error('Request failed with status: ' + xhr.status), xhr.responseText);\n            }\n        };\n\n        xhr.onerror = () => complete(new Error('Network error'), null);\n        xhr.ontimeout = () => complete(new Error('Request timed out'), null);\n\n        xhr.xhrId = this.xhrId++;\n        this.xhrCallbacks[xhr.xhrId] = complete;\n\n        xhr.send(options.data);\n    }\n\n    abortRequest(callback) {\n        const xhrId = Object.keys(this.xhrCallbacks).find(id => this.xhrCallbacks[id] === callback);\n        if (xhrId) {\n            const xhr = this.xhrCallbacks[xhrId].xhr;\n            if (xhr) {\n                xhr.abort();\n                delete this.xhrCallbacks[xhrId];\n            }\n            callback();\n        }\n    }\n\n    getTransport(options) {\n        if (!this.xhrSupported) return undefined;\n        return {\n            send: (headers, complete) => this.sendRequest(options, headers, complete),\n            abort: (callback) => this.abortRequest(callback)\n        };\n    }\n}\n```",
      "```javascript\nclass AjaxTransport {\n    constructor() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = { 200: 200, 201: 200, 202: 200, 204: 204 };\n        this.xhrSupported = XMLHttpRequest ? new XMLHttpRequest() : false;\n    }\n\n    createXHR() {\n        if (this.xhrSupported) {\n            return new XMLHttpRequest();\n        }\n        return undefined;\n    }\n\n    sendRequest(options, headers, complete) {\n        const xhr = this.createXHR();\n        if (!xhr) return;\n\n        xhr.open(options.type, options.url, options.async);\n        xhr.withCredentials = options.withCredentials || false;\n\n        for (const [key, value] of Object.entries(headers)) {\n            xhr.setRequestHeader(key, value);\n        }\n\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300 || this.xhrSuccessStatus[xhr.status]) {\n                complete(null, xhr.responseText);\n            } else {\n                complete(new Error(`Request failed with status: ${xhr.status}`), xhr.responseText);\n            }\n        };\n\n        xhr.onerror = () => complete(new Error('Network error'), null);\n        xhr.ontimeout = () => complete(new Error('Request timed out'), null);\n\n        xhr.onabort = () => {\n            const error = new Error('Request aborted');\n            complete(error, null);\n        };\n\n        xhr.send(options.data);\n    }\n\n    abortRequest(callback) {\n        const xhr = this.xhrCallbacks[this.xhrId];\n        if (xhr) {\n            xhr.abort();\n            delete this.xhrCallbacks[this.xhrId];\n            callback();\n        }\n    }\n\n    getTransport(options) {\n        if (this.xhrSupported) {\n            const transport = {\n                send: (headers, complete) => this.sendRequest(options, headers, complete),\n                abort: (callback) => this.abortRequest(callback)\n            };\n            this.xhrCallbacks[this.xhrId] = transport;\n            return transport;\n        }\n        return undefined;\n    }\n}\n```",
      "```javascript\nclass AjaxTransport {\n    constructor() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = { 200: 200, 201: 200, 202: 200, 204: 204 };\n        this.xhrSupported = false;\n    }\n\n    createXHR() {\n        try {\n            const xhr = new XMLHttpRequest();\n            this.xhrSupported = xhr;\n            return xhr;\n        } catch (e) {\n            return undefined;\n        }\n    }\n\n    sendRequest(options, headers, complete) {\n        if (!this.xhrSupported) return;\n\n        const xhr = this.createXHR();\n        if (!xhr) return;\n\n        xhr.open(options.type, options.url, options.async);\n        xhr.withCredentials = options.withCredentials || false;\n\n        for (const key in headers) {\n            xhr.setRequestHeader(key, headers[key]);\n        }\n\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300 || this.xhrSuccessStatus[xhr.status]) {\n                complete(xhr.response, xhr.status, xhr);\n            } else {\n                complete(null, xhr.status, xhr);\n            }\n        };\n\n        xhr.onerror = () => {\n            complete(null, xhr.status, xhr);\n        };\n\n        xhr.ontimeout = () => {\n            complete(null, xhr.status, xhr);\n        };\n\n        xhr.xhrId = this.xhrId++;\n        this.xhrCallbacks[xhr.xhrId] = complete;\n\n        xhr.send(options.data);\n    }\n\n    abortRequest(callback) {\n        if (!this.xhrSupported) return;\n\n        for (const xhrId in this.xhrCallbacks) {\n            const xhr = this.xhrCallbacks[xhrId];\n            if (xhr) {\n                xhr.abort();\n                delete this.xhrCallbacks[xhrId];\n                callback(xhr);\n            }\n        }\n    }\n\n    getTransport(options) {\n        if (!this.xhrSupported) return undefined;\n\n        return {\n            send: (headers, complete) => this.sendRequest(options, headers, complete),\n            abort: (callback) => this.abortRequest(callback)\n        };\n    }\n}\n```",
      "```javascript\nclass AjaxTransport {\n    constructor() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = { 200: 200, 201: 200, 202: 200, 204: 200 };\n        this.xhrSupported = XMLHttpRequest ? new XMLHttpRequest() : false;\n    }\n\n    createXHR() {\n        if (this.xhrSupported) {\n            return new XMLHttpRequest();\n        }\n        return undefined;\n    }\n\n    sendRequest(options, headers, complete) {\n        if (!this.xhrSupported) return;\n\n        const xhr = this.createXHR();\n        const xhrId = ++this.xhrId;\n        this.xhrCallbacks[xhrId] = complete;\n\n        xhr.open(options.type, options.url, options.async);\n        xhr.withCredentials = options.withCredentials || false;\n\n        for (const header in headers) {\n            xhr.setRequestHeader(header, headers[header]);\n        }\n\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300 || this.xhrSuccessStatus[xhr.status]) {\n                this.xhrCallbacks[xhrId](xhr.responseText, xhr.status, xhr);\n            } else {\n                this.xhrCallbacks[xhrId](null, xhr.status, xhr);\n            }\n        };\n\n        xhr.onerror = () => {\n            this.xhrCallbacks[xhrId](null, xhr.status, xhr);\n        };\n\n        xhr.ontimeout = () => {\n            this.xhrCallbacks[xhrId](null, xhr.status, xhr);\n        };\n\n        xhr.onabort = () => {\n            this.xhrCallbacks[xhrId](null, xhr.status, xhr);\n        };\n\n        xhr.send(options.data);\n    }\n\n    abortRequest(callback) {\n        if (!this.xhrSupported) return;\n\n        for (const xhrId in this.xhrCallbacks) {\n            const xhr = this.xhrCallbacks[xhrId].xhr;\n            if (xhr) {\n                xhr.abort();\n                callback();\n                delete this.xhrCallbacks[xhrId];\n            }\n        }\n    }\n\n    getTransport(options) {\n        if (!this.xhrSupported) return undefined;\n\n        return {\n            send: (headers, complete) => this.sendRequest(options, headers, complete),\n            abort: () => this.abortRequest(() => {})\n        };\n    }\n}\n```",
      "```javascript\nclass AjaxTransport {\n    constructor() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = { 200: 200, 201: 200, 202: 200, 204: 200 };\n        this.xhrSupported = XMLHttpRequest ? new XMLHttpRequest() : false;\n    }\n\n    createXHR() {\n        if (this.xhrSupported) {\n            return new XMLHttpRequest();\n        }\n        return undefined;\n    }\n\n    sendRequest(options, headers, complete) {\n        if (!this.xhrSupported) return;\n\n        const xhr = this.createXHR();\n        const xhrId = ++this.xhrId;\n        this.xhrCallbacks[xhrId] = complete;\n\n        xhr.open(options.type, options.url, options.async);\n        xhr.withCredentials = options.withCredentials || false;\n\n        for (const header in headers) {\n            xhr.setRequestHeader(header, headers[header]);\n        }\n\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300 || this.xhrSuccessStatus[xhr.status]) {\n                complete(xhr.responseText, xhr.status, xhr);\n            } else {\n                complete(null, xhr.status, xhr);\n            }\n        };\n\n        xhr.onerror = () => {\n            complete(null, xhr.status, xhr);\n        };\n\n        xhr.ontimeout = () => {\n            complete(null, xhr.status, xhr);\n        };\n\n        xhr.onabort = () => {\n            complete(null, xhr.status, xhr);\n        };\n\n        xhr.send(options.data);\n    }\n\n    abortRequest(callback) {\n        if (!this.xhrSupported) return;\n\n        for (const xhrId in this.xhrCallbacks) {\n            const xhr = this.xhrCallbacks[xhrId].xhr;\n            if (xhr) {\n                xhr.abort();\n                delete this.xhrCallbacks[xhrId];\n                callback(xhr);\n            }\n        }\n    }\n\n    getTransport(options) {\n        if (!this.xhrSupported) return undefined;\n\n        return {\n            send: (headers, complete) => this.sendRequest(options, headers, complete),\n            abort: (callback) => this.abortRequest(callback)\n        };\n    }\n}\n```",
      "```javascript\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = { 200: 200, 201: 200, 202: 200, 204: 204 };\n    this.xhrSupported = XMLHttpRequest ? new XMLHttpRequest() : false;\n  }\n\n  createXHR() {\n    if (this.xhrSupported) {\n      return new XMLHttpRequest();\n    }\n    return undefined;\n  }\n\n  sendRequest(options, headers, complete) {\n    const xhr = this.createXHR();\n    if (!xhr) return;\n\n    xhr.open(options.type, options.url, options.async);\n    xhr.withCredentials = options.withCredentials || false;\n\n    for (const header in headers) {\n      xhr.setRequestHeader(header, headers[header]);\n    }\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300 || this.xhrSuccessStatus[xhr.status]) {\n        complete(xhr.response, xhr.status, xhr);\n      } else {\n        complete(null, xhr.status, xhr);\n      }\n    };\n\n    xhr.onerror = () => {\n      complete(null, xhr.status, xhr);\n    };\n\n    xhr.ontimeout = () => {\n      complete(null, xhr.status, xhr);\n    };\n\n    xhr.xhrId = this.xhrId++;\n    this.xhrCallbacks[xhr.xhrId] = complete;\n    xhr.send(options.data);\n  }\n\n  abortRequest(callback) {\n    const xhrId = Object.keys(this.xhrCallbacks).find(id => this.xhrCallbacks[id] === callback);\n    if (xhrId) {\n      const xhr = this.xhrSupported;\n      if (xhr && xhr.xhrId === xhrId) {\n        xhr.abort();\n        callback();\n        delete this.xhrCallbacks[xhrId];\n      }\n    }\n  }\n\n  getTransport(options) {\n    if (this.xhrSupported) {\n      return {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: (callback) => this.abortRequest(callback)\n      };\n    }\n    return undefined;\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nfunction run_test(data, sender) {\n  if (data === 'xhr') {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://example.com/data', true);\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('Error: ' + xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      sender.postMessage('Error: ' + xhr.statusText);\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://example.com/data')\n      .then(function(response) {\n        if (!response.ok) {\n          throw new Error('Network response was not ok ' + response.statusText);\n        }\n        return response.text();\n      })\n      .then(function(text) {\n        sender.postMessage(text);\n      })\n      .catch(function(error) {\n        sender.postMessage('Error: ' + error.message);\n      });\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Script imported successfully');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n    if (data === 'xhr') {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://example.com/data');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                sender.postMessage(xhr.responseText);\n            } else {\n                sender.postMessage('Error: ' + xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            sender.postMessage('Error: ' + xhr.statusText);\n        };\n        xhr.send();\n    } else if (data === 'fetch') {\n        fetch('https://example.com/data')\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                return response.text();\n            })\n            .then(data => sender.postMessage(data))\n            .catch(error => sender.postMessage('Error: ' + error.message));\n    } else if (data === 'importScripts') {\n        importScripts('https://example.com/script.js');\n        sender.postMessage('Script imported successfully');\n    } else {\n        sender.postMessage('Unexpected message');\n    }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://example.com/data');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('Error: ' + xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      sender.postMessage('Error: ' + xhr.statusText);\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://example.com/data')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok');\n        }\n        return response.text();\n      })\n      .then(data => sender.postMessage(data))\n      .catch(error => sender.postMessage('Error: ' + error.message));\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Script imported successfully');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://example.com/data');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('Error: ' + xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      sender.postMessage('Error: ' + xhr.statusText);\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://example.com/data')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok');\n        }\n        return response.text();\n      })\n      .then(data => sender.postMessage(data))\n      .catch(error => sender.postMessage('Error: ' + error.message));\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Script imported successfully');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://example.com/data');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('Error: ' + xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      sender.postMessage('Error: ' + xhr.statusText);\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://example.com/data')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok ' + response.statusText);\n        }\n        return response.text();\n      })\n      .then(data => sender.postMessage(data))\n      .catch(error => sender.postMessage('Error: ' + error.message));\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Script imported successfully');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://example.com/data');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('Error: ' + xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      sender.postMessage('Error: ' + xhr.statusText);\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://example.com/data')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok ' + response.statusText);\n        }\n        return response.text();\n      })\n      .then(data => sender.postMessage(data))\n      .catch(error => sender.postMessage('Error: ' + error.message));\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Script imported successfully');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://example.com/data');\n    xhr.onload = function() {\n      if (xhr.status === 200) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('Error: ' + xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      sender.postMessage('Error: ' + xhr.statusText);\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://example.com/data')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok ' + response.statusText);\n        }\n        return response.text();\n      })\n      .then(data => sender.postMessage(data))\n      .catch(error => sender.postMessage('Error: ' + error.message));\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Script imported successfully');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n    if (data === 'xhr') {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://example.com/data');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                sender.postMessage(xhr.responseText);\n            } else {\n                sender.postMessage('Error: ' + xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            sender.postMessage('Error: ' + xhr.statusText);\n        };\n        xhr.send();\n    } else if (data === 'fetch') {\n        fetch('https://example.com/data')\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                return response.text();\n            })\n            .then(data => sender.postMessage(data))\n            .catch(error => sender.postMessage('Error: ' + error.message));\n    } else if (data === 'importScripts') {\n        importScripts('https://example.com/script.js');\n        sender.postMessage('Script imported successfully');\n    } else {\n        sender.postMessage('Unexpected message');\n    }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n    if (data === 'xhr') {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://example.com/data');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                sender.postMessage(xhr.responseText);\n            } else {\n                sender.postMessage('Error: ' + xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            sender.postMessage('Error: ' + xhr.statusText);\n        };\n        xhr.send();\n    } else if (data === 'fetch') {\n        fetch('https://example.com/data')\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error('Network response was not ok ' + response.statusText);\n                }\n                return response.text();\n            })\n            .then(data => sender.postMessage(data))\n            .catch(error => sender.postMessage('Error: ' + error.message));\n    } else if (data === 'importScripts') {\n        importScripts('https://example.com/script.js');\n        sender.postMessage('Script imported successfully');\n    } else {\n        sender.postMessage('Unexpected message');\n    }\n}\n```",
      "```javascript\nfunction run_test(data, sender) {\n    if (data === 'xhr') {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://example.com/data');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                sender.postMessage(xhr.responseText);\n            } else {\n                sender.postMessage('Error: ' + xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            sender.postMessage('Error: ' + xhr.statusText);\n        };\n        xhr.send();\n    } else if (data === 'fetch') {\n        fetch('https://example.com/data')\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error('Network response was not ok ' + response.statusText);\n                }\n                return response.text();\n            })\n            .then(data => sender.postMessage(data))\n            .catch(error => sender.postMessage('Error: ' + error.message));\n    } else if (data === 'importScripts') {\n        importScripts('https://example.com/script.js');\n        sender.postMessage('Script imported successfully');\n    } else {\n        sender.postMessage('Unexpected message');\n    }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a function that makes an HTTP GET request to a specified URL with custom headers and query parameters, then handles the response asynchronously.\n\nFunction Description: The function `makeHttpRequest` initiates an HTTP GET request to a given endpoint with query parameters and an API key in the header. It uses XMLHttpRequest to handle the request and response asynchronously. The response is logged to the console upon successful completion.\n\nInput: None (The URL, query parameters, and headers are hardcoded in this example, but could be parameterized in a more flexible implementation.)\n\nOutput: None (The function logs the response to the console but does not return any value.)",
    "Canonical_solution": "function makeHttpRequest() {\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('GET', 'http://localhost:28139/synthetics/api/v3/monitors?test=2&limit=100&w=4');\n    xhr.setRequestHeader('X-Api-Key', '123456789');\n\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nfunction makeHttpRequest() {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', 'https://api.example.com/data?param1=value1&param2=value2', true);\n  xhr.setRequestHeader('API-Key', 'your_api_key_here');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n  xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://api.example.com/data?param1=value1&param2=value2', true);\n    xhr.setRequestHeader('API-Key', 'your_api_key_here');\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n    xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", \"https://api.example.com/data?param1=value1&param2=value2\", true);\n    xhr.setRequestHeader(\"API-Key\", \"your_api_key_here\");\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n    xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', 'https://api.example.com/data?param1=value1&param2=value2', true);\n  xhr.setRequestHeader('API-Key', 'your_api_key_here');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n  xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", \"https://api.example.com/data?param1=value1&param2=value2\", true);\n  xhr.setRequestHeader(\"API-Key\", \"your_api_key_here\");\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n  xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", \"https://api.example.com/data?param1=value1&param2=value2\", true);\n  xhr.setRequestHeader(\"API-Key\", \"your_api_key_here\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n  xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', 'https://api.example.com/data?param1=value1&param2=value2', true);\n  xhr.setRequestHeader('API-Key', 'your_api_key_here');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n  xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n  var xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", \"https://api.example.com/data?param1=value1&param2=value2\", true);\n  xhr.setRequestHeader(\"API-Key\", \"your_api_key_here\");\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n  xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n  const xhr = new XMLHttpRequest();\n  const url = 'https://api.example.com/data';\n  const queryParams = '?param1=value1&param2=value2';\n  const apiKey = 'your_api_key';\n  const headers = {\n    'Authorization': `Bearer ${apiKey}`\n  };\n\n  xhr.open('GET', url + queryParams, true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  for (const key in headers) {\n    xhr.setRequestHeader(key, headers[key]);\n  }\n\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      console.log(xhr.responseText);\n    } else {\n      console.error('The request was successful, but the response status code is not in the 2xx range.');\n    }\n  };\n\n  xhr.onerror = function() {\n    console.error('The request failed.');\n  };\n\n  xhr.send();\n}\n```",
      "```javascript\nfunction makeHttpRequest() {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', 'https://api.example.com/data?param1=value1&param2=value2', true);\n  xhr.setRequestHeader('API-Key', 'your_api_key_here');\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n  xhr.send();\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Create a function that performs an HTTP request using XMLHttpRequest and returns a Promise that resolves with a response object containing various utility methods for processing the response data.\n\nFunction Description: The function `fetchRequest` is a Promise-based wrapper around XMLHttpRequest that simplifies making HTTP requests. It handles request configuration, headers, credentials, and response processing. The response object provides methods to access the response data in different formats (text, JSON, blob) and inspect response headers.\n\nInput: \n- `e` [String] - The URL to which the request is sent\n- `n` [Object] - (Optional) Configuration object for the request with the following possible properties:\n  - `method` [String] - HTTP method (default: \"get\")\n  - `headers` [Object] - Key-value pairs of request headers\n  - `credentials` [String] - Controls credentials inclusion (e.g., \"include\")\n  - `body` [Any] - Data to be sent with the request\n\nOutput: [Promise] - A Promise that resolves to a response object with the following methods:\n- `ok` [Boolean] - Indicates if the request was successful (status 2xx)\n- `statusText` [String] - HTTP status text\n- `status` [Number] - HTTP status code\n- `url` [String] - Final URL after any redirects\n- `text()` [Function] - Returns a Promise resolving to response text\n- `json()` [Function] - Returns a Promise resolving to parsed JSON\n- `blob()` [Function] - Returns a Promise resolving to a Blob object\n- `clone()` [Function] - Returns a copy of the response object\n- `headers` [Object] - Provides methods to inspect response headers:\n  - `keys()` - Returns array of header names\n  - `entries()` - Returns array of [name, value] pairs\n  - `get(name)` - Returns value for a specific header\n  - `has(name)` - Checks if a header exists",
    "Canonical_solution": "function fetchRequest(e, n) {\n    n = n || {};\n    return new Promise((function(t, r) {\n        var s = new XMLHttpRequest,\n            o = [],\n            u = [],\n            i = {},\n            a = function() {\n                return {\n                    ok: 2 == (s.status / 100 | 0),\n                    statusText: s.statusText,\n                    status: s.status,\n                    url: s.responseURL,\n                    text: function() {\n                        return Promise.resolve(s.responseText)\n                    },\n                    json: function() {\n                        return Promise.resolve(s.responseText).then(JSON.parse)\n                    },\n                    blob: function() {\n                        return Promise.resolve(new Blob([s.response]))\n                    },\n                    clone: a,\n                    headers: {\n                        keys: function() {\n                            return o\n                        },\n                        entries: function() {\n                            return u\n                        },\n                        get: function(e) {\n                            return i[e.toLowerCase()]\n                        },\n                        has: function(e) {\n                            return e.toLowerCase() in i\n                        }\n                    }\n                }\n            };\n        for (var l in s.open(n.method || \"get\", e, !0), s.onload = function() {\n                s.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, (function(e, n, t) {\n                    o.push(n = n.toLowerCase()), u.push([n, t]), i[n] = i[n] ? i[n] + \",\" + t : t\n                })), t(a())\n            }, s.onerror = r, s.withCredentials = \"include\" == n.credentials, n.headers) s.setRequestHeader(l, n.headers[l]);\n        s.send(n.body || null)\n    }))\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(n.method || 'get', e, true);\n    xhr.withCredentials = n.credentials === 'include';\n    if (n.headers) {\n      Object.keys(n.headers).forEach(key => {\n        xhr.setRequestHeader(key, n.headers[key]);\n      });\n    }\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve({\n          ok: true,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL,\n          text: () => Promise.resolve(xhr.responseText),\n          json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n          blob: () => Promise.resolve(xhr.response),\n          clone: () => ({\n            ok: this.ok,\n            statusText: this.statusText,\n            status: this.status,\n            url: this.url,\n            text: this.text,\n            json: this.json,\n            blob: this.blob,\n            clone: this.clone,\n            headers: {\n              keys: this.headers.keys,\n              entries: this.headers.entries,\n              get: this.headers.get,\n              has: this.headers.has\n            }\n          }),\n          headers: {\n            keys: () => Array.from(xhr.responseHeaders.split('\\n')).map(line => line.split(':')[0]),\n            entries: () => Array.from(xhr.responseHeaders.split('\\n')).map(line => {\n              const [key, value] = line.split(':');\n              return [key.trim(), value.trim()];\n            }),\n            get: (name) => xhr.getResponseHeader(name),\n            has: (name) => xhr.getResponseHeader(name) !== null\n          }\n        });\n      } else {\n        reject({\n          ok: false,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL\n        });\n      }\n    };\n    xhr.onerror = () => reject({\n      ok: false,\n      statusText: xhr.statusText,\n      status: xhr.status,\n      url: xhr.responseURL\n    });\n    xhr.send(n.body);\n  });\n}\n```",
      "```javascript\nfunction fetchRequest(e, n) {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open(n.method || 'get', e, true);\n        xhr.withCredentials = n.credentials === 'include';\n        if (n.headers) {\n            Object.keys(n.headers).forEach(key => {\n                xhr.setRequestHeader(key, n.headers[key]);\n            });\n        }\n        xhr.onload = () => {\n            const response = {\n                ok: xhr.status >= 200 && xhr.status < 300,\n                statusText: xhr.statusText,\n                status: xhr.status,\n                url: xhr.responseURL,\n                text: () => Promise.resolve(xhr.responseText),\n                json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n                blob: () => Promise.resolve(xhr.response),\n                clone: () => response,\n                headers: {\n                    keys: () => Object.keys(xhr.getAllResponseHeaders()),\n                    entries: () => Object.entries(xhr.getAllResponseHeaders()),\n                    get: name => xhr.getResponseHeader(name),\n                    has: name => xhr.getResponseHeader(name) !== null\n                }\n            };\n            resolve(response);\n        };\n        xhr.onerror = () => reject(xhr.statusText);\n        xhr.send(n.body);\n    });\n}\n```",
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const config = n || {};\n    xhr.open(config.method || 'get', e, true);\n    xhr.withCredentials = config.credentials === 'include';\n    if (config.headers) {\n      for (const key in config.headers) {\n        xhr.setRequestHeader(key, config.headers[key]);\n      }\n    }\n    xhr.onload = () => {\n      const response = {\n        ok: xhr.status >= 200 && xhr.status < 300,\n        statusText: xhr.statusText,\n        status: xhr.status,\n        url: xhr.responseURL,\n        text: () => Promise.resolve(xhr.responseText),\n        json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n        blob: () => Promise.resolve(xhr.response),\n        clone: () => response,\n        headers: {\n          keys: () => Object.keys(xhr.getAllResponseHeaders()),\n          entries: () => Object.entries(xhr.getAllResponseHeaders()),\n          get: (name) => xhr.getResponseHeader(name),\n          has: (name) => xhr.getResponseHeader(name) !== null\n        }\n      };\n      resolve(response);\n    };\n    xhr.onerror = () => reject(xhr.statusText);\n    xhr.send(config.body);\n  });\n}\n```",
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(n.method || 'get', e, true);\n    xhr.withCredentials = n.credentials === 'include';\n    if (n.headers) {\n      Object.keys(n.headers).forEach(key => {\n        xhr.setRequestHeader(key, n.headers[key]);\n      });\n    }\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve({\n          ok: true,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL,\n          text: () => Promise.resolve(xhr.responseText),\n          json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n          blob: () => Promise.resolve(xhr.response),\n          clone: () => ({\n            ok: true,\n            statusText: xhr.statusText,\n            status: xhr.status,\n            url: xhr.responseURL,\n            text: () => Promise.resolve(xhr.responseText),\n            json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n            blob: () => Promise.resolve(xhr.response),\n            headers: {\n              keys: () => Object.keys(xhr.getAllResponseHeaders()),\n              entries: () => Object.entries(xhr.getAllResponseHeaders()),\n              get: name => xhr.getResponseHeader(name),\n              has: name => xhr.getResponseHeader(name) !== null\n            }\n          }),\n          headers: {\n            keys: () => Object.keys(xhr.getAllResponseHeaders()),\n            entries: () => Object.entries(xhr.getAllResponseHeaders()),\n            get: name => xhr.getResponseHeader(name),\n            has: name => xhr.getResponseHeader(name) !== null\n          }\n        });\n      } else {\n        reject({\n          ok: false,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL\n        });\n      }\n    };\n    xhr.onerror = () => reject({\n      ok: false,\n      statusText: xhr.statusText,\n      status: xhr.status,\n      url: xhr.responseURL\n    });\n    xhr.send(n.body);\n  });\n}\n```",
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(n.method || 'get', e, true);\n    xhr.withCredentials = n.credentials === 'include';\n    if (n.headers) {\n      Object.keys(n.headers).forEach(key => {\n        xhr.setRequestHeader(key, n.headers[key]);\n      });\n    }\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve({\n          ok: true,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL,\n          text: () => Promise.resolve(xhr.responseText),\n          json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n          blob: () => Promise.resolve(xhr.response),\n          clone: () => {\n            const clonedResponse = {\n              ok: this.ok,\n              statusText: this.statusText,\n              status: this.status,\n              url: this.url,\n              text: this.text,\n              json: this.json,\n              blob: this.blob,\n              clone: this.clone,\n              headers: {\n                keys: this.headers.keys,\n                entries: this.headers.entries,\n                get: this.headers.get,\n                has: this.headers.has\n              }\n            };\n            return Promise.resolve(clonedResponse);\n          },\n          headers: {\n            keys: () => Array.from(xhr.responseHeaders.split('\\n')).map(line => line.split(':')[0].trim()),\n            entries: () => Array.from(xhr.responseHeaders.split('\\n')).map(line => {\n              const [key, value] = line.split(':');\n              return [key.trim(), value.trim()];\n            }),\n            get: name => {\n              const headerLine = xhr.responseHeaders.split('\\n').find(line => line.startsWith(name.toUpperCase() + ':'));\n              return headerLine ? headerLine.split(':')[1].trim() : null;\n            },\n            has: name => xhr.responseHeaders.split('\\n').some(line => line.startsWith(name.toUpperCase() + ':'))\n          }\n        });\n      } else {\n        reject({\n          ok: false,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL\n        });\n      }\n    };\n    xhr.onerror = () => reject({\n      ok: false,\n      statusText: xhr.statusText,\n      status: xhr.status,\n      url: xhr.responseURL\n    });\n    xhr.send(n.body);\n  });\n}\n```",
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(n.method || 'get', e, true);\n    xhr.withCredentials = n.credentials === 'include';\n    if (n.headers) {\n      Object.keys(n.headers).forEach(key => {\n        xhr.setRequestHeader(key, n.headers[key]);\n      });\n    }\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve({\n          ok: true,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL,\n          text: () => Promise.resolve(xhr.responseText),\n          json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n          blob: () => Promise.resolve(xhr.response),\n          clone: () => ({\n            ok: this.ok,\n            statusText: this.statusText,\n            status: this.status,\n            url: this.url,\n            text: this.text,\n            json: this.json,\n            blob: this.blob,\n            clone: this.clone,\n            headers: {\n              keys: this.headers.keys,\n              entries: this.headers.entries,\n              get: this.headers.get,\n              has: this.headers.has\n            }\n          }),\n          headers: {\n            keys: () => Array.from(xhr.responseHeaders.split('\\n')).map(line => line.split(':')[0].trim()),\n            entries: () => Array.from(xhr.responseHeaders.split('\\n')).map(line => {\n              const [key, value] = line.split(':');\n              return [key.trim(), value.trim()];\n            }),\n            get: (name) => {\n              const headerLine = xhr.responseHeaders.split('\\n').find(line => line.startsWith(name.toUpperCase() + ':'));\n              return headerLine ? headerLine.split(':')[1].trim() : null;\n            },\n            has: (name) => xhr.responseHeaders.split('\\n').some(line => line.startsWith(name.toUpperCase() + ':'))\n          }\n        });\n      } else {\n        reject({\n          ok: false,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL\n        });\n      }\n    };\n    xhr.onerror = () => reject({\n      ok: false,\n      statusText: xhr.statusText,\n      status: xhr.status,\n      url: xhr.responseURL\n    });\n    xhr.send(n.body);\n  });\n}\n```",
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(n.method || 'get', e, true);\n    xhr.withCredentials = n.credentials === 'include';\n    if (n.headers) {\n      Object.keys(n.headers).forEach(key => {\n        xhr.setRequestHeader(key, n.headers[key]);\n      });\n    }\n    xhr.onload = () => {\n      const response = {\n        ok: xhr.status >= 200 && xhr.status < 300,\n        statusText: xhr.statusText,\n        status: xhr.status,\n        url: xhr.responseURL,\n        text: () => Promise.resolve(xhr.responseText),\n        json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n        blob: () => Promise.resolve(xhr.response),\n        clone: () => {\n          const clonedResponse = {\n            ok: this.ok,\n            statusText: this.statusText,\n            status: this.status,\n            url: this.url,\n            text: this.text,\n            json: this.json,\n            blob: this.blob,\n            clone: this.clone,\n            headers: {\n              keys: () => this.headers.keys(),\n              entries: () => this.headers.entries(),\n              get: (name) => this.headers.get(name),\n              has: (name) => this.headers.has(name)\n            }\n          };\n          return Promise.resolve(clonedResponse);\n        },\n        headers: {\n          keys: () => Array.from(xhr.responseHeaders.split('\\n')).map(line => line.split(':')[0].trim()),\n          entries: () => Array.from(xhr.responseHeaders.split('\\n')).map(line => {\n            const [key, value] = line.split(':').map(s => s.trim());\n            return [key, value];\n          }),\n          get: (name) => {\n            const headerLine = xhr.responseHeaders.split('\\n').find(line => line.startsWith(name.toUpperCase() + ':'));\n            return headerLine ? headerLine.split(':')[1].trim() : null;\n          },\n          has: (name) => xhr.responseHeaders.split('\\n').some(line => line.startsWith(name.toUpperCase() + ':'))\n        }\n      };\n      resolve(response);\n    };\n    xhr.onerror = () => reject(xhr.statusText);\n    xhr.send(n.body);\n  });\n}\n```",
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(n.method || 'get', e, true);\n    xhr.withCredentials = n.credentials === 'include';\n    if (n.headers) {\n      Object.keys(n.headers).forEach(key => {\n        xhr.setRequestHeader(key, n.headers[key]);\n      });\n    }\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve({\n          ok: true,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL,\n          text: () => Promise.resolve(xhr.responseText),\n          json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n          blob: () => Promise.resolve(xhr.response),\n          clone: () => ({\n            ok: true,\n            statusText: xhr.statusText,\n            status: xhr.status,\n            url: xhr.responseURL,\n            text: () => Promise.resolve(xhr.responseText),\n            json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n            blob: () => Promise.resolve(xhr.response),\n            headers: {\n              keys: () => Object.keys(xhr.getAllResponseHeaders()),\n              entries: () => Object.entries(xhr.getAllResponseHeaders()),\n              get: name => xhr.getResponseHeader(name),\n              has: name => xhr.getResponseHeader(name) !== null\n            }\n          }),\n          headers: {\n            keys: () => Object.keys(xhr.getAllResponseHeaders()),\n            entries: () => Object.entries(xhr.getAllResponseHeaders()),\n            get: name => xhr.getResponseHeader(name),\n            has: name => xhr.getResponseHeader(name) !== null\n          }\n        });\n      } else {\n        reject({\n          ok: false,\n          statusText: xhr.statusText,\n          status: xhr.status,\n          url: xhr.responseURL\n        });\n      }\n    };\n    xhr.onerror = () => reject({\n      ok: false,\n      statusText: xhr.statusText,\n      status: xhr.status,\n      url: xhr.responseURL\n    });\n    xhr.send(n.body);\n  });\n}\n```",
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(n.method || 'get', e, true);\n    xhr.withCredentials = n.credentials === 'include';\n    if (n.headers) {\n      Object.keys(n.headers).forEach(key => {\n        xhr.setRequestHeader(key, n.headers[key]);\n      });\n    }\n    xhr.onload = () => {\n      const response = {\n        ok: xhr.status >= 200 && xhr.status < 300,\n        statusText: xhr.statusText,\n        status: xhr.status,\n        url: xhr.responseURL,\n        text: () => Promise.resolve(xhr.responseText),\n        json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n        blob: () => Promise.resolve(xhr.response),\n        clone: () => response,\n        headers: {\n          keys: () => Object.keys(xhr.getAllResponseHeaders()),\n          entries: () => Object.entries(xhr.getAllResponseHeaders()),\n          get: name => xhr.getResponseHeader(name),\n          has: name => xhr.getResponseHeader(name) !== null\n        }\n      };\n      resolve(response);\n    };\n    xhr.onerror = () => reject(xhr.statusText);\n    xhr.send(n.body);\n  });\n}\n```"
    ],
    "unmatched_results": [
      "```javascript\nfunction fetchRequest(e, n) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const config = n || {};\n    xhr.open(config.method || 'get', e, true);\n    if (config.headers) {\n      Object.keys(config.headers).forEach(key => {\n        xhr.setRequestHeader(key, config.headers[key]);\n      });\n    }\n    if (config.credentials) {\n      xhr.withCredentials = config.credentials === 'include';\n    }\n    if (config.body) {\n      xhr.send(config.body);\n    } else {\n      xhr.send();\n    }\n    xhr.onload = () => {\n      const response = {\n        ok: xhr.status >= 200 && xhr.status < 300,\n        statusText: xhr.statusText,\n        status: xhr.status,\n        url: xhr.responseURL,\n        text: () => Promise.resolve(xhr.responseText),\n        json: () => Promise.resolve(JSON.parse(xhr.responseText)),\n        blob: () => Promise.resolve(xhr.response),\n        clone: () => Promise.resolve(response),\n        headers: {\n          keys: () => Object.keys(xhr.getAllResponseHeaders()),\n          entries: () => Object.entries(xhr.getAllResponseHeaders()),\n          get: name => xhr.getResponseHeader(name),\n          has: name => xhr.getResponseHeader(name) !== null\n        }\n      };\n      resolve(response);\n    };\n    xhr.onerror = () => reject(xhr.statusText);\n  });\n}\n```"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with form data and custom headers, then handles the response asynchronously.\n\nFunction Description: The function `sendRequest` constructs and sends an HTTP POST request using XMLHttpRequest. It packages form data as URL-encoded parameters, sets various request headers for authentication and content negotiation, and processes the server's response asynchronously. The function is designed to interact with a real estate listing API, sending search criteria and receiving property listings in return.\n\nInput: None (The function uses hardcoded values for demonstration, but in practice these could be parameterized)\n\nOutput: None (The function logs the response to console, but could be modified to return a Promise or use callbacks for response handling)",
    "Canonical_solution": "function sendRequest() {\n    const data = new URLSearchParams({\n        'CultureId': '1',\n        'ApplicationId': '1',\n        'RecordsPerPage': '200',\n        'MaximumResults': '200',\n        'PropertyTypeId': '300',\n        'TransactionTypeId': '2',\n        'StoreyRange': '0-0',\n        'BuildingTypeId': '1',\n        'BedRange': '0-0',\n        'BathRange': '0-0',\n        'LongitudeMin': '-79.3676805496215',\n        'LongitudeMax': '-79.27300930023185',\n        'LatitudeMin': '43.660358732823845',\n        'LatitudeMax': '43.692390574029936',\n        'SortOrder': 'A',\n        'SortBy': '1',\n        'viewState': 'm',\n        'Longitude': '-79.4107246398925',\n        'Latitude': '43.6552047278685',\n        'ZoomLevel': '13',\n        'CurrentPage': '1'\n    });\n\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/api/Listing.svc/PropertySearch_Post');\n    xhr.setRequestHeader('Origin', 'http://www.realtor.ca');\n    xhr.setRequestHeader('Accept-Encoding', 'gzip, deflate');\n    xhr.setRequestHeader('Accept-Language', 'en-US,en;q=0.8');\n    xhr.setRequestHeader('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n    xhr.setRequestHeader('Accept', '*/*');\n    xhr.setRequestHeader('Referer', 'http://www.realtor.ca/Residential/Map.aspx');\n    xhr.setRequestHeader('Connection', 'keep-alive');\n\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "```javascript\nfunction sendRequest() {\n    var xhr = new XMLHttpRequest();\n    var url = 'https://api.realestate.com/search';\n    var formData = 'criteria=location&price=500000';\n    var headers = {\n        'Authorization': 'Bearer your_access_token',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Accept': 'application/json'\n    };\n\n    xhr.open('POST', url, true);\n    for (var key in headers) {\n        xhr.setRequestHeader(key, headers[key]);\n    }\n\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n\n    xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n  var xhr = new XMLHttpRequest();\n  var url = 'https://api.realestate.com/search';\n  var formData = 'criteria=location&price=500000';\n  var headers = {\n    'Authorization': 'Bearer your_access_token',\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Accept': 'application/json'\n  };\n\n  xhr.open('POST', url, true);\n  for (var key in headers) {\n    xhr.setRequestHeader(key, headers[key]);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n    var xhr = new XMLHttpRequest();\n    var url = 'https://api.realestate.com/search';\n    var formData = 'criteria=location&price=500000';\n    var headers = {\n        'Authorization': 'Bearer your_access_token',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Accept': 'application/json'\n    };\n\n    xhr.open('POST', url, true);\n    for (var key in headers) {\n        xhr.setRequestHeader(key, headers[key]);\n    }\n\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n\n    xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n    var xhr = new XMLHttpRequest();\n    var url = 'https://api.realestate.com/search';\n    var formData = 'criteria=location&price=500000';\n    var headers = {\n        'Authorization': 'Bearer your_access_token',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Accept': 'application/json'\n    };\n\n    xhr.open('POST', url, true);\n    for (var key in headers) {\n        xhr.setRequestHeader(key, headers[key]);\n    }\n\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n\n    xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n  var xhr = new XMLHttpRequest();\n  var url = 'https://api.realestate.com/search';\n  var formData = 'criteria=location&price=500000';\n  var headers = {\n    'Authorization': 'Bearer your_access_token',\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Accept': 'application/json'\n  };\n\n  xhr.open('POST', url, true);\n  for (var key in headers) {\n    xhr.setRequestHeader(key, headers[key]);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n  var xhr = new XMLHttpRequest();\n  var url = 'https://api.realestate.com/search';\n  var formData = 'criteria=location&price=500000';\n  var headers = {\n    'Authorization': 'Bearer your_access_token',\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Accept': 'application/json'\n  };\n\n  xhr.open('POST', url, true);\n  for (var key in headers) {\n    xhr.setRequestHeader(key, headers[key]);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n  var xhr = new XMLHttpRequest();\n  var url = 'https://api.realestate.com/search';\n  var formData = 'criteria=location&price=500000';\n  var headers = {\n    'Authorization': 'Bearer your_access_token',\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Accept': 'application/json'\n  };\n\n  xhr.open('POST', url, true);\n  for (var key in headers) {\n    xhr.setRequestHeader(key, headers[key]);\n  }\n\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log(xhr.responseText);\n    }\n  };\n\n  xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n    var xhr = new XMLHttpRequest();\n    var url = 'https://api.realestate.com/search';\n    var formData = 'criteria=location&price=500000';\n    var headers = {\n        'Authorization': 'Bearer your_access_token',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Accept': 'application/json'\n    };\n\n    xhr.open('POST', url, true);\n    for (var key in headers) {\n        xhr.setRequestHeader(key, headers[key]);\n    }\n\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n\n    xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n    var xhr = new XMLHttpRequest();\n    var url = 'https://api.realestate.com/search';\n    var formData = 'criteria=location&price=500000';\n    var headers = {\n        'Authorization': 'Bearer your_access_token',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Accept': 'application/json'\n    };\n\n    xhr.open('POST', url, true);\n    for (var key in headers) {\n        xhr.setRequestHeader(key, headers[key]);\n    }\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n    xhr.send(formData);\n}\n```",
      "```javascript\nfunction sendRequest() {\n    var xhr = new XMLHttpRequest();\n    var url = 'https://api.realestate.com/search';\n    var formData = 'criteria=location&price=500000';\n    var headers = {\n        'Authorization': 'Bearer your_access_token',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Accept': 'application/json'\n    };\n\n    xhr.open('POST', url, true);\n    for (var key in headers) {\n        xhr.setRequestHeader(key, headers[key]);\n    }\n\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n\n    xhr.send(formData);\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a function that performs an asynchronous HTTP GET request to a specified URL and returns a Promise that resolves when the request is successful or rejects when it fails.\n\nFunction Description: The function `getData` initiates an HTTP GET request using XMLHttpRequest. It sets appropriate headers for JSON content, handles the response asynchronously through Promise callbacks, and manages both successful and failed request scenarios.\n\nInput: \n- url [String] - The URL to which the HTTP GET request will be made\n\nOutput: \n- [Promise] - A Promise object that resolves when the request succeeds and rejects when it fails. The Promise doesn't return any specific value upon resolution/rejection in this basic implementation, but can be extended to return response data or error information.",
    "Canonical_solution": "function getData(url) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Content-Type', 'application/json');\n    req.setRequestHeader('Accept', 'application/json');\n    req.onload = () => {\n      resolve();\n    };\n    req.onerror = () => {\n      reject();\n    };\n    req.send();\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [
      "function getData(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getData(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getData(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = function() {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = function() {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getData(url) {\n    return new Promise((resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr.responseText);\n            } else {\n                reject(xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            reject(xhr.statusText);\n        };\n        xhr.send();\n    });\n}",
      "function getData(url) {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = function() {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr.responseText);\n            } else {\n                reject(xhr.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            reject(xhr.statusText);\n        };\n        xhr.send();\n    });\n}",
      "function getData(url) {\n    return new Promise((resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                if (xhr.status === 200) {\n                    resolve(xhr.responseText);\n                } else {\n                    reject(xhr.statusText);\n                }\n            }\n        };\n        xhr.onerror = function () {\n            reject(xhr.statusText);\n        };\n        xhr.send();\n    });\n}",
      "function getData(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getData(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.responseText);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getData(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.response);\n      } else {\n        reject(xhr.statusText);\n      }\n    };\n    xhr.onerror = () => {\n      reject(xhr.statusText);\n    };\n    xhr.send();\n  });\n}",
      "function getData(url) {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.onload = () => {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                resolve(xhr.responseText);\n            } else {\n                reject(xhr.statusText);\n            }\n        };\n        xhr.onerror = () => {\n            reject(xhr.statusText);\n        };\n        xhr.send();\n    });\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('Response:', response);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to fetch YAML:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('YAML content loaded:', yamlText);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to load YAML content:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML content:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('Response:', response);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to fetch YAML:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('Response:', response);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to fetch YAML:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('Response:', response);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to fetch YAML:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('YAML content loaded:', yamlText);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to load YAML content:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML content:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('Response:', response);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to fetch YAML:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('Response:', response);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to fetch YAML:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('Response:', response);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to fetch YAML:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML:', error);\n  }\n}\n```",
      "```javascript\nconst fetch = require('node-fetch');\n\nasync function loadYamlUrl(url, yamlToForm) {\n  try {\n    const response = await fetch(url);\n    if (response.ok) {\n      const yamlText = await response.text();\n      console.log('Response:', response);\n      yamlToForm(yamlText);\n    } else {\n      console.error('Failed to fetch YAML:', response.status);\n    }\n  } catch (error) {\n    console.error('Error fetching YAML:', error);\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urlunparse\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self._expand_is_gd,\n            'goo.gl': self._expand_goo_gl,\n            'budurl.com': self._expand_budurl,\n            'snipurl.com': self._expand_snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        headers = args.get('headers', {})\n        urlp = args.get('urlp', urlparse(url))\n\n        if url in seen:\n            callback(args)\n            return\n\n        seen[url] = True\n\n        domain = urlp.netloc.split('.')[-2]\n        if domain in self.map:\n            api_method = self.APIs[domain]\n            api_method(url, headers, lambda expanded_url, headers, err, *args: self._handle_response(expanded_url, headers, err, args, callback))\n\n    def _handle_response(self, expanded_url, headers, err, args, callback):\n        if err:\n            args['err'] = err\n            callback(args)\n            return\n\n        if expanded_url:\n            args['url'] = expanded_url\n            args['headers'] = headers\n            callback(args)\n        else:\n            args['err'] = Exception('Failed to expand URL')\n            callback(args)\n\n    def _expand_is_gd(self, url, headers, callback):\n        response = requests.get(url, headers=headers, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(url, response.headers, None)\n        else:\n            callback(None, response.headers, Exception('Failed to expand URL'))\n\n    def _expand_goo_gl(self, url, headers, callback):\n        response = requests.get(url, headers=headers, timeout=self.timeout)\n        if response.status_code == 200:\n            parsed_url = urlparse(response.url)\n            query_params = parse_qs(parsed_url.query)\n            if 'id' in query_params:\n                expanded_url = f'https://www.google.com/url?q={query_params[\"id\"][0]}'\n                callback(expanded_url, response.headers, None)\n            else:\n                callback(None, response.headers, Exception('Failed to expand URL'))\n        else:\n            callback(None, response.headers, Exception('Failed to expand URL'))\n\n    def _expand_budurl(self, url, headers, callback):\n        response = requests.get(url, headers=headers, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(url, response.headers, None)\n        else:\n            callback(None, response.headers, Exception('Failed to expand URL'))\n\n    def _expand_snipurl(self, url, headers, callback):\n        response = requests.get(url, headers=headers, timeout=self.timeout)\n        if response.status_code == 200:\n            callback(url, response.headers, None)\n        else:\n            callback(None, response.headers, Exception('Failed to expand URL'))\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urljoin\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self._expand_is_gd,\n            'goo.gl': self._expand_goo_gl,\n            'budurl.com': self._expand_budurl,\n            'snipurl.com': self._expand_snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n\n        if url in seen:\n            callback(args, None)\n            return\n\n        seen[url] = True\n\n        parsed_url = urlparse(url)\n        domain = parsed_url.netloc\n\n        if domain in self.map:\n            expanded_url = self.APIs[domain](url)\n            if expanded_url:\n                args['url'] = expanded_url\n                args['depth'] = depth + 1\n                self.expand(args, callback)\n            else:\n                callback(args, None)\n        else:\n            self._follow_redirects(url, depth, seen, callback)\n\n    def _expand_is_gd(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_goo_gl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_budurl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_snipurl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _follow_redirects(self, url, depth, seen, callback):\n        if depth > 5:\n            callback({'url': url, 'depth': depth, 'seen': seen}, None)\n            return\n\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            new_url = response.headers['Location']\n            new_url = urljoin(url, new_url)\n            args = {'url': new_url, 'depth': depth + 1, 'seen': seen}\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'depth': depth, 'seen': seen}, None)\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urlunparse\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self.expand_is_gd,\n            'goo.gl': self.expand_goo_gl,\n            'budurl.com': self.expand_budurl,\n            'snipurl.com': self.expand_snipurl\n        }\n\n    def expand_is_gd(self, url):\n        return url\n\n    def expand_goo_gl(self, url):\n        return url\n\n    def expand_budurl(self, url):\n        return url\n\n    def expand_snipurl(self, url):\n        return url\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        headers = args.get('headers', {})\n        urlp = args.get('urlp', urlparse(url))\n\n        if url in seen:\n            callback({'url': url, 'depth': depth, 'seen': seen, 'err': None, 'headers': headers, 'urlp': urlp})\n            return\n\n        if depth > 5:  # Prevent infinite loops\n            callback({'url': url, 'depth': depth, 'seen': seen, 'err': Exception('Maximum depth reached'), 'headers': headers, 'urlp': urlp})\n            return\n\n        domain = urlp.netloc.split('.')[-2]\n        if domain in self.map:\n            expanded_url = self.APIs[domain](url)\n            seen[url] = True\n            self.expand({'url': expanded_url, 'depth': depth + 1, 'seen': seen, 'headers': headers, 'urlp': urlp}, callback)\n        else:\n            response = requests.get(url, headers=headers, timeout=self.timeout)\n            if response.history:\n                final_url = response.url\n                seen[url] = True\n                self.expand({'url': final_url, 'depth': depth + 1, 'seen': seen, 'headers': response.headers, 'urlp': urlparse(final_url)}, callback)\n            else:\n                callback({'url': url, 'depth': depth, 'seen': seen, 'err': None, 'headers': response.headers, 'urlp': urlp})\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urlunparse\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self._expand_is_gd,\n            'goo.gl': self._expand_goo_gl,\n            'budurl.com': self._expand_budurl,\n            'snipurl.com': self._expand_snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        headers = args.get('headers', {})\n        urlp = args.get('urlp', urlparse(url))\n\n        if url in seen:\n            callback({'url': url, 'depth': depth, 'seen': seen, 'err': None, 'headers': headers, 'urlp': urlp})\n            return\n\n        seen[url] = True\n        domain = urlp.netloc.split('.')[-2] if '.' in urlp.netloc else None\n\n        if domain in self.map:\n            api = self.APIs[domain]\n            api(url, depth, seen, callback)\n        else:\n            self._follow_redirects(url, depth, seen, callback)\n\n    def _expand_is_gd(self, url, depth, seen, callback):\n        expanded_url = f\"https://is.gd/expand?url={url}\"\n        self._make_request(expanded_url, depth, seen, callback)\n\n    def _expand_goo_gl(self, url, depth, seen, callback):\n        expanded_url = f\"https:// goo.gl/shorturl?url={url}\"\n        self._make_request(expanded_url, depth, seen, callback)\n\n    def _expand_budurl(self, url, depth, seen, callback):\n        expanded_url = f\"https://budurl.com/expand?url={url}\"\n        self._make_request(expanded_url, depth, seen, callback)\n\n    def _expand_snipurl(self, url, depth, seen, callback):\n        expanded_url = f\"https://snipurl.com/api.php?url={url}\"\n        self._make_request(expanded_url, depth, seen, callback)\n\n    def _make_request(self, url, depth, seen, callback):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.status_code == 200:\n                headers = response.headers\n                urlp = urlparse(response.url)\n                final_url = urlp.geturl()\n                callback({'url': final_url, 'depth': depth + 1, 'seen': seen, 'err': None, 'headers': headers, 'urlp': urlp})\n            else:\n                callback({'url': url, 'depth': depth, 'seen': seen, 'err': None, 'headers': headers, 'urlp': urlp})\n        except requests.RequestException as e:\n            callback({'url': url, 'depth': depth, 'seen': seen, 'err': e, 'headers': {}, 'urlp': urlparse(url)})\n\n    def _follow_redirects(self, url, depth, seen, callback):\n        try:\n            response = requests.get(url, timeout=self.timeout, allow_redirects=False)\n            if response.status_code == 301 or response.status_code == 302:\n                final_url = response.headers['Location']\n                self.expand({'url': final_url, 'depth': depth + 1, 'seen': seen}, callback)\n            else:\n                callback({'url': url, 'depth': depth, 'seen': seen, 'err': None, 'headers': response.headers, 'urlp': urlparse(url)})\n        except requests.RequestException as e:\n            callback({'url': url, 'depth': depth, 'seen': seen, 'err': e, 'headers': {}, 'urlp': urlparse(url)})\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urlunparse\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self._expand_is_gd,\n            'goo.gl': self._expand_goo_gl,\n            'budurl.com': self._expand_budurl,\n            'snipurl.com': self._expand_snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n\n        if url in seen:\n            callback(args, None)\n            return\n\n        parsed_url = urlparse(url)\n        domain = parsed_url.netloc\n\n        if domain in self.map:\n            expanded_url = self.APIs[domain](url)\n            if expanded_url:\n                seen[url] = True\n                args['url'] = expanded_url\n                args['depth'] = depth + 1\n                args['seen'] = seen\n                self.expand(args, callback)\n            else:\n                callback(args, None)\n        else:\n            callback(args, None)\n\n    def _expand_is_gd(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_goo_gl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_budurl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_snipurl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urljoin\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self._expand_is_gd,\n            'goo.gl': self._expand_goo_gl,\n            'budurl.com': self._expand_budurl,\n            'snipurl.com': self._expand_snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        headers = args.get('headers', {})\n        urlp = args.get('urlp', urlparse(url))\n\n        if url in seen:\n            callback(args)\n            return\n\n        seen[url] = True\n\n        def handle_response(response):\n            if response.status_code == 200:\n                expanded_url = response.url\n                if expanded_url in self.map:\n                    args['url'] = expanded_url\n                    args['depth'] = depth + 1\n                    args['headers'] = headers\n                    args['urlp'] = urlparse(expanded_url)\n                    self.expand(args, callback)\n                else:\n                    callback(args)\n            else:\n                callback(args)\n\n        def make_request():\n            domain = urlp.netloc\n            if domain in self.map:\n                api_method = self.APIs[domain]\n                api_method(url, handle_response)\n            else:\n                response = requests.get(url, headers=headers, timeout=self.timeout)\n                handle_response(response)\n\n        make_request()\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urljoin\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self._expand_is_gd,\n            'goo.gl': self._expand_goo_gl,\n            'budurl.com': self._expand_budurl,\n            'snipurl.com': self._expand_snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n\n        if url in seen:\n            callback(args, None)\n            return\n\n        seen[url] = True\n\n        parsed_url = urlparse(url)\n        domain = parsed_url.netloc\n\n        if domain in self.map:\n            api_method = self.APIs[domain]\n            api_method(url, args, callback)\n        else:\n            self._follow_redirects(url, args, callback)\n\n    def _expand_is_gd(self, url, args, callback):\n        expanded_url = f\"https://is.gd/expand?url={url}\"\n        self._make_request(expanded_url, args, callback)\n\n    def _expand_goo_gl(self, url, args, callback):\n        expanded_url = f\"https:// goo.gl/shorturl?shortUrl={url}\"\n        self._make_request(expanded_url, args, callback)\n\n    def _expand_budurl(self, url, args, callback):\n        expanded_url = f\"https://budurl.com/expand/{url}\"\n        self._make_request(expanded_url, args, callback)\n\n    def _expand_snipurl(self, url, args, callback):\n        expanded_url = f\"https://snipurl.com/go/{url}\"\n        self._make_request(expanded_url, args, callback)\n\n    def _make_request(self, url, args, callback):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.status_code == 200:\n                expanded_url = response.text.strip()\n                args['url'] = expanded_url\n                args['depth'] += 1\n                self.expand(args, callback)\n            else:\n                callback(args, None, None, response.headers)\n        except requests.RequestException as e:\n            callback(args, e)\n\n    def _follow_redirects(self, url, args, callback):\n        try:\n            response = requests.get(url, timeout=self.timeout, allow_redirects=False)\n            if response.status_code == 301 or response.status_code == 302:\n                new_url = response.headers['Location']\n                args['url'] = new_url\n                args['depth'] += 1\n                self.expand(args, callback)\n            else:\n                callback(args, None)\n        except requests.RequestException as e:\n            callback(args, e)\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urlunparse\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self._expand_is_gd,\n            'goo.gl': self._expand_goo_gl,\n            'budurl.com': self._expand_budurl,\n            'snipurl.com': self._expand_snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n\n        if url in seen:\n            callback({'url': url, 'depth': depth, 'seen': seen, 'err': None})\n            return\n\n        parsed_url = urlparse(url)\n        domain = parsed_url.netloc\n\n        if domain in self.map:\n            expanded_url = self.APIs[domain](url)\n            if expanded_url:\n                args['url'] = expanded_url\n                args['depth'] = depth + 1\n                args['seen'][url] = True\n                self.expand(args, callback)\n            else:\n                callback({'url': url, 'depth': depth, 'seen': seen, 'err': None})\n        else:\n            try:\n                response = requests.get(url, timeout=self.timeout)\n                if response.history:\n                    final_url = response.url\n                    args['url'] = final_url\n                    args['depth'] = depth + 1\n                    args['seen'][url] = True\n                    self.expand(args, callback)\n                else:\n                    callback({'url': url, 'depth': depth, 'seen': seen, 'err': None})\n            except requests.RequestException as e:\n                callback({'url': url, 'depth': depth, 'seen': seen, 'err': e})\n\n    def _expand_is_gd(self, url):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.history:\n                return response.url\n        except requests.RequestException:\n            pass\n        return None\n\n    def _expand_goo_gl(self, url):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.history:\n                return response.url\n        except requests.RequestException:\n            pass\n        return None\n\n    def _expand_budurl(self, url):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.history:\n                return response.url\n        except requests.RequestException:\n            pass\n        return None\n\n    def _expand_snipurl(self, url):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.history:\n                return response.url\n        except requests.RequestException:\n            pass\n        return None\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urljoin\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self.expand_is_gd,\n            'goo.gl': self.expand_goo_gl,\n            'budurl.com': self.expand_budurl,\n            'snipurl.com': self.expand_snipurl\n        }\n\n    def expand_is_gd(self, url):\n        return url\n\n    def expand_goo_gl(self, url):\n        return url\n\n    def expand_budurl(self, url):\n        return url\n\n    def expand_snipurl(self, url):\n        return url\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        headers = args.get('headers', {})\n        urlp = args.get('urlp', urlparse(url))\n\n        if url in seen:\n            callback({'url': url, 'depth': depth, 'seen': seen, 'err': None, 'headers': headers, 'urlp': urlp})\n            return\n\n        seen[url] = True\n\n        domain = urlp.netloc\n        if domain in self.map:\n            expanded_url = self.APIs[domain](url)\n            if urlparse(expanded_url).netloc != domain:\n                self.expand({'url': expanded_url, 'depth': depth + 1, 'seen': seen, 'headers': headers, 'urlp': urlp}, callback)\n            else:\n                callback({'url': expanded_url, 'depth': depth, 'seen': seen, 'err': None, 'headers': headers, 'urlp': urlp})\n        else:\n            try:\n                response = requests.get(url, timeout=self.timeout, headers=headers)\n                if response.history:\n                    for resp in response.history:\n                        if resp.status_code == 301 or resp.status_code == 302:\n                            url = resp.headers['Location']\n                            break\n                callback({'url': url, 'depth': depth, 'seen': seen, 'err': None, 'headers': response.headers, 'urlp': urlp})\n            except requests.RequestException as e:\n                callback({'url': url, 'depth': depth, 'seen': seen, 'err': e, 'headers': headers, 'urlp': urlp})\n```",
      "```python\nimport requests\nfrom urllib.parse import urlparse, parse_qs, urljoin\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'is.gd': 'is.gd',\n            'goo.gl': 'goo.gl',\n            'budurl.com': 'budurl.com',\n            'snipurl.com': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'is.gd': self._expand_is_gd,\n            'goo.gl': self._expand_goo_gl,\n            'budurl.com': self._expand_budurl,\n            'snipurl.com': self._expand_snipurl\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n\n        if url in seen:\n            callback(args, None)\n            return\n\n        seen[url] = True\n\n        parsed_url = urlparse(url)\n        domain = parsed_url.netloc\n\n        if domain in self.map:\n            expanded_url = self.APIs[domain](url)\n            if expanded_url:\n                args['url'] = expanded_url\n                args['depth'] = depth + 1\n                self.expand(args, callback)\n            else:\n                callback(args, None)\n        else:\n            self._follow_redirects(url, depth, seen, callback)\n\n    def _expand_is_gd(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_goo_gl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_budurl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _expand_snipurl(self, url):\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 200:\n            return response.url\n        return None\n\n    def _follow_redirects(self, url, depth, seen, callback):\n        if depth > 5:\n            callback({'url': url, 'depth': depth, 'seen': seen}, None)\n            return\n\n        response = requests.get(url, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            new_url = response.headers['Location']\n            new_url = urljoin(url, new_url)\n            args = {'url': new_url, 'depth': depth + 1, 'seen': seen}\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'depth': depth, 'seen': seen}, None)\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a function that sets up an Express server to handle HTTP requests, including serving static files, processing form data, and executing external commands to generate PDF files.\n\nFunction Description: The function `startServer` initializes an Express application, configures middleware for request processing, defines route handlers for specific endpoints, and starts the server on a specified port. It serves static files, handles JSON and URL-encoded form data, and provides endpoints for rendering pages and generating PDFs via an external command.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on the specified port)",
    "Canonical_solution": "function startServer() {\n    var express = require('express');\n    var app = express();\n    const execFile = require('child_process').execFile;\n\n    app.set('port', (process.env.PORT || 5000));\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: false }));\n    app.use(cookieParser());\n    app.use(express.static(__dirname + '/'));\n\n    app.get('/', function(request, response) {\n        response.render('pages/index');\n    });\n\n    app.get('/path_to_pdf', function(request, response) {\n        const child = execFile('unoconv', ['-f', 'pdf', 'generate-wifi.odt'], function(error, stdout, stderr) {\n            if (error) {\n                throw error;\n            }\n            response.json({ message: stdout });\n        });\n    });\n\n    app.listen(app.get('port'), function() {\n        console.log('Node app is running on port', app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.post('/generate-pdf', (req, res) => {\n  const command = `pdftk input.pdf cat 1-10 output output.pdf`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      return res.status(500).send('Error generating PDF');\n    }\n    res.download('output.pdf');\n  });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.post('/generate-pdf', (req, res) => {\n  const command = `pdftk input.pdf cat 1 2 output output.pdf`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      res.status(500).send('Error generating PDF');\n      return;\n    }\n    if (stderr) {\n      res.status(500).send('Error generating PDF');\n      return;\n    }\n    res.download('output.pdf');\n  });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.post('/generate-pdf', (req, res) => {\n  const command = `pdftk input.pdf cat 1 2 output output.pdf`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      return res.status(500).send('Error generating PDF');\n    }\n    res.download('output.pdf');\n  });\n});\napp.get('/', (req, res) => {\n  res.sendFile(__dirname + '/index.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.post('/generate-pdf', (req, res) => {\n  const command = `pdftk input.pdf cat 1 2 output output.pdf`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      res.status(500).send('Error generating PDF');\n      return;\n    }\n    if (stderr) {\n      res.status(500).send('Error generating PDF');\n      return;\n    }\n    res.download('output.pdf');\n  });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.post('/generate-pdf', (req, res) => {\n  const command = `pdftk input.pdf cat 1 output output.pdf`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      res.status(500).send('Error generating PDF');\n      return;\n    }\n    if (stderr) {\n      res.status(500).send('Error generating PDF');\n      return;\n    }\n    res.download('output.pdf');\n  });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.post('/generate-pdf', (req, res) => {\n  const command = `pdftk input.pdf cat 1 2 output output.pdf`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      return res.status(500).send('Error generating PDF');\n    }\n    res.download('output.pdf');\n  });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.post('/generate-pdf', (req, res) => {\n  const command = `pdftk input.pdf cat 1 2 output output.pdf`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      res.status(500).send('Error generating PDF');\n      return;\n    }\n    res.download('output.pdf');\n  });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/generate-pdf', (req, res) => {\n  const command = 'pdftk';\n  const args = ['input', 'input.pdf', 'output', 'output.pdf', 'cat', '1', '2', '3', 'endcat'];\n  const child = spawn(command, args);\n\n  child.stdout.on('data', (data) => {\n    console.log(`stdout: ${data}`);\n  });\n\n  child.stderr.on('data', (data) => {\n    console.error(`stderr: ${data}`);\n  });\n\n  child.on('close', (code) => {\n    console.log(`child process exited with code ${code}`);\n    res.download(path.join(__dirname, 'output.pdf'));\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst { exec } = require('child_process');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/generate-pdf', (req, res) => {\n  const command = 'your-pdf-generating-command';\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      return res.status(500).send('Error generating PDF');\n    }\n    if (stderr) {\n      return res.status(500).send('Error generating PDF');\n    }\n    res.download('output.pdf');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\nconst { exec } = require('child_process');\nconst app = express();\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.post('/generate-pdf', (req, res) => {\n  const command = `pdftk input.pdf cat 1 output output.pdf`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      return res.status(500).send('Error generating PDF');\n    }\n    res.download('output.pdf');\n  });\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create an HTTP server using Express.js that handles various routes for data processing, API endpoints, and event handling. The server should dynamically generate API endpoints based on available utility functions and provide basic route handling for updates, embedding, and event processing.\n\nFunction Description: The `createServer` function initializes an Express.js server with middleware configuration, defines route handlers for specific endpoints, dynamically creates API routes based on utility functions, and starts the server on a random available port. It outputs the server's port information as JSON to stdout.\n\nInput: None (The function takes no parameters but relies on external modules and variables like `express`, `connect`, `dataIn`, `locker`, `oembed`, `async`, `logger`, and `util` being available in scope)\n\nOutput: \n- The function doesn't return anything directly\n- Writes server port information to stdout as JSON: `{port: [number]}`\n- Creates a running HTTP server listening on localhost\n- Provides the following endpoints:\n  - GET /update - Triggers reindexing\n  - GET /embed - Handles oEmbed requests\n  - POST /events - Processes queued events\n  - Dynamic GET routes based on utility functions",
    "Canonical_solution": "function createServer() {\n    var express = require('express'),\n        connect = require('connect');\n    var app = express.createServer(connect.bodyParser());\n    app.use(require(\"express-jsonstream\")());\n    app.set('views', __dirname);\n    app.get('/update', function (req, res) {\n        dataIn.reIndex(locker, function () {\n            res.writeHead(200);\n            res.end('Extra mince!');\n        });\n    });\n    app.get('/embed', function (req, res) {\n        if (!dataIn.process) return res.send({});\n        oembed.fetch({url:req.query.url}, function (e) {\n            if(e) return res.send(e);\n            res.send({});\n        });\n    });\n    app.post('/events', function (req, res) {\n        var q = async.queue(dataIn.processEvent, 1);\n        req.jsonStream(q.push, function (error) {\n            if(error) logger.error(error);\n            res.send(200);\n        });\n    });\n    function genericApi(name,f) {\n        app.get(name, function (req,res) {\n            var results = [];\n            f(req.query, function (item) { results.push(item); }, function (err) {\n                if(err) {\n                    res.writeHead(500, {'Content-Type': 'text/plain'});\n                    res.end(err);\n                } else {\n                    res.writeHead(200, {'Content-Type': 'application/json'});\n                    res.end(JSON.stringify(results));\n                }\n            });\n        });\n    }\n    for (var f in util) {\n        if (f == 'init') continue;\n        genericApi('/'+f,util[f]);\n    }\n    app.listen(0, 'localhost', function () {\n        var returnedInfo = {port: app.address().port};\n        process.stdout.write(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nconst app = express();\nconst port = Math.floor(Math.random() * 10000) + 3000;\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.status(200).send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.processEvent(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error(err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.status(200).send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getWeather': (req, res) => {\n    // Implementation for getting weather\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\napp.listen(port, () => {\n  console.log(JSON.stringify({ port: port }));\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('./logger');\nconst util = require('util');\n\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.processEvent(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error('Error processing events', err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getProfile': (req, res) => {\n    // Profile retrieval logic\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nconst server = http.createServer(app);\n\nserver.listen(() => {\n  const port = server.address().port;\n  process.stdout.write(JSON.stringify({port: port}));\n});\n```",
      "```javascript\nconst express = require('express');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.process(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error('Error processing events', err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getAnalytics': (req, res) => {\n    // Placeholder for analytics function\n    res.send('Analytics data');\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nconst server = app.listen(() => {\n  const port = server.address().port;\n  console.log(JSON.stringify({ port: port }));\n});\n```",
      "```javascript\nconst express = require('express');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.processEvent(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error('Error processing events', err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getAnalytics': (req, res) => {\n    // Placeholder for actual analytics function\n    res.send('Analytics data');\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nconst server = app.listen(() => {\n  const port = server.address().port;\n  console.log(JSON.stringify({ port: port }));\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nconst app = express();\nconst server = http.createServer(app);\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.process(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error(err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getStats': (req, res) => {\n    util.getStats((err, stats) => {\n      if (err) {\n        logger.error(err);\n        res.status(500).send('Error retrieving stats');\n      } else {\n        res.json(stats);\n      }\n    });\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nserver.listen(0, () => {\n  const { port } = server.address();\n  process.stdout.write(JSON.stringify({ port: port }));\n});\n```",
      "```javascript\nconst express = require('express');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.process(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error('Error processing events', err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getWeather': (req, res) => {\n    // Implementation for getting weather\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nconst server = app.listen(() => {\n  const port = server.address().port;\n  console.log(JSON.stringify({ port: port }));\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nconst app = express();\nconst server = http.createServer(app);\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.processEvent(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error('Error processing events', err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getAnalytics': (req, res) => {\n    util.promisify(dataIn.getAnalytics)().then((result) => {\n      res.json(result);\n    }).catch((error) => {\n      logger.error('Error fetching analytics', error);\n      res.status(500).send('Error fetching analytics');\n    });\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nserver.listen(0, () => {\n  const { port } = server.address();\n  process.stdout.write(JSON.stringify({ port: port }));\n});\n```",
      "```javascript\nconst express = require('express');\nconst http = require('http');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('./logger');\nconst util = require('util');\n\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.process(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error('Error processing events', err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getWeather': (req, res) => {\n    // Placeholder for weather retrieval logic\n    res.send('Weather data');\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nconst server = http.createServer(app);\n\nserver.listen(0, () => {\n  const { port } = server.address();\n  process.stdout.write(JSON.stringify({ port: port }));\n});\n```",
      "```javascript\nconst express = require('express');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nconst app = express();\nconst server = require('http').createServer(app);\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.lock(event, () => {\n      // Process event\n      logger.log(`Processing event: ${util.inspect(event)}`);\n      callback();\n    });\n  }, (err) => {\n    if (err) {\n      logger.error('Error processing events', err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getDynamicData': (req, res) => {\n    // Dynamic data processing logic\n    res.send('Dynamic data retrieved');\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nserver.listen(0, () => {\n  const port = server.address().port;\n  process.stdout.write(JSON.stringify({ port: port }));\n});\n```",
      "```javascript\nconst express = require('express');\nconst connect = require('connect');\nconst dataIn = require('./dataIn');\nconst locker = require('./locker');\nconst oembed = require('./oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/update', (req, res) => {\n  dataIn.reindex();\n  res.send('Reindexing triggered');\n});\n\napp.get('/embed', (req, res) => {\n  oembed.handle(req, res);\n});\n\napp.post('/events', (req, res) => {\n  async.each(req.body.events, (event, callback) => {\n    locker.process(event, callback);\n  }, (err) => {\n    if (err) {\n      logger.error('Error processing events', err);\n      res.status(500).send('Error processing events');\n    } else {\n      res.send('Events processed');\n    }\n  });\n});\n\nconst utilityFunctions = {\n  // Example utility function\n  'getWeather': (req, res) => {\n    // Implementation for getting weather\n  }\n};\n\nObject.keys(utilityFunctions).forEach((key) => {\n  app.get(`/${key}`, utilityFunctions[key]);\n});\n\nconst server = app.listen(() => {\n  const port = server.address().port;\n  process.stdout.write(JSON.stringify({ port: port }));\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function that sets up an Express server with webpack middleware for development purposes, serves a main HTML file, and listens on a specified port.\n\nFunction Description: The function `setupServer` initializes an Express application, configures webpack middleware for development (including hot module replacement), defines a route to serve the main HTML file, and starts the server on the specified port. It handles errors during server startup and logs success messages.\n\nInput: None (The function does not take any explicit parameters. It relies on external variables `compiler` and `config` for webpack configuration.)\n\nOutput: None (The function does not return any value. It starts the server process and logs messages to the console.)",
    "Canonical_solution": "function setupServer() {\n    var app = new require('express')();\n    var port = 4001;\n\n    app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }));\n    app.use(webpackHotMiddleware(compiler));\n\n    app.get(\"/\", function(req, res) {\n        res.sendFile(__dirname + '/index.html');\n    });\n\n    app.listen(port, function(error) {\n        if (error) {\n            console.error(error);\n        } else {\n            console.info(\"==> ðŸŒŽ  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server is running on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server is running on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log(`Server started on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server started on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server is running on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server started on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server started on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server is running on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server is running on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendfile(path.resolve(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server is running on http://localhost:${config.port}`);\n  }\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a function to start an HTTP server using Express that serves static files from a specified directory and handles all routes by returning the static files.\n\nFunction Description: The function `startServer` initializes an Express application, configures it to serve static files from a predefined directory, and sets up a catch-all route to return the static files for any HTTP GET request. The server listens on a specified port and host.\n\nInput: None (The function uses predefined constants for port, host, and static file directory.)\n\nOutput: None (The function starts the server but does not return any value.)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const path = require('path');\n    \n    const PORT = process.env.PORT || 8080;\n    const HOST = '0.0.0.0';\n    const WWW = path.join(__dirname, '..', '/www/');\n\n    const app = express();\n    app.use(express.static(WWW));\n    app.get('*', function (req, res) {\n        res.sendFile(WWW);\n    });\n\n    app.listen(PORT, HOST);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\napp.use(express.static(STATIC_DIR));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\napp.use(express.static(STATIC_DIR));\napp.get('*', (req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = 'public';\n\napp.use(express.static(STATIC_DIR));\napp.get('*', (req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = './public';\n\napp.use(express.static(STATIC_DIR));\napp.get('*', (req, res) => {\n  res.sendFile(path.join(STATIC_DIR, req.url));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running on http://${HOST}:${PORT}/`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\napp.use(express.static(STATIC_DIR));\napp.get('*', (req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});"
    ],
    "unmatched_results": [
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\napp.use(express.static(STATIC_DIR));\napp.use((req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\napp.use(express.static(STATIC_DIR));\napp.use((req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\napp.use(express.static(STATIC_DIR));\napp.use((req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\napp.use(express.static(STATIC_DIR));\napp.use((req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = 3000;\nconst HOST = 'localhost';\nconst STATIC_DIR = path.join(__dirname, 'public');\n\napp.use(express.static(STATIC_DIR));\napp.use((req, res) => {\n  res.sendFile(path.join(STATIC_DIR, 'index.html'));\n});\n\napp.listen(PORT, HOST, () => {\n  console.log(`Server running at http://${HOST}:${PORT}/`);\n});"
    ],
    "match_count": 5,
    "pass@3": 0.9166666666666666,
    "pass@5": 0.996031746031746
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a function that sets up and configures an Express server with webpack middleware, proxy support, and static file serving capabilities.\n\nFunction Description: The function `createServer` initializes an Express application, configures it with webpack development and hot-reload middleware, sets up proxy routes based on a proxy table, enables history API fallback for single-page applications, serves static files, and starts the server on a specified port.\n\nInput: \n- None (The function relies on external configurations like `webpackConfig`, `proxyTable`, `config.dev`, and `port` which should be defined in the scope where the function is called)\n\nOutput: \n- Returns an HTTP server instance that is listening on the specified port, configured with all the middleware and routes.\n\nNote: The function assumes the following external dependencies are available:\n- `express`: The Express framework\n- `http-proxy-middleware`: For proxy functionality\n- `webpack` and related middlewares (`webpack-dev-middleware`, `webpack-hot-middleware`)\n- `connect-history-api-fallback`: For SPA history API fallback\n- `path`: Node.js path module\n- External configuration objects: `webpackConfig`, `proxyTable`, `config.dev`, `port`",
    "Canonical_solution": "const express = require('express')\nconst proxyMiddleware = require('http-proxy-middleware')\n\nfunction createServer() {\n  const app = express()\n  const compiler = webpack(webpackConfig)\n\n  const devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n    quiet: true,\n  })\n\n  const hotMiddleware = require('webpack-hot-middleware')(compiler, {\n    log: false,\n    heartbeat: 2000,\n  })\n\n  app.use(hotMiddleware)\n\n  Object.keys(proxyTable).forEach(function(context) {\n    let options = proxyTable[context]\n    if (typeof options === 'string') {\n      options = {target: options}\n    }\n    app.use(proxyMiddleware(options.filter || context, options))\n  })\n\n  app.use(require('connect-history-api-fallback')()))\n  app.use(devMiddleware)\n\n  const staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n  app.use(staticPath, express.static('./static'))\n\n  var server = app.listen(port)\n  return server\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\nconst app = express();\n\napp.use(webpackDevMiddleware(webpack(webpackConfig)));\napp.use(webpackHotMiddleware(webpack(webpackConfig)));\n\nObject.keys(proxyTable).forEach(function (context) {\n  let options = proxyTable[context];\n  if (typeof options === 'string') {\n    options = { target: options };\n  }\n  app.use(context, httpProxyMiddleware(options));\n});\n\napp.use(connectHistoryApiFallback());\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.listen(port, function () {\n  console.log(`Server is listening on port ${port}`);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\nconst app = express();\n\napp.use(webpackDevMiddleware(webpack(webpackConfig)));\napp.use(webpackHotMiddleware(webpack(webpackConfig)));\n\nObject.keys(proxyTable).forEach(function (context) {\n  let options = proxyTable[context];\n  if (typeof options === 'string') {\n    options = { target: options };\n  }\n  app.use(context, httpProxyMiddleware(options));\n});\n\napp.use(connectHistoryApiFallback());\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.listen(port, function () {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\n\nfunction createServer() {\n  const app = express();\n  const compiler = webpack(webpackConfig);\n  const devMiddleware = webpackDevMiddleware(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n  });\n  const hotMiddleware = webpackHotMiddleware(compiler);\n\n  app.use(devMiddleware);\n  app.use(hotMiddleware);\n\n  Object.keys(proxyTable).forEach(function (context) {\n    const options = proxyTable[context];\n    if (typeof options === 'string') {\n      options = { target: options };\n    }\n    app.use(httpProxyMiddleware(options));\n  });\n\n  app.use(connectHistoryApiFallback());\n\n  app.use(express.static(path.join(__dirname, config.dev.assetsPublicPath)));\n\n  app.listen(port, function () {\n    console.log(`Listening on port ${port}`);\n  });\n\n  return app;\n}",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\n\nfunction createServer() {\n  const app = express();\n  const compiler = webpack(webpackConfig);\n  const devMiddleware = webpackDevMiddleware(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n  });\n  const hotMiddleware = webpackHotMiddleware(compiler);\n\n  app.use(devMiddleware);\n  app.use(hotMiddleware);\n\n  Object.keys(proxyTable).forEach(function (context) {\n    const options = proxyTable[context];\n    if (typeof options === 'string') {\n      options = { target: options };\n    }\n    app.use(httpProxyMiddleware(options));\n  });\n\n  app.use(connectHistoryApiFallback());\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.listen(config.dev.port, function () {\n    console.log(`Listening on port ${config.dev.port}`);\n  });\n\n  return app;\n}",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\nconst app = express();\n\napp.use(webpackDevMiddleware(webpack(webpackConfig)));\napp.use(webpackHotMiddleware(webpack(webpackConfig)));\n\nObject.keys(proxyTable).forEach(function (context) {\n  const options = proxyTable[context];\n  if (typeof options === 'string') {\n    options = { target: options };\n  }\n  app.use(context, httpProxyMiddleware(options));\n});\n\napp.use(connectHistoryApiFallback());\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.listen(port, function () {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\n\nfunction createServer() {\n  const app = express();\n  const compiler = webpack(webpackConfig);\n  const devMiddleware = webpackDevMiddleware(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n  });\n  const hotMiddleware = webpackHotMiddleware(compiler);\n\n  app.use(devMiddleware);\n  app.use(hotMiddleware);\n\n  Object.keys(proxyTable).forEach(function (context) {\n    const options = proxyTable[context];\n    if (typeof options === 'string') {\n      options = { target: options };\n    }\n    app.use(httpProxyMiddleware(options));\n  });\n\n  app.use(connectHistoryApiFallback());\n\n  app.use(express.static(path.join(__dirname, config.dev.assetsPublicPath)));\n\n  app.listen(port, function () {\n    console.log(`Listening on port ${port}`);\n  });\n\n  return app;\n}",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\n\nfunction createServer() {\n  const app = express();\n  const compiler = webpack(webpackConfig);\n  const devMiddleware = webpackDevMiddleware(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n    noInfo: true,\n  });\n  const hotMiddleware = webpackHotMiddleware(compiler);\n\n  app.use(devMiddleware);\n  app.use(hotMiddleware);\n\n  Object.keys(proxyTable).forEach(function (context) {\n    const options = proxyTable[context];\n    if (typeof options === 'string') {\n      options = { target: options };\n    }\n    app.use(context, httpProxyMiddleware(options));\n  });\n\n  app.use(connectHistoryApiFallback());\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.listen(config.dev.port, function () {\n    console.log(`Listening on port ${config.dev.port}`);\n  });\n\n  return app;\n}",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\n\nfunction createServer() {\n  const app = express();\n  const compiler = webpack(webpackConfig);\n  const devMiddleware = webpackDevMiddleware(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n  });\n  const hotMiddleware = webpackHotMiddleware(compiler);\n\n  app.use(devMiddleware);\n  app.use(hotMiddleware);\n\n  Object.keys(proxyTable).forEach(function (context) {\n    const options = proxyTable[context];\n    if (typeof options === 'string') {\n      options = { target: options };\n    }\n    app.use(httpProxyMiddleware(options));\n  });\n\n  app.use(connectHistoryApiFallback());\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.listen(config.dev.port, function () {\n    console.log(`Listening on port ${config.dev.port}`);\n  });\n\n  return app;\n}",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\n\nfunction createServer() {\n  const app = express();\n  const compiler = webpack(webpackConfig);\n  const devMiddleware = webpackDevMiddleware(compiler, {\n    publicPath: webpackConfig.output.publicPath,\n  });\n  const hotMiddleware = webpackHotMiddleware(compiler);\n\n  app.use(devMiddleware);\n  app.use(hotMiddleware);\n\n  Object.keys(proxyTable).forEach(function (context) {\n    const options = proxyTable[context];\n    if (typeof options === 'string') {\n      options = { target: options };\n    }\n    app.use(httpProxyMiddleware(options));\n  });\n\n  app.use(connectHistoryApiFallback());\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.listen(config.dev.port, function () {\n    console.log(`Listening on port ${config.dev.port}`);\n  });\n\n  return app;\n}",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst connectHistoryApiFallback = require('connect-history-api-fallback');\nconst path = require('path');\nconst app = express();\n\napp.use(webpackDevMiddleware(webpack(webpackConfig)));\napp.use(webpackHotMiddleware(webpack(webpackConfig)));\n\nObject.keys(proxyTable).forEach(function (context) {\n  let options = proxyTable[context];\n  if (typeof options === 'string') {\n    options = { target: options };\n  }\n  app.use(context, httpProxyMiddleware(options));\n});\n\napp.use(connectHistoryApiFallback());\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Create a function to start an HTTP server using Express framework that serves static files and handles specific routes, with logging upon server startup.\n\nFunction Description: The function initializes an Express server with middleware for request processing, sets up static file serving, defines a route handler for CSV data, and starts listening on a specified port. Upon successful startup, it logs server information.\n\nInput: \n- None (uses module-level `processInfo.port` for port configuration)\n- Implicitly uses `csv` variable for the CSV endpoint response\n\nOutput: \n- No direct return value\n- Side effects:\n  - Creates and starts an HTTP server\n  - Logs server information to console upon successful startup\n  - Serves static files from './static' directory\n  - Responds to GET requests at '/csv' endpoint with CSV data",
    "Canonical_solution": "function startServer() {\n    var express = require('express'),\n        connect = require('connect');\n    var app = express.createServer(connect.bodyParser(), connect.cookieParser());\n    \n    app.set('views', __dirname);\n    app.use(express.static(__dirname + '/static'));\n    \n    app.get('/csv', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end(csv);\n    });\n    \n    app.listen(processInfo.port, function() {\n        var returnedInfo = {};\n        console.log(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst csv = require('csv-parser');\nconst { promisify } = require('util');\nconst readFileAsync = promisify(fs.readFile);\n\nconst app = express();\nconst port = processInfo.port;\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', async (req, res) => {\n  const csvData = await readFileAsync('data.csv');\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(csvData);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst csv = require('csv-parser');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', (req, res) => {\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(csv);\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst csv = require('csv-parser');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', (req, res) => {\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(csv);\n});\n\napp.listen(processInfo.port, () => {\n  console.log(`Server running on port ${processInfo.port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst csv = require('csv-parser');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', (req, res) => {\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(csv);\n});\n\nconst port = processInfo.port || 3000;\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst csv = require('csv');\nconst fs = require('fs');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', (req, res) => {\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(csv);\n});\n\nconst port = processInfo.port || 3000;\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst csv = require('csv-parser');\nconst { promisify } = require('util');\nconst readFileAsync = promisify(fs.readFile);\n\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', async (req, res) => {\n  const data = await readFileAsync('./data.csv');\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(data);\n});\n\nconst startServer = async () => {\n  const port = processInfo.port;\n  app.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n};\n\nstartServer();",
      "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst csv = require('csv-parser');\n\nconst app = express();\nconst port = processInfo.port;\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', (req, res) => {\n  const csvData = [];\n  fs.createReadStream('data.csv')\n    .pipe(csv())\n    .on('data', (data) => csvData.push(data))\n    .on('end', () => {\n      res.setHeader('Content-Type', 'text/csv');\n      res.send(csvData);\n    });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst csv = require('csv-parser');\nconst { promisify } = require('util');\nconst readFileAsync = promisify(fs.readFile);\n\nconst app = express();\nconst port = processInfo.port;\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', async (req, res) => {\n  const csvData = await readFileAsync('./data.csv');\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(csvData);\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst csv = require('csv');\nconst fs = require('fs');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', (req, res) => {\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(csv);\n});\n\nconst port = processInfo.port || 3000;\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst csv = require('csv-parser');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'static')));\n\napp.get('/csv', (req, res) => {\n  res.setHeader('Content-Type', 'text/csv');\n  res.send(csv);\n});\n\nconst port = processInfo.port || 3000;\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a function to start an Express.js server that handles HTTP requests, serves static files, implements custom middleware, and manages error handling.\n\nFunction Description: The function initializes an Express application, configures it with necessary settings and middleware, defines route handlers, and starts listening on a specified port. It includes:\n1. Static file serving from a 'public' directory\n2. Custom middleware for test mode detection\n3. Route handling for the home page\n4. 404 and 500 error handlers\n5. Server startup with port configuration\n\nInput: None (The function takes no parameters as it's self-contained)\n\nOutput: None (The function doesn't return anything but starts a server process that listens for HTTP requests)",
    "Canonical_solution": "function startServer() {\n    var express = require('express');\n    var app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n\n    app.use(function(req, res, next){\n        res.locals.showTests = app.get('env') !== 'production' && \n            req.query.test === '1';\n        next();\n    });\n\n    app.get('/', function(req, res) {\n        res.render('home');\n    });\n\n    app.use(function(req, res, next){\n        res.status(404);\n        res.render('404');\n    });\n\n    app.use(function(err, req, res, next){\n        console.error(err.stack);\n        res.status(500);\n        res.render('500');\n    });\n\n    app.listen(app.get('port'), function(){\n        console.log('Express started on http://localhost:' + \n            app.get('port') + '; press Ctrl-C to terminate.');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (req.query.test === 'true') {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page!');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (process.env.NODE_ENV === 'test') {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, that page does not exist!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (req.query.test) {\n    res.locals.testMode = true;\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page');\n});\n\napp.use((req, res, next) => {\n  const error = new Error('Not Found');\n  error.status = 404;\n  next(error);\n});\n\napp.use((error, req, res, next) => {\n  res.status(error.status || 500);\n  res.send(`Error: ${error.message}`);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (req.query.test === 'true') {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the home page!');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, that page does not exist!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (process.env.NODE_ENV === 'test') {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (req.query.test === 'true') {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (req.query.test) {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page!');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, that page does not exist!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (req.query.test) {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.send('Hello, World!');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (req.query.test === 'true') {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  if (req.headers.testmode) {\n    console.log('Test mode detected');\n  }\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.memoryStorage();\n    this.upload = multer({ storage: this.storage });\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = http.createServer(this.app);\n      this.server.listen(this.port, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((err) => {\n          if (err) {\n            reject(err);\n          } else {\n            this.server = null;\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst fs = require('fs');\nconst path = require('path');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.diskStorage({\n      destination: (req, file, cb) => {\n        cb(null, 'uploads/');\n      },\n      filename: (req, file, cb) => {\n        cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname));\n      }\n    });\n    this.upload = multer({ storage: this.storage });\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.port, () => {\n        resolve();\n      }).on('error', reject);\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close(err => {\n          if (err) {\n            return reject(err);\n          }\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.memoryStorage();\n    this.upload = multer({ storage: this.storage });\n  }\n\n  async start() {\n    this.server = http.createServer(this.app);\n    this.server.listen(this.port);\n    return new Promise((resolve, reject) => {\n      this.server.on('listening', () => resolve());\n      this.server.on('error', reject);\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      return new Promise((resolve, reject) => {\n        this.server.close(() => {\n          this.server = null;\n          resolve();\n        });\n        this.server.on('error', reject);\n      });\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.memoryStorage();\n    this.upload = multer({ storage: this.storage });\n  }\n\n  async start() {\n    this.server = http.createServer(this.app);\n    this.server.listen(this.port);\n    return new Promise((resolve, reject) => {\n      this.server.on('listening', () => resolve());\n      this.server.on('error', reject);\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      return new Promise((resolve, reject) => {\n        this.server.close(() => {\n          this.server = null;\n          resolve();\n        });\n        this.server.on('error', reject);\n      });\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.memoryStorage();\n    this.upload = multer({ storage: this.storage });\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = http.createServer(this.app);\n      this.server.listen(this.port, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((err) => {\n          if (err) {\n            reject(err);\n          } else {\n            this.server = null;\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.memoryStorage();\n    this.upload = multer({ storage: this.storage });\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = http.createServer(this.app);\n      this.server.listen(this.port, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((err) => {\n          if (err) {\n            reject(err);\n          } else {\n            this.server = null;\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.memoryStorage();\n    this.upload = multer({ storage: this.storage });\n  }\n\n  async start() {\n    this.server = http.createServer(this.app);\n    this.server.listen(this.port);\n    return new Promise((resolve, reject) => {\n      this.server.on('listening', () => resolve());\n      this.server.on('error', reject);\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      return new Promise((resolve, reject) => {\n        this.server.close(() => {\n          this.server = null;\n          resolve();\n        });\n        this.server.on('error', reject);\n      });\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.memoryStorage();\n    this.upload = multer({ storage: this.storage });\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = http.createServer(this.app);\n      this.server.listen(this.port, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((err) => {\n          if (err) {\n            reject(err);\n          } else {\n            this.server = null;\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst http = require('http');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.memoryStorage();\n    this.upload = multer({ storage: this.storage });\n  }\n\n  async start() {\n    this.server = http.createServer(this.app);\n    this.server.listen(this.port);\n    return new Promise((resolve, reject) => {\n      this.server.on('listening', () => resolve());\n      this.server.on('error', reject);\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      return new Promise((resolve, reject) => {\n        this.server.close(() => {\n          this.server = null;\n          resolve();\n        });\n        this.server.on('error', reject);\n      });\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```",
      "```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst fs = require('fs');\nconst path = require('path');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.storage = multer.diskStorage({\n      destination: (req, file, cb) => {\n        cb(null, 'uploads/');\n      },\n      filename: (req, file, cb) => {\n        cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname));\n      }\n    });\n    this.upload = multer({ storage: this.storage });\n  }\n\n  async start() {\n    this.server = await new Promise((resolve, reject) => {\n      this.app.listen(this.port, (err) => {\n        if (err) reject(err);\n        else resolve();\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      return new Promise((resolve, reject) => {\n        this.server.close((err) => {\n          if (err) reject(err);\n          else resolve();\n        });\n      });\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a function to set up an Express server with routes for managing todo items, including creating, retrieving, and deleting todos.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures JSON middleware, and defines route handlers for HTTP methods (GET, POST, DELETE) to manage todo items. The server listens on port 8080.\n\nInput: None\n\nOutput: None (The function starts an Express server but does not return any value.)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const app = express();\n    app.use(express.json());\n\n    app.delete(\"/todos\", async (req, res) => {\n        const {id} = req.body;  \n        const result = await deleteTodo(id);\n        res.setHeader(\"content-type\", \"application/json\");\n        res.send(JSON.stringify({result: result}));\n    });\n\n    app.post(\"/todos\", async (req, res) => {\n        const todoText = req.body;\n        const result = await create(todoText.todoText);\n        res.setHeader(\"content-type\", \"application/json\");\n        res.send(JSON.stringify({result: result}));\n    });\n\n    app.get(\"/todos\", async (req,res) => {\n        res.setHeader(\"content-type\", \"application/json\");\n        const result = await pool.query(\"select id, text from todos\");\n        res.send(JSON.stringify({result}));\n    });\n\n    app.listen(8080, () => console.log(\"listening\"));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos logic here\n});\napp.post('/todos', (req, res) => {\n  // Create todo logic here\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo logic here\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos\n});\napp.post('/todos', (req, res) => {\n  // Create todo\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos logic here\n});\napp.post('/todos', (req, res) => {\n  // Create todo logic here\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo logic here\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos logic here\n});\napp.post('/todos', (req, res) => {\n  // Create todo logic here\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo logic here\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos logic here\n});\napp.post('/todos', (req, res) => {\n  // Create todo logic here\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo logic here\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos logic here\n});\napp.post('/todos', (req, res) => {\n  // Create todo logic here\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo logic here\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos\n});\napp.post('/todos', (req, res) => {\n  // Create todo\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos logic here\n});\napp.post('/todos', (req, res) => {\n  // Create todo logic here\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo logic here\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos\n});\napp.post('/todos', (req, res) => {\n  // Create todo\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.get('/todos', (req, res) => {\n  // Retrieve todos logic here\n});\napp.post('/todos', (req, res) => {\n  // Create todo logic here\n});\napp.delete('/todos/:id', (req, res) => {\n  // Delete todo logic here\n});\napp.listen(8080);"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a function that sets up an HTTP server using Express.js to handle POST requests and serve static files.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware for handling file uploads and static files, defines route handlers for POST requests, and starts the server on port 3000. It handles two POST endpoints: `/post` and `/post-get`. The `/post` endpoint returns a JSON string of the request body, while the `/post-get` endpoint redirects to a specified HTML file.\n\nInput: None\n\nOutput: None (The function starts an HTTP server that listens on port 3000 and does not return any value.)",
    "Canonical_solution": "function setupServer() {\n    var express = require('express');\n    var multer = require('multer');\n    var app = express();\n    var upload = multer();\n\n    app.use(express.static('../../'));\n\n    app.post('/post', upload.array(), function(req, res, next) {\n        var content = '<div id=\"result1\">';\n        content += JSON.stringify(req.body, 5);\n        content += '</div>';\n        res.end(content);\n    });\n\n    app.post('/post-get', upload.array(), function(req, res, next) {\n        res.redirect('/examples/form/redirect.html');\n    });\n\n    app.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(multer({ dest: 'uploads/' }).array('file'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/post', (req, res) => {\n  res.json(req.body);\n});\n\napp.post('/post-get', (req, res) => {\n  const filePath = path.join(__dirname, 'public', req.body.file);\n  res.redirect(filePath);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\nconst port = 3000;\n\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, 'uploads/');\n  },\n  filename: function (req, file, cb) {\n    cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname));\n  }\n});\n\nconst upload = multer({ storage: storage });\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(express.static('public'));\n\napp.post('/post', upload.single('file'), (req, res) => {\n  res.json(req.body);\n});\n\napp.get('/post-get', (req, res) => {\n  const filePath = req.query.file;\n  res.redirect(filePath);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\n\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, 'uploads/');\n  },\n  filename: function (req, file, cb) {\n    cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname));\n  }\n});\n\nconst upload = multer({ storage: storage });\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(express.static('public'));\n\napp.post('/post', upload.single('file'), (req, res) => {\n  res.json(req.body);\n});\n\napp.get('/post-get', (req, res) => {\n  const filePath = req.query.file;\n  res.redirect(filePath);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\n\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, 'uploads/');\n  },\n  filename: function (req, file, cb) {\n    cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname));\n  }\n});\n\nconst upload = multer({ storage: storage });\n\napp.use(express.static('public'));\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/post', upload.single('file'), (req, res) => {\n  res.json(req.body);\n});\n\napp.get('/post-get', (req, res) => {\n  const filePath = req.query.file;\n  res.redirect(filePath);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(multer({ dest: 'uploads/' }).array('file'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/post', (req, res) => {\n  res.json(req.body);\n});\n\napp.post('/post-get', (req, res) => {\n  const filePath = path.join(__dirname, 'public', req.body.file);\n  res.redirect(filePath);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(multer({ dest: 'uploads/' }).array('file'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/post', (req, res) => {\n  res.json(req.body);\n});\n\napp.post('/post-get', (req, res) => {\n  const filePath = path.join(__dirname, 'public', req.body.file);\n  res.redirect(filePath);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(multer({ dest: 'uploads/' }).array('file'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/post', (req, res) => {\n  res.json(req.body);\n});\n\napp.post('/post-get', (req, res) => {\n  const filePath = path.join(__dirname, 'public', req.body.file);\n  res.redirect(filePath);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\n\nconst storage = multer.diskStorage({\n  destination: function(req, file, cb) {\n    cb(null, 'uploads/');\n  },\n  filename: function(req, file, cb) {\n    cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname));\n  }\n});\n\nconst upload = multer({ storage: storage });\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(express.static('public'));\n\napp.post('/post', upload.single('file'), (req, res) => {\n  res.json(req.body);\n});\n\napp.get('/post-get', (req, res) => {\n  const filePath = req.query.file;\n  res.redirect(filePath);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(multer({ dest: 'uploads/' }).array('file'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/post', (req, res) => {\n  res.json(req.body);\n});\n\napp.get('/post-get', (req, res) => {\n  res.redirect(req.query.file);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(multer({ dest: 'uploads/' }).array('file'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/post', (req, res) => {\n  res.json(req.body);\n});\n\napp.post('/post-get', (req, res) => {\n  const filePath = path.join(__dirname, 'public', req.body.file);\n  res.redirect(filePath);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        body: method === 'POST' ? JSON.stringify(params) : null\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, response, body) => {\n      if (err) {\n        callback(err, null);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.headers.date;\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = new Date(serverTime).getTime() - localTime;\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        params: params\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, resp, body) => {\n      if (err) {\n        callback(err);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.meta.timestamp;\n    this._twitter_time_minus_local_time_ms = new Date(serverTime * 1000).getTime() - new Date().getTime();\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        form: params\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, resp, body) => {\n      if (err) {\n        callback(err, null);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.meta.timestamp;\n    const localTime = Date.now();\n    this._twitter_time_minus_local_time_ms = serverTime - localTime;\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        data: params\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, response, body) => {\n      if (err) {\n        callback(err, null);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.headers.date;\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = new Date(serverTime).getTime() - localTime;\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        body: method === 'POST' ? JSON.stringify(params) : null\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, response, body) => {\n      if (err) {\n        callback(err, null);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.headers.date;\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = new Date(serverTime).getTime() - localTime;\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        data: params\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, response, body) => {\n      if (err) {\n        callback(err, null);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.headers.date;\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = new Date(serverTime).getTime() - localTime;\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        body: method === 'POST' ? JSON.stringify(params) : null\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, response, body) => {\n      if (err) {\n        callback(err);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = new Date(resp.server_time).getTime();\n    this._twitter_time_minus_local_time_ms = serverTime - new Date().getTime();\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        params: params\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, response, body) => {\n      if (err) {\n        callback(err);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.headers.date;\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = new Date(serverTime).getTime() - localTime;\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        params: params\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, response, body) => {\n      if (err) {\n        callback(err);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.meta.timestamp;\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = serverTime - localTime;\n  }\n}\n```",
      "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      const reqOpts = {\n        url: `https://api.twitter.com/1.1/${path}.json`,\n        method: method,\n        headers: {\n          'Authorization': `Bearer ${this.config.bearer_token}`,\n          'Content-Type': 'application/json'\n        },\n        form: params\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          this._updateClockOffsetFromResponse(data);\n          resolve(data);\n        }\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const request = require('request');\n    request(reqOpts, (err, response, body) => {\n      if (err) {\n        callback(err, null);\n      } else {\n        try {\n          const data = JSON.parse(body);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = resp.headers.date;\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = new Date(serverTime).getTime() - localTime;\n  }\n}\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function to set up an HTTP server using Express.js that evaluates JavaScript expressions sent via POST requests and returns the results.\n\nFunction Description: The function `setupServer` initializes an Express.js server with middleware for JSON parsing and CORS. It listens on port 3948 and provides a POST endpoint at the root path ('/') that evaluates JavaScript expressions sent in the request body using Node.js's `vm` module. The server logs its startup information to the console.\n\nInput: None (The function takes no parameters; configuration is hardcoded.)\n\nOutput: None (The function doesn't return anything; it starts a server that continues running and handles incoming requests.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const bodyParser = require('body-parser');\n    const cors = require('cors');\n    const path = require('path');\n    const vm = require('vm');\n\n    const app = express();\n    app.use(bodyParser.json());\n    app.use(cors());\n    app.post('/', function (request, response) {\n        try {\n            response.json({result: vm.runInThisContext(request.body.expression)});\n        } catch (error) {\n            response.json(error);\n        }\n    });\n    app.listen(3948, 'localhost', function () {\n        console.log('Devtron server listening on http://localhost:3948');\n        console.log(`Open file://${path.join(__dirname, '..', 'static', 'index.html')} to view`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst cors = require('cors');\nconst { createServer } = require('http');\nconst { readFileSync } = require('fs');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  if (expression) {\n    try {\n      const context = { console, process, require };\n      const result = vm.runInNewContext(expression, context);\n      res.json({ result });\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(400).json({ error: 'No expression provided' });\n  }\n});\n\nconst server = createServer(app);\nserver.listen(3948, () => {\n  console.log('Server is running on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst { createServer } = require('http');\nconst { readFileSync } = require('fs');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  if (expression) {\n    try {\n      const context = { console, process, require };\n      const result = vm.runInNewContext(expression, context);\n      res.json({ result });\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(400).json({ error: 'No expression provided' });\n  }\n});\n\nconst server = createServer(app);\nserver.listen(3948, () => {\n  console.log('Server started on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst { createServer } = require('http');\nconst { readFileSync } = require('fs');\nconst vm = require('vm');\n\nconst app = express();\nconst server = createServer(app);\n\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  if (expression) {\n    try {\n      const sandbox = { console: console };\n      const result = vm.runInNewContext(expression, sandbox);\n      res.json({ result });\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(400).json({ error: 'No expression provided' });\n  }\n});\n\nserver.listen(3948, () => {\n  console.log('Server is running on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  if (expression) {\n    try {\n      const context = { console: console };\n      const result = vm.runInNewContext(expression, context);\n      res.json({ result });\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(400).json({ error: 'No expression provided' });\n  }\n});\n\napp.listen(3948, () => {\n  console.log('Server started on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst { createServer } = require('http');\nconst { readFileSync } = require('fs');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  if (expression) {\n    try {\n      const context = { console, process, require };\n      const result = vm.runInNewContext(expression, context);\n      res.json({ result });\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(400).json({ error: 'No expression provided' });\n  }\n});\n\nconst server = createServer(app);\nserver.listen(3948, () => {\n  console.log('Server started on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst { createServer } = require('http');\nconst { readFileSync } = require('fs');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  if (expression) {\n    try {\n      const result = vm.runInThisContext(expression);\n      res.json({ result });\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(400).json({ error: 'No expression provided' });\n  }\n});\n\nconst server = createServer(app);\nserver.listen(3948, () => {\n  console.log('Server started on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  if (expression) {\n    try {\n      const context = { console: console };\n      const result = vm.runInNewContext(expression, context);\n      res.json({ result });\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(400).json({ error: 'No expression provided' });\n  }\n});\n\napp.listen(3948, () => {\n  console.log('Server started on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst { createServer } = require('http');\nconst { readFileSync } = require('fs');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  try {\n    const context = {\n      console: {\n        log: console.log,\n        error: console.error\n      }\n    };\n    const result = vm.runInNewContext(expression, context);\n    res.json({ result });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\nconst server = createServer(app);\nserver.listen(3948, () => {\n  console.log('Server is running on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  if (expression) {\n    try {\n      const result = vm.runInThisContext(expression);\n      res.json({ result });\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(400).json({ error: 'No expression provided' });\n  }\n});\n\napp.listen(3948, () => {\n  console.log('Server started on port 3948');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst vm = require('vm');\n\nconst app = express();\napp.use(cors());\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const { expression } = req.body;\n  try {\n    const context = { console: console };\n    const result = vm.runInNewContext(expression, context);\n    res.json({ result });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.listen(3948, () => {\n  console.log('Server is running on port 3948');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a function to set up an Express server with Bottender integration for handling HTTP requests, including specific routes for sending an ID and serving a LIFF page.\n\nFunction Description: The function `setupServer` initializes an Express server with Bottender framework integration. It configures middleware for JSON body parsing, sets up route handlers for '/send-id' and '/liff' endpoints, and provides a catch-all handler for other routes. The server listens on a specified port (default 5000) and serves both API responses and static files.\n\nInput: None (The function uses environment variables: PORT for server port and LINE_LIFF_ID for the ID to be sent)\n\nOutput: None (The function starts an HTTP server that listens on the specified port and handles incoming requests)\n\nNote: The function requires the following npm packages to be installed: express, body-parser, path, bottender",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const bodyParser = require('body-parser');\n    const path = require('path');\n    const { bottender } = require('bottender');\n\n    const app = bottender({\n        dev: process.env.NODE_ENV !== 'production',\n    });\n\n    const port = Number(process.env.PORT) || 5000;\n    const handle = app.getRequestHandler();\n\n    app.prepare().then(() => {\n        const server = express();\n\n        server.use(\n            bodyParser.json({\n                verify: (req, _, buf) => {\n                    req.rawBody = buf.toString();\n                },\n            })\n        );\n\n        server.get('/send-id', (req, res) => {\n            res.json({ id: process.env.LINE_LIFF_ID });\n        });\n\n        server.get('/liff', (req, res) => {\n            const filename = path.join(`${__dirname}/liff.html`);\n            res.sendFile(filename);\n        });\n\n        server.all('*', (req, res) => {\n            return handle(req, res);\n        });\n\n        server.listen(port, (err) => {\n            if (err) throw err;\n            console.log(`> Ready on http://localhost:${port}`);\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = Bottender;\n\nconst app = express();\n\napp.use(bodyParser.json());\n\napp.get('/send-id', (req, res) => {\n  const lineId = process.env.LINE_LIFF_ID;\n  res.json({ lineId });\n});\n\napp.get('/liff', (req, res) => {\n  const lineId = process.env.LINE_LIFF_ID;\n  res.sendFile(path.join(__dirname, 'liff.html'), { root: __dirname });\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Not Found');\n});\n\nconst port = process.env.PORT || 5000;\n\ncreateServer(app).then(server => {\n  server.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = Bottender;\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/send-id', (req, res) => {\n  const { id } = req.body;\n  // Handle sending ID logic here\n  res.json({ message: 'ID received', id });\n});\n\napp.get('/liff', (req, res) => {\n  const lineLiffId = process.env.LINE_LIFF_ID;\n  // Handle serving LIFF page logic here\n  res.json({ lineLiffId });\n});\n\napp.use((req, res, next) => {\n  res.status(404).json({ message: 'Route not found' });\n});\n\nconst port = process.env.PORT || 5000;\n\ncreateServer(app).listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = require('http');\nconst { createWebhook } = require('bottender/express');\nconst { line } = require('bottender/line');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\nconst server = createServer(app);\n\nconst bottender = Bottender.create({\n  middleware: [line()],\n});\n\nconst { lineMiddleware } = bottender;\n\napp.post('/send-id', lineMiddleware, async (req, res) => {\n  const { userId } = req.body;\n  // Send ID logic here\n  res.json({ message: 'ID sent' });\n});\n\napp.get('/liff', lineMiddleware, async (req, res) => {\n  const { line } = req.query;\n  // Serve LIFF page logic here\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Not Found');\n});\n\nconst port = process.env.PORT || 5000;\nserver.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = Bottender;\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/send-id', (req, res) => {\n  const { id } = req.body;\n  // Handle the ID sending logic here\n  res.json({ message: 'ID received', id });\n});\n\napp.get('/liff', (req, res) => {\n  const lineLiffId = process.env.LINE_LIFF_ID;\n  // Handle the LIFF page serving logic here\n  res.json({ lineLiffId });\n});\n\napp.use((req, res, next) => {\n  res.status(404).json({ message: 'Route not found' });\n});\n\nconst port = process.env.PORT || 5000;\n\ncreateServer(app).listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = require('http');\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/send-id', Bottender.expressMiddleware());\napp.get('/liff', Bottender.expressMiddleware());\n\napp.use((req, res, next) => {\n  res.status(404).send('Not Found');\n});\n\nconst port = process.env.PORT || 5000;\nconst server = createServer(app).listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = Bottender;\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/send-id', async (req, res) => {\n  const { id } = req.body;\n  // Handle sending ID logic here\n  res.json({ message: 'ID received', id });\n});\n\napp.get('/liff', async (req, res) => {\n  const lineLiffId = process.env.LINE_LIFF_ID;\n  // Handle serving LIFF page logic here\n  res.json({ lineLiffId });\n});\n\napp.use((req, res, next) => {\n  res.status(404).json({ message: 'Route not found' });\n});\n\nconst port = process.env.PORT || 5000;\n\ncreateServer(app, {\n  plugins: [\n    Bottender.LinePlugin({\n      channelSecret: process.env.LINE_CHANNEL_SECRET,\n      channelToken: process.env.LINE_CHANNEL_TOKEN,\n    }),\n  ],\n}).listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = require('http');\nconst { createWebhook } = require('bottender/express');\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\nconst bottender = Bottender.create({\n  source: 'line',\n  config: {\n    channelSecret: process.env.CHANNEL_SECRET,\n    channelToken: process.env.CHANNEL_TOKEN,\n    channelUrl: process.env.CHANNEL_URL,\n  },\n});\n\napp.use('/send-id', bottender.middleware());\napp.use('/liff', bottender.middleware());\n\napp.get('/send-id', async (req, res) => {\n  const { lineUserId } = req.query;\n  if (lineUserId) {\n    res.send(`ID sent to ${lineUserId}`);\n  } else {\n    res.status(400).send('Line user ID is required');\n  }\n});\n\napp.get('/liff', async (req, res) => {\n  const { liffId } = req.query;\n  if (liffId) {\n    res.send(`LIFF page served for ${liffId}`);\n  } else {\n    res.status(400).send('LIFF ID is required');\n  }\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Not Found');\n});\n\nconst PORT = process.env.PORT || 5000;\nconst server = createServer(app).listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = require('http');\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.post('/send-id', async (req, res) => {\n  const { id } = req.body;\n  // Handle the ID sending logic here\n  res.json({ message: 'ID received', id });\n});\n\napp.get('/liff', async (req, res) => {\n  const lineLiffId = process.env.LINE_LIFF_ID;\n  // Handle the LIFF page serving logic here\n  res.json({ lineLiffId });\n});\n\napp.use((req, res, next) => {\n  res.status(404).json({ message: 'Route not found' });\n});\n\nconst port = process.env.PORT || 5000;\nconst server = createServer(app).listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});"
    ],
    "unmatched_results": [
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = require('http');\nconst { createWebhook } = require('bottender/express');\nconst { line } = require('bottender/line');\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\nconst server = createServer(app);\n\nconst bottender = Bottender.create({\n  src: path.join(__dirname, 'src'),\n  platforms: ['line'],\n});\n\nconst webhook = createWebhook(bottender);\n\napp.use('/send-id', webhook(line, async (req, res) => {\n  const { id } = req.body;\n  // Handle sending ID\n  res.json({ success: true });\n}));\n\napp.use('/liff', webhook(line, async (req, res) => {\n  const { line } = req.query;\n  // Handle serving LIFF page\n  res.json({ success: true });\n}));\n\napp.use((req, res, next) => {\n  res.status(404).json({ error: 'Not Found' });\n});\n\nconst port = process.env.PORT || 5000;\n\nserver.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst Bottender = require('bottender');\nconst { createServer } = require('http');\nconst { createWebhook } = require('bottender/express');\nconst { LINE } = require('bottender/line');\n\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\nconst bottender = Bottender.create({\n  type: 'line',\n  config: {\n    channelSecret: process.env.CHANNEL_SECRET,\n    channelToken: process.env.CHANNEL_TOKEN,\n    middleware: [async (ctx, next) => {\n      if (ctx.event && ctx.event.type === 'message' && ctx.event.message.type === 'text') {\n        await ctx.sendText('Hello, World!');\n      }\n      return next();\n    }],\n  },\n});\n\nconst server = createServer(app);\n\napp.use('/send-id', async (req, res) => {\n  const { id } = req.body;\n  const lineClient = bottender.createClient({ type: 'line' });\n  await lineClient.sendText(id, 'Hello from the server!');\n  res.status(200).send('Message sent');\n});\n\napp.use('/liff', async (req, res) => {\n  const { line } = req.query;\n  const lineClient = bottender.createClient({ type: 'line' });\n  await lineClient.sendText(line, 'Hello from the server!');\n  res.status(200).send('Message sent');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Not Found');\n});\n\nconst port = process.env.PORT || 5000;\nserver.listen(port, () => {\n  console.log(`Server is running on http://localhost:${port}`);\n});"
    ],
    "match_count": 8,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Create a function to set up an Express server with webpack middleware for development purposes, serving a single-page application.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures webpack development and hot-reload middleware, sets up a catch-all route to serve the main HTML file, and starts the server on localhost port 3000. This is typically used in development environments for frontend applications bundled with webpack.\n\nInput: None (The function doesn't take any explicit parameters, but assumes the existence of `compiler` and `config` variables in its scope, which would typically be webpack compiler instance and configuration object respectively)\n\nOutput: None (The function doesn't return anything but starts an HTTP server that listens on port 3000)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const app = express();\n    \n    app.use(require('webpack-dev-middleware')(compiler, {\n        noInfo: true,\n        publicPath: config.output.publicPath,\n    }));\n    \n    app.use(require('webpack-hot-middleware')(compiler));\n    \n    app.get('*', (req, res) => {\n        res.sendFile(path.join(__dirname, '../index.html'));\n    });\n    \n    app.listen(3000, 'localhost', (err) => {\n        if (err) {\n            console.log(err);\n            return;\n        }\n        console.log('Listening at http://localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst app = express();\n\nconst webpackConfig = compiler.config;\nconst webpackCompiler = webpack(webpackConfig);\n\napp.use(webpackMiddleware(webpackCompiler, {\n  publicPath: webpackConfig.output.publicPath,\n  hot: true\n}));\n\napp.use(webpackHotMiddleware(webpackCompiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/index.html');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst app = express();\n\napp.use(webpackMiddleware(compiler, {\n  hot: true,\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/public/index.html');\n});\n\napp.listen(3000);",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst app = express();\n\nconst webpackConfig = {\n  ...config,\n  mode: 'development',\n  devtool: 'eval-source-map',\n};\n\nconst webpackCompiler = webpack(webpackConfig);\n\napp.use(webpackMiddleware(webpackCompiler, {\n  publicPath: webpackConfig.output.publicPath,\n  hot: true,\n  historyApiFallback: true,\n}));\n\napp.use(webpackHotMiddleware(webpackCompiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/index.html');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config').default;\n\nconst app = express();\n\napp.use(webpackMiddleware(compiler, {\n  hot: true,\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/public/index.html');\n});\n\napp.listen(3000);",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config').default;\nconst app = express();\n\napp.use(webpackMiddleware(compiler, {\n  hot: true,\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/public/index.html');\n});\n\napp.listen(3000);",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst app = express();\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: config.devServer.contentBase,\n  hot: true,\n  historyApiFallback: true,\n});\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\napp.get('*', (req, res) => {\n  res.send(middleware.fileSystem.readFileSync('index.html'));\n});\napp.listen(3000);",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst app = express();\n\nconst config = {\n  port: 3000,\n  hot: true,\n  publicPath: '/',\n};\n\nconst webpackMiddlewareConfig = {\n  stats: 'errors-only',\n  publicPath: config.publicPath,\n  hot: config.hot,\n};\n\nconst compilerInstance = webpack(compiler);\napp.use(webpackMiddleware(compilerInstance, webpackMiddlewareConfig));\napp.use(webpackHotMiddleware(compilerInstance));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/public/index.html');\n});\n\napp.listen(config.port, () => {\n  console.log(`Server is running on http://localhost:${config.port}`);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config').default;\nconst app = express();\n\napp.use(webpackMiddleware(compiler, {\n  hot: true,\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/public/index.html');\n});\n\napp.listen(3000);",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config').default;\nconst app = express();\n\napp.use(webpackMiddleware(compiler, {\n  hot: true,\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/index.html');\n});\n\napp.listen(3000);",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config').default;\nconst app = express();\n\napp.use(webpackMiddleware(compiler, {\n  hot: true,\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(__dirname + '/public/index.html');\n});\n\napp.listen(3000, () => {\n  console.log('Listening on port 3000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a function that sets up an Express server with session management and WebSocket capabilities using Primus, and handles basic routing.\n\nFunction Description: The function `setupExpressServer` initializes an Express application with session management using `express-session` and `cookie-parser`, sets up a basic route, and integrates Primus for WebSocket communication. It also includes session handling for WebSocket connections.\n\nInput: None (This function does not take any input parameters.)\n\nOutput: None (This function does not return any value but starts an HTTP server listening on port 8080 and logs a message to the console.)",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var expressSession = require('express-session');\n    var cookieParser = require('cookie-parser');\n    var http = require('http');\n    var Primus = require('../..');\n    var primusSession = require('./session');\n\n    var app = express();\n    var secret = 'shhhh, very secret';\n    var cookies = cookieParser(secret);\n    var store = new expressSession.MemoryStore();\n\n    app.use(cookies);\n    app.use(expressSession({\n        saveUninitialized: true,\n        secret: secret,\n        resave: true,\n        store: store\n    }));\n\n    app.get('/', function index(req, res) {\n        req.session.timestamp = Date.now();\n        res.sendFile(__dirname + '/index.html');\n    });\n\n    var server = http.createServer(app);\n    var primus = new Primus(server);\n\n    primus.use('cookies', cookies);\n    primus.use('session', primusSession, { store: store });\n\n    primus.on('connection', function connection(spark) {\n        spark.write(JSON.stringify(spark.request.session, null, '  '));\n    });\n\n    server.listen(8080, function listening() {\n        console.log('Open http://localhost:8080 in your browser');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log('Received data:', data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log(data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log('Received data:', data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log('Received data:', data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log(data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n```",
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log('Received data:', data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log('Received data:', data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log('Received data:', data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log(data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
      "const express = require('express');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst http = require('http');\nconst Primus = require('primus');\nconst app = express();\nconst server = http.createServer(app);\nconst primus = new Primus(server);\n\napp.use(cookieParser());\napp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true }));\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nprimus.on('connection', function (spark) {\n  spark.on('data', function (data) {\n    console.log('Received data:', data);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a function to start an Express server that serves static files and handles client requests.\n\nFunction Description: The function `startServer` initializes an Express application, configures middleware for compression and static file serving, sets up a catch-all route to serve the main HTML file, and starts the server on a specified port.\n\nInput: None\n\nOutput: None (The function starts a server that listens on the specified port and logs the server status to the console.)",
    "Canonical_solution": "function startServer() {\n    var express = require('express');\n    var path = require('path');\n    var compression = require('compression');\n\n    var app = express();\n\n    app.use(compression());\n    app.use(express.static(path.join(__dirname, 'public')));\n\n    app.get('*', function (req, res) {\n        res.sendFile(path.join(__dirname, 'public', 'index.html'));\n    });\n\n    var PORT = process.env.PORT || 8080;\n    app.listen(PORT, function() {\n        console.log('Production Express server running at localhost:' + PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\n\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\nconst app = express();\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\napp.listen(process.env.PORT || 3000, () => {\n  console.log(`Server is running on http://localhost:${process.env.PORT || 3000}`);\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\n\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});",
      "const express = require('express');\nconst compression = require('compression');\nconst path = require('path');\nconst app = express();\n\napp.use(compression());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function to set up an Express server that connects to a PostgreSQL database and provides an endpoint to retrieve employee data.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, establishes a connection pool to a PostgreSQL database, and defines a GET endpoint '/employees' that queries employee data from the database. It measures the query execution time and returns the results along with the elapsed time.\n\nInput: None (The function takes no parameters as all configuration is hardcoded within the function)\n\nOutput: None (The function doesn't return anything but starts an Express server listening on port 2015 and provides an endpoint that sends JSON responses)",
    "Canonical_solution": "function setupExpressServer() {\n    const app = require(\"express\")();\n    const {Pool} = require(\"pg\");\n\n    const pool = new Pool({\n        \"host\": \"husseinmac.local\",\n        \"port\": 5432,\n        \"user\":\"postgres\",\n        \"password\" : \"postgres\",\n        \"database\" : \"husseindb\",\n        \"max\": 20,\n        \"connectionTimeoutMillis\" : 0,\n        \"idleTimeoutMillis\": 0\n    });\n\n    app.get(\"/employees\", async (req, res) => {\n        const fromDate = new Date();\n        const results = await pool.query(\"select employeeid eid,firstname,ssn from employees\");\n        console.table(results.rows);\n        console.log(new Date());\n        const toDate = new Date();\n        const elapsed = toDate.getTime() - fromDate.getTime();\n        res.send({\"rows\": results.rows, \"elapsed\": elapsed, \"method\": \"pool\"});\n    });\n\n    app.listen(2015, () => console.log(\"Listening on port 2015\"));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const end = Date.now();\n    const elapsedTime = end - start;\n    res.json({ data: rows, time: elapsedTime });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const end = Date.now();\n    res.json({ data: rows, time: end - start });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst Pool = require('pg').Pool;\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const client = await pool.connect();\n    const query = 'SELECT * FROM employees';\n    const result = await client.query(query);\n    const end = Date.now();\n    res.json({ data: result.rows, time: end - start });\n    client.release();\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(err);\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const end = Date.now();\n    res.json({ data: rows, time: end - start });\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const end = Date.now();\n    const elapsed = end - start;\n    res.json({ data: rows, elapsed });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const end = Date.now();\n    res.json({ data: rows, time: end - start });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const elapsed = Date.now() - start;\n    res.json({ data: rows, time: elapsed });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const end = Date.now();\n    const timeElapsed = end - start;\n    res.json({ data: rows, timeElapsed });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const end = Date.now();\n    const timeElapsed = end - start;\n    res.json({ data: rows, timeElapsed });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\nconst port = 2015;\n\nconst pool = new Pool({\n  user: 'your_username',\n  host: 'localhost',\n  database: 'your_database',\n  password: 'your_password',\n  port: 5432,\n});\n\napp.get('/employees', async (req, res) => {\n  const start = Date.now();\n  try {\n    const { rows } = await pool.query('SELECT * FROM employees');\n    const end = Date.now();\n    const elapsedTime = end - start;\n    res.json({ data: rows, elapsedTime });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a function that sets up an Express server with CORS support, static file serving, and specific route handlers.\n\nFunction Description: The function `createServer` initializes an Express application, configures middleware for CORS and static file serving, defines route handlers for specific endpoints, and starts the server on port 80. It enables cross-origin requests, serves static files from a 'public' directory, and provides fallback to 'index.html' for unmatched routes.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function does not return a value but starts an Express server listening on port 80)",
    "Canonical_solution": "function createServer() {\n    const express = require('express');\n    const app = express();\n\n    app.use(function(req, res, next) {\n        res.set({\n            'Access-Control-Allow-Origin': '*'\n        });\n        next();\n    });\n    app.use(express.static(__dirname + '/public'));\n\n    app.get('/imagebox', imagebox.upload);\n    app.get('/readapi', api.requestApi);\n    app.get('*', (req, res) => {\n        res.sendFile(__dirname + '/public/index.html');\n    });\n\n    app.listen(80, () => {\n        console.log('app is listening at port:80');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.listen(80, () => {\n  console.log('Server is running on port 80');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.listen(80, () => {\n  console.log('Server is running on port 80');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.listen(80, () => {\n  console.log('Server is running on port 80');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.listen(80, () => {\n  console.log('Server is running on port 80');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.listen(80, () => {\n  console.log('Server is running on port 80');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.listen(80);",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Data endpoint' });\n});\n\napp.get('/api/another', (req, res) => {\n  res.json({ message: 'Another endpoint' });\n});\n\napp.listen(80);",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Data endpoint' });\n});\n\napp.listen(80);",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Data endpoint' });\n});\n\napp.listen(80, () => {\n  console.log('Server is running on port 80');\n});",
      "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use((req, res, next) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'), err => {\n    if (err) {\n      next(err);\n    }\n  });\n});\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.listen(80, () => {\n  console.log('Server is running on port 80');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a function to start an Express server with webpack middleware for development purposes, serving an HTML file as the main entry point.\n\nFunction Description: The function initializes an Express application, configures webpack middleware for development (including hot module replacement), sets up a catch-all route to serve the main HTML file, and starts the server on a specified port. It includes error handling for server startup.\n\nInput: None (The function doesn't take any parameters as input)\n\nOutput: None (The function doesn't return any value but starts a server process and logs messages to the console)",
    "Canonical_solution": "function startServer() {\n    var app = new (require('express'))();\n    var port = 3000;\n    \n    app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }));\n    app.use(webpackHotMiddleware(compiler));\n    \n    app.use(function(req, res) {\n        res.sendFile(__dirname + '/index.html');\n    });\n    \n    app.listen(port, function(error) {\n        if (error) {\n            console.error(error);\n        } else {\n            console.info(\"==> ðŸŒŽ  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack({\n  mode: 'development',\n  entry: path.resolve(__dirname, 'src/index.html'),\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n          },\n        ],\n      },\n    ],\n  },\n});\n\nconst devMiddleware = webpackDevMiddleware(compiler, {\n  publicPath: '/',\n  stats: {\n    colors: true,\n  },\n});\n\nconst hotMiddleware = webpackHotMiddleware(compiler);\n\napp.use(devMiddleware);\napp.use(hotMiddleware);\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist/index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n\napp.on('error', (err) => {\n  console.error('Error starting server:', err);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst config = require('./webpack.config');\n\nconst compiler = webpack(config);\n\napp.use(webpackDevMiddleware(compiler, {\n  noInfo: true,\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log('Server is running on http://localhost:3000');\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack({\n  mode: 'development',\n  entry: path.resolve(__dirname, 'src/index.html'),\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n          },\n        ],\n      },\n    ],\n  },\n});\n\nconst devMiddleware = webpackDevMiddleware(compiler, {\n  publicPath: '/',\n});\n\nconst hotMiddleware = webpackHotMiddleware(compiler);\n\napp.use(devMiddleware);\napp.use(hotMiddleware);\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist/index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n\napp.on('error', (err) => {\n  console.error('Error starting server:', err);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack({\n  mode: 'development',\n  entry: path.resolve(__dirname, 'src/index.html'),\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n          },\n        ],\n      },\n    ],\n  },\n});\n\nconst devMiddleware = webpackDevMiddleware(compiler, {\n  publicPath: '/',\n});\n\nconst hotMiddleware = webpackHotMiddleware(compiler);\n\napp.use(devMiddleware);\napp.use(hotMiddleware);\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist/index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n\napp.on('error', (err) => {\n  console.error('Error starting server:', err);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\nconst compiler = webpack({\n  mode: 'development',\n  entry: path.resolve(__dirname, 'src/index.html'),\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n          },\n        ],\n      },\n    ],\n  },\n});\n\nconst devMiddleware = webpackDevMiddleware(compiler, {\n  publicPath: '/',\n});\n\nconst hotMiddleware = webpackHotMiddleware(compiler);\n\napp.use(devMiddleware);\napp.use(hotMiddleware);\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist/index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n}).on('error', (err) => {\n  console.error('Error starting server:', err);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack({\n  mode: 'development',\n  entry: path.resolve(__dirname, 'src/index.html'),\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n          },\n        ],\n      },\n    ],\n  },\n});\n\nconst devMiddleware = webpackDevMiddleware(compiler, {\n  publicPath: '/',\n});\n\nconst hotMiddleware = webpackHotMiddleware(compiler);\n\napp.use(devMiddleware);\napp.use(hotMiddleware);\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist', 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n\napp.on('error', (err) => {\n  console.error('Error starting server:', err);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack({\n  mode: 'development',\n  entry: path.resolve(__dirname, 'src/index.html'),\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n          },\n        ],\n      },\n    ],\n  },\n});\n\nconst devMiddleware = webpackDevMiddleware(compiler, {\n  publicPath: '/',\n});\n\nconst hotMiddleware = webpackHotMiddleware(compiler);\n\napp.use(devMiddleware);\napp.use(hotMiddleware);\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist/index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n\napp.on('error', (err) => {\n  console.error('Error starting server:', err);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack({\n  entry: path.resolve(__dirname, 'src/index.html'),\n  mode: 'development',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n          },\n        ],\n      },\n    ],\n  },\n});\n\nconst devMiddleware = webpackDevMiddleware(compiler, {\n  publicPath: '/',\n});\n\nconst hotMiddleware = webpackHotMiddleware(compiler);\n\napp.use(devMiddleware);\napp.use(hotMiddleware);\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist/index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n\napp.on('error', (err) => {\n  console.error('Error starting server:', err);\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack({\n  mode: 'development',\n  entry: path.resolve(__dirname, 'src/index.html'),\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n          },\n        ],\n      },\n    ],\n  },\n});\n\nconst devMiddleware = webpackDevMiddleware(compiler, {\n  publicPath: '/',\n});\n\nconst hotMiddleware = webpackHotMiddleware(compiler);\n\napp.use(devMiddleware);\napp.use(hotMiddleware);\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'dist', 'index.html'));\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst config = require('./webpack.config');\n\nconst compiler = webpack(config);\n\napp.use(webpackDevMiddleware(compiler, {\n  noInfo: true,\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(3000, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log('Server is running on http://localhost:3000');\n  }\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Create a class that implements a simple HTTP server using Express.js framework to provide a FOAAS (F*** Off As A Service) style API, which generates humorous responses to HTTP requests.\n\nClass Description: The FOAAS class creates an Express application that handles various HTTP requests and returns humorous responses in a standardized format. It includes middleware configuration, route handling, and server management capabilities.\n\nAttributes:\n- app: [Object] - The Express application instance\n- operations: [Object] - A dictionary storing available API operations\n- operationsArray: [Array] - An array containing information about available operations\n\nMethods:\n- constructor(options) -> [void] - Initializes the Express application, configures middleware, and sets up default routes\n  - options: [Object] - Configuration options for the application (currently unused in reference implementation)\n  \n- sendIndex(req, res) -> [void] - Sends the index.html file as response\n  - req: [Object] - Express request object\n  - res: [Object] - Express response object\n  \n- start(port) -> [void] - Starts the HTTP server on the specified port and performs initialization checks\n  - port: [Number] - The port number to listen on\n  \n- output(req, res, message, subtitle) -> [void] - Formats and sends the response message\n  - req: [Object] - Express request object\n  - res: [Object] - Express response object\n  - message: [String] - The main response message\n  - subtitle: [String] - The secondary response message (typically containing the requester's name)",
    "Canonical_solution": "const express = require('express');\nconst request = require('request');\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.app.disable('x-powered-by');\n    \n    // Standard Middleware\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n    \n    // Operations\n    this.operations = {};\n    this.operationsArray = [];\n    \n    // Define routes\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/operations', (req, res) => {\n      res.send(this.operationsArray);\n    });\n    \n    // Default Operation\n    this.app.get('/:thing/:from', (req, res) => {\n      const message = `Fuck ${req.params.thing}.`;\n      const subtitle = `- ${req.params.from}`;\n      this.output(req, res, message, subtitle);\n    });\n  }\n\n  sendIndex(req, res) {\n    res.sendFile('./public/index.html');\n  }\n\n  start(port) {\n    this.app.listen(port);\n    console.log(`FOAAS Started on port ${port}`);\n    \n    request(`http://localhost:${port}/operations`, (error, response, body) => {\n      if (error) return console.log('Could not retrieve operations');\n      const ops = JSON.parse(body);\n      \n      ops.forEach((op) => {\n        request({\n          url: `http://localhost:${port}${op.url}`,\n          headers: { Accept: 'text/plain' }\n        }, (error, response, body) => {\n          if (error) return console.log('Could not retrieve operation ' + op.url);\n        });\n      });\n    });\n  }\n\n  output(req, res, message, subtitle) {\n    req.message = message;\n    req.subtitle = subtitle;\n    \n    // Process output\n    res.send(`${message} ${subtitle}`);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'f***off': 'F*** off!',\n      'shutup': 'Shut up!',\n      'screwyou': 'Screw you!'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/:operation', this.handleOperation.bind(this));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(path.join(__dirname, 'public', 'index.html'));\n  }\n\n  handleOperation(req, res) {\n    const operation = req.params.operation;\n    if (this.operations[operation]) {\n      this.output(res, this.operations[operation], `from ${req.query.name}`);\n    } else {\n      this.output(res, 'Invalid operation', '');\n    }\n  }\n\n  output(res, message, subtitle) {\n    res.send(`<h1>${message}</h1><p>${subtitle}</p>`);\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`FOAAS server running on port ${port}`);\n    });\n  }\n}",
      "```javascript\nconst express = require('express');\nconst app = express();\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'off': 'F*** off',\n      'as': 'As a service',\n      'service': 'Service',\n      'you': 'You',\n      'me': 'Me',\n      'they': 'They',\n      'us': 'Us',\n      'them': 'Them',\n      'yourself': 'Yourself',\n      'myself': 'Myself',\n      'himself': 'Himself',\n      'herself': 'Herself',\n      'itself': 'Itself',\n      'ourselves': 'Ourselves',\n      'yourselves': 'Yourselves',\n      'themselves': 'Themselves',\n      'your': 'Your',\n      'my': 'My',\n      'his': 'His',\n      'her': 'Her',\n      'its': 'Its',\n      'their': 'Their',\n      'theirs': 'Theirs',\n      'this': 'This',\n      'that': 'That',\n      'these': 'These',\n      'those': 'Those',\n      'am': 'Am',\n      'is': 'Is',\n      'are': 'Are',\n      'was': 'Was',\n      'were': 'Were',\n      'be': 'Be',\n      'been': 'Been',\n      'being': 'Being',\n      'have': 'Have',\n      'has': 'Has',\n      'had': 'Had',\n      'having': 'Having',\n      'do': 'Do',\n      'does': 'Does',\n      'did': 'Did',\n      'doing': 'Doing',\n      'a': 'A',\n      'an': 'An',\n      'the': 'The',\n      'and': 'And',\n      'but': 'But',\n      'if': 'If',\n      'or': 'Or',\n      'because': 'Because',\n      'as': 'As',\n      'until': 'Until',\n      'while': 'While',\n      'of': 'Of',\n      'at': 'At',\n      'by': 'By',\n      'for': 'For',\n      'with': 'With',\n      'about': 'About',\n      'against': 'Against',\n      'between': 'Between',\n      'into': 'Into',\n      'through': 'Through',\n      'during': 'During',\n      'before': 'Before',\n      'after': 'After',\n      'above': 'Above',\n      'below': 'Below',\n      'to': 'To',\n      'from': 'From',\n      'up': 'Up',\n      'down': 'Down',\n      'in': 'In',\n      'out': 'Out',\n      'on': 'On',\n      'off': 'Off',\n      'over': 'Over',\n      'under': 'Under',\n      'again': 'Again',\n      'further': 'Further',\n      'then': 'Then',\n      'once': 'Once',\n      'here': 'Here',\n      'there': 'There',\n      'when': 'When',\n      'where': 'Where',\n      'why': 'Why',\n      'how': 'How',\n      'all': 'All',\n      'any': 'Any',\n      'both': 'Both',\n      'each': 'Each',\n      'few': 'Few',\n      'more': 'More',\n      'most': 'Most',\n      'other': 'Other',\n      'some': 'Some',\n      'such': 'Such',\n      'no': 'No',\n      'nor': 'Nor',\n      'not': 'Not',\n      'only': 'Only',\n      'own': 'Own',\n      'same': 'Same',\n      'so': 'So',\n      'than': 'Than',\n      'too': 'Too',\n      'very': 'Very',\n      's': 'S',\n      't': 'T',\n      'can': 'Can',\n      'will': 'Will',\n      'just': 'Just',\n      'don': 'Don',\n      'should': 'Should',\n      'now': 'Now'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static('public'));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/foaas/:operation', this.handleFOAAS.bind(this));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(__dirname + '/public/index.html');\n  }\n\n  handleFOAAS(req, res) {\n    const operation = req.params.operation;\n    if (this.operations[operation]) {\n      const message = this.operations[operation];\n      const subtitle = `FOAAS ${operation}`;\n      this.output(req, res, message, subtitle);\n    } else {\n      this.output(req, res, 'Invalid operation', '');\n    }\n  }\n\n  output(req, res, message, subtitle) {\n    res.send(`<h1>${message}</h1><p>${subtitle}</p>`);\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`FOAAS server listening at http://localhost:${port}`);\n    });\n  }\n}\n\nmodule.exports = FOAAS;\n```",
      "```javascript\nconst express = require('express');\nconst app = express();\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'off': 'F*** off',\n      'as': 'As a service'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static('public'));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/off', (req, res) => this.output(req, res, this.operations['off'], ''));\n    this.app.get('/as', (req, res) => this.output(req, res, this.operations['as'], ''));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(__dirname + '/public/index.html');\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`FOAAS server running on port ${port}`);\n    });\n  }\n\n  output(req, res, message, subtitle) {\n    res.send(`<h1>${message}</h1><p>${subtitle}</p>`);\n  }\n}\n\nmodule.exports = FOAAS;\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'off': 'F*** Off',\n      'as': 'As A Service'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/off', (req, res) => this.output(req, res, this.operations['off'], ''));\n    this.app.get('/as', (req, res) => this.output(req, res, this.operations['as'], ''));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(path.join(__dirname, 'public', 'index.html'));\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`Server running on port ${port}`);\n    });\n  }\n\n  output(req, res, message, subtitle) {\n    res.send(`<h1>${message}</h1><p>${subtitle}</p>`);\n  }\n}\n\nmodule.exports = FOAAS;\n```",
      "```javascript\nconst express = require('express');\nconst app = express();\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'off': 'F*** off',\n      'as': 'As a service'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static('public'));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/off', (req, res) => this.output(req, res, this.operations['off'], ''));\n    this.app.get('/as', (req, res) => this.output(req, res, this.operations['as'], ''));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(__dirname + '/public/index.html');\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`FOAAS server listening at http://localhost:${port}`);\n    });\n  }\n\n  output(req, res, message, subtitle) {\n    res.send(`<html><head><title>FOAAS</title></head><body><h1>${message}</h1><p>${subtitle}</p></body></html>`);\n  }\n}\n\nmodule.exports = FOAAS;\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'off': 'F*** off',\n      'as': 'As a service',\n      'service': 'Service',\n      'you': 'You',\n      'me': 'Me',\n      'they': 'They',\n      'us': 'Us',\n      'them': 'Them',\n      'yourself': 'Yourself',\n      'myself': 'Myself',\n      'ourselves': 'Ourselves',\n      'themselves': 'Themselves',\n      'himself': 'Himself',\n      'herself': 'Herself',\n      'itself': 'Itself',\n      'him': 'Him',\n      'her': 'Her',\n      'it': 'It',\n      'we': 'We',\n      'they': 'They',\n      'i': 'I',\n      'you': 'You',\n      'he': 'He',\n      'she': 'She',\n      'they': 'They',\n      'am': 'Am',\n      'is': 'Is',\n      'are': 'Are',\n      'was': 'Was',\n      'were': 'Were',\n      'be': 'Be',\n      'been': 'Been',\n      'being': 'Being',\n      'have': 'Have',\n      'has': 'Has',\n      'had': 'Had',\n      'having': 'Having',\n      'do': 'Do',\n      'does': 'Does',\n      'did': 'Did',\n      'doing': 'Doing',\n      'a': 'A',\n      'an': 'An',\n      'the': 'The',\n      'and': 'And',\n      'but': 'But',\n      'if': 'If',\n      'or': 'Or',\n      'because': 'Because',\n      'as': 'As',\n      'until': 'Until',\n      'while': 'While',\n      'of': 'Of',\n      'at': 'At',\n      'by': 'By',\n      'for': 'For',\n      'with': 'With',\n      'about': 'About',\n      'against': 'Against',\n      'between': 'Between',\n      'into': 'Into',\n      'through': 'Through',\n      'during': 'During',\n      'before': 'Before',\n      'after': 'After',\n      'above': 'Above',\n      'below': 'Below',\n      'to': 'To',\n      'from': 'From',\n      'up': 'Up',\n      'down': 'Down',\n      'in': 'In',\n      'out': 'Out',\n      'on': 'On',\n      'off': 'Off',\n      'over': 'Over',\n      'under': 'Under',\n      'again': 'Again',\n      'further': 'Further',\n      'then': 'Then',\n      'once': 'Once',\n      'here': 'Here',\n      'there': 'There',\n      'when': 'When',\n      'where': 'Where',\n      'why': 'Why',\n      'how': 'How',\n      'all': 'All',\n      'any': 'Any',\n      'both': 'Both',\n      'each': 'Each',\n      'few': 'Few',\n      'more': 'More',\n      'most': 'Most',\n      'other': 'Other',\n      'some': 'Some',\n      'such': 'Such',\n      'no': 'No',\n      'nor': 'Nor',\n      'not': 'Not',\n      'only': 'Only',\n      'own': 'Own',\n      'same': 'Same',\n      'so': 'So',\n      'than': 'Than',\n      'too': 'Too',\n      'very': 'Very',\n      's': 'S',\n      't': 'T',\n      'can': 'Can',\n      'will': 'Will',\n      'just': 'Just',\n      'don': 'Don',\n      'should': 'Should',\n      'now': 'Now'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/foaas/:operation', this.handleFOAAS.bind(this));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(path.join(__dirname, 'public', 'index.html'));\n  }\n\n  handleFOAAS(req, res) {\n    const operation = req.params.operation;\n    if (this.operations[operation]) {\n      const message = this.operations[operation];\n      const subtitle = `FOAAS ${operation}`;\n      this.output(req, res, message, subtitle);\n    } else {\n      this.output(req, res, 'Invalid operation', '');\n    }\n  }\n\n  output(req, res, message, subtitle) {\n    res.status(200).send(`\n      <!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>FOAAS</title>\n      </head>\n      <body>\n        <h1>${message}</h1>\n        <p>${subtitle}</p>\n      </body>\n      </html>\n    `);\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`FOAAS server listening at http://localhost:${port}`);\n    });\n  }\n}\n\nmodule.exports = FOAAS;\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'off': 'F*** off',\n      'as': 'As a service',\n      'service': 'Service',\n      'you': 'You',\n      'me': 'Me',\n      'they': 'They',\n      'us': 'Us',\n      'them': 'Them',\n      'yourself': 'Yourself',\n      'myself': 'Myself',\n      'ourselves': 'Ourselves',\n      'themselves': 'Themselves',\n      'himself': 'Himself',\n      'herself': 'Herself',\n      'itself': 'Itself',\n      'him': 'Him',\n      'her': 'Her',\n      'it': 'It',\n      'we': 'We',\n      'they': 'They',\n      'i': 'I',\n      'you': 'You',\n      'he': 'He',\n      'she': 'She',\n      'they': 'They',\n      'am': 'Am',\n      'is': 'Is',\n      'are': 'Are',\n      'was': 'Was',\n      'were': 'Were',\n      'be': 'Be',\n      'been': 'Been',\n      'being': 'Being',\n      'have': 'Have',\n      'has': 'Has',\n      'had': 'Had',\n      'having': 'Having',\n      'do': 'Do',\n      'does': 'Does',\n      'did': 'Did',\n      'doing': 'Doing',\n      'a': 'A',\n      'an': 'An',\n      'the': 'The',\n      'and': 'And',\n      'but': 'But',\n      'or': 'Or',\n      'because': 'Because',\n      'as': 'As',\n      'until': 'Until',\n      'while': 'While',\n      'of': 'Of',\n      'at': 'At',\n      'by': 'By',\n      'for': 'For',\n      'with': 'With',\n      'about': 'About',\n      'against': 'Against',\n      'between': 'Between',\n      'into': 'Into',\n      'through': 'Through',\n      'during': 'During',\n      'before': 'Before',\n      'after': 'After',\n      'above': 'Above',\n      'below': 'Below',\n      'to': 'To',\n      'from': 'From',\n      'up': 'Up',\n      'down': 'Down',\n      'in': 'In',\n      'out': 'Out',\n      'on': 'On',\n      'off': 'Off',\n      'over': 'Over',\n      'under': 'Under',\n      'again': 'Again',\n      'further': 'Further',\n      'then': 'Then',\n      'once': 'Once',\n      'here': 'Here',\n      'there': 'There',\n      'when': 'When',\n      'where': 'Where',\n      'why': 'Why',\n      'how': 'How',\n      'all': 'All',\n      'any': 'Any',\n      'both': 'Both',\n      'each': 'Each',\n      'few': 'Few',\n      'more': 'More',\n      'most': 'Most',\n      'other': 'Other',\n      'some': 'Some',\n      'such': 'Such',\n      'no': 'No',\n      'nor': 'Nor',\n      'not': 'Not',\n      'only': 'Only',\n      'own': 'Own',\n      'same': 'Same',\n      'so': 'So',\n      'than': 'Than',\n      'too': 'Too',\n      'very': 'Very',\n      's': 'S',\n      't': 'T',\n      'can': 'Can',\n      'will': 'Will',\n      'just': 'Just',\n      'don': 'Don',\n      'should': 'Should',\n      'now': 'Now'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static(path.join(__dirname, 'public')));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/foaas/:operation', this.handleFOAAS.bind(this));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(path.join(__dirname, 'public', 'index.html'));\n  }\n\n  handleFOAAS(req, res) {\n    const operation = req.params.operation;\n    if (this.operations[operation]) {\n      const message = this.operations[operation];\n      const subtitle = `FOAAS ${operation}`;\n      this.output(req, res, message, subtitle);\n    } else {\n      this.output(req, res, 'Invalid operation', '');\n    }\n  }\n\n  output(req, res, message, subtitle) {\n    res.send(`<h1>${message}</h1><p>${subtitle}</p>`);\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`FOAAS server listening at http://localhost:${port}`);\n    });\n  }\n}\n\nmodule.exports = FOAAS;\n```",
      "```javascript\nconst express = require('express');\nconst app = express();\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'f***off': 'F*** off!',\n      'screwyou': 'Screw you!',\n      'goaway': 'Go away!',\n      'leave': 'Leave me alone!'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static('public'));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/foaas/:operation', this.handleOperation.bind(this));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(__dirname + '/public/index.html');\n  }\n\n  handleOperation(req, res) {\n    const operation = req.params.operation;\n    if (this.operations[operation]) {\n      this.output(res, this.operations[operation], `${req.query.name}!`);\n    } else {\n      this.output(res, 'Operation not found', '');\n    }\n  }\n\n  output(res, message, subtitle) {\n    res.send(`<html><head><title>FOAAS</title></head><body><h1>${message}</h1><p>${subtitle}</p></body></html>`);\n  }\n\n  start(port) {\n    if (port) {\n      this.app.listen(port, () => {\n        console.log(`Server running on port ${port}`);\n      });\n    } else {\n      this.app.listen(3000, () => {\n        console.log(`Server running on port 3000`);\n      });\n    }\n  }\n}\n\nmodule.exports = FOAAS;\n```",
      "```javascript\nconst express = require('express');\nconst app = express();\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'off': 'F*** off',\n      'as': 'As a service'\n    };\n    this.operationsArray = Object.keys(this.operations);\n    this.app.use(express.static('public'));\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/off', (req, res) => this.output(req, res, this.operations['off'], ''));\n    this.app.get('/as', (req, res) => this.output(req, res, this.operations['as'], ''));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(__dirname + '/public/index.html');\n  }\n\n  start(port) {\n    if (!this.app.listening) {\n      this.app.listen(port, () => {\n        console.log(`FOAAS server listening on port ${port}`);\n      });\n    } else {\n      console.log('FOAAS server is already running.');\n    }\n  }\n\n  output(req, res, message, subtitle) {\n    res.send(`<html><head><title>FOAAS</title></head><body><h1>${message}</h1><p>${subtitle}</p></body></html>`);\n  }\n}\n\nmodule.exports = FOAAS;\n```"
    ],
    "unmatched_results": [
      "const express = require('express');\nconst path = require('path');\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.operations = {\n      'f***off': 'F*** off!',\n      'screwyou': 'Screw you!',\n      'goaway': 'Go away!',\n      'bugoff': 'Bug off!',\n      'leave': 'Leave!',\n      'shutup': 'Shut up!',\n      'stop': 'Stop!',\n      'quit': 'Quit!',\n      'f***offanddie': 'F*** off and die!',\n      'f***offandgo': 'F*** off and go!',\n      'f***offandleave': 'F*** off and leave!',\n      'f***offandstop': 'F*** off and stop!',\n      'f***offandquit': 'F*** off and quit!',\n      'f***offandbugoff': 'F*** off and bug off!',\n      'f***offandleavealone': 'F*** off and leave alone!',\n      'f***offandshutup': 'F*** off and shut up!',\n      'f***offandstopit': 'F*** off and stop it!',\n      'f***offandquitnow': 'F*** off and quit now!'\n    };\n    this.operationsArray = Object.keys(this.operations);\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(path.join(__dirname, 'index.html'));\n  }\n\n  start(port) {\n    this.app.get('/', (req, res) => {\n      this.sendIndex(req, res);\n    });\n\n    this.app.get('/:operation', (req, res) => {\n      const { operation } = req.params;\n      const message = this.operations[operation] || 'Operation not found!';\n      const subtitle = `Requested by ${req.query.name || 'Unknown'}`;\n      this.output(req, res, message, subtitle);\n    });\n\n    this.app.listen(port, () => {\n      console.log(`FOAAS server listening at http://localhost:${port}`);\n    });\n  }\n\n  output(req, res, message, subtitle) {\n    res.send(`\n      <!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>FOAAS</title>\n      </head>\n      <body>\n        <h1>${message}</h1>\n        <p>${subtitle}</p>\n      </body>\n      </html>\n    `);\n  }\n}"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a function that initializes and starts an Express.js HTTP server with REST API capabilities, static file serving, and error handling.\n\nFunction Description: The function `startServer` creates and configures an Express.js application, sets up middleware for static file serving and request body parsing, configures REST API routes with error handling, and starts the HTTP server on a specified port. The server handles both regular web traffic and API requests through virtual hosting.\n\nInput: None (uses environment variable PORT if available)\n\nOutput: Returns the HTTP server instance that was created and started.\n\nTask Description: ...\n\nFunction Description: ...\n\nInput: ...\n\nOutput: ...",
    "Canonical_solution": "function startServer() {\n    var http = require('http'),\n        express = require('express'),\n        app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    var rest = require('connect-rest');\n    var apiOptions = {\n        context: '/',\n        domain: require('domain').create(),\n    };\n\n    apiOptions.domain.on('error', function(err){\n        console.log('API domain error.\\n', err.stack);\n        setTimeout(function(){\n            console.log('Server shutting down after API domain error.');\n            process.exit(1);\n        }, 5000);\n        server.close();\n        var worker = require('cluster').worker;\n        if(worker) worker.disconnect();\n    });\n\n    app.use(vhost('api.*', rest.rester(apiOptions)));\n\n    var server = http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express started in ' + app.get('env') +\n            ' mode on http://localhost:' + app.get('port') +\n            '; press Ctrl-C to terminate.');\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst port = process.env.PORT || 3000;\nconst server = app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = server;",
      "const express = require('express');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\napp.use(express.static('public'));\napp.use(express.json());\n\napp.get('/', (req, res) => {\n  res.sendFile(__dirname + '/index.html');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, can\\'t find that!');\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
    ],
    "unmatched_results": [
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');\n  next();\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst port = process.env.PORT || 3000;\nconst server = app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = server;",
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');\n  next();\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');\n  next();\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\napp.listen(process.env.PORT || 3000, () => {\n  console.log(`Server is running on port ${process.env.PORT || 3000}`);\n});\n\nmodule.exports = app;"
    ],
    "match_count": 7,
    "pass@3": 0.9916666666666667,
    "pass@5": 1.0
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': r'^https?://(?:www\\.)?is\\.gd/',\n            'googl': r'^https?://(?:www\\.)?goo\\.gl/',\n            'budurl': r'^https?://(?:www\\.)?budurl\\.com/',\n            'snipurl': r'^https?://(?:www\\.)?snipurl\\.com/',\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl,\n            'generic': self.generic\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback({'url': url, 'err': 'Maximum depth exceeded', 'depth': depth, 'seen': seen})\n            return\n        if url in seen:\n            callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n            return\n        seen[url] = True\n\n        for service, pattern in self.map.items():\n            if re.match(pattern, url):\n                response = self.APIs[service](url)\n                if response:\n                    callback({'url': response, 'err': None, 'headers': response.headers, 'depth': depth + 1, 'seen': seen})\n                    return\n\n        self.generic(url, callback)\n\n    def isgd(self, url):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return response.headers['Location']\n        return None\n\n    def googl(self, url):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return response.headers['Location']\n        return None\n\n    def budurl(self, url):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return response.headers['Location']\n        return None\n\n    def snipurl(self, url):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return response.headers['Location']\n        return None\n\n    def generic(self, url, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'err': None, 'headers': response.headers, 'depth': 1, 'seen': {url: True}})\n        else:\n            callback({'url': url, 'err': None, 'headers': response.headers, 'depth': 1, 'seen': {url: True}})\n```",
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': r'^https?://(?:www\\.)?is\\.gd/',\n            'googl': r'^https?://(?:www\\.)?goo\\.gl/',\n            'budurl': r'^https?://(?:www\\.)?budurl\\.com/',\n            'snipurl': r'^https?://(?:www\\.)?snipurl\\.com/',\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl,\n            'generic': self.generic\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback({'url': url, 'err': 'Maximum depth reached', 'depth': depth, 'seen': seen})\n            return\n        if url in seen:\n            callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n            return\n        seen[url] = True\n\n        for service, pattern in self.map.items():\n            if re.match(pattern, url):\n                api_method = self.APIs.get(service)\n                if api_method:\n                    api_method(url, args, callback)\n                    return\n                break\n\n        self.generic(url, args, callback)\n\n    def isgd(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def googl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def budurl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def snipurl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def generic(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n```",
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': 'is.gd',\n            'googl': 'goo.gl',\n            'budurl': 'budurl.com',\n            'snipurl': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl,\n            'generic': self.generic\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback({'url': url, 'err': 'Maximum depth exceeded', 'depth': depth, 'seen': seen})\n            return\n        if url in seen:\n            callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n            return\n        seen[url] = True\n        domain = urlparse(url).netloc\n        if domain in self.map:\n            api = self.APIs.get(domain.split('.')[0])\n            if api:\n                api(url, args, callback)\n            else:\n                callback({'url': url, 'err': 'No API for domain', 'depth': depth, 'seen': seen})\n        else:\n            self.generic(url, args, callback)\n\n    def isgd(self, url, args, callback):\n        expanded_url = f\"https://is.gd/resolve?url={url}\"\n        self._make_request(expanded_url, args, callback)\n\n    def googl(self, url, args, callback):\n        expanded_url = f\"https://www.googleapis.com/urlshortener/v1/url?key=YOUR_API_KEY&shortUrl={url}\"\n        self._make_request(expanded_url, args, callback)\n\n    def budurl(self, url, args, callback):\n        expanded_url = f\"https://budurl.com/resolve?url={url}\"\n        self._make_request(expanded_url, args, callback)\n\n    def snipurl(self, url, args, callback):\n        expanded_url = f\"https://snipurl.com/api.php?url={url}\"\n        self._make_request(expanded_url, args, callback)\n\n    def generic(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            location = response.headers.get('Location')\n            args['url'] = location\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'Not a redirect', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def _make_request(self, url, args, callback):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.status_code == 200:\n                result = response.json()\n                if 'longUrl' in result:\n                    final_url = result['longUrl']\n                    args['url'] = final_url\n                    self.expand(args, callback)\n                else:\n                    callback({'url': url, 'err': 'No long URL found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n            else:\n                callback({'url': url, 'err': 'API error', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n        except requests.RequestException as e:\n            callback({'url': url, 'err': str(e), 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n```",
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': r'^https?://(?:www\\.)?is\\.gd/',\n            'googl': r'^https?://(?:www\\.)?goo\\.gl/',\n            'budurl': r'^https?://(?:www\\.)?budurl\\.com/',\n            'snipurl': r'^https?://(?:www\\.)?snipurl\\.com/',\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl,\n            'generic': self.generic\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback({'url': url, 'err': 'Maximum depth exceeded', 'depth': depth, 'seen': seen})\n            return\n        if url in seen:\n            callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n            return\n        seen[url] = True\n\n        def handle_response(response):\n            if 'Location' in response.headers:\n                new_url = response.headers['Location']\n                if new_url.startswith('http'):\n                    args['url'] = new_url\n                    self.expand(args, callback)\n                else:\n                    callback({'url': url, 'err': 'Invalid redirect URL', 'depth': depth, 'seen': seen})\n            else:\n                callback({'url': url, 'err': 'No redirect URL found', 'depth': depth, 'seen': seen})\n\n        for service, pattern in self.map.items():\n            if re.match(pattern, url):\n                api_method = self.APIs.get(service)\n                if api_method:\n                    api_method(url, handle_response)\n                    return\n                break\n        self.generic(url, handle_response)\n\n    def isgd(self, url, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'depth': 1, 'seen': {url: True}})\n        else:\n            callback({'url': url, 'err': 'No redirect', 'depth': 1, 'seen': {url: True}})\n\n    def googl(self, url, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'depth': 1, 'seen': {url: True}})\n        else:\n            callback({'url': url, 'err': 'No redirect', 'depth': 1, 'seen': {url: True}})\n\n    def budurl(self, url, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'depth': 1, 'seen': {url: True}})\n        else:\n            callback({'url': url, 'err': 'No redirect', 'depth': 1, 'seen': {url: True}})\n\n    def snipurl(self, url, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'depth': 1, 'seen': {url: True}})\n        else:\n            callback({'url': url, 'err': 'No redirect', 'depth': 1, 'seen': {url: True}})\n\n    def generic(self, url, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'depth': 1, 'seen': {url: True}})\n        else:\n            callback({'url': url, 'err': 'No redirect', 'depth': 1, 'seen': {url: True}})\n```",
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': r'^https?://(?:www\\.)?is\\.gd/[a-zA-Z0-9]+',\n            'googl': r'^https?://(?:www\\.)?goo\\.gl/[a-zA-Z0-9]+',\n            'budurl': r'^https?://(?:www\\.)?budurl\\.com/[a-zA-Z0-9]+',\n            'snipurl': r'^https?://(?:www\\.)?snipurl\\.com/[a-zA-Z0-9]+'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl,\n            'generic': self.generic\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:  # Limiting depth to prevent infinite loops\n            return callback({'url': url, 'err': 'Maximum depth reached', 'depth': depth, 'seen': seen})\n\n        if url in seen:\n            return callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n\n        seen[url] = True\n        parsed_url = urlparse(url)\n        domain = parsed_url.netloc\n\n        for service, pattern in self.map.items():\n            if re.match(pattern, domain):\n                response = self.APIs[service](url)\n                if response:\n                    return callback({'url': response, 'err': None, 'headers': response.headers, 'depth': depth + 1, 'seen': seen})\n                break\n\n        return self.generic(url, args, callback)\n\n    def isgd(self, url):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return response.headers['Location']\n        return None\n\n    def googl(self, url):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return response.headers['Location']\n        return None\n\n    def budurl(self, url):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return response.headers['Location']\n        return None\n\n    def snipurl(self, url):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return response.headers['Location']\n        return None\n\n    def generic(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            return self.expand({'url': response.headers['Location'], 'depth': args['depth'] + 1, 'seen': args['seen']}, callback)\n        return callback({'url': url, 'err': 'No redirect found', 'depth': args['depth'], 'seen': args['seen']})\n```",
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': r'^https?://(?:www\\.)?is\\.gd/([a-zA-Z0-9]+)',\n            'googl': r'^https?://(?:www\\.)?goo\\.gl/([a-zA-Z0-9]+)',\n            'budurl': r'^https?://(?:www\\.)?budurl\\.com/([a-zA-Z0-9]+)',\n            'snipurl': r'^https?://(?:www\\.)?snipurl\\.com/([a-zA-Z0-9]+)'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl,\n            'generic': self.generic\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback({'url': url, 'err': 'Maximum depth exceeded', 'depth': depth, 'seen': seen})\n            return\n        if url in seen:\n            callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n            return\n        seen[url] = True\n        for service, pattern in self.map.items():\n            match = re.match(pattern, url)\n            if match:\n                short_code = match.group(1)\n                api_method = self.APIs.get(service)\n                if api_method:\n                    api_method(short_code, args, callback)\n                    return\n        self.generic(url, args, callback)\n\n    def isgd(self, short_code, args, callback):\n        expanded_url = f'https://isgd.com/api.php?short={short_code}'\n        self._make_request(expanded_url, args, callback)\n\n    def googl(self, short_code, args, callback):\n        expanded_url = f'https://www.googleapis.com/urlshortener/v1/url?key=YOUR_API_KEY&shortUrl=https://goo.gl/{short_code}'\n        self._make_request(expanded_url, args, callback)\n\n    def budurl(self, short_code, args, callback):\n        expanded_url = f'https://budurl.com/api.php?short={short_code}'\n        self._make_request(expanded_url, args, callback)\n\n    def snipurl(self, short_code, args, callback):\n        expanded_url = f'https://snipurl.com/api.php?short={short_code}'\n        self._make_request(expanded_url, args, callback)\n\n    def generic(self, url, args, callback):\n        headers = {'Connection': 'close'}\n        response = requests.head(url, headers=headers, timeout=self.timeout)\n        if response.status_code == 301 or response.status_code == 302:\n            location = response.headers.get('Location')\n            args['url'] = location\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'Not a short URL', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def _make_request(self, url, args, callback):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.status_code == 200:\n                location = response.url\n                args['url'] = location\n                self.expand(args, callback)\n            else:\n                callback({'url': url, 'err': 'Failed to expand URL', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n        except requests.RequestException as e:\n            callback({'url': url, 'err': str(e), 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n```",
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': r'^https?://(?:www\\.)?is\\.gd/([a-zA-Z0-9]+)',\n            'googl': r'^https?://(?:www\\.)?goo\\.gl/([a-zA-Z0-9]+)',\n            'budurl': r'^https?://(?:www\\.)?budurl\\.com/([a-zA-Z0-9]+)',\n            'snipurl': r'^https?://(?:www\\.)?snipurl\\.com/([a-zA-Z0-9]+)'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self._isgd,\n            'googl': self._googl,\n            'budurl': self._budurl,\n            'snipurl': self._snipurl,\n            'generic': self._generic\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback({'url': url, 'err': 'Maximum depth exceeded', 'depth': depth, 'seen': seen})\n            return\n        if url in seen:\n            callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n            return\n        seen[url] = True\n\n        def handle_response(response):\n            if response.status_code == 301 or response.status_code == 302:\n                new_url = response.headers.get('Location')\n                args['url'] = new_url\n                self.expand(args, callback)\n            else:\n                callback({'url': url, 'err': 'Unexpected status code', 'depth': depth, 'seen': seen})\n\n        for service, pattern in self.map.items():\n            match = re.match(pattern, url)\n            if match:\n                api_method = self.APIs.get(service)\n                if api_method:\n                    api_method(match.group(1), args, callback)\n                    return\n                break\n        self._generic(url, args, handle_response)\n\n    def _isgd(self, key, args, callback):\n        response = requests.get(f'https://is.gd/{key}', timeout=self.timeout)\n        self.expand(args, callback)\n\n    def _googl(self, key, args, callback):\n        response = requests.get(f'https://goo.gl/{key}', timeout=self.timeout)\n        self.expand(args, callback)\n\n    def _budurl(self, key, args, callback):\n        response = requests.get(f'https://budurl.com/{key}', timeout=self.timeout)\n        self.expand(args, callback)\n\n    def _snipurl(self, key, args, callback):\n        response = requests.get(f'https://snipurl.com/{key}', timeout=self.timeout)\n        self.expand(args, callback)\n\n    def _generic(self, url, args, callback):\n        response = requests.head(url, allow_redirects=True, timeout=self.timeout)\n        handle_response(response)\n```",
      "```python\nimport requests\nimport time\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': 'is.gd',\n            'googl': 'goo.gl',\n            'budurl': 'budurl.com',\n            'snipurl': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl,\n            'generic': self.generic\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n\n        if url in seen:\n            callback({'url': url, 'err': None, 'depth': depth, 'seen': seen})\n            return\n\n        if depth > 5:\n            callback({'url': url, 'err': None, 'depth': depth, 'seen': seen})\n            return\n\n        domain = self.get_domain(url)\n        if domain in self.map:\n            service = self.map[domain]\n            self.APIs[service](url, args, callback)\n        else:\n            self.generic(url, args, callback)\n\n    def get_domain(self, url):\n        return url.split('/')[2]\n\n    def isgd(self, url, args, callback):\n        expanded_url = f\"https://is.gd/expand?url={url}\"\n        self.make_request(expanded_url, args, callback)\n\n    def googl(self, url, args, callback):\n        expanded_url = f\"https://www.googleapis.com/urlshortener/v1/url?key=YOUR_API_KEY&shortUrl={url}\"\n        self.make_request(expanded_url, args, callback)\n\n    def budurl(self, url, args, callback):\n        expanded_url = f\"https://budurl.com/api.php?shorturl={url}\"\n        self.make_request(expanded_url, args, callback)\n\n    def snipurl(self, url, args, callback):\n        expanded_url = f\"https://snipurl.com/api.php?shorturl={url}\"\n        self.make_request(expanded_url, args, callback)\n\n    def generic(self, url, args, callback):\n        try:\n            response = requests.head(url, timeout=self.timeout)\n            if response.status_code == 301 or response.status_code == 302:\n                new_url = response.headers['Location']\n                args['url'] = new_url\n                self.expand(args, callback)\n            else:\n                callback({'url': url, 'err': None, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n        except requests.RequestException as e:\n            callback({'url': url, 'err': e, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def make_request(self, url, args, callback):\n        try:\n            response = requests.get(url, timeout=self.timeout)\n            if response.status_code == 200:\n                data = response.json()\n                final_url = data.get('longUrl')\n                args['url'] = final_url\n                self.expand(args, callback)\n            else:\n                callback({'url': url, 'err': None, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n        except requests.RequestException as e:\n            callback({'url': url, 'err': e, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n```",
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': 'is.gd',\n            'googl': 'goo.gl',\n            'budurl': 'budurl.com',\n            'snipurl': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self._isgd,\n            'googl': self._googl,\n            'budurl': self._budurl,\n            'snipurl': self._snipurl,\n            'generic': self._generic\n        }\n\n    def expand(self, args, callback):\n        url = args.get('url')\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback({'url': url, 'err': 'Maximum depth exceeded', 'depth': depth, 'seen': seen})\n            return\n        if url in seen:\n            callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n            return\n        seen[url] = True\n        domain = urlparse(url).netloc\n        for service, domain_name in self.map.items():\n            if domain.endswith(domain_name):\n                self.APIs[service](url, args, callback)\n                return\n        self._generic(url, args, callback)\n\n    def _isgd(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def _googl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def _budurl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def _snipurl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def _generic(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            args['url'] = response.headers['Location']\n            self.expand(args, callback)\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n```",
      "```python\nimport requests\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\nclass URLExpander:\n    def __init__(self):\n        self.map = {\n            'isgd': 'is.gd',\n            'googl': 'goo.gl',\n            'budurl': 'budurl.com',\n            'snipurl': 'snipurl.com'\n        }\n        self.timeout = 5000\n        self.APIs = {\n            'isgd': self.isgd,\n            'googl': self.googl,\n            'budurl': self.budurl,\n            'snipurl': self.snipurl,\n            'generic': self.generic\n        }\n\n    def expand(self, args, callback):\n        url = args['url']\n        depth = args.get('depth', 0)\n        seen = args.get('seen', {})\n        if depth > 5:\n            callback({'url': url, 'err': 'Max depth exceeded', 'depth': depth, 'seen': seen})\n            return\n        if url in seen:\n            callback({'url': url, 'err': 'Cycle detected', 'depth': depth, 'seen': seen})\n            return\n        seen[url] = True\n\n        domain = urlparse(url).netloc\n        for service, domain_pattern in self.map.items():\n            if re.match(domain_pattern, domain):\n                self.APIs[service](url, args, callback)\n                return\n\n        self.generic(url, args, callback)\n\n    def isgd(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'err': None, 'headers': response.headers, 'depth': args.get('depth', 0) + 1, 'seen': args.get('seen', {})})\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'headers': response.headers, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def googl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'err': None, 'headers': response.headers, 'depth': args.get('depth', 0) + 1, 'seen': args.get('seen', {})})\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'headers': response.headers, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def budurl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'err': None, 'headers': response.headers, 'depth': args.get('depth', 0) + 1, 'seen': args.get('seen', {})})\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'headers': response.headers, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def snipurl(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'err': None, 'headers': response.headers, 'depth': args.get('depth', 0) + 1, 'seen': args.get('seen', {})})\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'headers': response.headers, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n\n    def generic(self, url, args, callback):\n        response = requests.head(url, timeout=self.timeout)\n        if response.status_code == 302:\n            callback({'url': response.headers['Location'], 'err': None, 'headers': response.headers, 'depth': args.get('depth', 0) + 1, 'seen': args.get('seen', {})})\n        else:\n            callback({'url': url, 'err': 'No redirect found', 'headers': response.headers, 'depth': args.get('depth', 0), 'seen': args.get('seen', {})})\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a function that sets up an HTTP server using Express.js framework, configures middleware for logging, and defines route handlers for various endpoints.\n\nFunction Description: The function `setupServer` initializes an Express application, adds request logging middleware using Morgan, defines route handlers for the root path ('/'), about page ('/about'), and two API endpoints ('/api/products' and '//api/items'), and starts the server listening on port 5000.\n\nInput: None\n\nOutput: None (The function's effect is to start an HTTP server that listens on port 5000 and responds to defined routes)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const app = express();\n    const morgan = require('morgan');\n    \n    app.use(morgan('tiny'));\n    \n    app.get('/', (req, res) => {\n        res.send('Home');\n    });\n    app.get('/about', (req, res) => {\n        res.send('About');\n    });\n    app.get('/api/products', (req, res) => {\n        res.send('Products');\n    });\n    app.get('/api/items', (req, res) => {\n        console.log(req.user);\n        res.send('Items');\n    });\n    \n    app.listen(5000, () => {\n        console.log('Server is listening on port 5000....');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});",
      "const express = require('express');\nconst morgan = require('morgan');\n\nconst app = express();\n\napp.use(morgan('dev'));\n\napp.get('/', (req, res) => {\n  res.send('Home Page');\n});\n\napp.get('/about', (req, res) => {\n  res.send('About Page');\n});\n\napp.get('/api/products', (req, res) => {\n  res.send('Products API');\n});\n\napp.get('/api/items', (req, res) => {\n  res.send('Items API');\n});\n\napp.listen(5000, () => {\n  console.log('Server is running on port 5000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a function that sets up an Express server with various middleware configurations for static file serving, API proxying, HTML5 history API fallback, and webpack development tools.\n\nFunction Description: The function `setupExpressServer` initializes an Express application and configures it with multiple middleware layers. It serves static files from a specified directory, proxies API requests to a mock server, enables HTML5 History API fallback for single-page applications, and integrates Webpack's development and hot-reload middleware. Finally, it starts the server on a specified port.\n\nInput: \n- None (The function relies on external constants/variables: PATHS.STATIC, PORTS.MOCK_SERVER, PORTS.DEV_SERVER, compiler, and config)\n\nOutput: \n- None (The function's side effect is starting an Express server that listens on PORTS.DEV_SERVER)",
    "Canonical_solution": "function setupExpressServer() {\n  var express = require('express');\n  var proxy = require('http-proxy-middleware');\n  var app = express();\n\n  // Provide static resources\n  app.use('/static', express.static(PATHS.STATIC));\n\n  // Mock server proxy\n  app.use('/api', proxy({\n    target: 'http://127.0.0.1:' + PORTS.MOCK_SERVER,\n    changeOrigin: true,\n    pathRewrite: {\n      '^/api': '/'\n    }\n  }));\n\n  // HTML5 History API fallback\n  app.use(require('connect-history-api-fallback')());\n\n  // Webpack middleware\n  app.use(require('webpack-dev-middleware')(compiler, {\n    noInfo: true,\n    publicPath: config.output.publicPath\n  }));\n\n  // Hot reload middleware\n  app.use(require('webpack-hot-middleware')(compiler));\n\n  // Start server\n  app.listen(PORTS.DEV_SERVER);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\nconst proxy = httpProxy.createProxyServer({});\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use('/api', (req, res) => proxy.web(req, res, { target: `http://${PORTS.MOCK_SERVER}` }));\napp.use(webpackMiddleware(compiler, config));\napp.use(webpackHotMiddleware(compiler));\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\nconst proxy = httpProxy.createProxyServer({});\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use(webpackMiddleware(compiler, config));\napp.use(webpackHotMiddleware(compiler));\n\napp.use((req, res) => {\n  proxy.web(req, res, { target: PORTS.MOCK_SERVER }, (e) => {\n    proxy.web(req, res, { target: PORTS.MOCK_SERVER }, () => {\n      res.status(404).send('404: Page Not Found');\n    });\n  });\n});\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\nconst proxy = httpProxy.createProxyServer({});\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use(webpackMiddleware(compiler, config));\napp.use(webpackHotMiddleware(compiler));\n\napp.use((req, res) => {\n  proxy.web(req, res, { target: PORTS.MOCK_SERVER }, (e) => {\n    proxy.web(req, res, { target: PORTS.MOCK_SERVER }, () => {\n      res.status(404).send('404 Not Found');\n    });\n  });\n});\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\nconst proxy = httpProxy.createProxyServer({});\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use('/api', (req, res) => proxy.web(req, res, { target: `http://${PORTS.MOCK_SERVER}` }));\napp.use(webpackMiddleware(compiler, config));\napp.use(webpackHotMiddleware(compiler));\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst proxy = require('http-proxy-middleware');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use(proxy('/api', { target: `http://${PORTS.MOCK_SERVER}` }));\napp.use(webpackMiddleware(compiler, config));\napp.use(webpackHotMiddleware(compiler));\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\nconst proxy = httpProxy.createProxyServer({});\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use(webpackMiddleware(compiler, config));\napp.use(webpackHotMiddleware(compiler));\n\napp.use((req, res) => {\n  proxy.web(req, res, { target: PORTS.MOCK_SERVER }, (e) => {\n    proxy.web(req, res, { target: PORTS.MOCK_SERVER }, () => {\n      res.status(404).send('404: Page Not Found');\n    });\n  });\n});\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\nconst proxy = httpProxy.createProxyServer({});\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use((req, res) => {\n  if (req.url.startsWith('/api')) {\n    proxy.web(req, res, { target: `http://${PORTS.MOCK_SERVER}` });\n  }\n});\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: '/',\n  contentBase: path.resolve(__dirname, PATHS.STATIC),\n  hot: true,\n  quiet: false,\n  noInfo: false,\n  watchOptions: {\n    aggregateTimeout: 300,\n    poll: 1000\n  }\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\nconst proxy = httpProxy.createProxyServer({});\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use((req, res) => {\n  if (req.headers.host === PORTS.MOCK_SERVER) {\n    proxy.web(req, res, { target: PORTS.MOCK_SERVER });\n  }\n});\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: '/',\n  contentBase: path.resolve(__dirname, PATHS.STATIC),\n  hot: true,\n  quiet: false,\n  noInfo: false,\n  stats: { colors: true },\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst proxy = require('http-proxy-middleware');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use(proxy('/api', { target: `http://${PORTS.MOCK_SERVER}` }));\napp.use(webpackMiddleware(compiler, config));\napp.use(webpackHotMiddleware(compiler));\n\napp.listen(PORTS.DEV_SERVER);",
      "const express = require('express');\nconst path = require('path');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst app = express();\nconst proxy = httpProxy.createProxyServer({});\n\napp.use(express.static(PATHS.STATIC));\napp.use(history());\napp.use('/api', (req, res) => proxy.web(req, res, { target: `http://${PORTS.MOCK_SERVER}` }));\napp.use(webpackMiddleware(compiler, config));\napp.use(webpackHotMiddleware(compiler));\n\napp.listen(PORTS.DEV_SERVER);"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a function to start an Express server with REST API endpoints for managing tourist attractions, including retrieving approved attractions, adding new attractions, and fetching specific attraction details.\n\nFunction Description: The function initializes an Express application, configures middleware, sets up REST API routes using connect-rest, and starts an HTTP server. It handles GET and POST requests for attractions data, connects to a MongoDB model for data persistence, and implements error handling through domains.\n\nInput: None (The function takes no parameters but relies on environment variables like PORT and requires external modules)\n\nOutput: Returns the HTTP server instance that was created and started.\n\nMethods:\n\n- GET /attractions: Retrieves all approved attractions (returns array of attraction objects)\n- POST /attraction: Creates a new attraction (requires name, description, location, and email in request body, returns new attraction ID)\n- GET /attraction/:id: Retrieves details of a specific attraction (requires ID parameter, returns attraction object)\n\nError Handling:\n- Implements domain-based error handling that logs errors and gracefully shuts down the server\n- Returns appropriate error messages for database operations\n\nDependencies:\n- Requires Express, connect-rest, body-parser, and a MongoDB model (Attraction)\n- Uses cluster module for worker process management in case of errors",
    "Canonical_solution": "function startServer() {\n    var http = require('http'),\n        express = require('express'),\n        app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    var rest = require('connect-rest');\n    var apiOptions = {\n        context: '/',\n        domain: require('domain').create(),\n    };\n\n    apiOptions.domain.on('error', function(err){\n        console.log('API domain error.\\n', err.stack);\n        setTimeout(function(){\n            console.log('Server shutting down after API domain error.');\n            process.exit(1);\n        }, 5000);\n        server.close();\n        var worker = require('cluster').worker;\n        if(worker) worker.disconnect();\n    });\n\n    var Attraction = require('./models/attraction.js');\n\n    rest.get('/attractions', function(req, content, cb){\n        Attraction.find({ approved: true }, function(err, attractions){\n            if(err) return cb({ error: 'Internal error.' });\n            cb(null, attractions.map(function(a){\n                return {\n                    name: a.name,\n                    description: a.description,\n                    location: a.location,\n                };\n            }));\n        });\n    });\n\n    rest.post('/attraction', function(req, content, cb){\n        var a = new Attraction({\n            name: req.body.name,\n            description: req.body.description,\n            location: { lat: req.body.lat, lng: req.body.lng },\n            history: {\n                event: 'created',\n                email: req.body.email,\n                date: new Date(),\n            },\n            approved: false,\n        });\n        a.save(function(err, a){\n            if(err) return cb({ error: 'Unable to add attraction.' });\n            cb(null, { id: a._id });\n        }); \n    });\n\n    rest.get('/attraction/:id', function(req, content, cb){\n        Attraction.findById(req.params.id, function(err, a){\n            if(err) return cb({ error: 'Unable to retrieve attraction.' });\n            cb(null, { \n                name: a.name,\n                description: a.description,\n                location: a.location,\n            });\n        });\n    });\n\n    var server = http.createServer(app).listen(app.get('port'), function(){\n        console.log( 'Express started in ' + app.get('env') +\n            ' mode on http://localhost:' + app.get('port') +\n            '; press Ctrl-C to terminate.' );\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst http = require('http');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst routes = rest({\n  attractions: {\n    get: { path: '/attractions', handler: getAttractions },\n    post: { path: '/attraction', handler: addAttraction }\n  },\n  attraction: {\n    get: { path: '/attraction/:id', handler: getAttraction }\n  }\n});\n\napp.use('/api', routes);\n\nfunction getAttractions(req, res) {\n  Attraction.find({ approved: true }, (err, attractions) => {\n    if (err) {\n      handleError(err, res);\n      return;\n    }\n    res.json(attractions);\n  });\n}\n\nfunction addAttraction(req, res) {\n  const newAttraction = new Attraction(req.body);\n  newAttraction.save((err, attraction) => {\n    if (err) {\n      handleError(err, res);\n      return;\n    }\n    res.json({ id: attraction._id });\n  });\n}\n\nfunction getAttraction(req, res) {\n  Attraction.findById(req.params.id, (err, attraction) => {\n    if (err) {\n      handleError(err, res);\n      return;\n    }\n    res.json(attraction);\n  });\n}\n\nfunction handleError(err, res) {\n  const d = domain.create();\n  d.on('error', (error) => {\n    console.error(error);\n    res.status(500).json({ error: 'Internal Server Error' });\n    process.exit(1);\n  });\n  d.run(() => {\n    throw err;\n  });\n}\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  const server = http.createServer(app).listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n```",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst routes = rest({\n  attractions: {\n    get: { path: '/attractions', handler: getAttractions },\n    post: { path: '/attraction', handler: addAttraction }\n  },\n  attraction: {\n    get: { path: '/attraction/:id', handler: getAttraction }\n  }\n});\n\napp.use('/api', routes);\n\nfunction getAttractions(req, res) {\n  Attraction.find({ approved: true }, (err, attractions) => {\n    if (err) {\n      res.status(500).send('Error fetching attractions');\n      return;\n    }\n    res.status(200).send(attractions);\n  });\n}\n\nfunction addAttraction(req, res) {\n  const newAttraction = new Attraction(req.body);\n  newAttraction.save((err, attraction) => {\n    if (err) {\n      res.status(500).send('Error adding attraction');\n      return;\n    }\n    res.status(201).send({ id: attraction._id });\n  });\n}\n\nfunction getAttraction(req, res) {\n  Attraction.findById(req.params.id, (err, attraction) => {\n    if (err) {\n      res.status(500).send('Error fetching attraction');\n      return;\n    }\n    if (!attraction) {\n      res.status(404).send('Attraction not found');\n      return;\n    }\n    res.status(200).send(attraction);\n  });\n}\n\nconst server = app.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n\nconst serverDomain = domain.create();\nserverDomain.add(server);\nserverDomain.on('error', (err) => {\n  console.error('Server error:', err);\n  server.close(() => {\n    process.exit(1);\n  });\n});\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  serverDomain.run(() => {\n    serverDomain.run(() => {\n      serverDomain.run(() => {\n        serverDomain.run(() => {\n          serverDomain.run(() => {\n            serverDomain.run(() => {\n              serverDomain.run(() => {\n                serverDomain.run(() => {\n                  serverDomain.run(() => {\n                    serverDomain.run(() => {\n                      serverDomain.run(() => {\n                        serverDomain.run(() => {\n                          serverDomain.run(() => {\n                            serverDomain.run(() => {\n                              serverDomain.run(() => {\n                                serverDomain.run(() => {\n                                  serverDomain.run(() => {\n                                    serverDomain.run(() => {\n                                      serverDomain.run(() => {\n                                        serverDomain.run(() => {\n                                          serverDomain.run(() => {\n                                            serverDomain.run(() => {\n                                              serverDomain.run(() => {\n                                                serverDomain.run(() => {\n                                                  serverDomain.run(() => {\n                                                    serverDomain.run(() => {\n                                                      serverDomain.run(() => {\n                                                        serverDomain.run(() => {\n                                                          serverDomain.run(() => {\n                                                            serverDomain.run(() => {\n                                                              serverDomain.run(() => {\n                                                                serverDomain.run(() => {\n                                                                  serverDomain.run(() => {\n                                                                    serverDomain.run(() => {\n                                                                      serverDomain.run(() => {\n                                                                        serverDomain.run(() => {\n                                                                          serverDomain.run(() => {\n                                                                            serverDomain.run(() => {\n                                                                              serverDomain.run(() => {\n                                                                                serverDomain.run(() => {\n                                                                                  serverDomain.run(() => {\n                                                                                    serverDomain.run(() => {\n                                                                                      serverDomain.run(() => {\n                                                                                      });\n                                                                                    });\n                                                                                  });\n                                                                                });\n                                                                              });\n                                                                            });\n                                                                          });\n                                                                        });\n                                                                      });\n                                                                    });\n                                                                  });\n                                                                });\n                                                              });\n                                                            });\n                                                          });\n                                                        });\n                                                      });\n                                                    });\n                                                  });\n                                                });\n                                              });\n                                            });\n                                          });\n                                        });\n                                      });\n                                    });\n                                  });\n                                });\n                              });\n                            });\n                          });\n                        });\n                      });\n                    });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst http = require('http');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst router = rest.router();\n\nrouter.get('/attractions', (req, res) => {\n  Attraction.find({ approved: true }, (err, attractions) => {\n    if (err) {\n      res.status(500).send('Error fetching attractions');\n    } else {\n      res.send(attractions);\n    }\n  });\n});\n\nrouter.post('/attraction', (req, res) => {\n  const newAttraction = new Attraction(req.body);\n  newAttraction.save((err, attraction) => {\n    if (err) {\n      res.status(500).send('Error adding attraction');\n    } else {\n      res.send({ id: attraction._id });\n    }\n  });\n});\n\nrouter.get('/attraction/:id', (req, res) => {\n  Attraction.findById(req.params.id, (err, attraction) => {\n    if (err) {\n      res.status(500).send('Error fetching attraction');\n    } else if (!attraction) {\n      res.status(404).send('Attraction not found');\n    } else {\n      res.send(attraction);\n    }\n  });\n});\n\napp.use('/api', router);\n\nconst server = http.createServer(app);\n\nconst d = domain.create();\nd.on('error', (err) => {\n  console.error('Error:', err);\n  server.close(() => {\n    process.exit(1);\n  });\n});\n\nd.run(() => {\n  if (cluster.isMaster) {\n    const numCPUs = os.cpus().length;\n    for (let i = 0; i < numCPUs; i++) {\n      cluster.fork();\n    }\n    cluster.on('exit', (worker, code, signal) => {\n      console.log(`worker ${worker.process.pid} died`);\n    });\n  } else {\n    server.listen(port, () => {\n      console.log(`Server running on port ${port}`);\n    });\n  }\n});\n\nmodule.exports = server;",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst routes = rest({\n  attractions: {\n    get: { path: '/attractions', handler: getAttractions },\n    post: { path: '/attraction', handler: addAttraction }\n  },\n  attraction: {\n    get: { path: '/attraction/:id', handler: getAttraction }\n  }\n});\n\napp.use('/api', routes);\n\nfunction getAttractions(req, res) {\n  Attraction.find({ approved: true }, (err, attractions) => {\n    if (err) {\n      res.status(500).send('Error retrieving attractions');\n      return;\n    }\n    res.status(200).send(attractions);\n  });\n}\n\nfunction addAttraction(req, res) {\n  const newAttraction = new Attraction(req.body);\n  newAttraction.save((err, attraction) => {\n    if (err) {\n      res.status(500).send('Error adding attraction');\n      return;\n    }\n    res.status(201).send({ id: attraction._id });\n  });\n}\n\nfunction getAttraction(req, res) {\n  Attraction.findById(req.params.id, (err, attraction) => {\n    if (err) {\n      res.status(500).send('Error retrieving attraction');\n      return;\n    }\n    if (!attraction) {\n      res.status(404).send('Attraction not found');\n      return;\n    }\n    res.status(200).send(attraction);\n  });\n}\n\nconst server = app.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n\nconst serverDomain = domain.create();\nserverDomain.add(server);\nserverDomain.on('error', (err) => {\n  console.error('Server error:', err);\n  server.close(() => {\n    process.exit(1);\n  });\n});\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  serverDomain.run(() => {\n    serverDomain.run(() => {\n      serverDomain.run(() => {\n        serverDomain.run(() => {\n          serverDomain.run(() => {\n            serverDomain.run(() => {\n              serverDomain.run(() => {\n                serverDomain.run(() => {\n                  serverDomain.run(() => {\n                    serverDomain.run(() => {\n                      serverDomain.run(() => {\n                        serverDomain.run(() => {\n                          serverDomain.run(() => {\n                            serverDomain.run(() => {\n                              serverDomain.run(() => {\n                                serverDomain.run(() => {\n                                  serverDomain.run(() => {\n                                    serverDomain.run(() => {\n                                      serverDomain.run(() => {\n                                        serverDomain.run(() => {\n                                          serverDomain.run(() => {\n                                            serverDomain.run(() => {\n                                              serverDomain.run(() => {\n                                                serverDomain.run(() => {\n                                                  serverDomain.run(() => {\n                                                    serverDomain.run(() => {\n                                                      serverDomain.run(() => {\n                                                        serverDomain.run(() => {\n                                                          serverDomain.run(() => {\n                                                            serverDomain.run(() => {\n                                                              serverDomain.run(() => {\n                                                                serverDomain.run(() => {\n                                                                  serverDomain.run(() => {\n                                                                    serverDomain.run(() => {\n                                                                      serverDomain.run(() => {\n                                                                        serverDomain.run(() => {\n                                                                          serverDomain.run(() => {\n                                                                            serverDomain.run(() => {\n                                                                              serverDomain.run(() => {\n                                                                                serverDomain.run(() => {\n                                                                                  serverDomain.run(() => {\n                                                                                    serverDomain.run(() => {\n                                                                                      serverDomain.run(() => {\n                                                                                      });\n                                                                                    });\n                                                                                  });\n                                                                                });\n                                                                              });\n                                                                            });\n                                                                          });\n                                                                        });\n                                                                      });\n                                                                    });\n                                                                  });\n                                                                });\n                                                              });\n                                                            });\n                                                          });\n                                                        });\n                                                      });\n                                                    });\n                                                  });\n                                                });\n                                              });\n                                            });\n                                          });\n                                        });\n                                      });\n                                    });\n                                  });\n                                });\n                              });\n                            });\n                          });\n                        });\n                      });\n                    });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst router = rest.router();\n\nrouter.get('/attractions', (req, res) => {\n  Attraction.find({ approved: true }, (err, attractions) => {\n    if (err) {\n      res.status(500).send('Error retrieving attractions');\n    } else {\n      res.send(attractions);\n    }\n  });\n});\n\nrouter.post('/attraction', (req, res) => {\n  const newAttraction = new Attraction(req.body);\n  newAttraction.save((err, attraction) => {\n    if (err) {\n      res.status(500).send('Error creating attraction');\n    } else {\n      res.send({ id: attraction._id });\n    }\n  });\n});\n\nrouter.get('/attraction/:id', (req, res) => {\n  Attraction.findById(req.params.id, (err, attraction) => {\n    if (err) {\n      res.status(500).send('Error retrieving attraction');\n    } else {\n      res.send(attraction);\n    }\n  });\n});\n\napp.use('/api', router);\n\nconst server = app.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nconst shutdown = () => {\n  server.close(() => {\n    process.exit(0);\n  });\n};\n\nconst exitHandler = domain.create();\nexitHandler.on('error', (err) => {\n  console.error(err);\n  shutdown();\n});\n\nexitHandler.run(() => {\n  if (cluster.isMaster) {\n    for (let i = 0; i < os.cpus().length; i++) {\n      cluster.fork();\n    }\n    cluster.on('exit', (worker, code, signal) => {\n      console.log(`worker ${worker.process.pid} died`);\n      cluster.fork();\n    });\n  } else {\n    process.on('uncaughtException', (err) => {\n      exitHandler.emit('error', err);\n    });\n    process.on('unhandledRejection', (reason, promise) => {\n      exitHandler.emit('error', reason);\n    });\n  }\n});\n```",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst router = rest.router();\n\nrouter.get('/attractions', (req, res) => {\n  Attraction.find({ approved: true }, (err, attractions) => {\n    if (err) {\n      res.status(500).send('Error retrieving attractions');\n      return;\n    }\n    res.json(attractions);\n  });\n});\n\nrouter.post('/attraction', (req, res) => {\n  const newAttraction = new Attraction(req.body);\n  newAttraction.save((err, attraction) => {\n    if (err) {\n      res.status(500).send('Error creating attraction');\n      return;\n    }\n    res.json({ id: attraction._id });\n  });\n});\n\nrouter.get('/attraction/:id', (req, res) => {\n  Attraction.findById(req.params.id, (err, attraction) => {\n    if (err) {\n      res.status(500).send('Error finding attraction');\n      return;\n    }\n    if (!attraction) {\n      res.status(404).send('Attraction not found');\n      return;\n    }\n    res.json(attraction);\n  });\n});\n\napp.use('/api', router);\n\nconst server = app.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n\nconst shutdown = () => {\n  server.close(() => {\n    process.exit(0);\n  });\n};\n\nprocess.on('SIGINT', shutdown);\nprocess.on('SIGTERM', shutdown);\n\nconst workerDomain = domain.create();\nworkerDomain.on('error', (err) => {\n  console.error('Worker error:', err);\n  shutdown();\n});\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  workerDomain.run(() => {\n    server.listen(port);\n  });\n}",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst routes = rest({\n  attractions: {\n    get: { path: '/attractions', handler: getAttractions },\n    post: { path: '/attraction', handler: addAttraction }\n  },\n  attraction: {\n    get: { path: '/attraction/:id', handler: getAttraction }\n  }\n});\n\napp.use('/api', routes);\n\nfunction getAttractions(req, res) {\n  Attraction.find({ approved: true }, (err, attractions) => {\n    if (err) {\n      return handleError(res, err);\n    }\n    return res.status(200).json(attractions);\n  });\n}\n\nfunction addAttraction(req, res) {\n  const newAttraction = new Attraction(req.body);\n  newAttraction.save((err, attraction) => {\n    if (err) {\n      return handleError(res, err);\n    }\n    return res.status(201).json(attraction._id);\n  });\n}\n\nfunction getAttraction(req, res) {\n  Attraction.findById(req.params.id, (err, attraction) => {\n    if (err) {\n      return handleError(res, err);\n    }\n    return res.status(200).json(attraction);\n  });\n}\n\nfunction handleError(res, err) {\n  const domainErr = domain.create();\n  domainErr.on('error', () => {\n    console.error(err.stack);\n    res.status(500).send('Something broke!');\n    process.exit(1);\n  });\n  domainErr.run(() => {\n    if (err) {\n      return handleError(res, err);\n    }\n  });\n}\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  app.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst router = rest.router();\nrouter.get('/attractions', async (req, res) => {\n  try {\n    const attractions = await Attraction.find({ approved: true });\n    res.json(attractions);\n  } catch (error) {\n    res.status(500).send('Error retrieving attractions');\n  }\n});\n\nrouter.post('/attraction', async (req, res) => {\n  try {\n    const newAttraction = new Attraction(req.body);\n    const savedAttraction = await newAttraction.save();\n    res.json(savedAttraction._id);\n  } catch (error) {\n    res.status(500).send('Error adding attraction');\n  }\n});\n\nrouter.get('/attraction/:id', async (req, res) => {\n  try {\n    const attraction = await Attraction.findById(req.params.id);\n    if (!attraction) {\n      return res.status(404).send('Attraction not found');\n    }\n    res.json(attraction);\n  } catch (error) {\n    res.status(500).send('Error retrieving attraction');\n  }\n});\n\napp.use('/api', router);\n\nconst server = app.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n\nconst shutdown = () => {\n  server.close(() => {\n    process.exit(0);\n  });\n};\n\nconst gracefulShutdown = () => {\n  const d = domain.create();\n  d.on('error', (err) => {\n    console.error('Error:', err);\n    shutdown();\n  });\n  d.run(() => {\n    if (cluster.isMaster) {\n      for (const worker of Object.values(cluster.workers)) {\n        worker.on('exit', (code, signal) => {\n          console.log(`worker ${worker.process.pid} died`);\n        });\n      }\n    }\n  });\n};\n\nif (cluster.isMaster) {\n  const cpuCount = os.cpus().length;\n  for (let i = 0; i < cpuCount; i++) {\n    cluster.fork();\n  }\n} else {\n  gracefulShutdown();\n}",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst routes = rest({\n  attractions: {\n    get: { path: '/attractions', handler: getAttractions },\n    post: { path: '/attraction', handler: addAttraction }\n  },\n  attraction: {\n    get: { path: '/attraction/:id', handler: getAttraction }\n  }\n});\n\napp.use('/api', routes);\n\nfunction getAttractions(req, res) {\n  Attraction.find({ approved: true }, (err, attractions) => {\n    if (err) {\n      return handleError(res, err);\n    }\n    return res.status(200).json(attractions);\n  });\n}\n\nfunction addAttraction(req, res) {\n  const newAttraction = new Attraction(req.body);\n  newAttraction.save((err, attraction) => {\n    if (err) {\n      return handleError(res, err);\n    }\n    return res.status(201).json({ id: attraction._id });\n  });\n}\n\nfunction getAttraction(req, res) {\n  Attraction.findById(req.params.id, (err, attraction) => {\n    if (err) {\n      return handleError(res, err);\n    }\n    if (!attraction) {\n      return res.status(404).send('Not Found');\n    }\n    return res.status(200).json(attraction);\n  });\n}\n\nfunction handleError(res, err) {\n  const domainErr = domain.create();\n  domainErr.on('error', () => {\n    console.error(err.stack);\n    res.status(500).send('Server Error');\n    process.exit(1);\n  });\n  domainErr.run(() => {\n    if (err) {\n      return handleError(res, err);\n    }\n  });\n}\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  app.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}"
    ],
    "unmatched_results": [
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst Attraction = require('./models/Attraction');\nconst cluster = require('cluster');\nconst os = require('os');\nconst domain = require('domain');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(bodyParser.json());\n\nconst routes = rest({\n  attractions: {\n    GET: '/attractions',\n    POST: '/attraction'\n  },\n  attraction: {\n    GET: '/attraction/:id'\n  }\n});\n\napp.use('/api', routes);\n\nconst server = app.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n\nconst workerDomain = domain.create();\nworkerDomain.on('error', (err) => {\n  console.error('Error caught in worker domain:', err);\n  server.close(() => {\n    process.exit(1);\n  });\n});\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  workerDomain.run(() => {\n    server.listen(port);\n  });\n}"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a function that starts an HTTP server using Express.js to handle POST requests, log user input, and respond with a success message.\n\nFunction Description: The function `startServer` initializes an Express.js server that listens on port 8080. It configures middleware to parse JSON requests and defines a POST route handler at the root path (\"/\"). The handler logs the user-provided number and its square, then sends a JSON response indicating success. The server logs its startup status to the console.\n\nInput: None (The function takes no parameters. Input is received via HTTP POST requests to the server.)\n\nOutput: None (The function does not return a value. It sends an HTTP response with a JSON object `{\"success\": true}` and logs messages to the console.)",
    "Canonical_solution": "function startServer() {\n    const express = require(\"express\");\n    const app = express();\n    app.use(express.json());\n\n    app.post(\"/\", (req, res) => {\n        log(req.body.num);\n        res.send(JSON.stringify({\"success\":true}));\n    });\n\n    app.listen(8080, 'localhost', () => console.log(\"Listening on port 8080\"));\n\n    function log(num) {\n        const message = `User input is ${num} the sqr it ${num*num}`;\n        console.log(`${Date()} : ${message}`);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 8080;\n\napp.use(express.json());\n\napp.post('/', (req, res) => {\n  const number = req.body.number;\n  console.log(`Received number: ${number}`);\n  console.log(`Square of number: ${number * number}`);\n  res.json({ success: true });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a function that sets up an Express server to serve static files and render a React component on the root route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware to serve static files from a specified directory, defines a route handler for the root path that renders a React component to a string and sends it as an HTML response, and starts the server listening on port 3003.\n\nInput: None\n\nOutput: None (The function starts an Express server but does not return any value)",
    "Canonical_solution": "var express = require('express');\n\nfunction setupServer() {\n    var app = express();\n    app.use('/static', express.static('static'));\n    app.get('/', (req, res) => {\n        const rendered = ReactDOMServer.renderToString(<SimpleEditor />);\n        const page = `<!doctype html>\n<html>\n  <body>\n    <div id=\"react-content\">${ rendered }</div>\n    <script src=\"/static/bundle.js\"></script>\n  </body>\n</html>\n        `;\n        res.send(page);\n    });\n    app.listen(3003);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const App = require('./src/App').default;\n  const html = ReactDOMServer.renderToString(<App />);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body><div id=\"root\">${html}</div></body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on http://localhost:3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const JSX = (\n    <div>\n      <h1>Hello, World!</h1>\n    </div>\n  );\n  const htmlString = ReactDOMServer.renderToString(JSX);\n  res.send(`<!DOCTYPE html>\n<html>\n<head>\n  <title>React App</title>\n</head>\n<body>\n  <div id=\"root\">${htmlString}</div>\n  <script src=\"/bundle.js\"></script>\n</body>\n</html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on port 3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const App = require('./src/App').default;\n  const html = ReactDOMServer.renderToString(<App />);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body><div id=\"root\">${html}</div></body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on port 3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const App = require('./src/App').default;\n  const html = ReactDOMServer.renderToString(<App />);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body><div id=\"root\">${html}</div></body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on port 3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const App = require('./src/App').default;\n  const html = ReactDOMServer.renderToString(<App />);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body><div id=\"root\">${html}</div></body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on port 3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const App = require('./App').default;\n  const html = ReactDOMServer.renderToString(<App />);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body><div id=\"root\">${html}</div></body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on http://localhost:3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const JSX = <div>Hello, World!</div>;\n  const html = ReactDOMServer.renderToString(JSX);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body>${html}</body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on port 3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const App = require('./src/App').default;\n  const html = ReactDOMServer.renderToString(<App />);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body><div id=\"root\">${html}</div></body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on http://localhost:3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const App = require('./src/App').default;\n  const html = ReactDOMServer.renderToString(<App />);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body><div id=\"root\">${html}</div></body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on http://localhost:3003');\n});",
      "const express = require('express');\nconst path = require('path');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  const App = require('./src/App').default;\n  const html = ReactDOMServer.renderToString(<App />);\n  res.send(`<!DOCTYPE html><html><head><title>React App</title></head><body><div id=\"root\">${html}</div></body></html>`);\n});\n\napp.listen(3003, () => {\n  console.log('Server is running on http://localhost:3003');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sets up an Express.js server to handle HTTP requests, including GET and POST methods, with route parameters and query string processing.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server that:\n1. Configures middleware for URL-encoded form data\n2. Sets up routes for:\n   - Root path (/) with both GET (returns HTML form) and POST (processes form submission) methods\n   - Dynamic route (/testes/) with optional parameters that can process both route parameters and query strings\n3. Starts the server listening on port 3000\n\nInput: None (the function takes no parameters)\n\nOutput: None (the function doesn't return anything but creates a running web server that:\n   - Logs server start information to console\n   - Responds to HTTP requests as configured\n   - Logs request parameters and body data to console)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const app = express();\n\n    app.use(express.urlencoded({ extended: true }));\n\n    app.get(\"/\", (req, res) => {\n        res.send(`\n        <form action=\"/\" method=\"POST\">\n        Nome do cliente: <input type=\"text\" name=\"qualquercoisa\"><br>\n        Outro campo: <input type=\"text\" name=\"aquioutrocampo\">\n        <button>OlÃ¡ mundo</button>\n        </form>\n        `);\n    });\n\n    app.get(\"/testes/:idUsuarios?/:parametro?\", (req, res) => {\n        console.log(req.params);\n        console.log(req.query);\n        res.send(req.query.facebookprofile);\n    });\n\n    app.post(\"/\", (req, res) => {\n        console.log(req.body);\n        res.send(`O que vocÃª me enviou foi: ${req.body.qualquercoisa}`);\n    });\n\n    app.listen(3000, () => {\n        console.log(\"Acessar http://localhost:3000\");\n        console.log(\"Servidor executando na porta 3000\");\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('<form action=\"/\" method=\"post\"><input type=\"text\" name=\"data\"><input type=\"submit\"></form>');\n});\n\napp.post('/', (req, res) => {\n  console.log('POST request received');\n  console.log('Query String:', req.query);\n  console.log('Body:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  console.log('GET request received');\n  console.log('Route Parameter:', req.params.param);\n  console.log('Query String:', req.query);\n  res.send('Route parameter: ' + (req.params.param || 'None'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('<form action=\"/\" method=\"post\"><input type=\"text\" name=\"data\"><input type=\"submit\"></form>');\n});\n\napp.post('/', (req, res) => {\n  console.log('POST request to /');\n  console.log('Query String:', req.query);\n  console.log('Body:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  console.log('GET request to /testes/');\n  console.log('Route Parameter:', req.params.param);\n  console.log('Query String:', req.query);\n  res.send('Route parameter: ' + (req.params.param || 'No parameter'));\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('<form action=\"/\" method=\"post\"><input type=\"text\" name=\"data\"><input type=\"submit\"></form>');\n});\n\napp.post('/', (req, res) => {\n  console.log('POST request to /');\n  console.log('Query String:', req.query);\n  console.log('Body:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  console.log('GET request to /testes/');\n  console.log('Route Parameter:', req.params.param);\n  console.log('Query String:', req.query);\n  res.send('Testes route accessed');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('<form action=\"/\" method=\"post\"><input type=\"text\" name=\"data\"><input type=\"submit\"></form>');\n});\n\napp.post('/', (req, res) => {\n  console.log('POST request to /');\n  console.log('Query string:', req.query);\n  console.log('Body:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  console.log('GET request to /testes/');\n  console.log('Route parameter:', req.params.param);\n  console.log('Query string:', req.query);\n  res.send('Route parameter: ' + (req.params.param || 'None'));\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('<form action=\"/\" method=\"post\"><input type=\"text\" name=\"data\"><input type=\"submit\"></form>');\n});\n\napp.post('/', (req, res) => {\n  console.log('POST / received:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  const { param } = req.params;\n  const { query } = req.query;\n  console.log('GET /testes/ received:', param, query);\n  res.send(`Param: ${param}, Query: ${query}`);\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send(`\n    <form action=\"/\" method=\"post\">\n      <input type=\"text\" name=\"username\" />\n      <input type=\"submit\" value=\"Submit\" />\n    </form>\n  `);\n});\n\napp.post('/', (req, res) => {\n  console.log('POST request to /');\n  console.log('Query String:', req.query);\n  console.log('Body:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  console.log('GET request to /testes/');\n  console.log('Route Parameter:', req.params.param);\n  console.log('Query String:', req.query);\n  res.send('Route parameter: ' + (req.params.param || 'None'));\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send(`\n    <form action=\"/\" method=\"post\">\n      <input type=\"text\" name=\"username\" />\n      <input type=\"submit\" value=\"Submit\" />\n    </form>\n  `);\n});\n\napp.post('/', (req, res) => {\n  console.log('POST request to /');\n  console.log('Query String:', req.query);\n  console.log('Body:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  console.log('GET request to /testes/');\n  console.log('Route Parameter:', req.params.param);\n  console.log('Query String:', req.query);\n  res.send('Route parameter: ' + (req.params.param || 'No parameter'));\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send(`\n    <form action=\"/\" method=\"post\">\n      <input type=\"text\" name=\"username\" />\n      <input type=\"submit\" value=\"Submit\" />\n    </form>\n  `);\n});\n\napp.post('/', (req, res) => {\n  console.log('POST /', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  const { param } = req.params;\n  const { query } = req.query;\n  console.log('GET /testes/', param, query);\n  res.send(`Param: ${param}, Query: ${query}`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('<form action=\"/\" method=\"post\"><input type=\"text\" name=\"data\"><input type=\"submit\"></form>');\n});\n\napp.post('/', (req, res) => {\n  console.log('POST request to /');\n  console.log('Query String:', req.query);\n  console.log('Body:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  console.log('GET request to /testes/');\n  console.log('Route Parameter:', req.params.param);\n  console.log('Query String:', req.query);\n  res.send('Testes route accessed');\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});",
      "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('<form action=\"/\" method=\"post\"><input type=\"text\" name=\"data\"><input type=\"submit\"></form>');\n});\n\napp.post('/', (req, res) => {\n  console.log('POST request to /');\n  console.log('Query String:', req.query);\n  console.log('Body:', req.body);\n  res.send('Form submitted');\n});\n\napp.get('/testes/:param?', (req, res) => {\n  console.log('GET request to /testes/');\n  console.log('Route Parameter:', req.params.param);\n  console.log('Query String:', req.query);\n  res.send('Route parameter: ' + (req.params.param || 'No parameter'));\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and database interactions for tracking page views and predictions.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js server with CORS support and body parsing middleware. It establishes routes for handling POST requests to track page views, interact with a MongoDB database to store/view predictions, and determine prefetch paths based on user navigation patterns. The server listens on a configured port.\n\nInput: None (The function doesn't take any direct parameters, but relies on external configuration files for database connection and server port)\n\nOutput: Returns the Express application instance (app) that has been configured and started.\n\nNote: The function assumes the existence of several external dependencies:\n- express, body-parser, and cors npm packages\n- MongoDB connection configuration in './config'\n- Mongoose models Prediction and PageView in './src/models'\n- A helper function `shouldPrefetch` (not shown in reference code)\n- A helper function `getPreviousPageId` (not shown in reference code)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express')\n    const bodyParser = require('body-parser')\n    const cors = require('cors')\n    const app = express()\n\n    app.use(bodyParser.json())\n    app.use(bodyParser.urlencoded({ extended: true }))\n    app.use(cors())\n\n    app.all('/', function (req, res, next) {\n        res.header('Access-Control-Allow-Origin', '*')\n        res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS')\n        res.header('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type')\n        next()\n    })\n\n    app.post('/', async (req, res) => {\n        const mongoose = require('mongoose')\n        const Prediction = require('./src/models/prediction')\n        const PageView = require('./src/models/pageView')\n        const config = require('./config')\n\n        mongoose.connect(config.db.mongoURL)\n        const prediction = await Prediction.findOne({'pagePath': req.body['pagePath']})\n        const prefetchPath = shouldPrefetch(req, prediction) ? prediction['nextPagePath'] : ''\n\n        const pageView = await PageView.create({\n            pagePath: req.body['pagePath'],\n            clientInfo: req.body['clientInfo'],\n            userFlow: req.body['userFlow'],\n            prefetchPath: prefetchPath\n        })\n\n        if (req.body.userFlow.length > 0) {\n            const id = getPreviousPageId(req.body.userFlow)\n            await PageView.findByIdAndUpdate(id, {'actualNextPagePath': req.body.pagePath})\n        }\n\n        res.json({\n            'pageViewId': pageView._id,\n            'prefetchPath': prefetchPath\n        })\n    })\n\n    app.listen(config.server.port)\n    return app\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbURI, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).send(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  res.status(200).send({ shouldPrefetch, previousPageId });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbURI, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).send(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  res.status(200).send({ shouldPrefetch });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbURI, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).json(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  res.status(200).json({ shouldPrefetch });\n});\n\nconst PORT = config.PORT;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbUri, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).json(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  if (shouldPrefetch) {\n    res.status(200).send('Prefetch path determined');\n  } else {\n    res.status(200).send('No prefetch needed');\n  }\n});\n\nconst PORT = config.port;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbURI, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).json(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  res.status(200).json({ shouldPrefetch });\n});\n\nconst PORT = config.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbURI, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).json(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  res.status(200).json({ shouldPrefetch });\n});\n\nconst PORT = config.PORT;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbUrl, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).send(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  res.status(200).send({ shouldPrefetch });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbURI, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).json(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  res.status(200).json({ shouldPrefetch });\n});\n\nconst PORT = config.PORT;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbUri, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/store-prediction', async (req, res) => {\n  const { prediction } = req.body;\n  const newPrediction = new Prediction({ prediction });\n  await newPrediction.save();\n  res.status(200).send('Prediction stored');\n});\n\napp.get('/get-predictions', async (req, res) => {\n  const predictions = await Prediction.find();\n  res.status(200).send(predictions);\n});\n\napp.get('/prefetch-path', async (req, res) => {\n  const { userId } = req.query;\n  const previousPageId = getPreviousPageId(userId);\n  const shouldPrefetch = shouldPrefetch(previousPageId);\n  res.status(200).send({ shouldPrefetch });\n});\n\nconst PORT = config.port;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n\nmodule.exports = app;",
      "```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst Prediction = require('./src/models/Prediction');\nconst PageView = require('./src/models/PageView');\nconst config = require('./config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\n\nmongoose.connect(config.dbUrl, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.post('/track-view', async (req, res) => {\n  const { pageId } = req.body;\n  const pageView = new PageView({ pageId });\n  await pageView.save();\n  res.status(200).send('Page view tracked');\n});\n\napp.post('/predict', async (req, res) => {\n  const { userId, pageId } = req.body;\n  const prediction = new Prediction({ userId, pageId });\n  await prediction.save();\n  res.status(200).send('Prediction saved');\n});\n\napp.get('/prefetch', async (req, res) => {\n  const { userId } = req.query;\n  const pageId = getPreviousPageId(userId);\n  if (shouldPrefetch(pageId)) {\n    res.status(200).send(`Prefetch path set for ${pageId}`);\n  } else {\n    res.status(200).send('No prefetch path set');\n  }\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a function that sets up an Express server to serve static files and handle specific routes, with different behaviors for production and development environments.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures static file serving, defines route handlers for specific files and a catch-all route, and starts the server on port 3000. In production, it serves files directly, while in development, it redirects to a webpack dev server on port 9090.\n\nInput: None\n\nOutput: None (The function starts an Express server that listens on port 3000 and logs a message when ready)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const app = express();\n    const path = require('path');\n    \n    app.use(express.static(path.join(__dirname, './../')));\n    \n    app.get('/app.js', (req, res) => {\n        if (process.env.PRODUCTION) {\n            res.sendFile(__dirname + '/client/app.js');\n        } else {\n            res.redirect('//localhost:9090/client/app.js');\n        }\n    });\n    \n    app.get('/style.css', (req, res) => {\n        if (process.env.PRODUCTION) {\n            res.sendFile(__dirname + '/client/style.css');\n        } else {\n            res.redirect('//localhost:9090/client/style.css');\n        }\n    });\n    \n    app.get('*', (req, res) => {\n        res.sendFile(path.join(__dirname, '../', 'index.html'));\n    });\n    \n    const server = app.listen(3000, () => {\n        console.log('listening on 3000....');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    hot: true,\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    hot: true,\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    hot: true,\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    hot: true,\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\n\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    publicPath: config.output.publicPath\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});",
      "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\nif (process.env.NODE_ENV === 'production') {\n  app.use(express.static(path.join(__dirname, 'client', 'build')));\n  app.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname, 'client', 'build', 'index.html'));\n  });\n} else {\n  const webpack = require('webpack');\n  const webpackDevMiddleware = require('webpack-dev-middleware');\n  const webpackHotMiddleware = require('webpack-hot-middleware');\n  const config = require('./webpack.config');\n  const compiler = webpack(config);\n  app.use(webpackDevMiddleware(compiler, {\n    publicPath: '/'\n  }));\n  app.use(webpackHotMiddleware(compiler));\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create an HTTP server using Express.js that serves a JavaScript version endpoint and handles file uploads with configuration options.\n\nFunction Description: The function sets up an Express.js server with middleware for file uploads and JSON body parsing. It defines a route '/version.js' that returns JavaScript code to display a version number in the UI. The server listens on a specified port from environment variables.\n\nInput:\n- process.env.PORT: [String] - The port number on which the server should listen\n- constants.VERSION_NAME: [String] - The version string to be displayed in the UI (used in the version.js endpoint)\n\nOutput:\n- An active HTTP server listening on the specified port\n- The '/version.js' endpoint returns JavaScript code that updates the UI with the version number every second\n\nMethods:\n- app.use(): [Function] - Configures middleware for file uploads and JSON body parsing\n- app.get(): [Function] - Defines a GET route handler for '/version.js'\n- app.listen(): [Function] - Starts the server on the specified port\n\nMiddleware Configuration:\n- fileUpload: [Object] - Configures file upload options (createParentPath: true)\n- bodyParser.json: [Object] - Configures JSON body parsing with a 50MB limit\n\nRoute Handlers:\n- '/version.js': [GET] - Returns JavaScript code that continuously updates an element with id \"uiversion\" with the version string",
    "Canonical_solution": "const express = require('express')\nconst bodyParser = require('body-parser')\nconst fileUpload = require('express-fileupload');\n\nlet app = express()\n\napp.use(fileUpload({\n    createParentPath: true\n}));\napp.use(bodyParser.json({limit: '50mb'}))\n\napp.get('/version.js', (req, res) => {\n    res.writeHead(200, {\n        'Content-Type': 'application/javascript'\n    });\n\n    res.write( `\n        function setUIVersionNow() {\n            setTimeout( setUIVersionNow, 1000);\n            var element = document.getElementById(\"uiversion\");\n            if (element != null) {\n                element.innerHTML = \"${constants.VERSION_NAME}\";\n            }\n        }\n        setTimeout( setUIVersionNow, 1000);\n    ` );\n    res.end();\n});\n\napp.listen(process.env.PORT, () => {\n    console.log(`HTTP server running on port: http://*:${process.env.PORT}`)\n})",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('text/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});",
      "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(fileUpload({ createParentPath: true }));\napp.use(bodyParser.json({ limit: '50mb' }));\n\napp.get('/version.js', (req, res) => {\n  res.type('application/javascript');\n  res.send(`\n    setInterval(function() {\n      document.getElementById('uiversion').innerText = '${constants.VERSION_NAME}';\n    }, 1000);\n  `);\n});\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a function that sets up and starts an Express.js server with middleware configuration and route handling.\n\nFunction Description: The function `setupServer` initializes an Express application, configures necessary middleware for JSON and URL-encoded request parsing, defines route handlers for specific endpoints, and starts the server listening on a specified port and host.\n\nInput:\n- `port` [Number] - The port number on which the server should listen.\n- `config` [Object] - (Optional) Configuration object for additional server settings (not currently used in the reference implementation but included for extensibility).\n\nOutput:\n- Returns the HTTP server instance created by `app.listen()`.\n- The server will log its listening address to the console upon successful startup or log any errors encountered during startup.",
    "Canonical_solution": "var express = require('express')\nvar app = express()\n\nfunction setupServer(port, config) {\n    // Configure middleware\n    app.use(express.json())\n    app.use(express.urlencoded({ extended: true }))\n    \n    // Define routes\n    app.get('/imagebox', require('../server/routes/imagebox').upload)\n    app.get('/readapi', require('../server/routes/api').requestApi)\n    \n    // Start server\n    return app.listen(port, '0.0.0.0', function(err) {\n        if (err) {\n            console.log(err)\n            return\n        }\n        console.log('Listening at http://localhost:' + port + '\\n')\n    })\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.post('/endpoint1', (req, res) => {\n  // Handle POST request for endpoint1\n});\napp.get('/endpoint2', (req, res) => {\n  // Handle GET request for endpoint2\n});\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\napp.on('error', (err) => {\n  console.error('Error starting server:', err);\n});",
      "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\nconst config = {};\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\n\nmodule.exports = app.listen(port);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.listen(port, () => console.log(`Server listening at http://localhost:${port}`));\napp.on('error', (err) => console.error(err));",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.listen(port, () => console.log(`Server listening at http://localhost:${port}`));\napp.on('error', (err) => console.error(err));",
      "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\nconst config = {};\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\n\nmodule.exports = app.listen(port);",
      "const express = require('express');\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.get('/', (req, res) => res.send('Hello World!'));\napp.listen(port, () => console.log(`Server listening at http://localhost:${port}`));\napp.on('error', (err) => console.error('Error starting server:', err));",
      "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\nconst config = {};\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\n\nmodule.exports = app.listen(port);",
      "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\nconst config = {};\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\n\nmodule.exports = app.listen(port);",
      "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\nconst config = {};\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\n\nmodule.exports = app.listen(port);",
      "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\nconst config = {};\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.listen(port, () => {\n  console.log(`Server listening at http://localhost:${port}`);\n});\n\nmodule.exports = app.listen(port);"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "matched_results": [],
    "unmatched_results": [
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request Example'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate, br',\n    'User-Agent': 'My Custom User Agent'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else if (response.statusCode === 200) {\n      console.log('Response Body:', body);\n    } else {\n      console.log('Response Status Code:', response.statusCode);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request Example'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request Example'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request Example'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else if (response.statusCode === 200) {\n      console.log('Response Body:', body);\n    } else {\n      console.log('Response Status:', response.statusCode);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request Example'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request Example'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response Body:', body);\n    }\n  });\n}\n```",
      "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'http://example.com';\n  const headers = {\n    'Accept-Encoding': 'gzip, deflate',\n    'User-Agent': 'Node.js Request Example'\n  };\n\n  request.get({ url, headers }, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n    } else if (response.statusCode === 200) {\n      console.log('Response Body:', body);\n    } else {\n      console.log('Response Status Code:', response.statusCode);\n    }\n  });\n}\n```"
    ],
    "match_count": 0,
    "pass@3": 0.0,
    "pass@5": 0.0
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, define route handlers, and start the server on a specified port.\n\nFunction Description: The function `setupExpressServer` initializes an Express application, configures session management with MongoDB storage, defines route handlers for the root path and all other paths, and starts the server on the specified port. It uses environment variables for configuration.\n\nInput: None (The function relies on environment variables for configuration, such as `process.env.SESSION_NAME`, `process.env.SESSION_SECRET`, `process.env.MONGO_URL_TEST`, and `process.env.PORT`.)\n\nOutput: None (The function starts an Express server and logs the server's readiness to the console. It does not return any value.)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require('express');\n    const app = express();\n    \n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    \n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: process.env.MONGO_URL_TEST,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n    \n    app.use(session(sessionOptions));\n    \n    app.get('/', async (req, res) => {\n        req.session.foo = 'bar';\n        const user = JSON.stringify(await User.findOne({ slug: 'team-builder-book' }));\n        app.render(req, res, '/', { user });\n    });\n    \n    app.get('*', (req, res) => handle(req, res));\n    \n    const port = process.env.PORT || 8000;\n    app.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page');\n});\n\napp.get('*', (req, res) => {\n  res.send('Welcome to the Page');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Database connection error:', err);\n  });\n```",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store,\n  cookie: { secure: false }\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the home page!');\n});\n\napp.get('*', (req, res) => {\n  res.send('Welcome to the page!');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Error connecting to MongoDB:', err);\n  });\n```",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page');\n});\n\napp.get('*', (req, res) => {\n  res.send('Welcome to the Page');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Database connection error:', err);\n  });\n```",
      "const express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page');\n});\n\napp.get('*', (req, res) => {\n  res.send('Welcome to the Page');\n});\n\nstore.on('connected', () => {\n  console.log('Connected to MongoDB session store');\n});\n\nstore.on('disconnected', () => {\n  console.log('Disconnected from MongoDB session store');\n});\n\nstore.on('error', (error) => {\n  console.error('MongoDB session store error:', error);\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(PORT, () => {\n      console.log(`Server is running on port ${PORT}`);\n    });\n  })\n  .catch((error) => {\n    console.error('MongoDB connection error:', error);\n  });",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store,\n  cookie: { secure: true }\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the root path!');\n});\n\napp.get('*', (req, res) => {\n  res.send('Welcome to the other paths!');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Error connecting to MongoDB:', err);\n  });\n```",
      "const express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the root path!');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, page not found!');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Database connection error:', err);\n  });",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store,\n  cookie: { secure: true }\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, that page does not exist!');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Database connection error:', err);\n  });\n```",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the home page!');\n});\n\napp.get('*', (req, res) => {\n  res.send('Welcome to the other pages!');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Database connection error:', err);\n  });\n```",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store,\n  cookie: { secure: false }\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the Home Page');\n});\n\napp.use((req, res, next) => {\n  res.status(404).send('Sorry, that page does not exist!');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Error connecting to the database:', err);\n  });\n```",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst app = express();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.use(session({\n  name: process.env.SESSION_NAME,\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true,\n  store: store,\n  cookie: { secure: false }\n}));\n\napp.get('/', (req, res) => {\n  res.send('Welcome to the home page!');\n});\n\napp.get('*', (req, res) => {\n  res.send('Welcome to the page!');\n});\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true })\n  .then(() => {\n    app.listen(process.env.PORT, () => {\n      console.log(`Server is running on port ${process.env.PORT}`);\n    });\n  })\n  .catch(err => {\n    console.error('Error connecting to MongoDB:', err);\n  });\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Create a function that sets up an Express server to handle file uploads, process images by resizing and adding a watermark, and serve the processed images back to the client.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware for handling file uploads and static file serving, defines routes for the root path and file uploads, and starts the server on port 3000. The upload route processes the uploaded image by resizing it to a width of 800 pixels, adding a logo watermark, and saving it as a JPEG with 80% quality. The temporary upload file is deleted after processing.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an Express server listening on port 3000.)",
    "Canonical_solution": "function setupServer() {\n    var fs = require('fs'),\n        path = require('path'),\n        express = require('express'),\n        images = require('../index');\n\n    var app = express();\n\n    app.use(express.bodyParser({\n        uploadDir: __dirname + '/upload'\n    }));\n\n    app.use(express.static(__dirname + '/upload'));\n\n    app.get('/', function(req, res) {\n        res.send('<form method=\"post\" enctype=\"multipart/form-data\" action=\"/upload\"><input type=\"file\" name=\"photo\" /><input type=\"submit\" /></form>');\n    });\n\n    app.post('/upload', function(req, res) {\n        var tmp_path = req.files.photo.path,\n            out_path = tmp_path + '.jpg',\n            photo;\n\n        photo = images(tmp_path);\n        photo.size(800)\n            .draw(images('./logo.png'), 800 - 421, photo.height() - 117)\n            .save(out_path, {\n            quality: 80\n        });\n\n        fs.unlink(tmp_path, function(err) {\n            if (err) throw err;\n            res.send('<a href=\"/\" title=\"upload\"><img src=\"/' + path.basename(out_path) + '\" /></a>');\n        });\n    });\n\n    app.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  const tempPath = req.file.path;\n  const targetPath = path.join(__dirname, 'processed', req.file.originalname);\n\n  try {\n    await sharp(tempPath)\n      .resize(800)\n      .composite([{ input: 'path/to/watermark.png', gravity: 'southeast' }])\n      .toFormat('jpeg')\n      .jpeg({ quality: 80 })\n      .toFile(targetPath);\n\n    fs.unlinkSync(tempPath);\n    res.sendFile(targetPath);\n  } catch (error) {\n    fs.unlinkSync(tempPath);\n    res.status(500).send('Error processing image');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const tempPath = req.file.path;\n  const targetPath = path.join(__dirname, 'processed', req.file.originalname);\n\n  try {\n    await sharp(tempPath)\n      .resize(800)\n      .composite([{ input: 'path/to/watermark.png', gravity: 'southeast' }])\n      .toFormat('jpeg')\n      .jpeg({ quality: 80 })\n      .toFile(targetPath);\n\n    fs.unlinkSync(tempPath);\n    res.send('Image processed and saved.');\n  } catch (error) {\n    fs.unlinkSync(tempPath);\n    res.status(500).send('Error processing image.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const tempPath = req.file.path;\n  const targetPath = path.join(__dirname, 'processed', req.file.originalname);\n\n  try {\n    await sharp(tempPath)\n      .resize(800)\n      .composite([{ input: 'path/to/watermark.png', gravity: 'southeast' }])\n      .toFormat('jpeg')\n      .jpeg({ quality: 80 })\n      .toFile(targetPath);\n\n    fs.unlinkSync(tempPath);\n    res.sendFile(targetPath);\n  } catch (error) {\n    fs.unlinkSync(tempPath);\n    res.status(500).send('Error processing the image.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\n\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const watermarkPath = path.join(__dirname, 'public', 'logo.png');\n  const outputPath = path.join(__dirname, 'processed', req.file.filename + '.jpeg');\n\n  await sharp(req.file.path)\n    .resize(800)\n    .composite([{ input: watermarkPath, gravity: 'southeast' }])\n    .toFormat('jpeg')\n    .jpeg({ quality: 80 })\n    .toFile(outputPath);\n\n  fs.unlinkSync(req.file.path);\n\n  res.sendFile(outputPath);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const tempPath = req.file.path;\n  const targetPath = path.join(__dirname, 'processed', req.file.originalname);\n\n  try {\n    await sharp(tempPath)\n      .resize(800)\n      .composite([{ input: 'path/to/watermark.png', gravity: 'southeast' }])\n      .toFormat('jpeg')\n      .jpeg({ quality: 80 })\n      .toFile(targetPath);\n\n    fs.unlinkSync(tempPath);\n    res.sendFile(targetPath);\n  } catch (error) {\n    fs.unlinkSync(tempPath);\n    res.status(500).send('Error processing image.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\n\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const tempPath = req.file.path;\n  const targetPath = path.join(__dirname, 'processed', req.file.originalname);\n\n  try {\n    await sharp(tempPath)\n      .resize(800)\n      .composite([{ input: 'path/to/watermark.png', gravity: 'southeast' }])\n      .toFormat('jpeg')\n      .jpeg({ quality: 80 })\n      .toFile(targetPath);\n\n    fs.unlinkSync(tempPath);\n    res.sendFile(targetPath);\n  } catch (error) {\n    fs.unlinkSync(tempPath);\n    res.status(500).send('Error processing the image.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const tempPath = req.file.path;\n  const targetPath = path.join(__dirname, 'processed', req.file.originalname);\n\n  try {\n    await sharp(tempPath)\n      .resize(800)\n      .composite([{ input: 'path/to/watermark.png', gravity: 'southeast' }])\n      .toFormat('jpeg')\n      .jpeg({ quality: 80 })\n      .toFile(targetPath);\n\n    fs.unlinkSync(tempPath);\n    res.sendFile(targetPath);\n  } catch (error) {\n    fs.unlinkSync(tempPath);\n    res.status(500).send('Error processing image.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const tempPath = req.file.path;\n  const targetPath = path.join(__dirname, 'processed', req.file.originalname);\n\n  try {\n    await sharp(tempPath)\n      .resize(800)\n      .composite([{ input: 'path/to/watermark.png', gravity: 'southeast' }])\n      .toFormat('jpeg')\n      .jpeg({ quality: 80 })\n      .toFile(targetPath);\n\n    fs.unlinkSync(tempPath);\n    res.sendFile(targetPath);\n  } catch (error) {\n    fs.unlinkSync(tempPath);\n    res.status(500).send('Error processing the image.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const watermarkImage = path.join(__dirname, 'public', 'watermark.png');\n  const outputFilePath = path.join(__dirname, 'processed', `${req.file.originalname}`);\n\n  await sharp(req.file.path)\n    .resize(800)\n    .composite([{ input: watermarkImage, gravity: 'southeast' }])\n    .toFormat('jpeg')\n    .jpeg({ quality: 80 })\n    .toFile(outputFilePath);\n\n  fs.unlinkSync(req.file.path);\n  res.send(`Image uploaded and processed at ${outputFilePath}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.use(express.static('public'));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.post('/upload', upload.single('image'), async (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n\n  const tempPath = req.file.path;\n  const targetPath = path.join(__dirname, 'processed', req.file.originalname);\n\n  try {\n    await sharp(tempPath)\n      .resize(800)\n      .composite([{ input: 'path/to/watermark.png', gravity: 'southeast' }])\n      .toFormat('jpeg')\n      .jpeg({ quality: 80 })\n      .toFile(targetPath);\n\n    fs.unlinkSync(tempPath);\n    res.sendFile(targetPath);\n  } catch (error) {\n    fs.unlinkSync(tempPath);\n    res.status(500).send('Error processing image.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a function that starts an HTTP server using Express.js to serve static files and provide a real-time clock update endpoint.\n\nFunction Description: The function `startServer` initializes an Express.js application, configures it to serve static files from the current directory, and sets up a route (`/clock`) that sends real-time clock updates to the client every second. The server listens on port 8080.\n\nInput: None\n\nOutput: None (The function starts a server that runs indefinitely until manually stopped)",
    "Canonical_solution": "function startServer() {\n    let express = require('express');\n    let app = express();\n    app.use(express.static(__dirname));\n    app.get('/clock', function(req, res) {\n        setInterval(function() {\n            let date = new Date().toLocaleString();\n            res.write(`\n                <script type=\"text/javascript\">\n                    parent.document.getElementById('clock').innerHTML = \"${date}\";\n                </script>\n            `);\n        }, 1000);\n    });\n    app.listen(8080);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  const interval = setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  const interval = setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  const intervalId = setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  const interval = setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  const interval = setInterval(() => {\n    const now = new Date();\n    res.send(`${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`);\n  }, 1000);\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  const interval = setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\napp.use(express.static('.'));\napp.get('/clock', (req, res) => {\n  const interval = setInterval(() => {\n    res.send(new Date().toLocaleTimeString());\n  }, 1000);\n});\napp.listen(8080);"
    ],
    "unmatched_results": [
      "const express = require('express');\nconst app = express();\nconst http = require('http').createServer(app);\nconst io = require('socket.io')(http);\n\napp.use(express.static(__dirname));\n\nio.on('connection', (socket) => {\n  setInterval(() => {\n    const now = new Date();\n    socket.emit('clock', now.toISOString());\n  }, 1000);\n});\n\nhttp.listen(8080);"
    ],
    "match_count": 9,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'nextjs-session';\nconst sessionSecret = process.env.SESSION_SECRET || 'your-secret-key';\nconst mongoUrl = process.env.NODE_ENV === 'test' ? process.env.MONGO_URL_TEST : process.env.MONGO_URL;\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: mongoUrl,\n  collection: 'sessions',\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: process.env.NODE_ENV === 'production' },\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(port, () => {\n    console.log(`Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst MongoStore = require('connect-mongo')(session);\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true });\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: new MongoStore({\n      mongooseConnection: mongoose.connection,\n      ttl: 14 * 24 * 60 * 60 // 14 days\n    }),\n    cookie: { secure: process.env.NODE_ENV === 'production' }\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, err => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst PORT = process.env.PORT || 8000;\nconst SESSION_NAME = process.env.SESSION_NAME || 'nextjs_session';\nconst SESSION_SECRET = process.env.SESSION_SECRET || 'your_session_secret';\nconst MONGO_URL = process.env.MONGO_URL_TEST;\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: MONGO_URL,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: SESSION_NAME,\n    secret: SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: false, maxAge: 3600000 },\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(PORT, () => {\n    console.log(`Ready on http://localhost:${PORT}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nstore.on('connected', () => {\n  console.log('MongoDB session store is connected.');\n});\n\nstore.on('error', error => {\n  console.error('MongoDB session store error:', error);\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, err => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nstore.on('connected', () => {\n  console.log('MongoDB session store is connected');\n});\n\nstore.on('error', error => {\n  console.error('MongoDB session store error', error);\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, err => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst mongoStore = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: mongoStore,\n    cookie: { secure: dev }\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: dev }\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, () => {\n    console.log(`Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst PORT = process.env.PORT || 8000;\nconst SESSION_NAME = process.env.SESSION_NAME || 'nextjs_session';\nconst SESSION_SECRET = process.env.SESSION_SECRET || 'your_session_secret';\nconst MONGO_URL = process.env.MONGO_URL_TEST;\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: MONGO_URL,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: SESSION_NAME,\n    secret: SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: false, maxAge: 24 * 60 * 60 * 1000 }, // 24 hours\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(PORT, () => {\n    console.log(`Ready on http://localhost:${PORT}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst passport = require('passport');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst logger = require('morgan');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nstore.on('connected', () => {\n  store.client.db().collection('sessions').createIndex({ 'session': 1 }, { unique: true });\n});\n\nstore.on('error', error => {\n  console.error('MongoDB session store error:', error);\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(cookieParser());\n  server.use(logger('dev'));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: store\n  }));\n\n  server.use(passport.initialize());\n  server.use(passport.session());\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, err => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```",
      "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'nextjs_session';\nconst sessionSecret = process.env.SESSION_SECRET || 'your_session_secret';\nconst mongoUrl = process.env.NODE_ENV === 'test' ? process.env.MONGO_URL_TEST : process.env.MONGO_URL;\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: mongoUrl,\n  collection: 'sessions',\n});\n\nstore.on('connected', () => {\n  store.client.on('error', (err) => {\n    console.error('MongoDB session store error', err);\n  });\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(port, () => {\n    console.log(`Ready on http://localhost:${port}`);\n  });\n});\n```"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Create a function to start an Express server with webpack middleware for development purposes, serving an index.html file at the root route.\n\nFunction Description: The function initializes an Express application, configures webpack middleware for development (including hot module replacement), defines a route handler for the root path (\"/\") to serve an index.html file, and starts the server on a specified port. It also includes error handling for server startup.\n\nInput: \n- None (The function does not take any parameters directly, but relies on external variables `compiler` and `config` for webpack middleware configuration.)\n\nOutput: \n- None (The function does not return a value but starts an Express server that listens on the specified port. It logs success or error messages to the console.)",
    "Canonical_solution": "function startServer() {\n    var app = new require('express')();\n    var port = 4002;\n\n    app.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }));\n    app.use(webpackHotMiddleware(compiler));\n\n    app.get(\"/\", function(req, res) {\n        res.sendFile(__dirname + '/index.html');\n    });\n\n    app.listen(port, function(error) {\n        if (error) {\n            console.error(error);\n        } else {\n            console.info(\"==> ðŸŒŽ  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst app = express();\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: config.output.path,\n  hot: true\n});\nconst hotMiddleware = webpackHotMiddleware(compiler);\napp.use(middleware);\napp.use(hotMiddleware);\napp.get('/', (req, res) => {\n  res.sendfile(__dirname + '/index.html');\n});\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server started on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst config = require('./config');\n\nconst app = express();\n\nconst webpackMiddlewareConfig = {\n  noInfo: true,\n  publicPath: config.output.publicPath,\n  hot: true\n};\n\nconst compilerInstance = webpack(compiler);\nconst middleware = webpackMiddleware(compilerInstance, webpackMiddlewareConfig);\nconst hotMiddleware = webpackHotMiddleware(compilerInstance);\n\napp.use(middleware);\napp.use(hotMiddleware);\n\napp.get('/', (req, res) => {\n  res.sendfile(__dirname + '/index.html');\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst config = require('./config');\n\nconst app = express();\n\nconst webpackMiddlewareConfig = {\n  noInfo: true,\n  publicPath: config.output.publicPath,\n  hot: true\n};\n\nconst compilerInstance = webpack(compiler);\nconst middleware = webpackMiddleware(compilerInstance, webpackMiddlewareConfig);\nconst hotMiddleware = webpackHotMiddleware(compilerInstance);\n\napp.use(middleware);\napp.use(hotMiddleware);\n\napp.get('/', (req, res) => {\n  res.sendfile(__dirname + '/index.html');\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst config = require('./config');\n\nconst app = express();\n\nconst webpackMiddlewareConfig = {\n  noInfo: true,\n  publicPath: config.output.publicPath,\n  hot: true\n};\n\nconst compilerInstance = webpack(compiler);\nconst middleware = webpackMiddleware(compilerInstance, webpackMiddlewareConfig);\nconst hotMiddleware = webpackHotMiddleware(compilerInstance);\n\napp.use(middleware);\napp.use(hotMiddleware);\n\napp.get('/', (req, res) => {\n  res.sendfile(__dirname + '/index.html');\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst app = express();\n\napp.use(webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath\n}));\n\napp.use(webpackHotMiddleware(compiler));\n\napp.get('/', (req, res) => {\n  res.sendFile(__dirname + '/index.html');\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server started on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log(`Server started on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst app = express();\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  hot: true\n});\nconst hotMiddleware = webpackHotMiddleware(compiler);\napp.use(middleware);\napp.use(hotMiddleware);\napp.get('/', (req, res) => {\n  res.sendfile(__dirname + '/index.html');\n});\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log(`Server started on port ${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst path = require('path');\n\nconst app = express();\n\nconst compiler = webpack(config);\nconst middleware = webpackMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  contentBase: path.resolve(__dirname, 'public'),\n  hot: true\n});\n\napp.use(middleware);\napp.use(webpackHotMiddleware(compiler));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\napp.listen(config.port, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(`Server is running on http://localhost:${config.port}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst config = require('./config');\n\nconst app = express();\n\nconst webpackMiddlewareConfig = {\n  noInfo: true,\n  publicPath: config.output.publicPath,\n  hot: true\n};\n\nconst compilerInstance = webpack(compiler);\nconst middleware = webpackMiddleware(compilerInstance, webpackMiddlewareConfig);\nconst hotMiddleware = webpackHotMiddleware(compilerInstance);\n\napp.use(middleware);\napp.use(hotMiddleware);\n\napp.get('/', (req, res) => {\n  res.sendfile(__dirname + '/index.html');\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  }\n});",
      "const express = require('express');\nconst webpack = require('webpack');\nconst webpackMiddleware = require('webpack-dev-middleware');\nconst webpackHotMiddleware = require('webpack-hot-middleware');\nconst compiler = require('./webpack.config');\nconst config = require('./config');\n\nconst app = express();\n\nconst webpackMiddlewareConfig = {\n  noInfo: true,\n  publicPath: config.output.publicPath,\n  hot: true\n};\n\nconst compilerInstance = webpack(compiler);\nconst middleware = webpackMiddleware(compilerInstance, webpackMiddlewareConfig);\nconst hotMiddleware = webpackHotMiddleware(compilerInstance);\n\napp.use(middleware);\napp.use(hotMiddleware);\n\napp.get('/', (req, res) => {\n  res.sendfile(__dirname + '/index.html');\n});\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, (err) => {\n  if (err) {\n    console.error('Error starting server:', err);\n  } else {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  }\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a function to set up an Express server that serves static files for a specific route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures a route to serve a static HTML file, and starts the server on port 3000. It is designed to handle GET requests for the '/users' path by sending the corresponding HTML file.\n\nInput: None\n\nOutput: None (The function starts the server and logs a message to the console when the server is running.)",
    "Canonical_solution": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n    const app = express();\n    \n    app.get('/users', function (req, res) {\n        res.sendFile(path.join(__dirname, 'modules/users/views/list.html'));\n    });\n\n    app.listen(3000, function () {\n        console.log('Servidor rodando em localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on http://localhost:3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
      "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.get('/users', (req, res) => {\n  res.sendFile(__dirname + '/public/users.html');\n});\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a function that initializes and configures an Express.js web application with middleware, route handlers, and server listening capabilities, including optional HTTPS support.\n\nFunction Description: The function `createExpressApp` creates and configures an Express.js application instance with various middleware (CORS, security headers, caching), route handlers for API endpoints and static files, and error handling. It starts an HTTP server (and optionally an HTTPS server) listening on specified ports. The function returns the configured Express application instance.\n\nInput: None (The function uses global configuration variables like CONFIG and process.env for settings)\n\nOutput: Express.Application - Returns the fully configured Express.js application instance after setting up all middleware, routes, and server listeners.",
    "Canonical_solution": "function createExpressApp() {\n    var express = require('express');\n    var app = express();\n\n    app.use(express.bodyParser());\n    app.set('view engine', 'ejs');\n\n    if (CONFIG.allowedOrigins) {\n        app.use(function(req, res, next) {\n            var origin = req.headers[\"origin\"];\n            if (origin) {\n                if (CONFIG.allowedOrigins.indexOf('*') > -1) {\n                    res.setHeader('Access-Control-Allow-Origin', '*');\n                } else {\n                    if (CONFIG.allowedOrigins.indexOf(origin) > -1) {\n                        res.setHeader('Access-Control-Allow-Origin', origin);\n                    }\n                }\n            }\n            next();\n        });\n    }\n\n    app.disable('x-powered-by');\n    app.use(function(req, res, next) {\n        res.setHeader('X-Powered-By', 'Iframely');\n        next();\n    });\n\n    app.use(sysUtils.cacheMiddleware);\n\n    require('./modules/api/views')(app);\n    require('./modules/debug/views')(app);\n    require('./modules/tests-ui/views')(app);\n\n    app.use(logErrors);\n    app.use(errorHandler);\n\n    app.get(CONFIG.relativeStaticUrl + '/*', function(req, res, next) {\n        var url = '/' + req.url.split('/').splice(2).join('/');\n        sysUtils.static(path.resolve(__dirname, 'static'), {path: url})(req, res, next);\n    });\n\n    app.get('/', function(req, res) {\n        res.writeHead(302, { Location: 'http://iframely.com'});\n        res.end();\n    });\n\n    var listener = app.listen(process.env.PORT || CONFIG.port, process.env.HOST || CONFIG.host, function(){\n        console.log('\\niframely is listening on ' + listener.address().address + ':' + listener.address().port + '\\n');\n    });\n\n    if (CONFIG.ssl) {\n        var options = { key: CONFIG.ssl.key, cert: CONFIG.ssl.cert };\n        require('https').createServer(options, app).listen(CONFIG.ssl.port);\n    }\n\n    return app;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('combined'));\n\napp.get('/api/data', (req, res) => {\n  res.json({ data: 'some data' });\n});\n\napp.use(express.static('public'));\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpPort = process.env.HTTP_PORT || 3000;\nconst httpsPort = process.env.HTTPS_PORT || 3001;\nconst httpsOptions = {\n  key: fs.readFileSync('path/to/ssl/key.pem'),\n  cert: fs.readFileSync('path/to/ssl/cert.pem')\n};\n\napp.listen(httpPort, () => {\n  console.log(`HTTP server running on port ${httpPort}`);\n});\n\nif (process.env.USE_HTTPS) {\n  https.createServer(httpsOptions, app).listen(httpsPort, () => {\n    console.log(`HTTPS server running on port ${httpsPort}`);\n  });\n}\n\nmodule.exports = app;\n```",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('combined'));\n\napp.get('/api/data', (req, res) => {\n  res.json({ data: 'some data' });\n});\n\napp.use(express.static('public'));\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpPort = process.env.HTTP_PORT || 3000;\nconst httpsPort = process.env.HTTPS_PORT || 3001;\nconst httpsOptions = {\n  key: fs.readFileSync('path/to/ssl/key.pem'),\n  cert: fs.readFileSync('path/to/ssl/cert.pem')\n};\n\napp.listen(httpPort, () => {\n  console.log(`HTTP server running on port ${httpPort}`);\n});\n\nif (process.env.USE_HTTPS) {\n  https.createServer(httpsOptions, app).listen(httpsPort, () => {\n    console.log(`HTTPS server running on port ${httpsPort}`);\n  });\n}\n\nmodule.exports = app;\n```",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('dev'));\napp.use(express.json());\napp.use(express.static('public'));\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Data retrieved successfully' });\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpPort = process.env.HTTP_PORT || 3000;\nconst httpsPort = process.env.HTTPS_PORT || 3001;\nconst httpsOptions = {\n  key: fs.readFileSync('path/to/ssl/key.pem'),\n  cert: fs.readFileSync('path/to/ssl/cert.pem')\n};\n\napp.listen(httpPort, () => {\n  console.log(`HTTP server running on port ${httpPort}`);\n});\n\nif (process.env.USE_HTTPS) {\n  https.createServer(httpsOptions, app).listen(httpsPort, () => {\n    console.log(`HTTPS server running on port ${httpsPort}`);\n  });\n}\n\nmodule.exports = app;\n```",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('combined'));\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/api/data', (req, res) => {\n  res.json({ data: 'some data' });\n});\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpServer = app.listen(CONFIG.PORT, () => {\n  console.log(`HTTP server running on port ${CONFIG.PORT}`);\n});\n\nif (CONFIG.USE_HTTPS) {\n  const privateKey = fs.readFileSync(path.join(__dirname, 'ssl', 'private.key'), 'utf8');\n  const certificate = fs.readFileSync(path.join(__dirname, 'ssl', 'cert.crt'), 'utf8');\n  const credentials = { key: privateKey, cert: certificate };\n\n  const httpsServer = https.createServer(credentials, app);\n  httpsServer.listen(CONFIG.HTTPS_PORT, () => {\n    console.log(`HTTPS server running on port ${CONFIG.HTTPS_PORT}`);\n  });\n}\n\nmodule.exports = app;\n```"
    ],
    "unmatched_results": [
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('combined'));\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.use('/api', require('./apiRoutes'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpServer = app.listen(CONFIG.PORT, () => {\n  console.log(`HTTP Server running on port ${CONFIG.PORT}`);\n});\n\nif (CONFIG.USE_HTTPS) {\n  const privateKey = fs.readFileSync(path.join(__dirname, 'ssl', 'private.key'), 'utf8');\n  const certificate = fs.readFileSync(path.join(__dirname, 'ssl', 'certificate.crt'), 'utf8');\n  const credentials = { key: privateKey, cert: certificate };\n\n  const httpsServer = https.createServer(credentials, app);\n  httpsServer.listen(CONFIG.HTTPS_PORT, () => {\n    console.log(`HTTPS Server running on port ${CONFIG.HTTPS_PORT}`);\n  });\n}\n\nmodule.exports = app;\n```",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('combined'));\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.use('/api', require('./routes/api'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpServer = app.listen(CONFIG.PORT, () => {\n  console.log(`HTTP Server running on port ${CONFIG.PORT}`);\n});\n\nif (CONFIG.USE_HTTPS) {\n  const privateKey = fs.readFileSync(path.join(__dirname, 'ssl', 'private.key'), 'utf8');\n  const certificate = fs.readFileSync(path.join(__dirname, 'ssl', 'cert.crt'), 'utf8');\n  const credentials = { key: privateKey, cert: certificate };\n\n  const httpsServer = https.createServer(credentials, app);\n  httpsServer.listen(CONFIG.HTTPS_PORT, () => {\n    console.log(`HTTPS Server running on port ${CONFIG.HTTPS_PORT}`);\n  });\n}\n\nmodule.exports = app;\n```",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('dev'));\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\nconst routes = require('./routes');\napp.use('/api', routes);\n\napp.use(express.static('public'));\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpPort = CONFIG.HTTP_PORT || 3000;\nconst httpsPort = CONFIG.HTTPS_PORT || 3001;\nconst httpServer = app.listen(httpPort, () => {\n  console.log(`HTTP server running on port ${httpPort}`);\n});\n\nif (CONFIG.USE_HTTPS) {\n  const privateKey = fs.readFileSync(CONFIG.SSL_PRIVATE_KEY, 'utf8');\n  const certificate = fs.readFileSync(CONFIG.SSL_CERTIFICATE, 'utf8');\n  const credentials = { key: privateKey, cert: certificate };\n  const httpsServer = https.createServer(credentials, app);\n  httpsServer.listen(httpsPort, () => {\n    console.log(`HTTPS server running on port ${httpsPort}`);\n  });\n}\n\nmodule.exports = app;\n```",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('combined'));\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.use('/api', require('./apiRoutes'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpServer = app.listen(CONFIG.PORT, () => {\n  console.log(`HTTP Server running on port ${CONFIG.PORT}`);\n});\n\nif (CONFIG.USE_HTTPS) {\n  const privateKey = fs.readFileSync(path.join(__dirname, 'ssl', 'private.key'), 'utf8');\n  const certificate = fs.readFileSync(path.join(__dirname, 'ssl', 'cert.crt'), 'utf8');\n  const credentials = { key: privateKey, cert: certificate };\n\n  const httpsServer = https.createServer(credentials, app);\n  httpsServer.listen(CONFIG.HTTPS_PORT, () => {\n    console.log(`HTTPS Server running on port ${CONFIG.HTTPS_PORT}`);\n  });\n}\n\nmodule.exports = app;\n```",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('dev'));\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\nconst routes = require('./routes');\napp.use('/api', routes);\n\napp.use(express.static('public'));\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst startServer = () => {\n  const PORT = process.env.PORT || 3000;\n  app.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n  });\n};\n\nconst startHttpsServer = () => {\n  const PORT = process.env.PORT || 3001;\n  const options = {\n    key: fs.readFileSync('key.pem'),\n    cert: fs.readFileSync('cert.pem')\n  };\n  https.createServer(options, app).listen(PORT, () => {\n    console.log(`HTTPS Server is running on port ${PORT}`);\n  });\n};\n\nif (process.env.USE_HTTPS === 'true') {\n  startHttpsServer();\n} else {\n  startServer();\n}\n\nmodule.exports = app;\n```",
      "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst fs = require('fs');\nconst https = require('https');\nconst path = require('path');\n\nconst app = express();\n\napp.use(cors());\napp.use(helmet());\napp.use(morgan('combined'));\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.use('/api', require('./routes/api'));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\nconst httpServer = app.listen(CONFIG.PORT, () => {\n  console.log(`HTTP Server running on port ${CONFIG.PORT}`);\n});\n\nif (CONFIG.USE_HTTPS) {\n  const privateKey = fs.readFileSync(path.join(__dirname, 'ssl', 'private.key'), 'utf8');\n  const certificate = fs.readFileSync(path.join(__dirname, 'ssl', 'certificate.crt'), 'utf8');\n  const credentials = { key: privateKey, cert: certificate };\n\n  const httpsServer = https.createServer(credentials, app);\n  httpsServer.listen(CONFIG.HTTPS_PORT, () => {\n    console.log(`HTTPS Server running on port ${CONFIG.HTTPS_PORT}`);\n  });\n}\n\nmodule.exports = app;\n```"
    ],
    "match_count": 4,
    "pass@3": 0.8333333333333334,
    "pass@5": 0.9761904761904762
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Create a function that sets up an Express server with custom middleware for header manipulation, route handling for serving JavaScript files with dynamic content, and static file serving.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware to filter certain HTTP headers, defines a route to serve a dynamically modified JavaScript file, sets up static file serving for specified directories, and starts the server on port 8080.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but starts an Express server listening on port 8080)",
    "Canonical_solution": "function setupServer() {\n    var express = require('express');\n    var app = express();\n\n    app.use(function(req, res, next) {\n        var setHeader = res.setHeader;\n        res.setHeader = function(name) {\n            switch (name) {\n                case 'Cache-Control':\n                case 'Last-Modified':\n                case 'ETag':\n                    return;\n            }\n            return setHeader.apply(res, arguments);\n        };\n        next();\n    });\n\n    app.get('/test.js', function(req, res, next) {\n        var test = fs.readFileSync(__dirname + '/test.js', 'utf8');\n        var files = load();\n\n        test = test.replace('__TESTS__', JSON.stringify(files));\n        test = test.replace('__MAIN__', runTests + '');\n\n        res.contentType('.js');\n        res.send(test);\n    });\n\n    app.use(express.static(__dirname + '/../../lib'));\n    app.use(express.static(__dirname));\n\n    app.listen(8080);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-Content-Type-Options', 'nosniff');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalJs = `console.log('Hello, World!');`;\n  const modifiedJs = originalJs.replace('console.log', 'alert');\n  res.type('application/javascript');\n  res.send(modifiedJs);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/modified-js', (req, res) => {\n  const originalJs = `console.log('Hello, World!');`;\n  const modifiedJs = originalJs.replace('Hello, World!', 'Hello, ' + req.query.name + '!');\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedJs);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\nconst PORT = 8080;\n\napp.use((req, res, next) => {\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalContent = `console.log('Hello, World!');`;\n  const modifiedContent = originalContent.replace('Hello, World!', 'Hello, ' + req.query.name + '!');\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedContent);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 8080;\n\napp.use((req, res, next) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalContent = `console.log('Hello, World!');`;\n  const modifiedContent = originalContent.replace('Hello, World!', `console.log('Modified: Hello, World!');`);\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedContent);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalContent = `console.log('Hello, World!');`;\n  const modifiedContent = originalContent.replace('Hello, World!', 'Hello, ' + req.query.name + '!');\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedContent);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(8080);",
      "const express = require('express');\nconst app = express();\nconst PORT = 8080;\n\napp.use((req, res, next) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalJs = `console.log('Hello, World!');`;\n  const modifiedJs = originalJs.replace('Hello, World!', `console.log('Modified content: ${req.query.message}');`);\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedJs);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 8080;\n\napp.use((req, res, next) => {\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalJs = `console.log('Hello, World!');`;\n  const modifiedJs = originalJs.replace('Hello, World!', `console.log('Modified: Hello, World!');`);\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedJs);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 8080;\n\napp.use((req, res, next) => {\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalContent = `console.log('Hello, World!');`;\n  const modifiedContent = originalContent.replace('Hello, World!', `alert('Hello, World!');`);\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedContent);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 8080;\n\napp.use((req, res, next) => {\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalJs = `console.log('Hello, World!');`;\n  const modifiedJs = originalJs.replace('Hello, World!', `console.log('Modified content: ${req.query.message}');`);\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedJs);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});",
      "const express = require('express');\nconst app = express();\nconst PORT = 8080;\n\napp.use((req, res, next) => {\n  res.set('X-Frame-Options', 'DENY');\n  res.set('X-Content-Type-Options', 'nosniff');\n  res.set('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\napp.get('/dynamic-js', (req, res) => {\n  const originalJs = `console.log('Hello, World!');`;\n  const modifiedJs = originalJs.replace('Hello, World!', 'Dynamic content');\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(modifiedJs);\n});\n\napp.use(express.static('public'));\napp.use(express.static('node_modules'));\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create a function that initializes and configures an Express server for handling regression test components, with customizable port settings and reference mode detection.\n\nFunction Description: The function `getServer` creates and configures an Express.js web server specifically designed for regression testing of UI components. It sets up Handlebars as the view engine, configures static file serving, and defines routes for component testing. The server can operate in either reference mode (port 8000) or development mode (custom port), with different template directories for each mode.\n\nInput:\n- P: [Number|String|undefined] - Optional port number for the server. If not provided, falls back to environment variable PORT or defaults to 8000.\n\nOutput:\n- [Object] - Returns the Express server instance that has been started and is listening on the specified port.\n\nNote: The server includes special configuration for Handlebars templates, static file serving, and a dedicated route for rendering component test pages with associated configuration data. The server also sets the process title based on whether it's running in reference mode or development mode.",
    "Canonical_solution": "function getServer(P) {\n    var PORT = P || process.env.PORT || 8000;\n    var isReference = (PORT === 8000);\n    var partialsDir = isReference ? './reference/dist/templates/handlebars/fuelux' : './templates/handlebars/fuelux';\n\n    process.title = (isReference) ? 'referenceServer' : 'devServer';\n\n    var express = require('express');\n    var app = express();\n    var exphbs  = require('express-handlebars');\n\n    app.disable('view cache');\n\n    app.engine('.hbs',\n        exphbs({\n            extname: '.hbs',\n            defaultLayout: 'main',\n            layoutsDir: './test/regression/',\n            partialsDir: [partialsDir, {namespace: 'lt', dir: './test/regression/components/'}]\n        })\n    );\n\n    app.set('view engine', '.hbs');\n    app.set('views', './test/regression/');\n\n    var path = require('path');\n    app.use(express.static(path.join(__dirname, '../../')));\n\n    app.get('/component/:component', function renderCheckboxPage (req, res) {\n        var component = req.params.component;\n        var data = require('./config/' + component + '.js');\n        data.isReference = isReference;\n        data.components = [\n            'checkbox',\n            'combobox',\n            'datepicker',\n            'loader',\n            'pillbox',\n            'placard',\n            'radio',\n            'repeater',\n            'repeater-single',\n            'repeater-multi',\n            'scheduler',\n            'search',\n            'selectlist',\n            'spinbox',\n            'tree',\n            'wizard'\n        ];\n        res.render('./components/' + component, data);\n    });\n\n    var server = app.listen(PORT, function listen () {\n        console.log('info', 'Regression test server listening on port ' + server.address().port + '. isReference: ' + isReference);\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "```javascript\nconst express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const mode = port === 8000 ? 'reference' : 'development';\n  const viewsDir = mode === 'reference' ? 'views/reference' : 'views/development';\n\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars());\n  app.set('views', path.join(__dirname, viewsDir));\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', { mode });\n  });\n\n  process.title = `Regression Test Server (${mode} mode)`;\n\n  app.listen(port, () => {\n    console.log(`Server running in ${mode} mode on port ${port}`);\n  });\n\n  return app;\n}\n```",
      "```javascript\nconst express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const mode = port === 8000 ? 'reference' : 'development';\n  const viewsDir = mode === 'reference' ? 'views/reference' : 'views/development';\n\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars());\n  app.set('views', path.join(__dirname, viewsDir));\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', { mode });\n  });\n\n  process.title = `Regression Test Server (${mode} mode)`;\n\n  app.listen(port, () => {\n    console.log(`Server running in ${mode} mode on port ${port}`);\n  });\n\n  return app;\n}\n```",
      "```javascript\nconst express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const mode = port === 8000 ? 'reference' : 'development';\n  const viewsDir = mode === 'reference' ? 'views/reference' : 'views/development';\n\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars());\n  app.set('views', path.join(__dirname, viewsDir));\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', { mode });\n  });\n\n  process.title = `Regression Test Server (${mode} mode)`;\n\n  app.listen(port, () => {\n    console.log(`Server running in ${mode} mode on port ${port}`);\n  });\n\n  return app;\n}\n```",
      "```javascript\nconst express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const mode = port === 8000 ? 'reference' : 'development';\n  const viewsDir = mode === 'reference' ? 'views/reference' : 'views/development';\n\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars());\n  app.set('views', path.join(__dirname, viewsDir));\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', { mode });\n  });\n\n  process.title = `Regression Test Server (${mode} mode)`;\n\n  app.listen(port, () => {\n    console.log(`Server running in ${mode} mode on port ${port}`);\n  });\n\n  return app;\n}\n```",
      "const express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\nconst os = require('os');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const mode = port === 8000 ? 'reference' : 'development';\n  const templateDir = mode === 'reference' ? 'views/reference' : 'views/development';\n\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars({\n    layoutsDir: path.join(__dirname, templateDir, 'layouts'),\n    partialsDir: path.join(__dirname, templateDir, 'partials')\n  }));\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', {\n      config: { /* component configuration data */ }\n    });\n  });\n\n  process.title = `Regression Test Server (${mode} mode)`;\n\n  app.listen(port, () => {\n    console.log(`Server running in ${mode} mode on port ${port}`);\n  });\n\n  return app;\n}",
      "const express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\nconst os = require('os');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const isReferenceMode = port === 8000;\n\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars({\n    layoutsDir: isReferenceMode ? path.join(__dirname, 'views/reference') : path.join(__dirname, 'views/development'),\n    defaultLayout: 'main'\n  }));\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', {\n      isReferenceMode: isReferenceMode,\n      config: {\n        // Configuration data here\n      }\n    });\n  });\n\n  process.title = isReferenceMode ? 'Reference Regression Server' : 'Development Regression Server';\n\n  app.listen(port, () => {\n    console.log(`Server running in ${isReferenceMode ? 'reference mode' : 'development mode'} on port ${port}`);\n  });\n\n  return app;\n}",
      "```javascript\nconst express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\nconst os = require('os');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const isReferenceMode = port === 8000;\n\n  app.set('views', path.join(__dirname, isReferenceMode ? 'referenceTemplates' : 'developmentTemplates'));\n  app.engine('hbs', handlebars({\n    extname: '.hbs',\n    helpers: {\n      // Define any Handlebars helpers here\n    }\n  }));\n  app.set('view engine', 'hbs');\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    const componentConfig = {\n      // Define component configuration data here\n    };\n    res.render('componentTest', componentConfig);\n  });\n\n  process.title = isReferenceMode ? 'ReferenceModeServer' : 'DevelopmentModeServer';\n\n  app.listen(port, () => {\n    console.log(`Server running in ${isReferenceMode ? 'reference' : 'development'} mode on port ${port}`);\n  });\n\n  return app;\n}\n```",
      "```javascript\nconst express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const mode = port === 8000 ? 'reference' : 'development';\n  const templateDir = mode === 'reference' ? 'views/reference' : 'views/development';\n\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars());\n  app.set('views', templateDir);\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', { mode });\n  });\n\n  process.title = `Regression Test Server (${mode} mode)`;\n\n  app.listen(port, () => {\n    console.log(`Server running in ${mode} mode on port ${port}`);\n  });\n\n  return app;\n}\n```",
      "const express = require('express');\nconst path = require('path');\nconst handlebars = require('express-handlebars');\nconst bodyParser = require('body-parser');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const mode = port === 8000 ? 'reference' : 'development';\n\n  app.set('views', mode === 'reference' ? path.join(__dirname, 'views/reference') : path.join(__dirname, 'views/development'));\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars({\n    layoutsDir: path.join(app.get('views'), 'layouts'),\n    partialsDir: path.join(app.get('views'), 'partials')\n  }));\n\n  app.use(bodyParser.json());\n  app.use(bodyParser.urlencoded({ extended: true }));\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', { mode: mode });\n  });\n\n  process.title = `Regression Test Server - ${mode} Mode`;\n\n  app.listen(port, () => {\n    console.log(`Server running in ${mode} mode on port ${port}`);\n  });\n\n  return app;\n}",
      "const express = require('express');\nconst handlebars = require('express-handlebars');\nconst path = require('path');\nconst os = require('os');\n\nfunction getServer(P) {\n  const app = express();\n  const port = P || process.env.PORT || 8000;\n  const mode = port === 8000 ? 'reference' : 'development';\n  const viewsDir = mode === 'reference' ? path.join(__dirname, 'views/reference') : path.join(__dirname, 'views/development');\n\n  app.set('view engine', 'handlebars');\n  app.engine('handlebars', handlebars({\n    layoutsDir: path.join(viewsDir, 'layouts'),\n    partialsDir: path.join(viewsDir, 'partials')\n  }));\n  app.set('views', viewsDir);\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.get('/test-component', (req, res) => {\n    res.render('component-test', { mode });\n  });\n\n  process.title = `Regression Test Server (${mode} mode)`;\n\n  app.listen(port, () => {\n    console.log(`Server running in ${mode} mode on port ${port}`);\n  });\n\n  return app;\n}"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a function to set up a server using Express.js with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates Next.js for server-side rendering, and sets up basic route handling. It prepares the server environment, configures middleware, and starts listening on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption\n)\n\nOutput: None (The function starts a server process that:\n1. Creates an Express server with session management\n2. Integrates Next.js for server-side rendering\n3. Sets up route handling\n4. Listens on the specified port\n5. Logs server readiness to console\n)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "matched_results": [
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'nextjs-session';\nconst sessionSecret = process.env.SESSION_SECRET || 'your-secret-key';\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(express.json());\n  server.use(express.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: process.env.NODE_ENV === 'production' }\n  }));\n\n  server.get('/about', (req, res) => {\n    return app.render(req, res, '/about');\n  });\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`Server ready on http://localhost:${port}`);\n  });\n});",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'nextjs-session';\nconst sessionSecret = process.env.SESSION_SECRET || 'your-secret-key';\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: dev },\n  }));\n\n  server.get('/about', (req, res) => {\n    app.render(req, res, '/about');\n  });\n\n  server.get('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});",
      "const express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions',\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('/about', (req, res) => {\n    return app.render(req, res, '/about');\n  });\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});",
      "const express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions',\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('/about', (req, res) => {\n    return app.render(req, res, '/about');\n  });\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst bodyParser = require('body-parser');\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n    cookie: { secure: process.env.NODE_ENV === 'production' }\n  }));\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, err => {\n    if (err) throw err;\n    console.log(`Server ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n});",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'nextjs-session';\nconst sessionSecret = process.env.SESSION_SECRET || 'my-secret-key';\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions'\n});\n\nstore.on('connected', () => {\n  store.client.on('error', (err) => {\n    console.error('MongoDB session store error:', err);\n  });\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store\n  }));\n\n  server.get('/_next/*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n}).catch((err) => {\n  console.error('An error occurred, unable to start the server:', err);\n});",
      "const express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions',\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('/about', (req, res) => {\n    return app.render(req, res, '/about');\n  });\n\n  server.get('*', (req, res) => {\n    return handler(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst bodyParser = require('body-parser');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handler = app.getRequestHandler();\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions',\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(bodyParser.json());\n  server.use(bodyParser.urlencoded({ extended: true }));\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('/_next/*', handler);\n  server.get('*', handler);\n\n  server.listen(process.env.PORT || 8000, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n}).catch((err) => {\n  console.error(err);\n  process.exit(1);\n});",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'nextjs-session';\nconst sessionSecret = process.env.SESSION_SECRET || 'your-secret-key';\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('/about', (req, res) => {\n    app.render(req, res, '/about');\n  });\n\n  server.get('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`Server ready on http://localhost:${port}`);\n  });\n}).catch((err) => {\n  console.error('An error occurred, unable to start the server:', err);\n});",
      "const express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst port = process.env.PORT || 8000;\nconst sessionName = process.env.SESSION_NAME || 'next-session';\nconst sessionSecret = process.env.SESSION_SECRET || 'session-secret';\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\nmongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true });\n\nconst store = new MongoDBStore({\n  uri: process.env.MONGO_URL_TEST,\n  collection: 'sessions',\n});\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.use(express.json());\n  server.use(express.urlencoded({ extended: true }));\n  server.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: true,\n    store: store,\n  }));\n\n  server.get('/about', (req, res) => {\n    return app.render(req, res, '/about');\n  });\n\n  server.get('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`Server ready on http://localhost:${port}`);\n  });\n});"
    ],
    "unmatched_results": [],
    "match_count": 10,
    "pass@3": 1.0,
    "pass@5": 1.0
  }
]