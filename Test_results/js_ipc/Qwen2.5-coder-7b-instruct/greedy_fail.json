[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst crypto = require('crypto');\n\nclass Trader {\n    constructor(config) {\n        this.key = config.key;\n        this.secret = config.secret;\n        this.currency = config.currency;\n        this.asset = config.asset;\n        this.pair = `${this.asset}_${this.currency}`;\n        this.name = 'EXMO';\n        this.nonce = Date.now();\n    }\n\n    api_query(method, params, callback) {\n        const url = `https://api.exmo.com/v1/${method}/`;\n        params['nonce'] = ++this.nonce;\n\n        const queryString = Object.keys(params).map(key => `${key}=${params[key]}`).join('&');\n        const signature = crypto.createHmac('sha512', this.secret).update(queryString).digest('hex').toUpperCase();\n\n        params['signature'] = signature;\n\n        const options = {\n            hostname: 'api.exmo.com',\n            path: `/v1/${method}/?${queryString}`,\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Key': this.key,\n                'Sign': signature\n            }\n        };\n\n        const req = https.request(options, res => {\n            let data = '';\n            res.on('data', chunk => {\n                data += chunk;\n            });\n            res.on('end', () => {\n                try {\n                    const result = JSON.parse(data);\n                    if (result.error) {\n                        callback(new Error(result.error.message));\n                    } else {\n                        callback(null, result);\n                    }\n                } catch (err) {\n                    callback(err);\n                }\n            });\n        });\n\n        req.on('error', err => {\n            callback(err);\n        });\n\n        req.write(queryString);\n        req.end();\n    }\n}\n```"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a function that sets up an Express server with Socket.IO for real-time communication, including CORS support, route handling, and socket event management for chat room functionality.\n\nFunction Description: The function `setupServer` initializes an Express application with HTTP and WebSocket support. It configures CORS middleware, handles socket connections for chat room operations (joining, messaging, disconnecting), and starts the server on a specified port. The function integrates Express routing and Socket.IO events to manage real-time communication between clients in different rooms.\n\nInput: None (The function uses environment variables for port configuration, with a default fallback to port 5000)\n\nOutput: None (The function starts a server process that listens for incoming HTTP and WebSocket connections, but doesn't return any value)",
    "Canonical_solution": "function setupServer() {\n    const http = require('http');\n    const express = require('express');\n    const socketio = require('socket.io');\n    const cors = require('cors');\n    \n    const app = express();\n    const server = http.createServer(app);\n    const io = socketio(server);\n    \n    app.use(cors());\n    app.use(router);\n    \n    io.on('connect', (socket) => {\n        socket.on('join', ({ name, room }, callback) => {\n            const { error, user } = addUser({ id: socket.id, name, room });\n            if(error) return callback(error);\n            socket.join(user.room);\n            socket.emit('message', { user: 'admin', text: `${user.name}, welcome to room ${user.room}.`});\n            socket.broadcast.to(user.room).emit('message', { user: 'admin', text: `${user.name} has joined!` });\n            io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room) });\n            callback();\n        });\n        \n        socket.on('sendMessage', (message, callback) => {\n            const user = getUser(socket.id);\n            io.to(user.room).emit('message', { user: user.name, text: message });\n            callback();\n        });\n        \n        socket.on('disconnect', () => {\n            const user = removeUser(socket.id);\n            if(user) {\n                io.to(user.room).emit('message', { user: 'Admin', text: `${user.name} has left.` });\n                io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room)});\n            }\n        });\n    });\n    \n    server.listen(process.env.PORT || 5000, () => console.log(`Server has started.`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\n\nfunction setupServer() {\n    const app = express();\n    const server = http.createServer(app);\n    const io = socketIo(server, { cors: { origin: '*' } });\n\n    app.use(cors());\n\n    io.on('connection', (socket) => {\n        console.log('New client connected');\n\n        socket.on('joinRoom', (roomId) => {\n            socket.join(roomId);\n            console.log(`Client joined room ${roomId}`);\n        });\n\n        socket.on('sendMessage', (message) => {\n            io.to(message.roomId).emit('receiveMessage', message);\n        });\n\n        socket.on('disconnect', () => {\n            console.log('Client disconnected');\n        });\n    });\n\n    const PORT = process.env.PORT || 5000;\n    server.listen(PORT, () => {\n        console.log(`Server is running on port ${PORT}`);\n    });\n}\n\nsetupServer();\n```"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server with WebSocket support using Express and Socket.IO, implementing a particle simulation system with cluster and client event handling.\n\nFunction Description: The function `startServer` initializes an Express application, sets up static file serving, integrates Socket.IO for real-time communication, and configures a particle simulation system with collision detection and cluster management. It handles particle movement, boundary collisions, and client interactions through defined event handlers.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function starts a server listening on port 3000 but doesn't return any value)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    const server = require('http').Server(app);\n    const io = require('socket.io')(server);\n    const swip = require('../../../src/server/index.js');\n\n    app.use(express.static(__dirname + './../static'));\n\n    swip(io, {\n        cluster: {\n            events: {\n                update: (cluster) => {\n                    const blobs = cluster.data.blobs;\n                    const clients = cluster.clients;\n\n                    const updatedBlobs = blobs.map((blob) => {\n                        const boundaryOffset = blob.size;\n                        const client = clients.find((c) => isParticleInClient(blob, c));\n\n                        let nextPosX = blob.x + blob.speedX;\n                        let nextPosY = blob.y + blob.speedY;\n                        let nextSpeedX = blob.speedX;\n                        let nextSpeedY = blob.speedY;\n\n                        if (client) {\n                            if (((blob.speedX < 0) &&\n                                ((nextPosX - boundaryOffset) < client.transform.x)\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.left, nextPosY))) {\n                                nextPosX = client.transform.x + boundaryOffset;\n                                nextSpeedX = blob.speedX * -1;\n                            } else if (((blob.speedX > 0) &&\n                                ((nextPosX + boundaryOffset) > (client.transform.x + client.size.width))\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.right, nextPosY))) {\n                                nextPosX = client.transform.x + (client.size.width - boundaryOffset);\n                                nextSpeedX = blob.speedX * -1;\n                            }\n\n                            if (((blob.speedY < 0) &&\n                                ((nextPosY - boundaryOffset) < client.transform.y\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.top, nextPosX)))) {\n                                nextPosY = client.transform.y + boundaryOffset;\n                                nextSpeedY = blob.speedY * -1;\n                            } else if (((blob.speedY > 0) &&\n                                ((nextPosY + boundaryOffset) > (client.transform.y + client.size.height))\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.bottom, nextPosX))\n                            ) {\n                                nextPosY = client.transform.y + (client.size.height - boundaryOffset);\n                                nextSpeedY = blob.speedY * -1;\n                            }\n                        } else {\n                            const firstClient = clients[0];\n                            nextPosX = firstClient.transform.x + (firstClient.size.width / 2);\n                            nextPosY = firstClient.transform.y + (firstClient.size.height / 2);\n                            nextSpeedX = 0;\n                            nextSpeedY = 0;\n                        }\n\n                        blob.x = nextPosX;\n                        blob.y = nextPosY;\n                        blob.speedX = nextSpeedX;\n                        blob.speedY = nextSpeedY;\n\n                        return blob;\n                    });\n\n                    return {\n                        blobs: { $set: updatedBlobs },\n                    };\n                },\n                merge: (cluster1, cluster2, transform) => ({\n                    blobs: { $set: getNewParticleDist(cluster1, cluster2, transform) },\n                    backgroundColor: { $set: cluster1.data.backgroundColor },\n                }),\n            },\n            init: () => ({ blobs: [], backgroundColor: getRandomColor() }),\n        },\n\n        client: {\n            init: () => ({}),\n            events: {\n                addBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $push: blobs } },\n                        },\n                    };\n                },\n                updateBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $set: blobs } },\n                        },\n                    };\n                },\n            },\n        },\n    });\n\n    server.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cluster = require('cluster');\nconst numCPUs = require('os').cpus().length;\n\nfunction startServer() {\n    if (cluster.isMaster) {\n        console.log(`Master ${process.pid} is running`);\n\n        // Fork workers.\n        for (let i = 0; i < numCPUs; i++) {\n            cluster.fork();\n        }\n\n        cluster.on('exit', (worker, code, signal) => {\n            console.log(`worker ${worker.process.pid} died`);\n        });\n    } else {\n        const app = express();\n        const server = http.createServer(app);\n        const io = socketIo(server);\n\n        app.use(express.static('public'));\n\n        let particles = [];\n\n        function createParticle(x, y) {\n            return { x, y, dx: Math.random() * 2 - 1, dy: Math.random() * 2 - 1 };\n        }\n\n        function updateParticles() {\n            particles.forEach(particle => {\n                particle.x += particle.dx;\n                particle.y += particle.dy;\n\n                if (particle.x < 0 || particle.x > 800) particle.dx *= -1;\n                if (particle.y < 0 || particle.y > 600) particle.dy *= -1;\n            });\n\n            io.emit('updateParticles', particles);\n        }\n\n        setInterval(updateParticles, 50);\n\n        io.on('connection', (socket) => {\n            console.log('a user connected');\n\n            socket.on('addParticle', (data) => {\n                particles.push(createParticle(data.x, data.y));\n                io.emit('updateParticles', particles);\n            });\n\n            socket.on('disconnect', () => {\n                console.log('user disconnected');\n            });\n        });\n\n        server.listen(3000, () => {\n            console.log(`Worker ${process.pid} started`);\n        });\n    }\n}\n\nstartServer();\n```"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'tinyurl.com', 'bit.ly']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        const { url, depth = 0, seen = {} } = args;\n        if (seen[url]) return callback(new Error('Infinite loop detected'));\n        seen[url] = true;\n\n        for (const [service, domains] of Object.entries(this.map)) {\n            if (domains.some(domain => url.includes(domain))) {\n                return this[service]({ ...args, url }, (err, result) => {\n                    if (err) return callback(err);\n                    this.expand(result, callback);\n                });\n            }\n        }\n\n        this.generic({ ...args, url }, callback);\n    }\n\n    isgd(args, callback) {\n        // Implementation for expanding is.gd URLs\n    }\n\n    googl(args, callback) {\n        // Implementation for expanding goo.gl URLs\n    }\n\n    budurl(args, callback) {\n        // Implementation for expanding budurl.com URLs\n    }\n\n    snipurl(args, callback) {\n        // Implementation for expanding snipurl.com and related URLs\n    }\n\n    generic(args, callback) {\n        fetch(args.url, { method: 'HEAD', redirect: 'manual', timeout: args.timeout })\n            .then(response => response.headers.get('Location'))\n            .then(location => location ? this.expand({ ...args, url: location }, callback) : callback(null, args))\n            .catch(callback);\n    }\n}\n```"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a function to set up an Express.js server with middleware configuration, route handling, and database synchronization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with CORS support, request body parsing, and database synchronization. It configures middleware, defines basic routes, and starts the server on a specified port. The server integrates authentication and user management routes from external modules.\n\nInput: None (The function takes no parameters as it's self-contained for server setup)\n\nOutput: None (The function doesn't return anything but starts a server process that listens on the specified port)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const bodyParser = require(\"body-parser\");\n    const cors = require(\"cors\");\n\n    const app = express();\n\n    var corsOptions = {\n        origin: \"http://localhost:8081\"\n    };\n\n    app.use(cors(corsOptions));\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: true }));\n\n    const db = require(\"./app/models\");\n    const Role = db.role;\n\n    db.sequelize.sync();\n\n    app.get(\"/\", (req, res) => {\n        res.json({ message: \"Welcome to bezkoder application.\" });\n    });\n\n    require('./app/routes/auth.routes')(app);\n    require('./app/routes/user.routes')(app);\n\n    const PORT = process.env.PORT || 8080;\n    app.listen(PORT, () => {\n        console.log(`Server is running on port ${PORT}.`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst dbSync = require('./db-sync'); // Assuming db-sync exports a function to synchronize the database\nconst authRoutes = require('./auth-routes'); // Assuming auth-routes exports authentication routes\nconst userRoutes = require('./user-routes'); // Assuming user-routes exports user management routes\n\nfunction setupExpressServer() {\n    const app = express();\n    const PORT = 3000;\n\n    // Middleware\n    app.use(cors());\n    app.use(bodyParser.json());\n\n    // Database Synchronization\n    dbSync();\n\n    // Routes\n    app.use('/auth', authRoutes);\n    app.use('/users', userRoutes);\n\n    // Start Server\n    app.listen(PORT, () => {\n        console.log(`Server running on http://localhost:${PORT}`);\n    });\n}\n\n// Call the function to start the server\nsetupExpressServer();\n```"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server using the Express framework in JavaScript, with middleware configurations for request processing and static file serving.\n\nFunction Description: The function `createServer` initializes an Express application, configures various middleware for logging, request parsing, and static file serving, and starts an HTTP server listening on a specified port. It also includes environment-specific error handling for development mode.\n\nInput: None (The function does not take any parameters; it uses environment variables like `process.env.PORT` for configuration.)\n\nOutput: None (The function does not return any value; it starts an HTTP server that listens on the specified port and logs a message upon successful startup.)",
    "Canonical_solution": "function createServer() {\n    var express = require('express');\n    var http = require('http');\n    var path = require('path');\n\n    var app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.favicon());\n    app.use(express.logger('dev'));\n    app.use(express.json());\n    app.use(express.urlencoded());\n    app.use(express.methodOverride());\n    app.use(express.static(path.join(__dirname, '/public')));\n    app.use(express.static(path.join(__dirname, '/tests')));\n\n    if ('development' == app.get('env')) {\n        app.use(express.errorHandler());\n    }\n\n    http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express server listening on port ' + app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst path = require('path');\n\nfunction createServer() {\n    const app = express();\n    const PORT = process.env.PORT || 3000;\n\n    // Middleware for logging\n    app.use((req, res, next) => {\n        console.log(`${new Date().toISOString()} ${req.method} ${req.url}`);\n        next();\n    });\n\n    // Middleware for JSON parsing\n    app.use(express.json());\n\n    // Middleware for URL-encoded form data parsing\n    app.use(express.urlencoded({ extended: true }));\n\n    // Static file serving\n    app.use(express.static(path.join(__dirname, 'public')));\n\n    // Error handling middleware\n    if (process.env.NODE_ENV === 'development') {\n        app.use((err, req, res, next) => {\n            console.error(err.stack);\n            res.status(500).send('Something broke!');\n        });\n    }\n\n    // Start the server\n    app.listen(PORT, () => {\n        console.log(`Server is running on http://localhost:${PORT}`);\n    });\n}\n\ncreateServer();\n```"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with essential middleware (CORS, static file serving, JSON body parsing), configures route handlers, and starts listening on a specified port. It handles both API routes and serves static HTML files.\n\nInput: None (The function uses imported modules and configuration from './src/config' and './src/routes')\n\nOutput: None (The function's side effect is starting an HTTP server that listens on the configured port)",
    "Canonical_solution": "function setupExpressServer() {\n    const bodyParser = require('body-parser');\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const config = require('./src/config');\n    const routes = require('./src/routes');\n\n    const app = express();\n\n    app.enable('trust proxy');\n    app.use(cors());\n    app.use(express.static(path.join(__dirname, 'www')));\n    app.use(bodyParser.json());\n\n    app.get('/v2', (req, res) => res.sendFile(path.join(__dirname, 'www/index.html')));\n    app.use(routes);\n\n    app.listen(config.PORT, err => {\n        if (err) console.error(err);\n        console.log('Server started on ' + config.PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst apiRoutes = require('./src/routes/api');\nconst htmlRoutes = require('./src/routes/html');\n\nconst { PORT } = require('./src/config');\n\nconst app = express();\n\napp.use(cors());\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/api', apiRoutes);\napp.use('/', htmlRoutes);\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst twitter = require('twitter');\n\nclass TSClient {\n  constructor(query, cb) {\n    this.search = { q: query, rcount: 100, since_id: null };\n    this.id = crypto.createHash('md5').update(query).digest('hex');\n    this.new_since_id = null;\n    const statePath = `state_${this.id}.json`;\n    if (fs.existsSync(statePath)) {\n      this.search = JSON.parse(fs.readFileSync(statePath));\n    }\n    cb(this);\n  }\n\n  syncSearch(callback) {\n    this._walker({ ts: this, search: this.search, cb: callback, page: 1, results: [] });\n  }\n\n  set(search) {\n    this.search = search;\n    fs.writeFileSync(`state_${this.id}.json`, JSON.stringify(this.search));\n  }\n\n  _walker(s) {\n    const client = new twitter({\n      consumer_key: process.env.TWITTER_CONSUMER_KEY,\n      consumer_secret: process.env.TWITTER_CONSUMER_SECRET,\n      access_token_key: process.env.TWITTER_ACCESS_TOKEN_KEY,\n      access_token_secret: process.env.TWITTER_ACCESS_TOKEN_SECRET\n    });\n\n    client.get('search/tweets', { ...s.search, count: s.search.rcount, max_id: s.page > 1 ? `${s.search.since_id}-1` : undefined }, (error, tweets, response) => {\n      if (error) throw error;\n\n      s.results.push(...tweets.statuses);\n      if (tweets.statuses.length === 0 || s.page === 1 && !s.search.since_id) {\n        s.ts.new_since_id = s.results[s.results.length - 1].id_str;\n        s.ts.set(s.ts.search);\n        s.cb(s.results);\n      } else {\n        s.page++;\n        s.search.since_id = s.ts.new_since_id;\n        this._walker(s);\n      }\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst path = require('path');\nconst routes = require('./routes');\n\nfunction createExpressServer() {\n    const app = express();\n    const PORT = process.env.PORT || 3000;\n\n    // Serve static files from the parent directory\n    app.use(express.static(path.join(__dirname, '..')));\n\n    // Use additional route handlers from the routes module\n    app.use(routes);\n\n    // Start the server\n    const server = app.listen(PORT, () => {\n        console.log(`Server is running on port ${PORT}`);\n    });\n\n    return server;\n}\n\nmodule.exports = createExpressServer;\n```"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to efficiently handle large files.\n\nFunction Description: The function `uploadFileViaPipe` streams a file from the local filesystem to an HTTP server using Node.js's built-in `fs` and `http` modules. It utilizes the pipe mechanism to efficiently transfer data without loading the entire file into memory, making it suitable for large files. The function assumes a predefined server port and file path.\n\nInput: \n- None (The function uses hardcoded values for demonstration purposes. In a real implementation, these would typically be parameters.)\n\nOutput: \n- None (The function performs a side effect of uploading a file. Success or failure would typically be handled via callbacks or events in a production implementation.)",
    "Canonical_solution": "function uploadFileViaPipe() {\n    var http = require('http');\n    var fs = require('fs');\n    var path = require('path');\n    \n    var testFilePath = path.join(__dirname, '../fixture/file/binaryfile.tar.gz');\n    var port = common.port;\n\n    var request = http.request({\n        port: port,\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    });\n\n    fs.createReadStream(testFilePath).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction uploadFileViaPipe() {\n  const filePath = '/path/to/largefile.zip';\n  const serverPort = 3000;\n  const options = {\n    hostname: 'localhost',\n    port: serverPort,\n    path: '/',\n    method: 'POST'\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`statusCode: ${res.statusCode}`);\n  });\n\n  req.on('error', (error) => {\n    console.error(error);\n  });\n\n  const fileStream = fs.createReadStream(filePath);\n  fileStream.pipe(req);\n\n  req.end();\n}\n\nuploadFileViaPipe();\n```"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function uploads a specified file to a server using Node.js's filesystem and HTTP modules. It streams the file content directly to the HTTP request using pipe(), avoiding loading the entire file into memory. The function sets appropriate headers including content-type (multipart/form-data) and content-length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart form data\n\nOutput: None (The function makes an HTTP request but doesn't return any value. The actual upload result would be handled by the server's response, which isn't captured in this function.)",
    "Canonical_solution": "function uploadFile() {\n  const fs = require('fs');\n  const http = require('http');\n  \n  const stat = fs.statSync(FIXTURE);\n  const request = http.request({\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'content-length': stat.size,\n    },\n  });\n  \n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const boundaryEnd = '--' + BOUNDARY + '--\\r\\n';\n  const boundaryStart = '\\r\\n--' + BOUNDARY + '\\r\\n';\n\n  const options = {\n    hostname: 'localhost',\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    console.log(`statusCode: ${res.statusCode}`);\n  });\n\n  req.on('error', (error) => {\n    console.error(error);\n  });\n\n  let body = '';\n  body += boundaryStart;\n  body += 'Content-Disposition: form-data; name=\"file\"; filename=\"' + FIXTURE.split('/').pop() + '\"\\r\\n';\n  body += 'Content-Type: application/octet-stream\\r\\n\\r\\n';\n\n  req.write(body);\n\n  const readStream = fs.createReadStream(FIXTURE);\n  readStream.pipe(req, { end: false });\n  \n  readStream.on('end', () => {\n    req.write(boundaryEnd);\n    req.end();\n  });\n}\n\nuploadFile('path/to/fixture', 8000, 'boundary_string');\n```"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a function that sends a file over HTTP using a readable stream and pipes it to an HTTP request.\n\nFunction Description: The function `sendFileViaHTTP` is designed to stream a file from the local filesystem and send it as binary data via an HTTP POST request. It uses Node.js's `fs` module to create a readable stream from the file and pipes this stream directly to an HTTP request created with the `http` module. This approach is efficient for handling large files as it avoids loading the entire file into memory.\n\nInput: \n- `testFilePath` (string): The path to the file to be sent. Defaults to a predefined path in the fixture directory.\n- `port` (number): The port number on which the HTTP server is listening. Defaults to a common port defined elsewhere in the code.\n\nOutput: None. The function sends the file via HTTP but does not return any value. The result of the HTTP request (success or failure) would typically be handled via event listeners on the request object, which are not shown in this basic example.",
    "Canonical_solution": "function sendFileViaHTTP() {\n    var fs = require('fs');\n    var http = require('http');\n    var path = require('path');\n    \n    var testFilePath = path.join(__dirname, '../fixture/file/binaryfile.tar.gz');\n    var port = common.port;\n\n    var request = http.request({\n        port: port,\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    });\n\n    fs.createReadStream(testFilePath).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction sendFileViaHTTP(testFilePath = './fixture/testfile.txt', port = 8080) {\n    const options = {\n        hostname: 'localhost',\n        port,\n        path: '/upload',\n        method: 'POST'\n    };\n\n    const req = http.request(options, res => {\n        console.log(`statusCode: ${res.statusCode}`);\n\n        res.on('data', d => {\n            process.stdout.write(d);\n        });\n    });\n\n    req.on('error', error => {\n        console.error(error);\n    });\n\n    const fileStream = fs.createReadStream(testFilePath);\n\n    fileStream.pipe(req);\n\n    req.end();\n}\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n    const url = 'https://example.com/api';\n    const headers = {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer your_token_here'\n    };\n    const data = JSON.stringify({\n        key1: 'value1',\n        key2: 'value2'\n    });\n\n    request.post({url, headers, body: data}, (error, response, body) => {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        } else {\n            console.error(error || `Request failed with status code ${response.statusCode}`);\n        }\n    });\n}\n\nmakeHttpRequest();\n```"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to generate PDFs from HTML templates and serve them as streams.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. It serves PDF files generated from an HTML template, replacing placeholders with actual image paths, and streams the PDF output to the client. The server handles incoming requests, checks for favicon requests, and responds with either a 404 error or the generated PDF.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 8080 and logs the server address to the console.)",
    "Canonical_solution": "function createServer() {\n    const fs = require('fs');\n    const http = require('http');\n    const pdf = require('../../');\n    const tmpl = fs.readFileSync(require.resolve('../businesscard/businesscard.html'), 'utf8');\n\n    const server = http.createServer(function (req, res) {\n        if (req.url === '/favicon.ico') return res.end('404');\n        const html = tmpl.replace('{{image}}', `file://${require.resolve('../businesscard/image.png')}`);\n        pdf.create(html, {width: '50mm', height: '90mm'}).toStream((err, stream) => {\n            if (err) return res.end(err.stack);\n            res.setHeader('Content-type', 'application/pdf');\n            stream.pipe(res);\n        });\n    });\n\n    server.listen(8080, function (err) {\n        if (err) throw err;\n        console.log('Listening on http://localhost:%s', server.address().port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst express = require('express');\nconst puppeteer = require('puppeteer');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\n\napp.get('/', async (req, res) => {\n    if (req.path === '/favicon.ico') {\n        res.status(404).send('');\n        return;\n    }\n\n    const htmlTemplatePath = path.join(__dirname, 'template.html');\n    let htmlContent = fs.readFileSync(htmlTemplatePath, 'utf-8');\n\n    // Replace placeholders with actual image paths\n    htmlContent = htmlContent.replace(/image_placeholder/g, 'actual_image_path.jpg');\n\n    try {\n        const browser = await puppeteer.launch();\n        const page = await browser.newPage();\n        await page.setContent(htmlContent);\n        const pdfBuffer = await page.pdf({ format: 'A4' });\n        await browser.close();\n\n        res.setHeader('Content-Type', 'application/pdf');\n        res.setHeader('Content-Disposition', 'inline; filename=output.pdf');\n        res.send(pdfBuffer);\n    } catch (error) {\n        console.error(error);\n        res.status(500).send('Error generating PDF');\n    }\n});\n\napp.listen(8080, () => {\n    console.log('Server running at http://localhost:8080/');\n});\n```"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a JavaScript class that implements a server capable of handling HTTP requests and piping data to responses, with support for live reload functionality and error handling.\n\nClass Description: The `Server` class is designed to create an HTTP server that can handle incoming requests, pipe data to responses (particularly for live reload functionality), and manage server lifecycle events. It supports both standalone operation and integration with existing Express-like applications.\n\nAttributes:\n- options: [Object] - Configuration options for the server including livereload file path and port number.\n- clients: [Object] - Storage for connected clients (used for live reload functionality).\n- server: [http.Server] - The underlying HTTP server instance.\n- app: [Object] - Optional Express-like application instance for integration.\n- port: [Number] - The port number the server is listening on.\n\nMethods:\n- constructor(options) -> [Server] - Initializes the server with given options, setting defaults for livereload path and port.\n- configure(app) -> [Server] - Configures the server to work with an existing Express-like application.\n- handler(req, res, next) -> [Server] - Handles incoming HTTP requests, supporting both middleware and direct handling modes.\n- livereload(req, res) -> [void] - Pipes the livereload JavaScript file to the response.\n- listen(port, fn) -> [void] - Starts the server listening on the specified port.\n- close(req, res) -> [void] - Closes the server and optionally ends a response.\n- error(e) -> [void] - Handles and logs server errors.\n\nNote: The class demonstrates inter-process communication through HTTP and file system operations, particularly in the `livereload` method where it pipes file contents directly to HTTP responses.",
    "Canonical_solution": "var fs = require('fs');\nvar http = require('http');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.options.livereload = this.options.livereload || path.join(__dirname, 'public/livereload.js');\n    this.options.port = parseInt(this.options.port || 35729, 10);\n    this.clients = {};\n    this.configure(this.options.app);\n  }\n\n  configure(app) {\n    if(!app) {\n      this.server = http.createServer(this.handler.bind(this));\n      this.server.on('error', this.error.bind(this));\n      return this;\n    }\n\n    var self = this;\n    this.app = app;\n\n    this.app.listen = function(port, done) {\n      done = done || function() {};\n      var srv = self.server = http.createServer(app);\n      srv.on('error', self.error.bind(self));\n      srv.on('close', self.close.bind(self));\n      return srv.listen(port, done);\n    };\n\n    return this;\n  }\n\n  handler(req, res, next) {\n    var middleware = typeof next === 'function';\n    if(middleware) {\n      this.handle(req, res, next);\n      return this;\n    }\n\n    req\n      .on('end', this.handle.bind(this, req, res))\n      .on('data', function(chunk) {\n        req.data = req.data || '';\n        req.data += chunk;\n      });\n\n    return this;\n  }\n\n  livereload(req, res) {\n    fs.createReadStream(this.options.livereload).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port;\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if(res) res.end();\n    if(this.server._handle) this.server.close();\n  }\n\n  error(e) {\n    console.error('Error:', e.message);\n    console.error(e.stack);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\n\nclass Server {\n  constructor(options = {}) {\n    this.options = { livereloadPath: '/livereload.js', port: 3000, ...options };\n    this.clients = {};\n    this.server = http.createServer();\n    this.app = null;\n    this.port = options.port || 3000;\n  }\n\n  configure(app) {\n    this.app = app;\n    return this;\n  }\n\n  handler(req, res, next) {\n    if (req.url === this.options.livereloadPath) {\n      this.livereload(req, res);\n    } else {\n      if (this.app) {\n        this.app(req, res, next);\n      } else {\n        next();\n      }\n    }\n  }\n\n  livereload(req, res) {\n    const filePath = `${__dirname}/${this.options.livereloadPath}`;\n    fs.readFile(filePath, (err, data) => {\n      if (err) {\n        res.writeHead(500);\n        res.end('Internal Server Error');\n      } else {\n        res.setHeader('Content-Type', 'application/javascript');\n        res.end(data);\n      }\n    });\n  }\n\n  listen(port, fn) {\n    this.server.listen(port || this.port, () => {\n      console.log(`Server running at http://localhost:${port || this.port}/`);\n      if (fn) fn();\n    });\n  }\n\n  close(req, res) {\n    this.server.close(() => {\n      if (res) res.end();\n    });\n  }\n\n  error(e) {\n    console.error('Server error:', e);\n  }\n}\n\nmodule.exports = Server;\n```"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files, using Node.js's built-in `http` and `fs` modules. The server should handle different MIME types and pipe file contents to the response stream.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens on port 5000. It serves static files from the local file system, automatically determining the appropriate MIME type based on the file extension. If a requested file doesn't exist, it logs a warning. The function uses streaming to efficiently pipe file contents to the HTTP response.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server)",
    "Canonical_solution": "function createServer() {\n  var http = require('http'), fs = require('fs'), mimeTypes = {\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpg'\n  };\n\n  http.createServer(function (req, res) {\n    var file = (req.url === '/') ? 'index.html' : \".\" + req.url;\n    var ext = require('path').extname(file),\n      type = (mimeTypes[ext] ? mimeTypes[ext] : '');\n\n    fs.exists(file, function (exists) {\n      if (exists) {\n        res.writeHead(200, {'Content-Type': type});\n        fs.createReadStream(file).pipe(res);\n      } else {\n        console.warn(file, ' does not exit');\n      }\n    });\n  }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n    const server = http.createServer((req, res) => {\n        let filePath = '.' + req.url;\n        if (filePath === './') {\n            filePath += 'index.html';\n        }\n\n        const extname = String(path.extname(filePath)).toLowerCase();\n        let contentType = 'text/html';\n\n        switch (extname) {\n            case '.js':\n                contentType = 'text/javascript';\n                break;\n            case '.css':\n                contentType = 'text/css';\n                break;\n            case '.json':\n                contentType = 'application/json';\n                break;\n            case '.png':\n                contentType = 'image/png';\n                break;\n            case '.jpg':\n            case '.jpeg':\n                contentType = 'image/jpg';\n                break;\n            case '.wav':\n                contentType = 'audio/wav';\n                break;\n            case '.mp4':\n                contentType = 'video/mp4';\n                break;\n        }\n\n        fs.readFile(filePath, (err, content) => {\n            if (err) {\n                if (err.code == 'ENOENT') {\n                    fs.readFile('./404.html', (err, content) => {\n                        res.writeHead(200, { 'Content-Type': 'text/html' });\n                        res.end(content, 'utf-8');\n                    });\n                } else {\n                    res.writeHead(500);\n                    res.end(`Server Error: ${err.code}`);\n                }\n            } else {\n                res.writeHead(200, { 'Content-Type': contentType });\n                res.end(content, 'utf-8');\n            }\n        });\n    });\n\n    server.listen(5000, () => console.log('Server started on port 5000'));\n}\n\ncreateServer();\n```"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createFileServer() {\n    const server = http.createServer((req, res) => {\n        let filePath = path.join(__dirname, 'static', req.url === '/' ? 'index.html' : req.url);\n        let extname = String(path.extname(filePath)).toLowerCase();\n        let contentType = 'text/html';\n\n        switch (extname) {\n            case '.js':\n                contentType = 'text/javascript';\n                break;\n            case '.css':\n                contentType = 'text/css';\n                break;\n            case '.json':\n                contentType = 'application/json';\n                break;\n            case '.png':\n                contentType = 'image/png';\n                break;\n            case '.jpg':\n            case '.jpeg':\n                contentType = 'image/jpg';\n                break;\n            case '.gif':\n                contentType = 'image/gif';\n                break;\n        }\n\n        fs.readFile(filePath, (err, content) => {\n            if (err) {\n                if (err.code == 'ENOENT') {\n                    fs.readFile(path.join(__dirname, 'static', '404.html'), (err, content) => {\n                        res.writeHead(404, { 'Content-Type': 'text/html' });\n                        res.end(content, 'utf-8');\n                    });\n                } else {\n                    res.writeHead(500);\n                    res.end(`Server Error: ${err.code}`);\n                }\n            } else {\n                res.writeHead(200, { 'Content-Type': contentType });\n                res.end(content, 'utf-8');\n            }\n        });\n    });\n\n    server.listen(1338, () => console.log('Server running at http://localhost:1338/'));\n}\n\ncreateFileServer();\n```"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a TCP server class in JavaScript that can handle both regular and TLS-encrypted connections, manage client connections, and provide methods to start and destroy the server.\n\nClass Description: The MockServer class is a TCP server implementation that can be configured to use either regular TCP or TLS encryption. It manages server lifecycle, client connections, and provides methods to start and stop the server gracefully.\n\nAttributes:\n- host: [String] - The host address the server binds to\n- port: [Number] - The port number the server listens on\n- family: [String] - The IP address family (e.g., 'ipv4')\n- server: [Object] - The underlying TCP/TLS server instance\n- tlsEnabled: [Boolean] - Flag indicating if TLS is enabled\n- state: [String] - Current server state ('stopped', 'running', or 'destroyed')\n- connections: [Number] - Count of active client connections\n- sockets: [Array] - Array of active client sockets\n\nMethods:\n- constructor(port, host, options) -> [void] - Initializes the server with specified port, host, and options (including TLS configuration)\n- start() -> [Promise] - Starts the server and returns a promise that resolves when listening\n- destroy() -> [Promise] - Gracefully shuts down the server and returns a promise that resolves when complete",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    // Save the settings\n    this.host = host;\n    this.port = port;\n    this.family = 'ipv4';\n\n    // Create a server socket\n    this.server = options.tls ? tls.createServer(options) : net.createServer(options);\n    this.tlsEnabled = !!options.tls;\n\n    // state\n    this.state = 'stopped';\n\n    // Number of connections\n    this.connections = 0;\n\n    // sockets\n    this.sockets = [];\n  }\n\n  /**\n   * Start the TCP server\n   */\n  start() {\n    const self = this;\n    return new Promise((resolve, reject) => {\n      self.server.on('error', err => {\n        reject(err);\n      });\n\n      const connectionEventName = self.tlsEnabled ? 'secureConnection' : 'connection';\n      self.server.on(connectionEventName, c => {\n        self.connections = self.connections + 1;\n        self.sockets.push(c);\n\n        c.on('error', e => {\n          console.warn('connection error: ', e);\n        });\n\n        c.on('close', () => {\n          self.connections = self.connections - 1;\n          const index = self.sockets.indexOf(c);\n          if (index !== -1) {\n            self.sockets.splice(index, 1);\n          }\n        });\n      });\n\n      self.server.listen(self.port, self.host, () => {\n        // update address information if necessary\n        self.host = self.server.address().address;\n        self.port = self.server.address().port;\n        self.family = self.server.address().family;\n\n        resolve(self);\n      });\n\n      self.state = 'running';\n    });\n  }\n\n  /**\n   * Destroy the TCP server\n   */\n  destroy() {\n    const self = this;\n    if (self.state === 'destroyed') {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      self.sockets.forEach(socket => socket.destroy());\n      self.server.close(err => {\n        if (err) return reject(err);\n        self.state = 'destroyed';\n        resolve();\n      });\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst tls = require('tls');\n\nclass MockServer {\n  constructor(port, host, options) {\n    this.host = host;\n    this.port = port;\n    this.family = options.family || 'ipv4';\n    this.server = null;\n    this.tlsEnabled = !!options.key && !!options.cert;\n    this.state = 'stopped';\n    this.connections = 0;\n    this.sockets = [];\n  }\n\n  async start() {\n    if (this.state !== 'stopped') return Promise.reject(new Error('Server already running'));\n    this.state = 'starting';\n\n    const createServerFunc = this.tlsEnabled ? tls.createServer : net.createServer;\n\n    this.server = createServerFunc(options, socket => {\n      this.handleConnection(socket);\n    });\n\n    this.server.listen(this.port, this.host, () => {\n      this.state = 'running';\n    });\n\n    return new Promise((resolve, reject) => {\n      this.server.once('listening', resolve);\n      this.server.once('error', error => reject(error));\n    });\n  }\n\n  async destroy() {\n    if (this.state !== 'running') return Promise.resolve();\n    this.state = 'stopping';\n\n    for (const socket of this.sockets) {\n      socket.destroy();\n    }\n\n    return new Promise((resolve, reject) => {\n      this.server.close(err => {\n        if (err) return reject(err);\n        this.state = 'destroyed';\n        resolve();\n      });\n    });\n  }\n\n  handleConnection(socket) {\n    this.connections++;\n    this.sockets.push(socket);\n\n    socket.on('data', data => {\n      // Handle incoming data\n    });\n\n    socket.on('end', () => {\n      this.connections--;\n      this.sockets.splice(this.sockets.indexOf(socket), 1);\n    });\n\n    socket.on('error', err => {\n      console.error('Socket error:', err);\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module to handle client connections, data parsing, and server lifecycle events.\n\nClass Description: TcpReader is an EventEmitter-based class that manages a TCP server instance, handles client connections, processes incoming data through a custom parser, and manages server lifecycle events. It's designed to work within a transporter system for inter-process communication.\n\nAttributes:\n- server: [Object] - The TCP server instance created by the net module\n- opts: [Object] - Configuration options including port and maxPacketSize\n- transporter: [Object] - Reference to the parent transporter object\n- Promise: [Object] - Reference to the Promise implementation used by the transporter\n- logger: [Object] - Logger instance for logging events and errors\n- sockets: [Array] - Array of currently connected client sockets\n\nMethods:\n- listen() -> [Promise] - Starts the TCP server on the configured port and resolves with the actual port number when listening\n- onTcpClientConnected(socket: [Object]) -> [void] - Handles new client connections, sets up data parsing and error handling\n- closeSocket(socket: [Object]) -> [void] - Closes and removes a specific client socket\n- close() -> [void] - Stops the server and closes all client connections",
    "Canonical_solution": "const net = require(\"net\");\nconst EventEmitter = require(\"events\");\nconst Parser = require(\"./parser\");\n\nclass TcpReader extends EventEmitter {\n\tconstructor(transporter, opts) {\n\t\tsuper();\n\n\t\tthis.server = null;\n\t\tthis.opts = opts;\n\t\tthis.transporter = transporter;\n\t\tthis.Promise = transporter.broker.Promise;\n\t\tthis.logger = transporter.logger;\n\n\t\tthis.sockets = [];\n\t}\n\n\tlisten() {\n\t\treturn new this.Promise((resolve, reject) => {\n\t\t\tconst server = net.createServer(socket => this.onTcpClientConnected(socket));\n\n\t\t\tserver.on(\"error\", err => {\n\t\t\t\tthis.logger.error(\"Server error.\", err);\n\n\t\t\t\tif (reject) reject(err);\n\t\t\t});\n\n\t\t\tlet h = this.opts.port;\n\n\t\t\tif (process.versions.node.split(\".\")[0] >= 8)\n\t\t\t\th = { port: this.opts.port, exclusive: true };\n\n\t\t\tserver.listen(h, () => {\n\t\t\t\tthis.opts.port = this.server.address().port;\n\t\t\t\tthis.logger.info(`TCP server is listening on port ${this.opts.port}`);\n\t\t\t\tthis.connected = true;\n\n\t\t\t\tresolve(this.opts.port);\n\t\t\t\treject = null;\n\t\t\t});\n\n\t\t\tthis.server = server;\n\t\t});\n\t}\n\n\tonTcpClientConnected(socket) {\n\t\tthis.sockets.push(socket);\n\n\t\tsocket.setNoDelay(true);\n\n\t\tconst address = socket.remoteAddress;\n\t\tthis.logger.debug(`New TCP client connected from '${address}'`);\n\n\t\tconst parser = new Parser(undefined, this.opts.maxPacketSize);\n\t\tsocket.pipe(parser);\n\n\t\tparser.on(\"data\", (type, message) => {\n\t\t\tthis.transporter.onIncomingMessage(type, message, socket);\n\t\t});\n\n\t\tparser.on(\"error\", err => {\n\t\t\tthis.logger.warn(\"Packet parser error!\", err);\n\t\t\tthis.closeSocket(socket, err);\n\t\t});\n\n\t\tsocket.on(\"error\", err => {\n\t\t\tthis.logger.debug(`TCP client '${address}' error!`, err);\n\t\t\tthis.closeSocket(socket, err);\n\t\t});\n\n\t\tsocket.on(\"close\", hadError => {\n\t\t\tthis.logger.debug(`TCP client disconnected from '${address}'! Had error:`, !!hadError);\n\t\t\tthis.closeSocket(socket);\n\t\t});\n\n\t\tthis.emit(\"connect\", socket);\n\t}\n\n\tcloseSocket(socket) {\n\t\tsocket.destroy();\n\n\t\tthis.sockets.splice(this.sockets.indexOf(socket), 1);\n\t}\n\n\tclose() {\n\t\tif (this.server && this.server.listening) {\n\t\t\tthis.server.close();\n\n\t\t\tthis.sockets.forEach(socket => socket.destroy());\n\t\t\tthis.sockets = [];\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst { EventEmitter } = require('events');\n\nclass TcpReader extends EventEmitter {\n  constructor(opts, transporter) {\n    super();\n    this.server = null;\n    this.opts = opts || {};\n    this.transporter = transporter;\n    this.Promise = transporter.Promise;\n    this.logger = transporter.logger;\n    this.sockets = [];\n  }\n\n  async listen() {\n    return new this.Promise((resolve, reject) => {\n      this.server = net.createServer(async (socket) => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        resolve(this.server.address().port);\n      });\n\n      this.server.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    this.emit('clientConnected', socket);\n\n    socket.on('data', (data) => {\n      try {\n        const parsedData = this.parseData(data);\n        this.emit('dataReceived', socket, parsedData);\n      } catch (err) {\n        this.emit('dataError', socket, err);\n      }\n    });\n\n    socket.on('end', () => {\n      this.closeSocket(socket);\n      this.emit('clientDisconnected', socket);\n    });\n\n    socket.on('error', (err) => {\n      this.closeSocket(socket);\n      this.emit('clientError', socket, err);\n    });\n  }\n\n  parseData(data) {\n    // Custom data parsing logic here\n    return data.toString('utf8');\n  }\n\n  closeSocket(socket) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n      socket.destroy();\n    }\n  }\n\n  async close() {\n    await this.Promise.all(this.sockets.map((socket) => new this.Promise((resolve) => socket.end(resolve))));\n    this.server.close(() => {\n      this.emit('serverClosed');\n    });\n  }\n}\n\nmodule.exports = TcpReader;\n```"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  async taskRequest(method, url, body = '') {\n    const headers = {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${this.token}`,\n      'Did': this.did,\n      'Finger': this.finger,\n      'Oaid': this.oaid\n    };\n\n    let options = { method, headers };\n    if (method.toLowerCase() === 'post') {\n      options.body = JSON.stringify(body);\n    }\n\n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Request failed: ${error.message}`);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a TCP server in Node.js that handles client connections, processes incoming data in batches, and forwards each batch to an external service for processing.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that listens on port 5000. When a client connects, it sets up a bidirectional communication channel where incoming data from the client is collected in batches (separated by '.'). Each complete batch is then sent to an external 'uppercase' service via a REQ socket. The server handles data streaming and batch processing efficiently.\n\nInput: None (The function takes no parameters; configuration is hardcoded)\n\nOutput: None (The function creates a server instance that runs indefinitely, listening for connections)\n\n---\n\nIf you'd prefer the class format (though the reference code is function-based):\n\nTask Description: Implement a TCP server class in Node.js that manages client connections and batch processing of incoming data.\n\nClass Description: The `TCPServer` class encapsulates a TCP server that listens for client connections, collects incoming data in batches, and forwards complete batches to an external service.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- port: [number] - The port number the server listens on (default: 5000)\n\nMethods:\n- constructor([port: number]) -> void - Initializes the server with optional port configuration\n- start() -> void - Starts the server and begins listening for connections\n- handleConnection(conn: net.Socket) -> void - Internal method to manage client connections and data processing\n- processBatch(batch: string[]) -> void - Sends a complete batch to the external service",
    "Canonical_solution": "function createTCPServer() {\n    var server = require('net').createServer();\n    server.on('connection', function(conn) {\n        conn.setEncoding('utf8');\n        \n        var req = context.socket('REQ');\n        req.setEncoding('utf8');\n        req.pipe(conn);\n        req.connect('uppercase');\n        \n        var batch = [];\n        var ask = function (q) {\n            req.write(q, 'utf8');\n        }\n        function readBatch() {\n            var msg; while (msg = conn.read()) {\n                msg.split('\\n').forEach(function(item) {\n                    if (item == '.') {\n                        console.log('Sending batch %s', batch);\n                        batch.forEach(ask);\n                        batch = [];\n                    }\n                    else if (item != '') {\n                        batch.push(item);\n                    }\n                });\n            }\n        }\n        conn.on('readable', readBatch);\n        readBatch();\n    });\n    server.listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst zmq = require('zeromq');\n\nclass TCPServer {\n    constructor(port = 5000) {\n        this.server = net.createServer();\n        this.port = port;\n        this.uppercaseSocket = zmq.socket('req');\n        this.uppercaseSocket.connect('tcp://localhost:5558');\n    }\n\n    start() {\n        this.server.listen(this.port, () => {\n            console.log(`Server listening on port ${this.port}`);\n        });\n\n        this.server.on('connection', (conn) => {\n            this.handleConnection(conn);\n        });\n    }\n\n    handleConnection(conn) {\n        let buffer = '';\n\n        conn.on('data', (chunk) => {\n            buffer += chunk.toString();\n\n            while (buffer.includes('.')) {\n                const batchEndIndex = buffer.indexOf('.');\n                const batch = buffer.slice(0, batchEndIndex).split('\\n');\n                buffer = buffer.slice(batchEndIndex + 1);\n\n                this.processBatch(batch);\n            }\n        });\n\n        conn.on('end', () => {\n            if (buffer.length > 0) {\n                this.processBatch(buffer.split('\\n'));\n            }\n        });\n    }\n\n    processBatch(batch) {\n        const batchStr = batch.join('\\n');\n        this.uppercaseSocket.send(batchStr);\n        this.uppercaseSocket.on('message', (response) => {\n            console.log(`Received response from uppercase service: ${response}`);\n        });\n    }\n}\n\nconst server = new TCPServer();\nserver.start();\n```"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a POP3 server class in Node.js that handles secure and non-secure connections, manages client connections, and provides event-driven communication.\n\nClass Description: The POP3Server class extends EventEmitter to create a TCP server that can handle both regular and TLS-secured POP3 connections. It manages client connections and emits events for server lifecycle and errors.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- connections: [Set] - Tracks active client connections\n- server: [net.Server|tls.Server] - The underlying TCP/TLS server instance\n\nMethods:\n- constructor(options) -> [void] - Initializes the server with optional configuration\n- _setListeners() -> [void] - Sets up event listeners for the server\n- _onListening() -> [void] - Handles the 'listening' event\n- _onClose() -> [void] - Handles the 'close' event\n- _onError(err) -> [void] - Handles the 'error' event\n- connect(socket, socketOptions) -> [void] - Creates and manages a new client connection\n- listen(...args) -> [void] - Starts the server listening on specified port\n- close(callback) -> [void] - Stops the server and invokes callback when closed",
    "Canonical_solution": "const EventEmitter = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass POP3Server extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.options = options || {};\n        this.connections = new Set();\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    this.connect(socket, socketOptions);\n                });\n            });\n        }\n\n        this._setListeners();\n    }\n\n    _setListeners() {\n        this.server.on('listening', () => this._onListening());\n        this.server.on('close', () => this._onClose());\n        this.server.on('error', err => this._onError(err));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new POP3Connection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.once('error', err => {\n            this.connections.delete(connection);\n            this._onError(err);\n        });\n        connection.once('close', () => {\n            this.connections.delete(connection);\n        });\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            if (typeof callback === 'function') {\n                return callback();\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.options = { ...options };\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', () => this._onListening());\n    this.server.on('close', () => this._onClose());\n    this.server.on('error', (err) => this._onError(err));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    const pop3Client = new POP3Client(socket, socketOptions);\n    this.connections.add(pop3Client);\n    pop3Client.on('end', () => this.connections.delete(pop3Client));\n    pop3Client.on('error', (err) => this.emit('error', err));\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options.tlsOptions, (socket) => this.connect(socket, { secure: true }));\n    } else {\n      this.server = net.createServer((socket) => this.connect(socket, { secure: false }));\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(callback);\n  }\n}\n\nmodule.exports = POP3Server;\n```"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Create a TCP server in Node.js that serves Flash cross-domain policy files to clients, handling connections, errors, and policy file generation dynamically.\n\nClass Description: The Server class implements a TCP server that listens for Flash policy file requests and responds with an appropriate cross-domain policy XML. It handles server lifecycle events, client connections, and dynamic policy configuration.\n\nAttributes:\n- origins: [Array] - List of allowed domains and ports in \"domain:port\" format\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [net.Server] - The TCP server instance\n- server: [Object] - Optional fallback HTTP server\n- buffer: [Buffer] - Compiled policy file in binary format\n\nMethods:\n- constructor(options, origins) -> [Server] - Initializes the server with configuration options and allowed origins\n- listen(port, server, cb) -> [Server] - Starts listening on specified port, with optional fallback server and callback\n- responder(socket) -> [void] - Responds to client connections with policy file\n- compile() -> [Server] - Generates the policy file XML and converts it to buffer\n- add() -> [Server] - Adds one or more allowed origins to the policy\n- remove(origin) -> [Server] - Removes a specific origin from the policy\n- close() -> [Server] - Closes the server and cleans up resources",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => {\n        this.responder.call(this, socket);\n      });\n      this.responder.call(this, socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges. ' +\n          (\n            this.server\n            ? 'The Flash Policy File requests will only be served inline over the supplied HTTP server. Inline serving is slower than a dedicated server instance.'\n            : 'No fallback server supplied, we will be unable to answer Flash Policy File requests.'\n          )\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n      if (this.server && this.server['@'] && this.server.online) {\n        this.server.removeListener('connection', this.server['@']);\n      }\n      delete this.server?.online;\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (\n            data &&\n            data[0] === 60 &&\n            data.toString() === '<policy-file-request/>\\0' &&\n            socket &&\n            (socket.readyState === 'open' || socket.readyState === 'writeOnly')\n          ) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    if (this.port >= 0) {\n      this.socket.listen(this.port, () => {\n        this.socket.online = true;\n        callback?.call(this);\n      });\n    }\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = Buffer.from(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst url = require('url');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = Array.isArray(origins) ? origins : [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server || null;\n    this.buffer = null;\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    if (typeof port === 'function') {\n      cb = port;\n      port = null;\n    }\n    if (server) {\n      this.server = server;\n    }\n    if (!this.socket) {\n      this.socket = net.createServer((socket) => this.responder(socket));\n    }\n    this.socket.listen(port || this.port, () => {\n      this.log(`Server listening on port ${this.socket.address().port}`);\n      if (cb) cb(null);\n    });\n    return this;\n  }\n\n  responder(socket) {\n    const req = url.parse(`http://${socket.remoteAddress}:${socket.remotePort}`, true);\n    if (req.pathname === '/crossdomain.xml' && this.checkOrigin(req.query.source)) {\n      socket.write(this.buffer);\n      socket.end();\n    } else {\n      socket.destroy();\n    }\n  }\n\n  compile() {\n    const xml = `<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"${this.origins.join(',')}\" /></cross-domain-policy>`;\n    this.buffer = Buffer.from(xml, 'utf8');\n    return this;\n  }\n\n  add(origin) {\n    if (typeof origin === 'string') {\n      this.origins.push(origin);\n      this.compile();\n    }\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index !== -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n    return this;\n  }\n\n  checkOrigin(source) {\n    return this.origins.some(o => o.split(':')[0] === source.split(':')[0]);\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(() => this.log('Server closed'));\n    }\n    return this;\n  }\n}\n\nmodule.exports = Server;\n```"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a TCP server class in JavaScript using Node.js's 'net' module to handle client connections, manage sockets, and provide event-driven communication.\n\nClass Description: The Socket class represents a TCP server that can bind to a specific port/host, manage client connections, handle socket errors, and emit events for various connection states. It extends EventEmitter for event handling capabilities.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- socks: [Array] - Array of connected client sockets\n- settings: [Object] - Configuration settings for the server\n- type: [String] - Indicates whether the instance is acting as a server or client\n\nMethods:\n- constructor() -> [void] - Initializes the socket instance with default settings\n- bind(port, host, fn) -> [Socket] - Binds the server to a specified port and host (supports both TCP and Unix sockets)\n- onconnect(sock) -> [void] - Handles new client connections\n- addSocket(sock) -> [void] - Adds a new socket to the connection pool and sets up message parsing\n- removeSocket(sock) -> [void] - Removes a socket from the connection pool\n- handleErrors(sock) -> [void] - Sets up error handling for a socket\n- closeServer(fn) -> [void] - Closes the server and all client connections",
    "Canonical_solution": "var Emitter = require('events').EventEmitter;\nvar net = require('net');\nvar debug = require('debug')('axon:sock');\n\nclass Socket {\n  constructor() {\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.set('hwm', Infinity);\n    this.set('identity', String(process.pid));\n    this.set('retry timeout', 100);\n    this.set('retry max timeout', 5000);\n  }\n\n  bind(port, host, fn) {\n    var self = this;\n    if ('client' == this.type) throw new Error('cannot bind() after connect()');\n    if ('function' == typeof host) {\n      fn = host;\n      host = undefined;\n    }\n\n    var unixSocket = false;\n\n    if ('string' == typeof port) {\n      port = url.parse(port);\n\n      if ('unix:' == port.protocol) {\n        host = fn;\n        fn = undefined;\n        port = port.pathname;\n        unixSocket = true;\n      } else {\n        host = port.hostname || '0.0.0.0';\n        port = parseInt(port.port, 10);\n      }\n    } else {\n      host = host || '0.0.0.0';\n    }\n\n    this.type = 'server';\n\n    this.server = net.createServer(this.onconnect.bind(this));\n\n    debug('%s bind %s:%s', this.type, host, port);\n    this.server.on('listening', this.emit.bind(this, 'bind'));\n\n    if (unixSocket) {\n      this.server.on('error', function(e) {\n        if (e.code == 'EADDRINUSE') {\n          var clientSocket = new net.Socket();\n\n          clientSocket.on('error', function(e2) {\n            if (e2.code == 'ECONNREFUSED') {\n              fs.unlink(port);\n              self.server.listen(port, host, fn);\n            }\n          });\n\n          clientSocket.connect({path: port}, function() {\n            throw e;\n          });\n        }\n      });\n    }\n\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    var self = this;\n    var addr = sock.remoteAddress + ':' + sock.remotePort;\n    debug('%s accept %s', self.type, addr);\n    this.addSocket(sock);\n    this.handleErrors(sock);\n    this.emit('connect', sock);\n    sock.on('close', function() {\n      debug('%s disconnect %s', self.type, addr);\n      self.emit('disconnect', sock);\n      self.removeSocket(sock);\n    });\n  }\n\n  addSocket(sock) {\n    var parser = new Parser;\n    var i = this.socks.push(sock) - 1;\n    debug('%s add socket %d', this.type, i);\n    sock.pipe(parser);\n    parser.on('data', this.onmessage(sock));\n  }\n\n  removeSocket(sock) {\n    var i = this.socks.indexOf(sock);\n    if (!~i) return;\n    debug('%s remove socket %d', this.type, i);\n    this.socks.splice(i, 1);\n  }\n\n  handleErrors(sock) {\n    var self = this;\n    sock.on('error', function(err) {\n      debug('%s error %s', self.type, err.code || err.message);\n      self.emit('socket error', err);\n      self.removeSocket(sock);\n      if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n      debug('%s ignored %s', self.type, err.code);\n      self.emit('ignored error', err);\n    });\n  }\n\n  closeServer(fn) {\n    debug('%s closing server', this.type);\n    this.server.on('close', this.emit.bind(this, 'close'));\n    this.server.close();\n    fn && fn();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = { port: 3000, host: '127.0.0.1', type: 'server' };\n  }\n\n  bind(port, host, fn) {\n    this.settings.port = port || this.settings.port;\n    this.settings.host = host || this.settings.host;\n    this.server = net.createServer((sock) => {\n      this.onconnect(sock);\n      this.addSocket(sock);\n    });\n    this.server.listen(this.settings.port, this.settings.host, () => {\n      if (fn) fn(null, this);\n    }).on('error', (err) => {\n      if (fn) fn(err);\n    });\n    return this;\n  }\n\n  onconnect(sock) {\n    console.log('Client connected');\n    sock.on('data', (data) => {\n      this.emit('message', data.toString(), sock);\n    });\n    sock.on('end', () => {\n      this.removeSocket(sock);\n      console.log('Client disconnected');\n    });\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    this.handleErrors(sock);\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n      sock.destroy();\n    }\n  }\n\n  handleErrors(sock) {\n    sock.on('error', (err) => {\n      console.error('Socket error:', err);\n      this.removeSocket(sock);\n    });\n  }\n\n  closeServer(fn) {\n    this.server.close(() => {\n      this.socks.forEach((sock) => {\n        sock.destroy();\n      });\n      this.socks = [];\n      if (fn) fn(null);\n    }).on('error', (err) => {\n      if (fn) fn(err);\n    });\n  }\n}\n\nmodule.exports = Socket;\n```"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId = null) {\n    try {\n      let response;\n      if (unsplashClientId) {\n        response = await this.fetchFromUnsplash(unsplashClientId);\n      } else {\n        response = await this.fetchFromBing();\n      }\n      return { type: response.type, data: response.data };\n    } catch (error) {\n      console.error('Error fetching wallpaper:', error);\n      return this.getDefaultBingWallpaper();\n    }\n  }\n\n  static async fetchFromUnsplash(clientId) {\n    const url = `https://api.unsplash.com/photos/random?client_id=${clientId}`;\n    const response = await fetch(url);\n    if (!response.ok) throw new Error('Failed to fetch from Unsplash');\n    const data = await response.json();\n    return { type: 'unsplash', data };\n  }\n\n  static async fetchFromBing() {\n    const url = 'https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=en-US';\n    const response = await fetch(url);\n    if (!response.ok) throw new Error('Failed to fetch from Bing');\n    const data = await response.json();\n    return { type: 'bing', data: data.images[0] };\n  }\n\n  static getDefaultBingWallpaper() {\n    return {\n      type: 'bing',\n      data: {\n        startdate: new Date().toISOString().split('T')[0],\n        fullurl: 'https://www.bing.com/th?id=OHR.SunsetOverTheHills_ZH-CN6298355478_1920x1080.jpg&rf=LaDigue_1920x1080.jpg&pid=hp'\n      }\n    };\n  }\n}\n```"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a function that establishes a TCP server which listens for specific termination codes from clients and responds with a predefined byte sequence before shutting down.\n\nFunction Description: The function `makeTerminatingBackend` creates a TCP server that listens for incoming connections. When a client sends data containing specific termination codes (80877103 or 80877104), the server responds with a predefined byte sequence and then closes the connection. The server automatically selects an available port and returns it for external use.\n\nInput: \n- `byte` [String] - The UTF-8 encoded byte sequence to send as a response when a termination code is received.\n\nOutput:\n- `port` [Number] - The port number on which the TCP server is listening. This is dynamically assigned by the system.",
    "Canonical_solution": "function makeTerminatingBackend(byte) {\n  const { createServer } = require('net');\n\n  const server = createServer((socket) => {\n    socket.on('data', (buff) => {\n      const code = buff.readInt32BE(4);\n      if (code === 80877103 || code === 80877104) {\n        const packet = Buffer.from(byte, 'utf-8');\n        socket.write(packet);\n      }\n    });\n    socket.on('close', () => {\n      server.close();\n    });\n  });\n\n  server.listen();\n  const { port } = server.address();\n  return port;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "```python\nimport socket\n\ndef makeTerminatingBackend(byte):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('', 0))\n    server_socket.listen(5)\n    port = server_socket.getsockname()[1]\n    \n    def handle_client(client_socket):\n        while True:\n            data = client_socket.recv(1024)\n            if not data:\n                break\n            if int.from_bytes(data[:4], byteorder='big') == 80877103 or int.from_bytes(data[:4], byteorder='big') == 80877104:\n                client_socket.sendall(byte.encode('utf-8'))\n                client_socket.close()\n                return\n    \n    while True:\n        client_socket, addr = server_socket.accept()\n        handle_client(client_socket)\n\n# Example usage:\nresponse_byte_sequence = \"OK\"\nport_number = makeTerminatingBackend(response_byte_sequence)\nprint(f\"Server is running on port {port_number}\")\n```"
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module to handle client connections, manage socket communication, and process incoming messages.\n\nClass Description: The TcpReader class is responsible for establishing a TCP server, managing client connections, handling socket events, and processing incoming messages through a custom parser. It provides methods to start/stop the server and manage connected clients.\n\nAttributes:\n- transporter: [Object] - The parent transporter object that handles incoming messages\n- opts: [Object] - Configuration options including the port to listen on\n- sockets: [Array] - Array of currently connected client sockets\n- logger: [Object] - Logger instance from the transporter for error logging\n- server: [Object] - The TCP server instance\n- connected: [Boolean] - Flag indicating if the server is currently listening\n\nMethods:\n- constructor(transporter, opts) -> [void] - Initializes the TcpReader with transporter and options\n- listen() -> [Promise] - Starts the TCP server and begins listening for connections\n- onTcpClientConnected(socket) -> [void] - Handles new client connections and sets up event listeners\n- closeSocket(socket, err) -> [void] - Closes and removes a specific socket from the connections\n- close() -> [void] - Stops the server and closes all connected sockets",
    "Canonical_solution": "const net = require(\"net\");\n\nclass TcpReader {\n    constructor(transporter, opts) {\n        this.transporter = transporter;\n        this.opts = opts;\n        this.sockets = [];\n        this.logger = transporter.logger;\n    }\n\n    listen() {\n        return new Promise((resolve, reject) => {\n            this.server = net.createServer(socket => {\n                this.onTcpClientConnected(socket);\n            });\n\n            this.server.on(\"error\", err => {\n                reject(err);\n            });\n\n            const listenOptions = process.versions.node.split(\".\")[0] >= 8 \n                ? { port: this.opts.port, exclusive: true }\n                : this.opts.port;\n\n            this.server.listen(listenOptions, () => {\n                this.opts.port = this.server.address().port;\n                this.connected = true;\n                resolve();\n            });\n        });\n    }\n\n    onTcpClientConnected(socket) {\n        socket.on(\"error\", err => {\n            this.closeSocket(socket, err);\n        });\n\n        socket.on(\"close\", () => {\n            this.closeSocket(socket);\n        });\n\n        socket.setNoDelay(true);\n\n        const parser = require(\"../../../../src/transporters/tcp/parser\")();\n        socket.pipe(parser);\n\n        parser.on(\"data\", (type, message) => {\n            this.transporter.onIncomingMessage(type, message, socket);\n        });\n\n        parser.on(\"error\", err => {\n            this.closeSocket(socket, err);\n        });\n\n        this.sockets.push(socket);\n    }\n\n    closeSocket(socket, err) {\n        if (err) {\n            this.logger.warn(`TCP socket error: ${err.message}`);\n        }\n\n        const index = this.sockets.indexOf(socket);\n        if (index !== -1) {\n            this.sockets.splice(index, 1);\n            socket.destroy();\n        }\n    }\n\n    close() {\n        if (this.server && this.server.listening) {\n            this.server.close();\n        }\n\n        this.sockets.forEach(socket => {\n            socket.destroy();\n        });\n        this.sockets = [];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts;\n    this.sockets = [];\n    this.logger = transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  async listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer((socket) => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        resolve();\n      }).on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.setEncoding('utf8');\n    socket.on('data', (data) => {\n      try {\n        const message = JSON.parse(data);\n        this.transporter.processMessage(message);\n      } catch (e) {\n        this.logger.error('Error parsing message:', e);\n      }\n    });\n    socket.on('close', () => {\n      this.closeSocket(socket);\n    });\n    socket.on('error', (err) => {\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index !== -1) {\n      this.sockets.splice(index, 1);\n    }\n    socket.destroy(err);\n  }\n\n  close() {\n    this.server.close(() => {\n      this.sockets.forEach((socket) => {\n        this.closeSocket(socket);\n      });\n      this.connected = false;\n    });\n  }\n}\n\nmodule.exports = TcpReader;\n```"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Write a function that fetches version information and schema data from a remote API, caches the results locally, and handles errors appropriately.\n\nFunction Description: The function `fetchAndCacheVersions` retrieves version data from a specified API endpoint, then fetches schema data for each non-deprecated version. It caches all retrieved data in JSON files in a local directory. Errors during the process are caught and logged, with the process exiting on failure.\n\nInput: None (The function takes no parameters; all URLs and paths are hardcoded)\n\nOutput: \n- Success: Writes JSON files to the cache directory and logs success messages\n- Failure: Logs error messages and exits the process with status code 1",
    "Canonical_solution": "function fetchAndCacheVersions() {\n    const axios = require('axios');\n    const { writeJsonSync } = require('fs-extra');\n    const path = require('path');\n\n    axios\n        .get('https://exp.host/--/versions')\n        .then(async ({ data }) => {\n            writeJsonSync(path.join(__dirname, '../caches/versions.json'), data);\n\n            for (const version of Object.keys(data.sdkVersions)) {\n                if (data.sdkVersions[version].isDeprecated) {\n                    continue;\n                }\n                const {\n                    data: { data: schema },\n                } = await axios.get(`https://exp.host/--/api/v2/project/configuration/schema/${version}`);\n\n                const filePath = path.join(__dirname, `../caches/schema-${version}.json`);\n                console.log('Writing', filePath);\n                writeJsonSync(filePath, schema);\n            }\n        })\n        .then(() => console.log('Caches updated.'))\n        .catch(error => {\n            console.error(error);\n            console.error('Updating caches failed.');\n            process.exit(1);\n        });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```python\nimport requests\nimport json\nimport os\n\ndef fetch_and_cache_versions():\n    api_url = \"https://api.example.com/versions\"\n    cache_dir = \"./cache\"\n    \n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    \n    try:\n        response = requests.get(api_url)\n        response.raise_for_status()\n        versions_data = response.json()\n        \n        for version in versions_data['versions']:\n            if not version['deprecated']:\n                schema_url = f\"https://api.example.com/schemas/{version['id']}\"\n                schema_response = requests.get(schema_url)\n                schema_response.raise_for_status()\n                schema_data = schema_response.json()\n                \n                version_file_path = os.path.join(cache_dir, f\"{version['id']}_version.json\")\n                schema_file_path = os.path.join(cache_dir, f\"{version['id']}_schema.json\")\n                \n                with open(version_file_path, 'w') as file:\n                    json.dump(version, file)\n                with open(schema_file_path, 'w') as file:\n                    json.dump(schema_data, file)\n                \n                print(f\"Successfully cached version {version['id']} and its schema.\")\n        \n        print(\"All versions and schemas fetched and cached successfully.\")\n    \n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        exit(1)\n\n# Call the function\nfetch_and_cache_versions()\n```"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a Flash Policy Server class in JavaScript using Node.js's net module to handle cross-domain policy requests for socket connections.\n\nClass Description: The FlashPolicyServer class creates a TCP server that responds to Flash socket policy requests. It manages allowed origins/ports, compiles the XML policy file, and handles server lifecycle events.\n\nAttributes:\n- origins: [Array] - List of allowed domain:port combinations\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [Object] - TCP server instance\n- buffer: [Buffer] - Compiled policy file in binary format\n- server: [Object] - Optional existing server instance to attach to\n\nMethods:\n- constructor(options, origins) -> [FlashPolicyServer] - Initializes the server with options and allowed origins\n- listen(port, server, cb) -> [FlashPolicyServer] - Starts listening on specified port, optionally attaching to existing server\n- responder(socket) -> [void] - Responds to policy requests on a socket connection\n- compile() -> [FlashPolicyServer] - Generates the XML policy buffer from allowed origins\n- add() -> [FlashPolicyServer] - Adds new allowed origins to the policy\n- remove(origin) -> [FlashPolicyServer] - Removes an origin from the allowed list\n- close() -> [FlashPolicyServer] - Stops the server and cleans up listeners",
    "Canonical_solution": "var net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => this.responder(socket));\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges.'\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (data && data[0] === 60 && data.toString() === '<policy-file-request/>\\0' &&\n              socket && (socket.readyState === 'open' || socket.readyState === 'writeOnly')) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    this.port >= 0 && this.socket.listen(this.port, () => {\n      this.socket.online = true;\n      if (callback) {\n        callback.call(this);\n        callback = undefined;\n      }\n    });\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = new Buffer(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options = {}, origins = []) {\n    this.origins = origins;\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server || null;\n\n    this.compile();\n  }\n\n  listen(port = this.port, server = this.server, cb = () => {}) {\n    if (server) {\n      this.server = server;\n      this.server.on('connection', (socket) => this.responder(socket));\n    } else {\n      this.server = net.createServer((socket) => this.responder(socket));\n    }\n    this.server.listen(port, cb);\n    return this;\n  }\n\n  responder(socket) {\n    try {\n      socket.write(this.buffer);\n      socket.end();\n    } catch (error) {\n      this.log('Error responding to policy request:', error);\n    }\n  }\n\n  compile() {\n    const xml = '<?xml version=\"1.0\"?><cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"*\"/></cross-domain-policy>';\n    this.buffer = Buffer.from(xml, 'utf8');\n    return this;\n  }\n\n  add(origin) {\n    if (!this.origins.includes(origin)) {\n      this.origins.push(origin);\n      this.compile();\n    }\n    return this;\n  }\n\n  remove(origin) {\n    this.origins = this.origins.filter(o => o !== origin);\n    this.compile();\n    return this;\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close(() => {\n        this.log('Server closed');\n      });\n    }\n    return this;\n  }\n}\n\nmodule.exports = FlashPolicyServer;\n```"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```typescript\nimport { EventEmitter } from 'events';\n\nenum STATES {\n  DISCONNECTED,\n  CONNECTING,\n  SYNCHRONIZING,\n  OPEN,\n  ERROR\n}\n\nclass OrderBook extends EventEmitter {\n  private productID: string;\n  private websocketURI: string;\n  private restURI: string;\n  public state: string = STATES.DISCONNECTED;\n  private fail_count: number = 0;\n  private timeProvider: any;\n  private socket: WebSocket | null = null;\n  private queue: Array<any> = [];\n  public book: object = {};\n\n  constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.timeProvider = timeProvider;\n  }\n\n  public clear_book(): void {\n    this.book = {};\n    this.queue = [];\n  }\n\n  public connect(): void {\n    if (this.state !== STATES.DISCONNECTED && this.state !== STATES.ERROR) return;\n    this.changeState(STATES.CONNECTING);\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = () => this.onOpen();\n    this.socket.onclose = () => this.onClose();\n    this.socket.onmessage = (event) => this.onMessage(event.data);\n  }\n\n  public disconnect(): void {\n    if (!this.socket || this.state === STATES.DISCONNECTED) return;\n    this.socket.close();\n    this.socket = null;\n    this.clear_book();\n    this.changeState(STATES.DISCONNECTED);\n  }\n\n  private changeState(stateName: string): void {\n    const oldState = this.state;\n    this.state = stateName;\n    this.emit('statechange', oldState, this.state);\n  }\n\n  private onOpen(): void {\n    this.sync();\n    this.changeState(STATES.SYNCHRONIZING);\n  }\n\n  private onClose(): void {\n    this.fail_count++;\n    this.changeState(STATES.ERROR);\n    setTimeout(() => this.connect(), 5000 * this.fail_count);\n  }\n\n  private onMessage(datastr: string): void {\n    try {\n      const message = JSON.parse(datastr);\n      const t = this.timeProvider.now();\n      this.processMessage(message, t);\n    } catch (error) {\n      console.error('Error parsing message:', error);\n    }\n  }\n\n  private sync(): void {\n    this.socket?.send(JSON.stringify({ type: 'subscribe', product_ids: [this.productID] }));\n    fetch(`${this.restURI}?product_id=${this.productID}`)\n      .then(response => response.json())\n      .then(snapshot => {\n        this.book = snapshot;\n        this.changeState(STATES.OPEN);\n      })\n      .catch(error => {\n        console.error('Error fetching snapshot:', error);\n        this.fail_count++;\n        this.changeState(STATES.ERROR);\n        setTimeout(() => this.connect(), 5000 * this.fail_count);\n      });\n  }\n\n  private processMessage(message: object, t: Date): void {\n    switch (message['type']) {\n      case 'snapshot':\n        this.book = message;\n        break;\n      case 'match':\n        // Handle match event\n        break;\n      default:\n        console.warn(`Unhandled message type: ${message['type']}`);\n    }\n    this.emit(message['type'], message, t);\n  }\n}\n```"
  },
  {
    "Task_id": 195,
    "Instruction": "Task Description: Create a function to test WebSocket communication between a client and server, verifying the ability to send and receive empty payload messages.\n\nFunction Description: The function sets up a WebSocket server and client, where the server echoes back an empty message when it receives any message from the client. The test verifies that the client can successfully receive this empty message.\n\nInput: None (The function is self-contained and doesn't require external parameters)\n\nOutput: None (The function performs assertions internally and doesn't return any value)",
    "Canonical_solution": "function testWebSocketCommunication() {\n  const { test } = require('node:test');\n  const { WebSocketServer } = require('ws');\n  const { WebSocket } = require('../..');\n  const { tspl } = require('@matteo.collina/tspl');\n\n  test('Receiving frame with payload length 0 works', async (t) => {\n    const { ok, completed } = tspl(t, { plan: 1 });\n\n    const server = new WebSocketServer({ port: 0 });\n\n    server.on('connection', (socket) => {\n      socket.on('message', () => {\n        socket.send('');\n      });\n    });\n\n    t.after(() => {\n      server.close();\n      ws.close();\n    });\n\n    const ws = new WebSocket(`ws://127.0.0.1:${server.address().port}`);\n\n    ws.addEventListener('open', () => {\n      ws.send('Hi');\n    });\n\n    ws.addEventListener('message', () => {\n      ok(true);\n    });\n\n    await completed;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "```python\nimport asyncio\nimport websockets\n\nasync def echo_server(websocket, path):\n    async for message in websocket:\n        await websocket.send('')\n\nstart_server = websockets.serve(echo_server, \"localhost\", 8765)\n\nasync def test_empty_message():\n    uri = \"ws://localhost:8765\"\n    async with websockets.connect(uri) as websocket:\n        await websocket.send('')\n        response = await websocket.recv()\n        assert response == ''\n\nasyncio.get_event_loop().run_until_complete(start_server)\nasyncio.get_event_loop().run_until_complete(test_empty_message())\nasyncio.get_event_loop().close()\n```"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nclass Channel {\n    constructor(ws) {\n        this._ws = ws;\n        this._handler = null;\n        this._messageListener = this._messageReceived.bind(this);\n        this._ws.on('message', this._messageListener);\n    }\n\n    send(message) {\n        if (this._ws.readyState === WebSocket.OPEN) {\n            this._ws.send(JSON.stringify(message));\n        }\n    }\n\n    close() {\n        this._ws.close();\n    }\n\n    listen(handler) {\n        this._handler = handler;\n    }\n\n    dispose() {\n        this._ws.removeEventListener('message', this._messageListener);\n    }\n\n    _messageReceived(message) {\n        if (this._handler) {\n            try {\n                const data = JSON.parse(message);\n                this._handler(data);\n            } catch (error) {\n                console.error('Error parsing message:', error);\n            }\n        }\n    }\n}\n\nclass NddService {\n    constructor(frontend) {\n        this._disconnectPromise = new Promise((resolve) => {\n            process.on('disconnect', resolve);\n        });\n        this._connected = new Set();\n        this._frontend = frontend;\n        this._pipe = '/path/to/named/pipe';\n        this._setupIPCServer();\n    }\n\n    async _startSession(info, frontend) {\n        const sessionId = info.id;\n        this._connected.add(sessionId);\n\n        const cleanup = async () => {\n            this._connected.delete(sessionId);\n            await frontend.sessionClosed(sessionId);\n        };\n\n        // Simulate session start logic here\n        await frontend.sessionStarted(sessionId);\n\n        return cleanup;\n    }\n\n    _setupIPCServer() {\n        // Implement IPC server setup here\n    }\n}\n```"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome's DevTools Protocol, handling connection, message exchange, and event emission.\n\nClass Description: The Chrome class extends EventEmitter to create a WebSocket client that connects to Chrome's DevTools Protocol. It manages WebSocket connections, handles message parsing, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- _notifier: [Object] - External notification handler\n- _callbacks: [Object] - Map of pending command callbacks\n- _nextCommandId: [Number] - Counter for generating command IDs\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- constructor: [constructor](options: Object, notifier: Object) -> [Chrome] - Initializes the Chrome instance with connection options and notifier\n- _connectToWebSocket: [_connectToWebSocket]() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleMessage: [_handleMessage](message: Object) -> [void] - Processes incoming WebSocket messages (responses and events)\n- _enqueueCommand: [_enqueueCommand](method: String, params: Object, sessionId: String, callback: Function) -> [void] - Sends a command through WebSocket and tracks its callback\n- send: [send](method: String, ...args: Any) -> [Promise|undefined] - Public method to send commands, supporting both callback and Promise patterns",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this._notifier = notifier;\n        this._callbacks = {};\n        this._nextCommandId = 1;\n        this.webSocketUrl = undefined;\n        this._start();\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n        \n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nconst EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options = {}, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 1;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}` : `ws://${this.host}:${this.port}`;\n    this._ws = null;\n  }\n\n  async _connectToWebSocket() {\n    return new Promise((resolve, reject) => {\n      this._ws = new WebSocket(this.webSocketUrl);\n      this._ws.onopen = () => resolve();\n      this._ws.onerror = (error) => reject(error);\n      this._ws.onmessage = (event) => this._handleMessage(JSON.parse(event.data));\n    });\n  }\n\n  _handleMessage(message) {\n    if (message.id) {\n      const callback = this._callbacks[message.id];\n      if (callback) {\n        delete this._callbacks[message.id];\n        callback(null, message.result);\n      }\n    } else {\n      this.emit(message.method, message.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const id = this._nextCommandId++;\n    this._ws.send(JSON.stringify({ id, method, params, sessionId }));\n    this._callbacks[id] = callback;\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      const sessionId = args.pop(); // Assuming the last argument is the session ID\n      const params = Array.isArray(args[0]) ? args[0] : args;\n      this._enqueueCommand(method, params, sessionId, (err, result) => {\n        if (err) reject(err);\n        else resolve(result);\n      });\n    });\n  }\n}\n```"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a JavaScript class for interacting with the Cryptsy cryptocurrency exchange API, handling both public and private endpoints with proper authentication and request management.\n\nClass Description: The Cryptsy class provides a wrapper for the Cryptsy API, enabling users to make authenticated requests to private endpoints and public data requests. It handles API authentication, request signing, and response processing.\n\nAttributes:\n- key: string - API key for authentication\n- secret: string - API secret for request signing\n- PUBLIC_API_URL: string - Base URL for public API endpoints (default: 'http://pubapi.cryptsy.com/api.php')\n- PRIVATE_API_URL: string - Base URL for private API endpoints (default: 'https://api.cryptsy.com/api')\n- USER_AGENT: string - User agent string for requests (default: 'nomp/node-open-mining-portal')\n- STRICT_SSL: boolean - Static flag for SSL verification (default: true)\n\nMethods:\n- constructor(key, secret) -> Cryptsy - Initializes the API client with credentials\n- _getPrivateHeaders(parameters: object) -> object - Generates authentication headers for private requests\n- _request(options: object, callback: function) -> Cryptsy - Base request method with common configuration\n- _public(parameters: object, callback: function) -> Cryptsy - Makes public API requests\n- _private(parameters: object, callback: function) -> Cryptsy - Makes authenticated private API requests\n- getTicker(callback: function) -> Cryptsy - Gets market ticker data\n- getOrderBook(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets order book for a currency pair\n- getTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets public trade history\n- myBalances(callback: function) -> Cryptsy - Gets user's account balances\n- myOpenOrders(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's open orders\n- myTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's trade history\n- buy(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a buy order\n- sell(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a sell order\n- cancelOrder(currencyA: string, currencyB: string, orderNumber: string, callback: function) -> Cryptsy - Cancels an order\n- withdraw(currency: string, amount: number, address: string, callback: function) -> Cryptsy - Withdraws funds\n- _joinCurrencies(currencyA: string, currencyB: string) -> string - Helper to format currency pairs",
    "Canonical_solution": "var request = require('request');\nvar nonce = require('nonce');\nvar crypto = require('crypto');\n\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n    }\n\n    static STRICT_SSL = true;\n\n    _getPrivateHeaders(parameters) {\n        if (!this.key || !this.secret) {\n            throw 'Cryptsy: Error. API key and secret required';\n        }\n\n        let paramString = Object.keys(parameters).sort().map(function(param) {\n            return encodeURIComponent(param) + '=' + encodeURIComponent(parameters[param]);\n        }).join('&');\n\n        let signature = crypto.createHmac('sha512', this.secret).update(paramString).digest('hex');\n\n        return {\n            Key: this.key,\n            Sign: signature\n        };\n    }\n\n    _request(options, callback) {\n        if (!('headers' in options)) {\n            options.headers = {};\n        }\n\n        options.headers['User-Agent'] = this.USER_AGENT;\n        options.json = true;\n        options.strictSSL = Cryptsy.STRICT_SSL;\n\n        request(options, function(err, response, body) {\n            callback(err, body);\n        });\n\n        return this;\n    }\n\n    _public(parameters, callback) {\n        let options = {\n            method: 'GET',\n            url: this.PUBLIC_API_URL,\n            qs: parameters\n        };\n\n        return this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        parameters.nonce = nonce();\n        let options = {\n            method: 'POST',\n            url: this.PRIVATE_API_URL,\n            form: parameters,\n            headers: this._getPrivateHeaders(parameters)\n        };\n\n        return this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        let parameters = {\n            method: 'marketdatav2'\n        };\n        return this._public(parameters, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOrderBook',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    myBalances(callback) {\n        let parameters = {\n            command: 'returnBalances'\n        };\n        return this._private(parameters, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOpenOrders',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'buy',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'sell',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        let parameters = {\n            command: 'cancelOrder',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            orderNumber: orderNumber\n        };\n        return this._private(parameters, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        let parameters = {\n            command: 'withdraw',\n            currency: currency,\n            amount: amount,\n            address: address\n        };\n        return this._private(parameters, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return currencyA + '_' + currencyB;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass Cryptsy {\n  constructor(key, secret) {\n    this.key = key;\n    this.secret = secret;\n    this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n    this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n    this.USER_AGENT = 'nomp/node-open-mining-portal';\n    this.STRICT_SSL = true;\n  }\n\n  _getPrivateHeaders(parameters) {\n    const nonce = Math.floor(Date.now() / 1000);\n    const message = nonce + JSON.stringify(parameters);\n    const signature = require('crypto').createHmac('sha512', this.secret).update(message).digest('hex');\n    return {\n      'Key': this.key,\n      'Sign': signature,\n      'Nonce': nonce,\n      'User-Agent': this.USER_AGENT\n    };\n  }\n\n  _request(options, callback) {\n    options.timeout = 30 * 1000; // 30 seconds timeout\n    options.headers['User-Agent'] = this.USER_AGENT;\n    if (!options.headers['Accept']) {\n      options.headers['Accept'] = 'application/json';\n    }\n    if (!options.headers['Content-Type']) {\n      options.headers['Content-Type'] = 'application/json';\n    }\n    if (!this.STRICT_SSL) {\n      options.agentOptions = { rejectUnauthorized: false };\n    }\n    require('https').request(options, (response) => {\n      let data = '';\n      response.on('data', chunk => data += chunk);\n      response.on('end', () => {\n        try {\n          const result = JSON.parse(data);\n          callback(null, result);\n        } catch (error) {\n          callback(error);\n        }\n      });\n    }).on('error', callback).end();\n  }\n\n  _public(parameters, callback) {\n    parameters.method = 'marketdata';\n    const querystring = require('querystring').stringify(parameters);\n    const url = `${this.PUBLIC_API_URL}?${querystring}`;\n    this._request({ url, method: 'GET' }, callback);\n  }\n\n  _private(parameters, callback) {\n    parameters.method = 'private';\n    const headers = this._getPrivateHeaders(parameters);\n    const body = JSON.stringify(parameters);\n    this._request({ url: this.PRIVATE_API_URL, method: 'POST', headers, body }, callback);\n  }\n\n  getTicker(callback) {\n    this._public({}, (err, result) => {\n      if (err) return callback(err);\n      callback(null, result.return.ticker);\n    });\n  }\n\n  getOrderBook(currencyA, currencyB, callback) {\n    this._public({ command: 'orderbook', currencypair: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  getTradeHistory(currencyA, currencyB, callback) {\n    this._public({ command: 'trades', currencypair: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  myBalances(callback) {\n    this._private({ action: 'getbalances' }, callback);\n  }\n\n  myOpenOrders(currencyA, currencyB, callback) {\n    this._private({ action: 'getmyorders', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  myTradeHistory(currencyA, currencyB, callback) {\n    this._private({ action: 'getmytrades', marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  buy(currencyA, currencyB, rate, amount, callback) {\n    this._private({ action: 'buylimit', marketid: this._joinCurrencies(currencyA, currencyB), quantity: amount, price: rate }, callback);\n  }\n\n  sell(currencyA, currencyB, rate, amount, callback) {\n    this._private({ action: 'selllimit', marketid: this._joinCurrencies(currencyA, currencyB), quantity: amount, price: rate }, callback);\n  }\n\n  cancelOrder(currencyA, currencyB, orderNumber, callback) {\n    this._private({ action: 'cancelorder', orderid: orderNumber, marketid: this._joinCurrencies(currencyA, currencyB) }, callback);\n  }\n\n  withdraw(currency, amount, address, callback) {\n    this._private({ action: 'withdraw', currency: currency, quantity: amount, address: address }, callback);\n  }\n\n  _joinCurrencies(currencyA, currencyB) {\n    return `${currencyA}_${currencyB}`;\n  }\n}\n```"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a class that handles the downloading and installation of binary packages from a specified URL, including directory management and error handling.\n\nClass Description: The Binary class is responsible for downloading a binary package from a given URL, extracting it to a specified directory, and managing the installation process. It handles directory creation, file extraction, and provides feedback on the installation status.\n\nAttributes:\n- url: [String] - The URL from which the binary package will be downloaded.\n- name: [String] - The name of the binary package (optional, defaults to -1).\n- installDirectory: [String] - The base directory where the binary will be installed (optional, defaults to a 'bin' subdirectory in the current working directory).\n- binaryDirectory: [String] - The full path to the directory where the binary will be extracted (initialized as -1, set during installation).\n- binaryPath: [String] - The full path to the binary file (initialized as -1, not used in current implementation).\n\nMethods:\n- constructor(url, data) -> [None] - Initializes the Binary instance with the download URL and optional configuration data (name and installDirectory).\n- install() -> [Promise] - Handles the complete installation process including directory preparation, downloading, extraction, and cleanup. Returns a Promise that resolves when installation is complete or rejects on error.\n  - Internal method _getInstallDirectory() is used to determine the installation directory path.",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass Binary {\n    constructor(url, data) {\n        this.url = url;\n        this.name = data.name || -1;\n        this.installDirectory = data.installDirectory || join(__dirname, \"bin\");\n        this.binaryDirectory = -1;\n        this.binaryPath = -1;\n    }\n\n    install() {\n        const dir = this._getInstallDirectory();\n        if (!existsSync(dir)) {\n            mkdirSync(dir, { recursive: true });\n        }\n\n        this.binaryDirectory = join(dir, \"bin\");\n\n        if (existsSync(this.binaryDirectory)) {\n            rimraf.sync(this.binaryDirectory);\n        }\n\n        mkdirSync(this.binaryDirectory, { recursive: true });\n\n        console.log(`Downloading release from ${this.url}`);\n\n        return axios({ url: this.url, responseType: \"stream\" })\n            .then(res => {\n                const writer = tar.x({ strip: 1, C: this.binaryDirectory });\n\n                return new Promise((resolve, reject) => {\n                    res.data.pipe(writer);\n                    let error = null;\n                    writer.on('error', err => {\n                      error = err;\n                      reject(err);\n                    });\n                    writer.on('close', () => {\n                      if (!error) {\n                        resolve(true);\n                      }\n                    });\n                })\n            })\n            .then(() => {\n                console.log(\n                    `${this.name ? this.name : \"Your package\"} has been installed!`\n                );\n            })\n            .catch(e => {\n                error(`Error fetching release: ${e.message}`);\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass Binary {\n    constructor(url, data = {}) {\n        this.url = url;\n        this.name = data.name || '-1';\n        this.installDirectory = data.installDirectory || './bin';\n        this.binaryDirectory = '-1';\n        this.binaryPath = '-1';\n    }\n\n    async install() {\n        try {\n            const installDir = await this._getInstallDirectory();\n            console.log(`Installing ${this.name} to ${installDir}`);\n            // Simulate download and extraction\n            await this._downloadAndExtract(this.url, installDir);\n            console.log(`${this.name} installed successfully.`);\n            return { success: true };\n        } catch (error) {\n            console.error(`Failed to install ${this.name}:`, error);\n            return { success: false, error };\n        }\n    }\n\n    async _getInstallDirectory() {\n        if (!fs.existsSync(this.installDirectory)) {\n            fs.mkdirSync(this.installDirectory, { recursive: true });\n        }\n        return this.installDirectory;\n    }\n\n    async _downloadAndExtract(url, installDir) {\n        // Placeholder for download logic\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });\n        const fileName = url.split('/').pop();\n        const filePath = path.join(installDir, fileName);\n        await this._extractBlob(blob, filePath);\n        this.binaryDirectory = installDir;\n        this.binaryPath = filePath;\n    }\n\n    async _extractBlob(blob, filePath) {\n        // Placeholder for extraction logic\n        // This could involve using a library like adm-zip or similar\n        console.log(`Extracting ${filePath}`);\n        // Actual extraction code would go here\n    }\n}\n```"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "```javascript\nfunction testWebSocketConnection(wssUrl) {\n    const socket = new WebSocket(`wss://${wssUrl}`);\n\n    socket.onopen = () => {\n        console.log('WebSocket connection opened');\n        socket.send(JSON.stringify({ type: 'init', message: 'Hello Server!' }));\n    };\n\n    socket.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        console.log('Received from server:', data);\n    };\n\n    socket.onerror = (error) => {\n        console.error('WebSocket error:', error);\n    };\n\n    socket.onclose = (event) => {\n        console.log('WebSocket connection closed', event);\n    };\n}\n```"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles WebSocket connections, message processing, and connection lifecycle events. The class should support sending and receiving JSON messages, handling different commands, and managing connection states.\n\nClass Description: The `Client` class represents a WebSocket client that connects to a server, processes incoming messages, and sends commands. It handles connection events, message parsing, and provides methods for common operations like sending hello messages and triggering reloads.\n\nAttributes:\n- `ws`: [WebSocket] - The WebSocket connection instance.\n- `options`: [Object] - Configuration options for the client.\n- `id`: [String] - Unique identifier for the client instance.\n- `plugins`: [Array] - List of plugins received from the server.\n- `url`: [String] - URL received from the server.\n\nMethods:\n- `constructor(req, socket, head, options)` -> [Client] - Initializes a new WebSocket client instance with the given request, socket, head, and options.\n- `message(event)` -> [void] - Handles incoming WebSocket messages, parses them, and routes to appropriate command handlers.\n- `close(event)` -> [void] - Closes the WebSocket connection and emits an 'end' event.\n- `hello()` -> [void] - Sends a 'hello' command to the server with supported protocols and server name.\n- `info(data)` -> [void] - Processes 'info' command data from the server, storing plugins and URL.\n- `reload(files)` -> [void] - Sends 'reload' commands for each file in the provided list, with live reload options.\n- `_data(event)` -> [Object] - Parses incoming message data from JSON string to object.\n- `send(data)` -> [void] - Sends data as a JSON string over the WebSocket connection.\n- `uniqueId(prefix)` -> [String] - Generates a unique ID with an optional prefix.",
    "Canonical_solution": "var WebSocket = require('faye-websocket');\n\nclass Client {\n  constructor(req, socket, head, options) {\n    options = this.options = options || {};\n    this.ws = new WebSocket(req, socket, head);\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n    this.id = this.uniqueId('ws');\n  }\n\n  message(event) {\n    var data = this.data(event);\n    if(this[data.command]) return this[data.command](data);\n  }\n\n  close(event) {\n    if(this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.emit('end', event);\n  }\n\n  hello() {\n    this.send({\n      command: 'hello',\n      protocols: [\n        'http://livereload.com/protocols/official-7'\n      ],\n      serverName: 'tiny-lr'\n    });\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(function(file) {\n      this.send({\n        command: 'reload',\n        path: file,\n        liveCss: this.options.liveCss !== false,\n        liveJs: this.options.liveJs !== false,\n        liveImg: this.options.liveImg !== false\n      });\n    }, this);\n  }\n\n  _data(event) {\n    var data = {};\n    try {\n      data = JSON.parse(event.data);\n    } catch (e) {}\n    return data;\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  }\n}\n\nvar idCounter = 0;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass Client {\n  constructor(req, socket, head, options) {\n    this.ws = new WebSocket(`ws://${req.headers.host}`);\n    this.options = options;\n    this.id = this.uniqueId('client_');\n    this.plugins = [];\n    this.url = '';\n\n    this.ws.on('open', () => this.hello());\n    this.ws.on('message', (event) => this.message(event));\n    this.ws.on('close', (event) => this.close(event));\n  }\n\n  message(event) {\n    const data = this._data(event);\n    if (data.command === 'info') this.info(data);\n    // Add more command handlers here\n  }\n\n  close(event) {\n    console.log('Connection closed', event);\n    this.emit('end');\n  }\n\n  hello() {\n    this.send({\n      command: 'hello',\n      protocols: ['v1'],\n      server: 'myserver'\n    });\n  }\n\n  info(data) {\n    this.plugins = data.plugins || [];\n    this.url = data.url || '';\n  }\n\n  reload(files) {\n    files.forEach(file => {\n      this.send({\n        command: 'reload',\n        file,\n        live: true\n      });\n    });\n  }\n\n  _data(event) {\n    return JSON.parse(event.data);\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix = '') {\n    return `${prefix}${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n```"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Implement a LiveQueryClient class that manages WebSocket connections for real-time data updates in a Parse server environment, handling connection lifecycle, subscriptions, and error recovery.\n\nClass Description: The LiveQueryClient class establishes and maintains a WebSocket connection to a Parse LiveQuery server, manages subscriptions to queries, handles connection events (open, message, error, close), and implements automatic reconnection logic.\n\nAttributes:\n- attempts: number - Tracks reconnection attempts for exponential backoff\n- id: number - Unique client identifier assigned by server\n- requestId: number - Counter for subscription requests\n- applicationId: string - Parse application ID for authentication\n- serverURL: string - WebSocket server URL (must start with 'ws' or 'wss')\n- javascriptKey: string (optional) - JavaScript key for authentication\n- masterKey: string (optional) - Master key for authentication\n- sessionToken: string (optional) - User session token\n- installationId: string (optional) - Device installation identifier\n- additionalProperties: boolean - Flag to include additional properties in requests\n- connectPromise: Promise - Promise resolved when connection is established\n- subscriptions: Map<number, LiveQuerySubscription> - Active subscriptions\n- socket: WebSocketController - WebSocket connection controller\n- state: string - Current connection state (INITIALIZED, CONNECTING, CONNECTED, etc.)\n- reconnectHandle: any - Timeout handle for reconnection attempts\n- emitter: EventEmitter - Event emitter for connection events\n- on: function - Shortcut to emitter.on\n- emit: function - Shortcut to emitter.emit\n\nMethods:\n- constructor({applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId}) -> void - Initializes the client with connection parameters and validates serverURL\n- open() -> void - Establishes WebSocket connection and sets up event handlers\n- _handleWebSocketOpen() -> void - Sends connection request to server after WebSocket opens\n- _handleWebSocketMessage(event: any) -> void - Processes incoming messages from server and handles connection confirmation\n- _handleWebSocketClose() -> void - Handles connection closure and triggers reconnection\n- _handleWebSocketError(error: any) -> void - Handles WebSocket errors and triggers reconnection\n- _handleReconnect() -> void - Implements exponential backoff reconnection logic",
    "Canonical_solution": "import CoreManager, { WebSocketController } from './CoreManager';\nimport ParseObject from './ParseObject';\nimport LiveQuerySubscription from './LiveQuerySubscription';\nimport { resolvingPromise } from './promiseUtils';\nimport ParseError from './ParseError';\nimport type ParseQuery from './ParseQuery';\n\nclass LiveQueryClient {\n  attempts: number;\n  id: number;\n  requestId: number;\n  applicationId: string;\n  serverURL: string;\n  javascriptKey?: string;\n  masterKey?: string;\n  sessionToken?: string;\n  installationId?: string;\n  additionalProperties: boolean;\n  connectPromise: any;\n  subscriptions: Map<number, LiveQuerySubscription>;\n  socket: WebSocketController & { closingPromise?: any };\n  state: string;\n  reconnectHandle: any;\n  emitter: any;\n  on: any;\n  emit: any;\n\n  constructor({\n    applicationId,\n    serverURL,\n    javascriptKey,\n    masterKey,\n    sessionToken,\n    installationId,\n  }) {\n    if (!serverURL || serverURL.indexOf('ws') !== 0) {\n      throw new Error(\n        'You need to set a proper Parse LiveQuery server url before using LiveQueryClient'\n      );\n    }\n\n    this.reconnectHandle = null;\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.serverURL = serverURL;\n    this.applicationId = applicationId;\n    this.javascriptKey = javascriptKey || undefined;\n    this.masterKey = masterKey || undefined;\n    this.sessionToken = sessionToken || undefined;\n    this.installationId = installationId || undefined;\n    this.additionalProperties = true;\n    this.connectPromise = resolvingPromise();\n    this.subscriptions = new Map();\n    this.state = CLIENT_STATE.INITIALIZED;\n    const EventEmitter = CoreManager.getEventEmitter();\n    this.emitter = new EventEmitter();\n\n    this.on = (eventName, listener) => this.emitter.on(eventName, listener);\n    this.emit = (eventName, ...args) => this.emitter.emit(eventName, ...args);\n    this.on('error', () => {});\n  }\n\n  open() {\n    const WebSocketImplementation = CoreManager.getWebSocketController();\n    if (!WebSocketImplementation) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n      return;\n    }\n\n    if (this.state !== CLIENT_STATE.RECONNECTING) {\n      this.state = CLIENT_STATE.CONNECTING;\n    }\n\n    this.socket = new WebSocketImplementation(this.serverURL);\n    this.socket.closingPromise = resolvingPromise();\n\n    this.socket.onopen = () => {\n      this._handleWebSocketOpen();\n    };\n\n    this.socket.onmessage = event => {\n      this._handleWebSocketMessage(event);\n    };\n\n    this.socket.onclose = event => {\n      this.socket.closingPromise?.resolve(event);\n      this._handleWebSocketClose();\n    };\n\n    this.socket.onerror = error => {\n      this._handleWebSocketError(error);\n    };\n  }\n\n  _handleWebSocketOpen() {\n    const connectRequest = {\n      op: OP_TYPES.CONNECT,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken,\n      installationId: undefined as string | undefined,\n    };\n    if (this.additionalProperties) {\n      connectRequest.installationId = this.installationId;\n    }\n    this.socket.send(JSON.stringify(connectRequest));\n  }\n\n  _handleWebSocketMessage(event: any) {\n    let data = event.data;\n    if (typeof data === 'string') {\n      data = JSON.parse(data);\n    }\n    let subscription: null | LiveQuerySubscription = null;\n    if (data.requestId) {\n      subscription = this.subscriptions.get(data.requestId) || null;\n    }\n    const response = {\n      clientId: data.clientId,\n      installationId: data.installationId,\n    };\n    switch (data.op) {\n    case OP_EVENTS.CONNECTED:\n      if (this.state === CLIENT_STATE.RECONNECTING) {\n        this.resubscribe();\n      }\n      this.emit(CLIENT_EMMITER_TYPES.OPEN);\n      this.id = data.clientId;\n      this.connectPromise.resolve();\n      this.state = CLIENT_STATE.CONNECTED;\n      break;\n    }\n  }\n\n  _handleWebSocketClose() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.CLOSED;\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error: any) {\n    this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);\n    }\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.RECONNECTING;\n    const time = generateInterval(this.attempts);\n\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n    this.reconnectHandle = setTimeout(\n      (() => {\n        this.attempts++;\n        this.connectPromise = resolvingPromise();\n        this.open();\n      }).bind(this),\n      time\n    );\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```typescript\nimport { EventEmitter } from 'events';\n\ninterface LiveQuerySubscription {\n  query: any;\n  callback: Function;\n}\n\nclass WebSocketController {\n  send(data: any): void {\n    // Implementation of sending data over WebSocket\n  }\n  close(): void {\n    // Implementation of closing WebSocket connection\n  }\n}\n\nclass LiveQueryClient {\n  private attempts: number = 0;\n  private id: number | null = null;\n  private requestId: number = 1;\n  private applicationId: string;\n  private serverURL: string;\n  private javascriptKey?: string;\n  private masterKey?: string;\n  private sessionToken?: string;\n  private installationId?: string;\n  private additionalProperties: boolean = false;\n  private connectPromise: Promise<void>;\n  private subscriptions: Map<number, LiveQuerySubscription> = new Map();\n  private socket: WebSocketController | null = null;\n  private state: string = 'INITIALIZED';\n  private reconnectHandle: any = null;\n  private emitter: EventEmitter;\n\n  constructor({\n    applicationId,\n    serverURL,\n    javascriptKey,\n    masterKey,\n    sessionToken,\n    installationId,\n  }: {\n    applicationId: string;\n    serverURL: string;\n    javascriptKey?: string;\n    masterKey?: string;\n    sessionToken?: string;\n    installationId?: string;\n  }) {\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.emitter = new EventEmitter();\n    this.on = this.emitter.on.bind(this.emitter);\n    this.emit = this.emitter.emit.bind(this.emitter);\n    this.validateServerURL();\n  }\n\n  private validateServerURL(): void {\n    if (!this.serverURL.startsWith('ws') && !this.serverURL.startsWith('wss')) {\n      throw new Error('Invalid server URL. Must start with ws or wss.');\n    }\n  }\n\n  public open(): void {\n    if (this.state !== 'INITIALIZED') return;\n    this.state = 'CONNECTING';\n    this.socket = new WebSocketController();\n    this.socket.send = (data: any): void => {\n      this._handleWebSocketMessage({ data });\n    };\n    this.socket.close = (): void => {\n      this._handleWebSocketClose();\n    };\n    this.socket.send(JSON.stringify({ action: 'connect', applicationId: this.applicationId }));\n  }\n\n  private _handleWebSocketOpen(): void {\n    // Handle WebSocket open event\n  }\n\n  private _handleWebSocketMessage(event: any): void {\n    const data = JSON.parse(event.data);\n    if (data.event === 'connected') {\n      this.id = data.clientId;\n      this.connectPromise.resolve();\n      this.state = 'CONNECTED';\n      this.reconnectHandle = null;\n    }\n  }\n\n  private _handleWebSocketClose(): void {\n    this.state = 'DISCONNECTED';\n    this._handleReconnect();\n  }\n\n  private _handleWebSocketError(error: any): void {\n    console.error('WebSocket error:', error);\n    this._handleReconnect();\n  }\n\n  private _handleReconnect(): void {\n    if (this.reconnectHandle) clearTimeout(this.reconnectHandle);\n    this.reconnectHandle = setTimeout(() => {\n      this.attempts++;\n      this.open();\n    }, Math.pow(2, this.attempts) * 1000);\n  }\n}\n```"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a function to establish and manage a WebSocket connection in a browser environment, including handling connection events, sending messages, and closing the connection.\n\nFunction Description: The function `setupWebSocketConnection` initializes a WebSocket connection to a specified URL and provides methods to interact with the connection. It sets up event handlers for connection events (`open`, `message`, `close`, `error`) and returns an object with methods to send data, close the connection, and set the binary type of the WebSocket.\n\nInput: \n- `url` [String] - The URL to which the WebSocket connection will be established.\n\nOutput: \n- Returns an object with the following methods:\n  - `send(data)` - Sends data through the WebSocket connection.\n  - `close()` - Closes the WebSocket connection.\n  - `setBinaryType(type)` - Sets the binary type of the WebSocket connection (`blob` or `arraybuffer`).",
    "Canonical_solution": "function setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  \n  ws.onopen = function() {\n    alert('open');\n  };\n  \n  ws.onmessage = function(message) {\n    alert(message.data);\n  };\n  \n  ws.onclose = function() {\n    alert('close');\n  };\n  \n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    send: function(data) {\n      ws.send(data);\n    },\n    close: function() {\n      ws.close();\n    },\n    setBinaryType: function(type) {\n      ws.binaryType = type;\n    }\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nfunction setupWebSocketConnection(url) {\n    const socket = new WebSocket(url);\n\n    const handleOpen = () => {\n        console.log('WebSocket connection opened');\n    };\n\n    const handleMessage = (event) => {\n        console.log('Message from server ', event.data);\n    };\n\n    const handleClose = (event) => {\n        console.log(`WebSocket connection closed with code ${event.code}`);\n    };\n\n    const handleError = (error) => {\n        console.error('WebSocket error observed:', error);\n    };\n\n    socket.addEventListener('open', handleOpen);\n    socket.addEventListener('message', handleMessage);\n    socket.addEventListener('close', handleClose);\n    socket.addEventListener('error', handleError);\n\n    return {\n        send: (data) => {\n            if (socket.readyState === WebSocket.OPEN) {\n                socket.send(data);\n            } else {\n                console.error('WebSocket is not open');\n            }\n        },\n        close: () => {\n            socket.close();\n        },\n        setBinaryType: (type) => {\n            if (['blob', 'arraybuffer'].includes(type)) {\n                socket.binaryType = type;\n            } else {\n                console.error('Invalid binary type');\n            }\n        }\n    };\n}\n```"
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Implement a WebSocket client for audio streaming and transcription that connects to a server, handles real-time audio capture, and processes server responses for transcription and status updates.\n\nFunction Description: The `startRecording` function initializes a WebSocket connection to a specified server, configures audio capture from the user's microphone, and handles bidirectional communication with the server for audio streaming and transcription services. It manages connection events, server status updates, and transcription results while handling errors and disconnections gracefully.\n\nInput:\n- `data`: [Object] - Configuration object containing:\n  - `host`: [String] - WebSocket server host address\n  - `port`: [String|Number] - WebSocket server port\n  - `language`: [String] - Preferred language for transcription\n  - `task`: [String] - Task type (e.g., \"transcription\")\n  - `modelSize`: [String] - Model size specification\n  - `useVad`: [Boolean] - Flag for voice activity detection\n\nOutput:\n- None (Void) - The function establishes persistent connections and event handlers but doesn't return a value. Results are handled through:\n  - Browser runtime messages (via `browser.runtime.sendMessage`)\n  - WebSocket events (onmessage, onerror, etc.)\n  - Audio processing callbacks\n\nSide Effects:\n- Creates a WebSocket connection to the specified server\n- Requests microphone permissions and initializes audio capture\n- Modifies browser state through runtime messages\n- Maintains connection state internally through variables (`isServerReady`, `isCapturing`, etc.)",
    "Canonical_solution": "function startRecording(data) {\n    socket = new WebSocket(`ws://${data.host}:${data.port}/`);\n    language = data.language;\n\n    const uuid = generateUUID();\n    socket.onopen = function(e) { \n      socket.send(\n        JSON.stringify({\n            uid: uuid,\n            language: data.language,\n            task: data.task,\n            model: data.modelSize,\n            use_vad: data.useVad\n        })\n      );\n    };\n\n    let isServerReady = false;\n    socket.onmessage = async (event) => {\n      const data = JSON.parse(event.data);\n      if (data[\"uid\"] !== uuid)\n        return;\n      \n      if (data[\"status\"] === \"WAIT\"){\n        await browser.runtime.sendMessage({ action: \"showPopup\", data: data[\"message\"] })\n        return;\n      }\n      \n      if (!isServerReady && data[\"message\"] === \"SERVER_READY\"){\n        isServerReady = true;\n        return;\n      }\n\n      if (language === null ){\n        language = data[\"language\"];\n        await browser.runtime.sendMessage({ action: \"updateSelectedLanguage\", data: language })      \n        return\n      }\n\n      if (data[\"message\"] === \"DISCONNECT\"){\n        await browser.runtime.sendMessage({ action: \"toggleCaptureButtons\", data: false })        \n        return\n      }\n\n      await browser.runtime.sendMessage({ action: \"transcript\", data: event.data })\n          .catch(function(error) {\n            console.error(\"Error sending message:\", error);\n          });\n    };\n\n  navigator.mediaDevices.getUserMedia({ audio: true })\n    .then(function(stream) {\n      const audioDataCache = [];\n      audioContext = new AudioContext();\n      mediaStream = audioContext.createMediaStreamSource(stream);\n      recorder = audioContext.createScriptProcessor(4096, 1, 1);\n\n      recorder.onaudioprocess = async (event) => {\n        if (!audioContext || !isCapturing || !isServerReady || isPaused) return;\n\n        const inputData = event.inputBuffer.getChannelData(0);\n        const audioData16kHz = resampleTo16kHZ(inputData, audioContext.sampleRate);\n\n        audioDataCache.push(inputData);\n        \n        socket.send(audioData16kHz);\n      };\n\n      mediaStream.connect(recorder);\n      recorder.connect(audioContext.destination);\n    })\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nasync function startRecording(data) {\n    const { host, port, language, task, modelSize, useVad } = data;\n    const wsUrl = `ws://${host}:${port}`;\n    let isServerReady = false;\n    let isCapturing = false;\n\n    async function requestMicrophonePermission() {\n        try {\n            await navigator.mediaDevices.getUserMedia({ audio: true });\n            console.log(\"Microphone permission granted\");\n        } catch (err) {\n            console.error(\"Failed to get microphone permission\", err);\n        }\n    }\n\n    function handleConnectionEvents(ws) {\n        ws.onopen = () => {\n            console.log(\"Connected to server\");\n            isServerReady = true;\n            // Send initial configuration to server\n            ws.send(JSON.stringify({\n                language,\n                task,\n                modelSize,\n                useVad\n            }));\n        };\n\n        ws.onerror = (error) => {\n            console.error(\"WebSocket error:\", error);\n        };\n\n        ws.onclose = () => {\n            console.log(\"Disconnected from server\");\n            isServerReady = false;\n            isCapturing = false;\n        };\n\n        ws.onmessage = (event) => {\n            const message = JSON.parse(event.data);\n            if (message.type === \"status\") {\n                console.log(\"Server status:\", message.data);\n                browser.runtime.sendMessage(message.data);\n            } else if (message.type === \"transcript\") {\n                console.log(\"Transcription result:\", message.data);\n                browser.runtime.sendMessage(message.data);\n            }\n        };\n    }\n\n    async function startAudioCapture(ws) {\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        const mediaRecorder = new MediaRecorder(stream);\n\n        mediaRecorder.ondataavailable = (event) => {\n            if (event.data.size > 0 && isServerReady) {\n                ws.send(event.data);\n            }\n        };\n\n        mediaRecorder.start();\n        isCapturing = true;\n    }\n\n    await requestMicrophonePermission();\n    const ws = new WebSocket(wsUrl);\n    handleConnectionEvents(ws);\n    startAudioCapture(ws);\n}\n```"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with reconnection capabilities and event handling.\n\nClass Description: The N class represents a WebSocket client that connects to a specified URL, handles connection events, manages reconnection logic, and forwards received messages to a destination. It provides methods to start, destroy, and manage the WebSocket connection.\n\nAttributes:\n\nurl: [String] - The WebSocket server URL to connect to.\noptions: [Object] - Configuration options for the WebSocket connection.\nsocket: [WebSocket|null] - The WebSocket connection instance.\nstreaming: [Boolean] - Indicates if the connection is actively streaming.\ncallbacks: [Object] - Stores event callbacks for connect and data events.\ndestination: [Object|null] - The target to forward received messages to.\nreconnectInterval: [Number] - Time interval (in seconds) between reconnection attempts.\nshouldAttemptReconnect: [Boolean] - Flag to control reconnection behavior.\ncompleted: [Boolean] - Indicates if the connection has completed its purpose.\nestablished: [Boolean] - Indicates if the connection is successfully established.\nprogress: [Number] - Tracks connection progress (0-1).\nreconnectTimeoutId: [Number] - Timeout ID for reconnection attempts.\nonEstablishedCallback: [Function|null] - Callback when connection is established.\nonCompletedCallback: [Function|null] - Callback when connection is completed.\nhookOnEstablished: [Function|null] - Additional hook for established event.\n\nMethods:\n\nconstructor(url, options) -> [N] - Initializes the WebSocket client with the given URL and options.\nconnect(destination) -> [void] - Sets the destination for received messages.\ndestroy() -> [void] - Closes the WebSocket connection and stops reconnection attempts.\nstart() -> [void] - Initiates the WebSocket connection with event handlers.\nresume() -> [void] - Placeholder for resuming functionality (currently empty).\nonOpen() -> [void] - Handles WebSocket open event, sets progress to 1.\nonClose() -> [void] - Handles WebSocket close/error events, initiates reconnection if enabled.\nonMessage(event) -> [void] - Handles incoming messages, triggers established callbacks, and forwards data to destination.",
    "Canonical_solution": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = true;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== options.reconnectInterval ? options.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = options.onSourceEstablished;\n    this.onCompletedCallback = options.onSourceCompleted;\n    options.hookOnEstablished && (this.hookOnEstablished = options.hookOnEstablished);\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = false;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = false;\n    this.options.protocols \n      ? this.socket = new WebSocket(this.url, this.options.protocols)\n      : this.socket = new WebSocket(this.url);\n    \n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    if (this.shouldAttemptReconnect) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, 1000 * this.reconnectInterval);\n    }\n  }\n\n  onMessage(event) {\n    const wasFirstMessage = !this.established;\n    this.established = true;\n    \n    if (wasFirstMessage && this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    \n    if (wasFirstMessage && this.onEstablishedCallback) {\n      this.onEstablishedCallback(this);\n    }\n    \n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n  }\n}\n\n// External dependencies\nconst WebSocket = window.WebSocket;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nclass N {\n    constructor(url, options = {}) {\n        this.url = url;\n        this.options = options;\n        this.socket = null;\n        this.streaming = false;\n        this.callbacks = { connect: [], data: [] };\n        this.destination = null;\n        this.reconnectInterval = 5;\n        this.shouldAttemptReconnect = true;\n        this.completed = false;\n        this.established = false;\n        this.progress = 0;\n        this.reconnectTimeoutId = null;\n        this.onEstablishedCallback = null;\n        this.onCompletedCallback = null;\n        this.hookOnEstablished = null;\n    }\n\n    connect(destination) {\n        this.destination = destination;\n    }\n\n    destroy() {\n        if (this.socket) {\n            this.socket.close();\n            this.socket = null;\n        }\n        this.shouldAttemptReconnect = false;\n        clearTimeout(this.reconnectTimeoutId);\n    }\n\n    start() {\n        this.socket = new WebSocket(this.url, this.options);\n\n        this.socket.addEventListener('open', () => this.onOpen());\n        this.socket.addEventListener('close', () => this.onClose());\n        this.socket.addEventListener('error', () => this.onClose());\n        this.socket.addEventListener('message', (event) => this.onMessage(event));\n    }\n\n    resume() {}\n\n    onOpen() {\n        this.progress = 1;\n        this.established = true;\n        this.callbacks.connect.forEach(callback => callback());\n        if (this.onEstablishedCallback) this.onEstablishedCallback();\n        if (this.hookOnEstablished) this.hookOnEstablished();\n    }\n\n    onClose() {\n        this.established = false;\n        if (this.shouldAttemptReconnect) {\n            this.reconnectTimeoutId = setTimeout(() => this.start(), this.reconnectInterval * 1000);\n        }\n    }\n\n    onMessage(event) {\n        const message = JSON.parse(event.data);\n        this.callbacks.data.forEach(callback => callback(message));\n        if (this.destination && this.destination.receive) {\n            this.destination.receive(message);\n        }\n        if (!this.completed && this.onCompletedCallback) {\n            this.onCompletedCallback();\n            this.completed = true;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function getChannels() {\n    const url = \"https://api.example.com/tv-channels\";\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        const channels = data.channels.map(channel => ({\n            lang: channel.lang,\n            site_id: channel.site_id,\n            name: channel.name\n        }));\n        return channels;\n    } catch (error) {\n        console.error(\"Error fetching channels:\", error);\n        return [];\n    }\n}\n```"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Create a WebSocket server class that manages WebSocket connections for a webview application, handling connection events and maintaining active connections.\n\nClass Description: The WebviewServer class is responsible for setting up and managing a WebSocket server that facilitates real-time communication between a webview application and a data source. It maintains active connections and provides server information.\n\nAttributes:\n- server: [http.Server] - The underlying HTTP server instance used for WebSocket communication\n- secret: [string] - A secret string used for authentication or security purposes\n- connections: [Set<WebviewConnection>] - A collection of active WebSocket connections\n- config: [Config] - Configuration object containing server settings\n\nMethods:\n- constructor(dataSource: [VisualizationWatchModel], config: [Config]) -> [void] - Initializes the WebSocket server, sets up connection handlers, and stores the configuration\n- get port() -> [number] - Returns the port number on which the server is listening for connections",
    "Canonical_solution": "import { WebSocketStream } from \"@hediet/typed-json-rpc-websocket\";\nimport WebSocket = require(\"ws\");\nimport * as express from \"express\";\nimport * as http from \"http\";\n\nexport class WebviewServer {\n\tprivate readonly server: http.Server;\n\tpublic readonly secret: string;\n\n\tpublic readonly connections = new Set<WebviewConnection>();\n\n\tconstructor(\n\t\tdataSource: VisualizationWatchModel,\n\t\tprivate readonly config: Config\n\t) {\n\t\tconst app = express();\n\t\tthis.server = app.listen();\n\n\t\tconst wss = new WebSocket.Server({ server: this.server });\n\t\twss.on(\"connection\", async ws => {\n\t\t\tconst stream = new WebSocketStream(ws);\n\t\t\tconst c = new WebviewConnection(\n\t\t\t\tdataSource,\n\t\t\t\tstream,\n\t\t\t\tthis,\n\t\t\t\tconfig,\n\t\t\t\tthis.secret\n\t\t\t);\n\t\t\tthis.connections.add(c);\n\t\t\tawait stream.onClosed;\n\t\t\tthis.connections.delete(c);\n\t\t});\n\t}\n\n\tpublic get port(): number {\n\t\tconst httpPort = (this.server.address() as AddressInfo).port;\n\t\treturn httpPort;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "```typescript\nimport http from 'http';\nimport WebSocket from 'ws';\n\nclass WebviewConnection {\n  ws: WebSocket;\n  constructor(ws: WebSocket) {\n    this.ws = ws;\n  }\n}\n\ninterface Config {\n  port: number;\n  host?: string;\n}\n\nclass VisualizationWatchModel {\n  // Placeholder for actual implementation\n}\n\nclass WebviewServer {\n  private server: http.Server;\n  private secret: string;\n  private connections: Set<WebviewConnection>;\n  private config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.config = config;\n    this.secret = 'your_secret_here'; // Replace with actual secret logic\n    this.connections = new Set();\n    this.server = http.createServer();\n    const wss = new WebSocket.Server({ server: this.server });\n\n    wss.on('connection', (ws) => {\n      const connection = new WebviewConnection(ws);\n      this.connections.add(connection);\n\n      ws.on('message', (message) => {\n        console.log(`Received message: ${message}`);\n        // Handle incoming messages\n      });\n\n      ws.on('close', () => {\n        this.connections.delete(connection);\n        console.log('Client disconnected');\n      });\n    });\n\n    this.server.listen(this.config.port, this.config.host || 'localhost', () => {\n      console.log(`WebSocket server running at ws://${this.config.host}:${this.config.port}/`);\n    });\n  }\n\n  get port(): number {\n    return this.config.port;\n  }\n}\n```"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    let config = { method, url, headers };\n\n    if (params) {\n      config.params = this.queryStr(params);\n    }\n\n    if (body) {\n      if (this.isJSONString(body)) {\n        body = JSON.parse(body);\n      }\n      if (this.isJson(body)) {\n        headers['Content-Type'] = 'application/json';\n      }\n      config.data = body;\n    }\n\n    try {\n      const response = await axios(config);\n      return response.data;\n    } catch (error) {\n      throw error.response ? error.response.data : error.message;\n    }\n  }\n\n  queryStr(options) {\n    return Object.keys(options).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`).join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n\n  isJson(obj) {\n    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n  }\n}\n```"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('.channel-item').each((index, element) => {\n    const lang = $(element).find('.lang-code').text().trim();\n    const siteId = $(element).find('.site-id').text().trim();\n    const name = $(element).find('.channel-name').text().trim();\n    channels.push({ lang, site_id: siteId, name });\n  });\n\n  return channels;\n}\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst https = require('https');\n\nfunction installTelemetry() {\n  const enableTelemetry = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (!enableTelemetry) return;\n\n  const nodeVersion = process.version;\n  const platform = process.platform;\n\n  const data = JSON.stringify({\n    nodeVersion,\n    platform\n  });\n\n  const options = {\n    hostname: 'example.com',\n    port: 443,\n    path: '/telemetry/install',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': data.length\n    }\n  };\n\n  const req = https.request(options, res => {\n    // Handle response\n  });\n\n  req.on('error', () => {\n    // Handle error\n  });\n\n  req.write(data);\n  req.end();\n}\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass SauceLabsClient {\n  constructor() {\n    this.auth = null;\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth = { username: saucelabsUsername, access_token: saucelabsToken };\n  }\n\n  async get(path, callback) {\n    const response = await fetch(`https://api.saucelabs.com${path}`, {\n      method: 'GET',\n      headers: {\n        Authorization: `Basic ${Buffer.from(`${this.auth.username}:${this.auth.access_token}`).toString('base64')}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    callback(null, data);\n  }\n\n  async post(path, data, callback) {\n    const response = await fetch(`https://api.saucelabs.com${path}`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Basic ${Buffer.from(`${this.auth.username}:${this.auth.access_token}`).toString('base64')}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const responseData = await response.json();\n    callback(null, responseData);\n  }\n}\n```"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci = null) {\n    this.repo = repo.replace(/\\./g, '_');\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = Boolean(this.repo && this.token);\n  }\n\n  async get() {\n    try {\n      const response = await fetch(`${this.url}/${this.repo}`, {\n        method: 'GET',\n        headers: { Authorization: `Bearer ${this.token}` }\n      });\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching bundle size data:', error);\n      return {};\n    }\n  }\n\n  set(values) {\n    if (!this.enabled) return;\n    try {\n      const payload = { ...values, sha: this.sha };\n      fetch(`${this.url}/${this.repo}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${this.token}` },\n        body: JSON.stringify(payload)\n      }).catch(error => console.error('Error sending bundle size data:', error));\n    } catch (error) {\n      console.error('Error preparing bundle size data:', error);\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function fetchTVChannelData() {\n    const apiUrl = \"https://api.example.com/tvchannels\";\n    const params = new URLSearchParams({\n        page: 1,\n        limit: 50,\n        lang: 'sq'\n    });\n    const url = `${apiUrl}?${params}`;\n\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data.channels.map(channel => ({\n            lang: 'sq',\n            site_id: channel.id,\n            name: channel.name\n        }));\n    } catch (error) {\n        console.error('Error fetching TV channel data:', error);\n        return [];\n    }\n}\n```"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a function to download a video file from a given URL and save it with a specified description as the filename.\n\nFunction Description: The function `downloadVideo` initiates an asynchronous HTTP GET request to download a video file from the provided URL. It handles the response as a binary blob, creates a downloadable link, and triggers the download automatically. The function includes error handling for empty URLs and checks for successful request completion.\n\nInput:\n- `url` (String): The URL of the video file to be downloaded.\n- `desc` (String): The description to be used as the filename for the downloaded video.\n\nOutput: None (The function triggers a file download but does not return any value.)",
    "Canonical_solution": "function downloadVideo(url, desc) {\n    if (isEmpty(url)) {\n        layer.msg('\u6682\u65e0\u6570\u636e');\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\n    xhr.setRequestHeader(\"Access-Control-Allow-Credentials\", true);\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            let blob = this.response;\n            let u = window.URL.createObjectURL(new Blob([blob]));\n            let a = document.createElement('a');\n            a.download = desc + '.mp4';\n            a.href = u;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function downloadVideo(url, desc) {\n    if (!url) throw new Error('URL cannot be empty');\n    try {\n        const response = await fetch(url);\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n        const blob = await response.blob();\n        const urlObj = window.URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = urlObj;\n        a.download = `${desc}.mp4`;\n        document.body.appendChild(a);\n        a.click();\n        window.URL.revokeObjectURL(urlObj);\n        a.remove();\n    } catch (error) {\n        console.error('Error downloading video:', error);\n    }\n}\n```"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass Tool {\n  constructor() {\n    this._node = typeof require !== 'undefined' ? require : null;\n    this._isSurge = !!$httpClient;\n    this._isQuanX = !!$task;\n    this.isSurge = this._isSurge;\n    this.isQuanX = this._isQuanX;\n    this.isResponse = typeof $response !== 'undefined';\n  }\n\n  notify(title, subtitle, message, option = {}) {\n    if (this._isSurge) {\n      $notification.post(title, subtitle, message, option);\n    } else if (this._isQuanX) {\n      $notify(title, subtitle, message, option);\n    }\n  }\n\n  write(value, key) {\n    if (this._isSurge) {\n      return $persistentStore.write(value, key);\n    } else if (this._isQuanX) {\n      return $prefs.set(value, key);\n    }\n    return false;\n  }\n\n  read(key) {\n    if (this._isSurge) {\n      return $persistentStore.read(key);\n    } else if (this._isQuanX) {\n      return $prefs.get(key);\n    }\n    return null;\n  }\n\n  get(options, callback) {\n    if (typeof options === 'string') {\n      options = { url: options };\n    }\n    if (this._isSurge || this._isQuanX) {\n      $httpClient.get(options, callback);\n    } else if (this._node) {\n      const https = this._node.https;\n      https.get(options.url, (res) => {\n        let data = '';\n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          callback(null, { ...options, ...{ body: data } });\n        });\n      }).on('error', callback);\n    }\n  }\n\n  post(options, callback) {\n    if (typeof options === 'string') {\n      options = { url: options };\n    }\n    if (this._isSurge || this._isQuanX) {\n      $httpClient.post(options, callback);\n    } else if (this._node) {\n      const https = this._node.https;\n      const postData = JSON.stringify(options.body);\n      const req = https.request({\n        hostname: new URL(options.url).hostname,\n        port: new URL(options.url).port || 443,\n        path: new URL(options.url).pathname + new URL(options.url).search,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Content-Length': Buffer.byteLength(postData)\n        }\n      }, (res) => {\n        let data = '';\n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          callback(null, { ...options, ...{ body: data } });\n        });\n      }).on('error', callback);\n\n      req.write(postData);\n      req.end();\n    }\n  }\n\n  _status(response) {\n    const status = response.status;\n    return {\n      code: status,\n      text: http.STATUS_CODES[status]\n    };\n  }\n}\n```"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Implement a class for handling chunked data loading via XMLHttpRequest with support for range requests, progress tracking, and error handling.\n\nClass Description: The MozChunkedLoader class is designed to handle asynchronous loading of chunked binary data from a server using XMLHttpRequest with 'moz-chunked-arraybuffer' response type. It supports range requests, tracks loading progress, handles redirects, and provides comprehensive error handling.\n\nAttributes:\n- _seekHandler: [Object] - Handler for URL and range configuration\n- _config: [Object] - Configuration object for the loader\n- _needStash: [Boolean] - Flag indicating whether data needs to be stashed\n- _xhr: [XMLHttpRequest|null] - The XMLHttpRequest instance\n- _requestAbort: [Boolean] - Flag indicating if the request was aborted\n- _contentLength: [Number|null] - Total content length of the resource\n- _receivedLength: [Number] - Number of bytes received so far\n- _dataSource: [Object] - Data source configuration\n- _range: [Object] - Request range parameters\n- _requestURL: [String] - The URL used for the request\n\nMethods:\n- constructor(seekHandler, config) -> [MozChunkedLoader] - Initializes the loader with seek handler and configuration\n- open(dataSource, range) -> [void] - Opens a connection to the specified data source with range parameters\n- abort() -> [void] - Aborts the current request\n- _onReadyStateChange(e) -> [void] - Handles XMLHttpRequest ready state changes\n- _onProgress(e) -> [void] - Handles progress events during data loading\n- _onLoadEnd(e) -> [void] - Handles request completion\n- _onXhrError(e) -> [void] - Handles XMLHttpRequest errors\n\nEvent Callbacks (to be set externally):\n- _onURLRedirect: [Function] - Called when URL redirection occurs\n- _onError: [Function] - Called when an error occurs\n- _onContentLengthKnown: [Function] - Called when content length is determined\n- _onDataArrival: [Function] - Called when new data chunk arrives\n- _onComplete: [Function] - Called when loading completes successfully",
    "Canonical_solution": "class MozChunkedLoader {\n    constructor(seekHandler, config) {\n        this._seekHandler = seekHandler;\n        this._config = config;\n        this._needStash = true;\n        this._xhr = null;\n        this._requestAbort = false;\n        this._contentLength = null;\n        this._receivedLength = 0;\n    }\n\n    open(dataSource, range) {\n        this._dataSource = dataSource;\n        this._range = range;\n\n        let sourceURL = dataSource.url;\n        if (this._config.reuseRedirectedURL && dataSource.redirectedURL != undefined) {\n            sourceURL = dataSource.redirectedURL;\n        }\n\n        let seekConfig = this._seekHandler.getConfig(sourceURL, range);\n        this._requestURL = seekConfig.url;\n\n        let xhr = this._xhr = new XMLHttpRequest();\n        xhr.open('GET', seekConfig.url, true);\n        xhr.responseType = 'moz-chunked-arraybuffer';\n        xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        xhr.onprogress = this._onProgress.bind(this);\n        xhr.onloadend = this._onLoadEnd.bind(this);\n        xhr.onerror = this._onXhrError.bind(this);\n\n        if (dataSource.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        if (typeof seekConfig.headers === 'object') {\n            let headers = seekConfig.headers;\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        if (typeof this._config.headers === 'object') {\n            let headers = this._config.headers;\n            for (let key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        xhr.send();\n    }\n\n    abort() {\n        this._requestAbort = true;\n        if (this._xhr) {\n            this._xhr.abort();\n        }\n    }\n\n    _onReadyStateChange(e) {\n        let xhr = e.target;\n        if (xhr.readyState === 2) {\n            if (xhr.responseURL != undefined && xhr.responseURL !== this._requestURL) {\n                if (this._onURLRedirect) {\n                    let redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n                    this._onURLRedirect(redirectedURL);\n                }\n            }\n\n            if (xhr.status !== 0 && (xhr.status < 200 || xhr.status > 299)) {\n                if (this._onError) {\n                    this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {code: xhr.status, msg: xhr.statusText});\n                }\n            }\n        }\n    }\n\n    _onProgress(e) {\n        if (this._contentLength === null) {\n            if (e.total !== null && e.total !== 0) {\n                this._contentLength = e.total;\n                if (this._onContentLengthKnown) {\n                    this._onContentLengthKnown(this._contentLength);\n                }\n            }\n        }\n\n        let chunk = e.target.response;\n        let byteStart = this._range.from + this._receivedLength;\n        this._receivedLength += chunk.byteLength;\n\n        if (this._onDataArrival) {\n            this._onDataArrival(chunk, byteStart, this._receivedLength);\n        }\n    }\n\n    _onLoadEnd(e) {\n        if (this._requestAbort === true) {\n            this._requestAbort = false;\n            return;\n        }\n\n        if (this._onComplete) {\n            this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n        }\n    }\n\n    _onXhrError(e) {\n        let type = 0;\n        let info = null;\n\n        if (this._contentLength && e.loaded < this._contentLength) {\n            type = LoaderErrors.EARLY_EOF;\n            info = {code: -1, msg: 'Moz-Chunked stream meet Early-Eof'};\n        } else {\n            type = LoaderErrors.EXCEPTION;\n            info = {code: -1, msg: e.constructor.name + ' ' + e.type};\n        }\n\n        if (this._onError) {\n            this._onError(type, info);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nclass MozChunkedLoader {\n  constructor(seekHandler, config) {\n    this._seekHandler = seekHandler;\n    this._config = config;\n    this._needStash = false;\n    this._xhr = null;\n    this._requestAbort = false;\n    this._contentLength = null;\n    this._receivedLength = 0;\n    this._dataSource = null;\n    this._range = null;\n    this._requestURL = '';\n  }\n\n  open(dataSource, range) {\n    this._dataSource = dataSource;\n    this._range = range;\n    this._requestURL = this._seekHandler.getUrl(this._dataSource, this._range);\n    this._xhr = new XMLHttpRequest();\n    this._xhr.open('GET', this._requestURL, true);\n    this._xhr.responseType = 'moz-chunked-arraybuffer';\n    this._xhr.addEventListener('readystatechange', this._onReadyStateChange.bind(this));\n    this._xhr.addEventListener('progress', this._onProgress.bind(this));\n    this._xhr.addEventListener('loadend', this._onLoadEnd.bind(this));\n    this._xhr.addEventListener('error', this._onXhrError.bind(this));\n    this._xhr.send();\n  }\n\n  abort() {\n    this._requestAbort = true;\n    if (this._xhr) {\n      this._xhr.abort();\n    }\n  }\n\n  _onReadyStateChange(e) {\n    if (this._xhr.readyState === XMLHttpRequest.OPENED) {\n      if (this._xhr.status === 302 || this._xhr.status === 301) {\n        this._onURLRedirect(this._xhr.getResponseHeader('Location'));\n      } else if (this._xhr.status === 206) {\n        this._onContentLengthKnown(parseInt(this._xhr.getResponseHeader('Content-Length'), 10));\n      }\n    } else if (this._xhr.readyState === XMLHttpRequest.DONE) {\n      if (this._xhr.status >= 200 && this._xhr.status < 300) {\n        this._onComplete();\n      } else {\n        this._onError(new Error(`Request failed with status ${this._xhr.status}`));\n      }\n    }\n  }\n\n  _onProgress(e) {\n    if (e.lengthComputable) {\n      this._receivedLength += e.loaded;\n      this._onDataArrival(e.loaded, e.total);\n    }\n  }\n\n  _onLoadEnd(e) {\n    if (!this._requestAbort) {\n      this._onLoadEnd(e);\n    }\n  }\n\n  _onXhrError(e) {\n    this._onError(new Error('Network error occurred'));\n  }\n}\n```"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass DataManURL {\n  constructor(url, type = '', options = {}) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options;\n    this._size = null;\n  }\n\n  async getBuffer(callback) {\n    try {\n      const response = await fetch(this.url, this.urlOpts);\n      const buffer = await response.arrayBuffer();\n      callback(null, Buffer.from(buffer));\n    } catch (error) {\n      callback(error);\n    }\n  }\n\n  async getDataUri(callback) {\n    try {\n      const response = await fetch(this.url, this.urlOpts);\n      const buffer = await response.buffer();\n      const dataUri = `data:${this._type};base64,${buffer.toString('base64')}`;\n      callback(null, dataUri);\n    } catch (error) {\n      callback(error);\n    }\n  }\n\n  createReadStream() {\n    return fetch(this.url, this.urlOpts).then(response => response.body.getReader());\n  }\n\n  async size(callback) {\n    if (this._size === null) {\n      try {\n        const response = await fetch(this.url, { ...this.urlOpts, method: 'HEAD' });\n        this._size = response.headers.get('content-length');\n        callback(null, parseInt(this._size, 10));\n      } catch (error) {\n        callback(error);\n      }\n    } else {\n      callback(null, this._size);\n    }\n  }\n\n  type() {\n    return this._type;\n  }\n}\n```"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function sendPostRequest() {\n    const url = \"https://example.com/api\";\n    const data = new URLSearchParams();\n    data.append('key1', 'value1');\n    data.append('key2', 'value2');\n\n    try {\n        const response = await fetch(url, {\n            method: 'POST',\n            body: data,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            credentials: 'include' // Adjust as necessary\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const responseData = await response.text();\n        console.log(responseData);\n    } catch (error) {\n        console.error('Error sending POST request:', error);\n    }\n}\n\n// Call the function to execute it\nsendPostRequest();\n```"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a JavaScript class that handles AJAX requests using XMLHttpRequest, supporting cross-origin requests, custom headers, and various response handling scenarios.\n\nClass Description: The AjaxTransport class provides a wrapper around XMLHttpRequest for making asynchronous HTTP requests. It handles request creation, header management, response processing, and cleanup. The class supports CORS, maintains request state, and provides error handling capabilities.\n\nAttributes:\n\nxhrId: [Number] - Counter for generating unique IDs for each XMLHttpRequest instance\nxhrCallbacks: [Object] - Stores callback functions for active requests\nxhrSuccessStatus: [Object] - Maps certain HTTP status codes to standard success codes\nxhrSupported: [XMLHttpRequest|Boolean] - Stores the created XMLHttpRequest instance or false if not supported\n\nMethods:\n\ncreateXHR: () -> [XMLHttpRequest|undefined] - Creates and returns a new XMLHttpRequest instance or undefined if creation fails\n\nsendRequest: (options: Object, headers: Object, complete: Function) -> [undefined] - \n  Sends an AJAX request with the given configuration\n  options: Contains request parameters (type, url, async, etc.)\n  headers: Key-value pairs of request headers\n  complete: Callback function to handle response\n\nabortRequest: (callback: Function) -> [undefined] - \n  Aborts an active request and executes the given callback\n  callback: Function to execute after aborting\n\ngetTransport: (options: Object) -> [Object|undefined] - \n  Returns a transport object if the request can be handled\n  options: Configuration object for the request\n  Returns an object with send and abort methods or undefined if request can't be handled",
    "Canonical_solution": "var jQuery = require(\"../core\");\nvar support = require(\"../var/support\");\n\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      0: 200,\n      1223: 204\n    };\n    this.xhrSupported = this.createXHR();\n    \n    if (window.ActiveXObject) {\n      jQuery(window).on(\"unload\", () => {\n        for (var key in this.xhrCallbacks) {\n          this.xhrCallbacks[key]();\n        }\n      });\n    }\n    \n    support.cors = !!this.xhrSupported && (\"withCredentials\" in this.xhrSupported);\n    support.ajax = !!this.xhrSupported;\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch(e) {}\n  }\n\n  sendRequest(options, headers, complete) {\n    var xhr = options.xhr();\n    var id = ++this.xhrId;\n\n    xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n    if (options.xhrFields) {\n      for (var i in options.xhrFields) {\n        xhr[i] = options.xhrFields[i];\n      }\n    }\n\n    if (options.mimeType && xhr.overrideMimeType) {\n      xhr.overrideMimeType(options.mimeType);\n    }\n\n    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n      headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n    }\n\n    for (var i in headers) {\n      xhr.setRequestHeader(i, headers[i]);\n    }\n\n    var callback = (type) => {\n      return () => {\n        if (callback) {\n          delete this.xhrCallbacks[id];\n          callback = xhr.onload = xhr.onerror = null;\n\n          if (type === \"abort\") {\n            xhr.abort();\n          } else if (type === \"error\") {\n            complete(xhr.status, xhr.statusText);\n          } else {\n            complete(\n              this.xhrSuccessStatus[xhr.status] || xhr.status,\n              xhr.statusText,\n              typeof xhr.responseText === \"string\" ? { text: xhr.responseText } : undefined,\n              xhr.getAllResponseHeaders()\n            );\n          }\n        }\n      };\n    };\n\n    xhr.onload = callback();\n    xhr.onerror = callback(\"error\");\n    callback = this.xhrCallbacks[id] = callback(\"abort\");\n\n    try {\n      xhr.send(options.hasContent && options.data || null);\n    } catch (e) {\n      if (callback) {\n        throw e;\n      }\n    }\n  }\n\n  abortRequest(callback) {\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (support.cors || this.xhrSupported && !options.crossDomain) {\n      return {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: () => this.abortRequest(callback)\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nclass AjaxTransport {\n    constructor() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = { 200: true, 304: true };\n        this.xhrSupported = typeof XMLHttpRequest !== 'undefined' ? new XMLHttpRequest() : false;\n    }\n\n    createXHR() {\n        return this.xhrSupported ? new XMLHttpRequest() : undefined;\n    }\n\n    sendRequest(options, headers, complete) {\n        const xhr = this.createXHR();\n        if (!xhr) return;\n\n        const id = ++this.xhrId;\n        this.xhrCallbacks[id] = (event) => {\n            const status = xhr.status;\n            if (this.xhrSuccessStatus[status]) {\n                complete(null, xhr.responseText);\n            } else {\n                complete(new Error(`Request failed with status ${status}`));\n            }\n        };\n\n        xhr.open(options.type || 'GET', options.url, options.async !== false);\n        xhr.onload = this.xhrCallbacks[id];\n        xhr.onerror = (error) => complete(error);\n\n        for (const key in headers) {\n            xhr.setRequestHeader(key, headers[key]);\n        }\n\n        xhr.send(options.data);\n    }\n\n    abortRequest(callback) {\n        const xhr = this.xhrSupported;\n        if (xhr && xhr.readyState !== 4) {\n            xhr.abort();\n            callback();\n        }\n    }\n\n    getTransport(options) {\n        if (this.xhrSupported) {\n            return {\n                send: (headers, complete) => this.sendRequest(options, headers, complete),\n                abort: () => this.abortRequest(() => {})\n            };\n        }\n        return undefined;\n    }\n}\n```"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nfunction run_test(data, sender) {\n    if (data === 'xhr') {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://api.example.com/data', true);\n        xhr.onload = function () {\n            if (this.status === 200) {\n                sender.postMessage(this.responseText);\n            } else {\n                sender.postMessage('Error: ' + this.statusText);\n            }\n        };\n        xhr.onerror = function () {\n            sender.postMessage('Network Error');\n        };\n        xhr.send();\n    } else if (data === 'fetch') {\n        fetch('https://api.example.com/data')\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error('Network response was not ok ' + response.statusText);\n                }\n                return response.text();\n            })\n            .then(text => sender.postMessage(text))\n            .catch(error => sender.postMessage('Error: ' + error.message));\n    } else if (data === 'importScripts') {\n        importScripts('script.js');\n        postScriptMessage(sender);\n    } else {\n        sender.postMessage('Unexpected message');\n    }\n}\n```"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nfunction loadYamlUrl(url) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', url);\n  xhr.onload = function() {\n    if (xhr.status === 200) {\n      yamlToForm(xhr.responseText);\n      console.log(xhr.responseText);\n    } else {\n      console.error('Failed to load YAML content:', xhr.statusText);\n    }\n  };\n  xhr.onerror = function() {\n    console.error('Request failed');\n  };\n  xhr.send();\n}\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      \"is.gd\": \"https://is.gd/\",\n      \"goo.gl\": \"https://goo.gl/\",\n      \"budurl.com\": \"https://budurl.com/\",\n      \"snipurl.com\": \"https://snipurl.com/\"\n    };\n    this.timeout = 5000;\n    this.APIs = {};\n  }\n\n  async expand({ url, depth = 0, seen = {} }, callback) {\n    try {\n      if (seen[url]) throw new Error(\"Cycle detected\");\n      seen[url] = true;\n\n      const parsedUrl = new URL(url);\n      const service = Object.keys(this.map).find(key => url.startsWith(this.map[key]));\n      if (!service) return callback({ ...args, err: new Error(\"Unsupported URL service\") });\n\n      let response;\n      if (this.APIs[service]) {\n        response = await this.APIs[service](parsedUrl.pathname);\n      } else {\n        response = await fetch(parsedUrl.href, { method: \"HEAD\", redirect: \"follow\" });\n      }\n\n      const finalUrl = response.url || parsedUrl.href;\n      const finalDepth = depth + 1;\n      const headers = response.headers ? Object.fromEntries(response.headers.entries()) : {};\n\n      callback({\n        url: finalUrl,\n        depth: finalDepth,\n        seen,\n        headers,\n        urlp: parsedUrl\n      });\n    } catch (err) {\n      callback({ ...args, err });\n    }\n  }\n}\n```"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst multer = require('multer');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n\n    // Middleware\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n    const storage = multer.memoryStorage();\n    const upload = multer({ storage });\n    this.app.use(upload.any());\n\n    // Route handlers\n    this.routes = {};\n  }\n\n  async start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.port, () => {\n        resolve();\n      }).on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close(() => {\n        this.server = null;\n      });\n    }\n  }\n\n  addRoute(method, path, handler) {\n    if (!this.routes[path]) {\n      this.routes[path] = [];\n    }\n    this.routes[path].push({ method, handler });\n  }\n\n  get(path, handler) {\n    this.addRoute('GET', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('POST', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('PUT', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('DELETE', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('PATCH', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('OPTIONS', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('TRACE', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('HEAD', path, handler);\n  }\n}\n\nmodule.exports = HTTPServer;\n```"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = null;\n  }\n\n  async request(method, path, params, callback) {\n    const url = `https://api.twitter.com${path}`;\n    const headers = {\n      Authorization: `Bearer ${this.config.accessToken}`,\n      'Content-Type': 'application/json',\n    };\n    const reqOpts = { url, headers, method };\n\n    try {\n      const resp = await new Promise((resolve, reject) => {\n        this._doRestApiRequest(reqOpts, {}, method, (error, response) => {\n          if (error) reject(error);\n          else resolve(response);\n        });\n      });\n\n      if (resp.headers && resp.headers['x-rate-limit-reset']) {\n        this._updateClockOffsetFromResponse(resp);\n      }\n\n      return resp.data || resp.text();\n    } catch (error) {\n      callback(error, null);\n      throw error;\n    }\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    fetch(reqOpts.url, { ...reqOpts, ...twitOptions })\n      .then(res => res.json())\n      .then(data => callback(null, { data, status: res.status }))\n      .catch(error => callback(error, null));\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const twitterTime = new Date(resp.headers['date']).getTime();\n    const localTime = new Date().getTime();\n    this._twitter_time_minus_local_time_ms = twitterTime - localTime;\n  }\n}\n```"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Create a class that implements a simple HTTP server using Express.js framework to provide a FOAAS (F*** Off As A Service) style API, which generates humorous responses to HTTP requests.\n\nClass Description: The FOAAS class creates an Express application that handles various HTTP requests and returns humorous responses in a standardized format. It includes middleware configuration, route handling, and server management capabilities.\n\nAttributes:\n- app: [Object] - The Express application instance\n- operations: [Object] - A dictionary storing available API operations\n- operationsArray: [Array] - An array containing information about available operations\n\nMethods:\n- constructor(options) -> [void] - Initializes the Express application, configures middleware, and sets up default routes\n  - options: [Object] - Configuration options for the application (currently unused in reference implementation)\n  \n- sendIndex(req, res) -> [void] - Sends the index.html file as response\n  - req: [Object] - Express request object\n  - res: [Object] - Express response object\n  \n- start(port) -> [void] - Starts the HTTP server on the specified port and performs initialization checks\n  - port: [Number] - The port number to listen on\n  \n- output(req, res, message, subtitle) -> [void] - Formats and sends the response message\n  - req: [Object] - Express request object\n  - res: [Object] - Express response object\n  - message: [String] - The main response message\n  - subtitle: [String] - The secondary response message (typically containing the requester's name)",
    "Canonical_solution": "const express = require('express');\nconst request = require('request');\n\nclass FOAAS {\n  constructor(options) {\n    this.app = express();\n    this.app.disable('x-powered-by');\n    \n    // Standard Middleware\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n    \n    // Operations\n    this.operations = {};\n    this.operationsArray = [];\n    \n    // Define routes\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/operations', (req, res) => {\n      res.send(this.operationsArray);\n    });\n    \n    // Default Operation\n    this.app.get('/:thing/:from', (req, res) => {\n      const message = `Fuck ${req.params.thing}.`;\n      const subtitle = `- ${req.params.from}`;\n      this.output(req, res, message, subtitle);\n    });\n  }\n\n  sendIndex(req, res) {\n    res.sendFile('./public/index.html');\n  }\n\n  start(port) {\n    this.app.listen(port);\n    console.log(`FOAAS Started on port ${port}`);\n    \n    request(`http://localhost:${port}/operations`, (error, response, body) => {\n      if (error) return console.log('Could not retrieve operations');\n      const ops = JSON.parse(body);\n      \n      ops.forEach((op) => {\n        request({\n          url: `http://localhost:${port}${op.url}`,\n          headers: { Accept: 'text/plain' }\n        }, (error, response, body) => {\n          if (error) return console.log('Could not retrieve operation ' + op.url);\n        });\n      });\n    });\n  }\n\n  output(req, res, message, subtitle) {\n    req.message = message;\n    req.subtitle = subtitle;\n    \n    // Process output\n    res.send(`${message} ${subtitle}`);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\n\nclass FOAAS {\n  constructor(options = {}) {\n    this.app = express();\n    this.operations = {};\n    this.operationsArray = [];\n    this.setupRoutes();\n  }\n\n  setupRoutes() {\n    this.app.get('/', this.sendIndex.bind(this));\n    this.app.get('/api/:operation', this.handleOperation.bind(this));\n  }\n\n  sendIndex(req, res) {\n    res.sendFile(__dirname + '/index.html');\n  }\n\n  handleOperation(req, res) {\n    const operation = req.params.operation;\n    if (!this.operations[operation]) {\n      return res.status(404).send({ error: 'Operation not found' });\n    }\n    const { message, subtitle } = this.operations[operation](req.query);\n    this.output(res, message, subtitle);\n  }\n\n  output(res, message, subtitle) {\n    res.json({\n      message,\n      subtitle,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  start(port) {\n    this.app.listen(port, () => {\n      console.log(`Server running at http://localhost:${port}/`);\n    });\n  }\n}\n\nmodule.exports = FOAAS;\n```"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      isgd: 'https://is.gd',\n      googl: 'https://goo.gl',\n      budurl: 'https://budurl.com',\n      snipurl: 'https://snipurl.com'\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd,\n      googl,\n      budurl,\n      snipurl,\n      generic\n    };\n  }\n\n  expand({ url, depth = 0, seen = {} }, callback) {\n    if (seen[url]) {\n      return callback({ url, err: new Error('Cycle detected') });\n    }\n    seen[url] = true;\n\n    const domain = Object.keys(this.map).find(key => url.startsWith(this.map[key]));\n    if (!domain) {\n      return callback({ url, depth, seen });\n    }\n\n    this.APIs[domain](url, { timeout: this.timeout }, (err, res) => {\n      if (err) {\n        return callback({ url, err, depth, seen });\n      }\n      this.expand({ url: res.headers.location, depth: depth + 1, seen }, callback);\n    });\n  }\n}\n\nfunction isgd(url, options, callback) {\n  // Implementation for isgd API\n}\n\nfunction googl(url, options, callback) {\n  // Implementation for googl API\n}\n\nfunction budurl(url, options, callback) {\n  // Implementation for budurl API\n}\n\nfunction snipurl(url, options, callback) {\n  // Implementation for snipurl API\n}\n\nfunction generic(url, options, callback) {\n  // Implementation for generic URL expansion via HTTP HEAD request\n}\n```"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n    const url = 'https://example.com';\n    const headers = {\n        'User-Agent': 'Mozilla/5.0',\n        'Accept-Encoding': 'gzip'\n    };\n\n    request({url, headers}, (error, response, body) => {\n        if (error) {\n            console.error('Error making HTTP request:', error);\n        } else if (response.statusCode !== 200) {\n            console.error('HTTP request failed with status code:', response.statusCode);\n        } else {\n            console.log('Response body:', body);\n        }\n    });\n}\n\nmakeHttpRequest();\n```"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a function that starts an HTTP server using Express.js to serve static files and provide a real-time clock update endpoint.\n\nFunction Description: The function `startServer` initializes an Express.js application, configures it to serve static files from the current directory, and sets up a route (`/clock`) that sends real-time clock updates to the client every second. The server listens on port 8080.\n\nInput: None\n\nOutput: None (The function starts a server that runs indefinitely until manually stopped)",
    "Canonical_solution": "function startServer() {\n    let express = require('express');\n    let app = express();\n    app.use(express.static(__dirname));\n    app.get('/clock', function(req, res) {\n        setInterval(function() {\n            let date = new Date().toLocaleString();\n            res.write(`\n                <script type=\"text/javascript\">\n                    parent.document.getElementById('clock').innerHTML = \"${date}\";\n                </script>\n            `);\n        }, 1000);\n    });\n    app.listen(8080);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst app = express();\nconst http = require('http').createServer(app);\nconst io = require('socket.io')(http);\n\napp.use(express.static(__dirname));\n\nio.on('connection', (socket) => {\n    setInterval(() => {\n        socket.emit('time', new Date().toISOString());\n    }, 1000);\n});\n\nhttp.listen(8080, () => {\n    console.log('Server running at http://localhost:8080/');\n});\n```"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst next = require('next');\nconst mongoose = require('mongoose');\nconst session = require('express-session');\nconst MongoStore = require('connect-mongo')(session);\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\nasync function setupServer() {\n  await app.prepare();\n  const server = express();\n\n  server.use(\n    session({\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      resave: false,\n      saveUninitialized: true,\n      store: new MongoStore({ url: process.env.MONGO_URL_TEST }),\n      cookie: { secure: process.env.NODE_ENV === 'production' }\n    })\n  );\n\n  server.all('*', (req, res) => handle(req, res));\n\n  const PORT = process.env.PORT || 8000;\n  server.listen(PORT, () => {\n    console.log(`Ready on http://localhost:${PORT}`);\n  });\n}\n\nsetupServer();\n```"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a function to set up an Express server that serves static files for a specific route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures a route to serve a static HTML file, and starts the server on port 3000. It is designed to handle GET requests for the '/users' path by sending the corresponding HTML file.\n\nInput: None\n\nOutput: None (The function starts the server and logs a message to the console when the server is running.)",
    "Canonical_solution": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n    const app = express();\n    \n    app.get('/users', function (req, res) {\n        res.sendFile(path.join(__dirname, 'modules/users/views/list.html'));\n    });\n\n    app.listen(3000, function () {\n        console.log('Servidor rodando em localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst app = express();\n\napp.use('/users', express.static('public/users.html'));\n\napp.listen(3000, () => {\n    console.log('Server is running on http://localhost:3000');\n});\n```"
  }
]