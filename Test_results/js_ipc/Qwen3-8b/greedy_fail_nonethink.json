[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a function that makes an HTTP request using the 'request' module in JavaScript and handles the response via a callback.\n\nFunction Description: The function 'makeHttpRequest' is designed to simplify making HTTP requests by wrapping the 'request' module's functionality. It takes an options object and a callback function, makes the HTTP request, and invokes the callback with the response body if the request is successful (status code 200 and no errors).\n\nInput:  \n- options: [Object] - Configuration object for the HTTP request, including properties like URL, headers, and data.  \n- callback: [Function] - A function to be called with the response body upon successful request completion.  \n\nOutput:  \n- None (The result is handled asynchronously via the callback function).",
    "Canonical_solution": "var request = require('request');\n\nfunction makeHttpRequest(options, callback) {\n    request(options, function(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            callback(body);\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "function makeHttpRequest(options, callback) {\n  request(options, function (error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(body);\n    } else {\n      callback(null, error || response.statusMessage);\n    }\n  });\n}"
  },
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "function Trader(config) {\n  this.key = config.key;\n  this.secret = config.secret;\n  this.currency = config.currency;\n  this.asset = config.asset;\n  this.pair = config.asset + '_' + config.currency;\n  this.name = 'EXMO';\n  this.nonce = 1;\n}\n\nTrader.prototype.api_query = function(method, params, callback) {\n  const nonce = this.nonce++;\n  const timestamp = Math.floor(Date.now() / 1000);\n  const payload = JSON.stringify(params || {});\n  const signature = this._sign(nonce, payload);\n\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Key': this.key,\n      'Timestamp': timestamp,\n      'Signature': signature\n    },\n    body: payload\n  };\n\n  fetch('https://api.exmo.com/v1/' + method, options)\n    .then(response => response.json())\n    .then(data => callback(null, data))\n    .catch(error => callback(error, null));\n};\n\nTrader.prototype._sign = function(nonce, payload) {\n  return crypto.createHmac('sha512', this.secret)\n    .update(nonce.toString() + payload)\n    .digest('hex');\n};"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server with WebSocket support using Express and Socket.IO, implementing a particle simulation system with cluster and client event handling.\n\nFunction Description: The function `startServer` initializes an Express application, sets up static file serving, integrates Socket.IO for real-time communication, and configures a particle simulation system with collision detection and cluster management. It handles particle movement, boundary collisions, and client interactions through defined event handlers.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function starts a server listening on port 3000 but doesn't return any value)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    const server = require('http').Server(app);\n    const io = require('socket.io')(server);\n    const swip = require('../../../src/server/index.js');\n\n    app.use(express.static(__dirname + './../static'));\n\n    swip(io, {\n        cluster: {\n            events: {\n                update: (cluster) => {\n                    const blobs = cluster.data.blobs;\n                    const clients = cluster.clients;\n\n                    const updatedBlobs = blobs.map((blob) => {\n                        const boundaryOffset = blob.size;\n                        const client = clients.find((c) => isParticleInClient(blob, c));\n\n                        let nextPosX = blob.x + blob.speedX;\n                        let nextPosY = blob.y + blob.speedY;\n                        let nextSpeedX = blob.speedX;\n                        let nextSpeedY = blob.speedY;\n\n                        if (client) {\n                            if (((blob.speedX < 0) &&\n                                ((nextPosX - boundaryOffset) < client.transform.x)\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.left, nextPosY))) {\n                                nextPosX = client.transform.x + boundaryOffset;\n                                nextSpeedX = blob.speedX * -1;\n                            } else if (((blob.speedX > 0) &&\n                                ((nextPosX + boundaryOffset) > (client.transform.x + client.size.width))\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.right, nextPosY))) {\n                                nextPosX = client.transform.x + (client.size.width - boundaryOffset);\n                                nextSpeedX = blob.speedX * -1;\n                            }\n\n                            if (((blob.speedY < 0) &&\n                                ((nextPosY - boundaryOffset) < client.transform.y\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.top, nextPosX)))) {\n                                nextPosY = client.transform.y + boundaryOffset;\n                                nextSpeedY = blob.speedY * -1;\n                            } else if (((blob.speedY > 0) &&\n                                ((nextPosY + boundaryOffset) > (client.transform.y + client.size.height))\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.bottom, nextPosX))\n                            ) {\n                                nextPosY = client.transform.y + (client.size.height - boundaryOffset);\n                                nextSpeedY = blob.speedY * -1;\n                            }\n                        } else {\n                            const firstClient = clients[0];\n                            nextPosX = firstClient.transform.x + (firstClient.size.width / 2);\n                            nextPosY = firstClient.transform.y + (firstClient.size.height / 2);\n                            nextSpeedX = 0;\n                            nextSpeedY = 0;\n                        }\n\n                        blob.x = nextPosX;\n                        blob.y = nextPosY;\n                        blob.speedX = nextSpeedX;\n                        blob.speedY = nextSpeedY;\n\n                        return blob;\n                    });\n\n                    return {\n                        blobs: { $set: updatedBlobs },\n                    };\n                },\n                merge: (cluster1, cluster2, transform) => ({\n                    blobs: { $set: getNewParticleDist(cluster1, cluster2, transform) },\n                    backgroundColor: { $set: cluster1.data.backgroundColor },\n                }),\n            },\n            init: () => ({ blobs: [], backgroundColor: getRandomColor() }),\n        },\n\n        client: {\n            init: () => ({}),\n            events: {\n                addBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $push: blobs } },\n                        },\n                    };\n                },\n                updateBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $set: blobs } },\n                        },\n                    };\n                },\n            },\n        },\n    });\n\n    server.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst socketIO = require('socket.io');\nconst cluster = require('cluster');\nconst os = require('os');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIO(server);\n\napp.use(express.static('public'));\n\nconst particles = [];\n\nfunction createParticle(x, y) {\n  return {\n    x,\n    y,\n    vx: (Math.random() - 0.5) * 2,\n    vy: (Math.random() - 0.5) * 2,\n    radius: Math.random() * 10 + 5\n  };\n}\n\nfunction updateParticles() {\n  const width = 800;\n  const height = 600;\n\n  for (let i = 0; i < particles.length; i++) {\n    const p = particles[i];\n    p.x += p.vx;\n    p.y += p.vy;\n\n    if (p.x < 0 || p.x > width) p.vx *= -1;\n    if (p.y < 0 || p.y > height) p.vy *= -1;\n\n    for (let j = i + 1; j < particles.length; j++) {\n      const q = particles[j];\n      const dx = q.x - p.x;\n      const dy = q.y - p.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      const minDist = p.radius + q.radius;\n\n      if (dist < minDist) {\n        const angle = Math.atan2(dy, dx);\n        const overlap = minDist - dist;\n        p.x += Math.cos(angle) * overlap * 0.5;\n        p.y += Math.sin(angle) * overlap * 0.5;\n        q.x -= Math.cos(angle) * overlap * 0.5;\n        q.y -= Math.sin(angle) * overlap * 0.5;\n      }\n    }\n  }\n}\n\nfunction broadcastParticles() {\n  io.emit('particles', particles);\n}\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n\n  socket.on('createParticle', (data) => {\n    const { x, y } = data;\n    particles.push(createParticle(x, y));\n    broadcastParticles();\n  });\n\n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\nsetInterval(() => {\n  updateParticles();\n  broadcastParticles();\n}, 1000 / 60);\n\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    cluster.fork();\n  });\n} else {\n  server.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': this.isgd,\n      'goo.gl': this.googl,\n      'budurl.com': this.budurl,\n      'snipurl.com': this.snipurl\n    };\n    this.timeout = 5000;\n  }\n\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n\n    if (depth > 10 || seen[url]) {\n      return callback(new Error('Maximum recursion depth exceeded or loop detected'));\n    }\n\n    seen[url] = true;\n\n    const service = Object.keys(this.map).find(domain => url.includes(domain));\n    if (service) {\n      this.map[service](args, callback);\n    } else {\n      this.generic(args, callback);\n    }\n  }\n\n  isgd(args, callback) {\n    const { url, depth, seen } = args;\n    const parsed = new URL(url);\n    const shortCode = parsed.pathname.split('/').pop();\n\n    fetch(`https://is.gd/api.php?shorturl=${encodeURIComponent(url)}`, {\n      method: 'GET',\n      timeout: this.timeout\n    })\n      .then(res => res.text())\n      .then(data => {\n        const expandedUrl = data.trim();\n        if (expandedUrl && !seen[expandedUrl]) {\n          args.url = expandedUrl;\n          args.depth = depth + 1;\n          args.seen = seen;\n          this.expand(args, callback);\n        } else {\n          callback(null, args);\n        }\n      })\n      .catch(err => {\n        callback(err);\n      });\n  }\n\n  googl(args, callback) {\n    const { url, depth, seen } = args;\n    const parsed = new URL(url);\n    const shortCode = parsed.pathname.split('/').pop();\n\n    fetch(`https://www.googleapis.com/urlshortener/v1/expand?key=YOUR_API_KEY&shortUrl=${encodeURIComponent(url)}`, {\n      method: 'GET',\n      timeout: this.timeout\n    })\n      .then(res => res.json())\n      .then(data => {\n        const expandedUrl = data['items'][0]['longUrl'];\n        if (expandedUrl && !seen[expandedUrl]) {\n          args.url = expandedUrl;\n          args.depth = depth + 1;\n          args.seen = seen;\n          this.expand(args, callback);\n        } else {\n          callback(null, args);\n        }\n      })\n      .catch(err => {\n        callback(err);\n      });\n  }\n\n  budurl(args, callback) {\n    const { url, depth, seen } = args;\n    const parsed = new URL(url);\n    const shortCode = parsed.pathname.split('/').pop();\n\n    fetch(`https://budurl.com/api/expand?shorturl=${encodeURIComponent(url)}`, {\n      method: 'GET',\n      timeout: this.timeout\n    })\n      .then(res => res.text())\n      .then(data => {\n        const expandedUrl = data.trim();\n        if (expandedUrl && !seen[expandedUrl]) {\n          args.url = expandedUrl;\n          args.depth = depth + 1;\n          args.seen = seen;\n          this.expand(args, callback);\n        } else {\n          callback(null, args);\n        }\n      })\n      .catch(err => {\n        callback(err);\n      });\n  }\n\n  snipurl(args, callback) {\n    const { url, depth, seen } = args;\n    const parsed = new URL(url);\n    const shortCode = parsed.pathname.split('/').pop();\n\n    fetch(`https://snipurl.com/api/expand?shorturl=${encodeURIComponent(url)}`, {\n      method: 'GET',\n      timeout: this.timeout\n    })\n      .then(res => res.text())\n      .then(data => {\n        const expandedUrl = data.trim();\n        if (expandedUrl && !seen[expandedUrl]) {\n          args.url = expandedUrl;\n          args.depth = depth + 1;\n          args.seen = seen;\n          this.expand(args, callback);\n        } else {\n          callback(null, args);\n        }\n      })\n      .catch(err => {\n        callback(err);\n      });\n  }\n\n  generic(args, callback) {\n    const { url, depth, seen } = args;\n\n    fetch(url, {\n      method: 'HEAD',\n      timeout: this.timeout\n    })\n      .then(res => {\n        if (res.redirected) {\n          const expandedUrl = res.url;\n          if (expandedUrl && !seen[expandedUrl]) {\n            args.url = expandedUrl;\n            args.depth = depth + 1;\n            args.seen = seen;\n            this.expand(args, callback);\n          } else {\n            callback(null, args);\n          }\n        } else {\n          callback(null, args);\n        }\n      })\n      .catch(err => {\n        callback(err);\n      });\n  }\n}"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a function to set up an Express.js server with middleware configuration, route handling, and database synchronization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with CORS support, request body parsing, and database synchronization. It configures middleware, defines basic routes, and starts the server on a specified port. The server integrates authentication and user management routes from external modules.\n\nInput: None (The function takes no parameters as it's self-contained for server setup)\n\nOutput: None (The function doesn't return anything but starts a server process that listens on the specified port)",
    "Canonical_solution": "function setupExpressServer() {\n    const express = require(\"express\");\n    const bodyParser = require(\"body-parser\");\n    const cors = require(\"cors\");\n\n    const app = express();\n\n    var corsOptions = {\n        origin: \"http://localhost:8081\"\n    };\n\n    app.use(cors(corsOptions));\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: true }));\n\n    const db = require(\"./app/models\");\n    const Role = db.role;\n\n    db.sequelize.sync();\n\n    app.get(\"/\", (req, res) => {\n        res.json({ message: \"Welcome to bezkoder application.\" });\n    });\n\n    require('./app/routes/auth.routes')(app);\n    require('./app/routes/user.routes')(app);\n\n    const PORT = process.env.PORT || 8080;\n    app.listen(PORT, () => {\n        console.log(`Server is running on port ${PORT}.`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst cors = require('cors');\nconst bodyParser = require('body-parser');\nconst db = require('./db'); // Assuming a database connection module\nconst authRoutes = require('./routes/auth');\nconst userRoutes = require('./routes/user');\n\nfunction setupExpressServer() {\n  const app = express();\n  const PORT = 3000;\n\n  app.use(cors());\n  app.use(bodyParser.json());\n  app.use(bodyParser.urlencoded({ extended: true }));\n\n  db.sync().then(() => {\n    console.log('Database synchronized');\n  }).catch(err => {\n    console.error('Database synchronization failed:', err);\n  });\n\n  app.use('/api/auth', authRoutes);\n  app.use('/api/users', userRoutes);\n\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}\n\nsetupExpressServer();"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server using the Express framework in JavaScript, with middleware configurations for request processing and static file serving.\n\nFunction Description: The function `createServer` initializes an Express application, configures various middleware for logging, request parsing, and static file serving, and starts an HTTP server listening on a specified port. It also includes environment-specific error handling for development mode.\n\nInput: None (The function does not take any parameters; it uses environment variables like `process.env.PORT` for configuration.)\n\nOutput: None (The function does not return any value; it starts an HTTP server that listens on the specified port and logs a message upon successful startup.)",
    "Canonical_solution": "function createServer() {\n    var express = require('express');\n    var http = require('http');\n    var path = require('path');\n\n    var app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.favicon());\n    app.use(express.logger('dev'));\n    app.use(express.json());\n    app.use(express.urlencoded());\n    app.use(express.methodOverride());\n    app.use(express.static(path.join(__dirname, '/public')));\n    app.use(express.static(path.join(__dirname, '/tests')));\n\n    if ('development' == app.get('env')) {\n        app.use(express.errorHandler());\n    }\n\n    http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express server listening on port ' + app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use((req, res, next) => {\n  console.log(`${req.method} ${req.url}`);\n  next();\n});\n\nif (process.env.NODE_ENV === 'development') {\n  app.use((err, req, res, next) => {\n    console.error(err.stack);\n    res.status(500).send('Something broke!');\n  });\n}\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with essential middleware (CORS, static file serving, JSON body parsing), configures route handlers, and starts listening on a specified port. It handles both API routes and serves static HTML files.\n\nInput: None (The function uses imported modules and configuration from './src/config' and './src/routes')\n\nOutput: None (The function's side effect is starting an HTTP server that listens on the configured port)",
    "Canonical_solution": "function setupExpressServer() {\n    const bodyParser = require('body-parser');\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const config = require('./src/config');\n    const routes = require('./src/routes');\n\n    const app = express();\n\n    app.enable('trust proxy');\n    app.use(cors());\n    app.use(express.static(path.join(__dirname, 'www')));\n    app.use(bodyParser.json());\n\n    app.get('/v2', (req, res) => res.sendFile(path.join(__dirname, 'www/index.html')));\n    app.use(routes);\n\n    app.listen(config.PORT, err => {\n        if (err) console.error(err);\n        console.log('Server started on ' + config.PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst routes = require('./src/routes');\nconst config = require('./src/config');\n\nfunction setupExpressServer() {\n  const app = express();\n  const PORT = config.server.port;\n\n  app.use(cors());\n  app.use(express.static(path.join(__dirname, 'public')));\n  app.use(express.json());\n\n  app.use('/api', routes);\n\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}\n\nsetupExpressServer();"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "function TSClient(query, cb) {\n  this.id = crypto.createHash('md5').update(query).digest('hex');\n  this.search = {\n    q: query,\n    since_id: '',\n    rcount: 100\n  };\n  this.new_since_id = '';\n  this.loadState();\n  cb(this);\n}\n\nTSClient.prototype.syncSearch = function(callback) {\n  this._walker({\n    ts: this,\n    search: this.search,\n    cb: callback,\n    page: 1,\n    results: [],\n    new_since_id: ''\n  });\n};\n\nTSClient.prototype.set = function(search) {\n  this.search = search;\n  this.saveState();\n};\n\nTSClient.prototype._walker = function(s) {\n  const { ts, search, cb, page, results, new_since_id } = s;\n  const params = {\n    q: search.q,\n    count: search.rcount,\n    since_id: search.since_id,\n    max_id: new_since_id || undefined,\n    page: page\n  };\n\n  // Simulated API call to fetch tweets\n  fetchTweets(params, (err, data) => {\n    if (err) {\n      return cb(err);\n    }\n\n    if (!data || data.length === 0) {\n      return cb(results);\n    }\n\n    results.push(...data);\n    s.new_since_id = data[data.length - 1].id_str;\n    s.page += 1;\n    ts._walker(s);\n  });\n};\n\nfunction fetchTweets(params, callback) {\n  // Simulate an API call\n  setTimeout(() => {\n    const mockData = Array.from({ length: params.count }, (_, i) => ({\n      id_str: `123456789${i}`,\n      text: `Tweet ${i} for query \"${params.q}\"`,\n      created_at: new Date().toISOString()\n    }));\n    callback(null, mockData);\n  }, 500);\n};\n\nTSClient.prototype.saveState = function() {\n  fs.writeFileSync(`state_${this.id}.json`, JSON.stringify(this.search));\n};\n\nTSClient.prototype.loadState = function() {\n  try {\n    const state = fs.readFileSync(`state_${this.id}.json`, 'utf-8');\n    this.search = JSON.parse(state);\n  } catch (e) {\n    // No existing state, do nothing\n  }\n};"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\napp.use(express.static(path.join(__dirname, '..')));\n\nrequire('./routes')(app);\n\nconst server = app.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n\nmodule.exports = server;"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function uploads a specified file to a server using Node.js's filesystem and HTTP modules. It streams the file content directly to the HTTP request using pipe(), avoiding loading the entire file into memory. The function sets appropriate headers including content-type (multipart/form-data) and content-length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart form data\n\nOutput: None (The function makes an HTTP request but doesn't return any value. The actual upload result would be handled by the server's response, which isn't captured in this function.)",
    "Canonical_solution": "function uploadFile() {\n  const fs = require('fs');\n  const http = require('http');\n  \n  const stat = fs.statSync(FIXTURE);\n  const request = http.request({\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'content-length': stat.size,\n    },\n  });\n  \n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(fixture, testPort, boundary) {\n  const fileStream = fs.createReadStream(fixture);\n  const serverUrl = `http://localhost:${testPort}`;\n\n  const request = http.request({\n    hostname: 'localhost',\n    port: testPort,\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${boundary}`\n    }\n  });\n\n  const formData = [];\n  formData.push(`--${boundary}`);\n  formData.push(`Content-Disposition: form-data; name=\"file\"; filename=\"${fixture}\"`);\n  formData.push(`Content-Type: application/octet-stream`);\n  formData.push('');\n  formData.push(fileStream);\n  formData.push(`--${boundary}--`);\n\n  request.on('response', (res) => {\n    res.resume();\n  });\n\n  request.on('error', (err) => {\n    console.error(err);\n  });\n\n  request.write(formData.join('\\r\\n'));\n  request.end();\n}"
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle incoming requests, pipe the request data to individual files, and manage client connections. The server should record each connection's data to a separate file and provide a simple HTML upload form for root requests.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens for incoming connections. Each connection's request data is piped to a uniquely named file. For non-root requests, it returns request metadata in JSON format. For root requests (`/`), it serves an HTML upload form. The function tracks connection counts and logs connection/disconnection events.\n\nInput: None (The function takes no parameters but uses `process.env.PORT` environment variable as a fallback port)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that persists until stopped)",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nlet connectionCount = 0;\nconst connections = new Set();\n\nfunction createServer() {\n  const port = process.env.PORT || 3000;\n  const server = http.createServer((req, res) => {\n    const uniqueId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n    const filePath = path.join(__dirname, 'requests', `${uniqueId}.json`);\n\n    if (req.url === '/') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(`\n        <html>\n          <body>\n            <h1>Upload Form</h1>\n            <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n              <input type=\"file\" name=\"file\" required>\n              <button type=\"submit\">Upload</button>\n            </form>\n          </body>\n        </html>\n      `);\n    } else if (req.method === 'POST' && req.url === '/upload') {\n      const chunks = [];\n      req.on('data', chunk => chunks.push(chunk));\n      req.on('end', () => {\n        const data = Buffer.concat(chunks).toString();\n        fs.writeFileSync(filePath, data);\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ status: 'success', filePath }));\n      });\n    } else {\n      const metadata = {\n        method: req.method,\n        url: req.url,\n        headers: req.headers,\n        timestamp: new Date().toISOString()\n      };\n      fs.writeFileSync(filePath, JSON.stringify(metadata, null, 2));\n      res.writeHead(200, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify(metadata));\n    }\n  });\n\n  server.on('connection', socket => {\n    connectionCount++;\n    connections.add(socket);\n    console.log(`Connection established. Total connections: ${connectionCount}`);\n  });\n\n  server.on('close', socket => {\n    connections.delete(socket);\n    connectionCount--;\n    console.log(`Connection closed. Remaining connections: ${connectionCount}`);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "function makeHttpRequest() {\n  request.post({\n    url: 'https://api.example.com/endpoint',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer YOUR_TOKEN'\n    },\n    body: JSON.stringify({\n      key1: 'value1',\n      key2: 'value2'\n    })\n  }, function (error, response, body) {\n    if (error) {\n      console.error('Error:', error);\n    } else {\n      console.log('Response:', body);\n    }\n  });\n}"
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transform the incoming data to uppercase, and send it back as the response.\n\nFunction Description: The function `createPipeServer` creates an HTTP server that listens on a specified port. It handles incoming POST requests by piping the request data through a transformation stream that converts the data to uppercase, and then pipes the transformed data back to the response. Non-POST requests are responded to with a message indicating that a POST request is required.\n\nInput:  \n- `port` (Number): The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up the server but does not return any value).",
    "Canonical_solution": "const http = require('http');\nconst map = require('through2-map');\n\nfunction createPipeServer(port) {\n    const server = http.createServer(function (req, res) {\n        if (req.method !== 'POST') {\n            return res.end('send me a POST\\n');\n        }\n        req.pipe(map(function (chunk) {\n            return chunk.toString().toUpperCase();\n        })).pipe(res);\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const createPipeServer = (port) => {\n  const server = require('http').createServer();\n  server.on('request', (req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify({ error: 'POST request required' }));\n      return;\n    }\n    req.setEncoding('utf8');\n    let data = '';\n    req.on('data', (chunk) => {\n      data += chunk;\n    });\n    req.on('end', () => {\n      const transformedData = data.toUpperCase();\n      res.writeHead(200, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify({ data: transformedData }));\n    });\n  });\n  server.listen(port, () => console.log(`Server running on port ${port}`));\n};"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and requests, piping the request data to individual files for each connection.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. For each connection, it creates a unique file to store the raw HTTP request data. The server handles regular requests by responding with connection information and provides an HTML upload form for the root path. The server tracks active connections and logs connection/disconnection events.\n\nInput: None (The function takes no parameters but uses environment variable `PORT` for configuration)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that writes to files)\n\nNote: The function maintains internal state including:\n- A connection counter\n- An active HTTP server instance\n- File streams for each connection\n- Logging of connection events to console",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const PORT = process.env.PORT || 3000;\nlet connectionCounter = 0;\nlet server;\nlet activeConnections = new Map();\n\nfunction createServer() {\n  const http = require('http');\n  const fs = require('fs');\n  const path = require('path');\n\n  server = http.createServer((req, res) => {\n    if (req.url === '/') {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(`\n        <html>\n          <body>\n            <h1>Upload File</h1>\n            <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n              <input type=\"file\" name=\"file\" />\n              <input type=\"submit\" value=\"Upload\" />\n            </form>\n          </body>\n        </html>\n      `);\n    } else if (req.url.startsWith('/upload')) {\n      const form = require('querystring').parse(req.headers['content-type'] === 'application/x-www-form-urlencoded' ? req.url : '');\n      const file = req.files.file;\n      const filePath = path.join(__dirname, 'uploads', file.name);\n      fs.rename(file.path, filePath, (err) => {\n        if (err) throw err;\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end('File uploaded successfully.');\n      });\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.on('connection', (socket) => {\n    connectionCounter++;\n    const filename = `request_${connectionCounter}.txt`;\n    const filepath = path.join(__dirname, 'requests', filename);\n    const writeStream = fs.createWriteStream(filepath);\n    socket.on('data', (chunk) => writeStream.write(chunk));\n    socket.on('end', () => {\n      writeStream.end();\n      console.log(`Connection ${connectionCounter} ended. Request saved to ${filepath}`);\n    });\n    activeConnections.set(connectionCounter, { socket, writeStream });\n    console.log(`Connection ${connectionCounter} established.`);\n  });\n\n  server.on('close', (socket) => {\n    const connId = Array.from(activeConnections.keys()).find(key => activeConnections.get(key).socket === socket);\n    if (connId) {\n      activeConnections.delete(connId);\n      console.log(`Connection ${connId} closed.`);\n    }\n  });\n\n  server.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`);\n  });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to generate PDFs from HTML templates and serve them as streams.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. It serves PDF files generated from an HTML template, replacing placeholders with actual image paths, and streams the PDF output to the client. The server handles incoming requests, checks for favicon requests, and responds with either a 404 error or the generated PDF.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 8080 and logs the server address to the console.)",
    "Canonical_solution": "function createServer() {\n    const fs = require('fs');\n    const http = require('http');\n    const pdf = require('../../');\n    const tmpl = fs.readFileSync(require.resolve('../businesscard/businesscard.html'), 'utf8');\n\n    const server = http.createServer(function (req, res) {\n        if (req.url === '/favicon.ico') return res.end('404');\n        const html = tmpl.replace('{{image}}', `file://${require.resolve('../businesscard/image.png')}`);\n        pdf.create(html, {width: '50mm', height: '90mm'}).toStream((err, stream) => {\n            if (err) return res.end(err.stack);\n            res.setHeader('Content-type', 'application/pdf');\n            stream.pipe(res);\n        });\n    });\n\n    server.listen(8080, function (err) {\n        if (err) throw err;\n        console.log('Listening on http://localhost:%s', server.address().port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const express = require('express');\nconst pdf = require('html-pdf');\nconst fs = require('fs');\nconst path = require('path');\nconst app = express();\nconst port = 8080;\n\napp.get('/', (req, res) => {\n  const html = fs.readFileSync(path.join(__dirname, 'template.html'), 'utf8');\n  const template = html.replace(/{{image1}}/g, 'https://example.com/image1.jpg')\n                       .replace(/{{image2}}/g, 'https://example.com/image2.jpg');\n  \n  pdf.create(template, { format: 'A4' }).toStream((err, stream) => {\n    if (err) {\n      return res.status(500).send('Error generating PDF');\n    }\n    res.setHeader('Content-Type', 'application/pdf');\n    stream.pipe(res);\n  });\n});\n\napp.get('/favicon.ico', (req, res) => {\n  res.status(404).send('Not Found');\n});\n\napp.use((req, res) => {\n  res.status(404).send('Not Found');\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}`);\n});"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a JavaScript class that implements a server capable of handling HTTP requests and piping data to responses, with support for live reload functionality and error handling.\n\nClass Description: The `Server` class is designed to create an HTTP server that can handle incoming requests, pipe data to responses (particularly for live reload functionality), and manage server lifecycle events. It supports both standalone operation and integration with existing Express-like applications.\n\nAttributes:\n- options: [Object] - Configuration options for the server including livereload file path and port number.\n- clients: [Object] - Storage for connected clients (used for live reload functionality).\n- server: [http.Server] - The underlying HTTP server instance.\n- app: [Object] - Optional Express-like application instance for integration.\n- port: [Number] - The port number the server is listening on.\n\nMethods:\n- constructor(options) -> [Server] - Initializes the server with given options, setting defaults for livereload path and port.\n- configure(app) -> [Server] - Configures the server to work with an existing Express-like application.\n- handler(req, res, next) -> [Server] - Handles incoming HTTP requests, supporting both middleware and direct handling modes.\n- livereload(req, res) -> [void] - Pipes the livereload JavaScript file to the response.\n- listen(port, fn) -> [void] - Starts the server listening on the specified port.\n- close(req, res) -> [void] - Closes the server and optionally ends a response.\n- error(e) -> [void] - Handles and logs server errors.\n\nNote: The class demonstrates inter-process communication through HTTP and file system operations, particularly in the `livereload` method where it pipes file contents directly to HTTP responses.",
    "Canonical_solution": "var fs = require('fs');\nvar http = require('http');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.options.livereload = this.options.livereload || path.join(__dirname, 'public/livereload.js');\n    this.options.port = parseInt(this.options.port || 35729, 10);\n    this.clients = {};\n    this.configure(this.options.app);\n  }\n\n  configure(app) {\n    if(!app) {\n      this.server = http.createServer(this.handler.bind(this));\n      this.server.on('error', this.error.bind(this));\n      return this;\n    }\n\n    var self = this;\n    this.app = app;\n\n    this.app.listen = function(port, done) {\n      done = done || function() {};\n      var srv = self.server = http.createServer(app);\n      srv.on('error', self.error.bind(self));\n      srv.on('close', self.close.bind(self));\n      return srv.listen(port, done);\n    };\n\n    return this;\n  }\n\n  handler(req, res, next) {\n    var middleware = typeof next === 'function';\n    if(middleware) {\n      this.handle(req, res, next);\n      return this;\n    }\n\n    req\n      .on('end', this.handle.bind(this, req, res))\n      .on('data', function(chunk) {\n        req.data = req.data || '';\n        req.data += chunk;\n      });\n\n    return this;\n  }\n\n  livereload(req, res) {\n    fs.createReadStream(this.options.livereload).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port;\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if(res) res.end();\n    if(this.server._handle) this.server.close();\n  }\n\n  error(e) {\n    console.error('Error:', e.message);\n    console.error(e.stack);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 100,
    "wrong_result": "Server.prototype.constructor = function(options) {\n  this.options = options || {};\n  this.clients = {};\n  this.server = null;\n  this.app = null;\n  this.port = this.options.port || 3000;\n  this.options.livereload = this.options.livereload || '/livereload.js';\n};\n\nServer.prototype.configure = function(app) {\n  this.app = app;\n  return this;\n};\n\nServer.prototype.handler = function(req, res, next) {\n  if (req.url === this.options.livereload) {\n    this.livereload(req, res);\n  } else if (this.app) {\n    this.app(req, res, next);\n  } else {\n    res.writeHead(404);\n    res.end('Not Found');\n  }\n};\n\nServer.prototype.livereload = function(req, res) {\n  const filePath = require('path').resolve(__dirname, 'livereload.js');\n  const fs = require('fs');\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('Internal Server Error');\n      return;\n    }\n    res.setHeader('Content-Type', 'application/javascript');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.end(data);\n  });\n};\n\nServer.prototype.listen = function(port, fn) {\n  const http = require('http');\n  this.server = http.createServer(this.handler.bind(this));\n  this.server.listen(port || this.port, () => {\n    if (fn) fn();\n  });\n};\n\nServer.prototype.close = function(req, res) {\n  if (this.server) {\n    this.server.close(() => {\n      res.writeHead(200);\n      res.end('Server closed');\n    });\n  }\n};\n\nServer.prototype.error = function(e) {\n  console.error('Server error:', e.message);\n};"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files, using Node.js's built-in `http` and `fs` modules. The server should handle different MIME types and pipe file contents to the response stream.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens on port 5000. It serves static files from the local file system, automatically determining the appropriate MIME type based on the file extension. If a requested file doesn't exist, it logs a warning. The function uses streaming to efficiently pipe file contents to the HTTP response.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server)",
    "Canonical_solution": "function createServer() {\n  var http = require('http'), fs = require('fs'), mimeTypes = {\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpg'\n  };\n\n  http.createServer(function (req, res) {\n    var file = (req.url === '/') ? 'index.html' : \".\" + req.url;\n    var ext = require('path').extname(file),\n      type = (mimeTypes[ext] ? mimeTypes[ext] : '');\n\n    fs.exists(file, function (exists) {\n      if (exists) {\n        res.writeHead(200, {'Content-Type': type});\n        fs.createReadStream(file).pipe(res);\n      } else {\n        console.warn(file, ' does not exit');\n      }\n    });\n  }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst mimeTypes = {\n  '.html': 'text/html',\n  '.css': 'text/css',\n  '.js': 'application/javascript',\n  '.json': 'application/json',\n  '.txt': 'text/plain',\n  '.png': 'image/png',\n  '.jpg': 'image/jpeg',\n  '.gif': 'image/gif',\n  '.svg': 'image/svg+xml',\n  '.ico': 'image/x-icon',\n  '.pdf': 'application/pdf',\n  '.zip': 'application/zip',\n  '.tar': 'application/x-tar',\n  '.mp4': 'video/mp4',\n  '.ogg': 'audio/ogg',\n  '.wav': 'audio/wav',\n  '.mp3': 'audio/mpeg',\n  '.webm': 'video/webm',\n  '.flv': 'video/x-flv',\n  '.mpeg': 'video/mpeg',\n  '.avi': 'video/x-msvideo',\n  '.mov': 'video/quicktime',\n  '.wmv': 'video/x-ms-wmv'\n};\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, req.url === '/' ? 'index.html' : req.url);\n    \n    fs.exists(filePath, (exists) => {\n      if (!exists) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        console.warn(`File not found: ${filePath}`);\n        return;\n      }\n\n      fs.readFile(filePath, (err, data) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('500 Internal Server Error');\n          console.error(`Error reading file: ${filePath}`, err);\n          return;\n        }\n\n        const ext = path.extname(filePath);\n        const mimeType = mimeTypes[ext] || 'application/octet-stream';\n        res.writeHead(200, { 'Content-Type': mimeType });\n        res.end(data);\n      });\n    });\n  });\n\n  server.listen(5000, () => {\n    console.log('Server running on port 5000');\n  });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve a ReDoc documentation interface, including handling requests for the ReDoc JavaScript file and rendering the documentation page with the provided specification.\n\nFunction Description: The function creates an HTTP server that serves two main routes: (1) '/redoc.standalone.js' which streams the ReDoc JavaScript file to the client, and (2) '/' which renders a complete HTML page with the ReDoc interface hydrated with the provided OpenAPI specification. The server handles other routes with a 404 response.\n\nInput:\n- port: [number] - The port number on which the HTTP server should listen\n- filePath: [string] - The file path to the 'redoc.standalone.js' file to be served\n- specPath: [string] - The file path to the OpenAPI specification file (YAML format)\n\nOutput: None (The function starts an HTTP server that continues running until manually stopped)\n\nNote: The function assumes the availability of certain external dependencies (yaml, fs, http, React, ServerStyleSheet, Redoc) which should be imported/required in the actual implementation. The function also uses async/await for handling asynchronous operations related to the Redoc store creation.",
    "Canonical_solution": "const http = require('http');\nconst fs = require('fs');\n\nfunction createServer(port, filePath, specPath) {\n    const server = http.createServer(async (request, response) => {\n        if (request.url === '/redoc.standalone.js') {\n            fs.createReadStream(filePath, 'utf8').pipe(response);\n        } else if (request.url === '/') {\n            const spec = yaml.load(readFileSync(resolve(__dirname, specPath), 'utf-8'));\n            const store = await createStore(spec, 'path/to/spec.yaml');\n\n            const sheet = new ServerStyleSheet();\n            const html = renderToString(sheet.collectStyles(React.createElement(Redoc, { store })));\n            const css = sheet.getStyleTags();\n\n            const res = `<html>\n            <head>\n                <meta charset=\"utf8\" />\n                <title>ReDoc</title>\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                <style>\n                    body {\n                        padding: 0;\n                        margin: 0;\n                    }\n                </style>\n                <script src=\"redoc.standalone.js\"></script>\n                <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n                ${css}\n            </head>\n            <body>\n            <script>\n                document.addEventListener('DOMContentLoaded', function() {\n                    const state = ${JSON.stringify(await store.toJS())};\n                    Redoc.hydrate(state, document.getElementById('redoc'));\n                });\n                </script>\n                <div id=\"redoc\">${html}</div>\n            </body>\n            </html>`;\n            response.writeHead(200, { 'Content-Length': res.length });\n            response.write(res);\n            response.end();\n        } else {\n            response.writeHead(404);\n            response.write('Not found');\n            response.end();\n        }\n    });\n\n    server.listen(port, () => console.log(`Server started: http://127.0.0.1:${port}`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs').promises;\nconst yaml = require('yaml');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst { ServerStyleSheet } = require('styled-components');\nconst Redoc = require('redoc');\n\nasync function setupRedocServer(port, filePath, specPath) {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      try {\n        const data = await fs.readFile(filePath, 'utf-8');\n        res.writeHead(200, { 'Content-Type': 'application/javascript' });\n        res.end(data);\n      } catch (err) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error loading ReDoc standalone JS file');\n      }\n    } else if (req.url === '/') {\n      try {\n        const spec = await fs.readFile(specPath, 'utf-8');\n        const parsedSpec = yaml.parse(spec);\n        \n        const sheet = new ServerStyleSheet();\n        const Component = Redoc({\n          spec: parsedSpec,\n          scrollYOffset: 0\n        });\n        const html = ReactDOMServer.renderToString(\n          React.createElement(React.Fragment, null, \n            sheet.getStyleTags(),\n            React.createElement(Component)\n          )\n        );\n        sheet.flush();\n        \n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(html);\n      } catch (err) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Error loading OpenAPI specification');\n      }\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n    }\n  });\n\n  server.listen(port, () => {\n    console.log(`Redoc server running at http://localhost:${port}`);\n  });\n}"
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to handle POST requests, transforming the incoming data to uppercase and sending it back as the response.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for POST requests on a specified port. When a POST request is received, it pipes the request data through a transformation stream that converts the data to uppercase, then pipes the result back to the response. For non-POST requests, it responds with a message prompting a POST request.\n\nInput:  \n- `port` [Number] - The port number on which the HTTP server should listen.\n\nOutput:  \n- None (The function sets up a server that runs indefinitely, handling incoming requests.)",
    "Canonical_solution": "const http = require('http');\nconst through = require('through2');\n\nfunction createServer(port) {\n  const server = http.createServer(function (req, res) {\n    if (req.method === 'POST') {\n      req.pipe(through(function (buf, _, next) {\n        this.push(buf.toString().toUpperCase());\n        next();\n      })).pipe(res);\n    } else {\n      res.end('send me a POST\\n');\n    }\n  });\n  server.listen(parseInt(port));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\n\nfunction createServer(port) {\n  http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Please use a POST request.\\n');\n      return;\n    }\n\n    let data = '';\n\n    req.on('data', chunk => {\n      data += chunk;\n    });\n\n    req.on('end', () => {\n      const transformedData = data.toUpperCase();\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(transformedData);\n    });\n  }).listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a function that sets up a simple HTTP server to handle POST requests, piping the incoming request data to a response after converting it to a string.\n\nFunction Description: The function `createPipeServer` initializes an HTTP server that listens for POST requests. When a POST request is received, it pipes the request data through a transformation stream (converting chunks to strings) and then pipes the result back to the response. Non-POST requests are rejected with a message.\n\nInput:  \n- `port` (Number, optional): The port number on which the server will listen. If not provided or 0, the OS will assign an available port.\n\nOutput:  \n- None (The function starts an HTTP server that runs indefinitely, handling incoming requests.)",
    "Canonical_solution": "function createPipeServer(port) {\n  require('http').createServer(function (req, res) {\n    if (req.method !== 'POST') {\n      return res.end('POST only!\\n')\n    }\n    req.pipe(require('through2-map')(function (chunk) {\n      return chunk.toString()\n    })).pipe(res)\n  }).listen(port | 0)\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "function createPipeServer(port) {\n  const http = require('http');\n  const { Transform } = require('stream');\n\n  const server = http.createServer((req, res) => {\n    if (req.method !== 'POST') {\n      res.writeHead(405, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify({ error: 'Method Not Allowed' }));\n      return;\n    }\n\n    const chunks = [];\n    req.on('data', chunk => chunks.push(chunk));\n    req.on('end', () => {\n      const data = Buffer.concat(chunks).toString();\n      res.writeHead(200, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify({ received: data }));\n    });\n  });\n\n  server.listen(port || 0, () => {\n    console.log(`Server running at http://localhost:${server.address().port}`);\n  });\n}"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files and handle dynamic JavaScript file concatenation, with support for piping binary files.\n\nFunction Description: The `createServer` function initializes an HTTP server that serves static files from specified directories, handles dynamic concatenation of JavaScript files, and pipes binary files directly to the response. It supports virtual paths, content type detection, and redirection.\n\nInput: \n- Optional command line argument [string] - The port number to listen on (defaults to 90 if not provided)\n\nOutput: \n- None (directly creates and starts an HTTP server)\n- Console output indicating server startup and loaded files\n\nAttributes: (N/A - This is a function, not a class)\n\nMethods: (N/A - This is a function, not a class)\n\nAdditional Implementation Details:\n1. Reads and caches static files from '../src' and '../dist' directories at startup\n2. Handles binary files separately from text files\n3. Supports special handling for core JavaScript files and plugins\n4. Implements virtual path redirection\n5. Uses file extension to determine content type\n6. Provides fallback behavior for undefined routes\n7. Listens on localhost (127.0.0.1) only\n8. Outputs loaded file list to console at startup",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require(\"fs\");\n    var url = require(\"url\");\n\n    var BASE_URL=\"http://www.servicestack.net\", \n        VIRTUAL_PATH=\"/jqbuilder\"; \n\n    var getExt = function(path) {\n        return path.substring(path.lastIndexOf('.')+1);\n    };\n    String.prototype.startsWith = function (str){\n        return this.indexOf(str) === 0;\n    };\n\n    var contentTypes = { \"htm\": \"text/html\", \"js\": \"text/javascript\", \"gif\": \"image/gif\" };\n\n    var srcDir = '../src', targetDir = '../dist';\n    var webFiles = fs.readdirSync(targetDir);\n    var staticFiles = {}, binaryFiles = {};\n    fs.readdirSync(srcDir).forEach(function(file) { \n        var filePath = srcDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(targetDir).forEach(function(file) { \n        var filePath = targetDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(\"./\").forEach(function(file) {\n        var isText = (contentTypes[getExt(file)]||\"\").startsWith(\"text\");\n        if (isText)\n            staticFiles[\"/\" + file] = fs.readFileSync(file).toString('utf-8');\n        else \n            binaryFiles[\"/\" + file] = file;\n    });\n\n    staticFiles[\"/\"] = staticFiles[\"/default.htm\"];\n\n    console.log(\"loaded: \", Object.keys(staticFiles));\n\n    var isCore = { \"/jquip.js\": true, \"/jquip.min.js\": true };\n\n    var port = process.argv[2] || 90;\n\n    http.createServer(function (req, res) {\n        var reqUrl = url.parse(req.url), path = reqUrl.pathname.replace(VIRTUAL_PATH,'');\n        if (reqUrl.pathname == VIRTUAL_PATH){\n            res.writeHead(302,BASE_URL+VIRTUAL_PATH+\"/\");\n            res.end();\n            return;\n        }\n\n        var fileContents = staticFiles[path];\n\n        if (fileContents) {\n            var ext = path == \"/\" ? \"htm\" : getExt(path);\n            var contentType = contentTypes[ext];\n            res.writeHead(200, {'Content-Type': contentType });\n            var isPlugin = ext == \"js\" && path.startsWith(\"/jquip.\") && !isCore[path];\n            if (isPlugin) {\n                var coreJs = path.indexOf(\"min\") != -1 \n                    ? staticFiles[\"/jquip.min.js\"]\n                    : staticFiles[\"/jquip.js\"];\n                fileContents = coreJs + \";\" + fileContents;\n            }\n\n            res.end(fileContents);\n        }\n        else if (binaryFiles[path]) { \n            var filePath = binaryFiles[path]; \n            fs.createReadStream(filePath, {\n              'bufferSize': 4 * 1024\n            }).pipe(res);\n        }\n        else\n        {\n            var isDynamic = path.startsWith(\"/jquip.\");\n            if (isDynamic) {\n                var parts = path.substring(1).split('.');\n                var isMin = parts.indexOf(\"min\") >= 0;\n                var js = isMin ? staticFiles[\"/jquip.min.js\"] : staticFiles[\"/jquip.js\"];\t\t\t\n                parts.forEach(function(part){\n                    if (part == \"jquip\" || part == \"min\" || part == \"js\") return;\n                    var path = \"/jquip.\" + part + (isMin ? \".min.js\" : \".js\");\n                    var jsFile = staticFiles[path];\n                    if (jsFile)\n                        js += \";\" + jsFile;\n                });\n                res.writeHead(200, {'Content-Type': 'text/javascript' });\n                res.end(js);\t\t\n                return;\n            }\n\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            var sb = \"\";\n            for (var i in reqUrl) {\n                if (sb) sb += \"\\n\";\n                sb += i + \": \" + reqUrl[i];\n            }\n            res.end(\"Path not found:\\n\" + sb);\n        }\n    })\n    .listen(port, \"127.0.0.1\");\n    console.log('Server running at http://127.0.0.1:'+port+'/');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst url = require('url');\n\nconst PORT = process.argv[2] || 90;\n\nconst staticDirs = ['../src', '../dist'];\nconst coreJsFiles = ['core.js', 'utils.js'];\nconst pluginJsFiles = ['plugin1.js', 'plugin2.js'];\n\nconst fileCache = {};\nconst binaryFiles = new Set();\n\nstaticDirs.forEach(dir => {\n  fs.readdirSync(dir).forEach(file => {\n    const filePath = path.join(dir, file);\n    const ext = path.extname(file).toLowerCase();\n    if (ext === '.js') {\n      fileCache[file] = fs.readFileSync(filePath, 'utf-8');\n    } else if (ext === '.bin' || ext === '.dat') {\n      binaryFiles.add(file);\n    }\n  });\n});\n\nconst server = http.createServer((req, res) => {\n  const parsedUrl = url.parse(req.url, true);\n  const pathName = parsedUrl.pathname || '/';\n  const query = parsedUrl.query;\n\n  if (pathName.startsWith('/concat/')) {\n    const files = pathName.split('/').slice(2).join('/');\n    let content = '';\n    coreJsFiles.forEach(file => {\n      if (fileCache[file]) content += fileCache[file];\n    });\n    pluginJsFiles.forEach(file => {\n      if (fileCache[file]) content += fileCache[file];\n    });\n    res.writeHead(200, { 'Content-Type': 'application/javascript' });\n    res.end(content);\n    return;\n  }\n\n  if (binaryFiles.has(pathName)) {\n    const filePath = path.join(staticDirs[0], pathName);\n    fs.readFile(filePath, (err, data) => {\n      if (err) {\n        res.writeHead(404);\n        res.end('File not found');\n        return;\n      }\n      res.writeHead(200, { 'Content-Type': 'application/octet-stream' });\n      res.end(data);\n    });\n    return;\n  }\n\n  if (pathName === '/redirect') {\n    res.writeHead(301, { Location: '/' });\n    res.end();\n    return;\n  }\n\n  const ext = path.extname(pathName).toLowerCase();\n  let contentType = 'text/plain';\n  if (ext === '.html') contentType = 'text/html';\n  else if (ext === '.css') contentType = 'text/css';\n  else if (ext === '.js') contentType = 'application/javascript';\n  else if (ext === '.json') contentType = 'application/json';\n  else if (ext === '.png') contentType = 'image/png';\n  else if (ext === '.jpg' || ext === '.jpeg') contentType = 'image/jpeg';\n\n  const filePath = path.join(staticDirs[0], pathName);\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404);\n      res.end('File not found');\n      return;\n    }\n    res.writeHead(200, { 'Content-Type': contentType });\n    res.end(data);\n  });\n});\n\nserver.listen(PORT, '127.0.0.1', () => {\n  console.log(`Server running at http://127.0.0.1:${PORT}/`);\n  console.log('Loaded files:', Object.keys(fileCache));\n  console.log('Binary files:', [...binaryFiles]);\n});"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement an OAuth server class that handles GitHub OAuth authentication flow, including starting a server to receive the authorization code and exchanging it for an access token.\n\nClass Description: The OAuthServer class represents a server that facilitates GitHub OAuth authentication. It creates an Express server to handle the OAuth callback, exchanges the authorization code for an access token using GitHub's API, and provides methods to start and stop the server.\n\nAttributes:\n- options: [Object] - Configuration object containing client credentials and server settings\n- prompt: [Object] - Reference to an external prompt object used to signal completion of authentication\n- app: [Object] - Express application instance for handling HTTP requests\n- server: [Object] - HTTP server instance created by Express\n- token: [String|null] - Stores the obtained OAuth access token\n\nMethods:\n- constructor(options) -> [OAuthServer] - Initializes the OAuth server with configuration options and sets up the Express route for handling OAuth callbacks\n- start() -> [Promise] - Starts the HTTP server on the configured port and returns a promise that resolves when the server is ready or rejects on error\n- stop() -> [void] - Stops the HTTP server and cleans up resources",
    "Canonical_solution": "const express = require('express');\nconst axios = require('axios');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = this.options.prompt;\n    this.app = express();\n    this.app.get('/', (req, res) => {\n      const code = req.query.code;\n      axios\n        .post(\n          `https://github.com/login/oauth/access_token?client_secret=${\n            this.options.client_secret\n          }&client_id=${this.options.client_id}&code=${code}`,\n          {},\n          {\n            headers: {\n              Accept: 'application/json'\n            }\n          }\n        )\n        .then(response => {\n          const accessToken = response.data.access_token;\n          this.token = accessToken;\n          res.send('Enquirer: Github OAuth Server is up');\n          this.prompt.submit();\n        })\n        .catch(e => console.log('axios error', e));\n    });\n    this.token = null;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, err => {\n        if (err) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  stop() {\n    this.server.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst qs = require('querystring');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = options.prompt;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n\n    this.app.get('/callback', async (req, res) => {\n      const code = req.query.code;\n      if (!code) {\n        return res.status(400).send('Missing authorization code');\n      }\n\n      try {\n        const tokenResponse = await this.exchangeToken(code);\n        this.token = tokenResponse.access_token;\n        this.prompt.resolve(this.token);\n        res.redirect('/');\n      } catch (error) {\n        console.error('Error exchanging token:', error);\n        res.status(500).send('Error exchanging token');\n      }\n    });\n  }\n\n  async exchangeToken(code) {\n    const { client_id, client_secret, redirect_uri } = this.options;\n    const form = qs.stringify({\n      client_id,\n      client_secret,\n      code,\n      redirect_uri,\n      grant_type: 'authorization_code'\n    });\n\n    const response = await fetch('https://github.com/login/oauth/access_token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body: form\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to exchange token: ${await response.text()}`);\n    }\n\n    const data = await response.json();\n    return data;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = http.createServer(this.app);\n      this.server.listen(this.options.port, () => {\n        resolve();\n      }).on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n    }\n  }\n}"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst mimeTypes = {\n  '.html': 'text/html',\n  '.css': 'text/css',\n  '.js': 'application/javascript',\n  '.json': 'application/json',\n  '.txt': 'text/plain',\n  '.jpg': 'image/jpeg',\n  '.jpeg': 'image/jpeg',\n  '.png': 'image/png',\n  '.gif': 'image/gif',\n  '.svg': 'image/svg+xml',\n  '.ico': 'image/x-icon'\n};\n\nfunction createFileServer() {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, 'static', req.url === '/' ? 'index.html' : req.url);\n    \n    fs.readFile(filePath, (err, data) => {\n      if (err) {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('404 Not Found');\n        return;\n      }\n\n      const ext = path.extname(filePath);\n      const mimeType = mimeTypes[ext] || 'application/octet-stream';\n      res.writeHead(200, { 'Content-Type': mimeType });\n      res.end(data);\n    });\n  });\n\n  server.listen(1338, () => {\n    console.log('File server running on port 1338');\n  });\n}\n\ncreateFileServer();"
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a TCP server that handles client connections with authentication and provides a random quote service upon successful authentication.\n\nFunction Description: The function `createServer` establishes a TCP server that listens on a specified port. It uses the `dnode` library for remote procedure calls (RPC) and implements an authentication mechanism. Upon successful authentication, clients gain access to a `randomQuote` service. The server logs connection and disconnection events.\n\nInput:  \n- `port` (Number): The port number on which the TCP server should listen for incoming connections.\n\nOutput:  \n- None (The function creates and starts a server instance but doesn't return anything. Side effects include logging connection events to the console.)  \n\nNote: The function relies on an undefined `randomQuote` function which should be implemented elsewhere to provide quote generation functionality. The authentication hardcodes credentials (user: 'moo', pass: 'hax') for demonstration purposes.",
    "Canonical_solution": "var dnode = require('dnode');\nvar fs = require('fs');\nvar net = require('net');\n\nfunction createServer(port) {\n    var server = net.createServer(function (stream) {\n        var d = dnode({ auth : auth });\n        d.pipe(stream).pipe(d);\n        \n        function auth (user, pass, cb) {\n            if (typeof cb !== 'function') return;\n            \n            if (user === 'moo' && pass === 'hax') {\n                console.log('signed in: ' + user);\n                d.on('end', function () {\n                    console.log('disconnected: ' + user);\n                });\n                \n                cb(null, { quote : randomQuote });\n            }\n            else cb('ACCESS DENIED')\n        }\n    });\n    server.listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "const dnode = require('dnode');\n\nfunction createServer(port) {\n  const server = dnode(function (connection) {\n    connection.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n\n    connection.on('close', () => {\n      console.log('Client disconnected');\n    });\n\n    connection.authenticate = function (user, pass, callback) {\n      if (user === 'moo' && pass === 'hax') {\n        callback(null, true);\n      } else {\n        callback(new Error('Authentication failed'), false);\n      }\n    };\n\n    connection.randomQuote = function (callback) {\n      if (typeof randomQuote === 'function') {\n        randomQuote(callback);\n      } else {\n        callback(new Error('randomQuote function is not defined'));\n      }\n    };\n  });\n\n  server.listen(port, () => {\n    console.log(`Server listening on port ${port}`);\n  });\n\n  server.on('connection', (conn) => {\n    console.log('Client connected');\n  });\n\n  server.on('error', (err) => {\n    console.error('Server error:', err);\n  });\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  taskRequest(method, url, body = '') {\n    return new Promise((resolve, reject) => {\n      const headers = {\n        'Content-Type': method === 'post' ? 'application/json' : '',\n        'Device-ID': this.did,\n        'Fingerprint': this.finger,\n        'Authorization': this.token,\n        'OAID': this.oaid\n      };\n\n      if (method === 'post') {\n        headers['Content-Length'] = body.length;\n      }\n\n      const requestOptions = {\n        method: method.toUpperCase(),\n        headers: headers,\n        body: method === 'post' ? body : undefined\n      };\n\n      fetch(url, requestOptions)\n        .then(response => {\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          return response.json();\n        })\n        .then(data => resolve(data))\n        .catch(error => reject(error));\n    });\n  }\n}"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a TCP server in Node.js that handles client connections, processes incoming data in batches, and forwards each batch to an external service for processing.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that listens on port 5000. When a client connects, it sets up a bidirectional communication channel where incoming data from the client is collected in batches (separated by '.'). Each complete batch is then sent to an external 'uppercase' service via a REQ socket. The server handles data streaming and batch processing efficiently.\n\nInput: None (The function takes no parameters; configuration is hardcoded)\n\nOutput: None (The function creates a server instance that runs indefinitely, listening for connections)\n\n---\n\nIf you'd prefer the class format (though the reference code is function-based):\n\nTask Description: Implement a TCP server class in Node.js that manages client connections and batch processing of incoming data.\n\nClass Description: The `TCPServer` class encapsulates a TCP server that listens for client connections, collects incoming data in batches, and forwards complete batches to an external service.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- port: [number] - The port number the server listens on (default: 5000)\n\nMethods:\n- constructor([port: number]) -> void - Initializes the server with optional port configuration\n- start() -> void - Starts the server and begins listening for connections\n- handleConnection(conn: net.Socket) -> void - Internal method to manage client connections and data processing\n- processBatch(batch: string[]) -> void - Sends a complete batch to the external service",
    "Canonical_solution": "function createTCPServer() {\n    var server = require('net').createServer();\n    server.on('connection', function(conn) {\n        conn.setEncoding('utf8');\n        \n        var req = context.socket('REQ');\n        req.setEncoding('utf8');\n        req.pipe(conn);\n        req.connect('uppercase');\n        \n        var batch = [];\n        var ask = function (q) {\n            req.write(q, 'utf8');\n        }\n        function readBatch() {\n            var msg; while (msg = conn.read()) {\n                msg.split('\\n').forEach(function(item) {\n                    if (item == '.') {\n                        console.log('Sending batch %s', batch);\n                        batch.forEach(ask);\n                        batch = [];\n                    }\n                    else if (item != '') {\n                        batch.push(item);\n                    }\n                });\n            }\n        }\n        conn.on('readable', readBatch);\n        readBatch();\n    });\n    server.listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "function createTCPServer() {\n  const net = require('net');\n  const zmq = require('zeromq');\n\n  const server = net.createServer();\n  server.listen(5000, () => {\n    console.log('TCP server listening on port 5000');\n  });\n\n  const socket = zmq.socket('req');\n  socket.connect('tcp://localhost:5555');\n\n  server.on('connection', (conn) => {\n    let buffer = [];\n    let batch = [];\n\n    conn.on('data', (chunk) => {\n      buffer.push(chunk);\n    });\n\n    conn.on('end', () => {\n      const data = Buffer.concat(buffer).toString();\n      const batches = data.split('.');\n      batches.forEach(batchStr => {\n        if (batchStr.trim() !== '') {\n          processBatch([batchStr]);\n        }\n      });\n    });\n\n    conn.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n  });\n\n  function processBatch(batch) {\n    socket.send(JSON.stringify(batch), (err) => {\n      if (err) {\n        console.error('Error sending to service:', err);\n      }\n    });\n  }\n}"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a POP3 server class in Node.js that handles secure and non-secure connections, manages client connections, and provides event-driven communication.\n\nClass Description: The POP3Server class extends EventEmitter to create a TCP server that can handle both regular and TLS-secured POP3 connections. It manages client connections and emits events for server lifecycle and errors.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- connections: [Set] - Tracks active client connections\n- server: [net.Server|tls.Server] - The underlying TCP/TLS server instance\n\nMethods:\n- constructor(options) -> [void] - Initializes the server with optional configuration\n- _setListeners() -> [void] - Sets up event listeners for the server\n- _onListening() -> [void] - Handles the 'listening' event\n- _onClose() -> [void] - Handles the 'close' event\n- _onError(err) -> [void] - Handles the 'error' event\n- connect(socket, socketOptions) -> [void] - Creates and manages a new client connection\n- listen(...args) -> [void] - Starts the server listening on specified port\n- close(callback) -> [void] - Stops the server and invokes callback when closed",
    "Canonical_solution": "const EventEmitter = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass POP3Server extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.options = options || {};\n        this.connections = new Set();\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    this.connect(socket, socketOptions);\n                });\n            });\n        }\n\n        this._setListeners();\n    }\n\n    _setListeners() {\n        this.server.on('listening', () => this._onListening());\n        this.server.on('close', () => this._onClose());\n        this.server.on('error', err => this._onError(err));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new POP3Connection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.once('error', err => {\n            this.connections.delete(connection);\n            this._onError(err);\n        });\n        connection.once('close', () => {\n            this.connections.delete(connection);\n        });\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            if (typeof callback === 'function') {\n                return callback();\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "const { EventEmitter } = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass POP3Server extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    this.connections = new Set();\n    this.server = null;\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n    this.server.on('connection', this.connect.bind(this));\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    const connection = {\n      socket,\n      data: '',\n      state: 'AUTHORIZATION',\n      commands: {}\n    };\n    this.connections.add(connection);\n    socket.on('data', (chunk) => {\n      connection.data += chunk.toString();\n      this.processCommand(connection);\n    });\n    socket.on('end', () => {\n      this.connections.delete(connection);\n    });\n    socket.on('error', (err) => {\n      this.connections.delete(connection);\n      this.emit('error', err);\n    });\n  }\n\n  listen(...args) {\n    if (this.options.secure) {\n      this.server = tls.createServer(this.options, (socket) => {\n        this.connect(socket, { secure: true });\n      });\n    } else {\n      this.server = net.createServer((socket) => {\n        this.connect(socket, { secure: false });\n      });\n    }\n    this._setListeners();\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    this.server.close(() => {\n      this.connections.forEach(conn => {\n        conn.socket.destroy();\n      });\n      this.connections.clear();\n      if (callback) callback();\n    });\n  }\n\n  processCommand(connection) {\n    let data = connection.data;\n    let lines = data.split('\\r\\n');\n    let line = lines[0];\n    connection.data = lines.slice(1).join('\\r\\n');\n    let cmd = line.split(' ')[0];\n    let args = line.split(' ').slice(1).join(' ');\n\n    switch (cmd) {\n      case 'USER':\n        connection.commands.USER = args;\n        connection.state = 'PASS';\n        connection.socket.write('334 Authenticate with password\\r\\n');\n        break;\n      case 'PASS':\n        connection.commands.PASS = args;\n        connection.state = 'AUTHORIZATION';\n        connection.socket.write('235 Authentication successful\\r\\n');\n        break;\n      case 'STAT':\n        connection.socket.write(`+OK ${connection.commands.USER} ${connection.commands.PASS} 0 0\\r\\n`);\n        break;\n      case 'QUIT':\n        connection.socket.end();\n        break;\n      default:\n        connection.socket.write('-ERR Unknown command\\r\\n');\n    }\n  }\n}"
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module that can handle both secure (TLS) and non-secure connections, manage client connections, and emit relevant events.\n\nClass Description: The Server class extends Node.js's EventEmitter to create a TCP server that can handle multiple client connections. It supports both secure (TLS) and non-secure (plain TCP) modes, manages connection lifecycle events, and maintains a list of active connections.\n\nAttributes:\n- socket: [Object] - The underlying TCP/TLS server instance\n- connections: [Array] - Array of active Connection objects\n\nMethods:\n- constructor(secure, options, callback) -> [Server Instance] - Initializes the server. 'secure' is a boolean indicating TLS usage, 'options' is an optional configuration object, and 'callback' is an optional function for 'connection' events\n- listen(port, host, callback) -> [Server Instance] - Starts the server listening on specified port and host. 'host' is optional, and 'callback' is an optional function for 'listening' events\n\nEvents:\n- connection: Emitted when a new client connects (passes Connection object)\n- close: Emitted when the server closes\n- error: Emitted when an error occurs (passes error object)\n- listening: Emitted when the server starts listening",
    "Canonical_solution": "var util = require('util'),\n    net = require('net'),\n    tls = require('tls'),\n    events = require('events'),\n    Connection = require('./Connection');\n\nfunction nop() {}\n\nclass Server extends events.EventEmitter {\n    constructor(secure, options, callback) {\n        super();\n        var that = this;\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        var onConnection = function (socket) {\n            var conn = new Connection(socket, that, function () {\n                that.connections.push(conn);\n                conn.removeListener('error', nop);\n                that.emit('connection', conn);\n            });\n            conn.on('close', function () {\n                var pos = that.connections.indexOf(conn);\n                if (pos !== -1) {\n                    that.connections.splice(pos, 1);\n                }\n            });\n\n            // Ignore errors before the connection is established\n            conn.on('error', nop);\n        };\n\n        if (secure) {\n            this.socket = tls.createServer(options, onConnection);\n        } else {\n            this.socket = net.createServer(options, onConnection);\n        }\n\n        this.socket.on('close', function () {\n            that.emit('close');\n        });\n        this.socket.on('error', function (err) {\n            that.emit('error', err);\n        });\n        this.connections = [];\n\n        if (callback) {\n            this.on('connection', callback);\n        }\n    }\n\n    listen(port, host, callback) {\n        var that = this;\n\n        if (typeof host === 'function') {\n            callback = host;\n            host = undefined;\n        }\n\n        if (callback) {\n            this.on('listening', callback);\n        }\n\n        this.socket.listen(port, host, function () {\n            that.emit('listening');\n        });\n\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "const { EventEmitter } = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass Connection {\n  constructor(socket) {\n    this.socket = socket;\n    this.id = Date.now();\n  }\n}\n\nclass Server extends EventEmitter {\n  constructor(secure, options, callback) {\n    super();\n    this.secure = secure;\n    this.options = options || {};\n    this.connections = [];\n    this.socket = secure \n      ? tls.createServer(this.options, (socket) => {\n          const conn = new Connection(socket);\n          this.connections.push(conn);\n          this.emit('connection', conn);\n          socket.on('close', () => {\n            this.connections = this.connections.filter(c => c.id !== conn.id);\n            this.emit('close', conn);\n          });\n        }) \n      : net.createServer((socket) => {\n          const conn = new Connection(socket);\n          this.connections.push(conn);\n          this.emit('connection', conn);\n          socket.on('close', () => {\n            this.connections = this.connections.filter(c => c.id !== conn.id);\n            this.emit('close', conn);\n          });\n        });\n    if (callback) {\n      this.socket.on('connection', (socket) => {\n        const conn = new Connection(socket);\n        this.connections.push(conn);\n        this.emit('connection', conn);\n        socket.on('close', () => {\n          this.connections = this.connections.filter(c => c.id !== conn.id);\n          this.emit('close', conn);\n        });\n      });\n    }\n  }\n\n  listen(port, host, callback) {\n    this.socket.listen(port, host, () => {\n      this.emit('listening');\n      if (callback) callback();\n    });\n    this.socket.on('error', (err) => {\n      this.emit('error', err);\n    });\n    this.socket.on('close', () => {\n      this.emit('close');\n    });\n    return this;\n  }\n}"
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a TCP server using Node.js's `net` module to handle client connections and manage sessions with unique identifiers, while optionally supporting weak references for garbage collection.\n\nClass Description: The `DNodeServer` class is a TCP server implementation that manages client connections, assigns unique session IDs, and provides event-based interaction with connected clients. It supports optional weak reference handling for callbacks to prevent memory leaks.\n\nAttributes:\n- cons: [Function] - The constructor or function to be called for each new connection.\n- opts: [Object] - Configuration options for the server, including weak reference settings.\n- server: [net.Server] - The underlying TCP server instance.\n- server.sessions: [Object] - Dictionary of active sessions indexed by session IDs.\n\nMethods:\n- constructor(cons, opts) -> [DNodeServer] - Initializes the server with a connection handler and options. Sets up weak reference handling if enabled.\n- _handleConnection(stream) -> [void] - Handles new client connections, creates session with unique ID, and sets up data piping and event forwarding.\n- listen(port, host, callback) -> [net.Server] - Starts the server listening on specified port/host or UNIX socket path. Accepts optional callback for 'listening' event.\n- _randomId() -> [string] - Generates a random 16-character hexadecimal string for session identification.\n\nInput:\n- cons: [Function] - Required connection handler function\n- opts: [Object] - Optional configuration object (may contain 'weak' and 'proto' properties)\n- port: [number|string] - Port number or UNIX socket path to listen on\n- host: [string] - Optional hostname to bind to\n- callback: [Function] - Optional callback for listening event\n\nOutput:\n- Instance of DNodeServer when constructed\n- Instance of net.Server when calling listen()",
    "Canonical_solution": "var dnode = require('./lib/dnode');\nvar net = require('net');\nvar weak;\n\nclass DNodeServer {\n    constructor(cons, opts) {\n        if (!opts) opts = {};\n        \n        if (opts.weak !== false && !opts.proto) {\n            if (!weak) {\n                weak = require(\"weak\");\n            }\n            \n            opts.proto = {};\n            opts.proto.wrap = function (cb, id) {\n                var proto = this;\n                return weak(cb, function () {\n                    proto.cull(id);\n                });\n            };\n            opts.proto.unwrap = function (ref, id) {\n                var cb = weak.get(ref);\n                return cb || function () {};\n            };\n        }\n        \n        this.cons = cons;\n        this.opts = opts;\n        this.server = net.createServer(this._handleConnection.bind(this));\n        this.server.sessions = {};\n    }\n\n    _handleConnection(stream) {\n        var d = new dnode(this.cons, this.opts);\n        do { d.id = this._randomId(); }\n        while (this.server.sessions[d.id]);\n        \n        this.server.sessions[d.id] = d;\n        d.on('end', () => {\n            delete this.server.sessions[d.id];\n        });\n        \n        d.on('local', (ref) => {\n            this.server.emit('local', ref, d);\n        });\n        \n        d.on('remote', (remote) => {\n            this.server.emit('remote', remote, d);\n        });\n        \n        stream.on('error', (err) => {\n            if (err && err.code === 'EPIPE') return;\n            d.emit('error', err);\n        });\n        \n        d.stream = stream;\n        stream.pipe(d);\n        d.pipe(stream);\n    }\n\n    listen(port, host, callback) {\n        if (typeof port === 'number' && port >= 0) {\n            this.server.listen(port, host);\n        } else if (typeof port === 'string') {\n            this.server.listen(port);\n        } else {\n            throw new Error('no port or path provided');\n        }\n        \n        if (callback) {\n            this.server.on('listening', callback);\n        }\n        \n        return this.server;\n    }\n\n    _randomId() {\n        var s = '';\n        for (var i = 0; i < 4; i++) {\n            s += Math.random().toString(16).slice(2);\n        }\n        return s;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "const { net } = require('node:net');\nconst { WeakRef } = require('node:weakref');\n\nclass DNodeServer {\n  constructor(cons, opts = {}) {\n    this.cons = cons;\n    this.opts = opts;\n    this.server = net.createServer();\n    this.sessions = {};\n    this.weakRefs = new WeakMap();\n\n    if (opts.weak) {\n      this._setupWeakRefs();\n    }\n\n    this.server.on('connection', (stream) => {\n      this._handleConnection(stream);\n    });\n  }\n\n  _setupWeakRefs() {\n    this.server.on('connection', (stream) => {\n      const session = this._handleConnection(stream);\n      this.weakRefs.set(session, session);\n    });\n  }\n\n  _handleConnection(stream) {\n    const id = this._randomId();\n    const session = {\n      id,\n      stream\n    };\n\n    this.sessions[id] = session;\n\n    stream.on('data', (data) => {\n      this.cons(session, data);\n    });\n\n    stream.on('end', () => {\n      delete this.sessions[id];\n      this.weakRefs.delete(session);\n    });\n\n    stream.on('error', (err) => {\n      delete this.sessions[id];\n      this.weakRefs.delete(session);\n      console.error(err);\n    });\n\n    return session;\n  }\n\n  listen(port, host, callback) {\n    if (typeof port === 'string') {\n      this.server.listen(port, host, callback);\n    } else {\n      this.server.listen(port, host, callback);\n    }\n    return this.server;\n  }\n\n  _randomId() {\n    return 'xxxxxxxxxxxx'.replace(/x/g, () => Math.floor(Math.random() * 16).toString(16));\n  }\n}"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "static async getWallpaper(unsplashClientId) {\n  try {\n    if (unsplashClientId) {\n      const response = await fetch('https://api.unsplash.com/photos/random', {\n        headers: {\n          'Authorization': `Client-ID ${unsplashClientId}`\n        }\n      });\n      const data = await response.json();\n      return { type: 'unsplash', data };\n    } else {\n      const response = await fetch('https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1');\n      const data = await response.json();\n      const imageUrl = `https://www.bing.com${data.images[0].url}`;\n      return { type: 'bing', data: { url: imageUrl } };\n    }\n  } catch (error) {\n    console.error(error);\n    return { type: 'bing', data: { url: 'https://via.placeholder.com/1920x1080' } };\n  }\n}"
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a TCP server class in JavaScript using Node.js's built-in 'net' module to handle client connections, manage socket communication, and process incoming messages.\n\nClass Description: The TcpReader class is responsible for establishing a TCP server, managing client connections, handling socket events, and processing incoming messages through a custom parser. It provides methods to start/stop the server and manage connected clients.\n\nAttributes:\n- transporter: [Object] - The parent transporter object that handles incoming messages\n- opts: [Object] - Configuration options including the port to listen on\n- sockets: [Array] - Array of currently connected client sockets\n- logger: [Object] - Logger instance from the transporter for error logging\n- server: [Object] - The TCP server instance\n- connected: [Boolean] - Flag indicating if the server is currently listening\n\nMethods:\n- constructor(transporter, opts) -> [void] - Initializes the TcpReader with transporter and options\n- listen() -> [Promise] - Starts the TCP server and begins listening for connections\n- onTcpClientConnected(socket) -> [void] - Handles new client connections and sets up event listeners\n- closeSocket(socket, err) -> [void] - Closes and removes a specific socket from the connections\n- close() -> [void] - Stops the server and closes all connected sockets",
    "Canonical_solution": "const net = require(\"net\");\n\nclass TcpReader {\n    constructor(transporter, opts) {\n        this.transporter = transporter;\n        this.opts = opts;\n        this.sockets = [];\n        this.logger = transporter.logger;\n    }\n\n    listen() {\n        return new Promise((resolve, reject) => {\n            this.server = net.createServer(socket => {\n                this.onTcpClientConnected(socket);\n            });\n\n            this.server.on(\"error\", err => {\n                reject(err);\n            });\n\n            const listenOptions = process.versions.node.split(\".\")[0] >= 8 \n                ? { port: this.opts.port, exclusive: true }\n                : this.opts.port;\n\n            this.server.listen(listenOptions, () => {\n                this.opts.port = this.server.address().port;\n                this.connected = true;\n                resolve();\n            });\n        });\n    }\n\n    onTcpClientConnected(socket) {\n        socket.on(\"error\", err => {\n            this.closeSocket(socket, err);\n        });\n\n        socket.on(\"close\", () => {\n            this.closeSocket(socket);\n        });\n\n        socket.setNoDelay(true);\n\n        const parser = require(\"../../../../src/transporters/tcp/parser\")();\n        socket.pipe(parser);\n\n        parser.on(\"data\", (type, message) => {\n            this.transporter.onIncomingMessage(type, message, socket);\n        });\n\n        parser.on(\"error\", err => {\n            this.closeSocket(socket, err);\n        });\n\n        this.sockets.push(socket);\n    }\n\n    closeSocket(socket, err) {\n        if (err) {\n            this.logger.warn(`TCP socket error: ${err.message}`);\n        }\n\n        const index = this.sockets.indexOf(socket);\n        if (index !== -1) {\n            this.sockets.splice(index, 1);\n            socket.destroy();\n        }\n    }\n\n    close() {\n        if (this.server && this.server.listening) {\n            this.server.close();\n        }\n\n        this.sockets.forEach(socket => {\n            socket.destroy();\n        });\n        this.sockets = [];\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "class TcpReader {\n  constructor(transporter, opts) {\n    this.transporter = transporter;\n    this.opts = opts || {};\n    this.sockets = [];\n    this.logger = this.transporter.logger;\n    this.server = null;\n    this.connected = false;\n  }\n\n  listen() {\n    return new Promise((resolve, reject) => {\n      this.server = net.createServer((socket) => {\n        this.onTcpClientConnected(socket);\n      });\n\n      this.server.on('error', (err) => {\n        this.logger.error(`Server error: ${err.message}`);\n        reject(err);\n      });\n\n      this.server.listen(this.opts.port, () => {\n        this.connected = true;\n        this.logger.info(`Server listening on port ${this.opts.port}`);\n        resolve();\n      });\n    });\n  }\n\n  onTcpClientConnected(socket) {\n    this.sockets.push(socket);\n    socket.on('data', (data) => {\n      this.transporter.parse(data, socket);\n    });\n    socket.on('end', () => {\n      this.closeSocket(socket, null);\n    });\n    socket.on('error', (err) => {\n      this.logger.error(`Socket error: ${err.message}`);\n      this.closeSocket(socket, err);\n    });\n  }\n\n  closeSocket(socket, err) {\n    const index = this.sockets.indexOf(socket);\n    if (index > -1) {\n      this.sockets.splice(index, 1);\n    }\n    if (err) {\n      this.logger.error(`Closing socket due to error: ${err.message}`);\n    } else {\n      this.logger.info('Socket closed');\n    }\n    socket.end();\n  }\n\n  close() {\n    if (this.server) {\n      this.server.close(() => {\n        this.connected = false;\n        this.logger.info('Server closed');\n      });\n    }\n  }\n}"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Write a function that fetches version information and schema data from a remote API, caches the results locally, and handles errors appropriately.\n\nFunction Description: The function `fetchAndCacheVersions` retrieves version data from a specified API endpoint, then fetches schema data for each non-deprecated version. It caches all retrieved data in JSON files in a local directory. Errors during the process are caught and logged, with the process exiting on failure.\n\nInput: None (The function takes no parameters; all URLs and paths are hardcoded)\n\nOutput: \n- Success: Writes JSON files to the cache directory and logs success messages\n- Failure: Logs error messages and exits the process with status code 1",
    "Canonical_solution": "function fetchAndCacheVersions() {\n    const axios = require('axios');\n    const { writeJsonSync } = require('fs-extra');\n    const path = require('path');\n\n    axios\n        .get('https://exp.host/--/versions')\n        .then(async ({ data }) => {\n            writeJsonSync(path.join(__dirname, '../caches/versions.json'), data);\n\n            for (const version of Object.keys(data.sdkVersions)) {\n                if (data.sdkVersions[version].isDeprecated) {\n                    continue;\n                }\n                const {\n                    data: { data: schema },\n                } = await axios.get(`https://exp.host/--/api/v2/project/configuration/schema/${version}`);\n\n                const filePath = path.join(__dirname, `../caches/schema-${version}.json`);\n                console.log('Writing', filePath);\n                writeJsonSync(filePath, schema);\n            }\n        })\n        .then(() => console.log('Caches updated.'))\n        .catch(error => {\n            console.error(error);\n            console.error('Updating caches failed.');\n            process.exit(1);\n        });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "fetchAndCacheVersions = async () => {\n  const cacheDir = './cache';\n  const versionsUrl = 'https://api.example.com/versions';\n  const schemaUrlTemplate = 'https://api.example.com/schemas/%s';\n\n  try {\n    // Ensure cache directory exists\n    await fs.promises.mkdir(cacheDir, { recursive: true });\n\n    // Fetch versions\n    const versionsResponse = await fetch(versionsUrl);\n    if (!versionsResponse.ok) throw new Error(`Failed to fetch versions: ${versionsResponse.status}`);\n    const versions = await versionsResponse.json();\n\n    // Cache versions\n    const versionsFilePath = path.join(cacheDir, 'versions.json');\n    await fs.promises.writeFile(versionsFilePath, JSON.stringify(versions, null, 2));\n    console.log('Versions cached successfully');\n\n    // Fetch and cache schemas for non-deprecated versions\n    for (const version of versions) {\n      if (version.deprecated) continue;\n\n      const schemaUrl = format(schemaUrlTemplate, version.version);\n      const schemaResponse = await fetch(schemaUrl);\n      if (!schemaResponse.ok) {\n        console.error(`Failed to fetch schema for version ${version.version}: ${schemaResponse.status}`);\n        continue;\n      }\n\n      const schema = await schemaResponse.json();\n      const schemaFilePath = path.join(cacheDir, `schema_${version.version}.json`);\n      await fs.promises.writeFile(schemaFilePath, JSON.stringify(schema, null, 2));\n      console.log(`Schema for version ${version.version} cached successfully`);\n    }\n\n    console.log('All data cached successfully');\n  } catch (error) {\n    console.error('Error during fetching and caching:', error.message);\n    process.exit(1);\n  }\n};"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a Flash Policy Server class in JavaScript using Node.js's net module to handle cross-domain policy requests for socket connections.\n\nClass Description: The FlashPolicyServer class creates a TCP server that responds to Flash socket policy requests. It manages allowed origins/ports, compiles the XML policy file, and handles server lifecycle events.\n\nAttributes:\n- origins: [Array] - List of allowed domain:port combinations\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [Object] - TCP server instance\n- buffer: [Buffer] - Compiled policy file in binary format\n- server: [Object] - Optional existing server instance to attach to\n\nMethods:\n- constructor(options, origins) -> [FlashPolicyServer] - Initializes the server with options and allowed origins\n- listen(port, server, cb) -> [FlashPolicyServer] - Starts listening on specified port, optionally attaching to existing server\n- responder(socket) -> [void] - Responds to policy requests on a socket connection\n- compile() -> [FlashPolicyServer] - Generates the XML policy buffer from allowed origins\n- add() -> [FlashPolicyServer] - Adds new allowed origins to the policy\n- remove(origin) -> [FlashPolicyServer] - Removes an origin from the allowed list\n- close() -> [FlashPolicyServer] - Stops the server and cleans up listeners",
    "Canonical_solution": "var net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => this.responder(socket));\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges.'\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (data && data[0] === 60 && data.toString() === '<policy-file-request/>\\0' &&\n              socket && (socket.readyState === 'open' || socket.readyState === 'writeOnly')) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    this.port >= 0 && this.socket.listen(this.port, () => {\n      this.socket.online = true;\n      if (callback) {\n        callback.call(this);\n        callback = undefined;\n      }\n    });\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = new Buffer(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "const net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options && options.port ? options.port : 843;\n    this.log = options && options.log ? options.log : console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = null;\n  }\n\n  listen(port, server, cb) {\n    this.port = port || this.port;\n    this.server = server || null;\n\n    this.socket = net.createServer((socket) => {\n      this.responder(socket);\n    });\n\n    if (this.server) {\n      this.server.on('connection', (sock) => {\n        this.socket.handleConnection(sock);\n      });\n    } else {\n      this.socket.listen(this.port, () => {\n        this.log(`Flash Policy Server listening on port ${this.port}`);\n        if (cb) cb();\n      });\n    }\n\n    return this;\n  }\n\n  responder(socket) {\n    socket.on('data', (data) => {\n      if (data.toString().startsWith('<?xml')) {\n        this.log('Received policy request');\n        const response = this.compile();\n        socket.write(response);\n        socket.end();\n      }\n    });\n\n    socket.on('error', (err) => {\n      this.log('Socket error:', err.message);\n    });\n  }\n\n  compile() {\n    let xml = '<?xml version=\"1.0\"?><!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\"><cross-domain-policy>';\n    this.origins.forEach(origin => {\n      xml += `<allow-access-from domain=\"${origin}\" />`;\n    });\n    xml += '</cross-domain-policy>';\n    this.buffer = Buffer.from(xml, 'utf-8');\n    return this.buffer;\n  }\n\n  add(origin) {\n    if (origin && !this.origins.includes(origin)) {\n      this.origins.push(origin);\n      this.compile();\n    }\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index !== -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.log('Flash Policy Server closed');\n    return this;\n  }\n}"
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Create a UDP server that listens for incoming messages, processes them, and emits events to connected clients via WebSocket. The server should handle JSON-formatted messages, manage streams of data, and maintain a history of recent messages for each stream.\n\nFunction Description: The function `setupUDPServer` initializes a UDP server using Node.js's `dgram` module. It listens for incoming messages, parses them as JSON, and manages a collection of data streams. Each message is stored in its respective stream, with a limit of 100 messages per stream. The server also emits WebSocket events to notify clients of new messages and updates to the available streams.\n\nInput: \n- `argv.udpPort` [Number] - The port number on which the UDP server should listen.\n- `argv.udpHost` [String] - The host address on which the UDP server should bind (optional, defaults to all interfaces if not specified).\n- `io` [Object] - A WebSocket server instance (e.g., from `socket.io`) used to emit events to connected clients.\n- `debug` [Function] - A logging function used to output debug information.\n\nOutput: None (The function sets up the UDP server and binds it to the specified port and host, but does not return any value.)",
    "Canonical_solution": "function setupUDPServer() {\n    const dgram = require('dgram');\n    let streams = {};\n    let socket = dgram.createSocket('udp4');\n\n    socket.on('message', function (data, remote) {\n        try { data = JSON.parse(data); }\n        catch (err) { return debug('invalid data sent'); }\n\n        if (!streams[data.id]) {\n            streams[data.id] = [];\n            io.sockets.emit('streams', Object.keys(streams));\n        }\n\n        let message = {\n            timestamp: data.timestamp,\n            streamid: data.id,\n            host: remote.address,\n            port: remote.port,\n            content: data.content,\n            type: typeof data.content\n        };\n\n        streams[data.id].length >= 100 && streams[data.id].shift();\n        streams[data.id].push(message);\n\n        debug(JSON.stringify(message));\n        io.sockets.to(data.id).emit('line', message);\n    });\n\n    socket.bind(argv.udpPort, argv.udpHost);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 98,
    "wrong_result": "const dgram = require('dgram');\nconst WebSocket = require('ws');\n\nfunction setupUDPServer(udpPort, udpHost, io, debug) {\n  const server = dgram.createSocket({ type: 'udp4', reuseAddr: true });\n  const streams = new Map();\n\n  server.on('message', (message, remoteInfo) => {\n    try {\n      const data = JSON.parse(message.toString());\n      const { streamId, content } = data;\n\n      if (!streams.has(streamId)) {\n        streams.set(streamId, { id: streamId, messages: [] });\n      }\n\n      const stream = streams.get(streamId);\n      stream.messages.push(content);\n\n      if (stream.messages.length > 100) {\n        stream.messages.shift();\n      }\n\n      debug(`Received message for stream ${streamId}: ${content}`);\n\n      io.emit('newMessage', { streamId, content });\n\n      // Emit update to available streams\n      io.emit('updateStreams', Array.from(streams.values()));\n    } catch (err) {\n      debug(`Error parsing message: ${err.message}`);\n    }\n  });\n\n  server.on('error', (err) => {\n    debug(`UDP server error: ${err.message}`);\n    server.close();\n  });\n\n  server.bind(udpPort, udpHost || undefined);\n}"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Create a UDP communication class in JavaScript using Node.js's dgram module for bidirectional message handling between processes.\n\nClass Description: The Udp class facilitates UDP-based communication with capabilities for both sending and receiving messages. It manages socket creation, port binding, message queuing, and event handling for network communication.\n\nAttributes:\n- stack: [Array] - Stores outgoing messages in a queue before sending\n- port: [Number|null] - The target port number for outgoing messages\n- socket: [dgram.Socket|null] - UDP socket instance for sending messages\n- listener: [dgram.Socket|null] - UDP socket instance for receiving messages\n- client: [Object] - Reference to the parent client object for message handling\n\nMethods:\n- constructor(client) -> [void] - Initializes the UDP instance with a client reference and creates socket objects\n- start() -> [void] - Begins UDP communication by setting up input and output sockets\n- clear() -> [void] - Clears the message queue\n- run() -> [void] - Processes all messages in the queue\n- push(msg) -> [void] - Adds a message to the outgoing queue (Input: msg [String] - Message to send)\n- play(data) -> [void] - Sends a single message via UDP (Input: data [String] - Message content)\n- selectOutput(port=49161) -> [void] - Configures the output port (Input: port [Number] - Target port number)\n- selectInput(port=49160) -> [void] - Configures and starts the input listener (Input: port [Number] - Listening port number)",
    "Canonical_solution": "const dgram = require('dgram');\n\nclass Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = dgram ? dgram.createSocket('udp4') : null;\n    this.listener = dgram ? dgram.createSocket('udp4') : null;\n    this.client = client;\n  }\n\n  start() {\n    if (!dgram || !this.socket || !this.listener) { \n      console.warn('UDP', 'Could not start.'); \n      return; \n    }\n    console.info('UDP', 'Starting..');\n\n    this.selectInput();\n    this.selectOutput();\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    for (const item of this.stack) {\n      this.play(item);\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (!this.socket) { return; }\n    this.socket.send(Buffer.from(`${data}`), this.port, this.client.io.ip, (err) => {\n      if (err) { console.warn(err); }\n    });\n  }\n\n  selectOutput(port = 49161) {\n    if (!dgram) { console.warn('UDP', 'Unavailable.'); return; }\n    if (parseInt(port) === this.port) { console.warn('UDP', 'Already selected'); return; }\n    if (isNaN(port) || port < 1000) { console.warn('UDP', 'Unavailable port'); return; }\n\n    console.log('UDP', `Output: ${port}`);\n    this.port = parseInt(port);\n  }\n\n  selectInput(port = 49160) {\n    if (!dgram) { console.warn('UDP', 'Unavailable.'); return; }\n    if (this.listener) { this.listener.close(); }\n\n    console.log('UDP', `Input: ${port}`);\n    this.listener = dgram.createSocket('udp4');\n\n    this.listener.on('message', (msg, rinfo) => {\n      this.client.commander.trigger(`${msg}`);\n    });\n\n    this.listener.on('listening', () => {\n      const address = this.listener.address();\n      console.info('UDP', `Started socket at ${address.address}:${address.port}`);\n    });\n\n    this.listener.on('error', (err) => {\n      console.warn('UDP', `Server error:\\n ${err.stack}`);\n      this.listener.close();\n    });\n\n    this.listener.bind(port);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "class Udp {\n  constructor(client) {\n    this.stack = [];\n    this.port = null;\n    this.socket = null;\n    this.listener = null;\n    this.client = client;\n  }\n\n  start() {\n    this.selectInput();\n    this.selectOutput();\n  }\n\n  clear() {\n    this.stack = [];\n  }\n\n  run() {\n    while (this.stack.length > 0) {\n      this.play(this.stack.shift());\n    }\n  }\n\n  push(msg) {\n    this.stack.push(msg);\n  }\n\n  play(data) {\n    if (!this.socket) return;\n    this.socket.send(data, 0, data.length, this.port, '0.0.0.0', (err) => {\n      if (err) {\n        console.error('UDP send error:', err);\n      }\n    });\n  }\n\n  selectOutput(port = 49161) {\n    this.port = port;\n    if (!this.socket) {\n      this.socket = dgram.createSocket('udp4');\n    }\n  }\n\n  selectInput(port = 49160) {\n    if (!this.listener) {\n      this.listener = dgram.createSocket('udp4');\n      this.listener.on('message', (msg, rinfo) => {\n        const message = msg.toString();\n        this.client.receive(message, rinfo.address, rinfo.port);\n      });\n      this.listener.on('error', (err) => {\n        console.error('UDP listener error:', err);\n        this.listener.close();\n      });\n      this.listener.bind(port, '0.0.0.0', () => {\n        console.log(`UDP listener started on port ${port}`);\n      });\n    }\n  }\n}"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Create a UDP-based poller class in JavaScript that can send ping messages to a target UDP server and handle pong responses, with timeout functionality.\n\nClass Description: The UdpPoller class is designed to monitor UDP servers by sending periodic ping messages and listening for pong responses. It inherits from a base poller class and implements UDP communication using Node.js's dgram module.\n\nAttributes:\n- udpServer: [Object] - The UDP socket instance created using dgram module\n- target: [Object/String] - The target server address and port (parsed from input URL)\n- timeout: [Number] - The maximum time to wait for a response before timing out\n- callback: [Function] - The callback function to be executed when a response is received or an error occurs\n\nMethods:\n- constructor(target, timeout, callback) -> [void] - Initializes the poller with target, timeout, and callback\n- static get type() -> [String] - Returns the poller type ('udp')\n- static validateTarget(target) -> [Boolean] - Validates if the target URL matches UDP format\n- initialize() -> [void] - Sets up the UDP socket and parses the target address\n- poll() -> [void] - Sends a ping message to the target server and sets up response listener\n- onResponseCallback(message, sender) -> [void] - Handles incoming messages and processes pong responses\n- timeoutReached() -> [void] - Cleans up socket listeners when timeout occurs",
    "Canonical_solution": "var util = require('util');\nvar dgram = require('dgram');\nvar BasePoller = require('../basePoller');\n\nclass UdpPoller {\n  constructor(target, timeout, callback) {\n    UdpPoller.super_.call(this, target, timeout, callback);\n    this.udpServer = null;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    return reg.test(target);\n  }\n\n  initialize() {\n    this.udpServer = dgram.createSocket('udp4');\n    this.udpServer.bind();\n    this.udpServer.on('error', function() {});\n    \n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    if(!reg.test(this.target)) {\n      console.log(this.target + ' does not seems to be valid udp url');\n    }\n    var host = reg.exec(this.target);\n    this.target = {\n      'address': host[1],\n      'port': host[2]\n    };\n  }\n\n  poll() {\n    var ping = new Buffer(JSON.stringify({'command': 'ping'}));\n    this.udpServer.send(ping, 0, ping.length, this.target.port, this.target.address);\n    this.udpServer.on(\"message\", this.onResponseCallback.bind(this));\n  }\n\n  onResponseCallback(message, sender) {\n    var cmd;\n    try {\n      cmd = JSON.parse(message);\n    } catch (e) {\n      return this.onErrorCallback({ name: \"Unparsable answer\", message: \"server return answer \" + message.toString()});\n    }\n    if (cmd.command === 'pong') {\n      this.timer.stop();\n      this.callback(null, this.getTime(), cmd);\n    }\n  }\n\n  timeoutReached() {\n    this.udpServer.removeAllListeners();\n  }\n}\n\nutil.inherits(UdpPoller, BasePoller);",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "class UdpPoller {\n  constructor(target, timeout, callback) {\n    this.target = target;\n    this.timeout = timeout;\n    this.callback = callback;\n    this.udpServer = null;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    const udpRegex = /^udp:\\/\\/([^:]+):(\\d+)$/i;\n    return udpRegex.test(target);\n  }\n\n  initialize() {\n    const { host, port } = this.parseTarget();\n    this.udpServer = dgram.createSocket('udp4');\n    this.udpServer.on('message', this.onResponseCallback.bind(this));\n    this.udpServer.on('error', (err) => {\n      this.callback(err, null);\n      this.udpServer.close();\n    });\n  }\n\n  parseTarget() {\n    const match = this.target.match(/^udp:\\/\\/([^:]+):(\\d+)$/i);\n    return {\n      host: match[1],\n      port: parseInt(match[2], 10)\n    };\n  }\n\n  poll() {\n    const message = Buffer.from('PING');\n    this.udpServer.send(message, 0, message.length, this.target.port, this.target.host);\n    setTimeout(() => {\n      this.timeoutReached();\n    }, this.timeout);\n  }\n\n  onResponseCallback(message, sender) {\n    if (message.toString() === 'PONG') {\n      this.callback(null, 'PONG_RECEIVED');\n      this.udpServer.close();\n    }\n  }\n\n  timeoutReached() {\n    this.callback(new Error('Timeout reached'), null);\n    this.udpServer.close();\n  }\n}"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome DevTools Protocol, handling connection, message exchange, and disconnection events.\n\nClass Description: The Chrome class is an EventEmitter that establishes and manages a WebSocket connection to Chrome's DevTools Protocol. It handles message parsing, error handling, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The WebSocket instance\n- _notifier: [EventEmitter] - External event notifier\n- _callbacks: [Object] - Stores pending command callbacks\n- _nextCommandId: [Number] - Tracks the next command ID\n\nMethods:\n- constructor(options, notifier) -> [void] - Initializes the Chrome instance with connection options and notifier\n- _start() -> [Promise] - Internal method to initiate WebSocket connection\n- _connectToWebSocket() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleConnectionClose() -> [void] - Cleans up when connection closes\n- _handleMessage(message) -> [void] - Processes incoming WebSocket messages\n- send(method, params, sessionId, callback) -> [Promise|void] - Sends a command to Chrome DevTools Protocol\n- _enqueueCommand(method, params, sessionId, callback) -> [void] - Internal method to queue commands\n- close(callback) -> [Promise|void] - Closes the WebSocket connection cleanly",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this.webSocketUrl = undefined;\n        this._ws = null;\n        this._notifier = notifier;\n        this._start();\n    }\n\n    async _start() {\n        try {\n            await this._connectToWebSocket();\n            process.nextTick(() => {\n                this._notifier.emit('connect', this);\n            });\n        } catch (err) {\n            this._notifier.emit('error', err);\n        }\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleConnectionClose() {\n        this._callbacks = {};\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n\n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    close(callback) {\n        const closeWebSocket = (callback) => {\n            if (this._ws.readyState === 3) {\n                callback();\n            } else {\n                this._ws.removeAllListeners('close');\n                this._ws.once('close', () => {\n                    this._ws.removeAllListeners();\n                    this._handleConnectionClose();\n                    callback();\n                });\n                this._ws.close();\n            }\n        };\n        if (typeof callback === 'function') {\n            closeWebSocket(callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                closeWebSocket(fulfill);\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "const { EventEmitter } = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this.webSocketUrl = this.secure ? `wss://${this.host}:${this.port}/devtools/browser` : `ws://${this.host}:${this.port}/devtools/browser`;\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 1;\n  }\n\n  async _start() {\n    try {\n      this._ws = await this._connectToWebSocket();\n      this._ws.on('message', (message) => this._handleMessage(message));\n      this._ws.on('close', () => this._handleConnectionClose());\n      this._ws.on('error', (err) => {\n        this.emit('error', err);\n        this.close();\n      });\n    } catch (err) {\n      this.emit('error', err);\n      this.close();\n    }\n  }\n\n  async _connectToWebSocket() {\n    const ws = new WebSocket(this.webSocketUrl);\n    return new Promise((resolve, reject) => {\n      ws.on('open', resolve);\n      ws.on('error', reject);\n    });\n  }\n\n  _handleConnectionClose() {\n    this._ws = null;\n    this.emit('disconnect');\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message);\n    if (data.method) {\n      const callback = this._callbacks[data.id];\n      if (callback) {\n        callback(null, data.result, data.sessionId);\n        delete this._callbacks[data.id];\n      }\n    } else if (data.event) {\n      this.emit('event', data);\n    } else if (data.error) {\n      this.emit('error', data.error);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    if (!this._ws) {\n      return this._start().then(() => this._enqueueCommand(method, params, sessionId, callback));\n    }\n    return this._enqueueCommand(method, params, sessionId, callback);\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const id = this._nextCommandId++;\n    this._callbacks[id] = callback;\n    const message = {\n      id,\n      method,\n      params,\n      sessionId\n    };\n    this._ws.send(JSON.stringify(message));\n  }\n\n  close(callback) {\n    if (this._ws) {\n      this._ws.close();\n      this._ws = null;\n      this._callbacks = {};\n      if (callback) {\n        process.nextTick(callback);\n      }\n    }\n  }\n}"
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a WebSocket client class in Node.js that connects to a speech synthesis service, sends SSML requests, and handles the audio response streams.\n\nClass Description: WebSocketClient is a class that manages WebSocket connections to Microsoft's Bing Speech API for text-to-speech synthesis. It handles connection lifecycle, request/response mapping, and binary audio data streaming.\n\nAttributes:\n- ws: [WebSocket|null] - Active WebSocket connection instance\n- executorMap: [Map] - Stores promise resolvers/rejectors mapped by request IDs\n- bufferMap: [Map] - Accumulates binary audio data chunks mapped by request IDs\n- timer: [Timeout|null] - Connection timeout handler\n\nMethods:\n- connect() -> [Promise<WebSocket>] - Establishes WebSocket connection with proper headers and returns a promise that resolves when connected\n- sendRequest(ssml: [String], format: [String]) -> [Promise<Buffer>] - Sends SSML request with specified audio format and returns promise resolving to audio buffer\n\nInput:\n- For connect(): None\n- For sendRequest():\n  - ssml: [String] - SSML markup for speech synthesis\n  - format: [String] - Desired audio output format (e.g., \"audio-24khz-48kbitrate-mono-mp3\")\n\nOutput:\n- For connect(): Resolves with WebSocket instance or rejects with error\n- For sendRequest(): Resolves with audio buffer or rejects with error",
    "Canonical_solution": "const { WebSocket } = require(\"ws\");\nconst { randomBytes } = require(\"crypto\");\n\nclass WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  async connect() {\n    const connectionId = randomBytes(16).toString(\"hex\").toLowerCase();\n    let url = `wss://speech.platform.bing.com/consumer/speech/synthesize/readaloud/edge/v1?TrustedClientToken=6A5AA1D4EAFF4E9FB37E23D68491D6F4&ConnectionId=${connectionId}`;\n    let ws = new WebSocket(url, {\n      host: \"speech.platform.bing.com\",\n      origin: \"chrome-extension://jdiccldimpdaibmpdkjnbmckianbfold\",\n      headers: {\n        \"User-Agent\":\n          \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.66 Safari/537.36 Edg/103.0.1264.44\",\n      },\n    });\n    \n    return new Promise((resolve, reject) => {\n      ws.on(\"open\", () => {\n        resolve(ws);\n      });\n      \n      ws.on(\"close\", (code, reason) => {\n        this.ws = null;\n        if (this.timer) {\n          clearTimeout(this.timer);\n          this.timer = null;\n        }\n        for (let [key, value] of this.executorMap) {\n          value.reject(`\u8fde\u63a5\u5df2\u5173\u95ed: ${reason} ${code}`);\n        }\n        this.executorMap.clear();\n        this.bufferMap.clear();\n      });\n\n      ws.on(\"message\", (message, isBinary) => {\n        let pattern = /X-RequestId:(?<id>[a-z|0-9]*)/;\n        if (!isBinary) {\n          let data = message.toString();\n          if (data.includes(\"Path:turn.start\")) {\n            let matches = data.match(pattern);\n            let requestId = matches.groups.id;\n            this.bufferMap.set(requestId, Buffer.from([]));\n          } else if (data.includes(\"Path:turn.end\")) {\n            let matches = data.match(pattern);\n            let requestId = matches.groups.id;\n            let executor = this.executorMap.get(requestId);\n            if (executor) {\n              this.executorMap.delete(matches.groups.id);\n              let result = this.bufferMap.get(requestId);\n              executor.resolve(result);\n            }\n          }\n        } else if (isBinary) {\n          let separator = \"Path:audio\\r\\n\";\n          let data = message;\n          let contentIndex = data.indexOf(separator) + separator.length;\n          let headers = data.slice(2, contentIndex).toString();\n          let matches = headers.match(pattern);\n          let requestId = matches.groups.id;\n          let content = data.slice(contentIndex);\n          let buffer = this.bufferMap.get(requestId);\n          if (buffer) {\n            buffer = Buffer.concat([buffer, content], buffer.length+content.length);\n            this.bufferMap.set(requestId, buffer);\n          }\n        }\n      });\n      \n      ws.on(\"error\", (error) => {\n        reject(`\u8fde\u63a5\u5931\u8d25\uff1a ${error}`);\n      });\n    });\n  }\n\n  async sendRequest(ssml, format) {\n    if (this.ws == null || this.ws.readyState != WebSocket.OPEN) {\n      let connection = await this.connect();\n      this.ws = connection;\n    }\n    \n    const requestId = randomBytes(16).toString(\"hex\").toLowerCase();\n    let result = new Promise((resolve, reject) => {\n      this.executorMap.set(requestId, { resolve, reject });\n      \n      let configData = {\n        context: {\n          synthesis: {\n            audio: {\n              metadataoptions: {\n                sentenceBoundaryEnabled: \"false\",\n                wordBoundaryEnabled: \"false\",\n              },\n              outputFormat: format,\n            },\n          },\n        },\n      };\n      \n      let configMessage =\n        `X-Timestamp:${Date()}\\r\\n` +\n        \"Content-Type:application/json; charset=utf-8\\r\\n\" +\n        \"Path:speech.config\\r\\n\\r\\n\" +\n        JSON.stringify(configData);\n        \n      this.ws.send(configMessage, (configError) => {\n        if (configError) return;\n        \n        let ssmlMessage =\n          `X-Timestamp:${Date()}\\r\\n` +\n          `X-RequestId:${requestId}\\r\\n` +\n          `Content-Type:application/ssml+xml\\r\\n` +\n          `Path:ssml\\r\\n\\r\\n` +\n          ssml;\n        this.ws.send(ssmlMessage);\n      });\n    });\n\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    \n    this.timer = setTimeout(() => {\n      if (this.ws && this.ws.readyState == WebSocket.OPEN) {\n        this.ws.close(1000);\n        this.timer = null;\n      }\n    }, 10000);\n\n    return await Promise.race([\n      result,\n      new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.executorMap.delete(requestId);\n          this.bufferMap.delete(requestId);\n          reject(\"\u8bf7\u6c42\u8d85\u65f6\");\n        }, 10000);\n      }),\n    ]);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class WebSocketClient {\n  constructor() {\n    this.ws = null;\n    this.executorMap = new Map();\n    this.bufferMap = new Map();\n    this.timer = null;\n  }\n\n  async connect() {\n    return new Promise((resolve, reject) => {\n      this.timer = setTimeout(() => {\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n          clearTimeout(this.timer);\n          resolve(this.ws);\n        } else {\n          reject(new Error('Connection timeout'));\n        }\n      }, 5000);\n\n      this.ws = new WebSocket('wss://speech.platform.bing.com');\n\n      this.ws.onopen = () => {\n        clearTimeout(this.timer);\n        resolve(this.ws);\n      };\n\n      this.ws.onerror = (error) => {\n        clearTimeout(this.timer);\n        reject(new Error('WebSocket error: ' + error.message));\n      };\n\n      this.ws.onclose = () => {\n        clearTimeout(this.timer);\n        this.ws = null;\n      };\n    });\n  }\n\n  sendRequest(ssml, format) {\n    return new Promise((resolve, reject) => {\n      const requestId = Date.now().toString();\n      const resolver = { resolve, reject };\n      this.executorMap.set(requestId, resolver);\n      this.bufferMap.set(requestId, []);\n\n      const request = JSON.stringify({\n        \"context\": {\n          \"synthesis\": {\n            \"audio\": {\n              \"format\": format\n            },\n            \"voice\": \"en-US-JennyNeural\"\n          }\n        },\n        \"inputs\": [\n          {\n            \"type\": \"text\",\n            \"text\": ssml\n          }\n        ]\n      });\n\n      this.ws.send(request);\n\n      this.ws.onmessage = (event) => {\n        const data = event.data;\n        if (data instanceof Blob) {\n          const reader = new FileReader();\n          reader.onload = (e) => {\n            const buffer = Buffer.from(e.target.result);\n            this.bufferMap.get(requestId).push(buffer);\n            this.executorMap.delete(requestId);\n            this.bufferMap.delete(requestId);\n            const combinedBuffer = Buffer.concat(this.bufferMap.get(requestId));\n            resolve(combinedBuffer);\n          };\n          reader.readAsArrayBuffer(data);\n        } else if (data.toString().includes('sessionid')) {\n          const sessionIdMatch = data.toString().match(/\"sessionid\":\"([^\"]+)\"/);\n          if (sessionIdMatch) {\n            const sessionId = sessionIdMatch[1];\n            this.ws.send(JSON.stringify({\n              \"context\": {\n                \"synthesis\": {\n                  \"audio\": {\n                    \"format\": format\n                  },\n                  \"voice\": \"en-US-JennyNeural\"\n                }\n              },\n              \"inputs\": [\n                {\n                  \"type\": \"text\",\n                  \"text\": ssml\n                }\n              ],\n              \"sessionid\": sessionId\n            }));\n          }\n        }\n      };\n\n      this.ws.onclose = () => {\n        this.executorMap.delete(requestId);\n        this.bufferMap.delete(requestId);\n        reject(new Error('WebSocket closed before response'));\n      };\n    });\n  }\n}"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class OrderBook extends EventEmitter {\n  constructor(productID, websocketURI, restURI, timeProvider) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = 'disconnected';\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = {\n      sequence: 0,\n      bids: {},\n      asks: {}\n    };\n  }\n\n  clear_book() {\n    this.book = {\n      sequence: 0,\n      bids: {},\n      asks: {}\n    };\n    this.queue = [];\n  }\n\n  connect() {\n    if (this.state === 'connecting' || this.state === 'connected') {\n      return;\n    }\n    this.changeState('connecting');\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      this.fail_count++;\n      if (this.fail_count > 3) {\n        this.changeState('failed');\n      } else {\n        this.changeState('disconnected');\n      }\n    };\n  }\n\n  disconnect() {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close();\n    }\n    this.changeState('disconnected');\n  }\n\n  changeState(stateName) {\n    if (stateName !== this.state) {\n      this.state = stateName;\n      this.emit('statechange', this.state);\n    }\n  }\n\n  onOpen() {\n    this.changeState('connected');\n    this.sync();\n  }\n\n  onClose() {\n    this.changeState('disconnected');\n  }\n\n  onMessage(datastr) {\n    try {\n      const data = JSON.parse(datastr);\n      if (data.type === 'snapshot') {\n        this.processMessage(data, this.timeProvider.now());\n      } else if (data.type === 'update') {\n        this.processMessage(data, this.timeProvider.now());\n      } else {\n        this.queue.push(data);\n      }\n    } catch (e) {\n      console.error('Error parsing message:', e);\n    }\n  }\n\n  sync() {\n    this.socket.send(JSON.stringify({\n      type: 'subscribe',\n      product_id: this.productID\n    }));\n  }\n\n  processMessage(message, t) {\n    if (message.type === 'snapshot') {\n      this.clear_book();\n      this.book.sequence = message.sequence;\n      for (let price in message.bids) {\n        this.book.bids[price] = message.bids[price];\n      }\n      for (let price in message.asks) {\n        this.book.asks[price] = message.asks[price];\n      }\n      this.emit('snapshot', this.book, t);\n    } else if (message.type === 'update') {\n      if (message.action === 'delete') {\n        delete this.book.bids[message.price];\n        delete this.book.asks[message.price];\n      } else if (message.action === 'add') {\n        this.book.bids[message.price] = message.size;\n        this.book.asks[message.price] = message.size;\n      } else if (message.action === 'update') {\n        this.book.bids[message.price] = message.size;\n        this.book.asks[message.price] = message.size;\n      }\n      this.book.sequence = message.sequence;\n      this.emit('update', this.book, t);\n    }\n  }\n}"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Channel {  \n  constructor(ws) {  \n    this._ws = ws;  \n    this._handler = null;  \n    this._messageListener = this._messageReceived.bind(this);  \n    this._ws.onmessage = this._messageListener;  \n  }  \n\n  send(message) {  \n    if (this._ws.readyState === WebSocket.OPEN) {  \n      this._ws.send(message);  \n    } else {  \n      console.warn('WebSocket not open, message not sent');  \n    }  \n  }  \n\n  close() {  \n    if (this._ws) {  \n      this._ws.close();  \n    }  \n  }  \n\n  listen(handler) {  \n    this._handler = handler;  \n  }  \n\n  dispose() {  \n    if (this._ws) {  \n      this._ws.onmessage = null;  \n      this._ws.close();  \n    }  \n  }  \n\n  _messageReceived(message) {  \n    if (this._handler) {  \n      this._handler(message.data);  \n    }  \n  }  \n}  \n\nclass NddService {  \n  constructor(frontend) {  \n    this._disconnectPromise = Promise.resolve();  \n    this._connected = new Set();  \n    this._frontend = frontend;  \n    this._pipe = '/tmp/debug_pipe';  \n    this._setupIPC();  \n  }  \n\n  _setupIPC() {  \n    const net = require('net');  \n    const server = net.createServer((socket) => {  \n      const sessionId = Math.random().toString(36).substring(2, 9);  \n      this._connected.add(sessionId);  \n      const channel = new Channel(socket);  \n      channel.listen((data) => {  \n        this._frontend.messageHandler(data, sessionId);  \n      });  \n      this._startSession({ id: sessionId, url: 'ws://localhost:8080' }, this._frontend)  \n        .then(() => {  \n          this._frontend.sessionCreated(sessionId);  \n        })  \n        .catch((err) => {  \n          console.error('Session start failed:', err);  \n        });  \n      socket.on('close', () => {  \n        this._connected.delete(sessionId);  \n        this._frontend.sessionClosed(sessionId);  \n      });  \n    });  \n    server.listen(this._pipe);  \n  }  \n\n  _startSession(info, frontend) {  \n    return new Promise((resolve, reject) => {  \n      const cleanup = async () => {  \n        try {  \n          await this._frontend.cleanupSession(info.id);  \n        } catch (err) {  \n          console.error('Cleanup failed:', err);  \n        }  \n      };  \n      resolve(cleanup);  \n    });  \n  }  \n}"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome's DevTools Protocol, handling connection, message exchange, and event emission.\n\nClass Description: The Chrome class extends EventEmitter to create a WebSocket client that connects to Chrome's DevTools Protocol. It manages WebSocket connections, handles message parsing, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- _notifier: [Object] - External notification handler\n- _callbacks: [Object] - Map of pending command callbacks\n- _nextCommandId: [Number] - Counter for generating command IDs\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- constructor: [constructor](options: Object, notifier: Object) -> [Chrome] - Initializes the Chrome instance with connection options and notifier\n- _connectToWebSocket: [_connectToWebSocket]() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleMessage: [_handleMessage](message: Object) -> [void] - Processes incoming WebSocket messages (responses and events)\n- _enqueueCommand: [_enqueueCommand](method: String, params: Object, sessionId: String, callback: Function) -> [void] - Sends a command through WebSocket and tracks its callback\n- send: [send](method: String, ...args: Any) -> [Promise|undefined] - Public method to send commands, supporting both callback and Promise patterns",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this._notifier = notifier;\n        this._callbacks = {};\n        this._nextCommandId = 1;\n        this.webSocketUrl = undefined;\n        this._start();\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n        \n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "const { EventEmitter } = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = options.secure || false;\n    this._notifier = notifier;\n    this._callbacks = {};\n    this._nextCommandId = 1;\n    this.webSocketUrl = `${this.secure ? 'wss' : 'ws'}://${this.host}:${this.port}/devtools/browser`;\n    this._ws = null;\n  }\n\n  async _connectToWebSocket() {\n    this._ws = new WebSocket(this.webSocketUrl);\n    this._ws.onopen = () => {\n      this.emit('connect');\n    };\n    this._ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      this._handleMessage(message);\n    };\n    this._ws.onerror = (error) => {\n      this.emit('error', error);\n    };\n    this._ws.onclose = () => {\n      this.emit('disconnect');\n    };\n    return new Promise((resolve, reject) => {\n      this._ws.onopen = () => resolve();\n    });\n  }\n\n  _handleMessage(message) {\n    if (message.method && message.params) {\n      const callback = this._callbacks[message.id];\n      if (callback) {\n        callback(null, message.params);\n        delete this._callbacks[message.id];\n      }\n    } else if (message.method && !message.params) {\n      this.emit(message.method, message.params);\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const id = this._nextCommandId++;\n    this._callbacks[id] = callback;\n    this._ws.send(JSON.stringify({\n      id,\n      method,\n      params,\n      sessionId\n    }));\n  }\n\n  send(method, ...args) {\n    const sessionId = args[args.length - 1] || '';\n    const callback = args[args.length - 2] || null;\n    if (callback) {\n      this._enqueueCommand(method, args.slice(0, -2), sessionId, callback);\n    } else {\n      return new Promise((resolve, reject) => {\n        this._enqueueCommand(method, args, sessionId, (err, result) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n        });\n      });\n    }\n  }\n}"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a WebSocket client class in Node.js that handles WebSocket connections, message transmission, and connection lifecycle events.\n\nClass Description: WebSocketImpl is a WebSocket client implementation that manages WebSocket connections, including establishing connections, handling incoming messages, managing connection states, and sending messages. It wraps the 'ws' library functionality with additional state management and event handling.\n\nAttributes:\n- _globalObject: [Object] - The global context in which the WebSocket operates\n- _ownerDocument: [Object] - The document associated with the WebSocket\n- _urlRecord: [Object|null] - URL information for the WebSocket connection\n- url: [String] - The WebSocket server URL\n- extensions: [String] - Supported WebSocket extensions\n- binaryType: [String] - Type of binary data handling (\"blob\" or \"arraybuffer\")\n- _ws: [Object|null] - The underlying WebSocket instance\n- _readyState: [Number] - Current connection state (0=CONNECTING, 1=OPEN, 2=CLOSING, 3=CLOSED)\n- _requiredToFail: [Boolean] - Flag indicating if the connection should fail\n- bufferedAmount: [Number] - Number of bytes of queued data\n- _sendQueue: [Array] - Queue of messages waiting to be sent\n- _dequeueScheduled: [Boolean] - Flag for send queue scheduling\n\nMethods:\n- constructor(globalObject, args, privateData) -> [void] - Initializes the WebSocket client with configuration and establishes connection\n- _onConnectionEstablished() -> [void] - Handles successful connection establishment\n- _onMessageReceived(data, isBinary) -> [void] - Processes incoming WebSocket messages\n- _onConnectionClosed(code, reason) -> [void] - Handles connection closure\n- close(code, reason) -> [void] - Closes the WebSocket connection with optional code and reason\n- send(data) -> [void] - Queues data for sending through the WebSocket\n- _actuallySend() -> [void] - Internal method that sends queued messages\n- _scheduleSend() -> [void] - Schedules message sending on the next event loop tick",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = privateData.document;\n    this._urlRecord = null;\n    this.url = \"\";\n    this.extensions = \"\";\n    this.binaryType = \"blob\";\n    this._ws = null;\n    this._readyState = 0; // CONNECTING\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    const url = args[0];\n    let protocols = args[1] !== undefined ? args[1] : [];\n\n    this._ws = new WebSocket(this.url, protocols, {\n      headers: {\n        \"user-agent\": globalObject.navigator.userAgent,\n        \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n        \"origin\": globalObject._origin\n      },\n      rejectUnauthorized: globalObject._resourceLoader._strictSSL\n    });\n\n    this._ws.once(\"open\", () => {\n      this._onConnectionEstablished();\n    });\n    this._ws.on(\"message\", this._onMessageReceived.bind(this));\n    this._ws.once(\"close\", (...closeArgs) => {\n      this._onConnectionClosed(...closeArgs);\n    });\n    this._ws.once(\"error\", () => {\n      this._requiredToFail = true;\n    });\n  }\n\n  _onConnectionEstablished() {\n    if (this._ws.extensions !== null) {\n      this.extensions = Object.keys(this._ws.extensions).join(\", \");\n    }\n    // fire open event\n  }\n\n  _onMessageReceived(data, isBinary) {\n    if (this.readyState !== 1) { // OPEN\n      return;\n    }\n    // process message data and fire message event\n  }\n\n  _onConnectionClosed(code, reason) {\n    // fire close event\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (this.readyState === 0) { // CONNECTING\n      this._requiredToFail = true;\n      if (this._ws !== null) {\n        this._ws.terminate();\n      } else {\n        this._readyState = 2; // CLOSING\n      }\n    } else if (this.readyState === 1) { // OPEN\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this.readyState === 0) { // CONNECTING\n      throw new Error(\"Still in CONNECTING state.\");\n    }\n    if (this.readyState !== 1) { // OPEN\n      return;\n    }\n    let length;\n    if (typeof data === \"string\") {\n      length = Buffer.byteLength(data, \"utf8\");\n    } else {\n      length = data.byteLength;\n    }\n    this.bufferedAmount += length;\n    this._sendQueue.push([data, length]);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    for (const [data, length] of this._sendQueue.splice(0)) {\n      this._ws.send(data, { binary: typeof data !== \"string\" }, () => {\n        this.bufferedAmount -= length;\n      });\n    }\n  }\n\n  _scheduleSend() {\n    if (this._dequeueScheduled) {\n      return;\n    }\n    this._dequeueScheduled = true;\n    process.nextTick(() => {\n      this._dequeueScheduled = false;\n      this._actuallySend();\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args[0];\n    this.extensions = args[1] || '';\n    this.binaryType = 'arraybuffer';\n    this._ws = null;\n    this._readyState = 0;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n\n    this._connect();\n  }\n\n  _connect() {\n    if (this._requiredToFail) {\n      this._onConnectionClosed(1001, 'Required to fail');\n      return;\n    }\n\n    const ws = require('ws');\n    this._ws = new ws(this.url, this.extensions);\n\n    this._ws.on('open', () => {\n      this._readyState = 1;\n      this._onConnectionEstablished();\n    });\n\n    this._ws.on('message', (data, isBinary) => {\n      this._onMessageReceived(data, isBinary);\n    });\n\n    this._ws.on('close', (code, reason) => {\n      this._readyState = 2;\n      this._onConnectionClosed(code, reason);\n    });\n\n    this._ws.on('error', (err) => {\n      this._readyState = 3;\n      this._onConnectionClosed(1006, 'Connection failed');\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = 1;\n    this._scheduleSend();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Handle incoming message\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = 3;\n    this._ws = null;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code || 1000, reason || '');\n    }\n  }\n\n  send(data) {\n    if (this._readyState === 1) {\n      this._sendQueue.push(data);\n      this._scheduleSend();\n    } else {\n      // Handle error or queue based on state\n    }\n  }\n\n  _actuallySend() {\n    if (this._sendQueue.length > 0 && this._readyState === 1) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data, (err) => {\n        if (err) {\n          // Handle send error\n        }\n        this.bufferedAmount -= data.length;\n        this._scheduleSend();\n      });\n    } else {\n      this._dequeueScheduled = false;\n    }\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled && this._readyState === 1) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => {\n        this._actuallySend();\n        this._dequeueScheduled = false;\n      });\n    }\n  }\n}"
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Create a WebSocket processor class that manages WebSocket connections and integrates with an HTTP server for handling real-time communication.\n\nClass Description: The Processor class extends EventEmitter to handle WebSocket connections over an HTTP server. It manages the server lifecycle, connection events, and data transmission between client and server.\n\nAttributes:\n- httpServer: [Object] - Instance of Node.js HTTP server used as base for WebSocket server\n- wsServer: [Object] - WebSocket server instance attached to the HTTP server\n- state: [Number] - Tracks the server state (ST_STARTED or ST_CLOSED)\n\nMethods:\n- constructor() -> [void] - Initializes the HTTP and WebSocket servers, sets up connection event handling\n- add(socket: [Object], data: [Buffer|String]) -> [void] - Processes incoming socket connection and data\n- close() -> [void] - Properly shuts down the WebSocket and HTTP servers",
    "Canonical_solution": "var HttpServer = require('http').Server;\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar WebSocketServer = require('ws').Server;\n\nvar ST_STARTED = 1;\nvar ST_CLOSED = 2;\n\nclass Processor extends EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = new HttpServer();\n    this.wsServer = new WebSocketServer({server: this.httpServer});\n    this.state = ST_STARTED;\n\n    this.wsServer.on('connection', (socket) => {\n      this.emit('connection', socket);\n    });\n  }\n\n  add(socket, data) {\n    if(this.state !== ST_STARTED) {\n      return;\n    }\n    this.httpServer.emit('connection', socket);\n    if(typeof socket.ondata === 'function') {\n      socket.ondata(data, 0, data.length);\n    } else {\n      socket.emit('data', data);\n    }\n  }\n\n  close() {\n    if(this.state !== ST_STARTED) {\n      return;\n    }\n    this.state = ST_CLOSED;\n    this.wsServer.close();\n    this.wsServer = null;\n    this.httpServer = null;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Processor extends require('events').EventEmitter {\n  constructor() {\n    super();\n    this.httpServer = require('http').createServer();\n    this.wsServer = require('ws').Server({ server: this.httpServer });\n    this.state = 0; // 0 for ST_STARTED, 1 for ST_CLOSED\n    this.wsServer.on('connection', (socket) => {\n      this.emit('connection', socket);\n    });\n    this.httpServer.on('request', (req, res) => {\n      this.emit('request', req, res);\n    });\n  }\n\n  add(socket, data) {\n    if (this.state === 1) return;\n    if (socket.readyState === socket.OPEN) {\n      socket.send(data);\n    } else {\n      socket.on('open', () => {\n        socket.send(data);\n      });\n    }\n  }\n\n  close() {\n    if (this.state === 1) return;\n    this.state = 1;\n    this.wsServer.close(() => {\n      this.httpServer.close();\n    });\n  }\n}"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Create a JavaScript class for interacting with the Cryptsy cryptocurrency exchange API, handling both public and private endpoints with proper authentication and request management.\n\nClass Description: The Cryptsy class provides a wrapper for the Cryptsy API, enabling users to make authenticated requests to private endpoints and public data requests. It handles API authentication, request signing, and response processing.\n\nAttributes:\n- key: string - API key for authentication\n- secret: string - API secret for request signing\n- PUBLIC_API_URL: string - Base URL for public API endpoints (default: 'http://pubapi.cryptsy.com/api.php')\n- PRIVATE_API_URL: string - Base URL for private API endpoints (default: 'https://api.cryptsy.com/api')\n- USER_AGENT: string - User agent string for requests (default: 'nomp/node-open-mining-portal')\n- STRICT_SSL: boolean - Static flag for SSL verification (default: true)\n\nMethods:\n- constructor(key, secret) -> Cryptsy - Initializes the API client with credentials\n- _getPrivateHeaders(parameters: object) -> object - Generates authentication headers for private requests\n- _request(options: object, callback: function) -> Cryptsy - Base request method with common configuration\n- _public(parameters: object, callback: function) -> Cryptsy - Makes public API requests\n- _private(parameters: object, callback: function) -> Cryptsy - Makes authenticated private API requests\n- getTicker(callback: function) -> Cryptsy - Gets market ticker data\n- getOrderBook(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets order book for a currency pair\n- getTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets public trade history\n- myBalances(callback: function) -> Cryptsy - Gets user's account balances\n- myOpenOrders(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's open orders\n- myTradeHistory(currencyA: string, currencyB: string, callback: function) -> Cryptsy - Gets user's trade history\n- buy(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a buy order\n- sell(currencyA: string, currencyB: string, rate: number, amount: number, callback: function) -> Cryptsy - Places a sell order\n- cancelOrder(currencyA: string, currencyB: string, orderNumber: string, callback: function) -> Cryptsy - Cancels an order\n- withdraw(currency: string, amount: number, address: string, callback: function) -> Cryptsy - Withdraws funds\n- _joinCurrencies(currencyA: string, currencyB: string) -> string - Helper to format currency pairs",
    "Canonical_solution": "var request = require('request');\nvar nonce = require('nonce');\nvar crypto = require('crypto');\n\nclass Cryptsy {\n    constructor(key, secret) {\n        this.key = key;\n        this.secret = secret;\n        this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n        this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n        this.USER_AGENT = 'nomp/node-open-mining-portal';\n    }\n\n    static STRICT_SSL = true;\n\n    _getPrivateHeaders(parameters) {\n        if (!this.key || !this.secret) {\n            throw 'Cryptsy: Error. API key and secret required';\n        }\n\n        let paramString = Object.keys(parameters).sort().map(function(param) {\n            return encodeURIComponent(param) + '=' + encodeURIComponent(parameters[param]);\n        }).join('&');\n\n        let signature = crypto.createHmac('sha512', this.secret).update(paramString).digest('hex');\n\n        return {\n            Key: this.key,\n            Sign: signature\n        };\n    }\n\n    _request(options, callback) {\n        if (!('headers' in options)) {\n            options.headers = {};\n        }\n\n        options.headers['User-Agent'] = this.USER_AGENT;\n        options.json = true;\n        options.strictSSL = Cryptsy.STRICT_SSL;\n\n        request(options, function(err, response, body) {\n            callback(err, body);\n        });\n\n        return this;\n    }\n\n    _public(parameters, callback) {\n        let options = {\n            method: 'GET',\n            url: this.PUBLIC_API_URL,\n            qs: parameters\n        };\n\n        return this._request(options, callback);\n    }\n\n    _private(parameters, callback) {\n        parameters.nonce = nonce();\n        let options = {\n            method: 'POST',\n            url: this.PRIVATE_API_URL,\n            form: parameters,\n            headers: this._getPrivateHeaders(parameters)\n        };\n\n        return this._request(options, callback);\n    }\n\n    getTicker(callback) {\n        let parameters = {\n            method: 'marketdatav2'\n        };\n        return this._public(parameters, callback);\n    }\n\n    getOrderBook(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOrderBook',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    getTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._public(parameters, callback);\n    }\n\n    myBalances(callback) {\n        let parameters = {\n            command: 'returnBalances'\n        };\n        return this._private(parameters, callback);\n    }\n\n    myOpenOrders(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnOpenOrders',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    myTradeHistory(currencyA, currencyB, callback) {\n        let parameters = {\n            command: 'returnTradeHistory',\n            currencyPair: this._joinCurrencies(currencyA, currencyB)\n        };\n        return this._private(parameters, callback);\n    }\n\n    buy(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'buy',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    sell(currencyA, currencyB, rate, amount, callback) {\n        let parameters = {\n            command: 'sell',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            rate: rate,\n            amount: amount\n        };\n        return this._private(parameters, callback);\n    }\n\n    cancelOrder(currencyA, currencyB, orderNumber, callback) {\n        let parameters = {\n            command: 'cancelOrder',\n            currencyPair: this._joinCurrencies(currencyA, currencyB),\n            orderNumber: orderNumber\n        };\n        return this._private(parameters, callback);\n    }\n\n    withdraw(currency, amount, address, callback) {\n        let parameters = {\n            command: 'withdraw',\n            currency: currency,\n            amount: amount,\n            address: address\n        };\n        return this._private(parameters, callback);\n    }\n\n    _joinCurrencies(currencyA, currencyB) {\n        return currencyA + '_' + currencyB;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class Cryptsy {\n  constructor(key, secret) {\n    this.key = key;\n    this.secret = secret;\n    this.PUBLIC_API_URL = 'http://pubapi.cryptsy.com/api.php';\n    this.PRIVATE_API_URL = 'https://api.cryptsy.com/api';\n    this.USER_AGENT = 'nomp/node-open-mining-portal';\n    this.STRICT_SSL = true;\n  }\n\n  _getPrivateHeaders(parameters) {\n    const { key, secret } = this;\n    const data = {\n      method: 'POST',\n      parameters: parameters,\n      key: key\n    };\n    const dataStr = JSON.stringify(data);\n    const hmac = crypto.createHmac('sha256', secret).update(dataStr).digest('hex');\n    return {\n      'Content-Type': 'application/json',\n      'X-Cryptsy-Key': key,\n      'X-Cryptsy-Signature': hmac\n    };\n  }\n\n  _request(options, callback) {\n    const { PUBLIC_API_URL, PRIVATE_API_URL, USER_AGENT, STRICT_SSL } = this;\n    const { method, url, headers, body } = options;\n    const requestUrl = url.startsWith('http') ? url : (method === 'GET' ? `${url}?${body}` : url);\n\n    const req = https.request({\n      method: method,\n      hostname: requestUrl.split('/')[2],\n      path: requestUrl.split('/').slice(3).join('/'),\n      headers: headers || {},\n      agent: new https.Agent({ rejectUnauthorized: STRICT_SSL })\n    }, res => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          const result = JSON.parse(data);\n          if (result.success === false) {\n            return callback(new Error(result.message));\n          }\n          callback(null, result);\n        } catch (e) {\n          callback(e);\n        }\n      });\n    });\n\n    req.on('error', e => callback(e));\n    if (body) req.write(body);\n    req.end();\n  }\n\n  _public(parameters, callback) {\n    const { PUBLIC_API_URL } = this;\n    const query = Object.entries(parameters)\n      .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n      .join('&');\n    const options = {\n      method: 'GET',\n      url: `${PUBLIC_API_URL}?${query}`,\n      headers: { 'User-Agent': this.USER_AGENT }\n    };\n    this._request(options, callback);\n  }\n\n  _private(parameters, callback) {\n    const { PRIVATE_API_URL } = this;\n    const data = {\n      method: 'POST',\n      parameters: parameters\n    };\n    const dataStr = JSON.stringify(data);\n    const headers = this._getPrivateHeaders(data);\n    const options = {\n      method: 'POST',\n      url: PRIVATE_API_URL,\n      headers: headers,\n      body: dataStr\n    };\n    this._request(options, callback);\n  }\n\n  getTicker(callback) {\n    this._public({ command: 'getticker' }, callback);\n  }\n\n  getOrderBook(currencyA, currencyB, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._public({ command: 'getorderbook', currencypair: pair }, callback);\n  }\n\n  getTradeHistory(currencyA, currencyB, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._public({ command: 'gettradehistory', currencypair: pair }, callback);\n  }\n\n  myBalances(callback) {\n    this._private({ command: 'mybalances' }, callback);\n  }\n\n  myOpenOrders(currencyA, currencyB, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'myopenorders', currencypair: pair }, callback);\n  }\n\n  myTradeHistory(currencyA, currencyB, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'mytradehistory', currencypair: pair }, callback);\n  }\n\n  buy(currencyA, currencyB, rate, amount, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'buy', currencypair: pair, rate: rate, amount: amount }, callback);\n  }\n\n  sell(currencyA, currencyB, rate, amount, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'sell', currencypair: pair, rate: rate, amount: amount }, callback);\n  }\n\n  cancelOrder(currencyA, currencyB, orderNumber, callback) {\n    const pair = this._joinCurrencies(currencyA, currencyB);\n    this._private({ command: 'cancelorder', currencypair: pair, ordernumber: orderNumber }, callback);\n  }\n\n  withdraw(currency, amount, address, callback) {\n    this._private({ command: 'withdraw', currency: currency, amount: amount, address: address }, callback);\n  }\n\n  _joinCurrencies(currencyA, currencyB) {\n    return `${currencyA}${currencyB}`;\n  }\n}"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a class that handles the downloading and installation of binary packages from a specified URL, including directory management and error handling.\n\nClass Description: The Binary class is responsible for downloading a binary package from a given URL, extracting it to a specified directory, and managing the installation process. It handles directory creation, file extraction, and provides feedback on the installation status.\n\nAttributes:\n- url: [String] - The URL from which the binary package will be downloaded.\n- name: [String] - The name of the binary package (optional, defaults to -1).\n- installDirectory: [String] - The base directory where the binary will be installed (optional, defaults to a 'bin' subdirectory in the current working directory).\n- binaryDirectory: [String] - The full path to the directory where the binary will be extracted (initialized as -1, set during installation).\n- binaryPath: [String] - The full path to the binary file (initialized as -1, not used in current implementation).\n\nMethods:\n- constructor(url, data) -> [None] - Initializes the Binary instance with the download URL and optional configuration data (name and installDirectory).\n- install() -> [Promise] - Handles the complete installation process including directory preparation, downloading, extraction, and cleanup. Returns a Promise that resolves when installation is complete or rejects on error.\n  - Internal method _getInstallDirectory() is used to determine the installation directory path.",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass Binary {\n    constructor(url, data) {\n        this.url = url;\n        this.name = data.name || -1;\n        this.installDirectory = data.installDirectory || join(__dirname, \"bin\");\n        this.binaryDirectory = -1;\n        this.binaryPath = -1;\n    }\n\n    install() {\n        const dir = this._getInstallDirectory();\n        if (!existsSync(dir)) {\n            mkdirSync(dir, { recursive: true });\n        }\n\n        this.binaryDirectory = join(dir, \"bin\");\n\n        if (existsSync(this.binaryDirectory)) {\n            rimraf.sync(this.binaryDirectory);\n        }\n\n        mkdirSync(this.binaryDirectory, { recursive: true });\n\n        console.log(`Downloading release from ${this.url}`);\n\n        return axios({ url: this.url, responseType: \"stream\" })\n            .then(res => {\n                const writer = tar.x({ strip: 1, C: this.binaryDirectory });\n\n                return new Promise((resolve, reject) => {\n                    res.data.pipe(writer);\n                    let error = null;\n                    writer.on('error', err => {\n                      error = err;\n                      reject(err);\n                    });\n                    writer.on('close', () => {\n                      if (!error) {\n                        resolve(true);\n                      }\n                    });\n                })\n            })\n            .then(() => {\n                console.log(\n                    `${this.name ? this.name : \"Your package\"} has been installed!`\n                );\n            })\n            .catch(e => {\n                error(`Error fetching release: ${e.message}`);\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function Binary(url, data = {}) {\n  this.url = url;\n  this.name = data.name || '-1';\n  this.installDirectory = data.installDirectory || path.join(process.cwd(), 'bin');\n  this.binaryDirectory = '-1';\n  this.binaryPath = '-1';\n\n  this._getInstallDirectory = () => {\n    const dir = path.resolve(this.installDirectory);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n    return dir;\n  };\n}\n\nBinary.prototype.install = async function() {\n  try {\n    const installDir = this._getInstallDirectory();\n    const tempDir = path.join(installDir, 'temp');\n    if (fs.existsSync(tempDir)) {\n      fs.rmSync(tempDir, { recursive: true, force: true });\n    }\n    fs.mkdirSync(tempDir);\n\n    const response = await fetch(this.url);\n    if (!response.ok) {\n      throw new Error(`Failed to download binary: ${response.statusText}`);\n    }\n\n    const filePath = path.join(tempDir, 'package.tar.gz');\n    const fileStream = fs.createWriteStream(filePath);\n    await new Promise((resolve, reject) => {\n      response.body.pipe(fileStream)\n        .on('finish', resolve)\n        .on('error', reject);\n    });\n\n    const tar = await import('tar-stream');\n    const extract = tar.extract();\n    const readStream = fs.createReadStream(filePath);\n    extract.on('entry', (header, stream, next) => {\n      const targetPath = path.join(installDir, header.name);\n      if (header.type === 'directory') {\n        fs.mkdirSync(targetPath, { recursive: true });\n      } else {\n        fs.writeFileSync(targetPath, '');\n        stream.pipe(fs.createWriteStream(targetPath));\n      }\n      next();\n    });\n    readStream.pipe(extract);\n\n    await new Promise(resolve => extract.on('end', resolve));\n\n    this.binaryDirectory = installDir;\n    this.binaryPath = path.join(installDir, 'binary');\n    fs.renameSync(path.join(installDir, 'binary'), this.binaryPath);\n\n    fs.rmdirSync(tempDir, { recursive: true });\n    return this.binaryPath;\n  } catch (error) {\n    console.error('Installation failed:', error.message);\n    throw error;\n  }\n};"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "testWebSocketConnection = (wssUrl) => {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n  \n  ws.onopen = () => {\n    console.log('WebSocket connection established');\n    const initialMessage = { type: 'initial', payload: 'Hello from client' };\n    ws.send(JSON.stringify(initialMessage));\n  };\n  \n  ws.onmessage = (event) => {\n    const message = JSON.parse(event.data);\n    console.log('Received message:', message);\n  };\n  \n  ws.onclose = (event) => {\n    console.log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);\n  };\n  \n  ws.onerror = (error) => {\n    console.error('WebSocket error observed:', error);\n  };\n};"
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript using Node.js that establishes a connection to a WebSocket server, handles incoming messages, and manages connection events.\n\nClass Description: The WebSocketImpl class provides a wrapper around the Node.js 'ws' library to create and manage WebSocket connections. It handles connection establishment, message reception, error handling, and connection closure events. The class also provides methods for sending data and closing the connection.\n\nAttributes:\n- _globalObject: [Object] - The global context in which the WebSocket operates\n- _ownerDocument: [Object] - The document object associated with the WebSocket\n- _urlRecord: [Object] - Parsed URL information for the WebSocket connection\n- url: [String] - The WebSocket server URL as a string\n- _ws: [WebSocket|null] - The underlying WebSocket instance or null if not connected\n- _readyState: [Number] - Current connection state (0 = CONNECTING)\n- _requiredToFail: [Boolean] - Flag indicating if the connection should fail\n- bufferedAmount: [Number] - Amount of buffered data in bytes\n- _sendQueue: [Array] - Queue of messages waiting to be sent\n\nMethods:\n- constructor(globalObject, args, privateData) -> [void] - Initializes the WebSocket connection with the given parameters and sets up event handlers\n- _onConnectionEstablished() -> [void] - Internal method called when the WebSocket connection is successfully established\n- _onMessageReceived(data, isBinary) -> [void] - Internal method called when a message is received from the server\n- _onConnectionClosed(code, reason) -> [void] - Internal method called when the WebSocket connection is closed\n- close(code, reason) -> [void] - Closes the WebSocket connection with optional code and reason\n- send(data) -> [void] - Sends data through the WebSocket connection (supports strings and Blob objects)\n- get readyState() -> [Number] - Returns the current ready state of the WebSocket connection",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = idlUtils.implForWrapper(globalObject._document);\n    this._urlRecord = parseURL(args[0]);\n    this.url = serializeURL(this._urlRecord);\n    this._ws = null;\n    this._readyState = 0; // CONNECTING\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    const protocols = typeof args[1] === \"string\" ? [args[1]] : (args[1] || []);\n    const nodeParsedURL = nodeURL.parse(this.url);\n\n    this._ws = new WebSocket(this.url, protocols, {\n      headers: {\n        \"user-agent\": globalObject.navigator.userAgent,\n        \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n        \"origin\": globalObject._origin\n      },\n      rejectUnauthorized: globalObject._resourceLoader._strictSSL\n    });\n\n    this._ws.once(\"open\", () => {\n      this._onConnectionEstablished();\n    });\n    this._ws.on(\"message\", this._onMessageReceived.bind(this));\n    this._ws.once(\"close\", (...closeArgs) => {\n      this._onConnectionClosed(...closeArgs);\n    });\n    this._ws.once(\"error\", () => {\n      this._requiredToFail = true;\n    });\n  }\n\n  _onConnectionEstablished() {\n    fireAnEvent(\"open\", this);\n  }\n\n  _onMessageReceived(data, isBinary) {\n    let dataForEvent;\n    if (!isBinary) {\n      dataForEvent = data.toString();\n    } else if (this.binaryType === \"arraybuffer\") {\n      dataForEvent = copyToArrayBufferInNewRealm(data, this._globalObject);\n    } else {\n      dataForEvent = Blob.create(this._globalObject, [[data], { type: \"\" }]);\n    }\n    fireAnEvent(\"message\", this, MessageEvent, {\n      data: dataForEvent,\n      origin: serializeURLOrigin(this._urlRecord)\n    });\n  }\n\n  _onConnectionClosed(code, reason) {\n    fireAnEvent(\"close\", this, CloseEvent, {\n      wasClean: !this._requiredToFail,\n      code,\n      reason: reason.toString()\n    });\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._ws.readyState === WebSocket.OPEN) {\n      if (Blob.isImpl(data)) {\n        data = data._buffer;\n      }\n      this._ws.send(data, { binary: typeof data !== \"string\" });\n    }\n  }\n\n  get readyState() {\n    return this._ws ? this._ws.readyState : this._readyState;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = null;\n    this._urlRecord = null;\n    this.url = args[0];\n    this._ws = null;\n    this._readyState = 0;\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._setupWebSocket();\n  }\n\n  _setupWebSocket() {\n    const parsedUrl = new URL(this.url);\n    this._urlRecord = parsedUrl;\n    this._ws = new require('ws').WebSocket(parsedUrl.href);\n    this._ws.on('open', this._onConnectionEstablished.bind(this));\n    this._ws.on('message', (data, isBinary) => this._onMessageReceived(data, isBinary));\n    this._ws.on('close', (code, reason) => this._onConnectionClosed(code, reason));\n    this._ws.on('error', (err) => {\n      if (!this._requiredToFail) {\n        this._onConnectionClosed(1006, 'Unexpected server error');\n      }\n    });\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = 1;\n    this._processSendQueue();\n  }\n\n  _onMessageReceived(data, isBinary) {\n    // Simulate event dispatching\n    const event = {\n      data: data,\n      type: isBinary ? 'binary' : 'text'\n    };\n    // Dispatch to appropriate handlers\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = 2;\n    this._ws = null;\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code || 1000, reason || '');\n    }\n  }\n\n  send(data) {\n    if (this._ws && this._readyState === 1) {\n      this._sendQueue.push(data);\n      this._processSendQueue();\n    } else {\n      this._sendQueue.push(data);\n    }\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  _processSendQueue() {\n    while (this._sendQueue.length > 0) {\n      const message = this._sendQueue[0];\n      if (typeof message === 'string') {\n        this._ws.send(message);\n      } else if (message instanceof Buffer) {\n        this._ws.send(message);\n      } else {\n        // Handle Blob or other types if needed\n      }\n      this._sendQueue.shift();\n      this.bufferedAmount -= message.length;\n    }\n  }\n}"
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Implement a ReconnectingWebSocket class in JavaScript that provides a WebSocket client with automatic reconnection capabilities, customizable reconnection strategies, and event handling for connection states, messages, and errors.\n\nClass Description: The ReconnectingWebSocket class extends basic WebSocket functionality by automatically reconnecting when the connection is lost, with configurable reconnection intervals and exponential backoff. It provides event handlers for connection states (open, close, connecting), message reception, and errors.\n\nAttributes:\n- debug: Boolean - Enables debug logging when true\n- automaticOpen: Boolean - Automatically opens connection when instantiated if true\n- reconnectInterval: Number - Initial delay before reconnection attempt (ms)\n- maxReconnectInterval: Number - Maximum delay between reconnection attempts (ms)\n- reconnectDecay: Number - Multiplier for increasing reconnect delay\n- timeoutInterval: Number - Connection timeout duration (ms)\n- url: String - WebSocket server URL\n- reconnectAttempts: Number - Count of reconnection attempts\n- readyState: Number - Current connection state (matching WebSocket constants)\n- protocol: String|null - Selected subprotocol\n\nMethods:\n- constructor(url, protocols, options) -> ReconnectingWebSocket - Initializes the WebSocket connection with specified URL, optional subprotocols, and configuration options\n- addEventListener(type, listener) -> void - Adds event listener for WebSocket events\n- removeEventListener(type, listener) -> void - Removes event listener\n- dispatchEvent(event) -> void - Dispatches custom event\n- open(wasReconnect) -> void - Opens WebSocket connection (internal use)\n- send(data) -> void - Sends data through WebSocket connection\n- close(code, reason) -> void - Closes WebSocket connection and stops reconnection attempts\n- refresh() -> void - Forces reconnection by closing current connection\n- createEvent(eventName, detail) -> CustomEvent - Creates custom event object\n- onopen(event) -> void - Placeholder for open event handler\n- onclose(event) -> void - Placeholder for close event handler\n- onconnecting(event) -> void - Placeholder for connecting event handler\n- onmessage(event) -> void - Placeholder for message event handler\n- onerror(event) -> void - Placeholder for error event handler",
    "Canonical_solution": "class ReconnectingWebSocket {\n    constructor(url, protocols, options) {\n        this.debug = false;\n        this.automaticOpen = true;\n        this.reconnectInterval = 1000;\n        this.maxReconnectInterval = 30000;\n        this.reconnectDecay = 1.5;\n        this.timeoutInterval = 2000;\n        \n        if (options) {\n            for (var key in options) {\n                this[key] = options[key];\n            }\n        }\n        \n        this.url = url;\n        this.reconnectAttempts = 0;\n        this.readyState = WebSocket.CONNECTING;\n        this.protocol = null;\n        \n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n        \n        eventTarget.addEventListener('open', (event) => { this.onopen(event); });\n        eventTarget.addEventListener('close', (event) => { this.onclose(event); });\n        eventTarget.addEventListener('connecting', (event) => { this.onconnecting(event); });\n        eventTarget.addEventListener('message', (event) => { this.onmessage(event); });\n        eventTarget.addEventListener('error', (event) => { this.onerror(event); });\n        \n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n        \n        this.open = function(wasReconnect) {\n            var ws = new WebSocket(this.url, protocols || []);\n            if (!wasReconnect) {\n                eventTarget.dispatchEvent(this.createEvent('connecting'));\n            }\n            \n            var timeout = setTimeout(() => {\n                timedOut = true;\n                ws.close();\n                timedOut = false;\n            }, this.timeoutInterval);\n            \n            ws.onopen = () => {\n                clearTimeout(timeout);\n                this.protocol = ws.protocol;\n                this.readyState = WebSocket.OPEN;\n                this.reconnectAttempts = 0;\n                var event = this.createEvent('open');\n                event.isReconnect = wasReconnect;\n                wasReconnect = false;\n                eventTarget.dispatchEvent(event);\n            };\n            \n            ws.onclose = (event) => {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    this.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(this.createEvent('close'));\n                } else {\n                    this.readyState = WebSocket.CONNECTING;\n                    var connectingEvent = this.createEvent('connecting');\n                    connectingEvent.code = event.code;\n                    connectingEvent.reason = event.reason;\n                    connectingEvent.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(connectingEvent);\n                    \n                    if (!wasReconnect && !timedOut) {\n                        eventTarget.dispatchEvent(this.createEvent('close'));\n                    }\n                    \n                    var reconnectTimeout = this.reconnectInterval * Math.pow(this.reconnectDecay, this.reconnectAttempts);\n                    setTimeout(() => {\n                        this.reconnectAttempts++;\n                        this.open(true);\n                    }, Math.min(reconnectTimeout, this.maxReconnectInterval));\n                }\n            };\n            \n            ws.onmessage = (event) => {\n                var messageEvent = this.createEvent('message');\n                messageEvent.data = event.data;\n                eventTarget.dispatchEvent(messageEvent);\n            };\n            \n            ws.onerror = (event) => {\n                eventTarget.dispatchEvent(this.createEvent('error'));\n            };\n        };\n        \n        if (this.automaticOpen) {\n            this.open(false);\n        }\n        \n        this.send = function(data) {\n            if (ws) {\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n        \n        this.close = function(code, reason) {\n            forcedClose = true;\n            if (ws) {\n                ws.close(code || 1000, reason);\n            }\n        };\n        \n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n    \n    createEvent(eventName, detail) {\n        var event = document.createEvent('CustomEvent');\n        event.initCustomEvent(eventName, false, false, detail);\n        return event;\n    }\n    \n    onopen(event) {}\n    onclose(event) {}\n    onconnecting(event) {}\n    onmessage(event) {}\n    onerror(event) {}\n}\n\nReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\nReconnectingWebSocket.OPEN = WebSocket.OPEN;\nReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\nReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\nReconnectingWebSocket.debugAll = false;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class ReconnectingWebSocket extends WebSocket {\n  constructor(url, protocols, options = {}) {\n    this.debug = options.debug || false;\n    this.automaticOpen = options.automaticOpen || true;\n    this.reconnectInterval = options.reconnectInterval || 1000;\n    this.maxReconnectInterval = options.maxReconnectInterval || 30000;\n    this.reconnectDecay = options.reconnectDecay || 1.5;\n    this.timeoutInterval = options.timeoutInterval || 5000;\n    this.url = url;\n    this.reconnectAttempts = 0;\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = null;\n    this._listeners = {\n      open: [],\n      close: [],\n      connecting: [],\n      message: [],\n      error: []\n    };\n    this._reconnectTimer = null;\n    this._reconnectAttempts = 0;\n    super(url, protocols);\n    if (this.automaticOpen) {\n      this.open(true);\n    }\n  }\n\n  addEventListener(type, listener) {\n    if (this._listeners[type]) {\n      this._listeners[type].push(listener);\n    }\n  }\n\n  removeEventListener(type, listener) {\n    if (this._listeners[type]) {\n      const index = this._listeners[type].indexOf(listener);\n      if (index !== -1) {\n        this._listeners[type].splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this._listeners[event.type]) {\n      this._listeners[event.type].forEach(listener => listener(event));\n    }\n  }\n\n  open(wasReconnect) {\n    if (this.readyState === WebSocket.CLOSED || this.readyState === WebSocket.CLOSING) {\n      this._reconnectAttempts = 0;\n      this._reconnectTimer = null;\n      this._startReconnect(wasReconnect);\n    } else {\n      this._startReconnect(wasReconnect);\n    }\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      super.send(data);\n    } else {\n      this.dispatchEvent(new CustomEvent('error', { detail: 'WebSocket not open' }));\n    }\n  }\n\n  close(code, reason) {\n    if (this.readyState === WebSocket.OPEN || this.readyState === WebSocket.CONNECTING) {\n      super.close(code, reason);\n      this._reconnectTimer = null;\n      this._reconnectAttempts = 0;\n    }\n  }\n\n  refresh() {\n    this.close();\n    this.open(true);\n  }\n\n  createEvent(eventName, detail) {\n    return new CustomEvent(eventName, { detail });\n  }\n\n  onopen(event) {\n    this.readyState = WebSocket.OPEN;\n    this.dispatchEvent(new CustomEvent('open', { detail: event }));\n    this._reconnectAttempts = 0;\n    this._reconnectTimer = null;\n  }\n\n  onclose(event) {\n    this.readyState = WebSocket.CLOSED;\n    this.dispatchEvent(new CustomEvent('close', { detail: event }));\n    if (this._reconnectTimer) {\n      clearTimeout(this._reconnectTimer);\n    }\n    this._startReconnect(false);\n  }\n\n  onconnecting(event) {\n    this.readyState = WebSocket.CONNECTING;\n    this.dispatchEvent(new CustomEvent('connecting', { detail: event }));\n  }\n\n  onmessage(event) {\n    this.dispatchEvent(new CustomEvent('message', { detail: event }));\n  }\n\n  onerror(event) {\n    this.dispatchEvent(new CustomEvent('error', { detail: event }));\n    if (this._reconnectTimer) {\n      clearTimeout(this._reconnectTimer);\n    }\n    this._startReconnect(false);\n  }\n\n  _startReconnect(wasReconnect) {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    const timeout = setTimeout(() => {\n      this._reconnectAttempts++;\n      if (this._reconnectAttempts > 5) {\n        this._reconnectAttempts = 0;\n        return;\n      }\n      const delay = Math.min(this.reconnectInterval * Math.pow(this.reconnectDecay, this._reconnectAttempts), this.maxReconnectInterval);\n      this._reconnectTimer = setTimeout(() => {\n        this.open(wasReconnect);\n      }, delay);\n    }, this.timeoutInterval);\n  }\n}"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Implement a WebSocket transport class for establishing and managing WebSocket connections in a browser or Node.js environment, supporting both binary and text data transmission with configurable options.\n\nClass Description: The WS class extends a base Transport class to provide WebSocket-specific functionality. It handles connection establishment, message transmission, error handling, and connection cleanup, with support for various WebSocket options like binary data, compression, and security settings.\n\nAttributes:\n- supportsBinary: Boolean - Indicates whether the connection supports binary data transmission\n- perMessageDeflate: Object - Configuration for message compression\n- ws: WebSocket - The underlying WebSocket connection instance\n- writable: Boolean - Indicates if the connection is ready to send data\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the WebSocket transport with configuration options\n- doOpen() -> void - Establishes the WebSocket connection and sets up event listeners\n- addEventListeners() -> void - Attaches event handlers for connection events (open, close, message, error)\n- write(packets: Array) -> void - Encodes and sends multiple packets through the WebSocket connection\n- onClose() -> void - Handles connection closure and cleans up resources\n- doClose() -> void - Explicitly closes the WebSocket connection\n- uri() -> String - Generates the WebSocket connection URI with query parameters\n- check() -> Boolean - Verifies WebSocket availability and compatibility\n\nInput:\n- opts: Object - Configuration options including:\n  - forceBase64: Boolean - Forces base64 encoding if binary not supported\n  - perMessageDeflate: Object - Compression settings\n  - agent: Object - Custom HTTP agent\n  - pfx: String - SSL PFX certificate\n  - key: String - SSL key\n  - passphrase: String - SSL passphrase\n  - cert: String - SSL certificate\n  - ca: Array - SSL certificate authorities\n  - ciphers: String - SSL cipher suite\n  - rejectUnauthorized: Boolean - SSL verification setting\n  - extraHeaders: Object - Additional HTTP headers\n  - secure: Boolean - Use secure protocol (wss)\n  - port: Number - Custom port number\n  - timestampRequests: Boolean - Add timestamp to requests\n  - timestampParam: String - Parameter name for timestamp\n  - hostname: String - Server hostname\n  - path: String - WebSocket endpoint path\n  - query: Object - Additional query parameters\n\nOutput:\n- Instance of WS class with established WebSocket connection and configured event handlers",
    "Canonical_solution": "var Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  try {\n    WebSocket = require('ws');\n  } catch (e) { }\n}\n\nfunction WS(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  Transport.call(this, opts);\n}\n\ninherit(WS, Transport);\n\nWS.prototype.name = 'websocket';\nWS.prototype.supportsBinary = true;\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    return;\n  }\n\n  var self = this;\n  var uri = this.uri();\n  var protocols = void(0);\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n\n  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'buffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\nWS.prototype.addEventListeners = function(){\n  var self = this;\n\n  this.ws.onopen = function(){\n    self.onOpen();\n  };\n  this.ws.onclose = function(){\n    self.onClose();\n  };\n  this.ws.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function(packet) {\n      parser.encodePacket(packet, self.supportsBinary, function(data) {\n        if (!BrowserWebSocket) {\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        try {\n          if (BrowserWebSocket) {\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e){\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done(){\n    self.emit('flush');\n    setTimeout(function(){\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\nWS.prototype.onClose = function(){\n  Transport.prototype.onClose.call(this);\n};\n\nWS.prototype.doClose = function(){\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\nWS.prototype.check = function(){\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class WS extends Transport {\n  constructor(opts) {\n    super();\n    this.supportsBinary = opts.forceBase64 ? false : true;\n    this.perMessageDeflate = opts.perMessageDeflate || {};\n    this.ws = null;\n    this.writable = false;\n    this.opts = opts;\n  }\n\n  doOpen() {\n    const { secure, hostname, port, path, query } = this.opts;\n    const protocol = secure ? 'wss' : 'ws';\n    const uri = this.uri();\n    this.ws = new WebSocket(uri);\n    this.addEventListeners();\n  }\n\n  addEventListeners() {\n    this.ws.addEventListener('open', () => {\n      this.writable = true;\n      this.emit('open');\n    });\n\n    this.ws.addEventListener('close', () => {\n      this.writable = false;\n      this.emit('close');\n      this.onClose();\n    });\n\n    this.ws.addEventListener('message', (event) => {\n      this.emit('message', event.data);\n    });\n\n    this.ws.addEventListener('error', (err) => {\n      this.emit('error', err);\n    });\n  }\n\n  write(packets) {\n    if (!this.writable) return;\n    packets.forEach(packet => {\n      if (this.supportsBinary && Buffer.isBuffer(packet)) {\n        this.ws.send(packet);\n      } else {\n        this.ws.send(JSON.stringify(packet));\n      }\n    });\n  }\n\n  onClose() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  doClose() {\n    if (this.ws) {\n      this.ws.close();\n    }\n  }\n\n  uri() {\n    const { secure, hostname, port, path, query } = this.opts;\n    let url = `${secure ? 'wss' : 'ws'}://${hostname}`;\n    if (port !== 80 && port !== 443) {\n      url += `:${port}`;\n    }\n    if (path) {\n      url += path;\n    }\n    if (query) {\n      url += '?' + new URLSearchParams(query).toString();\n    }\n    return url;\n  }\n\n  check() {\n    return typeof WebSocket !== 'undefined';\n  }\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using HTTP POST request with error handling.\n\nFunction Description: The function `sendWebhook` is an asynchronous function that takes data as input and sends it to a predefined webhook URL using an HTTP POST request. It handles potential errors during the request and logs them to the console.\n\nInput: \n- `data` [Object] - The payload/data to be sent to the webhook URL.\n\nOutput: \n- None (The function does not return any value, but it may log errors to the console if the request fails).",
    "Canonical_solution": "const axios = require('axios');\n\nconst sendWebhook = async (data) => {\n    try {\n        await axios.post(process.env.UPDATE_WEBHOOK, data);\n    } catch (err) {\n        console.log(err);\n    }\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function sendWebhook(data) {\n  const webhookUrl = 'https://example.com/webhook';\n  try {\n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Failed to send webhook:', error);\n  }\n}"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that handles WebSocket connections, message processing, and connection lifecycle events. The class should support sending and receiving JSON messages, handling different commands, and managing connection states.\n\nClass Description: The `Client` class represents a WebSocket client that connects to a server, processes incoming messages, and sends commands. It handles connection events, message parsing, and provides methods for common operations like sending hello messages and triggering reloads.\n\nAttributes:\n- `ws`: [WebSocket] - The WebSocket connection instance.\n- `options`: [Object] - Configuration options for the client.\n- `id`: [String] - Unique identifier for the client instance.\n- `plugins`: [Array] - List of plugins received from the server.\n- `url`: [String] - URL received from the server.\n\nMethods:\n- `constructor(req, socket, head, options)` -> [Client] - Initializes a new WebSocket client instance with the given request, socket, head, and options.\n- `message(event)` -> [void] - Handles incoming WebSocket messages, parses them, and routes to appropriate command handlers.\n- `close(event)` -> [void] - Closes the WebSocket connection and emits an 'end' event.\n- `hello()` -> [void] - Sends a 'hello' command to the server with supported protocols and server name.\n- `info(data)` -> [void] - Processes 'info' command data from the server, storing plugins and URL.\n- `reload(files)` -> [void] - Sends 'reload' commands for each file in the provided list, with live reload options.\n- `_data(event)` -> [Object] - Parses incoming message data from JSON string to object.\n- `send(data)` -> [void] - Sends data as a JSON string over the WebSocket connection.\n- `uniqueId(prefix)` -> [String] - Generates a unique ID with an optional prefix.",
    "Canonical_solution": "var WebSocket = require('faye-websocket');\n\nclass Client {\n  constructor(req, socket, head, options) {\n    options = this.options = options || {};\n    this.ws = new WebSocket(req, socket, head);\n    this.ws.onmessage = this.message.bind(this);\n    this.ws.onclose = this.close.bind(this);\n    this.id = this.uniqueId('ws');\n  }\n\n  message(event) {\n    var data = this.data(event);\n    if(this[data.command]) return this[data.command](data);\n  }\n\n  close(event) {\n    if(this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.emit('end', event);\n  }\n\n  hello() {\n    this.send({\n      command: 'hello',\n      protocols: [\n        'http://livereload.com/protocols/official-7'\n      ],\n      serverName: 'tiny-lr'\n    });\n  }\n\n  info(data) {\n    this.plugins = data.plugins;\n    this.url = data.url;\n  }\n\n  reload(files) {\n    files.forEach(function(file) {\n      this.send({\n        command: 'reload',\n        path: file,\n        liveCss: this.options.liveCss !== false,\n        liveJs: this.options.liveJs !== false,\n        liveImg: this.options.liveImg !== false\n      });\n    }, this);\n  }\n\n  _data(event) {\n    var data = {};\n    try {\n      data = JSON.parse(event.data);\n    } catch (e) {}\n    return data;\n  }\n\n  send(data) {\n    this.ws.send(JSON.stringify(data));\n  }\n\n  uniqueId(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  }\n}\n\nvar idCounter = 0;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "Client.prototype.constructor = function(req, socket, head, options) {\n  this.ws = new WebSocket('ws://example.com');\n  this.options = options || {};\n  this.id = this.uniqueId('client_');\n  this.plugins = [];\n  this.url = '';\n};\n\nClient.prototype.message = function(event) {\n  const data = this._data(event);\n  if (data.cmd === 'hello') {\n    this.hello();\n  } else if (data.cmd === 'info') {\n    this.info(data);\n  } else if (data.cmd === 'reload') {\n    this.reload(data.files);\n  }\n};\n\nClient.prototype.close = function(event) {\n  this.ws.close();\n  this.emit('end');\n};\n\nClient.prototype.hello = function() {\n  const helloData = {\n    cmd: 'hello',\n    protocols: ['protocol1', 'protocol2'],\n    serverName: 'MyServer'\n  };\n  this.send(helloData);\n};\n\nClient.prototype.info = function(data) {\n  this.plugins = data.plugins;\n  this.url = data.url;\n};\n\nClient.prototype.reload = function(files) {\n  files.forEach(file => {\n    const reloadData = {\n      cmd: 'reload',\n      file: file,\n      liveReload: true\n    };\n    this.send(reloadData);\n  });\n};\n\nClient.prototype._data = function(event) {\n  try {\n    return JSON.parse(event.data);\n  } catch (e) {\n    console.error('Failed to parse message data:', e);\n    return {};\n  }\n};\n\nClient.prototype.send = function(data) {\n  this.ws.send(JSON.stringify(data));\n};\n\nClient.prototype.uniqueId = function(prefix) {\n  return prefix + Math.random().toString(36).substr(2, 9);\n};"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "fetch('https://speech.platform.bing.com/synthesize', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/ssml+xml',\n    'X-Microsoft-OutputFormat': 'audio-16khz-mp3',\n    'Authorization': 'Bearer ' + process.env.MICROSOFT_SPEECH_API_KEY\n  },\n  body: ssml\n}).then(response => {\n  if (!response.ok) throw new Error('Network response was not ok');\n  return response.arrayBuffer();\n}).catch(error => {\n  throw error;\n})"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a class that serves as an HTTP client for interacting with a build service API, handling different types of package-related operations with proper error handling.\n\nClass Description: The BuildService class provides methods to fetch package build statistics, exports, and export sizes from a remote build service. It uses Axios for HTTP requests and implements centralized error handling.\n\nAttributes:\n- operations: [Array] - A predefined list of available API operations, each specifying the operation type, endpoint, and corresponding method name\n\nMethods:\n- _makeHttpRequest: [Name](operation: Object, packageString: String) -> Promise<Object> - Makes an HTTP GET request to the build service with the specified operation and package string, handles the response and errors\n- _handleError: [Name](error: Error, operationType: String) -> Throws CustomError - Centralized error handling that processes different types of errors (response errors, request errors, and other errors) and throws appropriate custom errors\n- getPackageBuildStats: [Name](packageString: String) -> Promise<Object> - Retrieves build statistics for the specified package\n- getPackageExports: [Name](packageString: String) -> Promise<Object> - Retrieves all exports for the specified package\n- getPackageExportSizes: [Name](packageString: String) -> Promise<Object> - Retrieves size information for all exports of the specified package",
    "Canonical_solution": "const axios = require('axios');\nconst CustomError = require('../CustomError');\n\nclass BuildService {\n  constructor() {\n    this.operations = [\n      {\n        type: 'PACKAGE_BUILD_STATS',\n        endpoint: '/size',\n        methodName: 'getPackageStats',\n      },\n      {\n        type: 'PACKAGE_EXPORTS',\n        endpoint: '/exports',\n        methodName: 'getAllPackageExports',\n      },\n      {\n        type: 'PACKAGE_EXPORTS_SIZES',\n        endpoint: '/exports-sizes',\n        methodName: 'getPackageExportSizes',\n      },\n    ];\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    try {\n      const response = await axios.get(\n        `${process.env.BUILD_SERVICE_ENDPOINT}${operation.endpoint}?p=${encodeURIComponent(packageString)}`\n      );\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      const contents = error.response.data;\n      throw new CustomError(\n        contents.name || 'BuildError',\n        contents.originalError,\n        contents.extra\n      );\n    } else if (error.request) {\n      throw new CustomError('BuildError', {\n        operation: operationType,\n        reason: 'BUILD_SERVICE_UNREACHABLE',\n        url: error.request._currentUrl,\n      });\n    } else {\n      throw new CustomError('BuildError', error.message, {\n        operation: operationType,\n      });\n    }\n  }\n\n  async getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_BUILD_STATS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS_SIZES');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class BuildService {\n  constructor() {\n    this.operations = [\n      { type: 'buildStats', endpoint: '/api/packages/{packageString}/build-stats', method: 'getPackageBuildStats' },\n      { type: 'exports', endpoint: '/api/packages/{packageString}/exports', method: 'getPackageExports' },\n      { type: 'exportSizes', endpoint: '/api/packages/{packageString}/export-sizes', method: 'getPackageExportSizes' }\n    ];\n  }\n\n  _makeHttpRequest(operation, packageString) {\n    const url = operation.endpoint.replace('{packageString}', packageString);\n    return axios.get(url)\n      .then(response => response.data)\n      .catch(error => {\n        throw this._handleError(error, operation.type);\n      });\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      const { status, data } = error.response;\n      throw new CustomError(`HTTP error during ${operationType} operation: ${status} - ${data.message || 'Unknown error'}`);\n    } else if (error.request) {\n      throw new CustomError(`No response received during ${operationType} operation`);\n    } else {\n      throw new CustomError(`Unexpected error during ${operationType} operation: ${error.message}`);\n    }\n  }\n\n  getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.method === 'getPackageBuildStats');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.method === 'getPackageExports');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.method === 'getPackageExportSizes');\n    return this._makeHttpRequest(operation, packageString);\n  }\n}\n\nclass CustomError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'CustomError';\n  }\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function getChannels() {\n  try {\n    const response = await fetch('https://api.example.com/channels');\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: channel.language,\n      site_id: channel.siteId,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching TV channels:', error);\n    return [];\n  }\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a server, handles various connection events, and processes incoming messages for a reload service.\n\nFunction Description: The `connect` function initializes and manages a WebSocket connection to a specified server. It handles connection events (open, error, message, close) and processes incoming messages to trigger appropriate actions, such as requesting initial load data or reloading extensions when file changes are detected. The function ensures only one active connection exists at a time.\n\nInput: None (The WebSocket URL is hardcoded as 'ws://localhost:__RELOAD_PORT__')\n\nOutput: None (The function primarily manages side effects: establishing connections, logging events, and triggering other functions based on received messages)",
    "Canonical_solution": "function connect() {\n  if (webSocket) {\n    return;\n  }\n\n  webSocket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  webSocket.onerror = (event) => {\n    console.error(`[Reload Service] Connection error: ${JSON.stringify(event)}`);\n    webSocket.close();\n  };\n\n  webSocket.onopen = () => {\n    console.info(`[Reload Service] Connection opened.`);\n  };\n\n  webSocket.onmessage = async (event) => {\n    const message = JSON.parse(event.data);\n\n    if (message.status === 'serverReady') {\n      console.info('[Reload Service] Connection ready.');\n      await requestInitialLoadData();\n    }\n\n    if (message.changedFile) {\n      console.info(\n        `[Reload Service] Changes detected on ${message.changedFile}. Reloading extension...`\n      );\n      await messageAllExtensions(message.changedFile);\n    }\n  };\n\n  webSocket.onclose = () => {\n    console.info('[Reload Service] Connection closed.');\n    webSocket = null;\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "const WebSocket = require('ws');\n\nlet ws;\nlet isConnecting = false;\n\nfunction connect() {\n  if (isConnecting) return;\n  isConnecting = true;\n\n  ws = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  ws.on('open', () => {\n    console.log('WebSocket connection established');\n    isConnecting = false;\n  });\n\n  ws.on('error', (err) => {\n    console.error('WebSocket error:', err);\n    isConnecting = false;\n  });\n\n  ws.on('message', (data) => {\n    const message = data.toString();\n    console.log('Received message:', message);\n\n    if (message === 'reload') {\n      console.log('Reloading extensions...');\n      // Trigger reload logic here\n    } else if (message.startsWith('load ')) {\n      const moduleId = message.split(' ')[1];\n      console.log(`Requesting initial load data for module ${moduleId}`);\n      // Trigger load data request logic here\n    }\n  });\n\n  ws.on('close', () => {\n    console.log('WebSocket connection closed');\n    isConnecting = false;\n  });\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Implement a WebSocket server class for peer-to-peer communication that handles connections, messages, and room management.\n\nClass Description: The SnapdropServer class represents a WebSocket server that facilitates peer-to-peer communication. It manages WebSocket connections, handles incoming messages, and maintains rooms for peer grouping. The server also handles connection headers and keeps connections alive.\n\nAttributes:\n- _wss: [WebSocket.Server] - The WebSocket server instance\n- _rooms: [Object] - A dictionary tracking peers grouped by their IP addresses (rooms)\n\nMethods:\n- constructor(port: number) -> void - Initializes the WebSocket server on the specified port and sets up event handlers\n- _onConnection(peer: Peer) -> void - Handles new WebSocket connections, sets up message handlers, and joins the peer to a room\n- _onHeaders(headers: Array, response: Object) -> void - Processes HTTP headers during WebSocket handshake, setting cookies if needed\n- _onMessage(sender: Peer, message: string) -> void - Handles incoming messages from peers, routing them to appropriate recipients\n- _send(peer: Peer, message: Object) -> void - Sends a message to a specific peer over WebSocket connection\n- _joinRoom(peer: Peer) -> void - Adds a peer to their respective room (Not shown in reference but implied)\n- _leaveRoom(peer: Peer) -> void - Removes a peer from their room (Not shown in reference but implied)\n- _keepAlive(peer: Peer) -> void - Maintains connection with periodic pings (Not shown in reference but implied)",
    "Canonical_solution": "const WebSocket = require('ws');\n\nclass SnapdropServer {\n    constructor(port) {\n        this._wss = new WebSocket.Server({ port: port });\n        this._wss.on('connection', (socket, request) => this._onConnection(new Peer(socket, request)));\n        this._wss.on('headers', (headers, response) => this._onHeaders(headers, response));\n\n        this._rooms = {};\n    }\n\n    _onConnection(peer) {\n        this._joinRoom(peer);\n        peer.socket.on('message', message => this._onMessage(peer, message));\n        peer.socket.on('error', console.error);\n        this._keepAlive(peer);\n\n        this._send(peer, {\n            type: 'display-name',\n            message: {\n                displayName: peer.name.displayName,\n                deviceName: peer.name.deviceName\n            }\n        });\n    }\n\n    _onHeaders(headers, response) {\n        if (response.headers.cookie && response.headers.cookie.indexOf('peerid=') > -1) return;\n        response.peerId = Peer.uuid();\n        headers.push('Set-Cookie: peerid=' + response.peerId + \"; SameSite=Strict; Secure\");\n    }\n\n    _onMessage(sender, message) {\n        try {\n            message = JSON.parse(message);\n        } catch (e) {\n            return;\n        }\n\n        switch (message.type) {\n            case 'disconnect':\n                this._leaveRoom(sender);\n                break;\n            case 'pong':\n                sender.lastBeat = Date.now();\n                break;\n        }\n\n        if (message.to && this._rooms[sender.ip]) {\n            const recipientId = message.to;\n            const recipient = this._rooms[sender.ip][recipientId];\n            delete message.to;\n            message.sender = sender.id;\n            this._send(recipient, message);\n            return;\n        }\n    }\n\n    _send(peer, message) {\n        if (!peer) return;\n        if (this._wss.readyState !== this._wss.OPEN) return;\n        message = JSON.stringify(message);\n        peer.socket.send(message, error => '');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "class SnapdropServer {\n  constructor(port) {\n    this._wss = new WebSocket.Server({ port });\n    this._rooms = {};\n    this._wss.on('connection', (ws, req) => this._onConnection(ws, req));\n  }\n\n  _onConnection(peer, req) {\n    const headers = req.headers;\n    this._onHeaders(headers, peer);\n    peer.on('message', (message) => this._onMessage(peer, message));\n    peer.on('close', () => this._leaveRoom(peer));\n    this._joinRoom(peer);\n    this._keepAlive(peer);\n  }\n\n  _onHeaders(headers, response) {\n    if (headers['cookie']) {\n      const cookies = parseCookies(headers['cookie']);\n      if (cookies['room']) {\n        const room = cookies['room'];\n        if (!this._rooms[room]) {\n          this._rooms[room] = [];\n        }\n        this._rooms[room].push(peer);\n      }\n    }\n  }\n\n  _onMessage(sender, message) {\n    const data = JSON.parse(message);\n    if (data.type === 'offer' || data.type === 'answer') {\n      const room = this._getRoomForPeer(sender);\n      room.forEach(peer => {\n        if (peer !== sender) {\n          this._send(peer, data);\n        }\n      });\n    } else if (data.type === 'ice') {\n      const room = this._getRoomForPeer(sender);\n      room.forEach(peer => {\n        if (peer !== sender) {\n          this._send(peer, data);\n        }\n      });\n    }\n  }\n\n  _send(peer, message) {\n    peer.send(JSON.stringify(message));\n  }\n\n  _joinRoom(peer) {\n    const ip = peer._socket.remoteAddress;\n    if (!this._rooms[ip]) {\n      this._rooms[ip] = [];\n    }\n    this._rooms[ip].push(peer);\n  }\n\n  _leaveRoom(peer) {\n    const ip = peer._socket.remoteAddress;\n    if (this._rooms[ip]) {\n      this._rooms[ip] = this._rooms[ip].filter(p => p !== peer);\n    }\n  }\n\n  _keepAlive(peer) {\n    setInterval(() => {\n      peer.ping();\n    }, 30000);\n  }\n\n  _getRoomForPeer(peer) {\n    const ip = peer._socket.remoteAddress;\n    return this._rooms[ip] || [];\n  }\n}\n\nfunction parseCookies(cookieString) {\n  const cookies = {};\n  if (!cookieString) return cookies;\n  cookieString.split(';').forEach(cookie => {\n    const [name, value] = cookie.trim().split('=');\n    cookies[name] = decodeURIComponent(value);\n  });\n  return cookies;\n}"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles WebSocket connections, manages events, and provides methods for server lifecycle management.\n\nClass Description: The WebSocketServer class encapsulates the functionality to create and manage a WebSocket server instance. It handles server creation, connection events, and provides cleanup methods. The class uses promises for asynchronous server initialization and UUID generation for client identification.\n\nAttributes:\n- options: [Object] - Configuration options for the WebSocket server, including the port number.\n- wss: [WebSocket.Server|null] - The WebSocket server instance, initialized as null until created.\n\nMethods:\n- createServer(): [Promise<WebSocket.Server>] - Creates and starts the WebSocket server instance. Returns a promise that resolves with the server instance when listening or rejects on error.\n- onConnection(callback: [Function]): [void] - Sets up a connection event handler. The callback receives the WebSocket connection object and a generated UUID for the client.\n- close(): [void] - Closes the WebSocket server instance.",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('eventemitter3');\nvar uuid = require('uuid');\n\nclass WebSocketServer {\n  constructor(options) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  createServer() {\n    this.wss = new WebSocket.Server({\n      port: this.options.publicPort,\n      perMessageDeflate: false\n    });\n\n    var listeningListener, errorListener;\n    return new Promise((resolve, reject) => {\n      listeningListener = () => resolve(this.wss);\n      errorListener = (err) => reject(err);\n\n      this.wss.on('listening', listeningListener);\n      this.wss.on('error', errorListener);\n    })\n    .finally(() => {\n      this.wss.removeListener('listening', listeningListener);\n      this.wss.removeListener('error', errorListener);\n    });\n  }\n\n  onConnection(callback) {\n    this.wss.on('connection', (ws) => {\n      var id = uuid.v4();\n      callback(ws, id);\n    });\n  }\n\n  close() {\n    this.wss.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "class WebSocketServer {\n  constructor(options = {}) {\n    this.options = options;\n    this.wss = null;\n  }\n\n  async createServer() {\n    return new Promise((resolve, reject) => {\n      const { port } = this.options;\n      this.wss = new WebSocket.Server({ port });\n      this.wss.on('listening', () => resolve(this.wss));\n      this.wss.on('error', error => reject(error));\n    });\n  }\n\n  onConnection(callback) {\n    if (!this.wss) {\n      throw new Error('WebSocket server not created yet');\n    }\n    this.wss.on('connection', (ws) => {\n      const uuid = require('uuid').v4();\n      callback(ws, uuid);\n    });\n  }\n\n  close() {\n    if (this.wss) {\n      this.wss.close();\n    }\n  }\n}"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Create a WebSocket server class that manages WebSocket connections for a webview application, handling connection events and maintaining active connections.\n\nClass Description: The WebviewServer class is responsible for setting up and managing a WebSocket server that facilitates real-time communication between a webview application and a data source. It maintains active connections and provides server information.\n\nAttributes:\n- server: [http.Server] - The underlying HTTP server instance used for WebSocket communication\n- secret: [string] - A secret string used for authentication or security purposes\n- connections: [Set<WebviewConnection>] - A collection of active WebSocket connections\n- config: [Config] - Configuration object containing server settings\n\nMethods:\n- constructor(dataSource: [VisualizationWatchModel], config: [Config]) -> [void] - Initializes the WebSocket server, sets up connection handlers, and stores the configuration\n- get port() -> [number] - Returns the port number on which the server is listening for connections",
    "Canonical_solution": "import { WebSocketStream } from \"@hediet/typed-json-rpc-websocket\";\nimport WebSocket = require(\"ws\");\nimport * as express from \"express\";\nimport * as http from \"http\";\n\nexport class WebviewServer {\n\tprivate readonly server: http.Server;\n\tpublic readonly secret: string;\n\n\tpublic readonly connections = new Set<WebviewConnection>();\n\n\tconstructor(\n\t\tdataSource: VisualizationWatchModel,\n\t\tprivate readonly config: Config\n\t) {\n\t\tconst app = express();\n\t\tthis.server = app.listen();\n\n\t\tconst wss = new WebSocket.Server({ server: this.server });\n\t\twss.on(\"connection\", async ws => {\n\t\t\tconst stream = new WebSocketStream(ws);\n\t\t\tconst c = new WebviewConnection(\n\t\t\t\tdataSource,\n\t\t\t\tstream,\n\t\t\t\tthis,\n\t\t\t\tconfig,\n\t\t\t\tthis.secret\n\t\t\t);\n\t\t\tthis.connections.add(c);\n\t\t\tawait stream.onClosed;\n\t\t\tthis.connections.delete(c);\n\t\t});\n\t}\n\n\tpublic get port(): number {\n\t\tconst httpPort = (this.server.address() as AddressInfo).port;\n\t\treturn httpPort;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "class WebviewServer {\n  server;\n  secret;\n  connections = new Set();\n  config;\n\n  constructor(dataSource, config) {\n    this.config = config;\n    this.secret = config.secret;\n    this.server = new http.Server((req, res) => {\n      res.writeHead(404);\n      res.end();\n    });\n\n    this.server.on('upgrade', (request, socket, head) => {\n      const { query } = new URL(request.url, 'http://localhost');\n      const token = query.token;\n\n      if (!token || token !== this.secret) {\n        socket.destroy();\n        return;\n      }\n\n      const connection = new WebviewConnection(this, dataSource, socket, request);\n      this.connections.add(connection);\n      connection.on('close', () => {\n        this.connections.delete(connection);\n      });\n    });\n\n    this.server.listen(this.config.port, () => {\n      console.log(`Webview server running on port ${this.config.port}`);\n    });\n  }\n\n  get port() {\n    return this.server.address().port;\n  }\n}\n\nclass WebviewConnection {\n  server;\n  dataSource;\n  socket;\n  request;\n  id;\n  isAlive = true;\n\n  constructor(server, dataSource, socket, request) {\n    this.server = server;\n    this.dataSource = dataSource;\n    this.socket = socket;\n    this.request = request;\n    this.id = Math.random().toString(36).substring(2, 9);\n\n    this.socket.on('message', (message) => {\n      if (this.isAlive) {\n        this.handleMessage(message);\n      }\n    });\n\n    this.socket.on('close', () => {\n      this.isAlive = false;\n      this.server.connections.delete(this);\n    });\n\n    this.socket.on('error', (err) => {\n      console.error('WebSocket error:', err);\n      this.isAlive = false;\n      this.server.connections.delete(this);\n    });\n  }\n\n  handleMessage(message) {\n    try {\n      const data = JSON.parse(message.toString());\n      this.dataSource.processData(data);\n      this.sendStatus('connected');\n    } catch (err) {\n      console.error('Error parsing message:', err);\n      this.sendStatus('error');\n    }\n  }\n\n  sendStatus(status) {\n    if (this.isAlive) {\n      this.socket.send(JSON.stringify({ status, id: this.id }));\n    }\n  }\n}"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class HTTPClient {\n  constructor() {\n    this.requestModule = 'axios';\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers, params, body } = options;\n    let config = {\n      method,\n      url,\n      headers: headers || {},\n      params: params || {},\n      data: body || {}\n    };\n\n    if (method === 'GET') {\n      config.params = params || {};\n    } else if (method === 'POST') {\n      if (!headers) config.headers = {};\n      if (!config.headers['Content-Type']) {\n        if (typeof body === 'object' && !Array.isArray(body)) {\n          config.headers['Content-Type'] = 'application/json';\n        } else {\n          config.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        }\n      }\n    }\n\n    try {\n      const response = await axios(config);\n      return {\n        status: response.status,\n        data: response.data,\n        headers: response.headers\n      };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  queryStr(options) {\n    return Object.keys(options).reduce((str, key) => {\n      if (options[key] !== undefined) {\n        str += `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}&`;\n      }\n      return str;\n    }, '').slice(0, -1);\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return typeof obj === 'object' && obj !== null && Object.prototype.toString.call(obj) === '[object Object]';\n  }\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript that handles real-time communication between clients and integrates with an Express application and Deployd backend.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io, integrates it with an Express application, and attaches a Deployd backend. It sets up event listeners for server operations and handles custom Express routes.\n\nInput: None (The function uses environment variables for configuration: `process.env.NODE_ENV` for environment setting and `process.env.PORT` for port number)\n\nOutput: None (The function starts a server that listens on the specified port and logs server status to the console)\n\nNote: The function internally uses:\n- Express for HTTP server functionality\n- Socket.io for WebSocket communication\n- Deployd for backend services\n- MongoDB (configured to connect to localhost:27017 with database name 'test-app')",
    "Canonical_solution": "function setupWebSocketServer() {\n    var express = require('express');\n    var app = express();\n    var server = require('http').createServer(app);\n    var io = require('socket.io').listen(server, {'log level': 0});\n\n    require('deployd').attach(server, {\n        socketIo: io,\n        env: process.env.NODE_ENV || 'development',\n        db: {host:'localhost', port:27017, name:'test-app'}\n    });\n    app.use(server.handleRequest);\n\n    app.get('/express-custom-handler', function(req, res) {\n        res.send('Ok');\n    });\n\n    server.listen(process.env.PORT || 2403, function() {\n        console.log({ ENV: process.env.NODE_ENV || 'development', PORT: process.env.PORT || 2403 });\n    });\n    server.on('error', function(err) {\n        console.log(err.stack);\n        process.nextTick(function() {\n            process.exit();\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst socketIO = require('socket.io');\nconst deployd = require('deployd');\nconst mongoose = require('mongoose');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIO(server);\n\nconst dbConfig = {\n  uri: 'mongodb://localhost:27017/test-app'\n};\n\nmongoose.connect(dbConfig.uri, { useNewUrlParser: true, useUnifiedTopology: true });\n\nconst dp = deployd({\n  port: 3000,\n  database: dbConfig.uri,\n  secret: 'your-secret-key',\n  cors: {\n    origin: '*',\n    methods: ['GET', 'POST', 'PUT', 'DELETE'],\n    credentials: true\n  }\n});\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\ndp.start();\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  \n  socket.on('message', (data) => {\n    console.log('Received message:', data);\n    io.emit('message', data);\n  });\n  \n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Data from Express' });\n});\n\nconst PORT = process.env.PORT || 3001;\n\nserver.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Deployd running on port 3000`);\n});"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function getChannels() {\n  const response = await axios.get(this.url());\n  const $ = cheerio.load(response.data);\n  const channels = [];\n  \n  $('.channel-item').each((index, element) => {\n    const lang = $(element).find('.lang').text().trim();\n    const site_id = $(element).find('.site-id').text().trim();\n    const name = $(element).find('.name').text().trim();\n    \n    if (lang && site_id && name) {\n      channels.push({ lang, site_id, name });\n    }\n  });\n  \n  return channels;\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function installTelemetry() {\n  const TELEMETRY_ENABLED = process.env.TUNNELMOLE_TELEMETRY === 'true';\n  if (!TELEMETRY_ENABLED) return;\n  const { version: nodeVersion } = process;\n  const platform = process.platform;\n  try {\n    const response = await fetch('https://telemetry.example.com/endpoint', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ nodeVersion, platform })\n    });\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n  } catch (error) {\n    // Handle error silently\n  }\n}"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const SauceLabsClient = class {\n  constructor() {\n    this.auth = null;\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth = {\n      username: saucelabsUsername,\n      token: saucelabsToken\n    };\n  }\n\n  get(path, callback) {\n    const url = `https://api.saucelabs.com/${path}`;\n    const options = {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Basic ${Buffer.from(`${this.auth.username}:${this.auth.token}`).toString('base64')}`\n      }\n    };\n\n    fetch(url, options)\n      .then(response => response.json())\n      .then(data => callback(null, data))\n      .catch(error => callback(error));\n  }\n\n  post(path, data, callback) {\n    const url = `https://api.saucelabs.com/${path}`;\n    const options = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Basic ${Buffer.from(`${this.auth.username}:${this.auth.token}`).toString('base64')}`\n      },\n      body: JSON.stringify(data)\n    };\n\n    fetch(url, options)\n      .then(response => response.json())\n      .then(data => callback(null, data))\n      .catch(error => callback(error));\n  }\n};"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using an HTTP POST request and triggers a callback function upon completion or failure.\n\nFunction Description: The function uses Axios to send an HTTP POST request to a specified webhook URL with event and data payload. It triggers a callback function (triggerActivity) when the request succeeds or fails. The request includes custom headers for identification.\n\nInput:\n- url: [String] - The webhook URL to which the POST request will be sent\n- event: [String/Object] - The event information to be sent in the request payload\n- data: [Object] - The data payload to be sent in the request\n- triggerActivity: [Function] - Callback function to be triggered after request completion (takes an optional error parameter)\n\nOutput: [None] - The function doesn't return anything but triggers the callback function",
    "Canonical_solution": "const axios = require(\"axios\");\n\nfunction postWebhook(url, event, data, triggerActivity) {\n    axios.post(url, {event, data}, {headers: {\"user-agent\": \"MySpeed/WebhookAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "axios.post(url, { event, data }, { headers: { 'Content-Type': 'application/json', 'X-Request-ID': 'unique-id' } })\n  .then(() => triggerActivity(null))\n  .catch(error => triggerActivity(error));"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = \"https://bundlesize-store.now.sh/values\";\n    this.enabled = Boolean(repo && token);\n  }\n\n  get() {\n    return new Promise((resolve, reject) => {\n      const sanitizedRepo = this.repo.replace(/\\./g, \"_\");\n      const options = {\n        method: \"GET\",\n        headers: {\n          Authorization: `Bearer ${this.token}`,\n          \"Content-Type\": \"application/json\"\n        }\n      };\n\n      fetch(`${this.url}/${sanitizedRepo}?sha=${this.sha}`, options)\n        .then(response => {\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          return response.json();\n        })\n        .then(data => resolve(data))\n        .catch(error => {\n          console.error(\"Error fetching bundle size data:\", error);\n          resolve({});\n        });\n    });\n  }\n\n  set(values) {\n    if (!this.enabled) {\n      console.warn(\"Bundle size API is not enabled. Missing repo or token.\");\n      return;\n    }\n\n    const sanitizedRepo = this.repo.replace(/\\./g, \"_\");\n    const payload = {\n      repo: sanitizedRepo,\n      sha: this.sha,\n      values\n    };\n\n    fetch(this.url, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${this.token}`,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload)\n    })\n      .catch(error => {\n        console.error(\"Error setting bundle size data:\", error);\n      });\n  }\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "fetch('https://api.health.gov.il/covid19-dashboard/api/v1/data', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    request: {\n      datasets: [\n        'updates',\n        'patient_statistics',\n        'test_results',\n        'demographic_breakdowns'\n      ]\n    }\n  })\n}).then(response => {\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  return response.json();\n}).catch(error => {\n  console.error('Failed to fetch COVID-19 data:', error);\n  return null;\n});"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with optional path extension and error data, then triggers an activity callback based on the request's success or failure.\n\nFunction Description: The function `sendPing` is an asynchronous function that constructs a target URL by combining a base URL and an optional path, then sends an HTTP POST request using Axios. The request includes error data in the payload and a custom user-agent header. Depending on the request's outcome, it triggers a callback function (`triggerActivity`) with a success or failure indicator.\n\nInput:  \n- `url`: [String] - The base URL to which the request will be sent.  \n- `path`: [String] (optional) - An additional path segment to append to the base URL.  \n- `error`: [Any] - Data to be sent as the request payload (typically error information).  \n- `triggerActivity`: [Function] - A callback function to be executed after the request completes, receiving a boolean parameter indicating failure (true) or success (false/undefined).  \n\nOutput:  \n- None (The function's primary effect is the HTTP request and callback execution, not a direct return value).",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function sendPing(url, path, error, triggerActivity) {\n    if (url == null) return;\n    if (path) url += \"/\" + path;\n\n    await axios.post(url, error, {headers: {\"user-agent\": \"MySpeed/HealthAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "sendPing = async (url, path, error, triggerActivity) => {\n  const targetUrl = path ? `${url}/${path}` : url;\n  try {\n    await axios.post(targetUrl, { error }, {\n      headers: {\n        'User-Agent': 'CustomPingClient/1.0'\n      }\n    });\n    triggerActivity(false);\n  } catch (err) {\n    triggerActivity(true);\n  }\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a function to send emails using different email service providers (Mailgun and Sendgrid) through HTTP requests, with error handling and promise-based asynchronous operation.\n\nFunction Description: The function `sendMail` sends an email using a configured transporter (either Mailgun or Sendgrid). It wraps the transporter's send operation in a Promise for better async handling. The transporter is configured to make HTTP requests to the respective email service API.\n\nInput:\n- `to`: [String] - Recipient email address\n- `subject`: [String] - Email subject\n- `text`: [String] - Email body content\n- `options`: [Object] (optional) - Additional email options (defaults to empty object)\n\nOutput:\n- [Promise] - Resolves with email sending success info, or rejects with an error if sending fails.\n\n---\n\nClass Description: (Not applicable, as the reference code is at the function level)",
    "Canonical_solution": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    transporter.sendMail({\n      from: `\"${ config.plugins.email.name || '' }\" <${ config.plugins.email.email || config.plugins.email.username }>`,\n      to,\n      subject,\n      text,\n    }, (error, info) => {\n      if(error) {\n        return reject(error);\n      }\n      return resolve(info);\n    });\n  });\n}\n\n// External libraries and global variables used:\nconst axios = require('axios');\nconst FormData = require('form-data');\nconst config = appRequire('services/config').all();\nlet transporter;\n\n// Mailgun implementation\ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  const form = new FormData();\n  form.append('from', options.from);\n  form.append('to', options.to);\n  form.append('subject', options.subject);\n  form.append('text', options.text);\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: form.getHeaders(),\n    data: form,\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};\n\n// Sendgrid implementation  \ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${ emailConfig.apiKey }`,\n    },\n    data: {\n      personalizations: [{\n        to: [{ email: options.to }]\n      }],\n      from: { email: options.from },\n      subject: options.subject,\n      content: [{\n        type: 'text/plain',\n        value: options.text,\n      }]\n    },\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    const transporter = {\n      mailgun: {\n        apiKey: 'your-mailgun-api-key',\n        domain: 'your-mailgun-domain',\n        send: (data, callback) => {\n          fetch(`https://api.mailgun.net/v3/${transporter.mailgun.domain}/messages`, {\n            method: 'POST',\n            headers: {\n              'Authorization': `Basic ${btoa('api:' + transporter.mailgun.apiKey)}`,\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            body: new URLSearchParams({\n              from: 'Your <you@example.com>',\n              to,\n              subject,\n              text\n            })\n          })\n          .then(response => response.json())\n          .then(data => {\n            if (data.id) {\n              resolve({ success: true, message: 'Email sent via Mailgun', data });\n            } else {\n              reject(new Error('Failed to send email via Mailgun'));\n            }\n          })\n          .catch(error => {\n            reject(new Error('Error sending email via Mailgun: ' + error.message));\n          });\n        }\n      },\n      sendgrid: {\n        apiKey: 'your-sendgrid-api-key',\n        send: (data, callback) => {\n          fetch('https://api.sendgrid.com/v3/mail/send', {\n            method: 'POST',\n            headers: {\n              'Authorization': 'Bearer ' + transporter.sendgrid.apiKey,\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n              personalizations: [{ to: [{ email: to }] }],\n              from: { email: 'you@example.com' },\n              subject,\n              content: [{ type: 'text/plain', value: text }]\n            })\n          })\n          .then(response => response.json())\n          .then(data => {\n            if (data.status.code === 202) {\n              resolve({ success: true, message: 'Email sent via Sendgrid', data });\n            } else {\n              reject(new Error('Failed to send email via Sendgrid'));\n            }\n          })\n          .catch(error => {\n            reject(new Error('Error sending email via Sendgrid: ' + error.message));\n          });\n        }\n      }\n    };\n\n    const selectedTransporter = transporter.mailgun;\n    selectedTransporter.send({ to, subject, text, options }, (error, info) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(info);\n      }\n    });\n  });\n}"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function fetchTVChannels() {\n  try {\n    const response = await fetch('https://api.example.com/tv-channels');\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: 'sq',\n      site_id: channel.id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Failed to fetch TV channels:', error);\n    return [];\n  }\n}"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a function that downloads icons from a specified URL, processes them, and handles potential duplicates while maintaining error handling and callback functionality.\n\nFunction Description: The `downloadIcons` function downloads icon data from a given URL, processes the icons to extract relevant information, checks for duplicate names, and downloads the SVG files. It handles errors appropriately and uses a callback to return the processed data or errors. The function also supports configuration for handling duplicates and customizing the download process.\n\nInput:  \n- `url` [String] - The URL from which to download the icon data.  \n- `style` [String] - The style of the icons (e.g., \"solid\", \"outline\").  \n- `callback` [Function] - A callback function that handles the processed data or errors. The callback signature is `(error, data)`.  \n\nOutput:  \n- The function does not return a value directly but invokes the `callback` with either:  \n  - An error object if an error occurs during the process.  \n  - An array of processed icon data objects sorted by name if successful. Each object includes details like `name`, `svg`, `category`, `style`, `tags`, `code`, `unicode`, and `pro` status.  \n\nAdditional Notes:  \n- The function uses Axios for HTTP requests and includes default headers for JSON acceptance and credentials.  \n- Duplicate handling is optional and can be controlled via the `breakOnError` flag (not shown in inputs but implied by the reference code).  \n- Downloaded SVGs are saved to a specified directory (`targetImagePath`), and metadata is compiled into an array for the callback.  \n- Error handling includes logging and callback invocation with errors, as well as file operations for duplicate tracking.",
    "Canonical_solution": "const axios = require('axios')\n\nfunction downloadIcons(url, style, callback) {\n  axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest'\n  axios.defaults.headers.common['Accept'] = 'application/json'\n  axios.defaults.withCredentials = true\n\n  axios.get(url).then((response) => {\n    const data = []\n    const icons = response.data.response.unicons.map((item) => ({\n      ...item,\n      allTags: item.name,\n      name: item.tags[item.tags.length - 1],\n    }))\n\n    const names = icons.map((icon) => icon.name)\n    const uniqueNames = uniq(names)\n    const repeated = countDuplicates(names)\n    const duplicates = filter(repeated, (item) => item.count > 1)\n\n    if (duplicates.length && breakOnError) {\n      console.log(\n        `Total Icons: ${names.length}, Unique Names: ${uniqueNames.length}`\n      )\n\n      console.log(`${style} Duplicates:`, duplicates)\n\n      let dupFiles = []\n      duplicates.forEach((d) => {\n        dupFiles = [...dupFiles, ...filter(icons, { name: d.value })]\n      })\n\n      fs.writeFileSync(\n        `${style}-duplicates.json`,\n        JSON.stringify(dupFiles),\n        'utf-8'\n      )\n\n      throw new Error('There are duplicate files')\n    }\n\n    eachLimit(\n      icons,\n      50,\n      async (row) => {\n        const url = row.svg\n        const name = row.name\n        const fileName = `${name}.svg`\n        const filePath = path.resolve(targetImagePath, fileName)\n\n        try {\n          await downloadImage(url, filePath)\n\n          const charCodeExists = existingConfig.find((i) => i.name === name)\n          const charCode =\n            charCodeExists && charCodeExists.code\n              ? charCodeExists.code\n              : startCharCode++\n\n          data.push({\n            uuid: row.uuid,\n            id: row.id,\n            name: name,\n            svg: `svg/${style}/${fileName}`,\n            category: row.category,\n            style: upperFirst(style),\n            tags: row.tags,\n            code: charCode,\n            unicode: charCode.toString(16),\n            pro: Boolean(row.price),\n          })\n        } catch (error) {\n          console.error(error)\n          console.log('Error Downloading:', name)\n        }\n      },\n      (err, results) => {\n        if (err) {\n          console.log(results)\n          throw err\n        }\n\n        console.log(`${data.length} Images Downloaded!`)\n        callback(null, sortBy(data, 'name'))\n      }\n    )\n  }).catch(err => {\n    callback(err)\n  })\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function downloadIcons(url, style, callback) {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'credentials': 'include'\n      }\n    });\n\n    const icons = response.data.icons || [];\n    const processedIcons = [];\n\n    for (const icon of icons) {\n      const { name, svg, category, tags, code, unicode, pro } = icon;\n      const fileName = `${name}.svg`;\n      const filePath = path.join(targetImagePath, fileName);\n\n      // Check for duplicates\n      if (fs.existsSync(filePath)) {\n        if (breakOnError) {\n          throw new Error(`Duplicate icon found: ${fileName}`);\n        }\n        continue;\n      }\n\n      fs.writeFileSync(filePath, svg);\n      processedIcons.push({ name, svg, category, style, tags, code, unicode, pro });\n    }\n\n    callback(null, processedIcons.sort((a, b) => a.name.localeCompare(b.name)));\n  } catch (error) {\n    console.error('Error downloading or processing icons:', error.message);\n    callback(error);\n  }\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a function that retrieves TV channel information from multiple providers and returns a list of unique channels.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers and parameters)\n\nOutput: Array of objects - Returns an array of channel objects containing language, name, and site_id (deduplicated by site_id). Each channel object has the following structure:\n{\n    lang: string,    // Language code ('fr' for French)\n    name: string,    // Channel name\n    site_id: string  // Unique identifier combining channel number and slug\n}",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3', '-4', '-5']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.tvcesoir.fr/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'France',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 2155,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'fr',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function getUniqueTVChannels() {\n  const providers = [\n    { url: 'https://api.example.com/tv-guide', payload: { region: 'fr' } },\n    { url: 'https://api.example.com/tv-guide', payload: { region: 'en' } }\n  ];\n\n  const channelPromises = providers.map(provider => {\n    return axios.post(provider.url, provider.payload)\n      .then(response => {\n        const $ = cheerio.load(response.data);\n        const channels = [];\n        $('.channel').each((i, element) => {\n          const lang = $(element).attr('lang') || 'en';\n          const name = $(element).find('.name').text().trim();\n          const siteId = $(element).attr('id') || `${i + 1}-default`;\n          channels.push({ lang, name, site_id: siteId });\n        });\n        return channels;\n      })\n      .catch(error => {\n        console.error(`Error fetching data from provider: ${error.message}`);\n        return [];\n      });\n  });\n\n  const allChannels = await Promise.all(channelPromises);\n  const flatChannels = allChannels.flat();\n  return _.uniqBy(flatChannels, 'site_id');\n}"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a function to download a video file from a given URL and save it with a specified description as the filename.\n\nFunction Description: The function `downloadVideo` initiates an asynchronous HTTP GET request to download a video file from the provided URL. It handles the response as a binary blob, creates a downloadable link, and triggers the download automatically. The function includes error handling for empty URLs and checks for successful request completion.\n\nInput:\n- `url` (String): The URL of the video file to be downloaded.\n- `desc` (String): The description to be used as the filename for the downloaded video.\n\nOutput: None (The function triggers a file download but does not return any value.)",
    "Canonical_solution": "function downloadVideo(url, desc) {\n    if (isEmpty(url)) {\n        layer.msg('\u6682\u65e0\u6570\u636e');\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\n    xhr.setRequestHeader(\"Access-Control-Allow-Credentials\", true);\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            let blob = this.response;\n            let u = window.URL.createObjectURL(new Blob([blob]));\n            let a = document.createElement('a');\n            a.download = desc + '.mp4';\n            a.href = u;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "async function downloadVideo(url, desc) {\n  if (!url || !desc) {\n    throw new Error('Both URL and description are required.');\n  }\n\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const blob = await response.blob();\n    const fileName = `${desc}.mp4`;\n    const urlObject = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = urlObject;\n    a.download = fileName;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    window.URL.revokeObjectURL(urlObject);\n  } catch (error) {\n    console.error('Error downloading video:', error);\n    throw error;\n  }\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "Tool = class {\n  constructor() {\n    this._node = null;\n    this._isSurge = false;\n    this._isQuanX = false;\n    this.isSurge = this._isSurge;\n    this.isQuanX = this._isQuanX;\n    this.isResponse = false;\n    this.detectEnvironment();\n  }\n\n  detectEnvironment() {\n    if (typeof process !== 'undefined' && process.versions.node) {\n      this._node = {\n        http: require('http'),\n        https: require('https'),\n        fs: require('fs'),\n        path: require('path'),\n        url: require('url')\n      };\n      this._isSurge = false;\n      this._isQuanX = false;\n    } else if (typeof $task !== 'undefined') {\n      this._isSurge = true;\n      this._isQuanX = false;\n    } else if (typeof $request !== 'undefined') {\n      this._isQuanX = true;\n      this._isSurge = false;\n    }\n    this.isResponse = this._isSurge || this._isQuanX;\n  }\n\n  notify(title, subtitle, message, option) {\n    if (this._isSurge) {\n      $notify(title, subtitle, message, option);\n    } else if (this._isQuanX) {\n      $notification.post(title, subtitle, message, option);\n    }\n  }\n\n  write(value, key) {\n    if (this._isSurge) {\n      $prefs.setValueForKey(value, key);\n    } else if (this._isQuanX) {\n      $persistentStore.write(value, key);\n    }\n    return true;\n  }\n\n  read(key) {\n    if (this._isSurge) {\n      return $prefs.valueForKey(key);\n    } else if (this._isQuanX) {\n      return $persistentStore.read(key);\n    }\n    return null;\n  }\n\n  get(options, callback) {\n    if (this._node) {\n      const parsedUrl = new URL(options);\n      const req = this._node.http.get(parsedUrl.href, (res) => {\n        let data = '';\n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          const status = this._status(res);\n          callback(status, data);\n        });\n      }).on('error', (err) => {\n        callback({ error: err.message }, null);\n      });\n      req.end();\n    } else if (this._isSurge) {\n      $get(options, callback);\n    } else if (this._isQuanX) {\n      $get(options, callback);\n    }\n  }\n\n  post(options, callback) {\n    if (this._node) {\n      const parsedUrl = new URL(options.url);\n      const req = this._node.http.request({\n        hostname: parsedUrl.hostname,\n        port: parsedUrl.port || 443,\n        path: parsedUrl.pathname + (parsedUrl.search ? parsedUrl.search : ''),\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }, (res) => {\n        let data = '';\n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          const status = this._status(res);\n          callback(status, data);\n        });\n      }).on('error', (err) => {\n        callback({ error: err.message }, null);\n      });\n      req.write(JSON.stringify(options.data));\n      req.end();\n    } else if (this._isSurge || this._isQuanX) {\n      $post(options, callback);\n    }\n  }\n\n  _status(response) {\n    return {\n      statusCode: response.statusCode,\n      statusMessage: response.statusMessage,\n      headers: response.headers\n    };\n  }\n};"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Implement an asynchronous function that makes an HTTP request using XMLHttpRequest with timeout handling, customizable request options, and proper error management.\n\nFunction Description: The function `_xhrRequestWithTimeout` performs an HTTP request using XMLHttpRequest with configurable method, URL, and request options. It includes timeout handling, response type configuration, custom headers, and proper cleanup of resources. The function returns a Promise that resolves with the XMLHttpRequest object on success or rejects with an error or timeout message.\n\nInput:\n- `method` (string): The HTTP method to use for the request (e.g., 'GET', 'POST').\n- `url` (string): The URL to which the request is sent.\n- `options` (RequestOptions): An object containing additional request configurations:\n  - `responseType` (optional, string): The expected response type (e.g., 'json', 'arraybuffer').\n  - `headers` (optional, object): Key-value pairs representing request headers.\n  - `body` (optional, any): The request payload to send.\n\nOutput:\n- Returns a Promise that:\n  - Resolves with the XMLHttpRequest object if the request succeeds.\n  - Rejects with an error object if the request fails.\n  - Rejects with the string 'timeout' if the request times out.",
    "Canonical_solution": "async function _xhrRequestWithTimeout(method: string, url: string, options: RequestOptions): Promise<XMLHttpRequest> {\n    return new Promise((resolve, reject) => {\n        log('[requests XHR]', method, url);\n        let timedOut = false;\n        const timer = setTimeout(() => {\n            timedOut = true;\n            reject('timeout');\n        }, config.requestTimeout);\n        const xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        if (options.responseType) {\n            xhr.responseType = options.responseType;\n        }\n        if (options.headers) {\n            for (const key in options.headers) {\n                xhr.setRequestHeader(key, options.headers[key]);\n            }\n        }\n        xhr.onload = (): void => {\n            if (timedOut) {\n                return;\n            }\n            clearTimeout(timer);\n            resolve(xhr);\n        };\n        xhr.onerror = (error): void => {\n            if (timedOut) {\n                return;\n            }\n            clearTimeout(timer);\n            reject(error);\n        };\n        let body = options.body;\n        if (typeof (body) === 'object' && !isArrayBufferView(body) && body instanceof ArrayBuffer) {\n            body = new Uint8Array(body);\n        }\n        xhr.send(body);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function _xhrRequestWithTimeout(method, url, options = {}) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    let timeoutId;\n\n    xhr.open(method, url, true);\n\n    if (options.responseType) {\n      xhr.responseType = options.responseType;\n    }\n\n    if (options.headers) {\n      for (const [key, value] of Object.entries(options.headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n    }\n\n    if (options.body !== undefined) {\n      xhr.send(options.body);\n    } else {\n      xhr.send();\n    }\n\n    xhr.onload = () => {\n      clearTimeout(timeoutId);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr);\n      } else {\n        reject(new Error(`Request failed with status ${xhr.status}`));\n      }\n    };\n\n    xhr.onerror = () => {\n      clearTimeout(timeoutId);\n      reject(new Error('Network error occurred'));\n    };\n\n    xhr.ontimeout = () => {\n      clearTimeout(timeoutId);\n      reject('timeout');\n    };\n\n    timeoutId = setTimeout(() => {\n      xhr.abort();\n    }, 10000); // Default timeout of 10 seconds\n  });\n}"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a function that handles HTTP requests using XMLHttpRequest in JavaScript, including request configuration, progress tracking, and response handling.\n\nFunction Description: The function `makeRequest` initiates and manages an HTTP request using XMLHttpRequest. It configures the request with provided settings, tracks upload/download progress, handles timeouts, and processes the response. The function supports both successful and error responses, with appropriate callbacks for each scenario.\n\nInput:\n- `resolve`: [Function] - A callback function to handle the final resolution of the request (either success or error).\n- `config`: [Object] - Configuration object containing properties to set on the XMLHttpRequest instance.\n- `method`: [String] - HTTP method for the request (e.g., 'GET', 'POST').\n- `fullUrl`: [String] - The complete URL for the request.\n- `headers`: [Object] - Key-value pairs representing HTTP headers to set on the request.\n- `payload`: [Any] - Data to send with the request (for POST/PUT requests).\n- `defaultTimeout`: [Number] - Timeout duration in milliseconds for the request.\n- `xhrExtra`: [Any] - Additional data to pass to error/timeout handlers.\n- Event handlers:\n  - `onRequestProgress`: [Function] - Callback for upload progress events.\n  - `onRequestStart`: [Function] - Callback when the request starts.\n  - `onRequestEnd`: [Function] - Callback when the request ends.\n  - `onResponseStart`: [Function] - Callback when the response starts.\n  - `onResponseProgress`: [Function] - Callback for download progress events.\n  - `onResponseEnd`: [Function] - Callback when the response ends.\n  - `onTimeoutError`: [Function] - Callback for timeout errors.\n  - `onSuccess`: [Function] - Callback for successful responses.\n  - `onError`: [Function] - Callback for error responses.\n  - `onBeforeRequest`: [Function] - Callback before sending the request.\n  - `createAbortListener`: [Function] - Creates a listener for abort events.\n  - `parseResponse`: [Function] - Parses successful response data.\n  - `parseErrorResponse`: [Function] - Parses error response data.\n  - `getResponseHeaders`: [Function] - Parses raw response headers.\n\nOutput: None (The function uses callbacks to handle results asynchronously).",
    "Canonical_solution": "function makeRequest(resolve) {\n    const xhr = new XMLHttpRequest();\n    xhr.timeout = defaultTimeout;\n\n    const abort = () => xhr.abort();\n\n    Object.entries(config).forEach(([name, value]) => {\n        xhr[name] = value;\n    });\n\n    xhr.open(method, fullUrl, true);\n\n    Object.entries(headers).forEach(([name, value]) => xhr.setRequestHeader(name, value as string));\n\n    const unmountListener = createAbortListener(0, xhrExtra, abort, resolve);\n\n    xhr.upload.onprogress = onRequestProgress;\n\n    xhr.onloadstart = (): void => {\n        onRequestEnd();\n        onResponseStart();\n    };\n\n    xhr.onprogress = onResponseProgress;\n\n    xhr.onloadend = () => {\n        onResponseEnd();\n        unmountListener();\n    };\n\n    xhr.ontimeout = () => onTimeoutError(0, xhrExtra, resolve);\n\n    xhr.onreadystatechange = (e: Event) => {\n        const event = e as unknown as ProgressEvent<XMLHttpRequest>;\n        const finishedState = 4;\n\n        if (event.target && event.target.readyState === finishedState) {\n            const { status } = event.target;\n            const success = String(status).startsWith(\"2\") || String(status).startsWith(\"3\");\n            const responseHeaders = getResponseHeaders(xhr.getAllResponseHeaders());\n\n            if (success) {\n                const data = parseResponse(event.target.response);\n                onSuccess(data, status, { headers: responseHeaders }, resolve);\n            } else {\n                const data = parseErrorResponse(event.target.response);\n                onError(data, status, { headers: responseHeaders }, resolve);\n            }\n        }\n    };\n\n    onBeforeRequest();\n    onRequestStart();\n\n    xhr.send(payload);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function makeRequest(resolve, config, method, fullUrl, headers, payload, defaultTimeout, xhrExtra) {\n    var xhr = new XMLHttpRequest();\n    var timeout = defaultTimeout || 0;\n    var abortListener = config.createAbortListener || function() {};\n    var onBeforeRequest = config.onBeforeRequest || function() {};\n    var onRequestStart = config.onRequestStart || function() {};\n    var onRequestProgress = config.onRequestProgress || function() {};\n    var onResponseStart = config.onResponseStart || function() {};\n    var onResponseProgress = config.onResponseProgress || function() {};\n    var onResponseEnd = config.onResponseEnd || function() {};\n    var onRequestEnd = config.onRequestEnd || function() {};\n    var onSuccess = config.onSuccess || function() {};\n    var onError = config.onError || function() {};\n    var onTimeoutError = config.onTimeoutError || function() {};\n    var parseResponse = config.parseResponse || function(data) { return data; };\n    var parseErrorResponse = config.parseErrorResponse || function(data) { return data; };\n    var getResponseHeaders = config.getResponseHeaders || function(xhr) { return xhr.getAllResponseHeaders(); };\n\n    xhr.open(method, fullUrl, true);\n\n    if (headers) {\n        for (var header in headers) {\n            xhr.setRequestHeader(header, headers[header]);\n        }\n    }\n\n    if (payload) {\n        xhr.send(payload);\n    } else {\n        xhr.send();\n    }\n\n    xhr.timeout = timeout;\n    xhr.ontimeout = function() {\n        onTimeoutError(xhrExtra);\n        resolve(onTimeoutError(xhrExtra));\n    };\n\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            onRequestEnd();\n            if (xhr.status >= 200 && xhr.status < 300) {\n                onResponseEnd();\n                var responseData = parseResponse(xhr.responseText);\n                onSuccess(responseData);\n                resolve(onSuccess(responseData));\n            } else {\n                onResponseEnd();\n                var errorData = parseErrorResponse(xhr.responseText);\n                onError(errorData);\n                resolve(onError(errorData));\n            }\n        }\n    };\n\n    xhr.upload.onprogress = function(event) {\n        if (event.lengthComputable) {\n            onRequestProgress(event.loaded / event.total * 100);\n        }\n    };\n\n    xhr.onprogress = function(event) {\n        if (event.lengthComputable) {\n            onResponseProgress(event.loaded / event.total * 100);\n        }\n    };\n\n    xhr.onloadstart = function() {\n        onRequestStart();\n    };\n\n    xhr.onload = function() {\n        onResponseStart();\n    };\n\n    onBeforeRequest();\n\n    xhr.addEventListener('abort', function() {\n        abortListener();\n    });\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type || null;\n    this.urlOpts = options || {};\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    const { url, urlOpts } = this;\n    const req = require('http').request(url, urlOpts, (res) => {\n      if (res.statusCode >= 400) {\n        return callback(new Error(`HTTP error: ${res.statusMessage}`));\n      }\n      const chunks = [];\n      res.on('data', (chunk) => chunks.push(chunk));\n      res.on('end', () => {\n        this._size = chunks.length * 1024;\n        callback(null, Buffer.concat(chunks));\n      });\n    }).on('error', (err) => {\n      callback(err);\n    });\n    req.end();\n  }\n\n  getDataUri(callback) {\n    this.getBuffer((err, buffer) => {\n      if (err) return callback(err);\n      const contentType = this.type() || 'application/octet-stream';\n      const base64 = buffer.toString('base64');\n      const dataUri = `data:${contentType};base64,${base64}`;\n      callback(null, dataUri);\n    });\n  }\n\n  createReadStream() {\n    const { url, urlOpts } = this;\n    const { headers } = urlOpts;\n    const req = require('http').request(url, { ...urlOpts, headers });\n    return req;\n  }\n\n  size(callback) {\n    if (this._size !== null) {\n      return callback(null, this._size);\n    }\n    this.getBuffer((err, buffer) => {\n      if (err) return callback(err);\n      this._size = buffer.length;\n      callback(null, this._size);\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "fetch('https://example.com/api/endpoint', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  credentials: 'include',\n  body: 'key1=value1&key2=value2'\n})\n.then(response => response.text())\n.then(data => console.log(data))\n.catch(error => console.error('Error:', error));"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "run_test = function(data, sender) {\n  if (data === 'xhr') {\n    try {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', 'https://example.com/data', true);\n      xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          sender.postMessage(xhr.responseText);\n        } else {\n          sender.postMessage('XHR error: ' + xhr.statusText);\n        }\n      };\n      xhr.onerror = function() {\n        sender.postMessage('XHR network error');\n      };\n      xhr.send();\n    } catch (e) {\n      sender.postMessage('XHR exception: ' + e.message);\n    }\n  } else if (data === 'fetch') {\n    fetch('https://example.com/data')\n      .then(response => {\n        if (response.ok) {\n          return response.text();\n        } else {\n          throw new Error('Fetch error: ' + response.statusText);\n        }\n      })\n      .then(text => sender.postMessage(text))\n      .catch(e => sender.postMessage('Fetch error: ' + e.message));\n  } else if (data === 'importScripts') {\n    importScripts('https://example.com/script.js');\n    sender.postMessage('Script imported successfully');\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n};"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "fetch(url)\n  .then(response => {\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    return response.text();\n  })\n  .then(yamlText => {\n    console.log(yamlText);\n    yamlToForm(yamlText);\n  })\n  .catch(error => {\n    console.error('Failed to load YAML:', error);\n  });"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "function URLExpander() {\n  this.map = {\n    'is.gd': 'is.gd',\n    'goo.gl': 'goo.gl',\n    'budurl.com': 'budurl.com',\n    'snipurl.com': 'snipurl.com'\n  };\n  this.timeout = 5000;\n  this.APIs = {\n    'is.gd': function(url) {\n      return new Promise((resolve, reject) => {\n        const req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.timeout = this.timeout;\n        req.onload = () => {\n          if (req.status >= 200 && req.status < 300) {\n            resolve(req.responseText.trim());\n          } else {\n            reject(new Error(`Request failed with status ${req.status}`));\n          }\n        };\n        req.onerror = () => reject(new Error('Network error'));\n        req.ontimeout = () => reject(new Error('Request timeout'));\n        req.send();\n      });\n    },\n    'goo.gl': function(url) {\n      return new Promise((resolve, reject) => {\n        const req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.timeout = this.timeout;\n        req.onload = () => {\n          if (req.status >= 200 && req.status < 300) {\n            resolve(req.responseText.trim());\n          } else {\n            reject(new Error(`Request failed with status ${req.status}`));\n          }\n        };\n        req.onerror = () => reject(new Error('Network error'));\n        req.ontimeout = () => reject(new Error('Request timeout'));\n        req.send();\n      });\n    },\n    'budurl.com': function(url) {\n      return new Promise((resolve, reject) => {\n        const req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.timeout = this.timeout;\n        req.onload = () => {\n          if (req.status >= 200 && req.status < 300) {\n            resolve(req.responseText.trim());\n          } else {\n            reject(new Error(`Request failed with status ${req.status}`));\n          }\n        };\n        req.onerror = () => reject(new Error('Network error'));\n        req.ontimeout = () => reject(new Error('Request timeout'));\n        req.send();\n      });\n    },\n    'snipurl.com': function(url) {\n      return new Promise((resolve, reject) => {\n        const req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.timeout = this.timeout;\n        req.onload = () => {\n          if (req.status >= 200 && req.status < 300) {\n            resolve(req.responseText.trim());\n          } else {\n            reject(new Error(`Request failed with status ${req.status}`));\n          }\n        };\n        req.onerror = () => reject(new Error('Network error'));\n        req.ontimeout = () => reject(new Error('Request timeout'));\n        req.send();\n      });\n    }\n  };\n}\n\nURLExpander.prototype.expand = function(args, callback) {\n  const { url, depth = 0, seen = {} } = args;\n  const service = Object.keys(this.map).find(key => url.startsWith(key));\n  \n  if (!service || depth >= 5) {\n    callback({ ...args, url: url, err: new Error('Max depth reached or unknown service') });\n    return;\n  }\n\n  if (seen[url]) {\n    callback({ ...args, url: url, err: new Error('Cycle detected') });\n    return;\n  }\n\n  seen[url] = true;\n\n  this.APIs[service](url)\n    .then(expandedUrl => {\n      const parsedUrl = new URL(expandedUrl);\n      const newArgs = { ...args, url: expandedUrl, depth: depth + 1, seen: seen };\n      this.expand(newArgs, callback);\n    })\n    .catch(err => {\n      callback({ ...args, url: url, err: err });\n    });\n};"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create an HTTP server using Express.js that handles various routes for data processing, API endpoints, and event handling. The server should dynamically generate API endpoints based on available utility functions and provide basic route handling for updates, embedding, and event processing.\n\nFunction Description: The `createServer` function initializes an Express.js server with middleware configuration, defines route handlers for specific endpoints, dynamically creates API routes based on utility functions, and starts the server on a random available port. It outputs the server's port information as JSON to stdout.\n\nInput: None (The function takes no parameters but relies on external modules and variables like `express`, `connect`, `dataIn`, `locker`, `oembed`, `async`, `logger`, and `util` being available in scope)\n\nOutput: \n- The function doesn't return anything directly\n- Writes server port information to stdout as JSON: `{port: [number]}`\n- Creates a running HTTP server listening on localhost\n- Provides the following endpoints:\n  - GET /update - Triggers reindexing\n  - GET /embed - Handles oEmbed requests\n  - POST /events - Processes queued events\n  - Dynamic GET routes based on utility functions",
    "Canonical_solution": "function createServer() {\n    var express = require('express'),\n        connect = require('connect');\n    var app = express.createServer(connect.bodyParser());\n    app.use(require(\"express-jsonstream\")());\n    app.set('views', __dirname);\n    app.get('/update', function (req, res) {\n        dataIn.reIndex(locker, function () {\n            res.writeHead(200);\n            res.end('Extra mince!');\n        });\n    });\n    app.get('/embed', function (req, res) {\n        if (!dataIn.process) return res.send({});\n        oembed.fetch({url:req.query.url}, function (e) {\n            if(e) return res.send(e);\n            res.send({});\n        });\n    });\n    app.post('/events', function (req, res) {\n        var q = async.queue(dataIn.processEvent, 1);\n        req.jsonStream(q.push, function (error) {\n            if(error) logger.error(error);\n            res.send(200);\n        });\n    });\n    function genericApi(name,f) {\n        app.get(name, function (req,res) {\n            var results = [];\n            f(req.query, function (item) { results.push(item); }, function (err) {\n                if(err) {\n                    res.writeHead(500, {'Content-Type': 'text/plain'});\n                    res.end(err);\n                } else {\n                    res.writeHead(200, {'Content-Type': 'application/json'});\n                    res.end(JSON.stringify(results));\n                }\n            });\n        });\n    }\n    for (var f in util) {\n        if (f == 'init') continue;\n        genericApi('/'+f,util[f]);\n    }\n    app.listen(0, 'localhost', function () {\n        var returnedInfo = {port: app.address().port};\n        process.stdout.write(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst connect = require('connect');\nconst dataIn = require('data-in');\nconst locker = require('locker');\nconst oembed = require('oembed');\nconst async = require('async');\nconst logger = require('logger');\nconst util = require('util');\n\nfunction createServer() {\n  const app = express();\n  const server = connect().use(app).listen(0, () => {\n    const port = server.address().port;\n    console.log(JSON.stringify({port: port}));\n  });\n\n  app.get('/update', (req, res) => {\n    dataIn.reindex();\n    res.status(200).send('Reindexing triggered');\n  });\n\n  app.get('/embed', (req, res) => {\n    oembed.handleRequest(req, res);\n  });\n\n  app.post('/events', (req, res) => {\n    async.eachSeries(req.body, (event, callback) => {\n      locker.processEvent(event, callback);\n    }, (err) => {\n      if (err) {\n        logger.error(err);\n      }\n      res.status(200).send('Events processed');\n    });\n  });\n\n  const utils = require('./utils'); // Assuming utility functions are exported from utils.js\n  Object.keys(utils).forEach((key) => {\n    if (typeof utils[key] === 'function') {\n      const route = '/' + key;\n      app.get(route, (req, res) => {\n        utils[key](req, res);\n      });\n    }\n  });\n}"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "const HTTPServer = class {\n  constructor(port) {\n    this.app = require('express')();\n    this.port = port;\n    this.server = null;\n\n    this.app.use((req, res, next) => {\n      res.header('Access-Control-Allow-Origin', '*');\n      res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD, TRACE');\n      res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n      if (req.method === 'OPTIONS') {\n        return res.status(200).end();\n      }\n      next();\n    });\n\n    this.app.use(require('multer')().single('file'));\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.port, () => {\n        console.log(`Server running on port ${this.port}`);\n        resolve();\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n};"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class URLExpander {\n  constructor() {\n    this.map = {\n      isgd: 'is.gd',\n      googl: 'goo.gl',\n      budurl: 'budurl.com',\n      snipurl: 'snipurl.com'\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: this._isgd.bind(this),\n      googl: this._googl.bind(this),\n      budurl: this._budurl.bind(this),\n      snipurl: this._snipurl.bind(this),\n      generic: this._generic.bind(this)\n    };\n  }\n\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n\n    if (depth > 10) {\n      return callback({ ...args, err: new Error('Maximum recursion depth exceeded') });\n    }\n\n    if (seen[url]) {\n      return callback({ ...args, err: new Error('Cycle detected') });\n    }\n\n    seen[url] = true;\n\n    const service = this._detectService(url);\n    if (!service) {\n      return callback({ ...args, err: new Error('Unknown shortening service') });\n    }\n\n    this.APIs[service](args, (result) => {\n      if (result.err) {\n        return callback(result);\n      }\n      if (result.url) {\n        return this.expand({ ...args, url: result.url, depth: depth + 1, seen }, callback);\n      }\n      callback(result);\n    });\n  }\n\n  _detectService(url) {\n    for (const service in this.map) {\n      if (url.includes(this.map[service])) {\n        return service;\n      }\n    }\n    return null;\n  }\n\n  _isgd(args, callback) {\n    const { url } = args;\n    fetch(`https://is.gd/api.php?shorturl=${encodeURIComponent(url)}`, {\n      method: 'GET',\n      timeout: this.timeout\n    })\n      .then(response => response.text())\n      .then(data => {\n        const expandedUrl = data.trim();\n        if (expandedUrl.startsWith('http')) {\n          callback({ ...args, url: expandedUrl });\n        } else {\n          callback({ ...args, err: new Error('Failed to expand URL') });\n        }\n      })\n      .catch(err => callback({ ...args, err }));\n  }\n\n  _googl(args, callback) {\n    const { url } = args;\n    fetch(`https://www.googleapis.com/urlshortener/v1/expand?shortUrl=${encodeURIComponent(url)}`, {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' },\n      timeout: this.timeout\n    })\n      .then(response => response.json())\n      .then(data => {\n        if (data.items && data.items.length > 0) {\n          callback({ ...args, url: data.items[0].longUrl });\n        } else {\n          callback({ ...args, err: new Error('Failed to expand URL') });\n        }\n      })\n      .catch(err => callback({ ...args, err }));\n  }\n\n  _budurl(args, callback) {\n    const { url } = args;\n    fetch(`https://api.budurl.com/v1/expand?url=${encodeURIComponent(url)}`, {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' },\n      timeout: this.timeout\n    })\n      .then(response => response.json())\n      .then(data => {\n        if (data.url) {\n          callback({ ...args, url: data.url });\n        } else {\n          callback({ ...args, err: new Error('Failed to expand URL') });\n        }\n      })\n      .catch(err => callback({ ...args, err }));\n  }\n\n  _snipurl(args, callback) {\n    const { url } = args;\n    fetch(`https://snipurl.com/api/expand?url=${encodeURIComponent(url)}`, {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' },\n      timeout: this.timeout\n    })\n      .then(response => response.json())\n      .then(data => {\n        if (data.url) {\n          callback({ ...args, url: data.url });\n        } else {\n          callback({ ...args, err: new Error('Failed to expand URL') });\n        }\n      })\n      .catch(err => callback({ ...args, err }));\n  }\n\n  _generic(args, callback) {\n    const { url, depth, seen } = args;\n    fetch(url, {\n      method: 'HEAD',\n      timeout: this.timeout\n    })\n      .then(response => {\n        const location = response.headers.get('Location');\n        if (location) {\n          return this.expand({ ...args, url: location, depth: depth + 1, seen }, callback);\n        }\n        callback({ ...args, url });\n      })\n      .catch(err => callback({ ...args, err }));\n  }\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "function makeHttpRequest() {\n  const request = require('request');\n  const url = 'https://api.example.com/data';\n  const headers = {\n    'User-Agent': 'MyApp/1.0',\n    'Accept-Encoding': 'gzip, deflate'\n  };\n\n  request.get({\n    url: url,\n    headers: headers\n  }, function (error, response, body) {\n    if (!error && response.statusCode === 200) {\n      console.log(body);\n    } else {\n      console.error('Error:', error);\n    }\n  });\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a function to set up an Express server that serves static files for a specific route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures a route to serve a static HTML file, and starts the server on port 3000. It is designed to handle GET requests for the '/users' path by sending the corresponding HTML file.\n\nInput: None\n\nOutput: None (The function starts the server and logs a message to the console when the server is running.)",
    "Canonical_solution": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n    const app = express();\n    \n    app.get('/users', function (req, res) {\n        res.sendFile(path.join(__dirname, 'modules/users/views/list.html'));\n    });\n\n    app.listen(3000, function () {\n        console.log('Servidor rodando em localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst app = express();\napp.use('/users', express.static('public'));\napp.listen(3000, () => console.log('Server is running on port 3000'));"
  }
]