[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const crypto = require('crypto');\nconst https = require('https');\n\nclass Trader {\n  constructor(config) {\n    this.key = config.key;\n    this.secret = config.secret;\n    this.currency = config.currency;\n    this.asset = config.asset;\n    this.pair = `${this.asset}_${this.currency}`;\n    this.name = 'EXMO';\n    this.nonce = 0;\n  }\n\n  api_query(method, params, callback) {\n    this.nonce += 1;\n    params.nonce = this.nonce;\n\n    const keys = Object.keys(params).sort();\n    const parts = keys.map(k => {\n      const encodedKey = encodeURIComponent(k);\n      const encodedValue = encodeURIComponent(params[k]);\n      return `${encodedKey}=${encodedValue}`;\n    });\n    const query = parts.join('&');\n\n    const hmac = crypto.createHmac('sha512', this.secret);\n    hmac.update(query, 'utf8');\n    const signature = hmac.digest('hex');\n\n    const options = {\n      hostname: 'api.exmo.com',\n      port: 443,\n      path: `/v1.1/${method}`,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(query),\n        'key': this.key,\n        'sign': signature\n      }\n    };\n\n    const req = https.request(options, (res) => {\n      let data = '';\n      res.on('data', (chunk) => {\n        data += chunk;\n      });\n      res.on('end', () => {\n        try {\n          const json = JSON.parse(data);\n          if (json.error) {\n            callback(new Error(json.error));\n          } else {\n            callback(null, json);\n          }\n        } catch (e) {\n          callback(e);\n        }\n      });\n    });\n\n    req.on('error', (error) => {\n      callback(error);\n    });\n\n    req.write(query);\n    req.end();\n  }\n}\n\nmodule.exports = Trader;"
  },
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create a function that sets up an Express server with various route handlers for handling HTTP requests related to email functionality, including authentication, sending test emails, and managing email server configurations.\n\nFunction Description: The function `setupExpressServer` initializes an Express server with middleware for parsing request bodies and cookies. It defines several route handlers for different HTTP methods (GET, POST) that handle email-related operations such as authentication, sending test emails, and saving email server configurations. The server listens on a specified port.\n\nInput: None (The function uses module-level variables like `processInfo.port` for configuration)\n\nOutput: None (The function starts a server that listens on the specified port and handles incoming HTTP requests)\n\nNote: The function relies on several external modules and variables that should be available in the scope:\n- `express`: The Express framework\n- `connect`: Middleware for Express\n- `fs`: File system module\n- `nodemailer`: For sending emails\n- `lcrypto`: For encryption\n- `lutil`: For file operations\n- `auth`: A variable storing authentication details\n- `processInfo`: An object containing server configuration (like port number)\n- `locker`: An object containing base URL for locker service\n- `request`: For making HTTP requests",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var connect = require('connect');\n    var app = express.createServer(connect.bodyParser(), connect.cookieParser());\n    \n    app.set('views', __dirname);\n    \n    app.get('/', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!auth || req.param(\"change\")) return res.end(fs.readFileSync(__dirname + '/auth.html'));\n        res.write(\"<p>Using \"+auth.host+\":\"+auth.port+\" \");\n        if(auth.ssl) res.write(\"(ssl)\");\n        if(auth.user) res.write(\"authenticating as \"+auth.user);\n        res.write(\"<br><a href='?change=1'>change</a> or <a href='javascript:window.location=\\\"test?to=\\\"+window.prompt(\\\"recipient email address\\\")'>send test message</a>\");\n        res.end();\n    });\n    \n    app.post('/save', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!req.body || !req.body.host || !req.body.port) return res.end(\"missing minimum required host/port :(\");\n        nodemailer.SMTP = auth = {host:req.body.host, port:req.body.port, ssl:false};\n        if(req.body.ssl) auth.ssl = true;\n        if(req.body.user && req.body.pass) {\n            auth.use_authentication = true;\n            auth.user = req.body.user;\n            auth.pass = lcrypto.encrypt(req.body.pass);\n        }\n        lutil.atomicWriteFileSync(\"auth.json\", JSON.stringify(auth, null, 4));\n        if(auth.pass) auth.pass = req.body.pass;\n        res.end(\"saved! <a href='./'>continue</a>\");\n    });\n    \n    app.get('/state', function (req, res) {\n        var ready = (auth) ? 1 : 0;\n        res.send({ready:ready});\n    });\n    \n    app.get('/test', function (req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!req.param(\"to\") || req.param(\"to\").indexOf(\"@\") <= 0) return res.end(\"invalid recipient\")\n        var message = {\n            sender: 'Testificate <42@awesome.com>',\n            to: req.param(\"to\"),\n            subject: 'test message  \u2714',\n            body: 'Hello to you!',\n            html:'<p>it <b>WORKED</b></p>',\n            debug: true\n        };\n        request.post({url:locker.lockerBase + \"/Me/smtp/send\", json:message}, function(err, r, body){\n            if(err || !body) return res.end(\"failed \"+err);\n            return res.end(\"sent!\");\n        });\n    });\n    \n    app.post('/send', function (req, res) {\n        if(!auth) return res.send(false);\n        if (!req.body || !req.body.to) return res.send(false);\n        console.error(\"DEBUG SMTP: \"+JSON.stringify(req.body));\n        var sent = false;\n        nodemailer.send_mail(req.body, function(err, ok){\n            if(sent) return;\n            sent=true;\n            if(err || !ok){\n                console.error('Error occured: '+err);\n                return res.send(false);\n            }\n            res.send(true);\n        })\n    });\n    \n    app.listen(processInfo.port,function() {\n        var returnedInfo = {};\n        console.log(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "function setupExpressServer() {\n  const app = express();\n  app.use(connect.bodyParser());\n  app.use(connect.cookieParser());\n  \n  app.get('/email/auth', (req, res) => {\n    res.json(auth);\n  });\n  \n  app.post('/email/auth', (req, res) => {\n    const { username, password } = req.body;\n    auth.username = username;\n    auth.password = password;\n    res.json({ success: true });\n  });\n  \n  app.post('/email/test', (req, res) => {\n    const transporter = nodemailer.createTransport({\n      host: auth.smtp.host,\n      port: auth.smtp.port,\n      secure: auth.smtp.secure,\n      auth: {\n        user: auth.username,\n        pass: auth.password\n      }\n    });\n    \n    const mailOptions = {\n      from: auth.username,\n      to: auth.username,\n      subject: 'Test Email',\n      text: 'This is a test email sent from the server.'\n    };\n    \n    transporter.sendMail(mailOptions, (error, info) => {\n      if (error) {\n        return res.status(500).json({ error: error.message });\n      }\n      res.json({ success: true });\n    });\n  });\n  \n  app.get('/email/config', (req, res) => {\n    const config = lutil.readJSONFile('email-server-config');\n    res.json(config);\n  });\n  \n  app.post('/email/config', (req, res) => {\n    const configData = req.body;\n    const encrypted = lcrypto.encrypt(JSON.stringify(configData));\n    fs.writeFileSync(lutil.getConfigPath('email-server-config'), encrypted);\n    res.json({ success: true });\n  });\n  \n  app.listen(processInfo.port, () => {\n    console.log(`Email server running on port ${processInfo.port}`);\n  });\n}"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server with WebSocket support using Express and Socket.IO, implementing a particle simulation system with cluster and client event handling.\n\nFunction Description: The function `startServer` initializes an Express application, sets up static file serving, integrates Socket.IO for real-time communication, and configures a particle simulation system with collision detection and cluster management. It handles particle movement, boundary collisions, and client interactions through defined event handlers.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function starts a server listening on port 3000 but doesn't return any value)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    const server = require('http').Server(app);\n    const io = require('socket.io')(server);\n    const swip = require('../../../src/server/index.js');\n\n    app.use(express.static(__dirname + './../static'));\n\n    swip(io, {\n        cluster: {\n            events: {\n                update: (cluster) => {\n                    const blobs = cluster.data.blobs;\n                    const clients = cluster.clients;\n\n                    const updatedBlobs = blobs.map((blob) => {\n                        const boundaryOffset = blob.size;\n                        const client = clients.find((c) => isParticleInClient(blob, c));\n\n                        let nextPosX = blob.x + blob.speedX;\n                        let nextPosY = blob.y + blob.speedY;\n                        let nextSpeedX = blob.speedX;\n                        let nextSpeedY = blob.speedY;\n\n                        if (client) {\n                            if (((blob.speedX < 0) &&\n                                ((nextPosX - boundaryOffset) < client.transform.x)\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.left, nextPosY))) {\n                                nextPosX = client.transform.x + boundaryOffset;\n                                nextSpeedX = blob.speedX * -1;\n                            } else if (((blob.speedX > 0) &&\n                                ((nextPosX + boundaryOffset) > (client.transform.x + client.size.width))\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.right, nextPosY))) {\n                                nextPosX = client.transform.x + (client.size.width - boundaryOffset);\n                                nextSpeedX = blob.speedX * -1;\n                            }\n\n                            if (((blob.speedY < 0) &&\n                                ((nextPosY - boundaryOffset) < client.transform.y\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.top, nextPosX)))) {\n                                nextPosY = client.transform.y + boundaryOffset;\n                                nextSpeedY = blob.speedY * -1;\n                            } else if (((blob.speedY > 0) &&\n                                ((nextPosY + boundaryOffset) > (client.transform.y + client.size.height))\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.bottom, nextPosX))\n                            ) {\n                                nextPosY = client.transform.y + (client.size.height - boundaryOffset);\n                                nextSpeedY = blob.speedY * -1;\n                            }\n                        } else {\n                            const firstClient = clients[0];\n                            nextPosX = firstClient.transform.x + (firstClient.size.width / 2);\n                            nextPosY = firstClient.transform.y + (firstClient.size.height / 2);\n                            nextSpeedX = 0;\n                            nextSpeedY = 0;\n                        }\n\n                        blob.x = nextPosX;\n                        blob.y = nextPosY;\n                        blob.speedX = nextSpeedX;\n                        blob.speedY = nextSpeedY;\n\n                        return blob;\n                    });\n\n                    return {\n                        blobs: { $set: updatedBlobs },\n                    };\n                },\n                merge: (cluster1, cluster2, transform) => ({\n                    blobs: { $set: getNewParticleDist(cluster1, cluster2, transform) },\n                    backgroundColor: { $set: cluster1.data.backgroundColor },\n                }),\n            },\n            init: () => ({ blobs: [], backgroundColor: getRandomColor() }),\n        },\n\n        client: {\n            init: () => ({}),\n            events: {\n                addBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $push: blobs } },\n                        },\n                    };\n                },\n                updateBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $set: blobs } },\n                        },\n                    };\n                },\n            },\n        },\n    });\n\n    server.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "function startServer() {\n  const express = require('express');\n  const http = require('http');\n  const socketIO = require('socket.io');\n  const path = require('path');\n\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIO(server);\n\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  let particles = [];\n  let clusters = [];\n\n  for (let i = 0; i < 5; i++) {\n    clusters.push({\n      id: i,\n      x: Math.random() * 800,\n      y: Math.random() * 600,\n      radius: 100\n    });\n  }\n\n  io.on('connection', (socket) => {\n    const newParticle = {\n      id: socket.id,\n      x: 400,\n      y: 300,\n      vx: 0,\n      vy: 0,\n      radius: 10,\n      mass: 1,\n      clusterId: null\n    };\n    particles.push(newParticle);\n\n    socket.emit('init', { particles, clusters });\n    socket.broadcast.emit('particleAdded', newParticle);\n\n    socket.on('move', (direction) => {\n      const speed = 5;\n      const particle = particles.find(p => p.id === socket.id);\n      if (particle) {\n        switch (direction) {\n          case 'up': particle.vy = -speed; break;\n          case 'down': particle.vy = speed; break;\n          case 'left': particle.vx = -speed; break;\n          case 'right': particle.vx = speed; break;\n          default: particle.vx = 0; particle.vy = 0;\n        }\n      }\n    });\n\n    socket.on('disconnect', () => {\n      particles = particles.filter(p => p.id !== socket.id);\n      io.emit('particleRemoved', { id: socket.id });\n    });\n  });\n\n  setInterval(() => {\n    particles.forEach(particle => {\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n\n      if (particle.x - particle.radius < 0 || particle.x + particle.radius > 800) {\n        particle.vx *= -1;\n      }\n      if (particle.y - particle.radius < 0 || particle.y + particle.radius > 600) {\n        particle.vy *= -1;\n      }\n\n      particle.clusterId = null;\n      for (let cluster of clusters) {\n        const dx = particle.x - cluster.x;\n        const dy = particle.y - cluster.y;\n        const distance = Math.sqrt(dx*dx + dy*dy);\n        if (distance < cluster.radius) {\n          particle.clusterId = cluster.id;\n          break;\n        }\n      }\n    });\n\n    for (let i = 0; i < particles.length; i++) {\n      for (let j = i + 1; j < particles.length; j++) {\n        const p1 = particles[i];\n        const p2 = particles[j];\n        const dx = p1.x - p2.x;\n        const dy = p1.y - p2.y;\n        const distance = Math.sqrt(dx*dx + dy*dy);\n        if (distance < p1.radius + p2.radius) {\n          const angle = Math.atan2(dy, dx);\n          const sin = Math.sin(angle);\n          const cos = Math.cos(angle);\n\n          let u1x = p1.vx * cos + p1.vy * sin;\n          let u1y = p1.vy * cos - p1.vx * sin;\n          let u2x = p2.vx * cos + p2.vy * sin;\n          let u2y = p2.vy * cos - p2.vx * sin;\n\n          [u1x, u2x] = [u2x, u1x];\n\n          p1.vx = u1x * cos - u1y * sin;\n          p1.vy = u1y * cos + u1x * sin;\n          p2.vx = u2x * cos - u2y * sin;\n          p2.vy = u2y * cos + u2x * sin;\n        }\n      }\n    }\n\n    io.emit('update', { particles });\n  }, 16);\n\n  server.listen(3000, () => {\n    console.log('Server listening on port 3000');\n  });\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst url = require('url');\nconst http = require('http');\nconst https = require('https');\n\nclass URLExpander {\n  constructor() {\n    this.map = {\n      isgd: ['is.gd', 'www.is.gd'],\n      googl: ['goo.gl', 'www.goo.gl'],\n      budurl: ['budurl.com', 'www.budurl.com'],\n      snipurl: ['snipurl.com', 'www.snipurl.com']\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: this.isgd.bind(this),\n      googl: this.googl.bind(this),\n      budurl: this.budurl.bind(this),\n      snipurl: this.snipurl.bind(this),\n      generic: this.generic.bind(this)\n    };\n  }\n\n  expand(args, callback) {\n    const { url: inputUrl, depth = 0, seen = {} } = args;\n    if (seen[inputUrl]) {\n      return callback(new Error('Infinite loop detected'), args);\n    }\n    const newSeen = { ...seen, [inputUrl]: true };\n    let hostname;\n    try {\n      hostname = new URL(inputUrl).hostname;\n    } catch (err) {\n      return callback(new Error('Invalid URL'), args);\n    }\n\n    let service = null;\n    for (const [key, domains] of Object.entries(this.map)) {\n      if (domains.includes(hostname)) {\n        service = key;\n        break;\n      }\n    }\n\n    const nextArgs = { url: inputUrl, depth, seen: newSeen };\n    if (service && this.APIs[service]) {\n      this.APIs[service](nextArgs, callback);\n    } else {\n      this.APIs.generic(nextArgs, callback);\n    }\n  }\n\n  isgd(args, callback) {\n    this._followRedirect(args, callback);\n  }\n\n  googl(args, callback) {\n    const { url: shortUrl, depth, seen } = args;\n    const apiUrl = `https://www.googleapis.com/urlshortener/v1/url?shortUrl=${encodeURIComponent(shortUrl)}`;\n    https.get(apiUrl, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          const json = JSON.parse(data);\n          callback(null, { url: json.longUrl || shortUrl, depth, seen });\n        } catch (e) {\n          this._followRedirect(args, callback);\n        }\n      });\n    }).on('error', () => {\n      this._followRedirect(args, callback);\n    });\n  }\n\n  budurl(args, callback) {\n    this._followRedirect(args, callback);\n  }\n\n  snipurl(args, callback) {\n    this._followRedirect(args, callback);\n  }\n\n  generic(args, callback) {\n    this._followRedirect(args, callback);\n  }\n\n  _followRedirect(args, callback) {\n    const { url: currentUrl, depth, seen } = args;\n    if (depth >= 10) {\n      return callback(new Error('Maximum redirect depth exceeded'), args);\n    }\n\n    let parsedUrl;\n    try {\n      parsedUrl = new URL(currentUrl);\n    } catch {\n      return callback(new Error('Invalid URL'), args);\n    }\n\n    const protocol = parsedUrl.protocol === 'https:' ? https : http;\n    const options = {\n      method: 'HEAD',\n      hostname: parsedUrl.hostname,\n      port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),\n      path: parsedUrl.pathname + parsedUrl.search,\n      timeout: this.timeout\n    };\n\n    const req = protocol.request(options, (res) => {\n      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n        const nextUrl = new URL(res.headers.location, currentUrl).href;\n        this.expand({ url: nextUrl, depth: depth + 1, seen }, callback);\n      } else {\n        callback(null, { url: currentUrl, depth, seen });\n      }\n    });\n\n    req.on('error', (err) => {\n      callback(err, args);\n    });\n\n    req.on('timeout', () => {\n      req.abort();\n      callback(new Error('Request timeout'), args);\n    });\n\n    req.end();\n  }\n}\n\nmodule.exports = URLExpander;\n```"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server using the Express framework in JavaScript, with middleware configurations for request processing and static file serving.\n\nFunction Description: The function `createServer` initializes an Express application, configures various middleware for logging, request parsing, and static file serving, and starts an HTTP server listening on a specified port. It also includes environment-specific error handling for development mode.\n\nInput: None (The function does not take any parameters; it uses environment variables like `process.env.PORT` for configuration.)\n\nOutput: None (The function does not return any value; it starts an HTTP server that listens on the specified port and logs a message upon successful startup.)",
    "Canonical_solution": "function createServer() {\n    var express = require('express');\n    var http = require('http');\n    var path = require('path');\n\n    var app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.favicon());\n    app.use(express.logger('dev'));\n    app.use(express.json());\n    app.use(express.urlencoded());\n    app.use(express.methodOverride());\n    app.use(express.static(path.join(__dirname, '/public')));\n    app.use(express.static(path.join(__dirname, '/tests')));\n\n    if ('development' == app.get('env')) {\n        app.use(express.errorHandler());\n    }\n\n    http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express server listening on port ' + app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst morgan = require('morgan');\n\nfunction createServer() {\n  const app = express();\n  const server = http.createServer(app);\n\n  app.use(morgan('dev'));\n  app.use(express.json());\n  app.use(express.urlencoded({ extended: true }));\n  app.use(express.static('public'));\n\n  if (process.env.NODE_ENV === 'development') {\n    app.use((err, req, res, next) => {\n      res.status(500).json({ error: err.message, stack: err.stack });\n    });\n  } else {\n    app.use((err, req, res, next) => {\n      res.status(500).json({ error: 'Internal Server Error' });\n    });\n  }\n\n  const port = process.env.PORT || 3000;\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with essential middleware (CORS, static file serving, JSON body parsing), configures route handlers, and starts listening on a specified port. It handles both API routes and serves static HTML files.\n\nInput: None (The function uses imported modules and configuration from './src/config' and './src/routes')\n\nOutput: None (The function's side effect is starting an HTTP server that listens on the configured port)",
    "Canonical_solution": "function setupExpressServer() {\n    const bodyParser = require('body-parser');\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const config = require('./src/config');\n    const routes = require('./src/routes');\n\n    const app = express();\n\n    app.enable('trust proxy');\n    app.use(cors());\n    app.use(express.static(path.join(__dirname, 'www')));\n    app.use(bodyParser.json());\n\n    app.get('/v2', (req, res) => res.sendFile(path.join(__dirname, 'www/index.html')));\n    app.use(routes);\n\n    app.listen(config.PORT, err => {\n        if (err) console.error(err);\n        console.log('Server started on ' + config.PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "function setupExpressServer() {\n  const express = require('express');\n  const cors = require('cors');\n  const config = require('./src/config');\n  const routes = require('./src/routes');\n  \n  const app = express();\n  \n  app.use(cors());\n  app.use(express.json());\n  app.use(express.static('public'));\n  \n  app.use('/api', routes);\n  \n  app.listen(config.port, () => {\n    console.log(`Server running on port ${config.port}`);\n  });\n}"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a target API while modifying request and response headers.\n\nFunction Description: The function `createProxyServer` initializes an Express application that acts as a proxy server. It configures middleware to forward all incoming requests to a specified target API (https://api.openai.com in this case), removes certain headers from outgoing requests, and adds CORS headers to responses. The server listens on port 9000 by default.\n\nInput: None (The function takes no parameters as all configurations are hardcoded)\n\nOutput: None (The function doesn't return anything but starts a server process that continues running)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('http-proxy-middleware');\n    const app = express();\n    const port = 9000;\n\n    app.use('/', createProxyMiddleware({\n        target: 'https://api.openai.com',\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('x-forwarded-for');\n            proxyReq.removeHeader('x-real-ip');\n        },\n        onProxyRes: function (proxyRes, req, res) {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n        }\n    }));\n\n    app.listen(port, () => {\n        console.log(`Example app listening at http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nfunction createProxyServer() {\n  const app = express();\n\n  const proxy = createProxyMiddleware({\n    target: 'https://api.openai.com',\n    changeOrigin: true,\n    onProxyReq: (proxyReq, req, res) => {\n      delete proxyReq.headers['host'];\n      delete proxyReq.headers['connection'];\n      delete proxyReq.headers['origin'];\n    },\n    onProxyRes: (proxyRes, req, res) => {\n      res.setHeader('Access-Control-Allow-Origin', '*');\n      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n      res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    },\n  });\n\n  app.use('/', proxy);\n  app.listen(9000, () => {\n    console.log('Proxy server running on port 9000');\n  });\n}\n\ncreateProxyServer();"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const fs = require('fs');\nconst crypto = require('crypto');\n\nclass TSClient {\n  constructor(query, cb) {\n    this.id = crypto.createHash('md5').update(query).digest('hex');\n    this.search = {\n      q: query,\n      since_id: '',\n      rcount: 0,\n      id: this.id\n    };\n    try {\n      const data = fs.readFileSync(`tsclient_state_${this.id}.json`, 'utf8');\n      const saved = JSON.parse(data);\n      this.search = { ...this.search, ...saved };\n    } catch (e) {}\n    this.new_since_id = '';\n    cb(this);\n  }\n\n  syncSearch(callback) {\n    this.new_since_id = '';\n    this._walker({\n      ts: this,\n      search: { ...this.search },\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: ''\n    });\n  }\n\n  set(search) {\n    this.search = { ...this.search, ...search };\n    fs.writeFileSync(`tsclient_state_${this.id}.json`, JSON.stringify(this.search));\n  }\n\n  _walker(s) {\n    const params = {\n      q: s.search.q,\n      since_id: s.search.since_id,\n      count: 100\n    };\n    if (s.search.max_id) {\n      params.max_id = s.search.max_id;\n    }\n\n    setTimeout(() => {\n      try {\n        const tweets = [];\n        const next_max_id = null;\n\n        s.results.push(...tweets);\n\n        tweets.forEach(tweet => {\n          if (!s.new_since_id || tweet.id_str > s.new_since_id) {\n            s.new_since_id = tweet.id_str;\n          }\n        });\n\n        if (next_max_id) {\n          s.search.max_id = next_max_id;\n          s.page += 1;\n          this._walker(s);\n        } else {\n          if (s.new_since_id) {\n            const currentRCount = s.ts.search.rcount || 0;\n            const addedResults = s.results.length;\n            s.ts.set({ since_id: s.new_since_id, rcount: currentRCount + addedResults });\n          }\n          s.cb(s.results);\n        }\n      } catch (err) {\n        s.cb([]);\n      }\n    }, 0);\n  }\n}"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst path = require('path');\n\nfunction createExpressServer() {\n  const app = express();\n  app.use(express.static(path.join(__dirname, '..')));\n  const routes = require('./routes');\n  app.use(routes);\n  const port = process.env.PORT || 3000;\n  const server = app.listen(port, () => {\n    console.log(`Server started on port ${port}`);\n  });\n  return server;\n}\n\nmodule.exports = createExpressServer;"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function uploads a specified file to a server using Node.js's filesystem and HTTP modules. It streams the file content directly to the HTTP request using pipe(), avoiding loading the entire file into memory. The function sets appropriate headers including content-type (multipart/form-data) and content-length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart form data\n\nOutput: None (The function makes an HTTP request but doesn't return any value. The actual upload result would be handled by the server's response, which isn't captured in this function.)",
    "Canonical_solution": "function uploadFile() {\n  const fs = require('fs');\n  const http = require('http');\n  \n  const stat = fs.statSync(FIXTURE);\n  const request = http.request({\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'content-length': stat.size,\n    },\n  });\n  \n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "const fs = require('fs');\nconst path = require('path');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const filename = path.basename(FIXTURE);\n  const stats = fs.statSync(FIXTURE);\n  const fileSize = stats.size;\n\n  const initialHeader = `--${BOUNDARY}\\r\\nContent-Disposition: form-data; name=\"file\"; filename=\"${filename}\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n`;\n  const closingBoundary = `\\r\\n--${BOUNDARY}--\\r\\n`;\n\n  const contentLength = Buffer.byteLength(initialHeader) + fileSize + Buffer.byteLength(closingBoundary);\n\n  const req = http.request({\n    hostname: 'localhost',\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': contentLength\n    }\n  });\n\n  req.on('error', (err) => {\n    console.error(`Request error: ${err.message}`);\n  });\n\n  req.write(initialHeader);\n\n  const fileStream = fs.createReadStream(FIXTURE);\n  fileStream.pipe(req, { end: false });\n\n  fileStream.on('end', () => {\n    req.write(closingBoundary);\n    req.end();\n  });\n}"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Implement a function to upload a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function should create a readable stream from a specified file and pipe it directly to an HTTP POST request. This approach avoids loading the entire file into memory, making it suitable for large files. The function should set appropriate headers including content type (multipart/form-data) and content length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart/form-data content type\n\nOutput: None (The function streams the file directly to the HTTP request without returning any value)",
    "Canonical_solution": "function uploadFile() {\n  var fs = require('fs'),\n      http = require('http'),\n      stat = fs.statSync(FIXTURE),\n      request = http.request({\n        port: TEST_PORT,\n        path: '/',\n        method: 'POST',\n        headers: {\n          'content-type': 'multipart/form-data; boundary='+BOUNDARY,\n          'content-length': stat.size,\n        },\n      });\n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "const fs = require('fs');\nconst http = require('http');\nconst path = require('path');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n    const stats = fs.statSync(FIXTURE);\n    const fileSize = stats.size;\n    const filename = path.basename(FIXTURE);\n    \n    const headerStr = `--${BOUNDARY}\\r\\nContent-Disposition: form-data; name=\"file\"; filename=\"${filename}\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n`;\n    const closingStr = `\\r\\n--${BOUNDARY}--\\r\\n`;\n    \n    const headerLen = Buffer.byteLength(headerStr);\n    const closingLen = Buffer.byteLength(closingStr);\n    const contentLength = headerLen + fileSize + closingLen;\n    \n    const req = http.request({\n        hostname: 'localhost',\n        port: TEST_PORT,\n        path: '/',\n        method: 'POST',\n        headers: {\n            'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n            'Content-Length': contentLength\n        }\n    });\n    \n    req.write(headerStr);\n    \n    const fileStream = fs.createReadStream(FIXTURE);\n    fileStream.pipe(req, { end: false });\n    \n    fileStream.on('end', () => {\n        req.end(closingStr);\n    });\n    \n    fileStream.on('error', (err) => {\n        req.abort();\n    });\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "const request = require('request');\n\nfunction makeHttpRequest() {\n  const options = {\n    url: 'https://api.example.com/endpoint',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer YOUR_SECRET_TOKEN',\n      'X-Custom-Header': 'HeaderValue'\n    },\n    body: JSON.stringify({\n      username: 'demo',\n      action: 'submit'\n    })\n  };\n\n  request(options, (error, response, body) => {\n    if (error) {\n      console.error('HTTP Request Error:', error);\n    } else {\n      console.log('Server Response:', body);\n    }\n  });\n}"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a JavaScript class that implements a server capable of handling HTTP requests and piping data to responses, with support for live reload functionality and error handling.\n\nClass Description: The `Server` class is designed to create an HTTP server that can handle incoming requests, pipe data to responses (particularly for live reload functionality), and manage server lifecycle events. It supports both standalone operation and integration with existing Express-like applications.\n\nAttributes:\n- options: [Object] - Configuration options for the server including livereload file path and port number.\n- clients: [Object] - Storage for connected clients (used for live reload functionality).\n- server: [http.Server] - The underlying HTTP server instance.\n- app: [Object] - Optional Express-like application instance for integration.\n- port: [Number] - The port number the server is listening on.\n\nMethods:\n- constructor(options) -> [Server] - Initializes the server with given options, setting defaults for livereload path and port.\n- configure(app) -> [Server] - Configures the server to work with an existing Express-like application.\n- handler(req, res, next) -> [Server] - Handles incoming HTTP requests, supporting both middleware and direct handling modes.\n- livereload(req, res) -> [void] - Pipes the livereload JavaScript file to the response.\n- listen(port, fn) -> [void] - Starts the server listening on the specified port.\n- close(req, res) -> [void] - Closes the server and optionally ends a response.\n- error(e) -> [void] - Handles and logs server errors.\n\nNote: The class demonstrates inter-process communication through HTTP and file system operations, particularly in the `livereload` method where it pipes file contents directly to HTTP responses.",
    "Canonical_solution": "var fs = require('fs');\nvar http = require('http');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.options.livereload = this.options.livereload || path.join(__dirname, 'public/livereload.js');\n    this.options.port = parseInt(this.options.port || 35729, 10);\n    this.clients = {};\n    this.configure(this.options.app);\n  }\n\n  configure(app) {\n    if(!app) {\n      this.server = http.createServer(this.handler.bind(this));\n      this.server.on('error', this.error.bind(this));\n      return this;\n    }\n\n    var self = this;\n    this.app = app;\n\n    this.app.listen = function(port, done) {\n      done = done || function() {};\n      var srv = self.server = http.createServer(app);\n      srv.on('error', self.error.bind(self));\n      srv.on('close', self.close.bind(self));\n      return srv.listen(port, done);\n    };\n\n    return this;\n  }\n\n  handler(req, res, next) {\n    var middleware = typeof next === 'function';\n    if(middleware) {\n      this.handle(req, res, next);\n      return this;\n    }\n\n    req\n      .on('end', this.handle.bind(this, req, res))\n      .on('data', function(chunk) {\n        req.data = req.data || '';\n        req.data += chunk;\n      });\n\n    return this;\n  }\n\n  livereload(req, res) {\n    fs.createReadStream(this.options.livereload).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port;\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if(res) res.end();\n    if(this.server._handle) this.server.close();\n  }\n\n  error(e) {\n    console.error('Error:', e.message);\n    console.error(e.stack);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options = {}) {\n    this.options = {\n      livereloadPath: options.livereloadPath || '/livereload.js',\n      livereloadFile: options.livereloadFile || path.join(__dirname, 'livereload.js'),\n      port: options.port || 35729\n    };\n    this.clients = {};\n    this.server = null;\n    this.app = null;\n    this.port = this.options.port;\n  }\n\n  configure(app) {\n    this.app = app;\n    return this;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      return this.app(req, res, next);\n    }\n    if (req.url === this.options.livereloadPath) {\n      return this.livereload(req, res);\n    }\n    res.writeHead(404).end('Not Found');\n    if (next) return next();\n  }\n\n  livereload(req, res) {\n    res.setHeader('Content-Type', 'application/javascript');\n    fs.createReadStream(this.options.livereloadFile)\n      .on('error', (err) => {\n        res.statusCode = 500;\n        res.end('Internal Server Error');\n        this.error(err);\n      })\n      .pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port || this.port;\n    this.server = http.createServer(this.handler.bind(this));\n    this.server.on('error', this.error.bind(this));\n    this.server.listen(this.port, fn);\n  }\n\n  close(req, res) {\n    if (this.server) {\n      this.server.close(() => {\n        if (res) {\n          res.end();\n        }\n      });\n    }\n  }\n\n  error(e) {\n    console.error('Server Error:', e.stack || e.message || e);\n  }\n}\n\nmodule.exports = Server;"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement an OAuth server class that handles GitHub OAuth authentication flow, including starting a server to receive the authorization code and exchanging it for an access token.\n\nClass Description: The OAuthServer class represents a server that facilitates GitHub OAuth authentication. It creates an Express server to handle the OAuth callback, exchanges the authorization code for an access token using GitHub's API, and provides methods to start and stop the server.\n\nAttributes:\n- options: [Object] - Configuration object containing client credentials and server settings\n- prompt: [Object] - Reference to an external prompt object used to signal completion of authentication\n- app: [Object] - Express application instance for handling HTTP requests\n- server: [Object] - HTTP server instance created by Express\n- token: [String|null] - Stores the obtained OAuth access token\n\nMethods:\n- constructor(options) -> [OAuthServer] - Initializes the OAuth server with configuration options and sets up the Express route for handling OAuth callbacks\n- start() -> [Promise] - Starts the HTTP server on the configured port and returns a promise that resolves when the server is ready or rejects on error\n- stop() -> [void] - Stops the HTTP server and cleans up resources",
    "Canonical_solution": "const express = require('express');\nconst axios = require('axios');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = this.options.prompt;\n    this.app = express();\n    this.app.get('/', (req, res) => {\n      const code = req.query.code;\n      axios\n        .post(\n          `https://github.com/login/oauth/access_token?client_secret=${\n            this.options.client_secret\n          }&client_id=${this.options.client_id}&code=${code}`,\n          {},\n          {\n            headers: {\n              Accept: 'application/json'\n            }\n          }\n        )\n        .then(response => {\n          const accessToken = response.data.access_token;\n          this.token = accessToken;\n          res.send('Enquirer: Github OAuth Server is up');\n          this.prompt.submit();\n        })\n        .catch(e => console.log('axios error', e));\n    });\n    this.token = null;\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, err => {\n        if (err) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  stop() {\n    this.server.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "const express = require('express');\nconst https = require('https');\nconst { URLSearchParams } = require('url');\n\nclass OAuthServer {\n  constructor(options) {\n    this.options = options;\n    this.prompt = options.prompt;\n    this.app = express();\n    this.server = null;\n    this.token = null;\n    this.app.get('/oauth/callback', this.handleOAuthCallback.bind(this));\n  }\n\n  async handleOAuthCallback(req, res) {\n    const code = req.query.code;\n    if (!code) {\n      return res.status(400).send('Authorization code missing');\n    }\n    const postData = new URLSearchParams({\n      client_id: this.options.clientId,\n      client_secret: this.options.clientSecret,\n      code,\n      redirect_uri: this.options.redirectUri\n    }).toString();\n    const requestOptions = {\n      hostname: 'github.com',\n      path: '/login/oauth/access_token',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(postData),\n        'Accept': 'application/json'\n      }\n    };\n    try {\n      const request = https.request(requestOptions, (response) => {\n        let data = '';\n        response.on('data', (chunk) => data += chunk);\n        response.on('end', () => {\n          try {\n            const parsed = JSON.parse(data);\n            this.token = parsed.access_token;\n            this.prompt.resolve(this.token);\n            res.send('Authentication successful! You can close this window.');\n          } catch (error) {\n            console.error('Token parsing failed:', error);\n            res.status(500).send('Failed to parse token response');\n          }\n        });\n      });\n      request.on('error', (error) => {\n        console.error('Token exchange request failed:', error);\n        res.status(500).send('Token exchange failed');\n      });\n      request.write(postData);\n      request.end();\n    } catch (error) {\n      console.error('Unexpected error during callback:', error);\n      res.status(500).send('Internal server error');\n    }\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.options.port, () => {\n        resolve();\n      });\n      this.server.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n    }\n  }\n}\n\nmodule.exports = OAuthServer;"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst mimeTypes = require('mime-types');\n\nfunction createFileServer() {\n    const server = http.createServer((req, res) => {\n        try {\n            const requestUrl = new URL(req.url, 'http://localhost:1338');\n            let pathname = decodeURIComponent(requestUrl.pathname);\n            \n            const staticDir = path.join(process.cwd(), 'static');\n            const filePath = path.resolve(staticDir, '.' + pathname);\n            \n            if (!filePath.startsWith(staticDir)) {\n                res.writeHead(403, { 'Content-Type': 'text/plain' });\n                res.end('Forbidden', 'utf-8');\n                return;\n            }\n            \n            if (!fs.existsSync(filePath)) {\n                res.writeHead(404, { 'Content-Type': 'text/plain' });\n                res.end('Not Found', 'utf-8');\n                return;\n            }\n            \n            const stats = fs.statSync(filePath);\n            if (stats.isDirectory()) {\n                const indexFilePath = path.join(filePath, 'index.html');\n                if (fs.existsSync(indexFilePath)) {\n                    filePath = indexFilePath;\n                } else {\n                    res.writeHead(404, { 'Content-Type': 'text/plain' });\n                    res.end('Not Found', 'utf-8');\n                    return;\n                }\n            }\n            \n            const mimeType = mimeTypes.lookup(filePath) || 'application/octet-stream';\n            const fileContent = fs.readFileSync(filePath);\n            \n            res.writeHead(200, { 'Content-Type': mimeType });\n            res.end(fileContent);\n        } catch (err) {\n            res.writeHead(500, { 'Content-Type': 'text/plain' });\n            res.end('Internal Server Error', 'utf-8');\n        }\n    });\n    \n    server.listen(1338, 'localhost', () => {\n        console.log('Server running at http://localhost:1338/');\n    });\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "const crypto = require('crypto');\nconst fetch = require('node-fetch');\n\nclass TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  async taskRequest(method, url, body = '') {\n    const timestamp = Date.now().toString();\n    const dataToSign = method.toUpperCase() + url + timestamp + body;\n    const signature = crypto.createHmac('sha256', this.token)\n      .update(dataToSign)\n      .digest('base64');\n\n    const headers = {\n      'Authorization': `Bearer ${this.token}`,\n      'X-DID': this.did,\n      'X-Fingerprint': this.finger,\n      'OAID': this.oaid,\n      'X-Timestamp': timestamp,\n      'X-Signature': signature\n    };\n\n    if (method.toLowerCase() === 'post') {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const options = {\n      method: method.toUpperCase(),\n      headers,\n      body: method.toLowerCase() === 'post' ? body : undefined\n    };\n\n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Request failed: ${error.message}`);\n    }\n  }\n}"
  },
  {
    "Task_id": 160,
    "Instruction": "Task Description: Create a TCP server using Node.js's built-in 'net' module that listens on an available port and discards any incoming data.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that automatically binds to an available port. It discards any incoming data to ensure the server can terminate properly. The server's port is stored in the instance for later reference.\n\nInput: None\n\nOutput: None (The function modifies the instance properties, specifically setting `this.server` and `this.port`)",
    "Canonical_solution": "function createTCPServer() {\n  const net = require('net');\n  this.server = net.createServer((socket) => {\n    socket.on('data', () => {\n      // discard any buffered data or the server wont terminate\n    });\n  });\n  this.server.listen(() => {\n    this.port = this.server.address().port;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "const net = require('net');\nfunction createTCPServer() {\n  this.server = net.createServer((socket) => {\n    socket.resume();\n  });\n  this.server.listen(0, () => {\n    this.port = this.server.address().port;\n  });\n}"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a TCP server in Node.js that handles client connections, processes incoming data in batches, and forwards each batch to an external service for processing.\n\nFunction Description: The function `createTCPServer` initializes a TCP server that listens on port 5000. When a client connects, it sets up a bidirectional communication channel where incoming data from the client is collected in batches (separated by '.'). Each complete batch is then sent to an external 'uppercase' service via a REQ socket. The server handles data streaming and batch processing efficiently.\n\nInput: None (The function takes no parameters; configuration is hardcoded)\n\nOutput: None (The function creates a server instance that runs indefinitely, listening for connections)\n\n---\n\nIf you'd prefer the class format (though the reference code is function-based):\n\nTask Description: Implement a TCP server class in Node.js that manages client connections and batch processing of incoming data.\n\nClass Description: The `TCPServer` class encapsulates a TCP server that listens for client connections, collects incoming data in batches, and forwards complete batches to an external service.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- port: [number] - The port number the server listens on (default: 5000)\n\nMethods:\n- constructor([port: number]) -> void - Initializes the server with optional port configuration\n- start() -> void - Starts the server and begins listening for connections\n- handleConnection(conn: net.Socket) -> void - Internal method to manage client connections and data processing\n- processBatch(batch: string[]) -> void - Sends a complete batch to the external service",
    "Canonical_solution": "function createTCPServer() {\n    var server = require('net').createServer();\n    server.on('connection', function(conn) {\n        conn.setEncoding('utf8');\n        \n        var req = context.socket('REQ');\n        req.setEncoding('utf8');\n        req.pipe(conn);\n        req.connect('uppercase');\n        \n        var batch = [];\n        var ask = function (q) {\n            req.write(q, 'utf8');\n        }\n        function readBatch() {\n            var msg; while (msg = conn.read()) {\n                msg.split('\\n').forEach(function(item) {\n                    if (item == '.') {\n                        console.log('Sending batch %s', batch);\n                        batch.forEach(ask);\n                        batch = [];\n                    }\n                    else if (item != '') {\n                        batch.push(item);\n                    }\n                });\n            }\n        }\n        conn.on('readable', readBatch);\n        readBatch();\n    });\n    server.listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "const net = require('net');\nconst zmq = require('zmq');\n\nclass TCPServer {\n    constructor(port = 5000) {\n        this.port = port;\n        this.server = net.createServer(this.handleConnection.bind(this));\n        this.zmqSocket = zmq.socket('req');\n        this.zmqSocket.connect('tcp://localhost:5555');\n        this.lastPromise = Promise.resolve();\n    }\n\n    start() {\n        this.server.listen(this.port, () => {\n            console.log(`TCP server started on port ${this.port}`);\n        });\n    }\n\n    handleConnection(conn) {\n        let buffer = '';\n        conn.on('data', (data) => {\n            buffer += data.toString();\n            let index;\n            while ((index = buffer.indexOf('.')) !== -1) {\n                const batch = buffer.slice(0, index);\n                buffer = buffer.slice(index + 1);\n                this.lastPromise = this.lastPromise.then(() => this.processBatch(batch));\n            }\n        });\n    }\n\n    async processBatch(batch) {\n        try {\n            await this.zmqSocket.send(batch);\n            await this.zmqSocket.recv();\n        } catch (err) {\n            console.error(`Batch processing error: ${err}`);\n        }\n    }\n}\n\nconst server = new TCPServer();\nserver.start();"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a POP3 server class in Node.js that handles secure and non-secure connections, manages client connections, and provides event-driven communication.\n\nClass Description: The POP3Server class extends EventEmitter to create a TCP server that can handle both regular and TLS-secured POP3 connections. It manages client connections and emits events for server lifecycle and errors.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- connections: [Set] - Tracks active client connections\n- server: [net.Server|tls.Server] - The underlying TCP/TLS server instance\n\nMethods:\n- constructor(options) -> [void] - Initializes the server with optional configuration\n- _setListeners() -> [void] - Sets up event listeners for the server\n- _onListening() -> [void] - Handles the 'listening' event\n- _onClose() -> [void] - Handles the 'close' event\n- _onError(err) -> [void] - Handles the 'error' event\n- connect(socket, socketOptions) -> [void] - Creates and manages a new client connection\n- listen(...args) -> [void] - Starts the server listening on specified port\n- close(callback) -> [void] - Stops the server and invokes callback when closed",
    "Canonical_solution": "const EventEmitter = require('events');\nconst net = require('net');\nconst tls = require('tls');\n\nclass POP3Server extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.options = options || {};\n        this.connections = new Set();\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket => {\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    this.connect(socket, socketOptions);\n                });\n            });\n        }\n\n        this._setListeners();\n    }\n\n    _setListeners() {\n        this.server.on('listening', () => this._onListening());\n        this.server.on('close', () => this._onClose());\n        this.server.on('error', err => this._onError(err));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new POP3Connection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.once('error', err => {\n            this.connections.delete(connection);\n            this._onError(err);\n        });\n        connection.once('close', () => {\n            this.connections.delete(connection);\n        });\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            if (typeof callback === 'function') {\n                return callback();\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "const net = require('net');\nconst tls = require('tls');\nconst EventEmitter = require('events');\n\nclass POP3Server extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.options = { ...options, secure: !!options.secure };\n    const Server = this.options.secure ? tls.Server : net.Server;\n    this.server = new Server(this.options.secure ? this.options : undefined);\n    this.connections = new Set();\n    this._setListeners();\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n    this.server.on('connection', (socket) => {\n      this.connect(socket, { secure: this.options.secure });\n    });\n  }\n\n  _onListening() {\n    this.emit('listening');\n  }\n\n  _onClose() {\n    this.emit('close');\n  }\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  connect(socket, socketOptions) {\n    const client = new Client(socket, socketOptions);\n    this.connections.add(client);\n    client.on('close', () => {\n      this.connections.delete(client);\n    });\n    this.emit('connection', client);\n  }\n\n  listen(...args) {\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    if (callback) {\n      this.once('close', callback);\n    }\n    this.server.close();\n  }\n}\n\nmodule.exports = POP3Server;"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    if (unsplashClientId) {\n      try {\n        const data = await this.fetchUnsplashWallpaper(unsplashClientId);\n        return { type: 'unsplash', data };\n      } catch (error) {\n      }\n    }\n    try {\n      const data = await this.fetchBingWallpaper();\n      return { type: 'bing', data };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: 'https://example.com/default.jpg',\n          copyright: 'Default Wallpaper'\n        }]\n      };\n    }\n  }\n  static async fetchUnsplashWallpaper(clientId) {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 5000);\n    const response = await fetch('https://api.unsplash.com/photos/random?count=1', {\n      headers: {\n        'Authorization': `Client-ID ${clientId}`\n      },\n      signal: controller.signal\n    });\n    clearTimeout(timeout);\n    if (!response.ok) {\n      throw new Error('Unsplash API error');\n    }\n    return await response.json();\n  }\n  static async fetchBingWallpaper() {\n    const response = await fetch('https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1');\n    if (!response.ok) {\n      throw new Error('Bing API error');\n    }\n    const data = await response.json();\n    if (!data || !data.images || !Array.isArray(data.images) || data.images.length === 0) {\n      throw new Error('Invalid Bing response');\n    }\n    return data.images.map(image => ({\n      ...image,\n      url: 'https://bing.com' + image.url\n    }));\n  }\n}"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Write a function that fetches version information and schema data from a remote API, caches the results locally, and handles errors appropriately.\n\nFunction Description: The function `fetchAndCacheVersions` retrieves version data from a specified API endpoint, then fetches schema data for each non-deprecated version. It caches all retrieved data in JSON files in a local directory. Errors during the process are caught and logged, with the process exiting on failure.\n\nInput: None (The function takes no parameters; all URLs and paths are hardcoded)\n\nOutput: \n- Success: Writes JSON files to the cache directory and logs success messages\n- Failure: Logs error messages and exits the process with status code 1",
    "Canonical_solution": "function fetchAndCacheVersions() {\n    const axios = require('axios');\n    const { writeJsonSync } = require('fs-extra');\n    const path = require('path');\n\n    axios\n        .get('https://exp.host/--/versions')\n        .then(async ({ data }) => {\n            writeJsonSync(path.join(__dirname, '../caches/versions.json'), data);\n\n            for (const version of Object.keys(data.sdkVersions)) {\n                if (data.sdkVersions[version].isDeprecated) {\n                    continue;\n                }\n                const {\n                    data: { data: schema },\n                } = await axios.get(`https://exp.host/--/api/v2/project/configuration/schema/${version}`);\n\n                const filePath = path.join(__dirname, `../caches/schema-${version}.json`);\n                console.log('Writing', filePath);\n                writeJsonSync(filePath, schema);\n            }\n        })\n        .then(() => console.log('Caches updated.'))\n        .catch(error => {\n            console.error(error);\n            console.error('Updating caches failed.');\n            process.exit(1);\n        });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const fetch = require('node-fetch');\nconst fs = require('fs/promises');\nconst path = require('path');\n\nconst VERSIONS_URL = 'https://api.example.com/versions';\nconst SCHEMA_URL_BASE = 'https://api.example.com/schema/';\nconst CACHE_DIR = './cache';\nconst SCHEMA_DIR = path.join(CACHE_DIR, 'schemas');\nconst VERSIONS_FILE_PATH = path.join(CACHE_DIR, 'versions.json');\n\nasync function fetchAndCacheVersions() {\n    try {\n        const versionsResponse = await fetch(VERSIONS_URL);\n        if (!versionsResponse.ok) {\n            throw new Error(`Failed to fetch versions: ${versionsResponse.status} ${versionsResponse.statusText}`);\n        }\n        const versions = await versionsResponse.json();\n\n        await fs.mkdir(CACHE_DIR, { recursive: true });\n        await fs.mkdir(SCHEMA_DIR, { recursive: true });\n\n        await fs.writeFile(VERSIONS_FILE_PATH, JSON.stringify(versions, null, 2));\n\n        for (const version of versions) {\n            if (version.deprecated) continue;\n\n            const schemaUrl = `${SCHEMA_URL_BASE}${version.name}`;\n            const schemaResponse = await fetch(schemaUrl);\n            if (!schemaResponse.ok) {\n                throw new Error(`Failed to fetch schema for ${version.name}: ${schemaResponse.status} ${schemaResponse.statusText}`);\n            }\n            const schema = await schemaResponse.json();\n            const schemaFilePath = path.join(SCHEMA_DIR, `${version.name}.json`);\n            await fs.writeFile(schemaFilePath, JSON.stringify(schema, null, 2));\n        }\n\n        console.log('Successfully fetched and cached all versions and schemas.');\n    } catch (error) {\n        console.error(`Error: ${error.message}`);\n        process.exit(1);\n    }\n}"
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Implement a UDP-based server discovery system that allows servers to broadcast their presence and receive information about other nearby servers on the network.\n\nClass Description: The class provides functionality for UDP-based server discovery, including broadcasting server presence (heartbeats) and listening for broadcasts from other servers. It maintains a list of discovered servers and handles network communication errors.\n\nAttributes:\n- nearbyServers: [Object] - A dictionary storing information about discovered nearby servers, keyed by hostname.\n- lastDiscoveryBroadcast: [Number] - Timestamp of the last broadcast sent by this server.\n- broadcastIP: [String] - The broadcast IP address used for sending discovery messages.\n- discoveryListener: [Object] - The UDP socket instance used for listening to discovery messages.\n\nMethods:\n- setupDiscovery([callback: Function]) -> [void] - Initializes the UDP listener socket and binds it to the configured port. The optional callback is executed when binding is complete.\n- discoveryBroadcast([type: String, message: Object, callback: Function]) -> [void] - Creates a UDP client to broadcast a message of the specified type. The message should be an object that will be stringified to JSON. The optional callback is executed after the message is sent.\n- discoveryReceive([msg: Buffer, rinfo: Object]) -> [void] - Handles incoming UDP messages, parsing them as JSON and processing different message types (currently only 'heartbeat' is implemented). Updates the nearbyServers list when valid messages are received.\n- shutdownDiscovery() -> [void] - Closes the UDP listener socket if it exists, cleaning up network resources.\n- calcBroadcastIP() -> [String] - (Implied but not shown) Calculates the broadcast IP address based on network interfaces.",
    "Canonical_solution": "var dgram = require(\"dgram\");\nvar os = require('os');\nvar Netmask = require('netmask').Netmask;\n\nvar Class = require(\"pixl-class\");\nvar Tools = require(\"pixl-tools\");\n\nmodule.exports = Class.create({\n\t\n\tnearbyServers: null,\n\tlastDiscoveryBroadcast: 0,\n\t\n\tsetupDiscovery: function(callback) {\n\t\tvar self = this;\n\t\t\n\t\tthis.nearbyServers = {};\n\t\tthis.lastDiscoveryBroadcast = 0;\n\t\t\n\t\tif (!this.server.config.get('udp_broadcast_port')) {\n\t\t\tif (callback) callback();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.broadcastIP = this.server.config.get('broadcast_ip') || this.calcBroadcastIP();\n\t\t\n\t\tvar listener = this.discoveryListener = dgram.createSocket(\"udp4\");\n\t\t\n\t\tlistener.on(\"message\", function (msg, rinfo) {\n\t\t\tself.discoveryReceive( msg, rinfo );\n\t\t} );\n\t\t\n\t\tlistener.on(\"error\", function (err) {\n\t\t\tself.logError('udp', \"UDP socket listener error: \" + err);\n\t\t\tself.discoveryListener = null;\n\t\t} );\n\t\t\n\t\tlistener.bind( this.server.config.get('udp_broadcast_port'), function() {\n\t\t\tif (callback) callback();\n\t\t} );\n\t},\n\t\n\tdiscoveryBroadcast: function(type, message, callback) {\n\t\tvar self = this;\n\t\t\n\t\tmessage.action = type;\n\t\t\n\t\tvar client = dgram.createSocket('udp4');\n\t\tvar message = Buffer.from( JSON.stringify(message) + \"\\n\" );\n\t\tclient.bind( 0, function() {\n\t\t\tclient.setBroadcast( true );\t\t\t\n\t\t\tclient.send(message, 0, message.length, self.server.config.get('udp_broadcast_port'), self.broadcastIP, function(err) {\n\t\t\t\tif (err) self.logDebug(9, \"UDP broadcast failed: \" + err);\n\t\t\t\tclient.close();\n\t\t\t\tif (callback) callback();\n\t\t\t} );\n\t\t} );\n\t},\n\t\n\tdiscoveryReceive: function(msg, rinfo) {\n\t\tvar text = msg.toString();\n\t\tif (text.match(/^\\{/)) {\n\t\t\tvar json = null;\n\t\t\ttry { json = JSON.parse(text); }\n\t\t\tcatch (e) {\n\t\t\t\tthis.logError(9, \"Failed to parse UDP JSON message: \" + e);\n\t\t\t}\n\t\t\tif (json && json.action) {\n\t\t\t\tswitch (json.action) {\n\t\t\t\t\tcase 'heartbeat':\n\t\t\t\t\t\tif (json.hostname && (json.hostname != this.server.hostname)) {\n\t\t\t\t\t\t\tjson.now = Tools.timeNow();\n\t\t\t\t\t\t\tdelete json.action;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!this.nearbyServers[ json.hostname ]) {\n\t\t\t\t\t\t\t\tthis.nearbyServers[ json.hostname ] = json;\n\t\t\t\t\t\t\t\tif (this.multi.master) {\n\t\t\t\t\t\t\t\t\tthis.logDebug(6, \"Discovered nearby server: \" + json.hostname, json);\n\t\t\t\t\t\t\t\t\tthis.authSocketEmit( 'update', { nearby: this.nearbyServers } );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.nearbyServers[ json.hostname ] = json;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\tshutdownDiscovery: function() {\n\t\tif (this.discoveryListener) {\n\t\t\tthis.discoveryListener.close();\n\t\t}\n\t}\n});",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "const dgram = require('dgram');\nconst os = require('os');\n\nclass ServerDiscovery {\n  constructor(port, broadcastPort) {\n    this.nearbyServers = {};\n    this.lastDiscoveryBroadcast = 0;\n    this.broadcastIP = this.calcBroadcastIP();\n    this.discoveryListener = null;\n    this.port = port;\n    this.broadcastPort = broadcastPort;\n  }\n\n  setupDiscovery(callback) {\n    this.discoveryListener = dgram.createSocket('udp4');\n    this.discoveryListener.setBroadcast(true);\n    this.discoveryListener.bind(this.port, () => {\n      if (callback) callback();\n    });\n    this.discoveryListener.on('message', (msg, rinfo) => this.discoveryReceive(msg, rinfo));\n  }\n\n  discoveryBroadcast(type, message, callback) {\n    if (!this.discoveryListener) {\n      if (callback) callback(new Error('Socket not initialized'));\n      return;\n    }\n    const payload = JSON.stringify({ type, message });\n    const buffer = Buffer.from(payload);\n    this.discoveryListener.send(buffer, 0, buffer.length, this.broadcastPort, this.broadcastIP, (err) => {\n      if (callback) callback(err);\n    });\n    this.lastDiscoveryBroadcast = Date.now();\n  }\n\n  discoveryReceive(msg, rinfo) {\n    try {\n      const data = JSON.parse(msg.toString());\n      if (data.type === 'heartbeat') {\n        const serverInfo = data.message;\n        const hostname = serverInfo.hostname;\n        if (!hostname) return;\n        this.nearbyServers[hostname] = {\n          ...serverInfo,\n          lastSeen: Date.now(),\n          address: rinfo.address\n        };\n      }\n    } catch (e) {}\n  }\n\n  shutdownDiscovery() {\n    if (this.discoveryListener) {\n      this.discoveryListener.close();\n      this.discoveryListener = null;\n    }\n  }\n\n  calcBroadcastIP() {\n    const interfaces = os.networkInterfaces();\n    let broadcastIP = '255.255.255.255';\n    for (const name of Object.keys(interfaces)) {\n      for (const iface of interfaces[name]) {\n        if (iface.family === 'IPv4' && !iface.internal) {\n          const ipParts = iface.address.split('.').map(Number);\n          const maskParts = iface.netmask.split('.').map(Number);\n          const broadcastParts = ipParts.map((ip, i) => (ip | ~maskParts[i]) & 0xff);\n          return broadcastParts.join('.');\n        }\n      }\n    }\n    return broadcastIP;\n  }\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a reusable HTTP client class that simplifies making HTTP requests using Axios, with support for common methods like GET and POST, while handling errors consistently.\n\nClass Description: The HTTPClient class encapsulates Axios functionality to provide a clean interface for making HTTP requests. It maintains headers across requests and provides methods for GET and POST operations with error handling.\n\nAttributes:\n- headers: Object - Contains HTTP headers to be sent with every request\n\nMethods:\n- constructor(headers: Object) -> void - Initializes the HTTP client with default headers\n- get(url: String, params: Object = {}) -> Promise<Object> - Sends a GET request to the specified URL with optional query parameters, returns response data or throws error\n- post(url: String, data: Object = {}, params: Object = {}) -> Promise<Object> - Sends a POST request to the specified URL with optional request body and query parameters, returns response data or throws error",
    "Canonical_solution": "const axios = require('axios');\n\nclass HTTPClient {\n    constructor(headers) {\n        this.headers = headers;\n    }\n\n    async get(url, params = {}) {\n        try {\n            const response = await axios({\n                method: 'get',\n                url: url,\n                headers: this.headers,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('GET request failed:', error);\n            throw error;\n        }\n    }\n\n    async post(url, data = {}, params = {}) {\n        try {\n            const response = await axios({\n                method: 'post',\n                url: url,\n                headers: this.headers,\n                data: data,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('POST request failed:', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "const axios = require('axios');\n\nclass HTTPClient {\n  constructor(headers) {\n    this.axiosInstance = axios.create({ headers });\n  }\n\n  get(url, params = {}) {\n    return this.axiosInstance.get(url, { params }).then(res => res.data);\n  }\n\n  post(url, data = {}, params = {}) {\n    return this.axiosInstance.post(url, data, { params }).then(res => res.data);\n  }\n}\n\nmodule.exports = HTTPClient;"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a class that handles the downloading and installation of binary packages from a specified URL, including directory management and error handling.\n\nClass Description: The Binary class is responsible for downloading a binary package from a given URL, extracting it to a specified directory, and managing the installation process. It handles directory creation, file extraction, and provides feedback on the installation status.\n\nAttributes:\n- url: [String] - The URL from which the binary package will be downloaded.\n- name: [String] - The name of the binary package (optional, defaults to -1).\n- installDirectory: [String] - The base directory where the binary will be installed (optional, defaults to a 'bin' subdirectory in the current working directory).\n- binaryDirectory: [String] - The full path to the directory where the binary will be extracted (initialized as -1, set during installation).\n- binaryPath: [String] - The full path to the binary file (initialized as -1, not used in current implementation).\n\nMethods:\n- constructor(url, data) -> [None] - Initializes the Binary instance with the download URL and optional configuration data (name and installDirectory).\n- install() -> [Promise] - Handles the complete installation process including directory preparation, downloading, extraction, and cleanup. Returns a Promise that resolves when installation is complete or rejects on error.\n  - Internal method _getInstallDirectory() is used to determine the installation directory path.",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass Binary {\n    constructor(url, data) {\n        this.url = url;\n        this.name = data.name || -1;\n        this.installDirectory = data.installDirectory || join(__dirname, \"bin\");\n        this.binaryDirectory = -1;\n        this.binaryPath = -1;\n    }\n\n    install() {\n        const dir = this._getInstallDirectory();\n        if (!existsSync(dir)) {\n            mkdirSync(dir, { recursive: true });\n        }\n\n        this.binaryDirectory = join(dir, \"bin\");\n\n        if (existsSync(this.binaryDirectory)) {\n            rimraf.sync(this.binaryDirectory);\n        }\n\n        mkdirSync(this.binaryDirectory, { recursive: true });\n\n        console.log(`Downloading release from ${this.url}`);\n\n        return axios({ url: this.url, responseType: \"stream\" })\n            .then(res => {\n                const writer = tar.x({ strip: 1, C: this.binaryDirectory });\n\n                return new Promise((resolve, reject) => {\n                    res.data.pipe(writer);\n                    let error = null;\n                    writer.on('error', err => {\n                      error = err;\n                      reject(err);\n                    });\n                    writer.on('close', () => {\n                      if (!error) {\n                        resolve(true);\n                      }\n                    });\n                })\n            })\n            .then(() => {\n                console.log(\n                    `${this.name ? this.name : \"Your package\"} has been installed!`\n                );\n            })\n            .catch(e => {\n                error(`Error fetching release: ${e.message}`);\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "const fs = require('fs/promises');\nconst path = require('path');\nconst https = require('https');\nconst { promisify } = require('util');\nconst stream = require('stream');\nconst AdmZip = require('adm-zip');\n\nclass Binary {\n  constructor(url, data = {}) {\n    this.url = url;\n    this.name = data.name || -1;\n    this.installDirectory = data.installDirectory ? path.resolve(data.installDirectory) : path.resolve('bin');\n    this.binaryDirectory = -1;\n    this.binaryPath = -1;\n  }\n\n  _getInstallDirectory() {\n    return this.installDirectory;\n  }\n\n  async install() {\n    const installDir = this._getInstallDirectory();\n    await fs.mkdir(installDir, { recursive: true });\n\n    const tempFile = path.join(require('os').tmpdir(), `${this.name}.zip`);\n    \n    try {\n      await this._downloadFile(this.url, tempFile);\n      this._extractZip(tempFile, installDir);\n      await fs.unlink(tempFile);\n      this.binaryDirectory = installDir;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async _downloadFile(url, dest) {\n    return new Promise((resolve, reject) => {\n      const file = fs.createWriteStream(dest);\n      https.get(url, (response) => {\n        if (response.statusCode !== 200) {\n          reject(new Error(`Download failed: ${url} - Status ${response.statusCode}`));\n          return;\n        }\n        response.pipe(file);\n        file.on('finish', () => {\n          file.close(resolve);\n        });\n      }).on('error', (err) => {\n        fs.unlink(dest, () => reject(err));\n      });\n    });\n  }\n\n  _extractZip(src, dest) {\n    const zip = new AdmZip(src);\n    zip.extractAllTo(dest, true);\n  }\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "function testWebSocketConnection(wssUrl) {\n  const socket = new WebSocket('wss://' + wssUrl);\n\n  socket.onopen = function(event) {\n    console.log('Connection established');\n    socket.send(JSON.stringify({ type: 'connect', message: 'Connected to server' }));\n    socket.send(JSON.stringify({ type: 'test', message: 'Initial test message' }));\n  };\n\n  socket.onmessage = function(event) {\n    try {\n      const data = JSON.parse(event.data);\n      console.log('Received message:', data);\n    } catch (e) {\n      console.error('Error parsing JSON:', e);\n    }\n  };\n\n  socket.onerror = function(error) {\n    console.error('WebSocket error:', error);\n    socket.close();\n  };\n\n  socket.onclose = function(event) {\n    console.log('Connection closed:', event.reason || 'No reason provided');\n  };\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using HTTP POST request with error handling.\n\nFunction Description: The function `sendWebhook` is an asynchronous function that takes data as input and sends it to a predefined webhook URL using an HTTP POST request. It handles potential errors during the request and logs them to the console.\n\nInput: \n- `data` [Object] - The payload/data to be sent to the webhook URL.\n\nOutput: \n- None (The function does not return any value, but it may log errors to the console if the request fails).",
    "Canonical_solution": "const axios = require('axios');\n\nconst sendWebhook = async (data) => {\n    try {\n        await axios.post(process.env.UPDATE_WEBHOOK, data);\n    } catch (err) {\n        console.log(err);\n    }\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function sendWebhook(data) {\n    const WEBHOOK_URL = 'https://example.com/webhook';\n    try {\n        const response = await fetch(WEBHOOK_URL, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    } catch (error) {\n        console.error('Webhook request failed:', error.message);\n    }\n}"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes a connection to a WebSocket server, handles communication events (open, message, close, error), and provides methods to send messages and close the connection. The class should integrate with a listener interface to notify about connection events and received messages.\n\nClass Description: The WebSocketClient class is an implementation of the AiClient interface that manages WebSocket connections in a browser environment. It handles the WebSocket lifecycle, including connection establishment, message exchange, and error handling, while notifying a listener about these events.\n\nAttributes:\n- isStop: boolean - Indicates whether the connection has been stopped.\n- url: string - The WebSocket server URL to connect to.\n- webSocket: WebSocket | undefined - The WebSocket instance.\n- isOpen: boolean - Indicates whether the WebSocket connection is open.\n- payload: string | undefined - The initial message payload to send after connection.\n- listener: AiClientListener - The listener interface for event notifications.\n\nMethods:\n- constructor(url: string, listener: AiClientListener) -> void - Initializes the WebSocketClient with the server URL and a listener.\n- start(payload: string) -> void - Starts the WebSocket connection and sets up event handlers. Sends the initial payload once connected.\n- stop() -> void - Closes the WebSocket connection and notifies the listener.\n- send(message: string) -> void - Sends a message through the WebSocket if the connection is open.\n- onOpen(_: Event) -> void - Handles the WebSocket 'open' event, sets the connection state, and sends the initial payload.\n- onMessage(event: MessageEvent) -> void - Handles incoming messages and notifies the listener.\n- onClose(_: CloseEvent) -> void - Handles the WebSocket 'close' event, updates the connection state, and notifies the listener.\n- onError(_: Event) -> void - Handles WebSocket errors, updates the connection state, and notifies the listener.",
    "Canonical_solution": "import {AiClientListener} from \"../../AiClientListener.ts\";\nimport {AiClient} from \"../../AiClient.ts\";\n\nexport class WebSocketClient implements AiClient {\n    isStop: boolean = false\n    url: string;\n    webSocket?: WebSocket;\n    isOpen: boolean = false;\n    payload?: string;\n    listener: AiClientListener;\n\n    constructor(url: string, listener: AiClientListener) {\n        this.url = url;\n        this.listener = listener;\n    }\n\n    start(payload: string) {\n        this.listener.onStart(this);\n        this.payload = payload;\n        this.webSocket = new WebSocket(this.url);\n        this.webSocket.onopen = (e) => this.onOpen(e)\n        this.webSocket.onmessage = (e) => this.onMessage(e)\n        this.webSocket.onclose = (e) => this.onClose(e)\n        this.webSocket.onerror = (e) => this.onError(e)\n    }\n\n    stop() {\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = void 0;\n\n            if (!this.isStop) {\n                this.listener.onStop();\n                this.isStop = true;\n            }\n        }\n    }\n\n    send(message: string) {\n        if (this.webSocket && this.isOpen) {\n            this.webSocket.send(message);\n        }\n    }\n\n    protected onOpen(_: Event) {\n        this.isOpen = true;\n        this.send(this.payload!);\n    }\n\n    protected onMessage(event: MessageEvent) {\n        this.listener.onMessage(event.data)\n    }\n\n    protected onClose(_: CloseEvent) {\n        this.isOpen = false;\n        if (!this.isStop) {\n            this.listener.onStop();\n            this.isStop = true;\n        }\n    }\n\n    protected onError(_: Event) {\n        this.isOpen = false;\n        if (!this.isStop) {\n            this.listener.onStop();\n            this.isStop = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class WebSocketClient {\n  constructor(url, listener) {\n    this.url = url;\n    this.listener = listener;\n    this.isStop = false;\n    this.isOpen = false;\n    this.webSocket = undefined;\n    this.payload = undefined;\n  }\n\n  start(payload) {\n    this.isStop = false;\n    this.payload = payload;\n    this.webSocket = new WebSocket(this.url);\n    this.webSocket.addEventListener('open', this.onOpen.bind(this));\n    this.webSocket.addEventListener('message', this.onMessage.bind(this));\n    this.webSocket.addEventListener('close', this.onClose.bind(this));\n    this.webSocket.addEventListener('error', this.onError.bind(this));\n  }\n\n  stop() {\n    this.isStop = true;\n    if (this.webSocket) {\n      this.webSocket.close();\n    }\n    this.listener.onClosed();\n  }\n\n  send(message) {\n    if (this.isOpen && this.webSocket) {\n      this.webSocket.send(message);\n    }\n  }\n\n  onOpen(event) {\n    this.isOpen = true;\n    if (this.payload !== undefined) {\n      this.send(this.payload);\n      this.payload = undefined;\n    }\n    this.listener.onOpen(event);\n  }\n\n  onMessage(event) {\n    this.listener.onMessage(event.data);\n  }\n\n  onClose(event) {\n    this.isOpen = false;\n    this.listener.onClosed(event);\n  }\n\n  onError(event) {\n    this.isOpen = false;\n    this.listener.onError(event);\n  }\n}"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript to establish a connection with a server, send a command, and handle connection events.\n\nFunction Description: The code establishes a WebSocket connection to a specified URL with a custom protocol. It sends a \"REBOOT\" command upon successful connection and provides empty handlers for incoming messages and connection closure. Error handling is included for connection issues.\n\nInput: None (The WebSocket URL is obtained internally via get_appropriate_ws_url() function)\n\nOutput: None (The function establishes a WebSocket connection and sends a command, but doesn't return any value)\n\nKey Steps:\n1. Initialize WebSocket connection with appropriate browser API (MozWebSocket or standard WebSocket)\n2. Set up event handlers for connection opening, message reception, and connection closing\n3. Implement error handling for connection attempts\n4. Send \"REBOOT\" command upon successful connection\n5. Provide empty handlers for message reception and connection closing events",
    "Canonical_solution": "function init_command() {\n    socket_command.send(\"REBOOT\\n\");\n}\n\nvar socket_command;\n\nif (typeof MozWebSocket != \"undefined\") {\n    socket_command = new MozWebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n} else {\n    socket_command = new WebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n}\n\ntry {\n    socket_command.onopen = function() {\n        init_command();\n    }\n\n    socket_command.onmessage = function got_packet(msg) {\n    }\n\n    socket_command.onclose = function(){\n    }\n} catch(exception) {\n    alert('<p>Error' + exception);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "const WsImpl = window.MozWebSocket || window.WebSocket;\nconst ws = new WsImpl(get_appropriate_ws_url(), 'custom-protocol');\n\nws.onopen = function() {\n    ws.send('REBOOT');\n};\n\nws.onmessage = function() {};\n\nws.onclose = function() {};\n\nws.onerror = function(error) {\n    ws.close();\n};"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a specified path on a server and returns the WebSocket object if the connection is successfully opened.\n\nFunction Description: The function `apiWebSocket` attempts to create a WebSocket connection to a given path on a secure WebSocket server. It waits for the connection to be established or fail (due to error or closure) and returns the WebSocket object only if the connection is successfully opened. If the connection fails or an error occurs, the function returns `undefined`.\n\nInput: \n- `path` (string): The path on the server to which the WebSocket connection should be established. This is appended to the base URL `wss://services.bonjourr.fr/`.\n\nOutput: \n- `Promise<WebSocket | undefined>`: A promise that resolves to the WebSocket object if the connection is successfully opened, or `undefined` if the connection fails or an error occurs.",
    "Canonical_solution": "export async function apiWebSocket(path: string): Promise<WebSocket | undefined> {\n\ttry {\n\t\tconst socket = new WebSocket(`wss://services.bonjourr.fr/${path}`)\n\t\tconst isOpened = await new Promise((resolve) => {\n\t\t\tsocket.onopen = () => resolve(true)\n\t\t\tsocket.onerror = () => resolve(false)\n\t\t\tsocket.onclose = () => resolve(false)\n\t\t})\n\n\t\tif (isOpened) {\n\t\t\treturn socket\n\t\t}\n\t} catch (_error) {\n\t\t// ...\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function apiWebSocket(path) {\n  return new Promise((resolve) => {\n    const url = 'wss://services.bonjourr.fr/' + path;\n    const ws = new WebSocket(url);\n    let resolved = false;\n\n    const cleanup = () => {\n      ws.removeEventListener('open', handleOpen);\n      ws.removeEventListener('error', handleError);\n      ws.removeEventListener('close', handleClose);\n    };\n\n    const handleOpen = () => {\n      if (!resolved) {\n        resolved = true;\n        cleanup();\n        resolve(ws);\n      }\n    };\n\n    const handleError = () => {\n      if (!resolved) {\n        resolved = true;\n        cleanup();\n        resolve(undefined);\n      }\n    };\n\n    const handleClose = () => {\n      if (!resolved) {\n        resolved = true;\n        cleanup();\n        resolve(undefined);\n      }\n    };\n\n    ws.addEventListener('open', handleOpen);\n    ws.addEventListener('error', handleError);\n    ws.addEventListener('close', handleClose);\n  });\n}"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function speechApi(ssml) {\n  const subscriptionKey = 'YOUR_SUBSCRIPTION_KEY';\n  const region = 'YOUR_REGION';\n  const tokenEndpoint = `https://${region}.api.cognitive.microsoft.com/sts/v1.0/issueToken`;\n  const ttsEndpoint = `https://${region}.tts.speech.microsoft.com/cognitiveservices/v1`;\n  try {\n    const tokenResponse = await fetch(tokenEndpoint, {\n      method: 'POST',\n      headers: {\n        'Ocp-Apim-Subscription-Key': subscriptionKey\n      }\n    });\n    if (!tokenResponse.ok) throw new Error('Failed to get token');\n    const token = await tokenResponse.text();\n    const response = await fetch(ttsEndpoint, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/ssml+xml',\n        'X-Microsoft-OutputFormat': 'audio-24khz-160kbitrate-mono-mp3'\n      },\n      body: ssml\n    });\n    if (!response.ok) throw new Error('TTS request failed');\n    const audioData = await response.arrayBuffer();\n    return audioData;\n  } catch (error) {\n    throw error;\n  }\n}"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that connects to a server, sends messages, and displays received messages in a chat interface.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a server when a button is clicked. It handles connection events (open, close, message) and allows sending messages via an input field. The function disables the join button during active connection and re-enables it when closed.\n\nInput: \n- None (the function uses DOM elements internally: username input, join button, chat textarea, and message input field)\n\nOutput: \n- None (the function sets up event listeners and modifies DOM elements directly)\n\nAttributes: N/A (function-level implementation)\n\nMethods: N/A (function-level implementation)",
    "Canonical_solution": "function setupWebSocket() {\n    const username = document.querySelector(\"#username\");\n    const join_btn = document.querySelector(\"#join-chat\");\n    const textarea = document.querySelector(\"#chat\");\n    const input = document.querySelector(\"#input\");\n\n    join_btn.addEventListener(\"click\", function(e) {\n        this.disabled = true;\n\n        const websocket = new WebSocket(\"ws://localhost:3000/websocket\");\n\n        websocket.onopen = function() {\n            console.log(\"connection opened\");\n            websocket.send(username.value);\n        }\n\n        const btn = this;\n\n        websocket.onclose = function() {\n            console.log(\"connection closed\");\n            btn.disabled = false;\n        }\n\n        websocket.onmessage = function(e) {\n            console.log(\"received message: \"+e.data);\n            textarea.value += e.data+\"\\r\\n\";\n        }\n\n        input.onkeydown = function(e) {\n            if (e.key == \"Enter\") {\n                websocket.send(input.value);\n                input.value = \"\";\n            }\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function setupWebSocket() {\n  const joinButton = document.getElementById('joinButton');\n  const usernameInput = document.getElementById('usernameInput');\n  const messageInput = document.getElementById('messageInput');\n  const chatArea = document.getElementById('chatArea');\n  let socket = null;\n\n  messageInput.addEventListener('keypress', (e) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        const message = messageInput.value.trim();\n        if (message) {\n          socket.send(message);\n          messageInput.value = '';\n        }\n      }\n    }\n  });\n\n  joinButton.addEventListener('click', () => {\n    const username = usernameInput.value.trim();\n    if (!username) return;\n\n    socket = new WebSocket('ws://example.com/socket');\n    joinButton.disabled = true;\n\n    socket.addEventListener('open', () => {\n      socket.send(username);\n    });\n\n    socket.addEventListener('message', (event) => {\n      chatArea.value += event.data + '\\n';\n      chatArea.scrollTop = chatArea.scrollHeight;\n    });\n\n    socket.addEventListener('close', () => {\n      joinButton.disabled = false;\n      socket = null;\n    });\n\n    socket.addEventListener('error', (error) => {\n      console.error('WebSocket error:', error);\n      socket.close();\n    });\n  });\n}"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, listens for incoming messages, and sends user input from a text box when the Enter key is pressed.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a specified server URL. It sets up an event listener for incoming messages to display them in a designated HTML element. Additionally, it listens for the Enter key press in a text box to send the input text via the WebSocket connection and clears the text box afterward.\n\nInput: None (The function uses DOM elements with IDs \"txt\" and \"divOut\" for text input and message display, respectively.)\n\nOutput: None (The function's side effects include establishing a WebSocket connection, displaying received messages in the \"divOut\" element, and sending user input to the server.)",
    "Canonical_solution": "function setupWebSocket() {\n    const txtBox = document.getElementById(\"txt\");\n    const divOut = document.getElementById(\"divOut\");\n    const ws = new WebSocket(\"ws://localhost/wsapp/\");\n    \n    ws.onmessage = function(e) {\n        divOut.innerHTML += e.data + \"<br/>\";\n    };\n    \n    txtBox.addEventListener(\"keypress\", function(e) {\n        if (e.keyCode === 13) {\n            ws.send(txtBox.value);\n            txtBox.value = \"\";\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function setupWebSocket() {\n  const socket = new WebSocket('ws://example.com/socket');\n  const txt = document.getElementById('txt');\n  const divOut = document.getElementById('divOut');\n  socket.addEventListener('message', (event) => {\n    divOut.innerHTML += event.data + '<br>';\n  });\n  txt.addEventListener('keydown', (event) => {\n    if (event.key === 'Enter') {\n      const input = txt.value.trim();\n      if (input) {\n        socket.send(input);\n        txt.value = '';\n      }\n    }\n  });\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function getChannels() {\n  const url = 'https://api.example.com/tv-channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Network response was not ok: ${response.statusText}`);\n    }\n    const data = await response.json();\n    return data.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channel data:', error);\n    return [];\n  }\n}"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends messages, and manages errors and closures.\n\nFunction Description: The function `connectWebSocket` initializes a WebSocket client connection to a specified server. It sets up event handlers for connection opening, incoming messages, and connection closing. The function also sends an initial message upon successful connection and logs all events to the console.\n\nInput: \n- Optional command line arguments:\n  - `port` (number): The port number to connect to (default: 7000).\n  - `secure` (boolean): Whether to use a secure WebSocket connection (wss) (default: false, uses ws).\n\nOutput: \n- No explicit return value. The function logs connection status, received messages, and closure events to the console.\n- Side effects: Establishes a WebSocket connection and sends/receives messages.",
    "Canonical_solution": "function connectWebSocket() {\n    var WebSocket = require('../lib/faye/websocket'),\n        port = process.argv[2] || 7000,\n        secure = process.argv[3] === 'ssl',\n        scheme = secure ? 'wss' : 'ws',\n        ws = new WebSocket.Client(scheme + '://localhost:' + port + '/');\n\n    console.log('Connecting to ' + ws.url);\n\n    ws.onopen = function(event) {\n        console.log('open');\n        ws.send('Hello, WebSocket!');\n    };\n\n    ws.onmessage = function(event) {\n        console.log('message', event.data);\n    };\n\n    ws.onclose = function(event) {\n        console.log('close', event.code, event.reason);\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function connectWebSocket(port = 7000, secure = false) {\n    const protocol = secure ? 'wss' : 'ws';\n    const socket = new WebSocket(`${protocol}://localhost:${port}`);\n    \n    socket.addEventListener('open', () => {\n        console.log('Connection established');\n        socket.send('Client connected');\n    });\n    \n    socket.addEventListener('message', (event) => {\n        console.log(`Message received: ${event.data}`);\n    });\n    \n    socket.addEventListener('close', (event) => {\n        console.log(`Connection closed: ${event.reason}`);\n    });\n    \n    socket.addEventListener('error', (error) => {\n        console.error(`WebSocket error: ${error.message}`);\n        socket.close();\n    });\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a server, handles various connection events, and processes incoming messages for a reload service.\n\nFunction Description: The `connect` function initializes and manages a WebSocket connection to a specified server. It handles connection events (open, error, message, close) and processes incoming messages to trigger appropriate actions, such as requesting initial load data or reloading extensions when file changes are detected. The function ensures only one active connection exists at a time.\n\nInput: None (The WebSocket URL is hardcoded as 'ws://localhost:__RELOAD_PORT__')\n\nOutput: None (The function primarily manages side effects: establishing connections, logging events, and triggering other functions based on received messages)",
    "Canonical_solution": "function connect() {\n  if (webSocket) {\n    return;\n  }\n\n  webSocket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  webSocket.onerror = (event) => {\n    console.error(`[Reload Service] Connection error: ${JSON.stringify(event)}`);\n    webSocket.close();\n  };\n\n  webSocket.onopen = () => {\n    console.info(`[Reload Service] Connection opened.`);\n  };\n\n  webSocket.onmessage = async (event) => {\n    const message = JSON.parse(event.data);\n\n    if (message.status === 'serverReady') {\n      console.info('[Reload Service] Connection ready.');\n      await requestInitialLoadData();\n    }\n\n    if (message.changedFile) {\n      console.info(\n        `[Reload Service] Changes detected on ${message.changedFile}. Reloading extension...`\n      );\n      await messageAllExtensions(message.changedFile);\n    }\n  };\n\n  webSocket.onclose = () => {\n    console.info('[Reload Service] Connection closed.');\n    webSocket = null;\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function connect() {\n  if (connect.currentSocket) {\n    connect.currentSocket.close();\n    connect.currentSocket = null;\n  }\n\n  const socket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n  connect.currentSocket = socket;\n\n  socket.addEventListener('open', () => {\n    console.log('WebSocket connection established');\n    socket.send(JSON.stringify({ type: 'initialLoadRequest' }));\n  });\n\n  socket.addEventListener('error', (error) => {\n    console.error('WebSocket error:', error);\n  });\n\n  socket.addEventListener('message', (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      if (data.type === 'reload') {\n        reloadExtensions();\n      }\n    } catch (e) {\n      console.warn('Received non-JSON message:', event.data);\n    }\n  });\n\n  socket.addEventListener('close', () => {\n    console.log('WebSocket connection closed');\n  });\n}"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Create a WebSocket server class that manages WebSocket connections for a webview application, handling connection events and maintaining active connections.\n\nClass Description: The WebviewServer class is responsible for setting up and managing a WebSocket server that facilitates real-time communication between a webview application and a data source. It maintains active connections and provides server information.\n\nAttributes:\n- server: [http.Server] - The underlying HTTP server instance used for WebSocket communication\n- secret: [string] - A secret string used for authentication or security purposes\n- connections: [Set<WebviewConnection>] - A collection of active WebSocket connections\n- config: [Config] - Configuration object containing server settings\n\nMethods:\n- constructor(dataSource: [VisualizationWatchModel], config: [Config]) -> [void] - Initializes the WebSocket server, sets up connection handlers, and stores the configuration\n- get port() -> [number] - Returns the port number on which the server is listening for connections",
    "Canonical_solution": "import { WebSocketStream } from \"@hediet/typed-json-rpc-websocket\";\nimport WebSocket = require(\"ws\");\nimport * as express from \"express\";\nimport * as http from \"http\";\n\nexport class WebviewServer {\n\tprivate readonly server: http.Server;\n\tpublic readonly secret: string;\n\n\tpublic readonly connections = new Set<WebviewConnection>();\n\n\tconstructor(\n\t\tdataSource: VisualizationWatchModel,\n\t\tprivate readonly config: Config\n\t) {\n\t\tconst app = express();\n\t\tthis.server = app.listen();\n\n\t\tconst wss = new WebSocket.Server({ server: this.server });\n\t\twss.on(\"connection\", async ws => {\n\t\t\tconst stream = new WebSocketStream(ws);\n\t\t\tconst c = new WebviewConnection(\n\t\t\t\tdataSource,\n\t\t\t\tstream,\n\t\t\t\tthis,\n\t\t\t\tconfig,\n\t\t\t\tthis.secret\n\t\t\t);\n\t\t\tthis.connections.add(c);\n\t\t\tawait stream.onClosed;\n\t\t\tthis.connections.delete(c);\n\t\t});\n\t}\n\n\tpublic get port(): number {\n\t\tconst httpPort = (this.server.address() as AddressInfo).port;\n\t\treturn httpPort;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "import http from 'http';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { AddressInfo } from 'net';\n\ninterface VisualizationWatchModel {}\ninterface Config {\n  secret: string;\n  port: number;\n}\n\nclass WebviewConnection {\n  constructor(public socket: WebSocket) {}\n}\n\nclass WebviewServer {\n  private server: http.Server;\n  private secret: string;\n  private connections: Set<WebviewConnection>;\n  private config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.config = config;\n    this.secret = config.secret;\n    this.connections = new Set<WebviewConnection>();\n    this.server = http.createServer((req, res) => {\n      res.writeHead(404);\n      res.end();\n    });\n    const wss = new WebSocketServer({ server: this.server });\n    wss.on('connection', (socket) => {\n      const connection = new WebviewConnection(socket);\n      this.connections.add(connection);\n      socket.on('close', () => {\n        this.connections.delete(connection);\n      });\n    });\n    this.server.listen(config.port);\n  }\n\n  get port(): number {\n    return (this.server.address() as AddressInfo).port;\n  }\n}"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n  }\n\n  async httpRequest(options) {\n    const axios = require('axios');\n    const config = {\n      method: options.method,\n      url: options.url,\n      headers: options.headers || {},\n    };\n\n    if (options.params) {\n      const queryString = this.queryStr(options.params);\n      if (queryString) {\n        config.url += (config.url.includes('?') ? '&' : '?') + queryString;\n      }\n    }\n\n    if (config.method === 'POST') {\n      const body = options.body;\n      if (body !== undefined && body !== null) {\n        if (this.isJson(body)) {\n          if (!config.headers['Content-Type']) {\n            config.headers['Content-Type'] = 'application/json';\n          }\n          config.data = JSON.stringify(body);\n        } else if (typeof body === 'string') {\n          if (this.isJSONString(body)) {\n            if (!config.headers['Content-Type']) {\n              config.headers['Content-Type'] = 'application/json';\n            }\n          }\n          config.data = body;\n        }\n      }\n    }\n\n    try {\n      const response = await axios(config);\n      return response.data;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  queryStr(options) {\n    const parts = [];\n    const encode = (key, value) => {\n      if (value !== undefined && value !== null) {\n        parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n      }\n    };\n\n    const recurse = (current, path) => {\n      if (Array.isArray(current)) {\n        current.forEach((item, index) => {\n          recurse(item, path ? path + '[' + index + ']' : index);\n        });\n      } else if (current instanceof Object) {\n        Object.keys(current).forEach(key => {\n          recurse(current[key], path ? path + '[' + key + ']' : key);\n        });\n      } else {\n        encode(path, current);\n      }\n    };\n\n    recurse(options, '');\n    return parts.join('&');\n  }\n\n  isJSONString(str) {\n    if (typeof str !== 'string') return false;\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj !== null && \n           typeof obj === 'object' && \n           !Array.isArray(obj) && \n           Object.prototype.toString.call(obj) === '[object Object]';\n  }\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript that handles real-time communication between clients and integrates with an Express application and Deployd backend.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io, integrates it with an Express application, and attaches a Deployd backend. It sets up event listeners for server operations and handles custom Express routes.\n\nInput: None (The function uses environment variables for configuration: `process.env.NODE_ENV` for environment setting and `process.env.PORT` for port number)\n\nOutput: None (The function starts a server that listens on the specified port and logs server status to the console)\n\nNote: The function internally uses:\n- Express for HTTP server functionality\n- Socket.io for WebSocket communication\n- Deployd for backend services\n- MongoDB (configured to connect to localhost:27017 with database name 'test-app')",
    "Canonical_solution": "function setupWebSocketServer() {\n    var express = require('express');\n    var app = express();\n    var server = require('http').createServer(app);\n    var io = require('socket.io').listen(server, {'log level': 0});\n\n    require('deployd').attach(server, {\n        socketIo: io,\n        env: process.env.NODE_ENV || 'development',\n        db: {host:'localhost', port:27017, name:'test-app'}\n    });\n    app.use(server.handleRequest);\n\n    app.get('/express-custom-handler', function(req, res) {\n        res.send('Ok');\n    });\n\n    server.listen(process.env.PORT || 2403, function() {\n        console.log({ ENV: process.env.NODE_ENV || 'development', PORT: process.env.PORT || 2403 });\n    });\n    server.on('error', function(err) {\n        console.log(err.stack);\n        process.nextTick(function() {\n            process.exit();\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst socketIO = require('socket.io');\nconst deployd = require('deployd');\n\nfunction setupWebSocketServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketIO(server);\n\n  const deploydServer = deployd.createServer({\n    db: { connectionString: 'mongodb://localhost:27017/test-app' },\n    server: server\n  });\n\n  app.use(deploydServer);\n\n  app.get('/', (req, res) => {\n    res.send('WebSocket server operational');\n  });\n\n  io.on('connection', (socket) => {\n    console.log('Client connected');\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  const PORT = process.env.PORT || 3000;\n  const ENV = process.env.NODE_ENV || 'development';\n\n  server.listen(PORT, () => {\n    console.log(`Server running in ${ENV} mode on port ${PORT}`);\n  });\n}\n\nsetupWebSocketServer();"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const response = await axios.get(this.url());\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('option[data-lang]').each((i, el) => {\n    const $el = $(el);\n    channels.push({\n      lang: $el.data('lang'),\n      site_id: $el.attr('value'),\n      name: $el.text().trim()\n    });\n  });\n\n  return channels;\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "function installTelemetry() {\n  if (process.env.TUNNELMOLE_TELEMETRY !== 'true') return;\n  const https = require('https');\n  const data = {\n    nodeVersion: process.versions.node,\n    platform: process.platform\n  };\n  const body = JSON.stringify(data);\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': Buffer.byteLength(body)\n    }\n  };\n  const req = https.request('https://telemetry.endpoint.example/install', options, (res) => {\n    res.resume();\n  });\n  req.on('error', () => {});\n  req.write(body);\n  req.end();\n}"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const https = require('https');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {};\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.username = saucelabsUsername;\n    this.auth.token = saucelabsToken;\n  }\n\n  get(path, callback) {\n    if (!this.auth.username || !this.auth.token) {\n      return callback(new Error('Authentication not set'));\n    }\n\n    const options = {\n      hostname: 'saucelabs.com',\n      port: 443,\n      path: `/rest/v1/${path}`,\n      method: 'GET',\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(`${this.auth.username}:${this.auth.token}`).toString('base64')\n      }\n    };\n\n    const req = https.get(options, (res) => {\n      let data = '';\n      res.on('data', (chunk) => { data += chunk; });\n      res.on('end', () => {\n        try {\n          const parsed = JSON.parse(data);\n          callback(null, parsed);\n        } catch (err) {\n          callback(err);\n        }\n      });\n    });\n\n    req.on('error', (err) => {\n      callback(err);\n    });\n  }\n\n  post(path, data, callback) {\n    if (!this.auth.username || !this.auth.token) {\n      return callback(new Error('Authentication not set'));\n    }\n\n    const jsonData = JSON.stringify(data);\n    const options = {\n      hostname: 'saucelabs.com',\n      port: 443,\n      path: `/rest/v1/${path}`,\n      method: 'POST',\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(`${this.auth.username}:${this.auth.token}`).toString('base64'),\n        'Content-Type': 'application/json',\n        'Content-Length': Buffer.byteLength(jsonData)\n      }\n    };\n\n    const req = https.request(options, (res) => {\n      let responseData = '';\n      res.on('data', (chunk) => { responseData += chunk; });\n      res.on('end', () => {\n        try {\n          const parsed = JSON.parse(responseData);\n          callback(null, parsed);\n        } catch (err) {\n          callback(err);\n        }\n      });\n    });\n\n    req.on('error', (err) => {\n      callback(err);\n    });\n\n    req.write(jsonData);\n    req.end();\n  }\n}\n\nmodule.exports = SauceLabsClient;"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using an HTTP POST request and triggers a callback function upon completion or failure.\n\nFunction Description: The function uses Axios to send an HTTP POST request to a specified webhook URL with event and data payload. It triggers a callback function (triggerActivity) when the request succeeds or fails. The request includes custom headers for identification.\n\nInput:\n- url: [String] - The webhook URL to which the POST request will be sent\n- event: [String/Object] - The event information to be sent in the request payload\n- data: [Object] - The data payload to be sent in the request\n- triggerActivity: [Function] - Callback function to be triggered after request completion (takes an optional error parameter)\n\nOutput: [None] - The function doesn't return anything but triggers the callback function",
    "Canonical_solution": "const axios = require(\"axios\");\n\nfunction postWebhook(url, event, data, triggerActivity) {\n    axios.post(url, {event, data}, {headers: {\"user-agent\": \"MySpeed/WebhookAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "function sendWebhook(url, event, data, triggerActivity) {\n  axios.post(url, { event, data }, {\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Webhook-Client': '1.0'\n    }\n  }).then(() => triggerActivity(null)).catch(triggerActivity);\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Write a function that retrieves TV channel information from multiple regions, processes the data, and returns a unique list of channels based on their site IDs.\n\nFunction Description: The function `channels` makes HTTP GET requests to a TV channel API for multiple regions, collects channel data from all available pages for each region, and returns a deduplicated list of channels. It uses axios for HTTP requests and lodash for data processing.\n\nInput: None (The function uses hardcoded region IDs internally)\n\nOutput: An array of objects representing unique TV channels, where each object contains:\n- lang: string - Language code ('ru' for Russian)\n- name: string - Name of the TV channel\n- site_id: string/number - Unique identifier for the channel on the site\n\nThe output is deduplicated based on the site_id field using lodash's uniqBy function.",
    "Canonical_solution": "async function channels() {\n    const _ = require('lodash')\n    const axios = require('axios')\n\n    const regions = [5506, 1096, 1125, 285]\n    let channels = []\n    for (let region of regions) {\n        const totalPages = await getTotalPageCount(region)\n        const pages = Array.from(Array(totalPages).keys())\n        for (let page of pages) {\n            const data = await axios\n                .get('https://tv.mail.ru/ajax/channel/list/', {\n                    params: { page },\n                    headers: {\n                        cookie: `s=fver=0|geo=${region};`\n                    }\n                })\n                .then(r => r.data)\n                .catch(console.log)\n\n            data.channels.forEach(item => {\n                channels.push({\n                    lang: 'ru',\n                    name: item.name,\n                    site_id: item.id\n                })\n            })\n        }\n    }\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\nimport _ from 'lodash';\n\nasync function channels() {\n  const regions = ['ru', 'en'];\n  const allChannels = [];\n\n  for (const region of regions) {\n    let page = 1;\n    let hasMore = true;\n\n    while (hasMore) {\n      try {\n        const response = await axios.get(`https://api.example.com/tv-channels?region=${region}&page=${page}`);\n        const data = response.data;\n\n        if (data.length === 0) {\n          hasMore = false;\n        } else {\n          data.forEach(channel => {\n            allChannels.push({ ...channel, lang: region });\n          });\n          page++;\n        }\n      } catch (error) {\n        console.error(`Error fetching data for region ${region}, page ${page}:`, error.message);\n        hasMore = false;\n      }\n    }\n  }\n\n  return _.uniqBy(allChannels, 'site_id');\n}\n\nexport default channels;"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = !!repo && !!token;\n  }\n\n  get() {\n    if (!this.enabled) return Promise.resolve({});\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    const url = `${this.url}?repo=${encodeURIComponent(sanitizedRepo)}&sha=${encodeURIComponent(this.sha)}`;\n    return fetch(url)\n      .then(response => {\n        try {\n          return response.json();\n        } catch (e) {\n          console.error('Error parsing JSON response:', e);\n          return {};\n        }\n      })\n      .catch(error => {\n        console.error('Failed to fetch bundle sizes:', error);\n        return {};\n      });\n  }\n\n  set(values) {\n    if (!this.enabled) return;\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    const payload = {\n      repo: sanitizedRepo,\n      sha: this.sha,\n      values\n    };\n    fetch(this.url, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.token}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(payload)\n    }).catch(error => {\n      console.error('Failed to submit bundle sizes:', error);\n    });\n  }\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function fetchCovidData() {  const url = 'https://datadashboardapi.health.gov.il/api/queries/getAllData';  try {    const response = await fetch(url, {      method: 'POST',      headers: {        'Content-Type': 'application/json',        'Accept': 'application/json'      },      body: JSON.stringify({})    });    if (!response.ok) {      throw new Error(`HTTP error! status: ${response.status}`);    }    const data = await response.json();    return data;  } catch (error) {    console.error('Failed to fetch data:', error);    return null;  }}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with optional path extension and error data, then triggers an activity callback based on the request's success or failure.\n\nFunction Description: The function `sendPing` is an asynchronous function that constructs a target URL by combining a base URL and an optional path, then sends an HTTP POST request using Axios. The request includes error data in the payload and a custom user-agent header. Depending on the request's outcome, it triggers a callback function (`triggerActivity`) with a success or failure indicator.\n\nInput:  \n- `url`: [String] - The base URL to which the request will be sent.  \n- `path`: [String] (optional) - An additional path segment to append to the base URL.  \n- `error`: [Any] - Data to be sent as the request payload (typically error information).  \n- `triggerActivity`: [Function] - A callback function to be executed after the request completes, receiving a boolean parameter indicating failure (true) or success (false/undefined).  \n\nOutput:  \n- None (The function's primary effect is the HTTP request and callback execution, not a direct return value).",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function sendPing(url, path, error, triggerActivity) {\n    if (url == null) return;\n    if (path) url += \"/\" + path;\n\n    await axios.post(url, error, {headers: {\"user-agent\": \"MySpeed/HealthAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\n\nasync function sendPing(url, path, error, triggerActivity) {\n  const targetUrl = path ? new URL(path, url).href : url;\n  try {\n    await axios.post(targetUrl, error, {\n      headers: {\n        'User-Agent': 'ErrorReporter/1.0'\n      }\n    });\n    triggerActivity(false);\n  } catch (e) {\n    triggerActivity(true);\n  }\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a function to send emails using different email service providers (Mailgun and Sendgrid) through HTTP requests, with error handling and promise-based asynchronous operation.\n\nFunction Description: The function `sendMail` sends an email using a configured transporter (either Mailgun or Sendgrid). It wraps the transporter's send operation in a Promise for better async handling. The transporter is configured to make HTTP requests to the respective email service API.\n\nInput:\n- `to`: [String] - Recipient email address\n- `subject`: [String] - Email subject\n- `text`: [String] - Email body content\n- `options`: [Object] (optional) - Additional email options (defaults to empty object)\n\nOutput:\n- [Promise] - Resolves with email sending success info, or rejects with an error if sending fails.\n\n---\n\nClass Description: (Not applicable, as the reference code is at the function level)",
    "Canonical_solution": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    transporter.sendMail({\n      from: `\"${ config.plugins.email.name || '' }\" <${ config.plugins.email.email || config.plugins.email.username }>`,\n      to,\n      subject,\n      text,\n    }, (error, info) => {\n      if(error) {\n        return reject(error);\n      }\n      return resolve(info);\n    });\n  });\n}\n\n// External libraries and global variables used:\nconst axios = require('axios');\nconst FormData = require('form-data');\nconst config = appRequire('services/config').all();\nlet transporter;\n\n// Mailgun implementation\ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  const form = new FormData();\n  form.append('from', options.from);\n  form.append('to', options.to);\n  form.append('subject', options.subject);\n  form.append('text', options.text);\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: form.getHeaders(),\n    data: form,\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};\n\n// Sendgrid implementation  \ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${ emailConfig.apiKey }`,\n    },\n    data: {\n      personalizations: [{\n        to: [{ email: options.to }]\n      }],\n      from: { email: options.from },\n      subject: options.subject,\n      content: [{\n        type: 'text/plain',\n        value: options.text,\n      }]\n    },\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const mailgun = require('mailgun-js');\nconst sgMail = require('@sendgrid/mail');\n\nasync function sendMail(to, subject, text, options = {}) {\n  const provider = process.env.EMAIL_PROVIDER;\n  if (!provider) {\n    throw new Error('Email provider not configured.');\n  }\n\n  if (provider === 'mailgun') {\n    const mg = mailgun({\n      apiKey: process.env.MAILGUN_API_KEY,\n      domain: process.env.MAILGUN_DOMAIN,\n    });\n    const data = {\n      from: options.from || `noreply@${process.env.MAILGUN_DOMAIN}`,\n      to,\n      subject,\n      text,\n      ...options,\n    };\n    return new Promise((resolve, reject) => {\n      mg.messages().send(data, (error, body) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(body);\n        }\n      });\n    });\n  } else if (provider === 'sendgrid') {\n    sgMail.setApiKey(process.env.SENDGRID_API_KEY);\n    const msg = {\n      to,\n      from: options.from || process.env.SENDGRID_DEFAULT_FROM,\n      subject,\n      text,\n      ...options,\n    };\n    const [response] = await sgMail.send(msg);\n    return response;\n  } else {\n    throw new Error('Unsupported email provider.');\n  }\n}"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function fetchTVChannels() {\n  try {\n    const response = await fetch('https://api.example.com/tv-channels');\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: 'sq',\n      site_id: channel.id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Failed to fetch TV channels:', error);\n    return [];\n  }\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Create a function that retrieves TV channel information from multiple providers and returns a list of unique channels.\n\nFunction Description: The function makes HTTP POST requests to a TV guide service for each provider, extracts channel information from the HTML response, and returns a deduplicated list of channels. It uses axios for HTTP requests, cheerio for HTML parsing, and lodash for deduplication.\n\nInput: None (The function uses hardcoded providers and parameters)\n\nOutput: Array of objects - Returns an array of channel objects containing language, name, and site_id (deduplicated by site_id). Each channel object has the following structure:\n{\n    lang: string,    // Language code ('fr' for French)\n    name: string,    // Channel name\n    site_id: string  // Unique identifier combining channel number and slug\n}",
    "Canonical_solution": "function async channels() {\n    const axios = require('axios')\n    const _ = require('lodash')\n\n    const providers = ['-1', '-2', '-3', '-4', '-5']\n\n    const channels = []\n    for (let provider of providers) {\n        const data = await axios\n            .post('https://www.tvcesoir.fr/guide/schedule', null, {\n                params: {\n                    provider,\n                    region: 'France',\n                    TVperiod: 'Night',\n                    date: dayjs().format('YYYY-MM-DD'),\n                    st: 0,\n                    u_time: 2155,\n                    is_mobile: 1\n                }\n            })\n            .then(r => r.data)\n            .catch(console.log)\n\n        const $ = cheerio.load(data)\n        $('.channelname').each((i, el) => {\n            const name = $(el).find('center > a:eq(1)').text()\n            const url = $(el).find('center > a:eq(1)').attr('href')\n            const [, number, slug] = url.match(/\\/(\\d+)\\/(.*)\\.html$/)\n\n            channels.push({\n                lang: 'fr',\n                name,\n                site_id: `${number}/${slug}`\n            })\n        })\n    }\n\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const axios = require('axios');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\n\nasync function getTVChannels() {\n  const providers = [\n    { id: 'netplus', lang: 'fr' },\n    { id: 'cablevision', lang: 'fr' },\n    { id: 'streamtv', lang: 'en' }\n  ];\n  \n  let allChannels = [];\n  \n  for (const provider of providers) {\n    const response = await axios.post('https://api.tvguide.example.com/channels', {\n      provider_id: provider.id,\n      country: 'CA',\n      format: 'html'\n    });\n    \n    const $ = cheerio.load(response.data);\n    $('.channel').each((i, el) => {\n      const number = $(el).attr('data-number');\n      const slug = $(el).attr('data-slug');\n      const name = $(el).find('.channel-name').text().trim();\n      \n      allChannels.push({\n        lang: provider.lang,\n        name,\n        site_id: `${number}-${slug}`\n      });\n    });\n  }\n  \n  return _.uniqBy(allChannels, 'site_id');\n}\n\nmodule.exports = getTVChannels;"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a function to download a video file from a given URL and save it with a specified description as the filename.\n\nFunction Description: The function `downloadVideo` initiates an asynchronous HTTP GET request to download a video file from the provided URL. It handles the response as a binary blob, creates a downloadable link, and triggers the download automatically. The function includes error handling for empty URLs and checks for successful request completion.\n\nInput:\n- `url` (String): The URL of the video file to be downloaded.\n- `desc` (String): The description to be used as the filename for the downloaded video.\n\nOutput: None (The function triggers a file download but does not return any value.)",
    "Canonical_solution": "function downloadVideo(url, desc) {\n    if (isEmpty(url)) {\n        layer.msg('\u6682\u65e0\u6570\u636e');\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\n    xhr.setRequestHeader(\"Access-Control-Allow-Credentials\", true);\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            let blob = this.response;\n            let u = window.URL.createObjectURL(new Blob([blob]));\n            let a = document.createElement('a');\n            a.download = desc + '.mp4';\n            a.href = u;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "async function downloadVideo(url, desc) {\n    if (!url) {\n        console.error(\"URL cannot be empty\");\n        return;\n    }\n    try {\n        const response = await fetch(url);\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n        const blob = await response.blob();\n        const blobUrl = URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = blobUrl;\n        a.download = desc;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(blobUrl);\n    } catch (error) {\n        console.error(\"Download failed:\", error);\n    }\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class Tool{_node=null;_isSurge=false;_isQuanX=false;isResponse=typeof $response!=\"undefined\";isSurge=this._isSurge;isQuanX=this._isQuanX;constructor(){if(typeof $httpClient!=\"undefined\")this._isSurge=true;if(typeof $task!=\"undefined\")this._isQuanX=true;if(typeof process!=\"undefined\"&&process.versions?.node){const fs=require(\"fs\"),path=require(\"path\");this._node={fs,path}}}notify(t,e,r,n={}){if(this._isSurge)$notify(t,e,r);else if(this.isQuanX)$notification.post(t,e,r,n.url);else if(this._node)console.log(`NOTIFY: ${t}\\n${e}\\n${r}`)}write(t,e){if(this._isSurge)return $persistentStore.write(t,e);if(this.isQuanX)return $prefs.setValueForKey(t,e);if(this._node)try{const r=this._node.path.join(process.cwd(),\"storage.json\"),n=this._node.fs.existsSync(r)?JSON.parse(this._node.fs.readFileSync(r,\"utf8\")):{};n[e]=t,this._node.fs.writeFileSync(r,JSON.stringify(n));return true}catch(t){return false}return false}read(t){if(this._isSurge)return $persistentStore.read(t);if(this.isQuanX)return $prefs.valueForKey(t);if(this._node)try{const e=this._node.path.join(process.cwd(),\"storage.json\");if(!this._node.fs.existsSync(e))return null;const r=JSON.parse(this._node.fs.readFileSync(e,\"utf8\"));return r[t]||null}catch(t){return null}return null}get(t,e){if(this._isSurge)$httpClient.get(t,(r,n,o)=>e(r,this._status(n),o));else if(this.isQuanX)$task.fetch(\"string\"==typeof t?{url:t}:t).then(t=>e(null,this._status(t),t.body),(t=>e(t.error,this._status(t),null)));else if(this._node){const r=\"string\"==typeof t?t:t.url,i=r.startsWith(\"https\")?require(\"https\"):require(\"http\");i.get(r,t=>{let r=\"\";t.on(\"data\",t=>r+=t),t.on(\"end\",()=>e(null,this._status(t),r))}).on(\"error\",t=>e(t,null,null))}}post(t,e){if(this._isSurge)$httpClient.post(t,(r,n,o)=>e(r,this._status(n),o));else if(this.isQuanX){const{url:r,headers:n,body:i}=\"string\"==typeof t?{url:t}:t;$task.fetch({url:r,method:\"POST\",headers:n,body:i}).then(t=>e(null,this._status(t),t.body),(t=>e(t.error,this._status(t),null)))}else if(this._node){const r=\"string\"==typeof t?t:t.url,i=r.startsWith(\"https\")?require(\"https\"):require(\"http\"),{headers:o,body:c}=t,a=i.request(r,{method:\"POST\",headers:o||{}},t=>{let r=\"\";t.on(\"data\",t=>r+=t),t.on(\"end\",()=>e(null,this._status(t),r))});a.on(\"error\",t=>e(t,null,null)),c&&a.write(c),a.end()}}_status(t){if(!t)return{statusCode:500,headers:{}};if(void 0!==t.statusCode)return{statusCode:t.statusCode,headers:t.headers||{}};return{statusCode:t.status||500,headers:t.headers||{}}} }"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a function that handles HTTP requests using XMLHttpRequest in JavaScript, including request configuration, progress tracking, and response handling.\n\nFunction Description: The function `makeRequest` initiates and manages an HTTP request using XMLHttpRequest. It configures the request with provided settings, tracks upload/download progress, handles timeouts, and processes the response. The function supports both successful and error responses, with appropriate callbacks for each scenario.\n\nInput:\n- `resolve`: [Function] - A callback function to handle the final resolution of the request (either success or error).\n- `config`: [Object] - Configuration object containing properties to set on the XMLHttpRequest instance.\n- `method`: [String] - HTTP method for the request (e.g., 'GET', 'POST').\n- `fullUrl`: [String] - The complete URL for the request.\n- `headers`: [Object] - Key-value pairs representing HTTP headers to set on the request.\n- `payload`: [Any] - Data to send with the request (for POST/PUT requests).\n- `defaultTimeout`: [Number] - Timeout duration in milliseconds for the request.\n- `xhrExtra`: [Any] - Additional data to pass to error/timeout handlers.\n- Event handlers:\n  - `onRequestProgress`: [Function] - Callback for upload progress events.\n  - `onRequestStart`: [Function] - Callback when the request starts.\n  - `onRequestEnd`: [Function] - Callback when the request ends.\n  - `onResponseStart`: [Function] - Callback when the response starts.\n  - `onResponseProgress`: [Function] - Callback for download progress events.\n  - `onResponseEnd`: [Function] - Callback when the response ends.\n  - `onTimeoutError`: [Function] - Callback for timeout errors.\n  - `onSuccess`: [Function] - Callback for successful responses.\n  - `onError`: [Function] - Callback for error responses.\n  - `onBeforeRequest`: [Function] - Callback before sending the request.\n  - `createAbortListener`: [Function] - Creates a listener for abort events.\n  - `parseResponse`: [Function] - Parses successful response data.\n  - `parseErrorResponse`: [Function] - Parses error response data.\n  - `getResponseHeaders`: [Function] - Parses raw response headers.\n\nOutput: None (The function uses callbacks to handle results asynchronously).",
    "Canonical_solution": "function makeRequest(resolve) {\n    const xhr = new XMLHttpRequest();\n    xhr.timeout = defaultTimeout;\n\n    const abort = () => xhr.abort();\n\n    Object.entries(config).forEach(([name, value]) => {\n        xhr[name] = value;\n    });\n\n    xhr.open(method, fullUrl, true);\n\n    Object.entries(headers).forEach(([name, value]) => xhr.setRequestHeader(name, value as string));\n\n    const unmountListener = createAbortListener(0, xhrExtra, abort, resolve);\n\n    xhr.upload.onprogress = onRequestProgress;\n\n    xhr.onloadstart = (): void => {\n        onRequestEnd();\n        onResponseStart();\n    };\n\n    xhr.onprogress = onResponseProgress;\n\n    xhr.onloadend = () => {\n        onResponseEnd();\n        unmountListener();\n    };\n\n    xhr.ontimeout = () => onTimeoutError(0, xhrExtra, resolve);\n\n    xhr.onreadystatechange = (e: Event) => {\n        const event = e as unknown as ProgressEvent<XMLHttpRequest>;\n        const finishedState = 4;\n\n        if (event.target && event.target.readyState === finishedState) {\n            const { status } = event.target;\n            const success = String(status).startsWith(\"2\") || String(status).startsWith(\"3\");\n            const responseHeaders = getResponseHeaders(xhr.getAllResponseHeaders());\n\n            if (success) {\n                const data = parseResponse(event.target.response);\n                onSuccess(data, status, { headers: responseHeaders }, resolve);\n            } else {\n                const data = parseErrorResponse(event.target.response);\n                onError(data, status, { headers: responseHeaders }, resolve);\n            }\n        }\n    };\n\n    onBeforeRequest();\n    onRequestStart();\n\n    xhr.send(payload);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function makeRequest(resolve,config,method,fullUrl,headers,payload,defaultTimeout,xhrExtra,onRequestProgress,onRequestStart,onRequestEnd,onResponseStart,onResponseProgress,onResponseEnd,onTimeoutError,onSuccess,onError,onBeforeRequest,createAbortListener,parseResponse,parseErrorResponse,getResponseHeaders){const xhr=new XMLHttpRequest();xhr.timeout=defaultTimeout;for(const key in config)xhr[key]=config[key];if(headers)for(const key in headers)xhr.setRequestHeader(key,headers[key]);if(onBeforeRequest)onBeforeRequest();let resolved=false;const callOnce=()=>{if(!resolved){resolved=true;resolve();}};xhr.onreadystatechange=()=>{if(xhr.readyState===XMLHttpRequest.DONE){const responseHeaders=getResponseHeaders?getResponseHeaders(xhr.getAllResponseHeaders()):{};if(xhr.status>=200&&xhr.status<300){const parsed=parseResponse?parseResponse(xhr.responseText):xhr.responseText;if(onSuccess)onSuccess(parsed,responseHeaders);}else{const parsed=parseErrorResponse?parseErrorResponse(xhr.responseText):xhr.responseText;if(onError)onError(parsed,xhr.status,responseHeaders)}callOnce();}};xhr.onprogress=e=>{if(onResponseProgress&&e.lengthComputable)onResponseProgress(e.loaded,e.total);};xhr.onloadstart=()=>{if(onResponseStart)onResponseStart();};xhr.onloadend=()=>{if(onResponseEnd)onResponseEnd();};xhr.ontimeout=()=>{if(onTimeoutError)onTimeoutError(xhrExtra);callOnce();};xhr.onerror=()=>{if(onError)onError(parseErrorResponse?parseErrorResponse(xhr.responseText):xhr.responseText,xhr.status||0,{});callOnce();};xhr.onabort=()=>{if(createAbortListener){const handler=createAbortListener(xhr,xhrExtra);handler();}callOnce();};xhr.upload.onprogress=e=>{if(onRequestProgress&&e.lengthComputable)onRequestProgress(e.loaded,e.total);};xhr.upload.onloadstart=()=>{if(onRequestStart)onRequestStart();};xhr.upload.onloadend=()=>{if(onRequestEnd)onRequestEnd();};try{xhr.send(payload||null);}catch(e){if(onError)onError(parseErrorResponse?parseErrorResponse(e.toString()):e.toString(),0,{});callOnce();}}"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a function to handle form submission asynchronously using XMLHttpRequest in JavaScript. The function should prevent default form submission, process form data, send it to a server via POST request, and handle the server's response to display a thank-you message upon successful submission.\n\nFunction Description: The function `handleFormSubmit` intercepts form submission events, validates the form data (checking for honeypot fields), disables all buttons during submission, sends the form data to a specified URL via POST request, and processes the server's response to update the UI accordingly.\n\nInput: \n- `event`: [Event Object] - The form submission event that triggers this function. The event object contains the target form element and allows prevention of default submission behavior.\n\nOutput: \n- None (void) - The function does not return any value but performs side effects including:\n  - Preventing default form submission\n  - Disabling form buttons during submission\n  - Sending form data to the server\n  - Updating the UI based on server response (resetting form and showing thank-you message)",
    "Canonical_solution": "function handleFormSubmit(event) {\n    event.preventDefault();\n    var form = event.target;\n    var formData = getFormData(form);\n    var data = formData.data;\n\n    if (formData.honeypot) {\n        return false;\n    }\n\n    disableAllButtons(form);\n    var url = form.action;\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            form.reset();\n            var formElements = form.querySelector(\".form-elements\")\n            if (formElements) {\n                formElements.style.display = \"none\";\n            }\n            var thankYouMessage = form.querySelector(\".thankyou_message\");\n            if (thankYouMessage) {\n                thankYouMessage.style.display = \"block\";\n            }\n        }\n    };\n    var encoded = Object.keys(data).map(function(k) {\n        return encodeURIComponent(k) + \"=\" + encodeURIComponent(data[k]);\n    }).join('&');\n    xhr.send(encoded);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  const honeypotFields = form.querySelectorAll('.honeypot');\n  let isValid = true;\n  honeypotFields.forEach(field => {\n    if (field.value.trim()) {\n      isValid = false;\n    }\n  });\n  if (!isValid) {\n    return;\n  }\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => { button.disabled = true; });\n  const formData = new FormData(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action, true);\n  xhr.onload = function() {\n    buttons.forEach(button => { button.disabled = false; });\n    if (xhr.status >= 200 && xhr.status < 300) {\n      form.reset();\n      const thankYou = document.getElementById('thank-you-message');\n      if (thankYou) {\n        thankYou.style.display = 'block';\n      }\n    }\n  };\n  xhr.onerror = function() {\n    buttons.forEach(button => { button.disabled = false; });\n  };\n  xhr.send(formData);\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "async function sendPostRequest() {\n  const url = 'https://example.com/api/endpoint';\n  const data = { username: 'test', password: 'secret' };\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body: new URLSearchParams(data).toString(),\n      credentials: 'include'\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n\n    const result = await response.json();\n    console.log('Response:', result);\n  } catch (error) {\n    console.error('Request failed:', error);\n  }\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a JavaScript class that handles AJAX requests using XMLHttpRequest, supporting cross-origin requests, custom headers, and various response handling scenarios.\n\nClass Description: The AjaxTransport class provides a wrapper around XMLHttpRequest for making asynchronous HTTP requests. It handles request creation, header management, response processing, and cleanup. The class supports CORS, maintains request state, and provides error handling capabilities.\n\nAttributes:\n\nxhrId: [Number] - Counter for generating unique IDs for each XMLHttpRequest instance\nxhrCallbacks: [Object] - Stores callback functions for active requests\nxhrSuccessStatus: [Object] - Maps certain HTTP status codes to standard success codes\nxhrSupported: [XMLHttpRequest|Boolean] - Stores the created XMLHttpRequest instance or false if not supported\n\nMethods:\n\ncreateXHR: () -> [XMLHttpRequest|undefined] - Creates and returns a new XMLHttpRequest instance or undefined if creation fails\n\nsendRequest: (options: Object, headers: Object, complete: Function) -> [undefined] - \n  Sends an AJAX request with the given configuration\n  options: Contains request parameters (type, url, async, etc.)\n  headers: Key-value pairs of request headers\n  complete: Callback function to handle response\n\nabortRequest: (callback: Function) -> [undefined] - \n  Aborts an active request and executes the given callback\n  callback: Function to execute after aborting\n\ngetTransport: (options: Object) -> [Object|undefined] - \n  Returns a transport object if the request can be handled\n  options: Configuration object for the request\n  Returns an object with send and abort methods or undefined if request can't be handled",
    "Canonical_solution": "var jQuery = require(\"../core\");\nvar support = require(\"../var/support\");\n\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      0: 200,\n      1223: 204\n    };\n    this.xhrSupported = this.createXHR();\n    \n    if (window.ActiveXObject) {\n      jQuery(window).on(\"unload\", () => {\n        for (var key in this.xhrCallbacks) {\n          this.xhrCallbacks[key]();\n        }\n      });\n    }\n    \n    support.cors = !!this.xhrSupported && (\"withCredentials\" in this.xhrSupported);\n    support.ajax = !!this.xhrSupported;\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch(e) {}\n  }\n\n  sendRequest(options, headers, complete) {\n    var xhr = options.xhr();\n    var id = ++this.xhrId;\n\n    xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n    if (options.xhrFields) {\n      for (var i in options.xhrFields) {\n        xhr[i] = options.xhrFields[i];\n      }\n    }\n\n    if (options.mimeType && xhr.overrideMimeType) {\n      xhr.overrideMimeType(options.mimeType);\n    }\n\n    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n      headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n    }\n\n    for (var i in headers) {\n      xhr.setRequestHeader(i, headers[i]);\n    }\n\n    var callback = (type) => {\n      return () => {\n        if (callback) {\n          delete this.xhrCallbacks[id];\n          callback = xhr.onload = xhr.onerror = null;\n\n          if (type === \"abort\") {\n            xhr.abort();\n          } else if (type === \"error\") {\n            complete(xhr.status, xhr.statusText);\n          } else {\n            complete(\n              this.xhrSuccessStatus[xhr.status] || xhr.status,\n              xhr.statusText,\n              typeof xhr.responseText === \"string\" ? { text: xhr.responseText } : undefined,\n              xhr.getAllResponseHeaders()\n            );\n          }\n        }\n      };\n    };\n\n    xhr.onload = callback();\n    xhr.onerror = callback(\"error\");\n    callback = this.xhrCallbacks[id] = callback(\"abort\");\n\n    try {\n      xhr.send(options.hasContent && options.data || null);\n    } catch (e) {\n      if (callback) {\n        throw e;\n      }\n    }\n  }\n\n  abortRequest(callback) {\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (support.cors || this.xhrSupported && !options.crossDomain) {\n      return {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: () => this.abortRequest(callback)\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "class AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = { 200: 200, 204: 204, 206: 206, 304: 304 };\n    this.xhrSupported = typeof XMLHttpRequest !== 'undefined';\n  }\n\n  createXHR() {\n    if (this.xhrSupported) {\n      return new XMLHttpRequest();\n    }\n    return undefined;\n  }\n\n  sendRequest(options, headers, complete) {\n    const xhr = this.createXHR();\n    if (!xhr) {\n      complete(new Error('XMLHttpRequest not supported'), null, 0);\n      return;\n    }\n\n    const id = this.xhrId++;\n    this.xhrCallbacks[id] = xhr;\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        if (this.xhrCallbacks[id]) {\n          delete this.xhrCallbacks[id];\n          let success = false;\n          try {\n            success = xhr.status in this.xhrSuccessStatus;\n          } catch (e) {\n            success = false;\n          }\n          if (success || (xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n            complete(null, xhr.responseText, xhr.status, xhr);\n          } else {\n            complete(new Error('Request failed'), null, xhr.status, xhr);\n          }\n        }\n      }\n    };\n\n    xhr.onerror = (e) => {\n      if (this.xhrCallbacks[id]) {\n        delete this.xhrCallbacks[id];\n        complete(new Error('Network error'), null, 0, xhr);\n      }\n    };\n\n    xhr.ontimeout = () => {\n      if (this.xhrCallbacks[id]) {\n        delete this.xhrCallbacks[id];\n        complete(new Error('Request timed out'), null, 0, xhr);\n      }\n    };\n\n    xhr.onabort = () => {\n      if (this.xhrCallbacks[id]) {\n        delete this.xhrCallbacks[id];\n        complete(new Error('Request aborted'), null, 0, xhr);\n      }\n    };\n\n    xhr.open(options.type || 'GET', options.url, options.async !== false);\n\n    for (let header in headers) {\n      if (headers.hasOwnProperty(header)) {\n        xhr.setRequestHeader(header, headers[header]);\n      }\n    }\n\n    if (options.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    if (options.responseType) {\n      xhr.responseType = options.responseType;\n    }\n\n    xhr.send(options.data || null);\n  }\n\n  abortRequest(callback) {\n    for (let id in this.xhrCallbacks) {\n      const xhr = this.xhrCallbacks[id];\n      if (xhr && xhr.readyState !== XMLHttpRequest.DONE) {\n        xhr.abort();\n      }\n    }\n    this.xhrCallbacks = {};\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (!this.xhrSupported) {\n      return undefined;\n    }\n    return {\n      send: (headers, complete) => {\n        this.sendRequest(options, headers, complete);\n      },\n      abort: (callback) => {\n        this.abortRequest(callback);\n      }\n    };\n  }\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', '/test-endpoint', true);\n    xhr.onload = () => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR request failed');\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('/test-endpoint')\n      .then(response => response.text())\n      .then(text => sender.postMessage(text))\n      .catch(error => sender.postMessage(`Fetch error: ${error.message}`));\n  } else if (data === 'importScripts') {\n    try {\n      importScripts('/test-script.js');\n      sender.postMessage('Script message');\n    } catch (e) {\n      sender.postMessage(`Import error: ${e.message}`);\n    }\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function loadYamlUrl(url) {\n  fetch(url).then(response => {\n    if (response.status === 200) {\n      return response.text().then(text => {\n        console.log(text);\n        yamlToForm(text);\n      });\n    }\n  });\n}"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class URLExpander{constructor(){this.map={isgd:\"is.gd\",google:\"goo.gl\",budurl:\"budurl.com\",snipurl:\"snipurl.com\"};this.timeout=1e4;this.APIs={isgd:this.handleIsGd.bind(this),google:this.handleGoogle.bind(this),budurl:this.handleBudUrl.bind(this),snipurl:this.handleSnipUrl.bind(this)}}expand(e,t){const n=e.url,r=e.depth||0,o=e.seen||{},a=10;if(r>=a)return t({url:n,depth:r,seen:o,err:new Error(\"Maximum expansion depth exceeded\")});if(o[n])return t({url:n,depth:r,seen:o,err:new Error(\"Cycle detected\")});o[n]=!0;let i;try{i=new URL(n)}catch(e){return t({url:n,depth:r,seen:o,err:new Error(\"Invalid URL\")})}const u=i.hostname,c=this.getServiceForHost(u);if(!c)return t({url:n,depth:r,seen:o});const s=this.APIs[c];if(s)s(n,(e,a,i)=>{if(e)return t({url:n,depth:r,seen:o,err:e,headers:i});a?this.expand({url:a,depth:r+1,seen:o},t):this.followRedirect(n,(e,a,i)=>{if(e)return t({url:n,depth:r,seen:o,err:e,headers:i});this.expand({url:a,depth:r+1,seen:o},t)})});else this.followRedirect(n,(e,a,i)=>{if(e)return t({url:n,depth:r,seen:o,err:e,headers:i});this.expand({url:a,depth:r+1,seen:o},t)})}getServiceForHost(e){for(const t in this.map)if(this.map[t]===e)return t}followRedirect(e,t){const n=new URL(e),r=n.protocol.startsWith(\"https\")?require(\"https\"):require(\"http\"),o={method:\"HEAD\",hostname:n.hostname,path:n.pathname+n.search+(n.hash||\"\"),headers:{Host:n.hostname,\"User-Agent\":\"URLExpander/1.0\"}};const a=r.request(o,i=>{i.resume();if(i.statusCode>=300&&i.statusCode<400&&i.headers.location)try{const e=new URL(i.headers.location,n.href).href;t(null,e,i.headers)}catch(e){t(new Error(\"Invalid redirect URL\"),null,i.headers)}else this.makeGetRequest(n.href,t)});a.on(\"error\",e=>t(e)),a.setTimeout(this.timeout,()=>{a.abort(),t(new Error(\"Request timeout\"))}),a.end()}makeGetRequest(e,t){const n=new URL(e),r=n.protocol.startsWith(\"https\")?require(\"https\"):require(\"http\"),o={method:\"GET\",hostname:n.hostname,path:n.pathname+n.search+(n.hash||\"\"),headers:{Host:n.hostname,\"User-Agent\":\"URLExpander/1.0\"}};const a=r.get(o,i=>{i.resume();if(i.statusCode>=300&&i.statusCode<400&&i.headers.location)try{const e=new URL(i.headers.location,n.href).href;t(null,e,i.headers)}catch(e){t(new Error(\"Invalid redirect URL\"),null,i.headers)}else t(null,n.href,i.headers)});a.on(\"error\",e=>t(e)),a.setTimeout(this.timeout,()=>{a.abort(),t(new Error(\"Request timeout\"))})}handleIsGd(e,t){const n=new URL(`https://is.gd/forward.php?shorturl=${encodeURIComponent(e)}`),r=n.protocol.startsWith(\"https\")?require(\"https\"):require(\"http\");const o=r.get({hostname:n.hostname,path:n.pathname+n.search,headers:{Host:n.hostname}},a=>{a.resume();if(a.statusCode>=300&&a.statusCode<400&&a.headers.location){const e=new URL(a.headers.location,n.href).href;t(null,e,a.headers)}else t(new Error(\"No redirect found in is.gd API response\"),null,a.headers)});o.on(\"error\",e=>t(e)),o.setTimeout(this.timeout,()=>{o.abort(),t(new Error(\"Request timeout\"))})}handleGoogle(e,t){t(null,null)}handleBudUrl(e,t){t(null,null)}handleSnipUrl(e,t){t(null,null)}}"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst multer = require('multer');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n\n    const storage = multer.memoryStorage();\n    const upload = multer({ storage });\n\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n    this.app.use(upload.any());\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.port, resolve);\n      this.server.on('error', reject);\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method.toLowerCase()](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    const url = `https://api.twitter.com${path}`;\n    const reqOpts = {\n      url,\n      headers: {\n        'User-Agent': 'TwitterHTTPClient/1.0',\n        'Content-Type': 'application/json'\n      }\n    };\n    const twitOptions = { params };\n    return new Promise((resolve, reject) => {\n      this._doRestApiRequest(reqOpts, twitOptions, method, (err, data) => {\n        if (callback) callback(err, data);\n        if (err) reject(err);\n        else resolve(data);\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const https = require('https');\n    const url = new URL(reqOpts.url);\n    const options = {\n      hostname: url.hostname,\n      path: url.pathname,\n      method,\n      headers: reqOpts.headers\n    };\n\n    const req = https.request(options, (res) => {\n      this._updateClockOffsetFromResponse(res);\n      let data = '';\n      res.on('data', (chunk) => data += chunk);\n      res.on('end', () => {\n        try {\n          const json = JSON.parse(data);\n          if (res.statusCode >= 200 && res.statusCode < 300) {\n            callback(null, json);\n          } else {\n            callback(new Error(`Twitter API error: ${json.error}`), null);\n          }\n        } catch (e) {\n          callback(e, null);\n        }\n      });\n    });\n\n    req.on('error', (e) => {\n      callback(e, null);\n    });\n\n    if (method === 'POST' && twitOptions.params) {\n      req.write(JSON.stringify(twitOptions.params));\n    }\n\n    req.end();\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const dateHeader = resp.headers['date'];\n    if (dateHeader) {\n      const twitterTime = new Date(dateHeader).getTime();\n      const localTime = Date.now();\n      this._twitter_time_minus_local_time_ms = twitterTime - localTime;\n    }\n  }\n}"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com']\n        };\n        this.timeout = 5000;\n        this.maxDepth = 10;\n        this.APIs = {\n            isgd: this.isgd.bind(this),\n            googl: this.googl.bind(this),\n            budurl: this.budurl.bind(this),\n            snipurl: this.snipurl.bind(this),\n            generic: this.generic.bind(this)\n        };\n    }\n\n    getServiceForDomain(domain) {\n        for (const service in this.map) {\n            if (this.map[service].includes(domain)) {\n                return service;\n            }\n        }\n        return null;\n    }\n\n    expand(args, callback) {\n        const { url, depth = 0, seen = {} } = args;\n\n        let hostname;\n        try {\n            hostname = new URL(url).hostname;\n        } catch (err) {\n            return callback({ url, depth, seen, err: new Error('Invalid URL') });\n        }\n\n        if (depth >= this.maxDepth) {\n            return callback({ url, depth, seen, err: new Error('Maximum expansion depth exceeded') });\n        }\n\n        if (seen[url]) {\n            return callback({ url, depth, seen, err: new Error('Cycle detected') });\n        }\n\n        seen[url] = true;\n\n        const service = this.getServiceForDomain(hostname);\n        const handler = service ? this.APIs[service] : this.APIs.generic;\n\n        handler(url, (err, expandedUrl, headers) => {\n            if (err) {\n                return callback({ url, depth, seen, err, headers });\n            }\n\n            try {\n                const newHostname = new URL(expandedUrl).hostname;\n                const newService = this.getServiceForDomain(newHostname);\n                if (newService || newHostname !== hostname) {\n                    this.expand({ url: expandedUrl, depth: depth + 1, seen }, callback);\n                } else {\n                    callback({ url: expandedUrl, depth, seen, headers });\n                }\n            } catch (parseErr) {\n                callback({ url: expandedUrl, depth, seen, err: parseErr });\n            }\n        });\n    }\n\n    generic(url, callback) {\n        const parsedUrl = new URL(url);\n        const isHttps = parsedUrl.protocol === 'https:';\n        const module = isHttps ? require('https') : require('http');\n        const options = {\n            hostname: parsedUrl.hostname,\n            port: parsedUrl.port || (isHttps ? 443 : 80),\n            path: parsedUrl.pathname + parsedUrl.search,\n            method: 'HEAD',\n            headers: {\n                'User-Agent': 'URLExpander/1.0'\n            }\n        };\n\n        let req;\n        const timeoutId = setTimeout(() => {\n            if (req && req.abort) {\n                req.abort();\n            }\n            callback(new Error('Request timeout'));\n        }, this.timeout);\n\n        req = module.request(options, (res) => {\n            clearTimeout(timeoutId);\n            let redirectUrl = null;\n\n            if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n                try {\n                    redirectUrl = new URL(res.headers.location, url).href;\n                } catch (e) {\n                    return callback(new Error(`Invalid redirect URL: ${res.headers.location}`));\n                }\n            }\n\n            callback(null, redirectUrl || url, res.headers);\n        });\n\n        req.on('error', (err) => {\n            clearTimeout(timeoutId);\n            callback(err);\n        });\n\n        req.end();\n    }\n\n    isgd(url, callback) {\n        this.generic(url, callback);\n    }\n\n    googl(url, callback) {\n        this.generic(url, callback);\n    }\n\n    budurl(url, callback) {\n        this.generic(url, callback);\n    }\n\n    snipurl(url, callback) {\n        this.generic(url, callback);\n    }\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "const request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'https://example.com/api/data';\n  const headers = {\n    'User-Agent': 'Node.js',\n    'Authorization': 'Bearer YOUR_TOKEN'\n  };\n\n  request.get({ url, headers, gzip: true }, (error, response, body) => {\n    if (error) {\n      console.error('Request error:', error);\n      return;\n    }\n\n    if (response.statusCode === 200) {\n      console.log('Response body:', body);\n    } else {\n      console.error(`Unexpected status code: ${response.statusCode}`);\n    }\n  });\n}\n\nmakeHttpRequest();"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst session = require('express-session');\nconst MongoStore = require('connect-mongo')(session);\nconst mongoose = require('mongoose');\nconst next = require('next');\n\nfunction setupServer() {\n  const dev = process.env.NODE_ENV !== 'production';\n  const nextApp = next({ dev });\n  const handle = nextApp.getRequestHandler();\n\n  nextApp.prepare().then(() => {\n    const app = express();\n\n    mongoose.connect(process.env.MONGO_URL_TEST, { useNewUrlParser: true, useUnifiedTopology: true });\n\n    const sessionStore = new MongoStore({ mongooseConnection: mongoose.connection });\n\n    app.use(session({\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      resave: false,\n      saveUninitialized: false,\n      store: sessionStore,\n      cookie: {\n        maxAge: 1000 * 60 * 60 * 24 * 7,\n        httpOnly: true,\n        secure: !dev\n      }\n    }));\n\n    app.all('*', (req, res) => {\n      return handle(req, res);\n    });\n\n    const port = process.env.PORT || 8000;\n    app.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`Server ready at http://localhost:${port}`);\n    });\n  }).catch(err => {\n    console.error('Failed to start server:', err);\n  });\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a function that initializes and configures an Express.js web application with middleware, route handlers, and server listening capabilities, including optional HTTPS support.\n\nFunction Description: The function `createExpressApp` creates and configures an Express.js application instance with various middleware (CORS, security headers, caching), route handlers for API endpoints and static files, and error handling. It starts an HTTP server (and optionally an HTTPS server) listening on specified ports. The function returns the configured Express application instance.\n\nInput: None (The function uses global configuration variables like CONFIG and process.env for settings)\n\nOutput: Express.Application - Returns the fully configured Express.js application instance after setting up all middleware, routes, and server listeners.",
    "Canonical_solution": "function createExpressApp() {\n    var express = require('express');\n    var app = express();\n\n    app.use(express.bodyParser());\n    app.set('view engine', 'ejs');\n\n    if (CONFIG.allowedOrigins) {\n        app.use(function(req, res, next) {\n            var origin = req.headers[\"origin\"];\n            if (origin) {\n                if (CONFIG.allowedOrigins.indexOf('*') > -1) {\n                    res.setHeader('Access-Control-Allow-Origin', '*');\n                } else {\n                    if (CONFIG.allowedOrigins.indexOf(origin) > -1) {\n                        res.setHeader('Access-Control-Allow-Origin', origin);\n                    }\n                }\n            }\n            next();\n        });\n    }\n\n    app.disable('x-powered-by');\n    app.use(function(req, res, next) {\n        res.setHeader('X-Powered-By', 'Iframely');\n        next();\n    });\n\n    app.use(sysUtils.cacheMiddleware);\n\n    require('./modules/api/views')(app);\n    require('./modules/debug/views')(app);\n    require('./modules/tests-ui/views')(app);\n\n    app.use(logErrors);\n    app.use(errorHandler);\n\n    app.get(CONFIG.relativeStaticUrl + '/*', function(req, res, next) {\n        var url = '/' + req.url.split('/').splice(2).join('/');\n        sysUtils.static(path.resolve(__dirname, 'static'), {path: url})(req, res, next);\n    });\n\n    app.get('/', function(req, res) {\n        res.writeHead(302, { Location: 'http://iframely.com'});\n        res.end();\n    });\n\n    var listener = app.listen(process.env.PORT || CONFIG.port, process.env.HOST || CONFIG.host, function(){\n        console.log('\\niframely is listening on ' + listener.address().address + ':' + listener.address().port + '\\n');\n    });\n\n    if (CONFIG.ssl) {\n        var options = { key: CONFIG.ssl.key, cert: CONFIG.ssl.cert };\n        require('https').createServer(options, app).listen(CONFIG.ssl.port);\n    }\n\n    return app;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst compression = require('compression');\nconst fs = require('fs');\nconst http = require('http');\nconst https = require('https');\n\nfunction createExpressApp() {\n  const app = express();\n  const port = process.env.PORT || CONFIG.port || 3000;\n\n  app.use(cors(CONFIG.corsOptions || {}));\n  app.use(helmet(CONFIG.helmetOptions || {}));\n  app.use(express.json());\n  app.use(express.urlencoded({ extended: true }));\n  if (CONFIG.enableCompression) app.use(compression());\n\n  app.use(express.static(CONFIG.staticDir || 'public'));\n\n  const apiRouter = require('./routes/api');\n  app.use('/api', apiRouter);\n\n  app.use((err, req, res, next) => {\n    res.status(err.status || 500).json({\n      message: err.message,\n      error: CONFIG.env === 'development' ? err : {}\n    });\n  });\n\n  const httpServer = http.createServer(app);\n  httpServer.listen(port, () => {\n    console.log(`HTTP server running on port ${port}`);\n  });\n\n  if (CONFIG.https && CONFIG.https.enabled) {\n    const options = {\n      key: fs.readFileSync(CONFIG.https.keyPath),\n      cert: fs.readFileSync(CONFIG.https.certPath)\n    };\n    const httpsServer = https.createServer(options, app);\n    const httpsPort = CONFIG.https.port || 443;\n    httpsServer.listen(httpsPort, () => {\n      console.log(`HTTPS server running on port ${httpsPort}`);\n    });\n  }\n\n  return app;\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a function to set up a server using Express.js with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates Next.js for server-side rendering, and sets up basic route handling. It prepares the server environment, configures middleware, and starts listening on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption\n)\n\nOutput: None (The function starts a server process that:\n1. Creates an Express server with session management\n2. Integrates Next.js for server-side rendering\n3. Sets up route handling\n4. Listens on the specified port\n5. Logs server readiness to console\n)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst session = require('express-session');\nconst MongoStore = require('connect-mongo');\nconst next = require('next');\nconst { MongoClient } = require('mongodb');\n\nasync function setupServer() {\n  const dev = process.env.NODE_ENV !== 'production';\n  const nextApp = next({ dev });\n  const handle = nextApp.getRequestHandler();\n\n  await nextApp.prepare();\n\n  const client = new MongoClient(process.env.MONGO_URL_TEST, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n  });\n\n  try {\n    await client.connect();\n  } catch (err) {\n    console.error('MongoDB connection error:', err);\n    process.exit(1);\n  }\n\n  const server = express();\n\n  const sessionMiddleware = session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    store: new MongoStore({ client: client }),\n    cookie: { maxAge: 1000 * 60 * 60 * 24 },\n  });\n\n  server.use(sessionMiddleware);\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, () => {\n    console.log(`Server is ready on port ${port}`);\n  });\n}\n\nmodule.exports = setupServer;"
  }
]