[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const crypto = require('crypto');\nconst axios = require('axios');\n\nclass Trader {\n  constructor(config) {\n    this.key = config.key;\n    this.secret = config.secret;\n    this.currency = config.currency;\n    this.asset = config.asset;\n    this.pair = `${this.asset}_${this.currency}`;\n    this.name = 'EXMO';\n    this.nonce = 0;\n  }\n\n  api_query(method, params, callback) {\n    this.nonce += 1;\n    const url = `https://api.exmo.com/v1.1/${method}`;\n    params.nonce = this.nonce;\n    params.pair = this.pair;\n\n    const sign = crypto.createHmac('sha512', this.secret)\n      .update(`${params.nonce}${this.key}${params.pair}`)\n      .digest('hex');\n\n    const headers = {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Key': this.key,\n      'Sign': sign\n    };\n\n    axios.post(url, new URLSearchParams(params), { headers })\n      .then(response => {\n        if (response.data.error) {\n          return callback(new Error(response.data.error), null);\n        }\n        callback(null, response.data);\n      })\n      .catch(error => {\n        callback(error, null);\n      });\n  }\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': ['is.gd', 'tiny.is'],\n      'goo.gl': ['goo.gl'],\n      'budurl.com': ['budurl.com'],\n      'snipurl.com': ['snipurl.com', 'sni.pr']\n    };\n    this.timeout = 5000;\n  }\n\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n    \n    if (depth > 10 || seen[url]) {\n      return callback(null, { url, expanded: url, error: 'Possible loop or max depth reached' });\n    }\n    \n    seen[url] = true;\n    \n    const hostname = new URL(url).hostname;\n    const service = Object.entries(this.map).find(([_, domains]) => \n      domains.includes(hostname)\n    )?.[0];\n    \n    const apiMethod = this[service] || this.generic;\n    \n    apiMethod.call(this, { url, depth, seen }, (err, expandedUrl) => {\n      if (err) return callback(err, { url, expanded: url, error: err.message });\n      \n      if (expandedUrl === url) {\n        return callback(null, { url, expanded: url });\n      }\n      \n      this.expand({ url: expandedUrl, depth: depth + 1, seen }, callback);\n    });\n  }\n\n  isgd(args, callback) {\n    const apiUrl = `https://is.gd/forward.php?shorturl=${encodeURIComponent(args.url)}&format=json`;\n    \n    fetch(apiUrl, { method: 'HEAD', redirect: 'manual' })\n      .then(response => {\n        if (response.status >= 300 && response.status < 400 && response.headers.get('Location')) {\n          callback(null, response.headers.get('Location'));\n        } else {\n          callback(new Error('No redirect location'), null);\n        }\n      })\n      .catch(error => callback(error, null));\n  }\n\n  googl(args, callback) {\n    fetch(args.url, { method: 'HEAD', redirect: 'manual' })\n      .then(response => {\n        if (response.status >= 300 && response.status < 400 && response.headers.get('Location')) {\n          callback(null, response.headers.get('Location'));\n        } else {\n          callback(new Error('No redirect location'), null);\n        }\n      })\n      .catch(error => callback(error, null));\n  }\n\n  budurl(args, callback) {\n    fetch(args.url, { method: 'HEAD', redirect: 'manual' })\n      .then(response => {\n        if (response.status >= 300 && response.status < 400 && response.headers.get('Location')) {\n          callback(null, response.headers.get('Location'));\n        } else {\n          callback(new Error('No redirect location'), null);\n        }\n      })\n      .catch(error => callback(error, null));\n  }\n\n  snipurl(args, callback) {\n    fetch(args.url, { method: 'HEAD', redirect: 'manual' })\n      .then(response => {\n        if (response.status >= 300 && response.status < 400 && response.headers.get('Location')) {\n          callback(null, response.headers.get('Location'));\n        } else {\n          callback(new Error('No redirect location'), null);\n        }\n      })\n      .catch(error => callback(error, null));\n  }\n\n  generic(args, callback) {\n    fetch(args.url, { method: 'HEAD', redirect: 'manual' })\n      .then(response => {\n        if (response.status >= 300 && response.status < 400 && response.headers.get('Location')) {\n          callback(null, response.headers.get('Location'));\n        } else {\n          callback(null, args.url); // No further redirects found\n        }\n      })\n      .catch(error => callback(error, args.url));\n  }\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create a function to set up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB as the session store. It integrates Next.js for server-side rendering and sets up a catch-all route handler. The server listens on a specified port and connects to MongoDB using environment variables for configuration.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that:\n- Listens on the specified port\n- Outputs the server URL to console when ready\n- Maintains persistent connections to MongoDB for session storage)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  mongoose.connect(MONGO_URL);\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  const server = express();\n\n  const sessionOptions = {\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    store: mongoSessionStore.create({\n      mongoUrl: MONGO_URL,\n      ttl: 14 * 24 * 60 * 60,\n    }),\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      httpOnly: true,\n      maxAge: 14 * 24 * 60 * 60 * 1000,\n      domain: 'localhost',\n    },\n  };\n\n  const sessionMiddleware = session(sessionOptions);\n  server.use(sessionMiddleware);\n\n  server.get('*', (req, res) => handle(req, res));\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on ${ROOT_URL}`);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst session = require('express-session');\nconst MongoDBStore = require('connect-mongodb-session')(session);\nconst mongoose = require('mongoose');\nconst next = require('next');\n\nconst setupServer = async () => {\n  const dev = process.env.NODE_ENV !== 'production';\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  await app.prepare();\n\n  const server = express();\n\n  const store = new MongoDBStore({\n    uri: process.env.MONGO_URL_TEST,\n    collection: 'sessions',\n  });\n\n  server.use(session({\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    store: store,\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      maxAge: 1000 * 60 * 60 * 24 * 7, // 1 week\n      httpOnly: true,\n      secure: !dev,\n      sameSite: 'strict',\n    },\n  }));\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n\n  await mongoose.connect(process.env.MONGO_URL_TEST, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n  });\n\n  const listener = server.listen(port, () => {\n    console.log(`Server is running on http://localhost:${port}`);\n  });\n\n  return { app, server, listener };\n};\n\nmodule.exports = setupServer;"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with essential middleware (CORS, static file serving, JSON body parsing), configures route handlers, and starts listening on a specified port. It handles both API routes and serves static HTML files.\n\nInput: None (The function uses imported modules and configuration from './src/config' and './src/routes')\n\nOutput: None (The function's side effect is starting an HTTP server that listens on the configured port)",
    "Canonical_solution": "function setupExpressServer() {\n    const bodyParser = require('body-parser');\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const config = require('./src/config');\n    const routes = require('./src/routes');\n\n    const app = express();\n\n    app.enable('trust proxy');\n    app.use(cors());\n    app.use(express.static(path.join(__dirname, 'www')));\n    app.use(bodyParser.json());\n\n    app.get('/v2', (req, res) => res.sendFile(path.join(__dirname, 'www/index.html')));\n    app.use(routes);\n\n    app.listen(config.PORT, err => {\n        if (err) console.error(err);\n        console.log('Server started on ' + config.PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "import express from 'express';\nimport cors from 'cors';\nimport config from './src/config';\nimport routes from './src/routes';\n\nfunction setupExpressServer() {\n    const app = express();\n    app.use(cors());\n    app.use(express.json());\n    app.use(express.static('public'));\n    app.use('/api', routes);\n    app.get('*', (req, res) => {\n        res.sendFile('public/index.html', { root: '.' });\n    });\n    app.listen(config.port, () => {\n        console.log(`Server running on port ${config.port}`);\n    });\n}"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a target API while modifying request and response headers.\n\nFunction Description: The function `createProxyServer` initializes an Express application that acts as a proxy server. It configures middleware to forward all incoming requests to a specified target API (https://api.openai.com in this case), removes certain headers from outgoing requests, and adds CORS headers to responses. The server listens on port 9000 by default.\n\nInput: None (The function takes no parameters as all configurations are hardcoded)\n\nOutput: None (The function doesn't return anything but starts a server process that continues running)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('http-proxy-middleware');\n    const app = express();\n    const port = 9000;\n\n    app.use('/', createProxyMiddleware({\n        target: 'https://api.openai.com',\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('x-forwarded-for');\n            proxyReq.removeHeader('x-real-ip');\n        },\n        onProxyRes: function (proxyRes, req, res) {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n        }\n    }));\n\n    app.listen(port, () => {\n        console.log(`Example app listening at http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nfunction createProxyServer() {\n    const app = express();\n\n    const proxyMiddleware = createProxyMiddleware({\n        target: 'https://api.openai.com',\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('host');\n            proxyReq.removeHeader('authorization');\n        },\n        onProxyRes: (proxyRes, req, res) => {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n            proxyRes.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';\n            proxyRes.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';\n        }\n    });\n\n    app.use((req, res, next) => {\n        if (req.path === '/v1/chat/completions') {\n            req.headers['host'] = 'api.openai.com';\n        }\n        next();\n    });\n\n    app.use(proxyMiddleware);\n\n    app.listen(9000, () => {\n        console.log('Proxy server is running on port 9000');\n    });\n}\n\ncreateProxyServer();"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "var crypto = require('crypto');\nvar fs = require('fs');\nvar path = require('path');\n\nfunction TSClient(query, cb) {\n  this.search = {\n    q: query,\n    since_id: null,\n    rcount: 0\n  };\n  this.id = crypto.createHash('md5').update(query).digest('hex');\n  this.new_since_id = null;\n  this._loadState(() => {\n    cb(this);\n  });\n}\n\nTSClient.prototype._loadState = function(cb) {\n  var statePath = this._getStatePath();\n  fs.readFile(statePath, 'utf8', (err, data) => {\n    if (!err && data) {\n      try {\n        var state = JSON.parse(data);\n        this.search.since_id = state.since_id || null;\n      } catch (e) {}\n    }\n    cb();\n  });\n};\n\nTSClient.prototype._getStatePath = function() {\n  return path.join(__dirname, 'state', this.id + '.json');\n};\n\nTSClient.prototype.set = function(search) {\n  this.search = Object.assign({}, this.search, search);\n  this.new_since_id = search.since_id || this.new_since_id;\n  var statePath = this._getStatePath();\n  fs.mkdir(path.dirname(statePath), { recursive: true }, () => {\n    fs.writeFile(statePath, JSON.stringify(this.search), () => {});\n  });\n};\n\nTSClient.prototype.syncSearch = function(callback) {\n  var s = {\n    ts: this,\n    search: Object.assign({}, this.search),\n    cb: callback,\n    page: 1,\n    results: []\n  };\n  this._walker(s);\n};\n\nTSClient.prototype._walker = function(s) {\n  var params = Object.assign({}, s.search, {\n    page: s.page\n  });\n  \n  // Simulated Twitter API request\n  simulateTwitterAPIRequest(params, (err, tweets, nextResults) => {\n    if (err) {\n      s.cb(err);\n      return;\n    }\n\n    if (tweets && tweets.length > 0) {\n      s.results = s.results.concat(tweets);\n      \n      if (!s.ts.new_since_id || tweets[0].id > s.ts.new_since_id) {\n        s.ts.new_since_id = tweets[0].id;\n      }\n\n      if (nextResults) {\n        s.page++;\n        s.search.max_id = nextResults.max_id;\n        s.search.page = s.page;\n        setImmediate(() => s.ts._walker(s));\n      } else {\n        if (s.ts.new_since_id) {\n          s.ts.set({ since_id: s.ts.new_since_id });\n        }\n        s.cb(null, s.results);\n      }\n    } else {\n      if (s.ts.new_since_id) {\n        s.ts.set({ since_id: s.ts.new_since_id });\n      }\n      s.cb(null, s.results);\n    }\n  });\n};\n\n// Simulated Twitter API request function\nfunction simulateTwitterAPIRequest(params, callback) {\n  // In a real implementation, this would be an actual API call to Twitter\n  setTimeout(() => {\n    var tweetCount = Math.floor(Math.random() * 10);\n    var tweets = [];\n    \n    for (var i = 0; i < tweetCount; i++) {\n      tweets.push({\n        id: Date.now() - i,\n        text: \"Sample tweet about \" + params.q + \" #\" + i,\n        created_at: new Date(Date.now() - i * 60000).toISOString()\n      });\n    }\n    \n    var hasMore = Math.random() > 0.7;\n    var nextResults = hasMore ? {\n      max_id: tweets[tweets.length - 1].id - 1\n    } : null;\n    \n    callback(null, tweets, nextResults);\n  }, 100);\n}"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst path = require('path');\nconst app = express();\nconst routes = require('./routes'); // assuming route handlers are in a module named 'routes'\n\nfunction createExpressServer() {\n    const port = process.env.PORT || 3000;\n    const parentDir = path.join(__dirname, '..');\n\n    app.use(express.static(parentDir));\n    app.use('/api', routes);\n\n    const server = app.listen(port, () => {\n        console.log(`Server is running on port ${port}`);\n    });\n\n    return server;\n}\n\nmodule.exports = createExpressServer;"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function uploads a specified file to a server using Node.js's filesystem and HTTP modules. It streams the file content directly to the HTTP request using pipe(), avoiding loading the entire file into memory. The function sets appropriate headers including content-type (multipart/form-data) and content-length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart form data\n\nOutput: None (The function makes an HTTP request but doesn't return any value. The actual upload result would be handled by the server's response, which isn't captured in this function.)",
    "Canonical_solution": "function uploadFile() {\n  const fs = require('fs');\n  const http = require('http');\n  \n  const stat = fs.statSync(FIXTURE);\n  const request = http.request({\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'content-length': stat.size,\n    },\n  });\n  \n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "const fs = require('fs');\nconst http = require('http');\nconst path = require('path');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n    const filename = path.basename(FIXTURE);\n    const stats = fs.statSync(FIXTURE);\n    const fileSize = stats.size;\n\n    const boundary = BOUNDARY;\n    const requestHeaders = {\n        'Content-Type': `multipart/form-data; boundary=${boundary}`,\n        'Content-Length': fileSize\n    };\n\n    const options = {\n        hostname: 'localhost',\n        port: TEST_PORT,\n        path: '/upload',\n        method: 'POST',\n        headers: requestHeaders\n    };\n\n    const req = http.request(options);\n    const readStream = fs.createReadStream(FIXTURE);\n\n    readStream.pipe(req);\n}"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and handle file uploads, using Node.js's `fs` and `http` modules. The server should log connection details and save request data to files.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. It handles requests by piping the socket data to a file stream and provides a simple HTML form for file uploads. Each connection is assigned a unique filename for logging purposes.\n\nInput: None (The function does not take any input parameters)\n\nOutput: None (The function does not return any value but creates a running HTTP server that logs to the console and writes to files)",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer() {\n    let connectionCount = 0;\n\n    const server = http.createServer((req, res) => {\n        connectionCount++;\n        const filename = `request_${connectionCount}.log`;\n        const filePath = path.join(__dirname, filename);\n\n        const writeStream = fs.createWriteStream(filePath);\n\n        console.log(`New connection ${connectionCount}: ${req.method} ${req.url}`);\n\n        req.socket.on('data', (chunk) => {\n            writeStream.write(chunk);\n        });\n\n        req.socket.on('end', () => {\n            writeStream.end();\n            console.log(`Request ${connectionCount} data saved to ${filename}`);\n        });\n\n        if (req.url === '/' && req.method.toLowerCase() === 'get') {\n            res.writeHead(200, { 'Content-Type': 'text/html' });\n            res.end(`\n                <h1>Upload File</h1>\n                <form method=\"POST\" enctype=\"multipart/form-data\">\n                    <input type=\"file\" name=\"fileToUpload\" />\n                    <button type=\"submit\">Upload</button>\n                </form>\n            `);\n        } else {\n            res.writeHead(200, { 'Content-Type': 'text/plain' });\n            res.end(`Received your request. Data saved to ${filename}`);\n        }\n    });\n\n    server.listen(3000, () => {\n        console.log('Server listening on port 3000');\n    });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "const request = require('request');\n\nfunction makeHttpRequest() {\n    const url = 'https://example.com/api';\n    const headers = {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer YOUR_TOKEN'\n    };\n    const data = {\n        key1: 'value1',\n        key2: 'value2'\n    };\n\n    request.post({\n        url: url,\n        headers: headers,\n        body: JSON.stringify(data)\n    }, (error, response, body) => {\n        if (error) {\n            console.error('Request error:', error);\n            return;\n        }\n\n        if (response.statusCode >= 200 && response.statusCode < 300) {\n            try {\n                const jsonResponse = JSON.parse(body);\n                console.log('Response:', jsonResponse);\n            } catch (parseError) {\n                console.error('Error parsing JSON:', parseError);\n            }\n        } else {\n            console.error('Unexpected status code:', response.statusCode);\n            console.error('Response body:', body);\n        }\n    });\n}\n\nmakeHttpRequest();"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to record incoming connections and requests, piping the request data to individual files for each connection.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens for incoming connections. For each connection, it creates a unique file to store the raw HTTP request data. The server handles regular requests by responding with connection information and provides an HTML upload form for the root path. The server tracks active connections and logs connection/disconnection events.\n\nInput: None (The function takes no parameters but uses environment variable `PORT` for configuration)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server that writes to files)\n\nNote: The function maintains internal state including:\n- A connection counter\n- An active HTTP server instance\n- File streams for each connection\n- Logging of connection events to console",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require('fs');\n    var connections = 0;\n\n    var server = http.createServer(function(req, res) {\n        var socket = req.socket;\n        console.log('Request: %s %s -> %s', req.method, req.url, socket.filename);\n\n        req.on('end', function() {\n            if (req.url !== '/') {\n                res.end(JSON.stringify({\n                    method: req.method,\n                    url: req.url,\n                    filename: socket.filename,\n                }));\n                return;\n            }\n\n            res.writeHead(200, {'content-type': 'text/html'});\n            res.end(\n                '<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">'+\n                '<input type=\"text\" name=\"title\"><br>'+\n                '<input type=\"file\" name=\"upload\" multiple=\"multiple\"><br>'+\n                '<input type=\"submit\" value=\"Upload\">'+\n                '</form>'\n            );\n        });\n    });\n\n    server.on('connection', function(socket) {\n        connections++;\n        socket.id = connections;\n        socket.filename = 'connection-' + socket.id + '.http';\n        socket.file = fs.createWriteStream(socket.filename);\n        socket.pipe(socket.file);\n\n        console.log('--> %s', socket.filename);\n        socket.on('close', function() {\n            console.log('<-- %s', socket.filename);\n        });\n    });\n\n    var port = process.env.PORT || 8080;\n    server.listen(port, function() {\n        console.log('Recording connections on port %s', port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { parse } = require('url');\n\nfunction createServer() {\n    let connectionCount = 0;\n    const connections = new Map();\n\n    const server = http.createServer((req, res) => {\n        const connId = Date.now() + '-' + (Math.random().toString(36).substr(2, 5));\n        const filename = `conn_${connId}.log`;\n        const filepath = path.join(__dirname, 'requests', filename);\n        \n        connectionCount++;\n        const connInfo = {\n            id: connId,\n            timestamp: new Date(),\n            filename,\n            remoteAddress: req.socket.remoteAddress,\n            remotePort: req.socket.remotePort\n        };\n        \n        connections.set(connId, connInfo);\n        \n        const logStream = fs.createWriteStream(filepath);\n        console.log(`Connection ${connId} started from ${connInfo.remoteAddress}:${connInfo.remotePort}`);\n        \n        // Log request data\n        req.on('data', (chunk) => {\n            logStream.write(chunk);\n        });\n        \n        // Handle request completion\n        req.on('end', () => {\n            logStream.end();\n            console.log(`Request from ${connId} completed. Data saved to ${filename}`);\n            \n            // Send response\n            res.writeHead(200, {'Content-Type': 'text/html'});\n            if (req.url === '/') {\n                res.end(`\n                    <h1>Connection Info</h1>\n                    <p>Total connections: ${connectionCount}</p>\n                    <p>Your request has been recorded in ${filename}</p>\n                    <form method=\"POST\" enctype=\"multipart/form-data\">\n                        <input type=\"file\" name=\"upload\">\n                        <button type=\"submit\">Upload</button>\n                    </form>\n                `);\n            } else {\n                res.end(`\n                    <h1>Connection Info</h1>\n                    <p>Total connections: ${connectionCount}</p>\n                    <p>Your request has been recorded in ${filename}</p>\n                `);\n            }\n        });\n        \n        // Clean up on connection close\n        req.on('close', () => {\n            connections.delete(connId);\n            console.log(`Connection ${connId} closed`);\n        });\n    });\n\n    // Ensure requests directory exists\n    const requestsDir = path.join(__dirname, 'requests');\n    if (!fs.existsSync(requestsDir)) {\n        fs.mkdirSync(requestsDir);\n    }\n\n    const port = process.env.PORT || 3000;\n    server.listen(port, () => {\n        console.log(`Server running on port ${port}`);\n    });\n}"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to generate PDFs from HTML templates and serve them as streams.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. It serves PDF files generated from an HTML template, replacing placeholders with actual image paths, and streams the PDF output to the client. The server handles incoming requests, checks for favicon requests, and responds with either a 404 error or the generated PDF.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 8080 and logs the server address to the console.)",
    "Canonical_solution": "function createServer() {\n    const fs = require('fs');\n    const http = require('http');\n    const pdf = require('../../');\n    const tmpl = fs.readFileSync(require.resolve('../businesscard/businesscard.html'), 'utf8');\n\n    const server = http.createServer(function (req, res) {\n        if (req.url === '/favicon.ico') return res.end('404');\n        const html = tmpl.replace('{{image}}', `file://${require.resolve('../businesscard/image.png')}`);\n        pdf.create(html, {width: '50mm', height: '90mm'}).toStream((err, stream) => {\n            if (err) return res.end(err.stack);\n            res.setHeader('Content-type', 'application/pdf');\n            stream.pipe(res);\n        });\n    });\n\n    server.listen(8080, function (err) {\n        if (err) throw err;\n        console.log('Listening on http://localhost:%s', server.address().port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { createReadStream } = require('fs');\nconst ejs = require('ejs');\nconst puppeteer = require('puppeteer');\n\nasync function createServer() {\n    const server = http.createServer(async (req, res) => {\n        if (req.url === '/favicon.ico') {\n            res.writeHead(404);\n            res.end();\n            return;\n        }\n\n        const templatePath = path.join(__dirname, 'template.html');\n        const imagePath = path.join(__dirname, 'image.jpg');\n\n        try {\n            let htmlContent = fs.readFileSync(templatePath, 'utf8');\n            const imageUrl = `file://${imagePath}`;\n            htmlContent = ejs.render(htmlContent, { imageUrl });\n\n            const browser = await puppeteer.launch();\n            const page = await browser.newPage();\n            await page.setContent(htmlContent);\n            const pdfStream = await page.pdf({ format: 'A4', printBackground: true });\n\n            await browser.close();\n\n            res.writeHead(200, {\n                'Content-Type': 'application/pdf',\n                'Content-Disposition': 'inline; filename=output.pdf'\n            });\n            res.end(pdfStream);\n        } catch (error) {\n            console.error(error);\n            res.writeHead(500);\n            res.end('Internal Server Error');\n        }\n    });\n\n    server.listen(8080, () => {\n        console.log('Server running at http://localhost:8080/');\n    });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve a ReDoc documentation interface, including handling requests for the ReDoc JavaScript file and rendering the documentation page with the provided specification.\n\nFunction Description: The function creates an HTTP server that serves two main routes: (1) '/redoc.standalone.js' which streams the ReDoc JavaScript file to the client, and (2) '/' which renders a complete HTML page with the ReDoc interface hydrated with the provided OpenAPI specification. The server handles other routes with a 404 response.\n\nInput:\n- port: [number] - The port number on which the HTTP server should listen\n- filePath: [string] - The file path to the 'redoc.standalone.js' file to be served\n- specPath: [string] - The file path to the OpenAPI specification file (YAML format)\n\nOutput: None (The function starts an HTTP server that continues running until manually stopped)\n\nNote: The function assumes the availability of certain external dependencies (yaml, fs, http, React, ServerStyleSheet, Redoc) which should be imported/required in the actual implementation. The function also uses async/await for handling asynchronous operations related to the Redoc store creation.",
    "Canonical_solution": "const http = require('http');\nconst fs = require('fs');\n\nfunction createServer(port, filePath, specPath) {\n    const server = http.createServer(async (request, response) => {\n        if (request.url === '/redoc.standalone.js') {\n            fs.createReadStream(filePath, 'utf8').pipe(response);\n        } else if (request.url === '/') {\n            const spec = yaml.load(readFileSync(resolve(__dirname, specPath), 'utf-8'));\n            const store = await createStore(spec, 'path/to/spec.yaml');\n\n            const sheet = new ServerStyleSheet();\n            const html = renderToString(sheet.collectStyles(React.createElement(Redoc, { store })));\n            const css = sheet.getStyleTags();\n\n            const res = `<html>\n            <head>\n                <meta charset=\"utf8\" />\n                <title>ReDoc</title>\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                <style>\n                    body {\n                        padding: 0;\n                        margin: 0;\n                    }\n                </style>\n                <script src=\"redoc.standalone.js\"></script>\n                <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n                ${css}\n            </head>\n            <body>\n            <script>\n                document.addEventListener('DOMContentLoaded', function() {\n                    const state = ${JSON.stringify(await store.toJS())};\n                    Redoc.hydrate(state, document.getElementById('redoc'));\n                });\n                </script>\n                <div id=\"redoc\">${html}</div>\n            </body>\n            </html>`;\n            response.writeHead(200, { 'Content-Length': res.length });\n            response.write(res);\n            response.end();\n        } else {\n            response.writeHead(404);\n            response.write('Not found');\n            response.end();\n        }\n    });\n\n    server.listen(port, () => console.log(`Server started: http://127.0.0.1:${port}`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('js-yaml');\nconst React = require('react');\nconst { renderToString } = require('react-dom/server');\nconst { ServerStyleSheet } = require('styled-components');\nconst Redoc = require('redoc');\n\nfunction startReDocServer(port, filePath, specPath) {\n  async function requestHandler(req, res) {\n    if (req.url === '/redoc.standalone.js') {\n      res.setHeader('Content-Type', 'application/javascript');\n      fs.createReadStream(filePath).pipe(res);\n    } else if (req.url === '/') {\n      try {\n        const spec = await loadSpec(specPath);\n        const html = generateHTML(spec);\n        res.setHeader('Content-Type', 'text/html');\n        res.end(html);\n      } catch (e) {\n        res.statusCode = 500;\n        res.end('Internal Server Error');\n      }\n    } else {\n      res.statusCode = 404;\n      res.end('Not Found');\n    }\n  }\n\n  function loadSpec(specPath) {\n    return new Promise((resolve, reject) => {\n      fs.readFile(specPath, 'utf8', (err, data) => {\n        if (err) return reject(err);\n        try {\n          resolve(yaml.load(data));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n\n  async function generateHTML(spec) {\n    const sheet = new ServerStyleSheet();\n    try {\n      const store = await Redoc.init(spec, {}, { noScroll: true });\n      const html = `<!DOCTYPE html>\n        <html>\n          <head>\n            <title>ReDoc</title>\n            <meta charset=\"UTF-8\" />\n            <script src=\"/redoc.standalone.js\"></script>\n          </head>\n          <body>\n            <div id=\"redoc\">${renderToString(sheet.collectStyles(React.createElement(Redoc.RedocUI, { store })))}</div>\n            ${sheet.getStyleTags()}\n          </body>\n        </html>`;\n      return html;\n    } finally {\n      sheet.seal();\n    }\n  }\n\n  http.createServer(requestHandler).listen(port, () => {\n    console.log(`Server running on http://localhost:${port}`);\n  });\n}"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createFileServer() {\n    const mimeTypes = {\n        '.html': 'text/html',\n        '.js': 'application/javascript',\n        '.css': 'text/css',\n        '.png': 'image/png',\n        '.jpg': 'image/jpeg',\n        '.jpeg': 'image/jpeg',\n        '.gif': 'image/gif'\n    };\n\n    const server = http.createServer((req, res) => {\n        let filePath = path.join(process.cwd(), 'static', req.url === '/' ? 'index.html' : req.url);\n        const extname = path.extname(filePath).toLowerCase();\n        const contentType = mimeTypes[extname] || 'application/octet-stream';\n\n        fs.readFile(filePath, (err, content) => {\n            if (err) {\n                if (err.code === 'ENOENT') {\n                    res.writeHead(404, { 'Content-Type': 'text/plain' });\n                    res.end('404 Not Found', 'utf-8');\n                } else {\n                    res.writeHead(500, { 'Content-Type': 'text/plain' });\n                    res.end('Internal Server Error', 'utf-8');\n                }\n            } else {\n                res.writeHead(200, { 'Content-Type': contentType });\n                res.end(content, 'utf-8');\n            }\n        });\n    });\n\n    server.listen(1338, () => {\n        console.log('Server running at http://localhost:1338/');\n    });\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  _generateSignature(url, method, body = '') {\n    const timestamp = Math.floor(Date.now() / 1000);\n    const nonce = Math.random().toString(36).substring(2, 10);\n    const dataToSign = `${url}|${method.toUpperCase()}|${timestamp}|${nonce}|${body}`;\n    \n    // Simplified signature generation - in real use, use proper crypto library\n    const hashBuffer = new TextEncoder().encode(dataToSign + this.token);\n    const signature = btoa(String.fromCharCode.apply(null, hashBuffer));\n    \n    return { signature, timestamp, nonce };\n  }\n\n  async taskRequest(method, url, body = '') {\n    try {\n      const signingData = this._generateSignature(url, method, body);\n      \n      const headers = {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${this.token}`,\n        'X-Device-ID': this.did,\n        'X-Fingerprint': this.finger,\n        'X-OAID': this.oaid,\n        'X-Signature': signingData.signature,\n        'X-Timestamp': signingData.timestamp,\n        'X-Nonce': nonce\n      };\n\n      const options = {\n        method: method.toUpperCase(),\n        headers: headers,\n        body: method.toLowerCase() === 'post' ? body : undefined\n      };\n\n      const response = await fetch(url, options);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      throw new Error(`Request failed: ${error.message}`);\n    }\n  }\n}"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Create a TCP server in Node.js that serves Flash cross-domain policy files to clients, handling connections, errors, and policy file generation dynamically.\n\nClass Description: The Server class implements a TCP server that listens for Flash policy file requests and responds with an appropriate cross-domain policy XML. It handles server lifecycle events, client connections, and dynamic policy configuration.\n\nAttributes:\n- origins: [Array] - List of allowed domains and ports in \"domain:port\" format\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [net.Server] - The TCP server instance\n- server: [Object] - Optional fallback HTTP server\n- buffer: [Buffer] - Compiled policy file in binary format\n\nMethods:\n- constructor(options, origins) -> [Server] - Initializes the server with configuration options and allowed origins\n- listen(port, server, cb) -> [Server] - Starts listening on specified port, with optional fallback server and callback\n- responder(socket) -> [void] - Responds to client connections with policy file\n- compile() -> [Server] - Generates the policy file XML and converts it to buffer\n- add() -> [Server] - Adds one or more allowed origins to the policy\n- remove(origin) -> [Server] - Removes a specific origin from the policy\n- close() -> [Server] - Closes the server and cleans up resources",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => {\n        this.responder.call(this, socket);\n      });\n      this.responder.call(this, socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges. ' +\n          (\n            this.server\n            ? 'The Flash Policy File requests will only be served inline over the supplied HTTP server. Inline serving is slower than a dedicated server instance.'\n            : 'No fallback server supplied, we will be unable to answer Flash Policy File requests.'\n          )\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n      if (this.server && this.server['@'] && this.server.online) {\n        this.server.removeListener('connection', this.server['@']);\n      }\n      delete this.server?.online;\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (\n            data &&\n            data[0] === 60 &&\n            data.toString() === '<policy-file-request/>\\0' &&\n            socket &&\n            (socket.readyState === 'open' || socket.readyState === 'writeOnly')\n          ) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    if (this.port >= 0) {\n      this.socket.listen(this.port, () => {\n        this.socket.online = true;\n        callback?.call(this);\n      });\n    }\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = Buffer.from(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "const net = require('net');\n\nclass Server {\n  constructor(options = {}, origins = []) {\n    this.origins = origins;\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = new net.Server();\n    this.server = options.server;\n    this.buffer = null;\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    if (typeof port === 'function') {\n      cb = port;\n      port = this.port;\n      server = this.server;\n    } else if (typeof server === 'function') {\n      cb = server;\n      server = this.server;\n    }\n    this.port = port || this.port;\n    this.server = server;\n\n    this.socket.on('connection', this.responder.bind(this));\n    this.socket.on('error', err => this.log(`TCP server error: ${err.message}`));\n    this.socket.on('close', () => this.log('TCP server closed'));\n\n    this.socket.listen(this.port, () => {\n      this.log(`TCP server listening on port ${this.port}`);\n      if (cb) cb();\n    });\n\n    return this;\n  }\n\n  responder(socket) {\n    const address = socket.remoteAddress + ':' + socket.remotePort;\n    this.log(`Client connected: ${address}`);\n\n    socket.on('data', data => {\n      if (data.toString().indexOf('<policy-file-request/>') !== -1) {\n        this.log(`Policy file requested by ${address}`);\n        socket.write(this.buffer);\n        socket.end();\n      }\n    });\n\n    socket.on('error', err => this.log(`Socket error with ${address}: ${err.message}`));\n    socket.on('end', () => this.log(`Client disconnected: ${address}`));\n  }\n\n  compile() {\n    let xml = '<?xml version=\"1.0\"?>\\n';\n    xml += '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">\\n';\n    xml += '<cross-domain-policy>\\n';\n\n    this.origins.forEach(origin => {\n      const [domain, port] = origin.split(':');\n      xml += `  <allow-access-from domain=\"${domain}\"${port ? ` to-ports=\"${port}\"` : ''} secure=\"false\"/>\\n`;\n    });\n\n    xml += '</cross-domain-policy>\\x00';\n    this.buffer = Buffer.from(xml, 'utf8');\n    return this;\n  }\n\n  add(...origins) {\n    origins.forEach(origin => {\n      if (!this.origins.includes(origin)) this.origins.push(origin);\n    });\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const index = this.origins.indexOf(origin);\n    if (index !== -1) {\n      this.origins.splice(index, 1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.close(() => {\n      this.log('Server closed');\n    });\n    return this;\n  }\n}\n\nmodule.exports = Server;"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    if (unsplashClientId) {\n      try {\n        const response = await fetch('https://api.unsplash.com/photos/random?query=wallpaper', {\n          headers: {\n            Authorization: `Client-ID ${unsplashClientId}`\n          }\n        });\n        if (response.ok) {\n          const data = await response.json();\n          return { type: 'unsplash', data };\n        }\n      } catch (error) {\n        console.error('Unsplash API error:', error);\n      }\n    }\n\n    try {\n      const response = await fetch('https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1');\n      if (response.ok) {\n        const bingData = await response.json();\n        const imageUrl = `https://www.bing.com${bingData.images[0].url}`;\n        return {\n          type: 'bing',\n          data: {\n            images: [{ url: imageUrl }],\n            copyright: bingData.images[0].copyright || 'Bing Wallpaper'\n          }\n        };\n      }\n    } catch (error) {\n      console.error('Bing API error:', error);\n    }\n\n    return {\n      type: 'bing',\n      data: {\n        images: [{ url: 'https://example.com/default-wallpaper.jpg' }],\n        copyright: 'Default Wallpaper'\n      }\n    };\n  }\n}"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Create a TCP server implementation for handling IMAP (Internet Message Access Protocol) connections with optional TLS/SSL security support.\n\nClass Description: IMAPServer is a class that implements a TCP server for IMAP protocol connections. It supports both plain and TLS/SSL encrypted connections, handles client connections, and manages server lifecycle events.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- server: [net.Server] - The underlying TCP server instance\n- connections: [Set] - Active client connections\n- _closeTimeout: [Timeout] - Timer for server shutdown operations\n\nMethods:\n- constructor(options) -> [IMAPServer] - Initializes the server with configuration options and sets up event listeners\n- connect(socket, socketOptions) -> [void] - Creates a new IMAPConnection for a client socket\n- listen(...args) -> [void] - Starts the server listening on specified port/address\n- close(callback) -> [void] - Gracefully shuts down the server\n- _setListeners() -> [void] - Sets up server event listeners\n- _onListening() -> [void] - Handles server 'listening' event\n- _onClose() -> [void] - Handles server 'close' event\n- _onError(err) -> [void] - Handles server 'error' event\n- _handleProxy(socket, callback) -> [void] - Handles proxy protocol if needed\n- _upgrade(socket, callback) -> [void] - Upgrades a connection to TLS/SSL",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass IMAPServer {\n    constructor(options) {\n        this.options = options || {};\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                socket.setKeepAlive(true, 5 * 1000);\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket =>\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    socket.setKeepAlive(true, 5 * 1000);\n                    this.connect(socket, socketOptions);\n                })\n            );\n        }\n\n        this._setListeners();\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new IMAPConnection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.on('error', this._onError.bind(this));\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            clearTimeout(this._closeTimeout);\n            callback();\n        });\n    }\n\n    _setListeners() {\n        this.server.on('listening', this._onListening.bind(this));\n        this.server.on('close', this._onClose.bind(this));\n        this.server.on('error', this._onError.bind(this));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    _handleProxy(socket, callback) {\n        let socketOptions = {\n            id: base32.encode(crypto.randomBytes(10)).toLowerCase()\n        };\n        return setImmediate(() => callback(null, socketOptions));\n    }\n\n    _upgrade(socket, callback) {\n        let socketOptions = {\n            secureContext: this.secureContext.get('*'),\n            isServer: true,\n            server: this.server\n        };\n\n        let tlsSocket = new tls.TLSSocket(socket, socketOptions);\n        tlsSocket.on('secure', () => {\n            return callback(null, tlsSocket);\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "var net = require('net');\nvar tls = require('tls');\nvar EventEmitter = require('events').EventEmitter;\n\nfunction IMAPServer(options) {\n    var self = this;\n    this.options = options || {};\n    this.server = net.createServer();\n    this.connections = new Set();\n    this._closeTimeout = null;\n\n    this._setListeners();\n}\n\nIMAPServer.prototype.connect = function(socket, socketOptions) {\n    var connection = new IMAPConnection(socket, socketOptions);\n    this.connections.add(connection);\n\n    var self = this;\n    connection.on('close', function() {\n        self.connections.delete(connection);\n    });\n};\n\nIMAPServer.prototype.listen = function() {\n    this.server.listen.apply(this.server, arguments);\n};\n\nIMAPServer.prototype.close = function(callback) {\n    var self = this;\n\n    if (this._closeTimeout) {\n        clearTimeout(this._closeTimeout);\n    }\n\n    this._closeTimeout = setTimeout(function() {\n        self.server.close();\n        callback();\n    }, 5000);\n\n    if (this.connections.size === 0) {\n        this.server.close();\n        callback();\n    } else {\n        this.server.once('close', callback);\n    }\n};\n\nIMAPServer.prototype._setListeners = function() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n    this.server.on('connection', this._handleProxy.bind(this));\n};\n\nIMAPServer.prototype._onListening = function() {\n    // Handle server start listening\n};\n\nIMAPServer.prototype._onClose = function() {\n    // Handle server close event\n};\n\nIMAPServer.prototype._onError = function(err) {\n    this.emit('error', err);\n};\n\nIMAPServer.prototype._handleProxy = function(socket, callback) {\n    var self = this;\n    if (this.options.proxy === 'required') {\n        // Handle proxy protocol logic here\n        callback(socket);\n    } else {\n        if (this.options.secure) {\n            this._upgrade(socket, function(err, secureSocket) {\n                if (err) return self._onError(err);\n                self.connect(secureSocket, { secure: true });\n            });\n        } else {\n            this.connect(socket, { secure: false });\n        }\n    }\n};\n\nIMAPServer.prototype._upgrade = function(socket, callback) {\n    var secureSocket = new tls.TLSSocket(socket, {\n        secureContext: tls.createSecureContext(this.options.tls),\n        isServer: true\n    });\n\n    secureSocket.on('secure', function() {\n        callback(null, secureSocket);\n    });\n\n    secureSocket.on('error', function(err) {\n        callback(err);\n    });\n};\n\nIMAPServer.prototype.__proto__ = EventEmitter.prototype;"
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Implement a UDP-based server discovery system that allows servers to broadcast their presence and receive information about other nearby servers on the network.\n\nClass Description: The class provides functionality for UDP-based server discovery, including broadcasting server presence (heartbeats) and listening for broadcasts from other servers. It maintains a list of discovered servers and handles network communication errors.\n\nAttributes:\n- nearbyServers: [Object] - A dictionary storing information about discovered nearby servers, keyed by hostname.\n- lastDiscoveryBroadcast: [Number] - Timestamp of the last broadcast sent by this server.\n- broadcastIP: [String] - The broadcast IP address used for sending discovery messages.\n- discoveryListener: [Object] - The UDP socket instance used for listening to discovery messages.\n\nMethods:\n- setupDiscovery([callback: Function]) -> [void] - Initializes the UDP listener socket and binds it to the configured port. The optional callback is executed when binding is complete.\n- discoveryBroadcast([type: String, message: Object, callback: Function]) -> [void] - Creates a UDP client to broadcast a message of the specified type. The message should be an object that will be stringified to JSON. The optional callback is executed after the message is sent.\n- discoveryReceive([msg: Buffer, rinfo: Object]) -> [void] - Handles incoming UDP messages, parsing them as JSON and processing different message types (currently only 'heartbeat' is implemented). Updates the nearbyServers list when valid messages are received.\n- shutdownDiscovery() -> [void] - Closes the UDP listener socket if it exists, cleaning up network resources.\n- calcBroadcastIP() -> [String] - (Implied but not shown) Calculates the broadcast IP address based on network interfaces.",
    "Canonical_solution": "var dgram = require(\"dgram\");\nvar os = require('os');\nvar Netmask = require('netmask').Netmask;\n\nvar Class = require(\"pixl-class\");\nvar Tools = require(\"pixl-tools\");\n\nmodule.exports = Class.create({\n\t\n\tnearbyServers: null,\n\tlastDiscoveryBroadcast: 0,\n\t\n\tsetupDiscovery: function(callback) {\n\t\tvar self = this;\n\t\t\n\t\tthis.nearbyServers = {};\n\t\tthis.lastDiscoveryBroadcast = 0;\n\t\t\n\t\tif (!this.server.config.get('udp_broadcast_port')) {\n\t\t\tif (callback) callback();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.broadcastIP = this.server.config.get('broadcast_ip') || this.calcBroadcastIP();\n\t\t\n\t\tvar listener = this.discoveryListener = dgram.createSocket(\"udp4\");\n\t\t\n\t\tlistener.on(\"message\", function (msg, rinfo) {\n\t\t\tself.discoveryReceive( msg, rinfo );\n\t\t} );\n\t\t\n\t\tlistener.on(\"error\", function (err) {\n\t\t\tself.logError('udp', \"UDP socket listener error: \" + err);\n\t\t\tself.discoveryListener = null;\n\t\t} );\n\t\t\n\t\tlistener.bind( this.server.config.get('udp_broadcast_port'), function() {\n\t\t\tif (callback) callback();\n\t\t} );\n\t},\n\t\n\tdiscoveryBroadcast: function(type, message, callback) {\n\t\tvar self = this;\n\t\t\n\t\tmessage.action = type;\n\t\t\n\t\tvar client = dgram.createSocket('udp4');\n\t\tvar message = Buffer.from( JSON.stringify(message) + \"\\n\" );\n\t\tclient.bind( 0, function() {\n\t\t\tclient.setBroadcast( true );\t\t\t\n\t\t\tclient.send(message, 0, message.length, self.server.config.get('udp_broadcast_port'), self.broadcastIP, function(err) {\n\t\t\t\tif (err) self.logDebug(9, \"UDP broadcast failed: \" + err);\n\t\t\t\tclient.close();\n\t\t\t\tif (callback) callback();\n\t\t\t} );\n\t\t} );\n\t},\n\t\n\tdiscoveryReceive: function(msg, rinfo) {\n\t\tvar text = msg.toString();\n\t\tif (text.match(/^\\{/)) {\n\t\t\tvar json = null;\n\t\t\ttry { json = JSON.parse(text); }\n\t\t\tcatch (e) {\n\t\t\t\tthis.logError(9, \"Failed to parse UDP JSON message: \" + e);\n\t\t\t}\n\t\t\tif (json && json.action) {\n\t\t\t\tswitch (json.action) {\n\t\t\t\t\tcase 'heartbeat':\n\t\t\t\t\t\tif (json.hostname && (json.hostname != this.server.hostname)) {\n\t\t\t\t\t\t\tjson.now = Tools.timeNow();\n\t\t\t\t\t\t\tdelete json.action;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!this.nearbyServers[ json.hostname ]) {\n\t\t\t\t\t\t\t\tthis.nearbyServers[ json.hostname ] = json;\n\t\t\t\t\t\t\t\tif (this.multi.master) {\n\t\t\t\t\t\t\t\t\tthis.logDebug(6, \"Discovered nearby server: \" + json.hostname, json);\n\t\t\t\t\t\t\t\t\tthis.authSocketEmit( 'update', { nearby: this.nearbyServers } );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.nearbyServers[ json.hostname ] = json;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\tshutdownDiscovery: function() {\n\t\tif (this.discoveryListener) {\n\t\t\tthis.discoveryListener.close();\n\t\t}\n\t}\n});",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "const dgram = require('dgram');\nconst os = require('os');\n\nclass ServerDiscovery {\n  constructor(port = 40000, broadcastPort = 40001, heartbeatInterval = 5000) {\n    this.port = port;\n    this.broadcastPort = broadcastPort;\n    this.heartbeatInterval = heartbeatInterval;\n    this.nearbyServers = {};\n    this.lastDiscoveryBroadcast = 0;\n    this.broadcastIP = this.calcBroadcastIP();\n    this.discoveryListener = dgram.createSocket({ type: 'udp4', reuseAddr: true });\n  }\n\n  setupDiscovery(callback) {\n    this.discoveryListener.on('listening', () => {\n      const address = this.discoveryListener.address();\n      console.log(`Discovery listener bound to ${address.address}:${address.port}`);\n      if (callback) callback();\n    });\n\n    this.discoveryListener.on('message', (msg, rinfo) => {\n      this.discoveryReceive(msg, rinfo);\n    });\n\n    this.discoveryListener.bind(this.port, () => {\n      this.discoveryListener.setBroadcast(true);\n      this.discoveryListener.setMulticastTtl(128);\n    });\n  }\n\n  discoveryBroadcast(type = 'heartbeat', message = {}, callback) {\n    const client = dgram.createSocket('udp4');\n    const payload = Buffer.from(JSON.stringify({\n      type,\n      timestamp: Date.now(),\n      ...message\n    }));\n\n    client.send(payload, 0, payload.length, this.broadcastPort, this.broadcastIP, (err) => {\n      if (err) {\n        console.error('Discovery broadcast error:', err);\n      }\n      client.close();\n      if (callback) callback();\n    });\n  }\n\n  discoveryReceive(msg, rinfo) {\n    try {\n      const data = JSON.parse(msg.toString());\n      \n      if (data.type === 'heartbeat') {\n        const serverKey = rinfo.address;\n        this.nearbyServers[serverKey] = {\n          ...data,\n          lastSeen: Date.now(),\n          address: rinfo.address,\n          port: rinfo.port\n        };\n      }\n    } catch (error) {\n      console.error('Error processing discovery message:', error);\n    }\n  }\n\n  shutdownDiscovery() {\n    if (this.discoveryListener) {\n      this.discoveryListener.close();\n      this.discoveryListener = null;\n    }\n  }\n\n  calcBroadcastIP() {\n    const interfaces = os.networkInterfaces();\n    \n    for (const devName in interfaces) {\n      const iface = interfaces[devName].find(\n        (details) => details.family === 'IPv4' && !details.internal\n      );\n      \n      if (iface) {\n        const parts = iface.address.split('.');\n        return parts.slice(0, 3).join('.') + '.255';\n      }\n    }\n    \n    return '255.255.255.255';\n  }\n\n  startHeartbeat() {\n    this.heartbeatTimer = setInterval(() => {\n      this.discoveryBroadcast('heartbeat', {\n        name: os.hostname(),\n        ip: this.getPrimaryIP()\n      });\n      this.lastDiscoveryBroadcast = Date.now();\n    }, this.heartbeatInterval);\n  }\n\n  stopHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n  }\n\n  getPrimaryIP() {\n    const interfaces = os.networkInterfaces();\n    \n    for (const devName in interfaces) {\n      const iface = interfaces[devName].find(\n        (details) => details.family === 'IPv4' && !details.internal\n      );\n      \n      if (iface) {\n        return iface.address;\n      }\n    }\n    \n    return '0.0.0.0';\n  }\n\n  cleanupStaleServers(ttl = 10000) {\n    const now = Date.now();\n    Object.keys(this.nearbyServers).forEach(key => {\n      if (now - this.nearbyServers[key].lastSeen > ttl) {\n        delete this.nearbyServers[key];\n      }\n    });\n  }\n}"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a class that implements inter-process communication (IPC) using UDP sockets in Node.js, allowing communication between a master process and worker processes.\n\nClass Description: The MasterIPC class facilitates communication between a master process and worker processes using UDP sockets. It handles socket creation, message parsing, method invocation, and event emission for worker connections and restarts.\n\nAttributes:\n- options: [Object] - Configuration options including socket port and address.\n- _sock: [dgram.Socket] - The UDP socket instance for communication.\n- children: [Array] - List of connected worker processes.\n- sock: [dgram.Socket] - Alternative socket reference used for sending messages.\n\nMethods:\n- IPCSocket() -> [dgram.Socket] - Creates and configures a UDP socket if not already created, setting up message event handling.\n- setupIPC() -> [void] - Binds the socket to the specified port and address, emits 'start' event when listening.\n- call(id, method, ...args) -> [void] - Sends a message to a worker process with the specified ID, method, and arguments.\n- invoke(method, args, worker) -> [void] - Invokes the specified method with given arguments and worker context if the method exists.\n- connect(worker) -> [void] - Emits a 'worker connected' event for the specified worker.\n- connectMaster(sig) -> [void] - Kills the parent process with the specified signal, either immediately or after the socket is listening.\n- masterKilled(data) -> [void] - Emits a 'restart' event with the provided data.",
    "Canonical_solution": "var dgram = require('dgram');\nvar net = require('net');\nvar utils = require('./utils');\n\nclass MasterIPC {\n  constructor(options) {\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n  }\n\n  IPCSocket() {\n    var self = this;\n    if (this._sock) return this._sock;\n    \n    this._sock = dgram.createSocket('udp4');\n    this._sock.on('message', function(msg, info) {\n      try {\n        msg = JSON.parse(msg.toString('ascii'));\n        self.invoke(msg.method, msg.args, self.children[msg.id]);\n      } catch (err) {\n        console.error(err.stack || String(err));\n      }\n    });\n    return this._sock;\n  }\n\n  setupIPC() {\n    var self = this;\n    this.IPCSocket().on('listening', function() {\n      process.nextTick(function() {\n        self.emit('start');\n      });\n    });\n    this.IPCSocket().bind(\n      this.options['socket port'],\n      this.options['socket addr']\n    );\n  }\n\n  call(id, method) {\n    this.sock = this.sock || dgram.createSocket('udp4');\n    var msg = new Buffer(utils.frame({\n      args: utils.toArray(arguments, 2),\n      method: method,\n      id: id\n    }));\n    this.sock.send(\n      msg,\n      0,\n      msg.length,\n      this.options['socket port'],\n      this.options['socket addr']\n    );\n  }\n\n  invoke(method, args, worker) {\n    if (this[method]) {\n      this[method].apply(this, args.concat(worker));\n    }\n  }\n\n  connect(worker) {\n    this.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    var self = this;\n    function kill() {\n      process.kill(self.ppid, sig);\n    }\n    if (this.listening) return kill();\n    this.on('listening', kill);\n  }\n\n  masterKilled(data) {\n    this.emit('restart', data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "const dgram = require('dgram');\nconst EventEmitter = require('events');\n\nclass MasterIPC extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    this._sock = null;\n    this.children = [];\n    this.sock = null;\n  }\n\n  IPCSocket() {\n    if (this._sock) return this._sock;\n    this._sock = dgram.createSocket({ type: 'udp4', reuseAddr: true });\n    this.sock = this._sock;\n    this._sock.on('message', (msg, rinfo) => {\n      let data;\n      try {\n        data = JSON.parse(msg);\n      } catch (e) {\n        return;\n      }\n      const worker = this.children.find(child => child.id === data.id);\n      if (!worker && data.event === 'connect') {\n        worker = { id: data.id, address: rinfo.address, port: rinfo.port };\n        this.children.push(worker);\n        this.connect(worker);\n      }\n      if (worker) {\n        this.invoke(data.method, data.args, worker);\n      }\n    });\n    return this._sock;\n  }\n\n  setupIPC() {\n    const socket = this.IPCSocket();\n    socket.bind(this.options.port || 0, this.options.address || '127.0.0.1', () => {\n      this.emit('start');\n    });\n  }\n\n  call(id, method, ...args) {\n    const worker = this.children.find(child => child.id === id);\n    if (!worker) return;\n    const msg = JSON.stringify({ id, method, args });\n    this.sock.send(msg, 0, msg.length, worker.port, worker.address);\n  }\n\n  invoke(method, args, worker) {\n    if (typeof this[method] === 'function') {\n      this[method].apply(this, [...args, worker]);\n    }\n  }\n\n  connect(worker) {\n    this.emit('worker connected', worker);\n  }\n\n  connectMaster(sig) {\n    const kill = () => process.kill(process.ppid, sig);\n    if (!this.sock || !this.sock.listening) {\n      this.once('start', kill);\n    } else {\n      kill();\n    }\n  }\n\n  masterKilled(data) {\n    this.emit('restart', data);\n  }\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Create a reusable HTTP client class that simplifies making HTTP requests using Axios, with support for common methods like GET and POST, while handling errors consistently.\n\nClass Description: The HTTPClient class encapsulates Axios functionality to provide a clean interface for making HTTP requests. It maintains headers across requests and provides methods for GET and POST operations with error handling.\n\nAttributes:\n- headers: Object - Contains HTTP headers to be sent with every request\n\nMethods:\n- constructor(headers: Object) -> void - Initializes the HTTP client with default headers\n- get(url: String, params: Object = {}) -> Promise<Object> - Sends a GET request to the specified URL with optional query parameters, returns response data or throws error\n- post(url: String, data: Object = {}, params: Object = {}) -> Promise<Object> - Sends a POST request to the specified URL with optional request body and query parameters, returns response data or throws error",
    "Canonical_solution": "const axios = require('axios');\n\nclass HTTPClient {\n    constructor(headers) {\n        this.headers = headers;\n    }\n\n    async get(url, params = {}) {\n        try {\n            const response = await axios({\n                method: 'get',\n                url: url,\n                headers: this.headers,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('GET request failed:', error);\n            throw error;\n        }\n    }\n\n    async post(url, data = {}, params = {}) {\n        try {\n            const response = await axios({\n                method: 'post',\n                url: url,\n                headers: this.headers,\n                data: data,\n                params: params\n            });\n            return response.data;\n        } catch (error) {\n            console.error('POST request failed:', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\n\nclass HTTPClient {\n  constructor(headers = {}) {\n    this.headers = headers;\n  }\n\n  async get(url, params = {}) {\n    try {\n      const response = await axios.get(url, {\n        params,\n        headers: this.headers,\n      });\n      return response.data;\n    } catch (error) {\n      throw this.handleError(error);\n    }\n  }\n\n  async post(url, data = {}, params = {}) {\n    try {\n      const response = await axios.post(url, data, {\n        params,\n        headers: this.headers,\n      });\n      return response.data;\n    } catch (error) {\n      throw this.handleError(error);\n    }\n  }\n\n  handleError(error) {\n    if (error.response) {\n      // Server responded with a status other than 2xx\n      return new Error(`HTTP error! Status: ${error.response.status}, Message: ${JSON.stringify(error.response.data)}`);\n    } else if (error.request) {\n      // No response received\n      return new Error('No response received from server.');\n    } else {\n      // Other errors\n      return new Error(`Request failed: ${error.message}`);\n    }\n  }\n}"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "import { EventEmitter } from 'events';\nimport WebSocket from 'ws';\nimport fetch from 'node-fetch';\n\nconst STATES = {\n  UNINITIALIZED: 'uninitialized',\n  CONNECTING: 'connecting',\n  SYNCING: 'syncing',\n  READY: 'ready',\n  FAILED: 'failed',\n  CLOSED: 'closed'\n};\n\nclass OrderBook extends EventEmitter {\n  constructor(productID, websocketURI, restURI, timeProvider) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.timeProvider = timeProvider || Date;\n    this.state = STATES.UNINITIALIZED;\n    this.fail_count = 0;\n    this.socket = null;\n    this.queue = [];\n    this.book = {\n      sequence: 0,\n      bids: {}, // price -> { price: String, size: String }\n      asks: {}  // price -> { price: String, size: String }\n    };\n    this.changeState(STATES.CONNECTING);\n    this.connect();\n  }\n\n  clear_book() {\n    this.book = {\n      sequence: 0,\n      bids: {},\n      asks: {}\n    };\n    this.queue = [];\n  }\n\n  connect() {\n    if (this.socket) {\n      this.socket.removeAllListeners();\n      this.socket.close();\n    }\n\n    this.changeState(STATES.CONNECTING);\n    this.socket = new WebSocket(this.websocketURI);\n\n    this.socket.on('open', () => this.onOpen());\n    this.socket.on('close', () => this.onClose());\n    this.socket.on('message', data => this.onMessage(data.toString()));\n    this.socket.on('error', err => {\n      console.error(`WebSocket error: ${err.message}`);\n      this.disconnect();\n    });\n  }\n\n  disconnect() {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.close();\n    }\n    this.changeState(STATES.CLOSED);\n  }\n\n  changeState(stateName) {\n    const prevState = this.state;\n    this.state = stateName;\n\n    if (stateName === STATES.FAILED) {\n      this.fail_count++;\n    } else if (stateName === STATES.CONNECTING) {\n      this.fail_count = 0;\n    }\n\n    this.emit('statechange', {\n      previous: prevState,\n      current: stateName,\n      timestamp: this.timeProvider.now ? this.timeProvider.now() : new Date()\n    });\n  }\n\n  onOpen() {\n    this.emit('connect');\n    this.changeState(STATES.SYNCING);\n    this.sync();\n  }\n\n  onClose() {\n    this.emit('disconnect');\n    this.changeState(STATES.CLOSED);\n  }\n\n  async onMessage(datastr) {\n    let message;\n    try {\n      message = JSON.parse(datastr);\n    } catch (e) {\n      console.error('Failed to parse message:', e);\n      return;\n    }\n\n    const t = this.timeProvider.now ? this.timeProvider.now() : new Date();\n\n    if (this.state === STATES.SYNCING) {\n      this.queue.push({ message, t });\n    } else {\n      await this.processMessage(message, t);\n    }\n  }\n\n  async sync() {\n    const subscribeMsg = {\n      type: 'subscribe',\n      product_ids: [this.productID],\n      channels: ['level2']\n    };\n\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(subscribeMsg));\n    } else {\n      console.error('Cannot send subscribe message - socket not open');\n      this.disconnect();\n      return;\n    }\n\n    try {\n      const snapshotResponse = await fetch(`${this.restURI}/products/${this.productID}/book?level=2`);\n      const snapshot = await snapshotResponse.json();\n\n      this.clear_book();\n      this.book.sequence = parseInt(snapshot.sequence, 10);\n\n      // Clear and initialize bids\n      for (const [price, size] of snapshot.bids) {\n        if (parseFloat(size) > 0) {\n          this.book.bids[price] = { price, size };\n        }\n      }\n\n      // Clear and initialize asks\n      for (const [price, size] of snapshot.asks) {\n        if (parseFloat(size) > 0) {\n          this.book.asks[price] = { price, size };\n        }\n      }\n\n      this.changeState(STATES.READY);\n      this.emit('snapshot', {\n        book: this.getSnapshot(),\n        timestamp: this.timeProvider.now ? this.timeProvider.now() : new Date()\n      });\n\n      // Process queued messages\n      for (const { message, t } of this.queue) {\n        await this.processMessage(message, t);\n      }\n      this.queue = [];\n    } catch (error) {\n      console.error(`Failed to fetch order book snapshot: ${error.message}`);\n      this.changeState(STATES.FAILED);\n      this.disconnect();\n    }\n  }\n\n  async processMessage(message, t) {\n    if (!message || !message.type || message.type !== 'l2update') {\n      return;\n    }\n\n    if (parseInt(message.sequence, 10) <= this.book.sequence) {\n      return; // stale message\n    }\n\n    if (this.book.sequence && parseInt(message.sequence, 10) !== this.book.sequence + 1) {\n      // gap detected\n      this.changeState(STATES.FAILED);\n      this.disconnect();\n      return;\n    }\n\n    this.book.sequence = parseInt(message.sequence, 10);\n\n    for (const changes of message.changes) {\n      const [side, price, size] = changes;\n      const priceLevel = parseFloat(price);\n      const sizeAmount = parseFloat(size);\n\n      if (sizeAmount === 0) {\n        // Remove price level\n        if (side === 'buy') {\n          delete this.book.bids[price];\n        } else {\n          delete this.book.asks[price];\n        }\n      } else {\n        // Update or add price level\n        const priceObj = { price, size };\n        if (side === 'buy') {\n          this.book.bids[price] = priceObj;\n        } else {\n          this.book.asks[price] = priceObj;\n        }\n      }\n    }\n\n    this.emit('update', {\n      book: this.getSnapshot(),\n      update: message,\n      timestamp: t\n    });\n\n    this.emit(`update:${message.product_id}`, {\n      book: this.getSnapshot(),\n      update: message,\n      timestamp: t\n    });\n  }\n\n  getSnapshot() {\n    return {\n      sequence: this.book.sequence,\n      bids: Object.values(this.book.bids).sort((a, b) => parseFloat(b.price) - parseFloat(a.price)),\n      asks: Object.values(this.book.asks).sort((a, b) => parseFloat(a.price) - parseFloat(b.price))\n    };\n  }\n}"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Channel {\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = (event) => this._messageReceived(event.data);\n    this._ws.addEventListener('message', this._messageListener);\n  }\n\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeEventListener('message', this._messageListener);\n    this._messageListener = null;\n    this._handler = null;\n  }\n\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise((resolve) => {\n      this._disconnectResolver = resolve;\n    });\n    this._connected = new Set();\n    this._frontend = frontend;\n    this._pipe = '/tmp/ndd_ipc_pipe';\n    this._setupIpcServer();\n  }\n\n  async _startSession(info, frontend) {\n    const sessionCleanup = async () => {\n      this._connected.delete(info.id);\n      if (this._frontend && typeof this._frontend.sessionClosed === 'function') {\n        await this._frontend.sessionClosed(info.id);\n      }\n    };\n\n    if (!this._connected.has(info.id)) {\n      this._connected.add(info.id);\n      \n      if (this._frontend && typeof this._frontend.sessionCreated === 'function') {\n        await this._frontend.sessionCreated(info);\n      }\n    }\n\n    return sessionCleanup;\n  }\n\n  _setupIpcServer() {\n    const net = require('net');\n    const server = net.createServer(async (socket) => {\n      try {\n        const inspectorUrl = socket.remoteAddress + ':' + socket.remotePort;\n        const sessionId = `session_${Date.now()}`;\n        \n        const info = {\n          id: sessionId,\n          inspectorUrl: inspectorUrl,\n          socket: socket\n        };\n        \n        const cleanup = await this._startSession(info, this._frontend);\n        \n        socket.on('close', async () => {\n          await cleanup();\n        });\n        \n      } catch (error) {\n        console.error('Error handling IPC connection:', error);\n      }\n    });\n\n    server.on('error', (err) => {\n      console.error('IPC server error:', err);\n    });\n\n    try {\n      server.listen(this._pipe, () => {\n        console.log(`IPC server listening on ${this._pipe}`);\n      });\n    } catch (e) {\n      console.error('Failed to start IPC server:', e);\n    }\n  }\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "function testWebSocketConnection(wssUrl) {\n    const ws = new WebSocket(`wss://${wssUrl}`);\n\n    ws.onopen = () => {\n        console.log('WebSocket connection opened');\n        const initialMessage = {\n            type: 'connection_init',\n            payload: {\n                timestamp: Date.now()\n            }\n        };\n        ws.send(JSON.stringify(initialMessage));\n    };\n\n    ws.onmessage = (event) => {\n        try {\n            const message = JSON.parse(event.data);\n            console.log('Received message:', message);\n            \n            if (message.type === 'ack') {\n                console.log('Server acknowledged connection');\n            } else if (message.type === 'ping') {\n                const pongResponse = {\n                    type: 'pong',\n                    payload: {\n                        timestamp: Date.now(),\n                        original: message.payload\n                    }\n                };\n                ws.send(JSON.stringify(pongResponse));\n            }\n        } catch (error) {\n            console.error('Error parsing message:', error);\n        }\n    };\n\n    ws.onclose = (event) => {\n        console.log(`WebSocket connection closed: ${event.reason} (Code: ${event.code})`);\n    };\n\n    ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        ws.close();\n    };\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using HTTP POST request with error handling.\n\nFunction Description: The function `sendWebhook` is an asynchronous function that takes data as input and sends it to a predefined webhook URL using an HTTP POST request. It handles potential errors during the request and logs them to the console.\n\nInput: \n- `data` [Object] - The payload/data to be sent to the webhook URL.\n\nOutput: \n- None (The function does not return any value, but it may log errors to the console if the request fails).",
    "Canonical_solution": "const axios = require('axios');\n\nconst sendWebhook = async (data) => {\n    try {\n        await axios.post(process.env.UPDATE_WEBHOOK, data);\n    } catch (err) {\n        console.log(err);\n    }\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function sendWebhook(data) {\n    const webhookUrl = 'https://example.com/webhook'; // Replace with actual webhook URL\n\n    try {\n        const response = await fetch(webhookUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n\n        if (!response.ok) {\n            throw new Error(`Webhook request failed with status ${response.status}`);\n        }\n    } catch (error) {\n        console.error('Error sending webhook:', error.message);\n    }\n}"
  },
  {
    "Task_id": 211,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with support for reconnection, message handling, and connection lifecycle events.\n\nClass Description: The `N` class represents a WebSocket client that connects to a specified URL, handles incoming messages, manages connection state, and provides automatic reconnection capabilities. It supports event callbacks for connection establishment and completion, and can pipe received data to a destination.\n\nAttributes:\n- url: [String] - The WebSocket server URL to connect to\n- options: [Object] - Configuration options including protocols, reconnect interval, and callbacks\n- socket: [WebSocket|null] - The active WebSocket connection instance\n- streaming: [Boolean] - Flag indicating if the connection is active\n- callbacks: [Object] - Collection of event callback arrays (connect, data)\n- destination: [Object|null] - Target to pipe received data to\n- reconnectInterval: [Number] - Time in seconds between reconnection attempts\n- shouldAttemptReconnect: [Boolean] - Flag controlling reconnection behavior\n- completed: [Boolean] - Connection completion state\n- established: [Boolean] - Connection establishment state\n- progress: [Number] - Connection progress indicator\n- reconnectTimeoutId: [Number] - Timer ID for reconnection attempts\n- onEstablishedCallback: [Function|null] - Called when connection is established\n- onCompletedCallback: [Function|null] - Called when connection completes\n- hookOnEstablished: [Function|null] - Optional hook for connection establishment\n\nMethods:\n- constructor(url, options) -> [N] - Initializes the WebSocket client with URL and options\n- connect(destination) -> [void] - Sets the destination for received data\n- destroy() -> [void] - Cleans up resources and closes the connection\n- start() -> [void] - Initiates the WebSocket connection with optional protocols\n- resume() -> [void] - Placeholder for resuming functionality (currently empty)\n- onOpen() -> [void] - Handles WebSocket open event, updates progress\n- onClose() -> [void] - Handles WebSocket close/error events, manages reconnection\n- onMessage(message) -> [void] - Handles incoming messages, triggers establishment callbacks",
    "Canonical_solution": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = true;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== options.reconnectInterval ? options.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = options.onSourceEstablished;\n    this.onCompletedCallback = options.onSourceCompleted;\n    options.hookOnEstablished && (this.hookOnEstablished = options.hookOnEstablished);\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = false;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = false;\n    this.options.protocols\n      ? this.socket = new WebSocket(this.url, this.options.protocols)\n      : this.socket = new WebSocket(this.url);\n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    const reconnect = () => {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, 1000 * this.reconnectInterval);\n    };\n    this.shouldAttemptReconnect && reconnect();\n  }\n\n  onMessage(message) {\n    const wasEstablished = this.established;\n    this.established = true;\n    wasEstablished || this.hookOnEstablished?.();\n    wasEstablished || this.onEstablishedCallback?.(this);\n    this.destination?.write(message.data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class N {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.shouldAttemptReconnect = false;\n    this.streaming = false;\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = 0;\n    }\n  }\n\n  start() {\n    try {\n      const protocols = this.options.protocols || [];\n      this.socket = new WebSocket(this.url, protocols);\n      this.socket.binaryType = 'arraybuffer';\n      this.socket.addEventListener('open', () => this.onOpen());\n      this.socket.addEventListener('close', () => this.onClose());\n      this.socket.addEventListener('error', () => this.onClose());\n      this.socket.addEventListener('message', (event) => this.onMessage(event));\n    } catch (e) {\n      this.onClose();\n    }\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.streaming = true;\n    this.established = false;\n    this.completed = false;\n  }\n\n  onClose() {\n    this.streaming = false;\n    this.socket = null;\n    if (this.shouldAttemptReconnect && !this.completed) {\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, this.reconnectInterval * 1000);\n    }\n  }\n\n  onMessage(message) {\n    if (!this.established) {\n      this.established = true;\n      if (this.hookOnEstablished) {\n        this.hookOnEstablished();\n      }\n      if (this.onEstablishedCallback) {\n        this.onEstablishedCallback();\n      }\n    }\n\n    if (this.destination && typeof this.destination.write === 'function') {\n      this.destination.write(message.data);\n    }\n\n    if (this.callbacks.data.length > 0) {\n      this.callbacks.data.forEach((cb) => cb(message.data));\n    }\n\n    if (this.completed) {\n      this.destroy();\n    }\n  }\n}"
  },
  {
    "Task_id": 213,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that connects to a server for real-time speech-to-text (STT) transcription, handles incoming messages, and updates the UI accordingly.\n\nFunction Description: The function `connectToDataSocket` establishes a WebSocket connection to a specified URL, sets up event handlers for connection status, incoming messages, errors, and connection closure. It processes real-time transcription data and full sentence updates, displaying them in designated HTML elements while handling errors gracefully.\n\nInput: None (The function uses the global variable `dataURL` for WebSocket endpoint and assumes predefined HTML elements: `statusDiv`, `transcriptionDiv`, `fullTextDiv`, `transcriptionContainer`, `fullTextContainer`)\n\nOutput: None (The function's effects are side-effects: updates UI elements and logs to console)",
    "Canonical_solution": "function connectToDataSocket() {\n    dataSocket = new WebSocket(dataURL);\n\n    dataSocket.onopen = () => {\n        statusDiv.textContent = \"Connected to STT server.\";\n        console.log(\"Connected to data WebSocket.\");\n    };\n\n    dataSocket.onmessage = (event) => {\n        try {\n            const message = JSON.parse(event.data);\n\n            if (message.type === \"realtime\") {\n                let words = message.text.split(\" \");\n                let lastWord = words.pop();\n                transcriptionDiv.innerHTML = `${words.join(\" \")} <span class=\"last-word\">${lastWord}</span>`;\n\n                const transcriptionContainer = document.getElementById(\"transcriptionContainer\");\n                transcriptionContainer.scrollTop = transcriptionContainer.scrollHeight;\n            } else if (message.type === \"fullSentence\") {\n                fullTextDiv.innerHTML += message.text + \" \";\n                transcriptionDiv.innerHTML = message.text;\n\n                const fullTextContainer = document.getElementById(\"fullTextContainer\");\n                fullTextContainer.scrollTop = fullTextContainer.scrollHeight;\n            }\n        } catch (e) {\n            console.error(\"Error parsing message:\", e);\n        }\n    };\n\n    dataSocket.onclose = () => {\n        statusDiv.textContent = \"Disconnected from STT server.\";\n    };\n\n    dataSocket.onerror = (error) => {\n        console.error(\"WebSocket error:\", error);\n        statusDiv.textContent = \"Error connecting to the STT server.\";\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function connectToDataSocket() {\n    const socket = new WebSocket(dataURL);\n    socket.addEventListener('open', () => {\n        statusDiv.textContent = 'Connected';\n        transcriptionDiv.textContent = '';\n        fullTextDiv.textContent = '';\n        transcriptionContainer.style.display = 'block';\n        fullTextContainer.style.display = 'block';\n    });\n    socket.addEventListener('message', event => {\n        try {\n            const data = JSON.parse(event.data);\n            if (data.transcription !== undefined) {\n                transcriptionDiv.textContent = data.transcription;\n            }\n            if (data.full_text !== undefined) {\n                fullTextDiv.textContent = data.full_text;\n            }\n        } catch (error) {\n            console.error('Error parsing message:', error);\n        }\n    });\n    socket.addEventListener('error', error => {\n        console.error('WebSocket error:', error);\n        statusDiv.textContent = 'Connection Error';\n    });\n    socket.addEventListener('close', () => {\n        statusDiv.textContent = 'Disconnected';\n    });\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Implement a client for interacting with Quqi.com's API to perform daily tasks, manage group operations, and track rewards.\n\nClass Description: The QuqiClient class provides methods to interact with Quqi.com's web services including task management, group operations, file uploads, and reward collection. It handles HTTP requests using Axios with proper headers and error handling.\n\nAttributes:\n- headers: [Object] - Contains HTTP headers including cookies and referer for API authentication\n- config: [Object] - Configuration object containing user credentials and settings\n\nMethods:\n- constructor(config) -> [void] - Initializes the client with configuration including authentication cookies\n- _sleep(ms) -> [Promise] - Utility method for delaying execution\n- getDailyTask() -> [Promise<Array|null>] - Retrieves list of incomplete daily tasks\n- getReward(id) -> [Promise<void>] - Claims reward for a specific task ID\n- visit(id) -> [Promise<void>] - Visits a specified group to complete visit tasks\n- getQuqiId() -> [Promise<Object|null>] - Gets group information and handles group joining if needed\n- uploadImg(id) -> [Promise<void>] - Uploads and deletes a dummy image to complete upload tasks\n- executeTasks() -> [Promise<String>] - Executes all available tasks and returns wallet information",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass QuqiClient {\n    constructor(config) {\n        this.headers = {\n            cookie: config.quqi.cookie,\n            referer: \"https://quqi.com/\"\n        };\n    }\n\n    async _sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    async getDailyTask() {\n        try {\n            let res = await axios.get(`https://exp.quqi.com/v1/dailyTask/state?_=1${Date.now()}`, {headers: this.headers});\n            if(res.data.err == 0) {\n                let list = res.data.data.filter(x => x.status != 2);\n                console.log(`\u5269\u4f59${list.length}\u4efb\u52a1\u672a\u5b8c\u6210`);\n                return list;\n            }\n        } catch (err) {\n            console.log(err);\n        }\n        return null;\n    }\n\n    async getReward(id) {\n        try {\n            let res = await axios.get(`https://exp.quqi.com/v1/dailyTask/sendAward/${id}`, {headers: this.headers});\n            console.log(\"\u9886\u53d6\u5956\u52b1\uff1a\" + res.data.msg);\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async visit(id) {\n        try {\n            this.headers[\"User-Agent\"] = \"Mozilla/5.0 (Linux; Android 11; Redmi K30) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36\";\n            let res = await axios.post(`https://quqi.com/api/dir/ls?quqi_id=${id}`, `quqi_id=${id}&tree_id=1&node_id=0`, {headers: this.headers});\n            let res1 = await axios.post(`https://quqi.com/auth/updateVisit?quqi_id=${id}`, `quqi_id=${id}`, {headers: this.headers});\n            console.log(\"\u6d4f\u89c8\u591a\u4eba\u7fa4\u7ec4\uff1a\" + res1.data.msg);\n            await this._sleep(1000);\n            await this.getReward(14);\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async getQuqiId() {\n        try {\n            let res = await axios.get(\"https://group.quqi.com/v1/group/list\", {headers: this.headers});\n            if (res.data.msg == \"success\") {\n                let gplist = res.data.data.filter(x => x.type == 14);\n                let quqid = gplist.length == 0 ? res.data.data[0].quqi_id : gplist[0].quqi_id;\n                let gtype = gplist.length == 0 ? 1 : 2;\n                if (gtype == 1) {\n                    console.log(\"\ud83c\ude1a\ufe0f\u591a\u4eba\u7fa4\u7ec4,\u8bf7\u81ea\u884c\u521b\u5efa\u4e00\u4e2a\u591a\u4eba\u7fa4\u7ec4,\u6216\u8005\u7533\u8bf7\u52a0\u5165https://quqi.avyeld.com/join/company/team.html?jointarget=ed521eef-7ed1-486f-a903-2457ebe5704f\");\n                    let sqres = await axios.post(\"https://group.quqi.com/v1/application\", \"credential=ed521eef-7ed1-486f-a903-2457ebe5704f\", {headers: this.headers});\n                    console.log(\"\u7533\u8bf7\u52a0\u5165\u591a\u4eba\u7fa4\u7ec4\uff1a\" + sqres.data.msg);\n                }\n                return {\n                    qid: quqid,\n                    gtype: gtype\n                };\n            }\n        } catch (err) {\n            console.log(err);\n        }\n        return null;\n    }\n\n    async uploadImg(id) {\n        try {\n            let name = `\u6bcf\u65e5\u7b7e\u5230${Date.now()}`;\n            this.headers[\"User-Agent\"] = \"Mozilla/5.0 (Linux; Android 11; Redmi K30) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36\";\n            let res = await axios.post(`https://quqi.com/api/upload/v1/file/init?quqi_id=${id}`, `file_name=${name}.jpg&is_slice=false&md5=507cf982c5db90bc35f9c6c8179c292f&parent_id=0&quqi_id=${id}&sha=4b4afc24113d86d0afd9be21b6841d9c627cdabf01317e3e760308b05f8bdd81&sign=617db783e0ba01343338ee9887dfdb18&size=331665&tree_id=1`, {headers: this.headers});\n            if (res.data.msg == \"ok\") {\n                console.log(`\u4e0a\u4f20\u56fe\u7247 ${name} \u6210\u529f`);\n                let nid = res.data.data.node_id;\n                if (nid) await axios.post(`https://quqi.com/api/node/batchDel?quqi_id=${id}`, `quqi_id=${id}&tree_id=1&node_ids=${nid}`, {headers: this.headers});\n                await this._sleep(1000);\n                await this.getReward(15);\n            } else {\n                console.log(\"\u4e0a\u4f20\u5931\u8d25\uff1a\" + res.data.msg);\n            }\n        } catch (err) {\n            console.log(err);\n        }\n    }\n\n    async executeTasks() {\n        let quqinfo = \"\";\n        let dailyTaskList = await this.getDailyTask();\n        let qgp = await this.getQuqiId();\n        \n        if (dailyTaskList) {\n            for (let task of dailyTaskList) {\n                console.log(task.task_decreption);\n                if (task.status == 1) {\n                    await this.getReward(task.task_type);\n                } else if (task.task_type == 14 && task.status == 0 && qgp.gtype == 2) {\n                    await this.visit(qgp.qid);\n                } else if (task.task_type == 15 && task.status == 0) {\n                    await this.uploadImg(qgp.qid);\n                }\n            }\n        }\n        \n        let ires = await axios.get(\"https://api.quqi.com/vipWallet/v1/vipAndWallet\", {headers: this.headers});\n        if (ires.data.msg == \"success\") {\n            quqinfo = `\u66f2\u5947\u997c\uff1a${ires.data.data.wallet_info.cookie}  \u66f2\u5947\u8c46\uff1a${ires.data.data.wallet_info.bean}`;\n        } else {\n            quqinfo = ires.data.msg;\n        }\n        console.log(quqinfo);\n        return \"\u3010\u66f2\u5947\u7f51\u76d8\u3011\uff1a\" + quqinfo;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\n\nclass QuqiClient {\n  constructor(config) {\n    this.config = config;\n    this.headers = {\n      'Cookie': `token=${config.token};`,\n      'Referer': 'https://quqi.com/',\n      'User-Agent': 'Mozilla/5.0'\n    };\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async getDailyTask() {\n    try {\n      const response = await axios.get('https://quqi.com/api/daily/tasks', { headers: this.headers });\n      return response.data.filter(task => !task.completed);\n    } catch (error) {\n      console.error('Failed to fetch daily tasks:', error.message);\n      return null;\n    }\n  }\n\n  async getReward(id) {\n    try {\n      await axios.post(`https://quqi.com/api/reward/${id}`, {}, { headers: this.headers });\n      console.log(`Reward claimed for task ID ${id}`);\n    } catch (error) {\n      console.error(`Failed to claim reward for task ${id}:`, error.message);\n    }\n  }\n\n  async visit(id) {\n    try {\n      await axios.post(`https://quqi.com/api/group/visit/${id}`, {}, { headers: this.headers });\n      console.log(`Visited group ID ${id}`);\n    } catch (error) {\n      console.error(`Failed to visit group ${id}:`, error.message);\n    }\n  }\n\n  async getQuqiId() {\n    try {\n      const response = await axios.get('https://quqi.com/api/groups', { headers: this.headers });\n      const groups = response.data;\n\n      if (groups.length === 0) {\n        console.log('No groups found, attempting to join...');\n        const joinResponse = await axios.post('https://quqi.com/api/group/join', { groupId: this.config.defaultGroupId }, { headers: this.headers });\n        return joinResponse.data;\n      }\n\n      return groups[0];\n    } catch (error) {\n      console.error('Failed to retrieve or join group:', error.message);\n      return null;\n    }\n  }\n\n  async uploadImg(id) {\n    try {\n      const formData = new FormData();\n      formData.append('file', 'dummy.jpg');\n\n      await axios.post('https://quqi.com/api/upload', formData, { headers: { ...this.headers, ...formData.getHeaders() } });\n      console.log(`Image uploaded for task ID ${id}`);\n\n      await axios.delete(`https://quqi.com/api/upload/${id}`, { headers: this.headers });\n      console.log(`Image deleted for task ID ${id}`);\n    } catch (error) {\n      console.error(`Failed to upload/delete image for task ${id}:`, error.message);\n    }\n  }\n\n  async executeTasks() {\n    try {\n      const tasks = await this.getDailyTask();\n      if (!tasks || tasks.length === 0) {\n        return 'No tasks available to execute.';\n      }\n\n      for (const task of tasks) {\n        switch (task.type) {\n          case 'reward':\n            await this.getReward(task.id);\n            break;\n          case 'visit':\n            await this.visit(task.id);\n            break;\n          case 'upload':\n            await this.uploadImg(task.id);\n            break;\n          default:\n            console.log(`Unknown task type: ${task.type}`);\n        }\n\n        await this._sleep(1000);\n      }\n\n      const walletRes = await axios.get('https://quqi.com/api/wallet', { headers: this.headers });\n      return `Execution complete. Wallet info: ${JSON.stringify(walletRes.data)}`;\n    } catch (error) {\n      console.error('Error during task execution:', error.message);\n      return 'Task execution failed.';\n    }\n  }\n}\n\nexport default QuqiClient;"
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with reconnection capabilities and event handling.\n\nClass Description: The N class represents a WebSocket client that connects to a specified URL, handles messages, errors, and connection events, and supports automatic reconnection. It provides methods to start, destroy, and manage the WebSocket connection, along with callbacks for connection events.\n\nAttributes:\n- url: [String] - The WebSocket server URL to connect to.\n- options: [Object] - Configuration options for the WebSocket connection, including protocols, reconnect interval, and callbacks.\n- socket: [WebSocket] - The WebSocket connection instance.\n- streaming: [Boolean] - Indicates if the connection is in streaming mode.\n- callbacks: [Object] - Contains arrays of callback functions for connection and data events.\n- destination: [Object] - The destination to write received data to.\n- reconnectInterval: [Number] - The interval (in seconds) between reconnection attempts.\n- shouldAttemptReconnect: [Boolean] - Indicates if reconnection should be attempted.\n- completed: [Boolean] - Indicates if the connection is completed.\n- established: [Boolean] - Indicates if the connection is established.\n- progress: [Number] - Tracks the connection progress.\n- reconnectTimeoutId: [Number] - The timeout ID for reconnection attempts.\n- onEstablishedCallback: [Function] - Callback function triggered when the connection is established.\n- onCompletedCallback: [Function] - Callback function triggered when the connection is completed.\n- hookOnEstablished: [Function] - Optional hook function triggered when the connection is established.\n\nMethods:\n- constructor(url, options) -> [N] - Initializes the WebSocket client with the given URL and options.\n- connect(destination) -> [void] - Sets the destination for received data.\n- destroy() -> [void] - Closes the WebSocket connection and stops reconnection attempts.\n- start() -> [void] - Starts the WebSocket connection and sets up event handlers.\n- resume() -> [void] - Placeholder for resuming the connection (currently empty).\n- onOpen() -> [void] - Handles the WebSocket 'open' event and updates progress.\n- onClose() -> [void] - Handles the WebSocket 'close' and 'error' events and initiates reconnection if enabled.\n- onMessage(event) -> [void] - Handles the WebSocket 'message' event, writes data to the destination, and triggers callbacks.",
    "Canonical_solution": "class N {\n  constructor(A, t) {\n    this.url = A;\n    this.options = t;\n    this.socket = null;\n    this.streaming = !0;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== t.reconnectInterval ? t.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = !1;\n    this.established = !1;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = t.onSourceEstablished;\n    this.onCompletedCallback = t.onSourceCompleted;\n    t.hookOnEstablished && (this.hookOnEstablished = t.hookOnEstablished);\n  }\n\n  connect(A) {\n    this.destination = A;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = !1;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = !1;\n    this.options.protocols\n      ? (this.socket = new WebSocket(this.url, this.options.protocols))\n      : (this.socket = new WebSocket(this.url));\n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    var A = this;\n    this.shouldAttemptReconnect &&\n      (clearTimeout(this.reconnectTimeoutId),\n      (this.reconnectTimeoutId = setTimeout(function () {\n        A.start();\n      }, 1e3 * this.reconnectInterval)));\n  }\n\n  onMessage(A) {\n    var t = !this.established;\n    this.established = !0;\n    t && this.hookOnEstablished && this.hookOnEstablished();\n    t && this.onEstablishedCallback && this.onEstablishedCallback(this);\n    this.destination && this.destination.write(A.data);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options || {};\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = this.options.reconnectInterval || 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = this.options.hookOnEstablished || null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.shouldAttemptReconnect = false;\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n    if (this.socket) {\n      this.socket.removeEventListener('open', this.onOpen);\n      this.socket.removeEventListener('close', this.onClose);\n      this.socket.removeEventListener('error', this.onClose);\n      this.socket.removeEventListener('message', this.onMessage);\n      this.socket.close();\n      this.socket = null;\n    }\n    this.established = false;\n    this.completed = false;\n  }\n\n  start() {\n    const protocols = this.options.protocols || [];\n    try {\n      this.socket = new WebSocket(this.url, protocols);\n      this.socket.addEventListener('open', () => this.onOpen());\n      this.socket.addEventListener('close', () => this.onClose());\n      this.socket.addEventListener('error', () => this.onClose());\n      this.socket.addEventListener('message', (event) => this.onMessage(event));\n    } catch (err) {\n      this.onClose();\n    }\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 100;\n    this.established = true;\n    this.callbacks.connect.forEach(cb => cb());\n    if (typeof this.onEstablishedCallback === 'function') {\n      this.onEstablishedCallback();\n    }\n    if (typeof this.hookOnEstablished === 'function') {\n      this.hookOnEstablished();\n    }\n  }\n\n  onClose() {\n    this.established = false;\n    this.completed = true;\n    if (this.shouldAttemptReconnect && !this.reconnectTimeoutId) {\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.reconnectTimeoutId = null;\n        this.start();\n      }, this.reconnectInterval * 1000);\n    }\n    if (typeof this.onCompletedCallback === 'function') {\n      this.onCompletedCallback();\n    }\n  }\n\n  onMessage(event) {\n    if (this.destination && typeof this.destination.write === 'function') {\n      this.destination.write(event.data);\n    }\n    this.callbacks.data.forEach(cb => cb(event.data));\n  }\n}"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a specified path on a server and returns the WebSocket object if the connection is successfully opened.\n\nFunction Description: The function `apiWebSocket` attempts to create a WebSocket connection to a given path on a secure WebSocket server. It waits for the connection to be established or fail (due to error or closure) and returns the WebSocket object only if the connection is successfully opened. If the connection fails or an error occurs, the function returns `undefined`.\n\nInput: \n- `path` (string): The path on the server to which the WebSocket connection should be established. This is appended to the base URL `wss://services.bonjourr.fr/`.\n\nOutput: \n- `Promise<WebSocket | undefined>`: A promise that resolves to the WebSocket object if the connection is successfully opened, or `undefined` if the connection fails or an error occurs.",
    "Canonical_solution": "export async function apiWebSocket(path: string): Promise<WebSocket | undefined> {\n\ttry {\n\t\tconst socket = new WebSocket(`wss://services.bonjourr.fr/${path}`)\n\t\tconst isOpened = await new Promise((resolve) => {\n\t\t\tsocket.onopen = () => resolve(true)\n\t\t\tsocket.onerror = () => resolve(false)\n\t\t\tsocket.onclose = () => resolve(false)\n\t\t})\n\n\t\tif (isOpened) {\n\t\t\treturn socket\n\t\t}\n\t} catch (_error) {\n\t\t// ...\n\t}\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function apiWebSocket(path) {\n  return new Promise((resolve) => {\n    const ws = new WebSocket('wss://services.bonjourr.fr/' + path);\n    \n    const onOpen = () => {\n      cleanup();\n      resolve(ws);\n    };\n    \n    const onError = () => {\n      cleanup();\n      resolve(undefined);\n    };\n    \n    const onClose = () => {\n      cleanup();\n      resolve(undefined);\n    };\n    \n    const cleanup = () => {\n      ws.removeEventListener('open', onOpen);\n      ws.removeEventListener('error', onError);\n      ws.removeEventListener('close', onClose);\n    };\n    \n    ws.addEventListener('open', onOpen);\n    ws.addEventListener('error', onError);\n    ws.addEventListener('close', onClose);\n  });\n}"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Implement a LiveQueryClient class that manages WebSocket connections for real-time data updates in a Parse server environment, handling connection lifecycle, subscriptions, and error recovery.\n\nClass Description: The LiveQueryClient class establishes and maintains a WebSocket connection to a Parse LiveQuery server, manages subscriptions to queries, handles connection events (open, message, error, close), and implements automatic reconnection logic.\n\nAttributes:\n- attempts: number - Tracks reconnection attempts for exponential backoff\n- id: number - Unique client identifier assigned by server\n- requestId: number - Counter for subscription requests\n- applicationId: string - Parse application ID for authentication\n- serverURL: string - WebSocket server URL (must start with 'ws' or 'wss')\n- javascriptKey: string (optional) - JavaScript key for authentication\n- masterKey: string (optional) - Master key for authentication\n- sessionToken: string (optional) - User session token\n- installationId: string (optional) - Device installation identifier\n- additionalProperties: boolean - Flag to include additional properties in requests\n- connectPromise: Promise - Promise resolved when connection is established\n- subscriptions: Map<number, LiveQuerySubscription> - Active subscriptions\n- socket: WebSocketController - WebSocket connection controller\n- state: string - Current connection state (INITIALIZED, CONNECTING, CONNECTED, etc.)\n- reconnectHandle: any - Timeout handle for reconnection attempts\n- emitter: EventEmitter - Event emitter for connection events\n- on: function - Shortcut to emitter.on\n- emit: function - Shortcut to emitter.emit\n\nMethods:\n- constructor({applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId}) -> void - Initializes the client with connection parameters and validates serverURL\n- open() -> void - Establishes WebSocket connection and sets up event handlers\n- _handleWebSocketOpen() -> void - Sends connection request to server after WebSocket opens\n- _handleWebSocketMessage(event: any) -> void - Processes incoming messages from server and handles connection confirmation\n- _handleWebSocketClose() -> void - Handles connection closure and triggers reconnection\n- _handleWebSocketError(error: any) -> void - Handles WebSocket errors and triggers reconnection\n- _handleReconnect() -> void - Implements exponential backoff reconnection logic",
    "Canonical_solution": "import CoreManager, { WebSocketController } from './CoreManager';\nimport ParseObject from './ParseObject';\nimport LiveQuerySubscription from './LiveQuerySubscription';\nimport { resolvingPromise } from './promiseUtils';\nimport ParseError from './ParseError';\nimport type ParseQuery from './ParseQuery';\n\nclass LiveQueryClient {\n  attempts: number;\n  id: number;\n  requestId: number;\n  applicationId: string;\n  serverURL: string;\n  javascriptKey?: string;\n  masterKey?: string;\n  sessionToken?: string;\n  installationId?: string;\n  additionalProperties: boolean;\n  connectPromise: any;\n  subscriptions: Map<number, LiveQuerySubscription>;\n  socket: WebSocketController & { closingPromise?: any };\n  state: string;\n  reconnectHandle: any;\n  emitter: any;\n  on: any;\n  emit: any;\n\n  constructor({\n    applicationId,\n    serverURL,\n    javascriptKey,\n    masterKey,\n    sessionToken,\n    installationId,\n  }) {\n    if (!serverURL || serverURL.indexOf('ws') !== 0) {\n      throw new Error(\n        'You need to set a proper Parse LiveQuery server url before using LiveQueryClient'\n      );\n    }\n\n    this.reconnectHandle = null;\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.serverURL = serverURL;\n    this.applicationId = applicationId;\n    this.javascriptKey = javascriptKey || undefined;\n    this.masterKey = masterKey || undefined;\n    this.sessionToken = sessionToken || undefined;\n    this.installationId = installationId || undefined;\n    this.additionalProperties = true;\n    this.connectPromise = resolvingPromise();\n    this.subscriptions = new Map();\n    this.state = CLIENT_STATE.INITIALIZED;\n    const EventEmitter = CoreManager.getEventEmitter();\n    this.emitter = new EventEmitter();\n\n    this.on = (eventName, listener) => this.emitter.on(eventName, listener);\n    this.emit = (eventName, ...args) => this.emitter.emit(eventName, ...args);\n    this.on('error', () => {});\n  }\n\n  open() {\n    const WebSocketImplementation = CoreManager.getWebSocketController();\n    if (!WebSocketImplementation) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n      return;\n    }\n\n    if (this.state !== CLIENT_STATE.RECONNECTING) {\n      this.state = CLIENT_STATE.CONNECTING;\n    }\n\n    this.socket = new WebSocketImplementation(this.serverURL);\n    this.socket.closingPromise = resolvingPromise();\n\n    this.socket.onopen = () => {\n      this._handleWebSocketOpen();\n    };\n\n    this.socket.onmessage = event => {\n      this._handleWebSocketMessage(event);\n    };\n\n    this.socket.onclose = event => {\n      this.socket.closingPromise?.resolve(event);\n      this._handleWebSocketClose();\n    };\n\n    this.socket.onerror = error => {\n      this._handleWebSocketError(error);\n    };\n  }\n\n  _handleWebSocketOpen() {\n    const connectRequest = {\n      op: OP_TYPES.CONNECT,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken,\n      installationId: undefined as string | undefined,\n    };\n    if (this.additionalProperties) {\n      connectRequest.installationId = this.installationId;\n    }\n    this.socket.send(JSON.stringify(connectRequest));\n  }\n\n  _handleWebSocketMessage(event: any) {\n    let data = event.data;\n    if (typeof data === 'string') {\n      data = JSON.parse(data);\n    }\n    let subscription: null | LiveQuerySubscription = null;\n    if (data.requestId) {\n      subscription = this.subscriptions.get(data.requestId) || null;\n    }\n    const response = {\n      clientId: data.clientId,\n      installationId: data.installationId,\n    };\n    switch (data.op) {\n    case OP_EVENTS.CONNECTED:\n      if (this.state === CLIENT_STATE.RECONNECTING) {\n        this.resubscribe();\n      }\n      this.emit(CLIENT_EMMITER_TYPES.OPEN);\n      this.id = data.clientId;\n      this.connectPromise.resolve();\n      this.state = CLIENT_STATE.CONNECTED;\n      break;\n    }\n  }\n\n  _handleWebSocketClose() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.CLOSED;\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error: any) {\n    this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);\n    }\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.RECONNECTING;\n    const time = generateInterval(this.attempts);\n\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n    this.reconnectHandle = setTimeout(\n      (() => {\n        this.attempts++;\n        this.connectPromise = resolvingPromise();\n        this.open();\n      }).bind(this),\n      time\n    );\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "import EventEmitter from 'events';\nimport WebSocketController from './WebSocketController'; // Assuming this is a custom class for managing WebSocket connections\nimport LiveQuerySubscription from './LiveQuerySubscription'; // Assuming this class exists\n\nclass LiveQueryClient extends EventEmitter {\n  constructor({ applicationId, serverURL, javascriptKey, masterKey, sessionToken, installationId }) {\n    super();\n    if (!serverURL || !serverURL.startsWith('ws')) {\n      throw new Error('Server URL must start with \"ws\" or \"wss\"');\n    }\n\n    this.attempts = 0;\n    this.id = null;\n    this.requestId = 0;\n    this.applicationId = applicationId;\n    this.serverURL = serverURL;\n    this.javascriptKey = javascriptKey;\n    this.masterKey = masterKey;\n    this.sessionToken = sessionToken;\n    this.installationId = installationId;\n    this.additionalProperties = true;\n    this.connectPromise = null;\n    this.subscriptions = new Map();\n    this.socket = null;\n    this.state = 'INITIALIZED';\n    this.reconnectHandle = null;\n    this.emitter = this;\n    this.on = this.emitter.on.bind(this.emitter);\n    this.emit = this.emitter.emit.bind(this.emitter);\n  }\n\n  open() {\n    this.state = 'CONNECTING';\n    const connect = () => {\n      const wsUrl = `${this.serverURL}?applicationId=${encodeURIComponent(this.applicationId)}`;\n      this.socket = new WebSocketController(wsUrl);\n\n      this.socket.on('open', this._handleWebSocketOpen.bind(this));\n      this.socket.on('message', this._handleWebSocketMessage.bind(this));\n      this.socket.on('close', this._handleWebSocketClose.bind(this));\n      this.socket.on('error', this._handleWebSocketError.bind(this));\n    };\n\n    this.connectPromise = new Promise((resolve, reject) => {\n      const timer = setInterval(() => {\n        if (this.state === 'CONNECTED') {\n          clearInterval(timer);\n          resolve();\n        } else if (this.state === 'CLOSED' || this.state === 'ERROR') {\n          clearInterval(timer);\n          reject(new Error('Connection failed'));\n        }\n      }, 100);\n    });\n\n    connect();\n  }\n\n  _handleWebSocketOpen() {\n    this.state = 'CONNECTED';\n    this.attempts = 0;\n\n    const connectionRequest = {\n      action: 'connect',\n      applicationId: this.applicationId,\n      requestId: this.requestId++,\n    };\n\n    if (this.javascriptKey) {\n      connectionRequest.javascriptKey = this.javascriptKey;\n    }\n\n    if (this.masterKey) {\n      connectionRequest.masterKey = this.masterKey;\n    }\n\n    if (this.sessionToken) {\n      connectionRequest.sessionToken = this.sessionToken;\n    }\n\n    if (this.installationId) {\n      connectionRequest.installationId = this.installationId;\n    }\n\n    this.socket.send(JSON.stringify(connectionRequest));\n  }\n\n  _handleWebSocketMessage(event) {\n    let message;\n    try {\n      message = JSON.parse(event.data);\n    } catch (e) {\n      return;\n    }\n\n    if (message.action === 'connected') {\n      this.id = message.clientId;\n      this.emit('open');\n    } else if (message.action === 'subscribed') {\n      const subscription = this.subscriptions.get(message.requestId);\n      if (subscription) {\n        subscription.subscribe(message.subscriptionId);\n      }\n    } else if (message.action === 'unsubscribed') {\n      const subscription = this.subscriptions.get(message.subscriptionId);\n      if (subscription) {\n        subscription.unsubscribe();\n        this.subscriptions.delete(message.subscriptionId);\n      }\n    } else if (message.operation && message.objectId) {\n      const subscription = this.subscriptions.get(message.subscriptionId);\n      if (subscription) {\n        subscription.handleEvent(message);\n      }\n    }\n  }\n\n  _handleWebSocketClose() {\n    this.state = 'CLOSED';\n    this.emit('close');\n\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error) {\n    this.emit('error', error);\n    this.socket.close();\n  }\n\n  _handleReconnect() {\n    if (this.state === 'CLOSED' || this.state === 'ERROR') {\n      this.attempts += 1;\n      const delay = Math.min(1000 * Math.pow(2, this.attempts), 30000);\n\n      this.reconnectHandle = setTimeout(() => {\n        this.open();\n      }, delay);\n    }\n  }\n\n  subscribe(query) {\n    const requestId = this.requestId++;\n    const subscription = new LiveQuerySubscription(requestId, query, this);\n    this.subscriptions.set(requestId, subscription);\n    subscription.start();\n    return subscription;\n  }\n\n  unsubscribe(subscriptionId) {\n    const unsubscribeMessage = {\n      action: 'unsubscribe',\n      subscriptionId,\n      requestId: this.requestId++\n    };\n    this.socket.send(JSON.stringify(unsubscribeMessage));\n  }\n\n  close() {\n    this.state = 'CLOSING';\n    if (this.socket) {\n      this.socket.close();\n    }\n    this.emit('close');\n  }\n}"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function speechApi(ssml) {\n    const subscriptionKey = 'YOUR_SUBSCRIPTION_KEY'; // Replace with your Microsoft Speech API key\n    const region = 'YOUR_REGION'; // Replace with your region (e.g., 'eastus')\n    const url = `https://${region}.tts.speech.microsoft.com/cognitiveservices/v1`;\n\n    const headers = {\n        'Ocp-Apim-Subscription-Key': subscriptionKey,\n        'Content-Type': 'application/ssml+xml',\n        'X-Microsoft-OutputFormat': 'audio-24khz-160kbitrate-mono-mp3'\n    };\n\n    try {\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: headers,\n            body: ssml\n        });\n\n        if (!response.ok) {\n            throw new Error(`Speech API request failed with status ${response.status}`);\n        }\n\n        const arrayBuffer = await response.arrayBuffer();\n        return arrayBuffer;\n    } catch (error) {\n        throw new Error(`Error in speech synthesis: ${error.message}`);\n    }\n}\n```"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that connects to a server, sends messages, and displays received messages in a chat interface.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a server when a button is clicked. It handles connection events (open, close, message) and allows sending messages via an input field. The function disables the join button during active connection and re-enables it when closed.\n\nInput: \n- None (the function uses DOM elements internally: username input, join button, chat textarea, and message input field)\n\nOutput: \n- None (the function sets up event listeners and modifies DOM elements directly)\n\nAttributes: N/A (function-level implementation)\n\nMethods: N/A (function-level implementation)",
    "Canonical_solution": "function setupWebSocket() {\n    const username = document.querySelector(\"#username\");\n    const join_btn = document.querySelector(\"#join-chat\");\n    const textarea = document.querySelector(\"#chat\");\n    const input = document.querySelector(\"#input\");\n\n    join_btn.addEventListener(\"click\", function(e) {\n        this.disabled = true;\n\n        const websocket = new WebSocket(\"ws://localhost:3000/websocket\");\n\n        websocket.onopen = function() {\n            console.log(\"connection opened\");\n            websocket.send(username.value);\n        }\n\n        const btn = this;\n\n        websocket.onclose = function() {\n            console.log(\"connection closed\");\n            btn.disabled = false;\n        }\n\n        websocket.onmessage = function(e) {\n            console.log(\"received message: \"+e.data);\n            textarea.value += e.data+\"\\r\\n\";\n        }\n\n        input.onkeydown = function(e) {\n            if (e.key == \"Enter\") {\n                websocket.send(input.value);\n                input.value = \"\";\n            }\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function setupWebSocket() {\n    const wsUri = \"ws://example.com/socket\"; \n    let websocket;\n    const joinButton = document.getElementById(\"joinBtn\");\n    const usernameInput = document.getElementById(\"username\");\n    const messageInput = document.getElementById(\"message\");\n    const chatBox = document.getElementById(\"chat\");\n\n    function logMessage(text) {\n        const msgElement = document.createElement(\"div\");\n        msgElement.textContent = text;\n        chatBox.appendChild(msgElement);\n        chatBox.scrollTop = chatBox.scrollHeight;\n    }\n\n    joinButton.addEventListener(\"click\", () => {\n        if (!websocket || websocket.readyState === WebSocket.CLOSED) {\n            const username = usernameInput.value.trim();\n            if (!username) {\n                alert(\"Please enter a username.\");\n                return;\n            }\n            websocket = new WebSocket(wsUri);\n            joinButton.disabled = true;\n\n            websocket.addEventListener(\"open\", () => {\n                logMessage(`Connected as ${username}`);\n                messageInput.disabled = false;\n            });\n\n            websocket.addEventListener(\"close\", () => {\n                logMessage(\"Connection closed\");\n                joinButton.disabled = false;\n                messageInput.disabled = true;\n            });\n\n            websocket.addEventListener(\"message\", (event) => {\n                logMessage(event.data);\n            });\n        }\n    });\n\n    messageInput.addEventListener(\"keypress\", (e) => {\n        if (e.key === \"Enter\") {\n            const username = usernameInput.value.trim();\n            const message = messageInput.value.trim();\n            if (message && websocket && websocket.readyState === WebSocket.OPEN) {\n                websocket.send(`${username}: ${message}`);\n                messageInput.value = \"\";\n            }\n        }\n    });\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a WebSocket client connection class for browser environments that handles connection lifecycle, message events, and window focus state tracking.\n\nClass Description: The BrowserConnection class manages a WebSocket connection in a browser environment, including connection setup, event handling, and window visibility tracking. It extends a base connection class (BaseConnection) and adds browser-specific functionality.\n\nAttributes:\n- focusDetectorTimer: [Number] - Timer ID for the focus detection interval\n- windowVisible: [Boolean] - Tracks whether the browser window is currently visible\n- socket: [WebSocket] - The WebSocket connection instance\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the connection with options and sets up event listeners for 'ready' and 'disconnect' events\n- setupSocket() -> WebSocket - Creates and configures a new WebSocket connection with event handlers for open, close, and message events\n- startFocusLoop() -> void - Starts tracking window visibility by setting up event listeners for focus/blur events and periodic checks\n- stopFocusLoop() -> void - Stops the window visibility tracking by clearing the interval timer and removing event listeners\n- handleOpen() -> void - Inherited from BaseConnection, called when WebSocket connection opens\n- handleClose(code: Number, reason: String) -> void - Inherited from BaseConnection, called when WebSocket connection closes\n- handleData(data: String) -> void - Inherited from BaseConnection, called when WebSocket receives a message\n- reportFocus(isVisible: Boolean) -> void - Inherited from BaseConnection, reports current window focus state",
    "Canonical_solution": "var WebSocket = require(\"ws\");\nvar _ = require(\"underscore\");\n\nclass BrowserConnection {\n  constructor(opts) {\n    BaseConnection.call(this, opts);\n    var connection = this;\n    this.on(\"ready\", function() {\n      connection.startFocusLoop()\n    });\n    this.on(\"disconnect\", function() {\n      connection.stopFocusLoop()\n    });\n  }\n\n  setupSocket() {\n    var connection = this;\n    var socket = new WebSocket(this.getUrl());\n    socket.onopen = function() {\n      connection.handleOpen()\n    };\n    socket.onclose = function(data) {\n      connection.handleClose(data[\"code\"], data[\"reason\"])\n    };\n    socket.onmessage = function(message) {\n      connection.handleData(message.data)\n    };\n    return socket;\n  }\n\n  startFocusLoop() {\n    if (this.focusDetectorTimer) return;\n    var connection = this;\n    var propertyName = null;\n    if (typeof document.hidden !== \"undefined\") {\n      propertyName = \"hidden\"\n    } else if (typeof document.mozHidden !== \"undefined\") {\n      propertyName = \"mozHidden\"\n    } else if (typeof document.msHidden !== \"undefined\") {\n      propertyName = \"msHidden\"\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      propertyName = \"webkitHidden\"\n    } else {\n      propertyName = undefined\n    }\n    if (connection.windowVisible === undefined) {\n      connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false\n    }\n    var focusListener = window.addEventListener(\"focus\", function(e) {\n      connection.windowVisible = true;\n      updateFocusState()\n    });\n    var blurListener = window.addEventListener(\"blur\", function(e) {\n      connection.windowVisible = false;\n      updateFocusState()\n    });\n    this.on(\"disconnect\", function() {\n      window.removeEventListener(\"focus\", focusListener);\n      window.removeEventListener(\"blur\", blurListener)\n    });\n    var updateFocusState = function() {\n      var isVisible = propertyName === undefined ? true : document[propertyName] === false;\n      connection.reportFocus(isVisible && connection.windowVisible)\n    };\n    this.focusDetectorTimer = setInterval(updateFocusState, 100)\n  }\n\n  stopFocusLoop() {\n    if (!this.focusDetectorTimer) return;\n    clearTimeout(this.focusDetectorTimer);\n    delete this.focusDetectorTimer;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = true;\n    this.socket = null;\n    this.setupSocket();\n    this.startFocusLoop();\n  }\n\n  setupSocket() {\n    this.socket = new WebSocket(this.opts.url);\n\n    this.socket.addEventListener('open', () => {\n      this.handleOpen();\n    });\n\n    this.socket.addEventListener('close', (event) => {\n      this.handleClose(event.code, event.reason);\n    });\n\n    this.socket.addEventListener('message', (event) => {\n      this.handleData(event.data);\n    });\n\n    return this.socket;\n  }\n\n  startFocusLoop() {\n    const checkVisibility = () => {\n      const isVisible = !document.hidden;\n      if (this.windowVisible !== isVisible) {\n        this.windowVisible = isVisible;\n        this.reportFocus(isVisible);\n      }\n    };\n\n    document.addEventListener('visibilitychange', checkVisibility);\n    window.addEventListener('focus', () => {\n      this.windowVisible = true;\n      this.reportFocus(true);\n    });\n    window.addEventListener('blur', () => {\n      this.windowVisible = false;\n      this.reportFocus(false);\n    });\n\n    this.focusDetectorTimer = setInterval(checkVisibility, 1000);\n  }\n\n  stopFocusLoop() {\n    clearInterval(this.focusDetectorTimer);\n    this.focusDetectorTimer = null;\n    document.removeEventListener('visibilitychange', this.checkVisibility);\n    window.removeEventListener('focus', this.handleFocus);\n    window.removeEventListener('blur', this.handleBlur);\n  }\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a class that serves as an HTTP client for interacting with a build service API, handling different types of package-related operations with proper error handling.\n\nClass Description: The BuildService class provides methods to fetch package build statistics, exports, and export sizes from a remote build service. It uses Axios for HTTP requests and implements centralized error handling.\n\nAttributes:\n- operations: [Array] - A predefined list of available API operations, each specifying the operation type, endpoint, and corresponding method name\n\nMethods:\n- _makeHttpRequest: [Name](operation: Object, packageString: String) -> Promise<Object> - Makes an HTTP GET request to the build service with the specified operation and package string, handles the response and errors\n- _handleError: [Name](error: Error, operationType: String) -> Throws CustomError - Centralized error handling that processes different types of errors (response errors, request errors, and other errors) and throws appropriate custom errors\n- getPackageBuildStats: [Name](packageString: String) -> Promise<Object> - Retrieves build statistics for the specified package\n- getPackageExports: [Name](packageString: String) -> Promise<Object> - Retrieves all exports for the specified package\n- getPackageExportSizes: [Name](packageString: String) -> Promise<Object> - Retrieves size information for all exports of the specified package",
    "Canonical_solution": "const axios = require('axios');\nconst CustomError = require('../CustomError');\n\nclass BuildService {\n  constructor() {\n    this.operations = [\n      {\n        type: 'PACKAGE_BUILD_STATS',\n        endpoint: '/size',\n        methodName: 'getPackageStats',\n      },\n      {\n        type: 'PACKAGE_EXPORTS',\n        endpoint: '/exports',\n        methodName: 'getAllPackageExports',\n      },\n      {\n        type: 'PACKAGE_EXPORTS_SIZES',\n        endpoint: '/exports-sizes',\n        methodName: 'getPackageExportSizes',\n      },\n    ];\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    try {\n      const response = await axios.get(\n        `${process.env.BUILD_SERVICE_ENDPOINT}${operation.endpoint}?p=${encodeURIComponent(packageString)}`\n      );\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      const contents = error.response.data;\n      throw new CustomError(\n        contents.name || 'BuildError',\n        contents.originalError,\n        contents.extra\n      );\n    } else if (error.request) {\n      throw new CustomError('BuildError', {\n        operation: operationType,\n        reason: 'BUILD_SERVICE_UNREACHABLE',\n        url: error.request._currentUrl,\n      });\n    } else {\n      throw new CustomError('BuildError', error.message, {\n        operation: operationType,\n      });\n    }\n  }\n\n  async getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_BUILD_STATS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.type === 'PACKAGE_EXPORTS_SIZES');\n    return await this._makeHttpRequest(operation, packageString);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\n\nclass CustomError extends Error {\n  constructor(message, type) {\n    super(message);\n    this.type = type;\n    this.name = 'CustomError';\n  }\n}\n\nclass BuildService {\n  constructor() {\n    this.operations = [\n      {\n        type: 'buildStats',\n        endpoint: '/api/build-stats/',\n        method: 'getPackageBuildStats'\n      },\n      {\n        type: 'exports',\n        endpoint: '/api/exports/',\n        method: 'getPackageExports'\n      },\n      {\n        type: 'exportSizes',\n        endpoint: '/api/export-sizes/',\n        method: 'getPackageExportSizes'\n      }\n    ];\n    this.axiosInstance = axios.create({\n      baseURL: 'https://build-service.example.com'\n    });\n  }\n\n  async _makeHttpRequest(operation, packageString) {\n    try {\n      const response = await this.axiosInstance.get(\n        `${operation.endpoint}${encodeURIComponent(packageString)}`\n      );\n      return response.data;\n    } catch (error) {\n      this._handleError(error, operation.type);\n    }\n  }\n\n  _handleError(error, operationType) {\n    if (error.response) {\n      throw new CustomError(\n        `Response error during ${operationType} operation: ${error.response.statusText}`,\n        'response'\n      );\n    } else if (error.request) {\n      throw new CustomError(\n        `Request error during ${operationType} operation: No response received`,\n        'request'\n      );\n    } else {\n      throw new CustomError(\n        `Unexpected error during ${operationType} operation: ${error.message}`,\n        'unknown'\n      );\n    }\n  }\n\n  async getPackageBuildStats(packageString) {\n    const operation = this.operations.find(op => op.type === 'buildStats');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExports(packageString) {\n    const operation = this.operations.find(op => op.type === 'exports');\n    return this._makeHttpRequest(operation, packageString);\n  }\n\n  async getPackageExportSizes(packageString) {\n    const operation = this.operations.find(op => op.type === 'exportSizes');\n    return this._makeHttpRequest(operation, packageString);\n  }\n}"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript that establishes a connection to a server, listens for incoming messages, and sends user input from a text box when the Enter key is pressed.\n\nFunction Description: The function `setupWebSocket` initializes a WebSocket connection to a specified server URL. It sets up an event listener for incoming messages to display them in a designated HTML element. Additionally, it listens for the Enter key press in a text box to send the input text via the WebSocket connection and clears the text box afterward.\n\nInput: None (The function uses DOM elements with IDs \"txt\" and \"divOut\" for text input and message display, respectively.)\n\nOutput: None (The function's side effects include establishing a WebSocket connection, displaying received messages in the \"divOut\" element, and sending user input to the server.)",
    "Canonical_solution": "function setupWebSocket() {\n    const txtBox = document.getElementById(\"txt\");\n    const divOut = document.getElementById(\"divOut\");\n    const ws = new WebSocket(\"ws://localhost/wsapp/\");\n    \n    ws.onmessage = function(e) {\n        divOut.innerHTML += e.data + \"<br/>\";\n    };\n    \n    txtBox.addEventListener(\"keypress\", function(e) {\n        if (e.keyCode === 13) {\n            ws.send(txtBox.value);\n            txtBox.value = \"\";\n        }\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function setupWebSocket(serverUrl) {\n    const socket = new WebSocket(serverUrl);\n    const txtInput = document.getElementById(\"txt\");\n    const outputDiv = document.getElementById(\"divOut\");\n\n    socket.addEventListener(\"message\", function(event) {\n        const message = document.createElement(\"div\");\n        message.textContent = event.data;\n        outputDiv.appendChild(message);\n    });\n\n    txtInput.addEventListener(\"keydown\", function(event) {\n        if (event.key === \"Enter\" && txtInput.value.trim() !== \"\") {\n            socket.send(txtInput.value);\n            txtInput.value = \"\";\n        }\n    });\n}"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that manages WebSocket connections with reconnection capabilities and event handling.\n\nClass Description: The N class represents a WebSocket client that connects to a specified URL, handles connection events, manages reconnection logic, and forwards received messages to a destination. It provides methods to start, destroy, and manage the WebSocket connection.\n\nAttributes:\n\nurl: [String] - The WebSocket server URL to connect to.\noptions: [Object] - Configuration options for the WebSocket connection.\nsocket: [WebSocket|null] - The WebSocket connection instance.\nstreaming: [Boolean] - Indicates if the connection is actively streaming.\ncallbacks: [Object] - Stores event callbacks for connect and data events.\ndestination: [Object|null] - The target to forward received messages to.\nreconnectInterval: [Number] - Time interval (in seconds) between reconnection attempts.\nshouldAttemptReconnect: [Boolean] - Flag to control reconnection behavior.\ncompleted: [Boolean] - Indicates if the connection has completed its purpose.\nestablished: [Boolean] - Indicates if the connection is successfully established.\nprogress: [Number] - Tracks connection progress (0-1).\nreconnectTimeoutId: [Number] - Timeout ID for reconnection attempts.\nonEstablishedCallback: [Function|null] - Callback when connection is established.\nonCompletedCallback: [Function|null] - Callback when connection is completed.\nhookOnEstablished: [Function|null] - Additional hook for established event.\n\nMethods:\n\nconstructor(url, options) -> [N] - Initializes the WebSocket client with the given URL and options.\nconnect(destination) -> [void] - Sets the destination for received messages.\ndestroy() -> [void] - Closes the WebSocket connection and stops reconnection attempts.\nstart() -> [void] - Initiates the WebSocket connection with event handlers.\nresume() -> [void] - Placeholder for resuming functionality (currently empty).\nonOpen() -> [void] - Handles WebSocket open event, sets progress to 1.\nonClose() -> [void] - Handles WebSocket close/error events, initiates reconnection if enabled.\nonMessage(event) -> [void] - Handles incoming messages, triggers established callbacks, and forwards data to destination.",
    "Canonical_solution": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.streaming = true;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = void 0 !== options.reconnectInterval ? options.reconnectInterval : 5;\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = 0;\n    this.onEstablishedCallback = options.onSourceEstablished;\n    this.onCompletedCallback = options.onSourceCompleted;\n    options.hookOnEstablished && (this.hookOnEstablished = options.hookOnEstablished);\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    clearTimeout(this.reconnectTimeoutId);\n    this.shouldAttemptReconnect = false;\n    this.socket.close();\n  }\n\n  start() {\n    this.shouldAttemptReconnect = !!this.reconnectInterval;\n    this.progress = 0;\n    this.established = false;\n    this.options.protocols \n      ? this.socket = new WebSocket(this.url, this.options.protocols)\n      : this.socket = new WebSocket(this.url);\n    \n    this.socket.binaryType = \"arraybuffer\";\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onerror = this.onClose.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n  }\n\n  onClose() {\n    if (this.shouldAttemptReconnect) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, 1000 * this.reconnectInterval);\n    }\n  }\n\n  onMessage(event) {\n    const wasFirstMessage = !this.established;\n    this.established = true;\n    \n    if (wasFirstMessage && this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    \n    if (wasFirstMessage && this.onEstablishedCallback) {\n      this.onEstablishedCallback(this);\n    }\n    \n    if (this.destination) {\n      this.destination.write(event.data);\n    }\n  }\n}\n\n// External dependencies\nconst WebSocket = window.WebSocket;",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class N {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options || {};\n    this.socket = null;\n    this.streaming = false;\n    this.callbacks = { connect: [], data: [] };\n    this.destination = null;\n    this.reconnectInterval = 5;\n    this.shouldAttemptReconnect = true;\n    this.completed = false;\n    this.established = false;\n    this.progress = 0;\n    this.reconnectTimeoutId = null;\n    this.onEstablishedCallback = null;\n    this.onCompletedCallback = null;\n    this.hookOnEstablished = null;\n  }\n\n  connect(destination) {\n    this.destination = destination;\n  }\n\n  destroy() {\n    this.shouldAttemptReconnect = false;\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    if (this.reconnectTimeoutId) {\n      clearTimeout(this.reconnectTimeoutId);\n      this.reconnectTimeoutId = null;\n    }\n    this.streaming = false;\n  }\n\n  start() {\n    try {\n      const wsOptions = this.options.websocket || {};\n      this.socket = new WebSocket(this.url, wsOptions.protocols || []);\n      this.socket.binaryType = 'arraybuffer';\n\n      this.socket.addEventListener('open', () => this.onOpen());\n      this.socket.addEventListener('close', () => this.onClose());\n      this.socket.addEventListener('error', () => this.onClose());\n      this.socket.addEventListener('message', event => this.onMessage(event));\n    } catch (e) {\n      this.onClose();\n    }\n  }\n\n  resume() {}\n\n  onOpen() {\n    this.progress = 1;\n    this.streaming = true;\n    this.established = true;\n    if (this.onEstablishedCallback) {\n      this.onEstablishedCallback();\n    }\n    if (this.hookOnEstablished) {\n      this.hookOnEstablished();\n    }\n    this.callbacks.connect.forEach(cb => cb());\n  }\n\n  onClose() {\n    this.streaming = false;\n    if (this.socket) {\n      this.socket = null;\n    }\n    if (!this.completed && this.shouldAttemptReconnect) {\n      this.reconnectTimeoutId = setTimeout(() => {\n        this.start();\n      }, this.reconnectInterval * 1000);\n    }\n  }\n\n  onMessage(event) {\n    if (!this.established) {\n      this.established = true;\n      if (this.onEstablishedCallback) {\n        this.onEstablishedCallback();\n      }\n      if (this.hookOnEstablished) {\n        this.hookOnEstablished();\n      }\n    }\n\n    if (this.destination && this.destination.receiveData) {\n      this.destination.receiveData(event.data);\n    }\n\n    this.callbacks.data.forEach(cb => cb(event.data));\n  }\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\n\nasync function getChannels() {\n    const url = 'https://api.example.com/tv-channels';\n    try {\n        const response = await axios.get(url);\n        const channels = response.data.map(channel => ({\n            lang: channel.lang,\n            site_id: channel.site_id,\n            name: channel.name\n        }));\n        return channels;\n    } catch (error) {\n        console.error('Error fetching TV channel data:', error);\n        return [];\n    }\n}"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Implement a WebSocket client class in JavaScript that establishes and manages a WebSocket connection, handles events (open, message, error, close), and provides methods for sending data and disconnecting.\n\nClass Description: The WsProvider class encapsulates WebSocket functionality, providing a clean interface for WebSocket communication. It handles connection lifecycle events and ensures proper cleanup when disconnecting.\n\nAttributes:\n#websocket: WebSocket | null - Private field storing the active WebSocket connection instance\n\nMethods:\nconstructor(endpoint: string) -> void - Initializes the WebSocket connection to the specified endpoint\n#connect(endpoint: string) -> void - Private method that establishes the WebSocket connection and sets up event handlers\n#onSocketClose(event: CloseEvent) -> void - Private method handling WebSocket close events\n#onSocketError(error: Event) -> void - Private method handling WebSocket error events\n#onSocketMessage(message: MessageEvent<string>) -> void - Private method handling incoming WebSocket messages\n#onSocketOpen() -> boolean - Private method handling WebSocket open events\nsend(body: string) -> void - Public method for sending data through the WebSocket connection\ndisconnect() -> void - Public method for properly closing the WebSocket connection",
    "Canonical_solution": "import type { Class } from '@polkadot/util/types';\nimport type { JsonRpcResponse, ProviderInterfaceCallback } from '../types.js';\nimport { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\n\nclass WsProvider {\n  #websocket: WebSocket | null;\n\n  constructor(endpoint: string) {\n    this.#websocket = null;\n    this.#connect(endpoint);\n  }\n\n  #connect(endpoint: string): void {\n    try {\n      this.#websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket as unknown as Class<WebSocket>, WebSocket)\n        ? new WebSocket(endpoint)\n        : new WebSocket(endpoint, undefined, {});\n\n      if (this.#websocket) {\n        this.#websocket.onclose = this.#onSocketClose;\n        this.#websocket.onerror = this.#onSocketError;\n        this.#websocket.onmessage = this.#onSocketMessage;\n        this.#websocket.onopen = this.#onSocketOpen;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  #onSocketClose(event: CloseEvent): void {\n    this.#websocket = null;\n  }\n\n  #onSocketError(error: Event): void {\n    // Handle error\n  }\n\n  #onSocketMessage(message: MessageEvent<string>): void {\n    const response = JSON.parse(message.data) as JsonRpcResponse<string>;\n    // Process message\n  }\n\n  #onSocketOpen(): boolean {\n    return true;\n  }\n\n  public send(body: string): void {\n    if (!this.#websocket) {\n      throw new Error('WebSocket is not connected');\n    }\n    this.#websocket.send(body);\n  }\n\n  public disconnect(): void {\n    if (this.#websocket) {\n      this.#websocket.close(1000);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class WsProvider {\n    #websocket = null;\n\n    constructor(endpoint) {\n        this.#connect(endpoint);\n    }\n\n    #connect(endpoint) {\n        this.#websocket = new WebSocket(endpoint);\n\n        this.#websocket.addEventListener('open', () => this.#onSocketOpen());\n        this.#websocket.addEventListener('message', (event) => this.#onSocketMessage(event));\n        this.#websocket.addEventListener('error', (error) => this.#onSocketError(error));\n        this.#websocket.addEventListener('close', (event) => this.#onSocketClose(event));\n    }\n\n    #onSocketClose(event) {\n        console.log('WebSocket closed:', event.reason);\n        this.#websocket = null;\n    }\n\n    #onSocketError(error) {\n        console.error('WebSocket error:', error);\n    }\n\n    #onSocketMessage(message) {\n        console.log('Received message:', message.data);\n    }\n\n    #onSocketOpen() {\n        console.log('WebSocket connected');\n        return true;\n    }\n\n    send(body) {\n        if (this.#websocket && this.#websocket.readyState === WebSocket.OPEN) {\n            this.#websocket.send(body);\n        } else {\n            console.warn('WebSocket not open. ReadyState:', this.#websocket?.readyState);\n        }\n    }\n\n    disconnect() {\n        if (this.#websocket) {\n            this.#websocket.close();\n            this.#websocket = null;\n        }\n    }\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a server, handles various connection events, and processes incoming messages for a reload service.\n\nFunction Description: The `connect` function initializes and manages a WebSocket connection to a specified server. It handles connection events (open, error, message, close) and processes incoming messages to trigger appropriate actions, such as requesting initial load data or reloading extensions when file changes are detected. The function ensures only one active connection exists at a time.\n\nInput: None (The WebSocket URL is hardcoded as 'ws://localhost:__RELOAD_PORT__')\n\nOutput: None (The function primarily manages side effects: establishing connections, logging events, and triggering other functions based on received messages)",
    "Canonical_solution": "function connect() {\n  if (webSocket) {\n    return;\n  }\n\n  webSocket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  webSocket.onerror = (event) => {\n    console.error(`[Reload Service] Connection error: ${JSON.stringify(event)}`);\n    webSocket.close();\n  };\n\n  webSocket.onopen = () => {\n    console.info(`[Reload Service] Connection opened.`);\n  };\n\n  webSocket.onmessage = async (event) => {\n    const message = JSON.parse(event.data);\n\n    if (message.status === 'serverReady') {\n      console.info('[Reload Service] Connection ready.');\n      await requestInitialLoadData();\n    }\n\n    if (message.changedFile) {\n      console.info(\n        `[Reload Service] Changes detected on ${message.changedFile}. Reloading extension...`\n      );\n      await messageAllExtensions(message.changedFile);\n    }\n  };\n\n  webSocket.onclose = () => {\n    console.info('[Reload Service] Connection closed.');\n    webSocket = null;\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "const connect = (() => {\n    let socket = null;\n    const connectFunction = () => {\n        if (socket) {\n            return;\n        }\n        socket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n        socket.addEventListener('open', () => {\n            console.log('WebSocket connection established');\n            socket.send(JSON.stringify({ type: 'handshake' }));\n        });\n        socket.addEventListener('error', event => {\n            console.error('WebSocket error:', event);\n        });\n        socket.addEventListener('message', async event => {\n            const message = JSON.parse(event.data);\n            switch (message.type) {\n                case 'initial-load':\n                    try {\n                        const response = await fetch('/__get-extension-data__');\n                        const data = await response.json();\n                        window.initializeExtensions(data);\n                    } catch (err) {\n                        console.error('Failed to load initial extension data:', err);\n                    }\n                    break;\n                case 'reload-extensions':\n                    window.reloadExtensions(message.changedFiles);\n                    break;\n                default:\n                    console.warn('Unknown message type received:', message.type);\n            }\n        });\n        socket.addEventListener('close', () => {\n            console.log('WebSocket connection closed');\n            socket = null;\n        });\n    };\n    return connectFunction;\n})();"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Implement a function to fetch and process subscribed TV channels from a streaming service API, including authentication and data extraction.\n\nFunction Description: This asynchronous function retrieves subscribed TV channel information from a streaming service by:\n1. Scraping initial configuration data from a webpage\n2. Authenticating with the service using extracted credentials\n3. Fetching subscribed channel packages\n4. Processing and deduplicating channel information\n5. Returning formatted channel data\n\nInput: \n- lang: [String] (optional, default='id') - Language code for the returned channel data\n\nOutput: \n- Returns: [Array<Object>] - An array of channel objects containing:\n  - lang: [String] - The language code\n  - site_id: [String] - The channel ID\n  - name: [String] - The channel name\n- Throws: [Error] - If any HTTP request fails or data parsing fails",
    "Canonical_solution": "function async channels({ lang = 'id' }) {\n    const axios = require('axios')\n    const cheerio = require('cheerio')\n    const result = await axios\n      .get('https://cubmu.com/live-tv')\n      .then(response => response.data)\n      .catch(console.error)\n\n    const $ = cheerio.load(result)\n\n    const config = JSON.parse($('#__NEXT_DATA__').text()).runtimeConfig || {}\n\n    const options = {\n      headers: {\n        Origin: 'https://cubmu.com',\n        Referer: 'https://cubmu.com/live-tv'\n      }\n    }\n    await axios\n      .post(\n        `https://servicebuss.transvision.co.id/tvs/login/external?email=${config.email}&password=${config.password}&deviceId=${config.deviceId}&deviceType=${config.deviceType}&deviceModel=${config.deviceModel}&deviceToken=&serial=&platformId=${config.platformId}`,\n        options\n      )\n      .then(response => response.data)\n      .catch(console.error)\n    const subscribedChannels = await axios\n      .post(\n        `https://servicebuss.transvision.co.id/tvs/subscribe_product/list?platformId=${config.platformId}`,\n        options\n      )\n      .then(response => response.data)\n      .catch(console.error)\n\n    const channels = []\n    const included = []\n    if (Array.isArray(subscribedChannels.channelPackageList)) {\n      subscribedChannels.channelPackageList.forEach(pkg => {\n        pkg.channelList.forEach(channel => {\n          if (included.indexOf(channel.id) < 0) {\n            included.push(channel.id)\n            channels.push({\n              lang,\n              site_id: channel.id,\n              name: channel.name\n            })\n          }\n        })\n      })\n    }\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\nimport { parse } from 'node-html-parser';\n\nasync function getSubscribedTVChannels(lang = 'id') {\n  const baseDomain = 'https://www.example-streaming-service.com';\n  const configUrl = `${baseDomain}/config.js`;\n  const authUrl = `${baseDomain}/api/authenticate`;\n  const packagesUrl = `${baseDomain}/api/channel-packages`;\n\n  try {\n    const configResponse = await axios.get(configUrl);\n    const configText = configResponse.data;\n\n    const usernameMatch = configText.match(/username:\\s*'([^']+)'/);\n    const passwordMatch = configText.match(/password:\\s*'([^']+)'/);\n\n    if (!usernameMatch || !passwordMatch) {\n      throw new Error('Failed to extract credentials from config');\n    }\n\n    const username = usernameMatch[1];\n    const password = passwordMatch[1];\n\n    const authResponse = await axios.post(authUrl, {\n      user: username,\n      pass: password\n    }, {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n\n    if (authResponse.status !== 200) {\n      throw new Error('Authentication failed');\n    }\n\n    const authToken = authResponse.data.token;\n\n    const packagesResponse = await axios.get(packagesUrl, {\n      headers: {\n        'Authorization': `Bearer ${authToken}`\n      }\n    });\n\n    if (packagesResponse.status !== 200) {\n      throw new Error('Failed to fetch channel packages');\n    }\n\n    const packageIds = packagesResponse.data.packages.map(pkg => pkg.id);\n\n    const allChannels = [];\n\n    for (const packageId of packageIds) {\n      const channelsUrl = `${baseDomain}/api/channels?package=${packageId}`;\n      const channelsResponse = await axios.get(channelsUrl, {\n        headers: {\n          'Authorization': `Bearer ${authToken}`\n        }\n      });\n\n      if (channelsResponse.status !== 200) {\n        throw new Error(`Failed to fetch channels for package ${packageId}`);\n      }\n\n      const channels = channelsResponse.data.channels;\n      allChannels.push(...channels);\n    }\n\n    const uniqueChannelsMap = new Map();\n    \n    allChannels.forEach(channel => {\n      if (!uniqueChannelsMap.has(channel.id)) {\n        uniqueChannelsMap.set(channel.id, {\n          lang: lang,\n          site_id: channel.id,\n          name: channel.name[lang] || channel.name['en'] || 'Unknown Channel'\n        });\n      }\n    });\n\n    return Array.from(uniqueChannelsMap.values());\n\n  } catch (error) {\n    if (error.response) {\n      throw new Error(`HTTP error! status: ${error.response.status}`);\n    } else if (error.request) {\n      throw new Error('No response received from server');\n    } else {\n      throw new Error(`Error: ${error.message}`);\n    }\n  }\n}"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript to handle real-time bidirectional communication between clients and the server.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io. It sets up event listeners for client connections, messages, and disconnections. The server broadcasts received messages to all connected clients.\n\nInput:\n- `port` (Number): The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:\n- Returns the `socketServer` instance (Object) which can be used to further configure or interact with the WebSocket server.\n\nNote: The function internally uses the `http` module to create an HTTP server and binds socket.io to it for WebSocket communication. The server logs connection, message, and disconnection events to the console.",
    "Canonical_solution": "const http = require(\"http\");\nconst socketIo = require(\"socket.io\");\n\nfunction setupWebSocketServer(port) {\n    const app = express();\n    const webServer = http.createServer(app);\n    const socketServer = socketIo(webServer, {\"log level\": 1});\n\n    socketServer.on(\"connection\", (socket) => {\n        console.log(\"New client connected\");\n\n        socket.on(\"message\", (data) => {\n            console.log(\"Message received: \", data);\n            socketServer.emit(\"message\", data);\n        });\n\n        socket.on(\"disconnect\", () => {\n            console.log(\"Client disconnected\");\n        });\n    });\n\n    webServer.listen(port, () => {\n        console.log(\"WebSocket server listening on port: \" + port);\n    });\n\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "const http = require('http');\nconst express = require('express');\nconst { app, server } = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n    const app = express();\n    const httpServer = http.createServer(app);\n    const io = new Server(httpServer, {\n        cors: {\n            origin: \"*\",\n            methods: [\"GET\", \"POST\"]\n        }\n    });\n\n    io.on('connection', (socket) => {\n        console.log('A client connected');\n\n        socket.on('message', (data) => {\n            console.log('Message received:', data);\n            io.emit('response', `Server received: ${data}`);\n        });\n\n        socket.on('disconnect', () => {\n            console.log('A client disconnected');\n        });\n    });\n\n    httpServer.listen(port, () => {\n        console.log(`WebSocket server is running on port ${port}`);\n    });\n\n    return io;\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const getChannels = async function () {\n    const response = await axios.get(this.url());\n    const $ = cheerio.load(response.data);\n    const channels = [];\n\n    $('.channel-list .channel').each((index, element) => {\n        const lang = $(element).find('.lang').text().trim();\n        const site_id = $(element).find('.site-id').text().trim();\n        const name = $(element).find('.name').text().trim();\n\n        if (lang && site_id && name) {\n            channels.push({ lang, site_id, name });\n        }\n    });\n\n    return channels;\n};"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const https = require('https');\nconst installTelemetry = () => {\n    if (process.env.TUNNELMOLE_TELEMETRY !== 'true') return;\n    const data = JSON.stringify({\n        nodeVersion: process.versions.node,\n        platform: process.platform\n    });\n    const options = {\n        hostname: 'telemetry.example.com',\n        port: 443,\n        path: '/api/v1/install',\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Content-Length': data.length\n        }\n    };\n    const req = https.request(options, (res) => {\n        res.on('data', () => {});\n    });\n    req.on('error', () => {});\n    req.write(data);\n    req.end();\n};"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class SauceLabsClient {\n  constructor() {\n    this.auth = {};\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.username = saucelabsUsername;\n    this.auth.accessToken = saucelabsToken;\n  }\n\n  get(path, callback) {\n    const options = {\n      method: 'GET',\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(`${this.auth.username}:${this.auth.accessToken}`).toString('base64'),\n        'Content-Type': 'application/json'\n      }\n    };\n\n    fetch(`https://saucelabs.com/rest/v1/${path}`, options)\n      .then(response => response.json())\n      .then(data => callback(null, data))\n      .catch(error => callback(error, null));\n  }\n\n  post(path, data, callback) {\n    const options = {\n      method: 'POST',\n      headers: {\n        'Authorization': 'Basic ' + Buffer.from(`${this.auth.username}:${this.auth.accessToken}`).toString('base64'),\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    };\n\n    fetch(`https://saucelabs.com/rest/v1/${path}`, options)\n      .then(response => response.json())\n      .then(result => callback(null, result))\n      .catch(error => callback(error, null));\n  }\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Write a function that retrieves TV channel information from multiple regions, processes the data, and returns a unique list of channels based on their site IDs.\n\nFunction Description: The function `channels` makes HTTP GET requests to a TV channel API for multiple regions, collects channel data from all available pages for each region, and returns a deduplicated list of channels. It uses axios for HTTP requests and lodash for data processing.\n\nInput: None (The function uses hardcoded region IDs internally)\n\nOutput: An array of objects representing unique TV channels, where each object contains:\n- lang: string - Language code ('ru' for Russian)\n- name: string - Name of the TV channel\n- site_id: string/number - Unique identifier for the channel on the site\n\nThe output is deduplicated based on the site_id field using lodash's uniqBy function.",
    "Canonical_solution": "async function channels() {\n    const _ = require('lodash')\n    const axios = require('axios')\n\n    const regions = [5506, 1096, 1125, 285]\n    let channels = []\n    for (let region of regions) {\n        const totalPages = await getTotalPageCount(region)\n        const pages = Array.from(Array(totalPages).keys())\n        for (let page of pages) {\n            const data = await axios\n                .get('https://tv.mail.ru/ajax/channel/list/', {\n                    params: { page },\n                    headers: {\n                        cookie: `s=fver=0|geo=${region};`\n                    }\n                })\n                .then(r => r.data)\n                .catch(console.log)\n\n            data.channels.forEach(item => {\n                channels.push({\n                    lang: 'ru',\n                    name: item.name,\n                    site_id: item.id\n                })\n            })\n        }\n    }\n    return _.uniqBy(channels, 'site_id')\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\nimport _ from 'lodash';\n\nasync function channels() {\n    const regionIds = [1, 2, 3]; // Example hardcoded region IDs\n    const allChannels = [];\n\n    for (const regionId of regionIds) {\n        let page = 1;\n        let totalPages = 1;\n\n        while (page <= totalPages) {\n            try {\n                const response = await axios.get(`https://api.example.com/tv/channels`, {\n                    params: {\n                        region_id: regionId,\n                        page: page\n                    }\n                });\n\n                const data = response.data;\n\n                if (data.channels && Array.isArray(data.channels)) {\n                    allChannels.push(...data.channels.map(channel => ({\n                        lang: 'ru',\n                        name: channel.name,\n                        site_id: channel.site_id\n                    })));\n                }\n\n                totalPages = data.total_pages || totalPages;\n                page++;\n            } catch (error) {\n                console.error(`Error fetching data for region ${regionId}, page ${page}:`, error.message);\n                page++;\n            }\n        }\n    }\n\n    return _.uniqBy(allChannels, 'site_id');\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class BundleSizeAPI {\n  constructor({ repo, token, sha, ci }) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = \"https://bundlesize-store.now.sh/values\";\n    this.enabled = !!(this.repo && this.token);\n  }\n\n  async get() {\n    if (!this.enabled) return {};\n    try {\n      const cleanRepo = this.repo.replace(/\\./g, \"_\");\n      const response = await fetch(`${this.url}?repo=${encodeURIComponent(cleanRepo)}&sha=${encodeURIComponent(this.sha)}`, {\n        headers: { authorization: `Bearer ${this.token}` }\n      });\n      if (!response.ok) throw new Error(`GET failed with status ${response.status}`);\n      return await response.json();\n    } catch (error) {\n      console.error(\"Failed to retrieve bundle sizes:\", error.message);\n      return {};\n    }\n  }\n\n  async set(values) {\n    if (!this.enabled) return;\n    try {\n      const cleanRepo = this.repo.replace(/\\./g, \"_\");\n      const payload = { repo: cleanRepo, sha: this.sha, values };\n      const response = await fetch(this.url, {\n        method: \"POST\",\n        headers: {\n          authorization: `Bearer ${this.token}`,\n          \"content-type\": \"application/json\"\n        },\n        body: JSON.stringify(payload)\n      });\n      if (!response.ok) throw new Error(`SET failed with status ${response.status}`);\n    } catch (error) {\n      console.error(\"Failed to store bundle sizes:\", error.message);\n    }\n  }\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const https = require('https');\n\nfunction fetchCovidDataFromIsraelHealthAPI() {\n    const options = {\n        hostname: 'data.gov.il',\n        path: '/api/3/action/datastore_search',\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json'\n        }\n    };\n\n    const req = https.request(options, (res) => {\n        let data = '';\n\n        res.on('data', (chunk) => {\n            data += chunk;\n        });\n\n        res.on('end', () => {\n            try {\n                const parsedData = JSON.parse(data);\n                const result = parseData(parsedData);\n                console.log(result);\n            } catch (error) {\n                console.error('Error parsing or processing data:', error);\n            }\n        });\n    });\n\n    req.on('error', (error) => {\n        console.error('Request failed:', error);\n    });\n\n    req.end();\n\n    return null;\n}\n\nfunction parseData(data) {\n    if (!data || !data.result) {\n        return null;\n    }\n\n    const datasets = {\n        updates: [],\n        patientStats: [],\n        testResults: [],\n        demographics: {}\n    };\n\n    data.result.records.forEach(record => {\n        if (record.type === 'update') {\n            datasets.updates.push(record);\n        } else if (record.type === 'patient_stats') {\n            datasets.patientStats.push(record);\n        } else if (record.type === 'test_results') {\n            datasets.testResults.push(record);\n        } else if (record.type === 'demographics') {\n            datasets.demographics = { ...datasets.demographics, ...record };\n        }\n    });\n\n    return datasets;\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with optional path extension and error data, then triggers an activity callback based on the request's success or failure.\n\nFunction Description: The function `sendPing` is an asynchronous function that constructs a target URL by combining a base URL and an optional path, then sends an HTTP POST request using Axios. The request includes error data in the payload and a custom user-agent header. Depending on the request's outcome, it triggers a callback function (`triggerActivity`) with a success or failure indicator.\n\nInput:  \n- `url`: [String] - The base URL to which the request will be sent.  \n- `path`: [String] (optional) - An additional path segment to append to the base URL.  \n- `error`: [Any] - Data to be sent as the request payload (typically error information).  \n- `triggerActivity`: [Function] - A callback function to be executed after the request completes, receiving a boolean parameter indicating failure (true) or success (false/undefined).  \n\nOutput:  \n- None (The function's primary effect is the HTTP request and callback execution, not a direct return value).",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function sendPing(url, path, error, triggerActivity) {\n    if (url == null) return;\n    if (path) url += \"/\" + path;\n\n    await axios.post(url, error, {headers: {\"user-agent\": \"MySpeed/HealthAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "import axios from 'axios';\n\nconst sendPing = async (url, path = '', error = null, triggerActivity) => {\n  try {\n    const targetUrl = `${url}${path}`;\n    const response = await axios.post(targetUrl, error, {\n      headers: {\n        'User-Agent': 'Custom-User-Agent'\n      }\n    });\n    triggerActivity(false);\n  } catch (err) {\n    triggerActivity(true);\n  }\n};"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function fetchTVChannels() {\n  const url = 'https://api.example.com/tvchannels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: 'sq',\n      site_id: channel.id.toString(),\n      name: channel.display_name\n    }));\n  } catch (error) {\n    console.error('Failed to fetch TV channels:', error);\n    return [];\n  }\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class Tool {\n    constructor() {\n        this._node = null;\n        this._isSurge = typeof $httpClient !== \"undefined\";\n        this._isQuanX = typeof $task !== \"undefined\";\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = typeof $response !== \"undefined\";\n        \n        if (typeof module !== \"undefined\" && typeof require === \"function\") {\n            try {\n                this._node = {\n                    http: require(\"http\"),\n                    https: require(\"https\"),\n                    url: require(\"url\")\n                };\n            } catch (e) {\n                this._node = null;\n            }\n        }\n    }\n\n    notify(title, subtitle, message, option = {}) {\n        if (this._isSurge) {\n            $notification.post(title, subtitle, message, option);\n        } else if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (console) {\n            console.log(`NOTIFY: ${title}\\n${subtitle}\\n${message}`);\n        }\n    }\n\n    write(value, key) {\n        if (this._isSurge) {\n            return $persistentStore.write(value, key);\n        } else if (this._isQuanX) {\n            $prefs.setValueForKey(value, key);\n            return true;\n        } else if (typeof localStorage !== \"undefined\") {\n            localStorage.setItem(key, value);\n            return true;\n        }\n        return false;\n    }\n\n    read(key) {\n        if (this._isSurge) {\n            return $persistentStore.read(key);\n        } else if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (typeof localStorage !== \"undefined\") {\n            return localStorage.getItem(key);\n        }\n        return null;\n    }\n\n    get(options, callback) {\n        if (this._isSurge || this._isQuanX) {\n            const method = this._isSurge ? $httpClient.get : $task.httpRequest;\n            method.call(this._isSurge ? $httpClient : undefined, options, (response, data) => {\n                callback(data, this._status(response), response);\n            });\n        } else if (this._node) {\n            const parsedUrl = typeof options === \"string\" ? this._node.url.parse(options) : options;\n            const protocol = parsedUrl.protocol === \"https:\" ? this._node.https : this._node.http;\n            const req = protocol.get(parsedUrl, (res) => {\n                let body = \"\";\n                res.on(\"data\", chunk => body += chunk);\n                res.on(\"end\", () => {\n                    callback(body, this._status(res), res);\n                });\n            });\n            req.on(\"error\", error => callback(error));\n        }\n    }\n\n    post(options, callback) {\n        if (this._isSurge || this._isQuanX) {\n            const method = this._isSurge ? $httpClient.post : $task.httpRequest;\n            method.call(this._isSurge ? $httpClient : undefined, options, (response, data) => {\n                callback(data, this._status(response), response);\n            });\n        } else if (this._node) {\n            const parsedUrl = typeof options === \"string\" ? this._node.url.parse(options) : options;\n            const protocol = parsedUrl.protocol === \"https:\" ? this._node.https : this._node.http;\n            \n            const requestOptions = {\n                hostname: parsedUrl.hostname,\n                port: parsedUrl.port,\n                path: parsedUrl.path,\n                method: \"POST\",\n                headers: options.headers || {}\n            };\n\n            if (options.body) {\n                requestOptions.headers[\"Content-Length\"] = Buffer.byteLength(options.body);\n            }\n\n            const req = protocol.request(requestOptions, (res) => {\n                let body = \"\";\n                res.on(\"data\", chunk => body += chunk);\n                res.on(\"end\", () => {\n                    callback(body, this._status(res), res);\n                });\n            });\n\n            req.on(\"error\", error => callback(error));\n            \n            if (options.body) {\n                req.write(options.body);\n            }\n            req.end();\n        }\n    }\n\n    _status(response) {\n        if (!response) return { statusCode: -1 };\n        if (response.status) {\n            return { statusCode: response.status };\n        } else if (response.statusCode) {\n            return { statusCode: response.statusCode };\n        }\n        return { statusCode: 0 };\n    }\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const https = require('https');\nconst http = require('http');\nconst { Readable } = require('stream');\nconst { promisify } = require('util');\n\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type || null;\n    this.urlOpts = options || {};\n    this._size = null;\n    this._bufferPromise = null;\n  }\n\n  getBuffer(callback) {\n    if (this._bufferPromise) {\n      return this._bufferPromise.then(buffer => callback(null, buffer)).catch(err => callback(err));\n    }\n\n    const fetchBuffer = async () => {\n      return new Promise((resolve, reject) => {\n        const protocol = this.url.startsWith('https') ? https : http;\n        const req = protocol.get(this.url, this.urlOpts, res => {\n          if (res.statusCode !== 200) {\n            return reject(new Error(`HTTP status code ${res.statusCode}`));\n          }\n          if (!this._type && res.headers['content-type']) {\n            this._type = res.headers['content-type'];\n          }\n          let data = [];\n          res.on('data', chunk => data.push(chunk));\n          res.on('end', () => {\n            const buffer = Buffer.concat(data);\n            if (!this._size && res.headers['content-length']) {\n              this._size = parseInt(res.headers['content-length'], 10);\n            }\n            resolve(buffer);\n          });\n        });\n\n        req.on('error', reject);\n      });\n    };\n\n    this._bufferPromise = fetchBuffer();\n\n    this._bufferPromise\n      .then(buffer => callback(null, buffer))\n      .catch(err => callback(err));\n  }\n\n  getDataUri(callback) {\n    this.getBuffer((err, buffer) => {\n      if (err) return callback(err);\n      const mimeType = this.type() || 'application/octet-stream';\n      const base64 = buffer.toString('base64');\n      callback(null, `data:${mimeType};base64,${base64}`);\n    });\n  }\n\n  createReadStream() {\n    const self = this;\n    return new Readable({\n      read() {\n        self.getBuffer((err, buffer) => {\n          if (err) {\n            this.emit('error', err);\n            return;\n          }\n          this.push(buffer);\n          this.push(null);\n        });\n      }\n    });\n  }\n\n  size(callback) {\n    if (this._size !== null) {\n      return process.nextTick(() => callback(null, this._size));\n    }\n\n    const protocol = this.url.startsWith('https') ? https : http;\n    const req = protocol.get(this.url, this.urlOpts, res => {\n      if (res.statusCode !== 200) {\n        return callback(new Error(`HTTP status code ${res.statusCode}`));\n      }\n      if (!this._type && res.headers['content-type']) {\n        this._type = res.headers['content-type'];\n      }\n      const contentLength = res.headers['content-length'];\n      if (contentLength) {\n        this._size = parseInt(contentLength, 10);\n        callback(null, this._size);\n      } else {\n        // Fallback: download the buffer to get accurate size\n        let length = 0;\n        res.on('data', chunk => {\n          length += chunk.length;\n        });\n        res.on('end', () => {\n          this._size = length;\n          callback(null, this._size);\n        });\n      }\n    });\n\n    req.on('error', callback);\n  }\n\n  type() {\n    return this._type;\n  }\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "import axios from 'axios';\n\nasync function sendPostRequest() {\n  const url = 'https://example.com/api/endpoint';\n  const data = new URLSearchParams({\n    key1: 'value1',\n    key2: 'value2'\n  });\n\n  try {\n    const response = await axios.post(url, data, {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      withCredentials: true\n    });\n    console.log('Response:', response.data);\n  } catch (error) {\n    if (error.response) {\n      console.error('Server responded with status code:', error.response.status);\n      console.error('Response data:', error.response.data);\n    } else if (error.request) {\n      console.error('No response received:', error.request);\n    } else {\n      console.error('Error:', error.message);\n    }\n  }\n}\n\nsendPostRequest();"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a JavaScript class that handles AJAX requests using XMLHttpRequest, supporting cross-origin requests, custom headers, and various response handling scenarios.\n\nClass Description: The AjaxTransport class provides a wrapper around XMLHttpRequest for making asynchronous HTTP requests. It handles request creation, header management, response processing, and cleanup. The class supports CORS, maintains request state, and provides error handling capabilities.\n\nAttributes:\n\nxhrId: [Number] - Counter for generating unique IDs for each XMLHttpRequest instance\nxhrCallbacks: [Object] - Stores callback functions for active requests\nxhrSuccessStatus: [Object] - Maps certain HTTP status codes to standard success codes\nxhrSupported: [XMLHttpRequest|Boolean] - Stores the created XMLHttpRequest instance or false if not supported\n\nMethods:\n\ncreateXHR: () -> [XMLHttpRequest|undefined] - Creates and returns a new XMLHttpRequest instance or undefined if creation fails\n\nsendRequest: (options: Object, headers: Object, complete: Function) -> [undefined] - \n  Sends an AJAX request with the given configuration\n  options: Contains request parameters (type, url, async, etc.)\n  headers: Key-value pairs of request headers\n  complete: Callback function to handle response\n\nabortRequest: (callback: Function) -> [undefined] - \n  Aborts an active request and executes the given callback\n  callback: Function to execute after aborting\n\ngetTransport: (options: Object) -> [Object|undefined] - \n  Returns a transport object if the request can be handled\n  options: Configuration object for the request\n  Returns an object with send and abort methods or undefined if request can't be handled",
    "Canonical_solution": "var jQuery = require(\"../core\");\nvar support = require(\"../var/support\");\n\nclass AjaxTransport {\n  constructor() {\n    this.xhrId = 0;\n    this.xhrCallbacks = {};\n    this.xhrSuccessStatus = {\n      0: 200,\n      1223: 204\n    };\n    this.xhrSupported = this.createXHR();\n    \n    if (window.ActiveXObject) {\n      jQuery(window).on(\"unload\", () => {\n        for (var key in this.xhrCallbacks) {\n          this.xhrCallbacks[key]();\n        }\n      });\n    }\n    \n    support.cors = !!this.xhrSupported && (\"withCredentials\" in this.xhrSupported);\n    support.ajax = !!this.xhrSupported;\n  }\n\n  createXHR() {\n    try {\n      return new XMLHttpRequest();\n    } catch(e) {}\n  }\n\n  sendRequest(options, headers, complete) {\n    var xhr = options.xhr();\n    var id = ++this.xhrId;\n\n    xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n    if (options.xhrFields) {\n      for (var i in options.xhrFields) {\n        xhr[i] = options.xhrFields[i];\n      }\n    }\n\n    if (options.mimeType && xhr.overrideMimeType) {\n      xhr.overrideMimeType(options.mimeType);\n    }\n\n    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n      headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n    }\n\n    for (var i in headers) {\n      xhr.setRequestHeader(i, headers[i]);\n    }\n\n    var callback = (type) => {\n      return () => {\n        if (callback) {\n          delete this.xhrCallbacks[id];\n          callback = xhr.onload = xhr.onerror = null;\n\n          if (type === \"abort\") {\n            xhr.abort();\n          } else if (type === \"error\") {\n            complete(xhr.status, xhr.statusText);\n          } else {\n            complete(\n              this.xhrSuccessStatus[xhr.status] || xhr.status,\n              xhr.statusText,\n              typeof xhr.responseText === \"string\" ? { text: xhr.responseText } : undefined,\n              xhr.getAllResponseHeaders()\n            );\n          }\n        }\n      };\n    };\n\n    xhr.onload = callback();\n    xhr.onerror = callback(\"error\");\n    callback = this.xhrCallbacks[id] = callback(\"abort\");\n\n    try {\n      xhr.send(options.hasContent && options.data || null);\n    } catch (e) {\n      if (callback) {\n        throw e;\n      }\n    }\n  }\n\n  abortRequest(callback) {\n    if (callback) {\n      callback();\n    }\n  }\n\n  getTransport(options) {\n    if (support.cors || this.xhrSupported && !options.crossDomain) {\n      return {\n        send: (headers, complete) => this.sendRequest(options, headers, complete),\n        abort: () => this.abortRequest(callback)\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "var AjaxTransport = (function () {\n    'use strict';\n\n    function AjaxTransport() {\n        this.xhrId = 0;\n        this.xhrCallbacks = {};\n        this.xhrSuccessStatus = {\n            200: 200,\n            304: 304,\n            201: 201,\n            202: 202,\n            203: 203,\n            204: 204,\n            205: 205,\n            206: 206\n        };\n        this.xhrSupported = this.createXHR();\n    }\n\n    AjaxTransport.prototype.createXHR = function () {\n        var xhr;\n        try {\n            xhr = new XMLHttpRequest();\n            return xhr;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    AjaxTransport.prototype.sendRequest = function (options, headers, complete) {\n        if (!this.xhrSupported) {\n            complete(new Error('XMLHttpRequest not supported'));\n            return;\n        }\n\n        var xhr = this.createXHR();\n        if (!xhr) {\n            complete(new Error('Failed to create XMLHttpRequest'));\n            return;\n        }\n\n        var id = ++this.xhrId;\n        this.xhrCallbacks[id] = xhr;\n\n        var self = this;\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                delete self.xhrCallbacks[id];\n\n                var isSuccess = xhr.status in self.xhrSuccessStatus;\n                var statusText = isSuccess ? 'success' : 'error';\n                var response = {\n                    status: xhr.status,\n                    statusText: xhr.statusText,\n                    responseText: xhr.responseText,\n                    responseXML: xhr.responseXML\n                };\n\n                try {\n                    response.getResponseHeader = function (header) {\n                        return xhr.getResponseHeader(header);\n                    };\n                } catch (e) {\n                    response.getResponseHeader = null;\n                }\n\n                if (isSuccess) {\n                    if (typeof complete === 'function') {\n                        complete(null, response);\n                    }\n                } else {\n                    if (typeof complete === 'function') {\n                        complete(new Error('Request failed with status: ' + xhr.status), response);\n                    }\n                }\n            }\n        };\n\n        try {\n            xhr.open(options.type || 'GET', options.url, options.async !== false);\n\n            for (var header in headers) {\n                if (headers.hasOwnProperty(header)) {\n                    xhr.setRequestHeader(header, headers[header]);\n                }\n            }\n\n            if (options.withCredentials !== undefined) {\n                xhr.withCredentials = !!options.withCredentials;\n            }\n\n            xhr.send(options.data || null);\n        } catch (err) {\n            if (typeof complete === 'function') {\n                complete(err);\n            }\n        }\n    };\n\n    AjaxTransport.prototype.abortRequest = function (callback) {\n        for (var id in this.xhrCallbacks) {\n            if (this.xhrCallbacks.hasOwnProperty(id)) {\n                var xhr = this.xhrCallbacks[id];\n                xhr.abort();\n                delete this.xhrCallbacks[id];\n            }\n        }\n\n        if (typeof callback === 'function') {\n            callback();\n        }\n    };\n\n    AjaxTransport.prototype.getTransport = function (options) {\n        var self = this;\n        return {\n            send: function (headers, complete) {\n                self.sendRequest(options, headers, complete);\n            },\n            abort: function (callback) {\n                self.abortRequest(callback);\n            }\n        };\n    };\n\n    return AjaxTransport;\n})();"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function run_test(data, sender) {\n    if (data === 'xhr') {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://example.com/data', true);\n        xhr.onload = function () {\n            if (xhr.status === 200) {\n                sender.postMessage(xhr.responseText);\n            } else {\n                sender.postMessage('XHR Error: ' + xhr.statusText);\n            }\n        };\n        xhr.onerror = function () {\n            sender.postMessage('XHR Network Error');\n        };\n        xhr.send();\n    } else if (data === 'fetch') {\n        fetch('https://example.com/data')\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error('Fetch failed with status ' + response.status);\n                }\n                return response.text();\n            })\n            .then(text => {\n                sender.postMessage(text);\n            })\n            .catch(error => {\n                sender.postMessage('Fetch Error: ' + error.message);\n            });\n    } else if (data === 'importScripts') {\n        importScripts('test_script.js');\n        sender.postMessage(SCRIPT_MESSAGE); // Assuming SCRIPT_MESSAGE is defined in test_script.js\n    } else {\n        sender.postMessage('Unexpected message');\n    }\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "async function loadYamlUrl(url) {\n    try {\n        const response = await fetch(url);\n        if (response.status === 200) {\n            const yamlText = await response.text();\n            console.log('Response:', yamlText);\n            yamlToForm(yamlText);\n        } else {\n            console.error(`Failed to load YAML: HTTP status ${response.status}`);\n        }\n    } catch (error) {\n        console.error('Error fetching YAML:', error);\n    }\n}"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': 'isgd',\n      'goo.gl': 'googl',\n      'budurl.com': 'budurl',\n      'snipurl.com': 'snipurl'\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: (url, callback) => {\n        const apiURL = `https://is.gd/forward.php?shorturl=${encodeURIComponent(url)}&format=json`;\n        fetch(apiURL, { method: 'GET', timeout: this.timeout })\n          .then(response => response.json())\n          .then(data => callback(null, data.url))\n          .catch(err => callback(err));\n      },\n      googl: (url, callback) => {\n        const apiURL = 'https://www.googleapis.com/urlshortener/v1/url';\n        fetch(`${apiURL}?shortUrl=${encodeURIComponent(url)}&key=YOUR_API_KEY`, { method: 'GET', timeout: this.timeout })\n          .then(response => response.json())\n          .then(data => callback(null, data.longUrl))\n          .catch(err => callback(err));\n      },\n      default: (url, callback) => {\n        fetch(url, { method: 'HEAD', follow: 1, timeout: this.timeout })\n          .then(response => callback(null, response.url))\n          .catch(err => callback(err));\n      }\n    };\n  }\n\n  expand(args, callback) {\n    const { url, depth = 0, seen = {} } = args;\n\n    if (seen[url]) {\n      return callback({ err: new Error('Cycle detected'), ...args });\n    }\n\n    seen[url] = true;\n\n    const hostname = new URL(url).hostname;\n    const service = this.map[hostname] || 'default';\n\n    this.APIs[service](url, (err, expandedURL) => {\n      if (err) {\n        return callback({ err, url, depth, seen });\n      }\n\n      if (expandedURL === url) {\n        return callback({ url: expandedURL, depth, seen });\n      }\n\n      const nextArgs = { url: expandedURL, depth: depth + 1, seen };\n      this.expand(nextArgs, callback);\n    });\n  }\n}"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst multer = require('multer');\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.upload = multer({ dest: 'uploads/' });\n    this._configureMiddleware();\n  }\n\n  _configureMiddleware() {\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.server = this.app.listen(this.port, () => {\n          resolve(`Server running on port ${this.port}`);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method.toLowerCase()](path, handler);\n  }\n\n  get(path, handler) {\n    this.app.get(path, handler);\n  }\n\n  post(path, handler) {\n    this.app.post(path, this.upload.single('file'), handler);\n  }\n\n  put(path, handler) {\n    this.app.put(path, this.upload.single('file'), handler);\n  }\n\n  delete(path, handler) {\n    this.app.delete(path, handler);\n  }\n\n  patch(path, handler) {\n    this.app.patch(path, this.upload.single('file'), handler);\n  }\n\n  options(path, handler) {\n    this.app.options(path, handler);\n  }\n\n  trace(path, handler) {\n    this.app.trace(path, handler);\n  }\n\n  head(path, handler) {\n    this.app.head(path, handler);\n  }\n}"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    const url = `https://api.twitter.com${path}`;\n    const headers = {\n      Authorization: `Bearer ${this.config.bearerToken}`,\n      'Content-Type': 'application/json',\n    };\n\n    const reqOpts = {\n      url,\n      headers,\n      method,\n    };\n\n    if (method === 'GET' && params) {\n      const queryString = new URLSearchParams(params).toString();\n      reqOpts.url = `${url}?${queryString}`;\n    } else if (method === 'POST' && params) {\n      reqOpts.body = JSON.stringify(params);\n    }\n\n    return new Promise((resolve, reject) => {\n      this._doRestApiRequest(reqOpts, this.config, method, (err, resp, data) => {\n        if (err) {\n          reject(err);\n          callback(err, null, null);\n          return;\n        }\n        resolve({ resp, data });\n        callback(null, resp, data);\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, reqOpts.url, true);\n    for (const header in reqOpts.headers) {\n      xhr.setRequestHeader(header, reqOpts.headers[header]);\n    }\n\n    xhr.onload = () => {\n      this._updateClockOffsetFromResponse(xhr);\n      let data;\n      try {\n        data = JSON.parse(xhr.responseText);\n      } catch (e) {\n        callback(new Error('Failed to parse response JSON'), null, null);\n        return;\n      }\n\n      if (xhr.status >= 200 && xhr.status < 300) {\n        callback(null, xhr, data);\n      } else {\n        callback(new Error(`Request failed with status ${xhr.status}`), xhr, data);\n      }\n    };\n\n    xhr.onerror = () => {\n      callback(new Error('Network error'), null, null);\n    };\n\n    if (reqOpts.body) {\n      xhr.send(reqOpts.body);\n    } else {\n      xhr.send();\n    }\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const dateHeader = resp.getResponseHeader('Date');\n    if (dateHeader) {\n      const twitterTime = new Date(dateHeader).getTime();\n      const localTime = Date.now();\n      this._twitter_time_minus_local_time_ms = twitterTime - localTime;\n    }\n  }\n}"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class URLExpander {\n  constructor() {\n    this.map = {\n      isgd: ['is.gd', 'v.gd'],\n      googl: ['goo.gl', 'bit.ly'],\n      budurl: ['budurl.com'],\n      snipurl: ['snipurl.com']\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: (url, cb) => {\n        const apiUrl = `https://is.gd/forward.php?shorturl=${encodeURIComponent(url)}&format=json`;\n        fetch(apiUrl)\n          .then(res => res.json())\n          .then(json => {\n            if (json && json.url) {\n              cb(null, { url: json.url });\n            } else {\n              cb(new Error('Invalid response from is.gd'));\n            }\n          })\n          .catch(err => cb(err));\n      },\n      googl: (url, cb) => {\n        const apiUrl = `https://www.googleapis.com/urlshortener/v1/url?key=YOUR_API_KEY&id=${encodeURIComponent(url)}`;\n        fetch(apiUrl)\n          .then(res => res.json())\n          .then(json => {\n            if (json && json.longUrl) {\n              cb(null, { url: json.longUrl });\n            } else {\n              cb(new Error('Invalid response from goo.gl'));\n            }\n          })\n          .catch(err => cb(err));\n      },\n      budurl: (url, cb) => {\n        fetch(`http://budurl.com/api/expand?url=${encodeURIComponent(url)}`)\n          .then(res => res.text())\n          .then(text => {\n            if (text.startsWith('http')) {\n              cb(null, { url: text });\n            } else {\n              cb(new Error('Invalid response from budurl.com'));\n            }\n          })\n          .catch(err => cb(err));\n      },\n      snipurl: (url, cb) => {\n        fetch(`http://snipr.com/site/expandurl?url=${encodeURIComponent(url)}`)\n          .then(res => res.json())\n          .then(json => {\n            if (json && json.long_url) {\n              cb(null, { url: json.long_url });\n            } else {\n              cb(new Error('Invalid response from snipurl.com'));\n            }\n          })\n          .catch(err => cb(err));\n      },\n      generic: (url, cb) => {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n        \n        fetch(url, { method: 'HEAD', redirect: 'manual', signal: controller.signal })\n          .then(res => {\n            clearTimeout(timeoutId);\n            if (res.status >= 300 && res.status < 400 && res.headers.get('Location')) {\n              cb(null, { url: res.headers.get('Location'), headers: Object.fromEntries(res.headers) });\n            } else {\n              cb(null, { url });\n            }\n          })\n          .catch(err => {\n            clearTimeout(timeoutId);\n            cb(err);\n          });\n      }\n    };\n  }\n\n  expand(args, callback) {\n    args.depth = args.depth || 0;\n    args.seen = args.seen || {};\n    \n    if (args.seen[args.url]) {\n      return callback({ ...args, err: new Error('Cycle detected') });\n    }\n    \n    args.seen[args.url] = true;\n    \n    const domain = new URL(args.url).hostname;\n    let apiMethod = null;\n    \n    for (const service in this.map) {\n      if (this.map[service].includes(domain)) {\n        apiMethod = this.APIs[service];\n        break;\n      }\n    }\n    \n    if (!apiMethod) {\n      apiMethod = this.APIs.generic;\n    }\n    \n    apiMethod(args.url, (err, result) => {\n      if (err) {\n        return callback({ ...args, err });\n      }\n      \n      if (result.url !== args.url) {\n        if (args.depth >= 10) {\n          return callback({ ...args, err: new Error('Maximum recursion depth exceeded') });\n        }\n        \n        this.expand({\n          url: result.url,\n          depth: args.depth + 1,\n          seen: args.seen\n        }, callback);\n      } else {\n        callback({ ...args, ...result });\n      }\n    });\n  }\n}"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a function that sets up an Express server to serve static files and render a React component on the root route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures middleware to serve static files from a specified directory, defines a route handler for the root path that renders a React component to a string and sends it as an HTML response, and starts the server listening on port 3003.\n\nInput: None\n\nOutput: None (The function starts an Express server but does not return any value)",
    "Canonical_solution": "var express = require('express');\n\nfunction setupServer() {\n    var app = express();\n    app.use('/static', express.static('static'));\n    app.get('/', (req, res) => {\n        const rendered = ReactDOMServer.renderToString(<SimpleEditor />);\n        const page = `<!doctype html>\n<html>\n  <body>\n    <div id=\"react-content\">${ rendered }</div>\n    <script src=\"/static/bundle.js\"></script>\n  </body>\n</html>\n        `;\n        res.send(page);\n    });\n    app.listen(3003);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "import express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\n\nfunction setupServer() {\n  const app = express();\n  const PORT = 3003;\n\n  // Serve static files from the 'public' directory\n  app.use(express.static('public'));\n\n  // Root route handler that renders a React component\n  app.get('/', (req, res) => {\n    const App = () => <div>Hello from React!</div>;\n    const html = ReactDOMServer.renderToString(<App />);\n    res.send(`<!DOCTYPE html><html><body>${html}</body></html>`);\n  });\n\n  // Start the server\n  app.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n  });\n}\n\nsetupServer();"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "const request = require('request');\n\nfunction makeHttpRequest() {\n    const url = 'https://api.example.com/data';\n    const headers = {\n        'Authorization': 'Bearer YOUR_ACCESS_TOKEN',\n        'Accept-Encoding': 'gzip'\n    };\n\n    request.get({\n        url: url,\n        headers: headers,\n        encoding: null\n    }, (error, response, body) => {\n        if (error) {\n            console.error('Error making request:', error);\n            return;\n        }\n\n        if (response.statusCode === 200) {\n            const zlib = require('zlib');\n            zlib.gunzip(body, (err, dezippedBody) => {\n                if (err) {\n                    console.error('Error decompressing response:', err);\n                    return;\n                }\n                console.log('Response body:', dezippedBody.toString());\n            });\n        } else {\n            console.error('Unexpected status code:', response.statusCode);\n        }\n    });\n}\n\nmakeHttpRequest();"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst session = require('express-session');\nconst mongoose = require('mongoose');\nconst MongoStore = require('connect-mongo')(session);\nconst next = require('next');\n\nconst setupServer = async () => {\n  const dev = process.env.NODE_ENV !== 'production';\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  await app.prepare();\n\n  const server = express();\n\n  const mongoUrl = process.env.MONGO_URL_TEST;\n  const port = parseInt(process.env.PORT, 10) || 8000;\n  const sessionName = process.env.SESSION_NAME;\n  const sessionSecret = process.env.SESSION_SECRET;\n\n  mongoose.connect(mongoUrl, { useNewUrlParser: true, useUnifiedTopology: true });\n\n  const sessionStore = new MongoStore({\n    mongooseConnection: mongoose.connection,\n    collection: 'sessions',\n  });\n\n  server.use(\n    session({\n      name: sessionName,\n      secret: sessionSecret,\n      resave: false,\n      saveUninitialized: false,\n      store: sessionStore,\n      cookie: {\n        maxAge: 1000 * 60 * 60 * 24, // 1 day\n        httpOnly: true,\n        secure: !dev,\n        sameSite: 'strict',\n      },\n    })\n  );\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  await new Promise((resolve) => server.listen(port, resolve));\n  console.log(`> Ready on http://localhost:${port}`);\n};\n\nsetupServer();"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a function that initializes and configures an Express.js web application with middleware, route handlers, and server listening capabilities, including optional HTTPS support.\n\nFunction Description: The function `createExpressApp` creates and configures an Express.js application instance with various middleware (CORS, security headers, caching), route handlers for API endpoints and static files, and error handling. It starts an HTTP server (and optionally an HTTPS server) listening on specified ports. The function returns the configured Express application instance.\n\nInput: None (The function uses global configuration variables like CONFIG and process.env for settings)\n\nOutput: Express.Application - Returns the fully configured Express.js application instance after setting up all middleware, routes, and server listeners.",
    "Canonical_solution": "function createExpressApp() {\n    var express = require('express');\n    var app = express();\n\n    app.use(express.bodyParser());\n    app.set('view engine', 'ejs');\n\n    if (CONFIG.allowedOrigins) {\n        app.use(function(req, res, next) {\n            var origin = req.headers[\"origin\"];\n            if (origin) {\n                if (CONFIG.allowedOrigins.indexOf('*') > -1) {\n                    res.setHeader('Access-Control-Allow-Origin', '*');\n                } else {\n                    if (CONFIG.allowedOrigins.indexOf(origin) > -1) {\n                        res.setHeader('Access-Control-Allow-Origin', origin);\n                    }\n                }\n            }\n            next();\n        });\n    }\n\n    app.disable('x-powered-by');\n    app.use(function(req, res, next) {\n        res.setHeader('X-Powered-By', 'Iframely');\n        next();\n    });\n\n    app.use(sysUtils.cacheMiddleware);\n\n    require('./modules/api/views')(app);\n    require('./modules/debug/views')(app);\n    require('./modules/tests-ui/views')(app);\n\n    app.use(logErrors);\n    app.use(errorHandler);\n\n    app.get(CONFIG.relativeStaticUrl + '/*', function(req, res, next) {\n        var url = '/' + req.url.split('/').splice(2).join('/');\n        sysUtils.static(path.resolve(__dirname, 'static'), {path: url})(req, res, next);\n    });\n\n    app.get('/', function(req, res) {\n        res.writeHead(302, { Location: 'http://iframely.com'});\n        res.end();\n    });\n\n    var listener = app.listen(process.env.PORT || CONFIG.port, process.env.HOST || CONFIG.host, function(){\n        console.log('\\niframely is listening on ' + listener.address().address + ':' + listener.address().port + '\\n');\n    });\n\n    if (CONFIG.ssl) {\n        var options = { key: CONFIG.ssl.key, cert: CONFIG.ssl.cert };\n        require('https').createServer(options, app).listen(CONFIG.ssl.port);\n    }\n\n    return app;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst CONFIG = require('./config'); // Assuming config is in a local file\n\nfunction createExpressApp() {\n    const app = express();\n\n    // Middleware setup\n    app.use(cors(CONFIG.cors));\n    app.use(helmet(CONFIG.helmet));\n    app.use(express.json());\n    app.use(express.urlencoded({ extended: true }));\n    if (CONFIG.cacheControl) {\n        app.use((req, res, next) => {\n            res.header('Cache-Control', CONFIG.cacheControl);\n            next();\n        });\n    }\n\n    // Route handlers\n    if (CONFIG.routes && typeof CONFIG.routes === 'object') {\n        Object.entries(CONFIG.routes).forEach(([path, handler]) => {\n            if (typeof handler === 'function') {\n                app.use(path, handler);\n            }\n        });\n    }\n\n    // Static files serving\n    if (CONFIG.staticPath) {\n        app.use(express.static(CONFIG.staticPath));\n    }\n\n    // Error handling middleware\n    app.use((err, req, res, next) => {\n        console.error(err.stack);\n        res.status(500).send(CONFIG.production ? 'Something went wrong!' : err.message);\n    });\n\n    // HTTP server\n    const server = http.createServer(app);\n    server.listen(CONFIG.httpPort, () => {\n        console.log(`HTTP server running on port ${CONFIG.httpPort}`);\n    });\n\n    // HTTPS server if enabled\n    if (CONFIG.httpsEnabled && CONFIG.httpsPort && CONFIG.sslKeyPath && CONFIG.sslCertPath) {\n        try {\n            const sslOptions = {\n                key: fs.readFileSync(CONFIG.sslKeyPath),\n                cert: fs.readFileSync(CONFIG.sslCertPath)\n            };\n            const httpsServer = https.createServer(sslOptions, app);\n            httpsServer.listen(CONFIG.httpsPort, () => {\n                console.log(`HTTPS server running on port ${CONFIG.httpsPort}`);\n            });\n        } catch (error) {\n            console.error('Failed to start HTTPS server:', error.message);\n        }\n    }\n\n    return app;\n}\n\nmodule.exports = createExpressApp;"
  }
]