[
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const http = require('http');\nconst https = require('https');\nconst url = require('url');\n\nclass URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': 'isgd',\n      'goo.gl': 'googl',\n      'budurl.com': 'budurl',\n      'snipurl.com': 'snipurl',\n      'snipr.com': 'snipurl',\n      'sn.im': 'snipurl',\n      'snurl.com': 'snipurl'\n    };\n    this.timeout = 5000;\n  }\n\n  expand(args, callback) {\n    if (!args.url) return callback(new Error('URL is required'));\n    args.depth = args.depth || 0;\n    args.seen = args.seen || {};\n\n    if (args.seen[args.url]) return callback(new Error('URL loop detected'));\n    if (args.depth > 10) return callback(new Error('Maximum depth exceeded'));\n\n    args.seen[args.url] = true;\n\n    const parsed = url.parse(args.url);\n    const domain = parsed.hostname;\n    const service = this.map[domain];\n\n    if (service && this.APIs[service]) {\n      this.APIs[service](args, (err, result) => {\n        if (err) return this.APIs.generic(args, callback);\n        callback(null, result);\n      });\n    } else {\n      this.APIs.generic(args, callback);\n    }\n  }\n\n  APIs = {\n    isgd: (args, callback) => {\n      const apiUrl = `https://is.gd/forward.php?format=json&shorturl=${encodeURIComponent(args.url)}`;\n      this._makeRequest(apiUrl, (err, data) => {\n        if (err) return callback(err);\n        try {\n          const result = JSON.parse(data);\n          if (result.errorcode) return callback(new Error(result.errormessage));\n          args.url = result.url;\n          this.expand(args, callback);\n        } catch (e) {\n          callback(e);\n        }\n      });\n    },\n\n    googl: (args, callback) => {\n      const apiUrl = `https://www.googleapis.com/urlshortener/v1/url?shortUrl=${encodeURIComponent(args.url)}`;\n      this._makeRequest(apiUrl, (err, data) => {\n        if (err) return callback(err);\n        try {\n          const result = JSON.parse(data);\n          if (result.error) return callback(new Error(result.error.message));\n          args.url = result.longUrl;\n          this.expand(args, callback);\n        } catch (e) {\n          callback(e);\n        }\n      });\n    },\n\n    budurl: (args, callback) => {\n      const apiUrl = `http://api.budurl.com/v1/expand?url=${encodeURIComponent(args.url)}`;\n      this._makeRequest(apiUrl, (err, data) => {\n        if (err) return callback(err);\n        try {\n          const result = JSON.parse(data);\n          if (result.error) return callback(new Error(result.error));\n          args.url = result.long_url;\n          this.expand(args, callback);\n        } catch (e) {\n          callback(e);\n        }\n      });\n    },\n\n    snipurl: (args, callback) => {\n      const apiUrl = `http://snipurl.com/site/getsnip?url=${encodeURIComponent(args.url)}`;\n      this._makeRequest(apiUrl, (err, data) => {\n        if (err) return callback(err);\n        try {\n          const result = JSON.parse(data);\n          if (result.error) return callback(new Error(result.error));\n          args.url = result.longurl;\n          this.expand(args, callback);\n        } catch (e) {\n          callback(e);\n        }\n      });\n    },\n\n    generic: (args, callback) => {\n      const options = {\n        method: 'HEAD',\n        timeout: this.timeout,\n        followRedirect: false\n      };\n\n      const req = (args.url.startsWith('https') ? https : http).request(args.url, options, (res) => {\n        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n          args.url = res.headers.location;\n          args.depth++;\n          this.expand(args, callback);\n        } else {\n          callback(null, args);\n        }\n      });\n\n      req.on('error', callback);\n      req.on('timeout', () => {\n        req.destroy();\n        callback(new Error('Request timeout'));\n      });\n      req.end();\n    }\n  };\n\n  _makeRequest(url, callback) {\n    const req = (url.startsWith('https') ? https : http).get(url, (res) => {\n      if (res.statusCode !== 200) {\n        return callback(new Error(`HTTP ${res.statusCode}`));\n      }\n      let data = '';\n      res.on('data', (chunk) => data += chunk);\n      res.on('end', () => callback(null, data));\n    });\n\n    req.on('error', callback);\n    req.on('timeout', () => {\n      req.destroy();\n      callback(new Error('Request timeout'));\n    });\n    req.setTimeout(this.timeout);\n  }\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create a function to set up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB as the session store. It integrates Next.js for server-side rendering and sets up a catch-all route handler. The server listens on a specified port and connects to MongoDB using environment variables for configuration.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that:\n- Listens on the specified port\n- Outputs the server URL to console when ready\n- Maintains persistent connections to MongoDB for session storage)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  mongoose.connect(MONGO_URL);\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  const server = express();\n\n  const sessionOptions = {\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    store: mongoSessionStore.create({\n      mongoUrl: MONGO_URL,\n      ttl: 14 * 24 * 60 * 60,\n    }),\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      httpOnly: true,\n      maxAge: 14 * 24 * 60 * 60 * 1000,\n      domain: 'localhost',\n    },\n  };\n\n  const sessionMiddleware = session(sessionOptions);\n  server.use(sessionMiddleware);\n\n  server.get('*', (req, res) => handle(req, res));\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on ${ROOT_URL}`);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst session = require('express-session');\nconst MongoStore = require('connect-mongo');\nconst next = require('next');\n\nconst setupServer = async () => {\n  const dev = process.env.NODE_ENV !== 'production';\n  const port = process.env.PORT || 8000;\n  const mongoUrl = process.env.MONGO_URL_TEST;\n  const sessionName = process.env.SESSION_NAME || 'sid';\n  const sessionSecret = process.env.SESSION_SECRET || 'secret';\n\n  const nextApp = next({ dev });\n  const handle = nextApp.getRequestHandler();\n\n  await nextApp.prepare();\n\n  const app = express();\n\n  app.use(session({\n    name: sessionName,\n    secret: sessionSecret,\n    resave: false,\n    saveUninitialized: false,\n    store: MongoStore.create({\n      mongoUrl,\n      ttl: 14 * 24 * 60 * 60\n    }),\n    cookie: {\n      httpOnly: true,\n      secure: !dev,\n      maxAge: 1000 * 60 * 60 * 24 * 14\n    }\n  }));\n\n  app.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  app.listen(port, () => {\n    console.log(`Server ready on http://localhost:${port}`);\n  });\n};\n\nsetupServer();"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a function that sets up and starts an HTTP server using the Express framework in JavaScript, with middleware configurations for request processing and static file serving.\n\nFunction Description: The function `createServer` initializes an Express application, configures various middleware for logging, request parsing, and static file serving, and starts an HTTP server listening on a specified port. It also includes environment-specific error handling for development mode.\n\nInput: None (The function does not take any parameters; it uses environment variables like `process.env.PORT` for configuration.)\n\nOutput: None (The function does not return any value; it starts an HTTP server that listens on the specified port and logs a message upon successful startup.)",
    "Canonical_solution": "function createServer() {\n    var express = require('express');\n    var http = require('http');\n    var path = require('path');\n\n    var app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.favicon());\n    app.use(express.logger('dev'));\n    app.use(express.json());\n    app.use(express.urlencoded());\n    app.use(express.methodOverride());\n    app.use(express.static(path.join(__dirname, '/public')));\n    app.use(express.static(path.join(__dirname, '/tests')));\n\n    if ('development' == app.get('env')) {\n        app.use(express.errorHandler());\n    }\n\n    http.createServer(app).listen(app.get('port'), function(){\n        console.log('Express server listening on port ' + app.get('port'));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst morgan = require('morgan');\nconst path = require('path');\n\nfunction createServer() {\n  const app = express();\n  const port = process.env.PORT || 3000;\n\n  app.use(morgan('dev'));\n  app.use(express.json());\n  app.use(express.urlencoded({ extended: true }));\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.use((err, req, res, next) => {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(err.stack);\n    }\n    res.status(500).send('Something broke!');\n  });\n\n  const server = app.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n\n  return server;\n}\n\ncreateServer();"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a function that sets up an Express server with middleware configuration, route handling, and server initialization.\n\nFunction Description: The function `setupExpressServer` initializes an Express.js web server with essential middleware (CORS, static file serving, JSON body parsing), configures route handlers, and starts listening on a specified port. It handles both API routes and serves static HTML files.\n\nInput: None (The function uses imported modules and configuration from './src/config' and './src/routes')\n\nOutput: None (The function's side effect is starting an HTTP server that listens on the configured port)",
    "Canonical_solution": "function setupExpressServer() {\n    const bodyParser = require('body-parser');\n    const express = require('express');\n    const path = require('path');\n    const cors = require('cors');\n    const config = require('./src/config');\n    const routes = require('./src/routes');\n\n    const app = express();\n\n    app.enable('trust proxy');\n    app.use(cors());\n    app.use(express.static(path.join(__dirname, 'www')));\n    app.use(bodyParser.json());\n\n    app.get('/v2', (req, res) => res.sendFile(path.join(__dirname, 'www/index.html')));\n    app.use(routes);\n\n    app.listen(config.PORT, err => {\n        if (err) console.error(err);\n        console.log('Server started on ' + config.PORT);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst config = require('./src/config');\nconst routes = require('./src/routes');\n\nfunction setupExpressServer() {\n  const app = express();\n\n  app.use(cors());\n  app.use(express.json());\n  app.use(express.static(path.join(__dirname, 'public')));\n\n  app.use('/api', routes.api);\n  app.use('/', routes.static);\n\n  const port = config.port || 3000;\n  app.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n}\n\nsetupExpressServer();"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a target API while modifying request and response headers.\n\nFunction Description: The function `createProxyServer` initializes an Express application that acts as a proxy server. It configures middleware to forward all incoming requests to a specified target API (https://api.openai.com in this case), removes certain headers from outgoing requests, and adds CORS headers to responses. The server listens on port 9000 by default.\n\nInput: None (The function takes no parameters as all configurations are hardcoded)\n\nOutput: None (The function doesn't return anything but starts a server process that continues running)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('http-proxy-middleware');\n    const app = express();\n    const port = 9000;\n\n    app.use('/', createProxyMiddleware({\n        target: 'https://api.openai.com',\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('x-forwarded-for');\n            proxyReq.removeHeader('x-real-ip');\n        },\n        onProxyRes: function (proxyRes, req, res) {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n        }\n    }));\n\n    app.listen(port, () => {\n        console.log(`Example app listening at http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nfunction createProxyServer() {\n    const app = express();\n    const target = 'https://api.openai.com';\n\n    const proxyOptions = {\n        target,\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('x-forwarded-for');\n            proxyReq.removeHeader('x-real-ip');\n        },\n        onProxyRes: (proxyRes, req, res) => {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n            proxyRes.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';\n            proxyRes.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';\n        }\n    };\n\n    app.use('/', createProxyMiddleware(proxyOptions));\n    app.listen(9000);\n}\n\ncreateProxyServer();"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst mkdir = promisify(fs.mkdir);\n\nclass TSClient {\n  constructor(query, cb) {\n    this.id = crypto.createHash('md5').update(query).digest('hex');\n    this.search = {\n      q: query,\n      since_id: null,\n      rcount: 0,\n      id: this.id\n    };\n    this.new_since_id = null;\n\n    const statePath = path.join(__dirname, 'state', `${this.id}.json`);\n    readFile(statePath, 'utf8')\n      .then(data => {\n        this.search = JSON.parse(data);\n        cb(this);\n      })\n      .catch(() => {\n        mkdir(path.join(__dirname, 'state'), { recursive: true })\n          .then(() => writeFile(statePath, JSON.stringify(this.search), 'utf8'))\n          .then(() => cb(this))\n          .catch(() => cb(this));\n      });\n  }\n\n  syncSearch(callback) {\n    const s = {\n      ts: this,\n      search: Object.assign({}, this.search),\n      cb: callback,\n      page: 1,\n      results: [],\n      new_since_id: null\n    };\n    this._walker(s);\n  }\n\n  set(search) {\n    this.search = search;\n    const statePath = path.join(__dirname, 'state', `${this.id}.json`);\n    writeFile(statePath, JSON.stringify(this.search), 'utf8').catch(() => {});\n  }\n\n  _walker(s) {\n    const { ts, search, cb, page, results } = s;\n    const params = {\n      q: search.q,\n      count: 100,\n      page\n    };\n    if (search.since_id) {\n      params.since_id = search.since_id;\n    }\n\n    twitterClient.get('search/tweets', params, (err, data, response) => {\n      if (err) {\n        return cb(err);\n      }\n\n      const tweets = data.statuses;\n      if (!tweets || tweets.length === 0) {\n        if (s.new_since_id && s.new_since_id !== search.since_id) {\n          ts.search.since_id = s.new_since_id;\n          ts.search.rcount += results.length;\n          ts.set(ts.search);\n        }\n        return cb(null, results);\n      }\n\n      if (!s.new_since_id || tweets[0].id_str > s.new_since_id) {\n        s.new_since_id = tweets[0].id_str;\n      }\n\n      s.results = results.concat(tweets);\n      s.page += 1;\n      ts._walker(s);\n    });\n  }\n}"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst path = require('path');\nconst fs = require('fs');\n\nfunction createExpressServer() {\n  const app = express();\n  const port = process.env.PORT || 3000;\n  const staticDir = path.join(__dirname, '../public');\n\n  if (fs.existsSync(staticDir)) {\n    app.use(express.static(staticDir));\n  }\n\n  const routes = require('./routes');\n  app.use('/', routes);\n\n  const server = app.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n    console.log(`Serving static files from: ${staticDir}`);\n  });\n\n  return server;\n}\n\nmodule.exports = createExpressServer;"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to efficiently handle large files.\n\nFunction Description: The function `uploadFileViaPipe` streams a file from the local filesystem to an HTTP server using Node.js's built-in `fs` and `http` modules. It utilizes the pipe mechanism to efficiently transfer data without loading the entire file into memory, making it suitable for large files. The function assumes a predefined server port and file path.\n\nInput: \n- None (The function uses hardcoded values for demonstration purposes. In a real implementation, these would typically be parameters.)\n\nOutput: \n- None (The function performs a side effect of uploading a file. Success or failure would typically be handled via callbacks or events in a production implementation.)",
    "Canonical_solution": "function uploadFileViaPipe() {\n    var http = require('http');\n    var fs = require('fs');\n    var path = require('path');\n    \n    var testFilePath = path.join(__dirname, '../fixture/file/binaryfile.tar.gz');\n    var port = common.port;\n\n    var request = http.request({\n        port: port,\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    });\n\n    fs.createReadStream(testFilePath).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "const fs = require('fs');\nconst http = require('http');\n\nfunction uploadFileViaPipe() {\n    const filePath = './largefile.dat';\n    const options = {\n        hostname: 'localhost',\n        port: 3000,\n        path: '/upload',\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/octet-stream'\n        }\n    };\n\n    const req = http.request(options, (res) => {\n        res.on('data', (chunk) => {});\n        res.on('end', () => {});\n    });\n\n    req.on('error', (e) => {});\n\n    const fileStream = fs.createReadStream(filePath);\n    fileStream.pipe(req);\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "const request = require('request');\n\nfunction makeHttpRequest() {\n    const url = 'https://example.com/api';\n    const headers = {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer token123'\n    };\n    const data = {\n        key1: 'value1',\n        key2: 'value2'\n    };\n\n    request.post({\n        url: url,\n        headers: headers,\n        json: data\n    }, function(error, response, body) {\n        if (error) {\n            console.error('Error:', error);\n            return;\n        }\n        console.log('Response:', body);\n    });\n}"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to generate PDFs from HTML templates and serve them as streams.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. It serves PDF files generated from an HTML template, replacing placeholders with actual image paths, and streams the PDF output to the client. The server handles incoming requests, checks for favicon requests, and responds with either a 404 error or the generated PDF.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 8080 and logs the server address to the console.)",
    "Canonical_solution": "function createServer() {\n    const fs = require('fs');\n    const http = require('http');\n    const pdf = require('../../');\n    const tmpl = fs.readFileSync(require.resolve('../businesscard/businesscard.html'), 'utf8');\n\n    const server = http.createServer(function (req, res) {\n        if (req.url === '/favicon.ico') return res.end('404');\n        const html = tmpl.replace('{{image}}', `file://${require.resolve('../businesscard/image.png')}`);\n        pdf.create(html, {width: '50mm', height: '90mm'}).toStream((err, stream) => {\n            if (err) return res.end(err.stack);\n            res.setHeader('Content-type', 'application/pdf');\n            stream.pipe(res);\n        });\n    });\n\n    server.listen(8080, function (err) {\n        if (err) throw err;\n        console.log('Listening on http://localhost:%s', server.address().port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst { PDFDocument } = require('pdf-lib');\nconst puppeteer = require('puppeteer');\n\nconst createServer = () => {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/favicon.ico') {\n      res.writeHead(404);\n      res.end();\n      return;\n    }\n\n    try {\n      const templatePath = path.join(__dirname, 'template.html');\n      const template = fs.readFileSync(templatePath, 'utf8');\n      const html = template.replace('{{image}}', 'https://example.com/image.jpg');\n\n      const browser = await puppeteer.launch();\n      const page = await browser.newPage();\n      await page.setContent(html);\n      const pdfBuffer = await page.pdf({ format: 'A4' });\n      await browser.close();\n\n      res.writeHead(200, {\n        'Content-Type': 'application/pdf',\n        'Content-Disposition': 'attachment; filename=generated.pdf'\n      });\n      res.end(pdfBuffer);\n    } catch (error) {\n      res.writeHead(500);\n      res.end('Error generating PDF');\n    }\n  });\n\n  server.listen(8080, () => {\n    console.log('Server running at http://localhost:8080/');\n  });\n};\n\ncreateServer();"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a JavaScript function that sets up an HTTP server to serve an HTML file using Node.js's built-in modules (http and fs). The function should handle incoming requests by piping the file content directly to the response.\n\nFunction Description: The function creates an HTTP server that listens for incoming requests. When a request is received, it reads an HTML file from the specified path and pipes its content to the response object, setting the appropriate content-type header.\n\nInput: \n- __dirname (string): The directory path where the HTML file is located.\n- '/index.html' (string): The path to the HTML file to be served, relative to __dirname.\n\nOutput: \n- An HTTP server instance that serves the specified HTML file for all incoming requests. The server does not explicitly return a value but starts listening on a default port (typically 80 or a specified port).",
    "Canonical_solution": "var server = require('http').createServer(function incoming(req, res) {\n  res.setHeader('Content-Type', 'text/html');\n  require('fs').createReadStream(__dirname + '/index.html').pipe(res);\n});",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createServer(dirname, filePath) {\n    const server = http.createServer((req, res) => {\n        const fullPath = path.join(dirname, filePath);\n        fs.readFile(fullPath, (err, data) => {\n            if (err) {\n                res.writeHead(500);\n                res.end('Error loading the file');\n                return;\n            }\n            res.writeHead(200, { 'Content-Type': 'text/html' });\n            res.end(data);\n        });\n    });\n    return server;\n}"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a JavaScript class that implements a server capable of handling HTTP requests and piping data to responses, with support for live reload functionality and error handling.\n\nClass Description: The `Server` class is designed to create an HTTP server that can handle incoming requests, pipe data to responses (particularly for live reload functionality), and manage server lifecycle events. It supports both standalone operation and integration with existing Express-like applications.\n\nAttributes:\n- options: [Object] - Configuration options for the server including livereload file path and port number.\n- clients: [Object] - Storage for connected clients (used for live reload functionality).\n- server: [http.Server] - The underlying HTTP server instance.\n- app: [Object] - Optional Express-like application instance for integration.\n- port: [Number] - The port number the server is listening on.\n\nMethods:\n- constructor(options) -> [Server] - Initializes the server with given options, setting defaults for livereload path and port.\n- configure(app) -> [Server] - Configures the server to work with an existing Express-like application.\n- handler(req, res, next) -> [Server] - Handles incoming HTTP requests, supporting both middleware and direct handling modes.\n- livereload(req, res) -> [void] - Pipes the livereload JavaScript file to the response.\n- listen(port, fn) -> [void] - Starts the server listening on the specified port.\n- close(req, res) -> [void] - Closes the server and optionally ends a response.\n- error(e) -> [void] - Handles and logs server errors.\n\nNote: The class demonstrates inter-process communication through HTTP and file system operations, particularly in the `livereload` method where it pipes file contents directly to HTTP responses.",
    "Canonical_solution": "var fs = require('fs');\nvar http = require('http');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.options.livereload = this.options.livereload || path.join(__dirname, 'public/livereload.js');\n    this.options.port = parseInt(this.options.port || 35729, 10);\n    this.clients = {};\n    this.configure(this.options.app);\n  }\n\n  configure(app) {\n    if(!app) {\n      this.server = http.createServer(this.handler.bind(this));\n      this.server.on('error', this.error.bind(this));\n      return this;\n    }\n\n    var self = this;\n    this.app = app;\n\n    this.app.listen = function(port, done) {\n      done = done || function() {};\n      var srv = self.server = http.createServer(app);\n      srv.on('error', self.error.bind(self));\n      srv.on('close', self.close.bind(self));\n      return srv.listen(port, done);\n    };\n\n    return this;\n  }\n\n  handler(req, res, next) {\n    var middleware = typeof next === 'function';\n    if(middleware) {\n      this.handle(req, res, next);\n      return this;\n    }\n\n    req\n      .on('end', this.handle.bind(this, req, res))\n      .on('data', function(chunk) {\n        req.data = req.data || '';\n        req.data += chunk;\n      });\n\n    return this;\n  }\n\n  livereload(req, res) {\n    fs.createReadStream(this.options.livereload).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port;\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if(res) res.end();\n    if(this.server._handle) this.server.close();\n  }\n\n  error(e) {\n    console.error('Error:', e.message);\n    console.error(e.stack);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nclass Server {\n  constructor(options = {}) {\n    this.options = {\n      livereload: options.livereload || path.join(__dirname, 'livereload.js'),\n      port: options.port || 35729\n    };\n    this.clients = {};\n    this.server = null;\n    this.app = null;\n    this.port = null;\n  }\n\n  configure(app) {\n    this.app = app;\n    return this;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      if (req.url === '/livereload.js') {\n        this.livereload(req, res);\n      } else {\n        next();\n      }\n    } else {\n      if (req.url === '/livereload.js') {\n        this.livereload(req, res);\n      } else {\n        res.writeHead(404);\n        res.end();\n      }\n    }\n    return this;\n  }\n\n  livereload(req, res) {\n    const stream = fs.createReadStream(this.options.livereload);\n    stream.pipe(res);\n    stream.on('error', (e) => this.error(e));\n  }\n\n  listen(port, fn) {\n    this.port = port || this.options.port;\n    if (this.app) {\n      this.server = http.createServer(this.app);\n      this.app.use((req, res, next) => this.handler(req, res, next));\n    } else {\n      this.server = http.createServer((req, res) => this.handler(req, res, () => {}));\n    }\n    this.server.listen(this.port, fn);\n    this.server.on('error', (e) => this.error(e));\n    return this;\n  }\n\n  close(req, res) {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n    }\n    if (res) {\n      res.end();\n    }\n    return this;\n  }\n\n  error(e) {\n    if (e.code === 'EADDRINUSE') {\n      console.error(`Port ${this.port} is already in use`);\n    } else {\n      console.error(e);\n    }\n  }\n}"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files, using Node.js's built-in `http` and `fs` modules. The server should handle different MIME types and pipe file contents to the response stream.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens on port 5000. It serves static files from the local file system, automatically determining the appropriate MIME type based on the file extension. If a requested file doesn't exist, it logs a warning. The function uses streaming to efficiently pipe file contents to the HTTP response.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server)",
    "Canonical_solution": "function createServer() {\n  var http = require('http'), fs = require('fs'), mimeTypes = {\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpg'\n  };\n\n  http.createServer(function (req, res) {\n    var file = (req.url === '/') ? 'index.html' : \".\" + req.url;\n    var ext = require('path').extname(file),\n      type = (mimeTypes[ext] ? mimeTypes[ext] : '');\n\n    fs.exists(file, function (exists) {\n      if (exists) {\n        res.writeHead(200, {'Content-Type': type});\n        fs.createReadStream(file).pipe(res);\n      } else {\n        console.warn(file, ' does not exit');\n      }\n    });\n  }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst mimeTypes = {\n  '.html': 'text/html',\n  '.js': 'text/javascript',\n  '.css': 'text/css',\n  '.json': 'application/json',\n  '.png': 'image/png',\n  '.jpg': 'image/jpg',\n  '.gif': 'image/gif',\n  '.svg': 'image/svg+xml',\n  '.wav': 'audio/wav',\n  '.mp4': 'video/mp4',\n  '.woff': 'application/font-woff',\n  '.ttf': 'application/font-ttf',\n  '.eot': 'application/vnd.ms-fontobject',\n  '.otf': 'application/font-otf',\n  '.wasm': 'application/wasm'\n};\n\nfunction createServer() {\n  const server = http.createServer((req, res) => {\n    let filePath = path.join(__dirname, req.url === '/' ? 'index.html' : req.url);\n    const extname = path.extname(filePath);\n    const contentType = mimeTypes[extname] || 'application/octet-stream';\n\n    fs.readFile(filePath, (err, content) => {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          console.warn(`File not found: ${filePath}`);\n          res.writeHead(404);\n          res.end('404 Not Found');\n        } else {\n          res.writeHead(500);\n          res.end(`Server Error: ${err.code}`);\n        }\n      } else {\n        res.writeHead(200, { 'Content-Type': contentType });\n        res.end(content, 'utf-8');\n      }\n    });\n  });\n\n  server.listen(5000, () => {\n    console.log('Server running on port 5000');\n  });\n}\n\ncreateServer();"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files and handle dynamic JavaScript file concatenation, with support for piping binary files.\n\nFunction Description: The `createServer` function initializes an HTTP server that serves static files from specified directories, handles dynamic concatenation of JavaScript files, and pipes binary files directly to the response. It supports virtual paths, content type detection, and redirection.\n\nInput: \n- Optional command line argument [string] - The port number to listen on (defaults to 90 if not provided)\n\nOutput: \n- None (directly creates and starts an HTTP server)\n- Console output indicating server startup and loaded files\n\nAttributes: (N/A - This is a function, not a class)\n\nMethods: (N/A - This is a function, not a class)\n\nAdditional Implementation Details:\n1. Reads and caches static files from '../src' and '../dist' directories at startup\n2. Handles binary files separately from text files\n3. Supports special handling for core JavaScript files and plugins\n4. Implements virtual path redirection\n5. Uses file extension to determine content type\n6. Provides fallback behavior for undefined routes\n7. Listens on localhost (127.0.0.1) only\n8. Outputs loaded file list to console at startup",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require(\"fs\");\n    var url = require(\"url\");\n\n    var BASE_URL=\"http://www.servicestack.net\", \n        VIRTUAL_PATH=\"/jqbuilder\"; \n\n    var getExt = function(path) {\n        return path.substring(path.lastIndexOf('.')+1);\n    };\n    String.prototype.startsWith = function (str){\n        return this.indexOf(str) === 0;\n    };\n\n    var contentTypes = { \"htm\": \"text/html\", \"js\": \"text/javascript\", \"gif\": \"image/gif\" };\n\n    var srcDir = '../src', targetDir = '../dist';\n    var webFiles = fs.readdirSync(targetDir);\n    var staticFiles = {}, binaryFiles = {};\n    fs.readdirSync(srcDir).forEach(function(file) { \n        var filePath = srcDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(targetDir).forEach(function(file) { \n        var filePath = targetDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(\"./\").forEach(function(file) {\n        var isText = (contentTypes[getExt(file)]||\"\").startsWith(\"text\");\n        if (isText)\n            staticFiles[\"/\" + file] = fs.readFileSync(file).toString('utf-8');\n        else \n            binaryFiles[\"/\" + file] = file;\n    });\n\n    staticFiles[\"/\"] = staticFiles[\"/default.htm\"];\n\n    console.log(\"loaded: \", Object.keys(staticFiles));\n\n    var isCore = { \"/jquip.js\": true, \"/jquip.min.js\": true };\n\n    var port = process.argv[2] || 90;\n\n    http.createServer(function (req, res) {\n        var reqUrl = url.parse(req.url), path = reqUrl.pathname.replace(VIRTUAL_PATH,'');\n        if (reqUrl.pathname == VIRTUAL_PATH){\n            res.writeHead(302,BASE_URL+VIRTUAL_PATH+\"/\");\n            res.end();\n            return;\n        }\n\n        var fileContents = staticFiles[path];\n\n        if (fileContents) {\n            var ext = path == \"/\" ? \"htm\" : getExt(path);\n            var contentType = contentTypes[ext];\n            res.writeHead(200, {'Content-Type': contentType });\n            var isPlugin = ext == \"js\" && path.startsWith(\"/jquip.\") && !isCore[path];\n            if (isPlugin) {\n                var coreJs = path.indexOf(\"min\") != -1 \n                    ? staticFiles[\"/jquip.min.js\"]\n                    : staticFiles[\"/jquip.js\"];\n                fileContents = coreJs + \";\" + fileContents;\n            }\n\n            res.end(fileContents);\n        }\n        else if (binaryFiles[path]) { \n            var filePath = binaryFiles[path]; \n            fs.createReadStream(filePath, {\n              'bufferSize': 4 * 1024\n            }).pipe(res);\n        }\n        else\n        {\n            var isDynamic = path.startsWith(\"/jquip.\");\n            if (isDynamic) {\n                var parts = path.substring(1).split('.');\n                var isMin = parts.indexOf(\"min\") >= 0;\n                var js = isMin ? staticFiles[\"/jquip.min.js\"] : staticFiles[\"/jquip.js\"];\t\t\t\n                parts.forEach(function(part){\n                    if (part == \"jquip\" || part == \"min\" || part == \"js\") return;\n                    var path = \"/jquip.\" + part + (isMin ? \".min.js\" : \".js\");\n                    var jsFile = staticFiles[path];\n                    if (jsFile)\n                        js += \";\" + jsFile;\n                });\n                res.writeHead(200, {'Content-Type': 'text/javascript' });\n                res.end(js);\t\t\n                return;\n            }\n\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            var sb = \"\";\n            for (var i in reqUrl) {\n                if (sb) sb += \"\\n\";\n                sb += i + \": \" + reqUrl[i];\n            }\n            res.end(\"Path not found:\\n\" + sb);\n        }\n    })\n    .listen(port, \"127.0.0.1\");\n    console.log('Server running at http://127.0.0.1:'+port+'/');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst url = require('url');\n\nconst createServer = (port = 90) => {\n  const srcDir = path.join(__dirname, '../src');\n  const distDir = path.join(__dirname, '../dist');\n  const fileCache = {};\n  const binaryExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.ico', '.woff', '.woff2', '.ttf', '.eot', '.svg'];\n\n  const loadFiles = (dir, prefix = '') => {\n    const files = fs.readdirSync(dir);\n    files.forEach(file => {\n      const fullPath = path.join(dir, file);\n      const stat = fs.statSync(fullPath);\n      if (stat.isDirectory()) {\n        loadFiles(fullPath, `${prefix}${file}/`);\n      } else {\n        const ext = path.extname(file);\n        const isBinary = binaryExtensions.includes(ext);\n        const cacheKey = `${prefix}${file}`;\n        if (isBinary) {\n          fileCache[cacheKey] = fs.readFileSync(fullPath);\n        } else {\n          fileCache[cacheKey] = fs.readFileSync(fullPath, 'utf8');\n        }\n        console.log(`Loaded: ${cacheKey}`);\n      }\n    });\n  };\n\n  loadFiles(srcDir);\n  loadFiles(distDir);\n\n  const getContentType = (filePath) => {\n    const ext = path.extname(filePath);\n    switch (ext) {\n      case '.html': return 'text/html';\n      case '.css': return 'text/css';\n      case '.js': return 'application/javascript';\n      case '.json': return 'application/json';\n      case '.png': return 'image/png';\n      case '.jpg': case '.jpeg': return 'image/jpeg';\n      case '.gif': return 'image/gif';\n      case '.ico': return 'image/x-icon';\n      case '.woff': return 'font/woff';\n      case '.woff2': return 'font/woff2';\n      case '.ttf': return 'font/ttf';\n      case '.eot': return 'application/vnd.ms-fontobject';\n      case '.svg': return 'image/svg+xml';\n      default: return 'text/plain';\n    }\n  };\n\n  const server = http.createServer((req, res) => {\n    const parsedUrl = url.parse(req.url, true);\n    let pathname = parsedUrl.pathname.replace(/^\\/+|\\/+$/g, '');\n    \n    if (pathname === 'core.js') {\n      const coreFiles = ['core/core.js', 'core/utils.js', 'core/events.js'];\n      let content = '';\n      coreFiles.forEach(file => {\n        if (fileCache[file]) {\n          content += fileCache[file] + '\\n';\n        }\n      });\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end(content);\n      return;\n    }\n\n    if (pathname === 'plugins.js') {\n      const pluginFiles = Object.keys(fileCache).filter(f => f.startsWith('plugins/') && f.endsWith('.js'));\n      let content = '';\n      pluginFiles.forEach(file => {\n        content += fileCache[file] + '\\n';\n      });\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end(content);\n      return;\n    }\n\n    if (pathname === '') {\n      pathname = 'index.html';\n    }\n\n    if (fileCache[pathname]) {\n      const isBinary = binaryExtensions.some(ext => pathname.endsWith(ext));\n      res.writeHead(200, { 'Content-Type': getContentType(pathname) });\n      res.end(fileCache[pathname], isBinary ? 'binary' : 'utf8');\n    } else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n    }\n  });\n\n  server.listen(port, '127.0.0.1', () => {\n    console.log(`Server running at http://127.0.0.1:${port}/`);\n  });\n};\n\nconst port = process.argv[2] || 90;\ncreateServer(parseInt(port));"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nfunction createFileServer() {\n    const server = http.createServer((req, res) => {\n        const staticDir = path.join(process.cwd(), 'static');\n        let filePath = path.join(staticDir, req.url === '/' ? 'index.html' : req.url);\n        const extname = path.extname(filePath).toLowerCase();\n        \n        const mimeTypes = {\n            '.html': 'text/html',\n            '.js': 'text/javascript',\n            '.css': 'text/css',\n            '.json': 'application/json',\n            '.png': 'image/png',\n            '.jpg': 'image/jpg',\n            '.gif': 'image/gif',\n            '.svg': 'image/svg+xml',\n            '.wav': 'audio/wav',\n            '.mp4': 'video/mp4',\n            '.woff': 'application/font-woff',\n            '.ttf': 'application/font-ttf',\n            '.eot': 'application/vnd.ms-fontobject',\n            '.otf': 'application/font-otf',\n            '.wasm': 'application/wasm'\n        };\n\n        const contentType = mimeTypes[extname] || 'application/octet-stream';\n\n        fs.readFile(filePath, (err, content) => {\n            if (err) {\n                if (err.code === 'ENOENT') {\n                    res.writeHead(404, { 'Content-Type': 'text/html' });\n                    res.end('404 Not Found', 'utf-8');\n                } else {\n                    res.writeHead(500);\n                    res.end('Server Error: ' + err.code);\n                }\n            } else {\n                res.writeHead(200, { 'Content-Type': contentType });\n                res.end(content, 'utf-8');\n            }\n        });\n    });\n\n    server.listen(1338);\n}\n\ncreateFileServer();"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  async taskRequest(method, url, body = '') {\n    const timestamp = Date.now();\n    const signature = this._generateSignature(timestamp);\n    const headers = this._generateHeaders(timestamp, signature);\n\n    const options = {\n      method: method.toUpperCase(),\n      headers: headers\n    };\n\n    if (method.toLowerCase() === 'post' && body) {\n      options.body = body;\n    }\n\n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Request failed: ${error.message}`);\n    }\n  }\n\n  _generateSignature(timestamp) {\n    const data = `${this.did}${this.token}${timestamp}`;\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n      const char = data.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return Math.abs(hash).toString(16);\n  }\n\n  _generateHeaders(timestamp, signature) {\n    return {\n      'Content-Type': 'application/json',\n      'X-DID': this.did,\n      'X-Finger': this.finger,\n      'X-Token': this.token,\n      'X-OAID': this.oaid,\n      'X-Timestamp': timestamp.toString(),\n      'X-Signature': signature\n    };\n  }\n}"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "const EventEmitter = require('events');\n\nclass OrderBook extends EventEmitter {\n  constructor(productID, websocketURI, restURI, timeProvider) {\n    super();\n    this.STATES = {\n      INITIALIZING: 'initializing',\n      CONNECTING: 'connecting',\n      CONNECTED: 'connected',\n      SYNCING: 'syncing',\n      READY: 'ready',\n      DISCONNECTED: 'disconnected',\n      ERROR: 'error'\n    };\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.timeProvider = timeProvider || Date;\n    this.state = this.STATES.INITIALIZING;\n    this.fail_count = 0;\n    this.socket = null;\n    this.queue = [];\n    this.book = {\n      sequence: null,\n      bids: {},\n      asks: {}\n    };\n    this.connect();\n  }\n\n  clear_book() {\n    this.book = {\n      sequence: null,\n      bids: {},\n      asks: {}\n    };\n    this.queue = [];\n  }\n\n  connect() {\n    this.changeState(this.STATES.CONNECTING);\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.socket.onerror = () => this.changeState(this.STATES.ERROR);\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n\n  changeState(stateName) {\n    if (this.state === stateName) return;\n    this.state = stateName;\n    this.emit('statechange', this.state);\n  }\n\n  onOpen() {\n    this.changeState(this.STATES.CONNECTED);\n    this.sync();\n  }\n\n  onClose() {\n    this.changeState(this.STATES.DISCONNECTED);\n    this.socket = null;\n    setTimeout(() => this.connect(), Math.min(1000 * Math.pow(2, this.fail_count), 30000));\n    this.fail_count++;\n  }\n\n  onMessage(datastr) {\n    const message = JSON.parse(datastr);\n    const t = new this.timeProvider();\n    if (this.state === this.STATES.SYNCING || this.state === this.STATES.READY) {\n      this.processMessage(message, t);\n    } else {\n      this.queue.push(message);\n    }\n  }\n\n  sync() {\n    this.changeState(this.STATES.SYNCING);\n    this.clear_book();\n    this.socket.send(JSON.stringify({\n      type: 'subscribe',\n      product_ids: [this.productID],\n      channels: ['level2']\n    }));\n    fetch(`${this.restURI}/products/${this.productID}/book?level=2`)\n      .then(response => response.json())\n      .then(data => {\n        data.bids.forEach(bid => {\n          this.book.bids[bid[0]] = bid[1];\n        });\n        data.asks.forEach(ask => {\n          this.book.asks[ask[0]] = ask[1];\n        });\n        this.book.sequence = data.sequence;\n        this.changeState(this.STATES.READY);\n        this.queue.forEach(msg => this.processMessage(msg, new this.timeProvider()));\n        this.queue = [];\n      })\n      .catch(err => {\n        this.changeState(this.STATES.ERROR);\n        this.emit('error', err);\n      });\n  }\n\n  processMessage(message, t) {\n    if (message.type === 'l2update') {\n      if (this.book.sequence && message.sequence <= this.book.sequence) return;\n      this.book.sequence = message.sequence;\n      message.changes.forEach(change => {\n        const [side, price, size] = change;\n        if (side === 'buy') {\n          if (size === '0') {\n            delete this.book.bids[price];\n          } else {\n            this.book.bids[price] = size;\n          }\n        } else {\n          if (size === '0') {\n            delete this.book.asks[price];\n          } else {\n            this.book.asks[price] = size;\n          }\n        }\n      });\n      this.emit('l2update', message, t);\n    } else if (message.type === 'snapshot') {\n      this.book.bids = {};\n      this.book.asks = {};\n      message.bids.forEach(bid => {\n        this.book.bids[bid[0]] = bid[1];\n      });\n      message.asks.forEach(ask => {\n        this.book.asks[ask[0]] = ask[1];\n      });\n      this.book.sequence = message.sequence;\n      this.emit('snapshot', message, t);\n    } else if (message.type === 'heartbeat') {\n      this.emit('heartbeat', message, t);\n    } else if (message.type === 'error') {\n      this.changeState(this.STATES.ERROR);\n      this.emit('error', message);\n    }\n  }\n}"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Channel {\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.addEventListener('message', this._messageListener);\n  }\n\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeEventListener('message', this._messageListener);\n    this._handler = null;\n  }\n\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => {\n      this._resolveDisconnect = resolve;\n    });\n    this._connected = new Set();\n    this._frontend = frontend;\n    this._pipe = '/tmp/ndd_pipe';\n    this._setupIpcServer();\n  }\n\n  async _startSession(info, frontend) {\n    const sessionId = info.id;\n    this._connected.add(sessionId);\n\n    const cleanup = async () => {\n      this._connected.delete(sessionId);\n      frontend.sessionClosed(sessionId);\n    };\n\n    frontend.sessionOpened(sessionId, info);\n    return cleanup;\n  }\n\n  _setupIpcServer() {\n    const net = require('net');\n    const server = net.createServer(socket => {\n      socket.on('data', data => {\n        const message = JSON.parse(data.toString());\n        if (message.type === 'connect') {\n          this._startSession(message.info, this._frontend);\n        }\n      });\n    });\n\n    server.listen(this._pipe, () => {\n      console.log(`IPC server listening on ${this._pipe}`);\n    });\n\n    this._ipcServer = server;\n  }\n}"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a class that handles the downloading and installation of binary packages from a specified URL, including directory management and error handling.\n\nClass Description: The Binary class is responsible for downloading a binary package from a given URL, extracting it to a specified directory, and managing the installation process. It handles directory creation, file extraction, and provides feedback on the installation status.\n\nAttributes:\n- url: [String] - The URL from which the binary package will be downloaded.\n- name: [String] - The name of the binary package (optional, defaults to -1).\n- installDirectory: [String] - The base directory where the binary will be installed (optional, defaults to a 'bin' subdirectory in the current working directory).\n- binaryDirectory: [String] - The full path to the directory where the binary will be extracted (initialized as -1, set during installation).\n- binaryPath: [String] - The full path to the binary file (initialized as -1, not used in current implementation).\n\nMethods:\n- constructor(url, data) -> [None] - Initializes the Binary instance with the download URL and optional configuration data (name and installDirectory).\n- install() -> [Promise] - Handles the complete installation process including directory preparation, downloading, extraction, and cleanup. Returns a Promise that resolves when installation is complete or rejects on error.\n  - Internal method _getInstallDirectory() is used to determine the installation directory path.",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass Binary {\n    constructor(url, data) {\n        this.url = url;\n        this.name = data.name || -1;\n        this.installDirectory = data.installDirectory || join(__dirname, \"bin\");\n        this.binaryDirectory = -1;\n        this.binaryPath = -1;\n    }\n\n    install() {\n        const dir = this._getInstallDirectory();\n        if (!existsSync(dir)) {\n            mkdirSync(dir, { recursive: true });\n        }\n\n        this.binaryDirectory = join(dir, \"bin\");\n\n        if (existsSync(this.binaryDirectory)) {\n            rimraf.sync(this.binaryDirectory);\n        }\n\n        mkdirSync(this.binaryDirectory, { recursive: true });\n\n        console.log(`Downloading release from ${this.url}`);\n\n        return axios({ url: this.url, responseType: \"stream\" })\n            .then(res => {\n                const writer = tar.x({ strip: 1, C: this.binaryDirectory });\n\n                return new Promise((resolve, reject) => {\n                    res.data.pipe(writer);\n                    let error = null;\n                    writer.on('error', err => {\n                      error = err;\n                      reject(err);\n                    });\n                    writer.on('close', () => {\n                      if (!error) {\n                        resolve(true);\n                      }\n                    });\n                })\n            })\n            .then(() => {\n                console.log(\n                    `${this.name ? this.name : \"Your package\"} has been installed!`\n                );\n            })\n            .catch(e => {\n                error(`Error fetching release: ${e.message}`);\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "const fs = require('fs');\nconst path = require('path');\nconst https = require('https');\nconst { promisify } = require('util');\nconst { exec } = require('child_process');\nconst extract = require('extract-zip');\nconst rimraf = promisify(require('rimraf'));\nconst mkdirp = promisify(require('mkdirp'));\n\nclass Binary {\n  constructor(url, data = {}) {\n    this.url = url;\n    this.name = data.name || -1;\n    this.installDirectory = data.installDirectory || path.join(process.cwd(), 'bin');\n    this.binaryDirectory = -1;\n    this.binaryPath = -1;\n  }\n\n  _getInstallDirectory() {\n    return this.name === -1 ? this.installDirectory : path.join(this.installDirectory, this.name);\n  }\n\n  async _downloadFile(url, dest) {\n    return new Promise((resolve, reject) => {\n      const file = fs.createWriteStream(dest);\n      https.get(url, (response) => {\n        response.pipe(file);\n        file.on('finish', () => {\n          file.close(resolve);\n        });\n      }).on('error', (err) => {\n        fs.unlink(dest, () => reject(err));\n      });\n    });\n  }\n\n  async _extractFile(zipPath, dest) {\n    try {\n      await extract(zipPath, { dir: dest });\n    } catch (err) {\n      throw new Error(`Extraction failed: ${err.message}`);\n    }\n  }\n\n  async install() {\n    try {\n      this.binaryDirectory = this._getInstallDirectory();\n      await mkdirp(this.binaryDirectory);\n\n      const zipPath = path.join(this.binaryDirectory, 'package.zip');\n      await this._downloadFile(this.url, zipPath);\n      await this._extractFile(zipPath, this.binaryDirectory);\n      await rimraf(zipPath);\n\n      return { success: true, directory: this.binaryDirectory };\n    } catch (err) {\n      await rimraf(this.binaryDirectory).catch(() => {});\n      throw err;\n    }\n  }\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "function testWebSocketConnection(wssUrl) {\n  const socket = new WebSocket(`wss://${wssUrl}`);\n\n  socket.onopen = () => {\n    console.log('WebSocket connection established');\n    socket.send(JSON.stringify({ type: 'greeting', message: 'Hello Server' }));\n  };\n\n  socket.onmessage = (event) => {\n    try {\n      const data = JSON.parse(event.data);\n      console.log('Received message:', data);\n    } catch (error) {\n      console.error('Error parsing message:', error);\n    }\n  };\n\n  socket.onerror = (error) => {\n    console.error('WebSocket error:', error);\n  };\n\n  socket.onclose = (event) => {\n    console.log('WebSocket connection closed:', event.code, event.reason);\n  };\n\n  return () => {\n    if (socket.readyState === WebSocket.OPEN) {\n      socket.close(1000, 'Client closing connection');\n    }\n  };\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using HTTP POST request with error handling.\n\nFunction Description: The function `sendWebhook` is an asynchronous function that takes data as input and sends it to a predefined webhook URL using an HTTP POST request. It handles potential errors during the request and logs them to the console.\n\nInput: \n- `data` [Object] - The payload/data to be sent to the webhook URL.\n\nOutput: \n- None (The function does not return any value, but it may log errors to the console if the request fails).",
    "Canonical_solution": "const axios = require('axios');\n\nconst sendWebhook = async (data) => {\n    try {\n        await axios.post(process.env.UPDATE_WEBHOOK, data);\n    } catch (err) {\n        console.log(err);\n    }\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const sendWebhook = async (data) => {\n  const webhookUrl = 'https://example.com/webhook';\n  try {\n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error sending webhook:', error);\n  }\n};"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Implement a WebSocket client in JavaScript to establish a connection with a server, send a command, and handle connection events.\n\nFunction Description: The code establishes a WebSocket connection to a specified URL with a custom protocol. It sends a \"REBOOT\" command upon successful connection and provides empty handlers for incoming messages and connection closure. Error handling is included for connection issues.\n\nInput: None (The WebSocket URL is obtained internally via get_appropriate_ws_url() function)\n\nOutput: None (The function establishes a WebSocket connection and sends a command, but doesn't return any value)\n\nKey Steps:\n1. Initialize WebSocket connection with appropriate browser API (MozWebSocket or standard WebSocket)\n2. Set up event handlers for connection opening, message reception, and connection closing\n3. Implement error handling for connection attempts\n4. Send \"REBOOT\" command upon successful connection\n5. Provide empty handlers for message reception and connection closing events",
    "Canonical_solution": "function init_command() {\n    socket_command.send(\"REBOOT\\n\");\n}\n\nvar socket_command;\n\nif (typeof MozWebSocket != \"undefined\") {\n    socket_command = new MozWebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n} else {\n    socket_command = new WebSocket(get_appropriate_ws_url(), \"yi-hack-v3_command\");\n}\n\ntry {\n    socket_command.onopen = function() {\n        init_command();\n    }\n\n    socket_command.onmessage = function got_packet(msg) {\n    }\n\n    socket_command.onclose = function(){\n    }\n} catch(exception) {\n    alert('<p>Error' + exception);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "const socket = new (window.MozWebSocket || window.WebSocket)(get_appropriate_ws_url(), 'custom-protocol');\n\nsocket.onopen = function(event) {\n    socket.send('REBOOT');\n};\n\nsocket.onmessage = function(event) {\n};\n\nsocket.onclose = function(event) {\n};\n\nsocket.onerror = function(error) {\n};"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const speechApi = (ssml) => {\n  const endpoint = 'https://eastus.tts.speech.microsoft.com/cognitiveservices/v1';\n  const subscriptionKey = 'YOUR_SUBSCRIPTION_KEY';\n  \n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', endpoint, true);\n    xhr.setRequestHeader('Content-Type', 'application/ssml+xml');\n    xhr.setRequestHeader('X-Microsoft-OutputFormat', 'audio-16khz-128kbitrate-mono-mp3');\n    xhr.setRequestHeader('Ocp-Apim-Subscription-Key', subscriptionKey);\n    xhr.responseType = 'arraybuffer';\n\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        resolve(xhr.response);\n      } else {\n        reject(new Error(`Request failed with status ${xhr.status}`));\n      }\n    };\n\n    xhr.onerror = () => {\n      reject(new Error('Request failed'));\n    };\n\n    xhr.send(ssml);\n  });\n};"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a WebSocket client connection class for browser environments that handles connection lifecycle, message events, and window focus state tracking.\n\nClass Description: The BrowserConnection class manages a WebSocket connection in a browser environment, including connection setup, event handling, and window visibility tracking. It extends a base connection class (BaseConnection) and adds browser-specific functionality.\n\nAttributes:\n- focusDetectorTimer: [Number] - Timer ID for the focus detection interval\n- windowVisible: [Boolean] - Tracks whether the browser window is currently visible\n- socket: [WebSocket] - The WebSocket connection instance\n\nMethods:\n- constructor(opts: Object) -> void - Initializes the connection with options and sets up event listeners for 'ready' and 'disconnect' events\n- setupSocket() -> WebSocket - Creates and configures a new WebSocket connection with event handlers for open, close, and message events\n- startFocusLoop() -> void - Starts tracking window visibility by setting up event listeners for focus/blur events and periodic checks\n- stopFocusLoop() -> void - Stops the window visibility tracking by clearing the interval timer and removing event listeners\n- handleOpen() -> void - Inherited from BaseConnection, called when WebSocket connection opens\n- handleClose(code: Number, reason: String) -> void - Inherited from BaseConnection, called when WebSocket connection closes\n- handleData(data: String) -> void - Inherited from BaseConnection, called when WebSocket receives a message\n- reportFocus(isVisible: Boolean) -> void - Inherited from BaseConnection, reports current window focus state",
    "Canonical_solution": "var WebSocket = require(\"ws\");\nvar _ = require(\"underscore\");\n\nclass BrowserConnection {\n  constructor(opts) {\n    BaseConnection.call(this, opts);\n    var connection = this;\n    this.on(\"ready\", function() {\n      connection.startFocusLoop()\n    });\n    this.on(\"disconnect\", function() {\n      connection.stopFocusLoop()\n    });\n  }\n\n  setupSocket() {\n    var connection = this;\n    var socket = new WebSocket(this.getUrl());\n    socket.onopen = function() {\n      connection.handleOpen()\n    };\n    socket.onclose = function(data) {\n      connection.handleClose(data[\"code\"], data[\"reason\"])\n    };\n    socket.onmessage = function(message) {\n      connection.handleData(message.data)\n    };\n    return socket;\n  }\n\n  startFocusLoop() {\n    if (this.focusDetectorTimer) return;\n    var connection = this;\n    var propertyName = null;\n    if (typeof document.hidden !== \"undefined\") {\n      propertyName = \"hidden\"\n    } else if (typeof document.mozHidden !== \"undefined\") {\n      propertyName = \"mozHidden\"\n    } else if (typeof document.msHidden !== \"undefined\") {\n      propertyName = \"msHidden\"\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      propertyName = \"webkitHidden\"\n    } else {\n      propertyName = undefined\n    }\n    if (connection.windowVisible === undefined) {\n      connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false\n    }\n    var focusListener = window.addEventListener(\"focus\", function(e) {\n      connection.windowVisible = true;\n      updateFocusState()\n    });\n    var blurListener = window.addEventListener(\"blur\", function(e) {\n      connection.windowVisible = false;\n      updateFocusState()\n    });\n    this.on(\"disconnect\", function() {\n      window.removeEventListener(\"focus\", focusListener);\n      window.removeEventListener(\"blur\", blurListener)\n    });\n    var updateFocusState = function() {\n      var isVisible = propertyName === undefined ? true : document[propertyName] === false;\n      connection.reportFocus(isVisible && connection.windowVisible)\n    };\n    this.focusDetectorTimer = setInterval(updateFocusState, 100)\n  }\n\n  stopFocusLoop() {\n    if (!this.focusDetectorTimer) return;\n    clearTimeout(this.focusDetectorTimer);\n    delete this.focusDetectorTimer;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "class BrowserConnection extends BaseConnection {\n  constructor(opts) {\n    super(opts);\n    this.focusDetectorTimer = null;\n    this.windowVisible = true;\n    this.socket = null;\n\n    this.on('ready', () => {\n      this.socket = this.setupSocket();\n      this.startFocusLoop();\n    });\n\n    this.on('disconnect', () => {\n      this.stopFocusLoop();\n    });\n  }\n\n  setupSocket() {\n    const socket = new WebSocket(this.url);\n\n    socket.addEventListener('open', () => {\n      this.handleOpen();\n    });\n\n    socket.addEventListener('close', (event) => {\n      this.handleClose(event.code, event.reason);\n    });\n\n    socket.addEventListener('message', (event) => {\n      this.handleData(event.data);\n    });\n\n    return socket;\n  }\n\n  startFocusLoop() {\n    const checkVisibility = () => {\n      const isVisible = !document.hidden;\n      if (isVisible !== this.windowVisible) {\n        this.windowVisible = isVisible;\n        this.reportFocus(isVisible);\n      }\n    };\n\n    document.addEventListener('visibilitychange', checkVisibility);\n    window.addEventListener('focus', () => {\n      this.windowVisible = true;\n      this.reportFocus(true);\n    });\n    window.addEventListener('blur', () => {\n      this.windowVisible = false;\n      this.reportFocus(false);\n    });\n\n    this.focusDetectorTimer = setInterval(checkVisibility, 1000);\n    checkVisibility();\n  }\n\n  stopFocusLoop() {\n    if (this.focusDetectorTimer) {\n      clearInterval(this.focusDetectorTimer);\n      this.focusDetectorTimer = null;\n    }\n\n    document.removeEventListener('visibilitychange', this.checkVisibility);\n    window.removeEventListener('focus', this.handleFocus);\n    window.removeEventListener('blur', this.handleBlur);\n  }\n}"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Create a function to establish and manage a WebSocket connection in a browser environment, including handling connection events, sending messages, and closing the connection.\n\nFunction Description: The function `setupWebSocketConnection` initializes a WebSocket connection to a specified URL and provides methods to interact with the connection. It sets up event handlers for connection events (`open`, `message`, `close`, `error`) and returns an object with methods to send data, close the connection, and set the binary type of the WebSocket.\n\nInput: \n- `url` [String] - The URL to which the WebSocket connection will be established.\n\nOutput: \n- Returns an object with the following methods:\n  - `send(data)` - Sends data through the WebSocket connection.\n  - `close()` - Closes the WebSocket connection.\n  - `setBinaryType(type)` - Sets the binary type of the WebSocket connection (`blob` or `arraybuffer`).",
    "Canonical_solution": "function setupWebSocketConnection(url) {\n  const ws = new WebSocket(url);\n  \n  ws.onopen = function() {\n    alert('open');\n  };\n  \n  ws.onmessage = function(message) {\n    alert(message.data);\n  };\n  \n  ws.onclose = function() {\n    alert('close');\n  };\n  \n  ws.onerror = function(error) {\n    console.error('WebSocket error:', error);\n  };\n\n  return {\n    send: function(data) {\n      ws.send(data);\n    },\n    close: function() {\n      ws.close();\n    },\n    setBinaryType: function(type) {\n      ws.binaryType = type;\n    }\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "function setupWebSocketConnection(url) {\n  const socket = new WebSocket(url);\n\n  const connection = {\n    send: (data) => {\n      if (socket.readyState === WebSocket.OPEN) {\n        socket.send(data);\n      }\n    },\n    close: () => {\n      socket.close();\n    },\n    setBinaryType: (type) => {\n      socket.binaryType = type;\n    }\n  };\n\n  socket.addEventListener('open', (event) => {\n    console.log('WebSocket connection opened:', event);\n  });\n\n  socket.addEventListener('message', (event) => {\n    console.log('Message received:', event.data);\n  });\n\n  socket.addEventListener('close', (event) => {\n    console.log('WebSocket connection closed:', event);\n  });\n\n  socket.addEventListener('error', (event) => {\n    console.error('WebSocket error:', event);\n  });\n\n  return connection;\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const getChannels = async () => {\n  try {\n    const response = await fetch('https://api.example.com/tv/channels');\n    const data = await response.json();\n    return data.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    return [];\n  }\n};"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a server, handles various connection events, and processes incoming messages for a reload service.\n\nFunction Description: The `connect` function initializes and manages a WebSocket connection to a specified server. It handles connection events (open, error, message, close) and processes incoming messages to trigger appropriate actions, such as requesting initial load data or reloading extensions when file changes are detected. The function ensures only one active connection exists at a time.\n\nInput: None (The WebSocket URL is hardcoded as 'ws://localhost:__RELOAD_PORT__')\n\nOutput: None (The function primarily manages side effects: establishing connections, logging events, and triggering other functions based on received messages)",
    "Canonical_solution": "function connect() {\n  if (webSocket) {\n    return;\n  }\n\n  webSocket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n  webSocket.onerror = (event) => {\n    console.error(`[Reload Service] Connection error: ${JSON.stringify(event)}`);\n    webSocket.close();\n  };\n\n  webSocket.onopen = () => {\n    console.info(`[Reload Service] Connection opened.`);\n  };\n\n  webSocket.onmessage = async (event) => {\n    const message = JSON.parse(event.data);\n\n    if (message.status === 'serverReady') {\n      console.info('[Reload Service] Connection ready.');\n      await requestInitialLoadData();\n    }\n\n    if (message.changedFile) {\n      console.info(\n        `[Reload Service] Changes detected on ${message.changedFile}. Reloading extension...`\n      );\n      await messageAllExtensions(message.changedFile);\n    }\n  };\n\n  webSocket.onclose = () => {\n    console.info('[Reload Service] Connection closed.');\n    webSocket = null;\n  };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "const connect = () => {\n  let socket = null;\n\n  const createSocket = () => {\n    if (socket) return;\n\n    socket = new WebSocket('ws://localhost:__RELOAD_PORT__');\n\n    socket.addEventListener('open', () => {\n      console.log('Reload server connected');\n      socket.send(JSON.stringify({ type: 'requestInitialLoad' }));\n    });\n\n    socket.addEventListener('message', (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        if (message.type === 'initialLoad') {\n          message.extensions.forEach(ext => {\n            chrome.management.setEnabled(ext.id, false);\n            chrome.management.setEnabled(ext.id, true);\n          });\n        } else if (message.type === 'fileChanged') {\n          chrome.management.getAll(extensions => {\n            const ext = extensions.find(e => e.id === message.extensionId);\n            if (ext) {\n              chrome.management.setEnabled(ext.id, false);\n              chrome.management.setEnabled(ext.id, true);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error processing message:', error);\n      }\n    });\n\n    socket.addEventListener('error', (error) => {\n      console.error('Reload server error:', error);\n      socket = null;\n    });\n\n    socket.addEventListener('close', () => {\n      console.log('Reload server disconnected');\n      socket = null;\n      setTimeout(createSocket, 1000);\n    });\n  };\n\n  createSocket();\n};"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "const axios = require('axios');\n\nclass HTTPClient {\n  constructor() {\n    this.requestModule = 'axios';\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers = {}, params = {}, body } = options;\n    const config = {\n      method: method.toLowerCase(),\n      url,\n      headers,\n      params\n    };\n\n    if (body) {\n      if (this.isJson(body) || this.isJSONString(body)) {\n        config.data = this.isJSONString(body) ? JSON.parse(body) : body;\n        config.headers['Content-Type'] = 'application/json';\n      } else {\n        config.data = body;\n      }\n    }\n\n    try {\n      const response = await axios(config);\n      return {\n        status: response.status,\n        data: response.data,\n        headers: response.headers\n      };\n    } catch (error) {\n      if (error.response) {\n        throw {\n          status: error.response.status,\n          data: error.response.data,\n          headers: error.response.headers\n        };\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  isJson(obj) {\n    return obj !== null && typeof obj === 'object' && !Array.isArray(obj);\n  }\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript that handles real-time communication between clients and integrates with an Express application and Deployd backend.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io, integrates it with an Express application, and attaches a Deployd backend. It sets up event listeners for server operations and handles custom Express routes.\n\nInput: None (The function uses environment variables for configuration: `process.env.NODE_ENV` for environment setting and `process.env.PORT` for port number)\n\nOutput: None (The function starts a server that listens on the specified port and logs server status to the console)\n\nNote: The function internally uses:\n- Express for HTTP server functionality\n- Socket.io for WebSocket communication\n- Deployd for backend services\n- MongoDB (configured to connect to localhost:27017 with database name 'test-app')",
    "Canonical_solution": "function setupWebSocketServer() {\n    var express = require('express');\n    var app = express();\n    var server = require('http').createServer(app);\n    var io = require('socket.io').listen(server, {'log level': 0});\n\n    require('deployd').attach(server, {\n        socketIo: io,\n        env: process.env.NODE_ENV || 'development',\n        db: {host:'localhost', port:27017, name:'test-app'}\n    });\n    app.use(server.handleRequest);\n\n    app.get('/express-custom-handler', function(req, res) {\n        res.send('Ok');\n    });\n\n    server.listen(process.env.PORT || 2403, function() {\n        console.log({ ENV: process.env.NODE_ENV || 'development', PORT: process.env.PORT || 2403 });\n    });\n    server.on('error', function(err) {\n        console.log(err.stack);\n        process.nextTick(function() {\n            process.exit();\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst socketio = require('socket.io');\nconst deployd = require('deployd');\nconst path = require('path');\n\nfunction setupWebSocketServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketio(server);\n  const dpd = deployd({\n    port: process.env.PORT || 3000,\n    env: process.env.NODE_ENV || 'development',\n    db: {\n      host: 'localhost',\n      port: 27017,\n      name: 'test-app'\n    }\n  });\n\n  app.use(express.static(path.join(__dirname, 'public')));\n  app.use(dpd);\n\n  io.on('connection', (socket) => {\n    console.log('New client connected');\n\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n\n    socket.on('message', (data) => {\n      io.emit('message', data);\n    });\n\n    socket.on('customEvent', (data) => {\n      console.log('Custom event received:', data);\n      socket.broadcast.emit('customEvent', data);\n    });\n  });\n\n  app.get('/api/custom', (req, res) => {\n    res.json({ message: 'Custom API endpoint' });\n  });\n\n  dpd.on('listening', () => {\n    console.log(`Server running on port ${dpd.options.port}`);\n  });\n\n  dpd.on('error', (err) => {\n    console.error('Deployd error:', err);\n  });\n\n  server.listen(dpd.options.port, () => {\n    console.log(`WebSocket server listening on port ${dpd.options.port}`);\n  });\n}\n\nsetupWebSocketServer();"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Write a function that scrapes TV channel information from a webpage, processes the data, and returns a list of channel objects with their details.\n\nFunction Description: The function `getChannels` asynchronously fetches HTML content from a URL, parses it to extract TV channel information, and returns an array of channel objects. Each channel object contains language, site ID, and name. The function uses Axios for HTTP requests and Cheerio for HTML parsing.\n\nInput: None (The function uses an implicit `this.url()` method to generate the target URL)\n\nOutput: Array<Object> - Returns an array of channel objects with the following structure:\n[\n  {\n    lang: string,      // Language code of the channel (e.g., 'tr')\n    site_id: string,   // Unique identifier for the channel\n    name: string       // Name of the channel\n  },\n  ...\n]",
    "Canonical_solution": "async function getChannels() {\n    const channels = {};\n    const axios = require('axios');\n    const data = await axios\n        .get(this.url({ date: dayjs() }))\n        .then(r => r.data)\n        .catch(console.error);\n\n    const $ = cheerio.load(data);\n    $('.channelContent').toArray()\n        .forEach(el => {\n            const item = $(el);\n            const channelId = item.find('.channelDetail .tvGuideResult-box-wholeDates-title')\n                .first()\n                .attr('onclick');\n            if (channelId) {\n                const site_id = channelId.match(/\\s(\\d+)\\)/)[1];\n                if (channels[site_id] === undefined) {\n                    channels[site_id] = {\n                        lang: 'tr',\n                        site_id,\n                        name: item.find('#channelID').val()\n                    };\n                }\n            }\n        });\n\n    return Object.values(channels);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const axios = require('axios');\nconst cheerio = require('cheerio');\n\nasync function getChannels() {\n  const url = this.url();\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  const channels = [];\n\n  $('.channel-item').each((index, element) => {\n    const lang = $(element).attr('data-lang');\n    const site_id = $(element).attr('data-site-id');\n    const name = $(element).find('.channel-name').text().trim();\n    \n    if (lang && site_id && name) {\n      channels.push({\n        lang,\n        site_id,\n        name\n      });\n    }\n  });\n\n  return channels;\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const https = require('https');\n\nfunction installTelemetry() {\n    if (process.env.TUNNELMOLE_TELEMETRY !== '1') {\n        return;\n    }\n\n    const data = JSON.stringify({\n        nodeVersion: process.version,\n        platform: process.platform\n    });\n\n    const options = {\n        hostname: 'telemetry.tunnelmole.com',\n        port: 443,\n        path: '/api/install',\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Content-Length': data.length\n        }\n    };\n\n    const req = https.request(options, () => {});\n    req.on('error', () => {});\n    req.write(data);\n    req.end();\n}"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const https = require('https');\n\nclass SauceLabsClient {\n    constructor() {\n        this.auth = {\n            username: null,\n            token: null\n        };\n    }\n\n    setAuth(saucelabsUsername, saucelabsToken) {\n        this.auth.username = saucelabsUsername;\n        this.auth.token = saucelabsToken;\n    }\n\n    get(path, callback) {\n        const options = {\n            hostname: 'api.eu-central-1.saucelabs.com',\n            path: `/rest/v1/${path}`,\n            method: 'GET',\n            auth: `${this.auth.username}:${this.auth.token}`,\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        };\n\n        const req = https.request(options, (res) => {\n            let data = '';\n            res.on('data', (chunk) => {\n                data += chunk;\n            });\n            res.on('end', () => {\n                callback(null, JSON.parse(data));\n            });\n        });\n\n        req.on('error', (error) => {\n            callback(error, null);\n        });\n\n        req.end();\n    }\n\n    post(path, data, callback) {\n        const postData = JSON.stringify(data);\n        const options = {\n            hostname: 'api.eu-central-1.saucelabs.com',\n            path: `/rest/v1/${path}`,\n            method: 'POST',\n            auth: `${this.auth.username}:${this.auth.token}`,\n            headers: {\n                'Content-Type': 'application/json',\n                'Content-Length': postData.length\n            }\n        };\n\n        const req = https.request(options, (res) => {\n            let responseData = '';\n            res.on('data', (chunk) => {\n                responseData += chunk;\n            });\n            res.on('end', () => {\n                callback(null, JSON.parse(responseData));\n            });\n        });\n\n        req.on('error', (error) => {\n            callback(error, null);\n        });\n\n        req.write(postData);\n        req.end();\n    }\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class BundleSizeAPI {\n  constructor({ repo, token, sha, ci }) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = Boolean(repo && token);\n  }\n\n  async get() {\n    if (!this.enabled) return {};\n\n    try {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      const response = await fetch(`${this.url}?repo=${sanitizedRepo}`, {\n        headers: { Authorization: `Bearer ${this.token}` }\n      });\n      return await response.json();\n    } catch (error) {\n      console.error('Failed to fetch bundle sizes:', error);\n      return {};\n    }\n  }\n\n  async set(values) {\n    if (!this.enabled || !values) return;\n\n    try {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      await fetch(this.url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${this.token}`\n        },\n        body: JSON.stringify({\n          repo: sanitizedRepo,\n          sha: this.sha,\n          values\n        })\n      });\n    } catch (error) {\n      console.error('Failed to post bundle sizes:', error);\n    }\n  }\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const fetchCovidData = () => {\n  const apiUrl = 'https://datadashboardapi.health.gov.il/api/queries/_batch';\n  const requestData = {\n    requests: [\n      { id: '1', queryName: 'lastUpdate' },\n      { id: '2', queryName: 'patientsPerDate' },\n      { id: '3', queryName: 'testResultsPerDate' },\n      { id: '4', queryName: 'infectedByAgeAndGenderPublic' }\n    ]\n  };\n\n  const requestOptions = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json'\n    },\n    body: JSON.stringify(requestData)\n  };\n\n  return fetch(apiUrl, requestOptions)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return response.json();\n    })\n    .then(data => {\n      const parseData = (rawData) => {\n        const result = {};\n        rawData.forEach(item => {\n          if (item.id === '1') result.lastUpdate = item.data;\n          if (item.id === '2') result.patients = item.data;\n          if (item.id === '3') result.tests = item.data;\n          if (item.id === '4') result.demographics = item.data;\n        });\n        return result;\n      };\n      return parseData(data);\n    })\n    .catch(error => {\n      console.error('Error fetching COVID-19 data:', error);\n      return null;\n    });\n};"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "const fetch = require('node-fetch');\n\nasync function getTVChannels() {\n  const apiUrl = 'https://api.example.com/tv/channels';\n  try {\n    const response = await fetch(apiUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.channels.map(channel => ({\n      lang: 'sq',\n      site_id: channel.id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Failed to fetch TV channels:', error);\n    return [];\n  }\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class Tool {\n    constructor() {\n        this._node = (() => {\n            try {\n                const http = require('http');\n                const https = require('https');\n                const fs = require('fs');\n                return { http, https, fs };\n            } catch (e) {\n                return null;\n            }\n        })();\n        this._isSurge = typeof $httpClient !== 'undefined';\n        this._isQuanX = typeof $task !== 'undefined';\n        this.isSurge = this._isSurge;\n        this.isQuanX = this._isQuanX;\n        this.isResponse = typeof $response !== 'undefined';\n    }\n\n    notify(title, subtitle, message, option = {}) {\n        if (this._isQuanX) {\n            $notify(title, subtitle, message, option);\n        } else if (this._isSurge) {\n            $notification.post(title, subtitle, message);\n        } else if (this._node) {\n            console.log(JSON.stringify({ title, subtitle, message }));\n        }\n    }\n\n    write(value, key) {\n        if (this._isQuanX) {\n            return $prefs.setValueForKey(value, key);\n        } else if (this._isSurge) {\n            return $persistentStore.write(value, key);\n        } else if (this._node) {\n            try {\n                this._node.fs.writeFileSync(key, value);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    }\n\n    read(key) {\n        if (this._isQuanX) {\n            return $prefs.valueForKey(key);\n        } else if (this._isSurge) {\n            return $persistentStore.read(key);\n        } else if (this._node) {\n            try {\n                return this._node.fs.readFileSync(key, 'utf8');\n            } catch (e) {\n                return null;\n            }\n        }\n    }\n\n    get(options, callback) {\n        if (typeof options === 'string') options = { url: options };\n        if (this._isQuanX) {\n            $task.fetch(options).then(response => {\n                callback(null, this._status(response), response.body);\n            }, reason => callback(reason.error, null, null));\n        } else if (this._isSurge) {\n            $httpClient.get(options, (error, response, body) => {\n                callback(error, this._status(response), body);\n            });\n        } else if (this._node) {\n            const protocol = options.url.startsWith('https') ? this._node.https : this._node.http;\n            protocol.get(options.url, res => {\n                const { statusCode } = res;\n                let body = '';\n                res.on('data', chunk => body += chunk);\n                res.on('end', () => {\n                    callback(null, { status: statusCode, headers: res.headers }, body);\n                });\n            }).on('error', error => callback(error, null, null));\n        }\n    }\n\n    post(options, callback) {\n        if (typeof options === 'string') options = { url: options };\n        if (this._isQuanX) {\n            $task.fetch(options).then(response => {\n                callback(null, this._status(response), response.body);\n            }, reason => callback(reason.error, null, null));\n        } else if (this._isSurge) {\n            $httpClient.post(options, (error, response, body) => {\n                callback(error, this._status(response), body);\n            });\n        } else if (this._node) {\n            const protocol = options.url.startsWith('https') ? this._node.https : this._node.http;\n            const req = protocol.request(options.url, {\n                method: 'POST',\n                headers: options.headers || {}\n            }, res => {\n                const { statusCode } = res;\n                let body = '';\n                res.on('data', chunk => body += chunk);\n                res.on('end', () => {\n                    callback(null, { status: statusCode, headers: res.headers }, body);\n                });\n            });\n            req.on('error', error => callback(error, null, null));\n            if (options.body) req.write(options.body);\n            req.end();\n        }\n    }\n\n    _status(response) {\n        if (!response) return { status: 0 };\n        if (this._isQuanX) {\n            return { status: response.statusCode || 0, headers: response.headers || {} };\n        } else if (this._isSurge) {\n            return { status: response.status || 0, headers: response.headers || {} };\n        } else if (this._node) {\n            return { status: response.statusCode || 0, headers: response.headers || {} };\n        }\n    }\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const http = require('http');\nconst https = require('https');\nconst { Readable } = require('stream');\n\nclass DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type || null;\n    this.urlOpts = options || {};\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    const req = this._makeRequest((err, res) => {\n      if (err) return callback(err);\n      const chunks = [];\n      res.on('data', (chunk) => chunks.push(chunk));\n      res.on('end', () => {\n        const buffer = Buffer.concat(chunks);\n        this._type = res.headers['content-type'] || this._type;\n        this._size = buffer.length;\n        callback(null, buffer);\n      });\n      res.on('error', (err) => callback(err));\n    });\n    req.on('error', (err) => callback(err));\n    req.end();\n  }\n\n  getDataUri(callback) {\n    this.getBuffer((err, buffer) => {\n      if (err) return callback(err);\n      const base64 = buffer.toString('base64');\n      const mime = this._type || 'application/octet-stream';\n      callback(null, `data:${mime};base64,${base64}`);\n    });\n  }\n\n  createReadStream() {\n    const stream = new Readable({ read() {} });\n    const req = this._makeRequest((err, res) => {\n      if (err) return stream.emit('error', err);\n      this._type = res.headers['content-type'] || this._type;\n      res.on('data', (chunk) => stream.push(chunk));\n      res.on('end', () => stream.push(null));\n      res.on('error', (err) => stream.emit('error', err));\n    });\n    req.on('error', (err) => stream.emit('error', err));\n    req.end();\n    return stream;\n  }\n\n  size(callback) {\n    if (this._size !== null) return callback(null, this._size);\n    const req = this._makeRequest({ method: 'HEAD' }, (err, res) => {\n      if (err) return callback(err);\n      const size = parseInt(res.headers['content-length'], 10);\n      this._size = size || null;\n      callback(null, this._size);\n    });\n    req.on('error', (err) => callback(err));\n    req.end();\n  }\n\n  type() {\n    return this._type;\n  }\n\n  _makeRequest(options = {}, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    const url = new URL(this.url);\n    const opts = {\n      ...this.urlOpts,\n      ...options,\n      hostname: url.hostname,\n      path: url.pathname + url.search,\n      port: url.port,\n      headers: {\n        ...this.urlOpts.headers,\n        ...options.headers\n      }\n    };\n    const protocol = url.protocol === 'https:' ? https : http;\n    return protocol.request(opts, callback);\n  }\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function sendPostRequest() {\n    const url = 'https://example.com/api/submit';\n    const data = new URLSearchParams();\n    data.append('username', 'user123');\n    data.append('password', 'pass456');\n\n    fetch(url, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        credentials: 'include',\n        body: data\n    })\n    .then(response => response.json())\n    .then(data => console.log(data))\n    .catch(error => console.error('Error:', error));\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function runTest(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://example.com', true);\n    xhr.onload = function() {\n      if (xhr.status === 200) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('XHR request failed with status: ' + xhr.status);\n      }\n    };\n    xhr.onerror = function() {\n      sender.postMessage('XHR request failed');\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://example.com')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Fetch request failed with status: ' + response.status);\n        }\n        return response.text();\n      })\n      .then(text => sender.postMessage(text))\n      .catch(error => sender.postMessage(error.message));\n  } else if (data === 'importScripts') {\n    try {\n      importScripts('test_script.js');\n      sender.postMessage(scriptMessage);\n    } catch (error) {\n      sender.postMessage('Failed to import script: ' + error.message);\n    }\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function loadYamlUrl(url) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4) {\n      if (xhr.status === 200) {\n        console.log(xhr.responseText);\n        yamlToForm(xhr.responseText);\n      }\n    }\n  };\n  xhr.send();\n}"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const http = require('http');\nconst https = require('https');\nconst url = require('url');\n\nclass URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': 'is.gd',\n      'goo.gl': 'goo.gl',\n      'bit.ly': 'bit.ly',\n      'tinyurl.com': 'tinyurl.com',\n      'budurl.com': 'budurl.com',\n      'snipurl.com': 'snipurl.com'\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      'is.gd': this._expandIsGd.bind(this),\n      'goo.gl': this._expandGooGl.bind(this),\n      'bit.ly': this._expandBitLy.bind(this),\n      'tinyurl.com': this._expandTinyUrl.bind(this),\n      'budurl.com': this._expandGeneric.bind(this),\n      'snipurl.com': this._expandGeneric.bind(this)\n    };\n  }\n\n  expand(args, callback) {\n    if (!args.url) {\n      return callback({ err: new Error('URL is required') });\n    }\n\n    args.depth = args.depth || 0;\n    args.seen = args.seen || {};\n\n    if (args.seen[args.url]) {\n      return callback({ err: new Error('Cycle detected'), url: args.url, depth: args.depth, seen: args.seen });\n    }\n\n    args.seen[args.url] = true;\n\n    const parsedUrl = url.parse(args.url);\n    const domain = parsedUrl.hostname;\n\n    if (!this.map[domain]) {\n      return callback({ url: args.url, depth: args.depth, seen: args.seen, urlp: parsedUrl });\n    }\n\n    const expander = this.APIs[domain];\n    if (!expander) {\n      return this._expandGeneric(args, callback);\n    }\n\n    expander(args, (result) => {\n      if (result.err) {\n        return callback(result);\n      }\n      if (result.url === args.url || args.depth >= 10) {\n        return callback(result);\n      }\n      this.expand(result, callback);\n    });\n  }\n\n  _expandIsGd(args, callback) {\n    const apiUrl = `http://is.gd/forward.php?format=json&shorturl=${encodeURIComponent(args.url)}`;\n    this._makeRequest(apiUrl, (err, data) => {\n      if (err) {\n        return callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n      }\n      try {\n        const json = JSON.parse(data);\n        if (json.errorcode) {\n          return callback({ err: new Error(json.errormessage), url: args.url, depth: args.depth, seen: args.seen });\n        }\n        callback({ url: json.url, depth: args.depth + 1, seen: args.seen });\n      } catch (e) {\n        callback({ err: e, url: args.url, depth: args.depth, seen: args.seen });\n      }\n    });\n  }\n\n  _expandGooGl(args, callback) {\n    const apiUrl = `https://www.googleapis.com/urlshortener/v1/url?shortUrl=${encodeURIComponent(args.url)}`;\n    this._makeRequest(apiUrl, (err, data) => {\n      if (err) {\n        return callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n      }\n      try {\n        const json = JSON.parse(data);\n        if (json.error) {\n          return callback({ err: new Error(json.error.message), url: args.url, depth: args.depth, seen: args.seen });\n        }\n        callback({ url: json.longUrl, depth: args.depth + 1, seen: args.seen });\n      } catch (e) {\n        callback({ err: e, url: args.url, depth: args.depth, seen: args.seen });\n      }\n    });\n  }\n\n  _expandBitLy(args, callback) {\n    const apiUrl = `http://api.bit.ly/v3/expand?shortUrl=${encodeURIComponent(args.url)}&format=json`;\n    this._makeRequest(apiUrl, (err, data) => {\n      if (err) {\n        return callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n      }\n      try {\n        const json = JSON.parse(data);\n        if (json.status_code !== 200) {\n          return callback({ err: new Error(json.status_txt), url: args.url, depth: args.depth, seen: args.seen });\n        }\n        const longUrl = json.data.expand[0].long_url;\n        callback({ url: longUrl, depth: args.depth + 1, seen: args.seen });\n      } catch (e) {\n        callback({ err: e, url: args.url, depth: args.depth, seen: args.seen });\n      }\n    });\n  }\n\n  _expandTinyUrl(args, callback) {\n    const apiUrl = `http://tinyurl.com/api-create.php?url=${encodeURIComponent(args.url)}`;\n    this._makeRequest(apiUrl, (err, data) => {\n      if (err) {\n        return callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n      }\n      callback({ url: data.trim(), depth: args.depth + 1, seen: args.seen });\n    });\n  }\n\n  _expandGeneric(args, callback) {\n    const options = {\n      method: 'HEAD',\n      timeout: this.timeout,\n      followRedirect: false\n    };\n\n    const protocol = args.url.startsWith('https') ? https : http;\n    const req = protocol.request(args.url, options, (res) => {\n      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n        callback({ url: res.headers.location, depth: args.depth + 1, seen: args.seen, headers: res.headers });\n      } else {\n        callback({ url: args.url, depth: args.depth, seen: args.seen, headers: res.headers });\n      }\n    });\n\n    req.on('error', (err) => {\n      callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n    });\n\n    req.on('timeout', () => {\n      req.abort();\n      callback({ err: new Error('Request timeout'), url: args.url, depth: args.depth, seen: args.seen });\n    });\n\n    req.end();\n  }\n\n  _makeRequest(url, callback) {\n    const protocol = url.startsWith('https') ? https : http;\n    const req = protocol.get(url, (res) => {\n      if (res.statusCode !== 200) {\n        return callback(new Error(`Request failed with status code ${res.statusCode}`));\n      }\n      let data = '';\n      res.on('data', (chunk) => {\n        data += chunk;\n      });\n      res.on('end', () => {\n        callback(null, data);\n      });\n    });\n\n    req.on('error', (err) => {\n      callback(err);\n    });\n\n    req.on('timeout', () => {\n      req.abort();\n      callback(new Error('Request timeout'));\n    });\n\n    req.setTimeout(this.timeout);\n  }\n}"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst multer = require('multer');\nconst upload = multer();\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n    this.app.use(upload.any());\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.port, () => {\n        resolve();\n      }).on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method.toLowerCase()](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n\n  trace(path, handler) {\n    this.addRoute('trace', path, handler);\n  }\n\n  head(path, handler) {\n    this.addRoute('head', path, handler);\n  }\n}"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "const http = require('http');\nconst https = require('https');\nconst url = require('url');\n\nclass URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': 'isgd',\n      'goo.gl': 'googl',\n      'budurl.com': 'budurl',\n      'snipurl.com': 'snipurl'\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: this.isgd.bind(this),\n      googl: this.googl.bind(this),\n      budurl: this.budurl.bind(this),\n      snipurl: this.snipurl.bind(this),\n      generic: this.generic.bind(this)\n    };\n  }\n\n  expand(args, callback) {\n    if (!args.url) {\n      return callback({ err: new Error('No URL provided') });\n    }\n\n    args.depth = args.depth || 0;\n    args.seen = args.seen || {};\n\n    if (args.seen[args.url]) {\n      return callback({ err: new Error('Cycle detected'), url: args.url, depth: args.depth, seen: args.seen });\n    }\n\n    args.seen[args.url] = true;\n\n    const parsed = url.parse(args.url);\n    const domain = parsed.hostname;\n    const service = this.map[domain] || 'generic';\n\n    this.APIs[service](args, (result) => {\n      if (result.err) {\n        return callback(result);\n      }\n\n      if (result.url === args.url || args.depth >= 10) {\n        return callback(result);\n      }\n\n      this.expand({\n        url: result.url,\n        depth: args.depth + 1,\n        seen: args.seen\n      }, callback);\n    });\n  }\n\n  isgd(args, callback) {\n    const apiUrl = `http://is.gd/forward.php?shorturl=${encodeURIComponent(args.url)}&format=json`;\n    this._makeRequest(apiUrl, (err, data) => {\n      if (err) {\n        return callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n      }\n      try {\n        const result = JSON.parse(data);\n        if (result.errorcode) {\n          return callback({ err: new Error(result.errormessage), url: args.url, depth: args.depth, seen: args.seen });\n        }\n        callback({ url: result.url, depth: args.depth, seen: args.seen });\n      } catch (e) {\n        callback({ err: e, url: args.url, depth: args.depth, seen: args.seen });\n      }\n    });\n  }\n\n  googl(args, callback) {\n    const apiUrl = `https://www.googleapis.com/urlshortener/v1/url?shortUrl=${encodeURIComponent(args.url)}`;\n    this._makeRequest(apiUrl, (err, data) => {\n      if (err) {\n        return callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n      }\n      try {\n        const result = JSON.parse(data);\n        if (result.error) {\n          return callback({ err: new Error(result.error.message), url: args.url, depth: args.depth, seen: args.seen });\n        }\n        callback({ url: result.longUrl, depth: args.depth, seen: args.seen });\n      } catch (e) {\n        callback({ err: e, url: args.url, depth: args.depth, seen: args.seen });\n      }\n    });\n  }\n\n  budurl(args, callback) {\n    const apiUrl = `http://api.budurl.com/v1/expand?short_url=${encodeURIComponent(args.url)}`;\n    this._makeRequest(apiUrl, (err, data) => {\n      if (err) {\n        return callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n      }\n      try {\n        const result = JSON.parse(data);\n        if (result.error) {\n          return callback({ err: new Error(result.error), url: args.url, depth: args.depth, seen: args.seen });\n        }\n        callback({ url: result.long_url, depth: args.depth, seen: args.seen });\n      } catch (e) {\n        callback({ err: e, url: args.url, depth: args.depth, seen: args.seen });\n      }\n    });\n  }\n\n  snipurl(args, callback) {\n    const apiUrl = `http://snipurl.com/site/getlinkinfo?link=${encodeURIComponent(args.url)}`;\n    this._makeRequest(apiUrl, (err, data) => {\n      if (err) {\n        return callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n      }\n      try {\n        const result = JSON.parse(data);\n        if (result.error) {\n          return callback({ err: new Error(result.error), url: args.url, depth: args.depth, seen: args.seen });\n        }\n        callback({ url: result.long_url, depth: args.depth, seen: args.seen });\n      } catch (e) {\n        callback({ err: e, url: args.url, depth: args.depth, seen: args.seen });\n      }\n    });\n  }\n\n  generic(args, callback) {\n    const parsed = url.parse(args.url);\n    const options = {\n      hostname: parsed.hostname,\n      port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),\n      path: parsed.path,\n      method: 'HEAD',\n      timeout: this.timeout\n    };\n\n    const protocol = parsed.protocol === 'https:' ? https : http;\n    const req = protocol.request(options, (res) => {\n      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n        callback({ url: res.headers.location, headers: res.headers, depth: args.depth, seen: args.seen });\n      } else {\n        callback({ url: args.url, headers: res.headers, depth: args.depth, seen: args.seen });\n      }\n      req.abort();\n    });\n\n    req.on('error', (err) => {\n      callback({ err, url: args.url, depth: args.depth, seen: args.seen });\n    });\n\n    req.on('timeout', () => {\n      req.abort();\n      callback({ err: new Error('Request timeout'), url: args.url, depth: args.depth, seen: args.seen });\n    });\n\n    req.end();\n  }\n\n  _makeRequest(url, callback) {\n    const parsed = url.parse(url);\n    const options = {\n      hostname: parsed.hostname,\n      port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),\n      path: parsed.path,\n      timeout: this.timeout\n    };\n\n    const protocol = parsed.protocol === 'https:' ? https : http;\n    const req = protocol.get(options, (res) => {\n      let data = '';\n      res.on('data', (chunk) => {\n        data += chunk;\n      });\n      res.on('end', () => {\n        callback(null, data);\n      });\n    });\n\n    req.on('error', (err) => {\n      callback(err);\n    });\n\n    req.on('timeout', () => {\n      req.abort();\n      callback(new Error('Request timeout'));\n    });\n  }\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a function to start an Express server with REST API endpoints for managing tourist attractions, including retrieving approved attractions, adding new attractions, and fetching specific attraction details.\n\nFunction Description: The function initializes an Express application, configures middleware, sets up REST API routes using connect-rest, and starts an HTTP server. It handles GET and POST requests for attractions data, connects to a MongoDB model for data persistence, and implements error handling through domains.\n\nInput: None (The function takes no parameters but relies on environment variables like PORT and requires external modules)\n\nOutput: Returns the HTTP server instance that was created and started.\n\nMethods:\n\n- GET /attractions: Retrieves all approved attractions (returns array of attraction objects)\n- POST /attraction: Creates a new attraction (requires name, description, location, and email in request body, returns new attraction ID)\n- GET /attraction/:id: Retrieves details of a specific attraction (requires ID parameter, returns attraction object)\n\nError Handling:\n- Implements domain-based error handling that logs errors and gracefully shuts down the server\n- Returns appropriate error messages for database operations\n\nDependencies:\n- Requires Express, connect-rest, body-parser, and a MongoDB model (Attraction)\n- Uses cluster module for worker process management in case of errors",
    "Canonical_solution": "function startServer() {\n    var http = require('http'),\n        express = require('express'),\n        app = express();\n\n    app.set('port', process.env.PORT || 3000);\n\n    app.use(express.static(__dirname + '/public'));\n    app.use(require('body-parser')());\n\n    var rest = require('connect-rest');\n    var apiOptions = {\n        context: '/',\n        domain: require('domain').create(),\n    };\n\n    apiOptions.domain.on('error', function(err){\n        console.log('API domain error.\\n', err.stack);\n        setTimeout(function(){\n            console.log('Server shutting down after API domain error.');\n            process.exit(1);\n        }, 5000);\n        server.close();\n        var worker = require('cluster').worker;\n        if(worker) worker.disconnect();\n    });\n\n    var Attraction = require('./models/attraction.js');\n\n    rest.get('/attractions', function(req, content, cb){\n        Attraction.find({ approved: true }, function(err, attractions){\n            if(err) return cb({ error: 'Internal error.' });\n            cb(null, attractions.map(function(a){\n                return {\n                    name: a.name,\n                    description: a.description,\n                    location: a.location,\n                };\n            }));\n        });\n    });\n\n    rest.post('/attraction', function(req, content, cb){\n        var a = new Attraction({\n            name: req.body.name,\n            description: req.body.description,\n            location: { lat: req.body.lat, lng: req.body.lng },\n            history: {\n                event: 'created',\n                email: req.body.email,\n                date: new Date(),\n            },\n            approved: false,\n        });\n        a.save(function(err, a){\n            if(err) return cb({ error: 'Unable to add attraction.' });\n            cb(null, { id: a._id });\n        }); \n    });\n\n    rest.get('/attraction/:id', function(req, content, cb){\n        Attraction.findById(req.params.id, function(err, a){\n            if(err) return cb({ error: 'Unable to retrieve attraction.' });\n            cb(null, { \n                name: a.name,\n                description: a.description,\n                location: a.location,\n            });\n        });\n    });\n\n    var server = http.createServer(app).listen(app.get('port'), function(){\n        console.log( 'Express started in ' + app.get('env') +\n            ' mode on http://localhost:' + app.get('port') +\n            '; press Ctrl-C to terminate.' );\n    });\n\n    return server;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst rest = require('connect-rest');\nconst domain = require('domain');\nconst cluster = require('cluster');\nconst Attraction = require('./models/attraction');\n\nfunction startServer() {\n    const app = express();\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: true }));\n    app.use(rest.rester());\n\n    const serverDomain = domain.create();\n    serverDomain.on('error', (err) => {\n        console.error('Domain caught error:', err);\n        if (cluster.worker) {\n            cluster.worker.disconnect();\n        }\n        server.close(() => {\n            process.exit(1);\n        });\n    });\n\n    serverDomain.run(() => {\n        const server = app.listen(process.env.PORT || 3000, () => {\n            console.log(`Server running on port ${server.address().port}`);\n        });\n\n        rest.get('/attractions', (req, content, cb) => {\n            Attraction.find({ approved: true }, (err, attractions) => {\n                if (err) return cb(err);\n                cb(null, attractions);\n            });\n        });\n\n        rest.post('/attraction', (req, content, cb) => {\n            const { name, description, location, email } = req.body;\n            if (!name || !description || !location || !email) {\n                return cb(new Error('Missing required fields'));\n            }\n            const newAttraction = new Attraction({\n                name,\n                description,\n                location,\n                email,\n                approved: false\n            });\n            newAttraction.save((err, attraction) => {\n                if (err) return cb(err);\n                cb(null, { id: attraction._id });\n            });\n        });\n\n        rest.get('/attraction/:id', (req, content, cb) => {\n            Attraction.findById(req.params.id, (err, attraction) => {\n                if (err) return cb(err);\n                if (!attraction) return cb(new Error('Attraction not found'));\n                cb(null, attraction);\n            });\n        });\n\n        return server;\n    });\n}\n\nmodule.exports = startServer;"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "const request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'https://example.com/api/data';\n  const headers = {\n    'Accept-Encoding': 'gzip',\n    'User-Agent': 'Custom-User-Agent/1.0',\n    'Authorization': 'Bearer some_token'\n  };\n\n  request.get({\n    url: url,\n    headers: headers,\n    gzip: true\n  }, function(error, response, body) {\n    if (error) {\n      console.error('Error:', error);\n      return;\n    }\n    if (response.statusCode !== 200) {\n      console.error('Status:', response.statusCode);\n      return;\n    }\n    console.log('Response:', body);\n  });\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst session = require('express-session');\nconst MongoStore = require('connect-mongo');\nconst next = require('next');\n\nconst setupServer = async () => {\n  const dev = process.env.NODE_ENV !== 'production';\n  const port = process.env.PORT || 8000;\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  await app.prepare();\n\n  const server = express();\n\n  server.use(\n    session({\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      resave: false,\n      saveUninitialized: false,\n      store: MongoStore.create({\n        mongoUrl: process.env.MONGO_URL_TEST,\n        ttl: 14 * 24 * 60 * 60\n      }),\n      cookie: {\n        httpOnly: true,\n        secure: !dev,\n        maxAge: 1000 * 60 * 60 * 24 * 14,\n        sameSite: 'lax'\n      }\n    })\n  );\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, () => {\n    console.log(`Server ready at http://localhost:${port}`);\n  });\n};\n\nsetupServer();"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a function that initializes and configures an Express.js web application with middleware, route handlers, and server listening capabilities, including optional HTTPS support.\n\nFunction Description: The function `createExpressApp` creates and configures an Express.js application instance with various middleware (CORS, security headers, caching), route handlers for API endpoints and static files, and error handling. It starts an HTTP server (and optionally an HTTPS server) listening on specified ports. The function returns the configured Express application instance.\n\nInput: None (The function uses global configuration variables like CONFIG and process.env for settings)\n\nOutput: Express.Application - Returns the fully configured Express.js application instance after setting up all middleware, routes, and server listeners.",
    "Canonical_solution": "function createExpressApp() {\n    var express = require('express');\n    var app = express();\n\n    app.use(express.bodyParser());\n    app.set('view engine', 'ejs');\n\n    if (CONFIG.allowedOrigins) {\n        app.use(function(req, res, next) {\n            var origin = req.headers[\"origin\"];\n            if (origin) {\n                if (CONFIG.allowedOrigins.indexOf('*') > -1) {\n                    res.setHeader('Access-Control-Allow-Origin', '*');\n                } else {\n                    if (CONFIG.allowedOrigins.indexOf(origin) > -1) {\n                        res.setHeader('Access-Control-Allow-Origin', origin);\n                    }\n                }\n            }\n            next();\n        });\n    }\n\n    app.disable('x-powered-by');\n    app.use(function(req, res, next) {\n        res.setHeader('X-Powered-By', 'Iframely');\n        next();\n    });\n\n    app.use(sysUtils.cacheMiddleware);\n\n    require('./modules/api/views')(app);\n    require('./modules/debug/views')(app);\n    require('./modules/tests-ui/views')(app);\n\n    app.use(logErrors);\n    app.use(errorHandler);\n\n    app.get(CONFIG.relativeStaticUrl + '/*', function(req, res, next) {\n        var url = '/' + req.url.split('/').splice(2).join('/');\n        sysUtils.static(path.resolve(__dirname, 'static'), {path: url})(req, res, next);\n    });\n\n    app.get('/', function(req, res) {\n        res.writeHead(302, { Location: 'http://iframely.com'});\n        res.end();\n    });\n\n    var listener = app.listen(process.env.PORT || CONFIG.port, process.env.HOST || CONFIG.host, function(){\n        console.log('\\niframely is listening on ' + listener.address().address + ':' + listener.address().port + '\\n');\n    });\n\n    if (CONFIG.ssl) {\n        var options = { key: CONFIG.ssl.key, cert: CONFIG.ssl.cert };\n        require('https').createServer(options, app).listen(CONFIG.ssl.port);\n    }\n\n    return app;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst path = require('path');\nconst fs = require('fs');\nconst https = require('https');\n\nfunction createExpressApp() {\n    const app = express();\n\n    app.use(cors({\n        origin: CONFIG.cors.origins,\n        methods: CONFIG.cors.methods,\n        allowedHeaders: CONFIG.cors.headers\n    }));\n\n    app.use(helmet());\n    app.use(helmet.hsts({\n        maxAge: 31536000,\n        includeSubDomains: true,\n        preload: true\n    }));\n    app.use(helmet.frameguard({ action: 'deny' }));\n    app.use(helmet.noSniff());\n    app.use(helmet.xssFilter());\n    app.use(express.json());\n    app.use(express.urlencoded({ extended: true }));\n\n    if (process.env.NODE_ENV !== 'production') {\n        app.use(morgan('dev'));\n    }\n\n    app.use((req, res, next) => {\n        res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');\n        res.set('Pragma', 'no-cache');\n        res.set('Expires', '0');\n        res.set('Surrogate-Control', 'no-store');\n        next();\n    });\n\n    app.use('/api', require('./routes/api'));\n    app.use('/static', express.static(path.join(__dirname, 'public')));\n\n    app.use((req, res, next) => {\n        const error = new Error('Not Found');\n        error.status = 404;\n        next(error);\n    });\n\n    app.use((err, req, res, next) => {\n        res.status(err.status || 500).json({\n            error: {\n                message: err.message,\n                status: err.status || 500\n            }\n        });\n    });\n\n    const httpServer = app.listen(CONFIG.server.httpPort, () => {\n        console.log(`HTTP Server running on port ${CONFIG.server.httpPort}`);\n    });\n\n    if (CONFIG.server.httpsEnabled) {\n        const httpsOptions = {\n            key: fs.readFileSync(CONFIG.server.ssl.keyPath),\n            cert: fs.readFileSync(CONFIG.server.ssl.certPath)\n        };\n        const httpsServer = https.createServer(httpsOptions, app).listen(CONFIG.server.httpsPort, () => {\n            console.log(`HTTPS Server running on port ${CONFIG.server.httpsPort}`);\n        });\n    }\n\n    return app;\n}"
  }
]