[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Implement a class for interacting with the EXMO cryptocurrency exchange API, handling authentication, request signing, and response processing.\n\nClass Description: The Trader class provides methods to authenticate and send signed requests to the EXMO API. It handles nonce generation, request signing using HMAC-SHA512, and response error handling.\n\nAttributes:\n- key: [String] - API key for authentication\n- secret: [String] - API secret for request signing\n- currency: [String] - Base currency for trading pairs\n- asset: [String] - Asset currency for trading pairs\n- pair: [String] - Combined trading pair in format 'asset_currency'\n- name: [String] - Exchange name (fixed as 'EXMO')\n- nonce: [Number] - Counter for API requests to prevent replay attacks\n\nMethods:\n- constructor(config) -> [Void] - Initializes the trader instance with configuration including API keys and currency pairs\n- api_query(method, params, callback) -> [Void] - Makes authenticated POST requests to the EXMO API\n  - method: [String] - API endpoint method\n  - params: [Object] - Request parameters\n  - callback: [Function] - Callback function to handle response (error, data)",
    "Canonical_solution": "const CryptoJS = require(\"crypto-js\");\nconst querystring = require('querystring');\nconst request = require('request');\n\nclass Trader {\n  constructor(config) {\n    this.key = \"\";\n    this.secret = \"\";\n    \n    if(_.isObject(config)) {\n      if(_.isString(config.key)) this.key = config.key;\n      if(_.isString(config.secret)) this.secret = config.secret;\n      this.currency = config.currency;\n      this.asset = config.asset;\n      this.pair = this.asset + '_' + this.currency;\n    };\n\n    this.name = 'EXMO';\n    this.nonce = new Date() * 1000;\n  }\n\n  api_query(method, params, callback) {\n    params.nonce = this.nonce++;\n    var post_data = querystring.stringify(params);\n\n    var options = {\n      url: API_URL + method,\n      headers: {'Key': this.key,'Sign': CryptoJS.HmacSHA512(post_data, this.secret).toString(CryptoJS.enc.hex) },\n      form: params\n    };\n    \n    request.post(options, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        data=JSON.parse(body);          \n        if(data.error) error = { message: data.error }\n        else if (data.result!=undefined && data.result==false)  error = { message: '\"result\": false' } ;\n        callback(error, data);\n      } else {\n        console.log('cb request error');\n        console.log(body);\n\n        if(error) {\n          if(includes(error.message, recoverableErrors)) {\n            error.notFatal = true;\n          }\n          console.log(error);\n          callback(error);\n        };\n      };\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class Trader {\n  constructor(config) {\n    this.key = config.key;\n    this.secret = config.secret;\n    this.currency = config.currency;\n    this.asset = config.asset;\n    this.pair = this.asset + '_' + this.currency;\n    this.name = 'EXMO';\n    this.nonce = Math.floor(Date.now() / 1000);\n  }\n\n  api_query(method, params, callback) {\n    this.nonce++;\n    let postData = new URLSearchParams();\n    postData.append('nonce', this.nonce);\n    for (let key in params) {\n      postData.append(key, params[key]);\n    }\n\n    const postBody = postData.toString();\n    const signature = crypto.createHmac('sha512', this.secret).update(postBody).digest('hex');\n\n    fetch('https://api.exmo.com/v1.1/' + method, {\n      method: 'POST',\n      headers: {\n        'Key': this.key,\n        'Sign': signature,\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body: postBody\n    })\n    .then(response => {\n      if (!response.ok) {\n        throw new Error(`EXMO API error ${response.status}: ${response.statusText}`);\n      }\n      return response.json();\n    })\n    .then(data => {\n      if (data.error) {\n        throw new Error(`EXMO API error: ${data.error}`);\n      }\n      callback(null, data);\n    })\n    .catch(error => {\n      callback(error, null);\n    });\n  }\n}\n"
  },
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create a function that sets up an Express server with various route handlers for handling HTTP requests related to email functionality, including authentication, sending test emails, and managing email server configurations.\n\nFunction Description: The function `setupExpressServer` initializes an Express server with middleware for parsing request bodies and cookies. It defines several route handlers for different HTTP methods (GET, POST) that handle email-related operations such as authentication, sending test emails, and saving email server configurations. The server listens on a specified port.\n\nInput: None (The function uses module-level variables like `processInfo.port` for configuration)\n\nOutput: None (The function starts a server that listens on the specified port and handles incoming HTTP requests)\n\nNote: The function relies on several external modules and variables that should be available in the scope:\n- `express`: The Express framework\n- `connect`: Middleware for Express\n- `fs`: File system module\n- `nodemailer`: For sending emails\n- `lcrypto`: For encryption\n- `lutil`: For file operations\n- `auth`: A variable storing authentication details\n- `processInfo`: An object containing server configuration (like port number)\n- `locker`: An object containing base URL for locker service\n- `request`: For making HTTP requests",
    "Canonical_solution": "function setupExpressServer() {\n    var express = require('express');\n    var connect = require('connect');\n    var app = express.createServer(connect.bodyParser(), connect.cookieParser());\n    \n    app.set('views', __dirname);\n    \n    app.get('/', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!auth || req.param(\"change\")) return res.end(fs.readFileSync(__dirname + '/auth.html'));\n        res.write(\"<p>Using \"+auth.host+\":\"+auth.port+\" \");\n        if(auth.ssl) res.write(\"(ssl)\");\n        if(auth.user) res.write(\"authenticating as \"+auth.user);\n        res.write(\"<br><a href='?change=1'>change</a> or <a href='javascript:window.location=\\\"test?to=\\\"+window.prompt(\\\"recipient email address\\\")'>send test message</a>\");\n        res.end();\n    });\n    \n    app.post('/save', function(req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!req.body || !req.body.host || !req.body.port) return res.end(\"missing minimum required host/port :(\");\n        nodemailer.SMTP = auth = {host:req.body.host, port:req.body.port, ssl:false};\n        if(req.body.ssl) auth.ssl = true;\n        if(req.body.user && req.body.pass) {\n            auth.use_authentication = true;\n            auth.user = req.body.user;\n            auth.pass = lcrypto.encrypt(req.body.pass);\n        }\n        lutil.atomicWriteFileSync(\"auth.json\", JSON.stringify(auth, null, 4));\n        if(auth.pass) auth.pass = req.body.pass;\n        res.end(\"saved! <a href='./'>continue</a>\");\n    });\n    \n    app.get('/state', function (req, res) {\n        var ready = (auth) ? 1 : 0;\n        res.send({ready:ready});\n    });\n    \n    app.get('/test', function (req, res) {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        if(!req.param(\"to\") || req.param(\"to\").indexOf(\"@\") <= 0) return res.end(\"invalid recipient\")\n        var message = {\n            sender: 'Testificate <42@awesome.com>',\n            to: req.param(\"to\"),\n            subject: 'test message  \u2714',\n            body: 'Hello to you!',\n            html:'<p>it <b>WORKED</b></p>',\n            debug: true\n        };\n        request.post({url:locker.lockerBase + \"/Me/smtp/send\", json:message}, function(err, r, body){\n            if(err || !body) return res.end(\"failed \"+err);\n            return res.end(\"sent!\");\n        });\n    });\n    \n    app.post('/send', function (req, res) {\n        if(!auth) return res.send(false);\n        if (!req.body || !req.body.to) return res.send(false);\n        console.error(\"DEBUG SMTP: \"+JSON.stringify(req.body));\n        var sent = false;\n        nodemailer.send_mail(req.body, function(err, ok){\n            if(sent) return;\n            sent=true;\n            if(err || !ok){\n                console.error('Error occured: '+err);\n                return res.send(false);\n            }\n            res.send(true);\n        })\n    });\n    \n    app.listen(processInfo.port,function() {\n        var returnedInfo = {};\n        console.log(JSON.stringify(returnedInfo));\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nfunction setupExpressServer() {\n  const app = express();\n  app.use(connect.bodyParser());\n  app.use(connect.cookieParser());\n\n  app.get('/sendTestEmail', function(req, res) {\n    const transport = nodemailer.createTransport({\n      host: auth.smtp_server,\n      port: auth.smtp_port,\n      secure: auth.smtp_use_ssl,\n      auth: {\n        user: auth.smtp_username,\n        pass: auth.smtp_password\n      }\n    });\n\n    const mailOptions = {\n      from: auth.smtp_username,\n      to: auth.testEmail,\n      subject: 'Test Email',\n      text: 'This is a test email sent from the server.'\n    };\n\n    transport.sendMail(mailOptions, function(error, info) {\n      if (error) {\n        res.send({ success: false, error: error.message });\n      } else {\n        res.send({ success: true, info: info.response });\n      }\n    });\n  });\n\n\n  app.post('/saveEmailConfig', function(req, res) {\n    const config = req.body;\n    auth.smtp_server = config.smtp_server;\n    auth.smtp_port = config.smtp_port;\n    auth.smtp_use_ssl = config.smtp_use_ssl;\n    auth.smtp_username = config.smtp_username;\n    auth.smtp_password = config.smtp_password;\n    auth.testEmail = config.testEmail;\n\n    res.send({ success: true });\n  });\n\n  app.get('/getEmailConfig', function(req, res) {\n    res.send({\n      smtp_server: auth.smtp_server,\n      smtp_port: auth.smtp_port,\n      smtp_use_ssl: auth.smtp_use_ssl,\n      smtp_username: auth.smtp_username,\n      testEmail: auth.testEmail\n    });\n  });\n\n  app.listen(processInfo.port, function() {\n    console.log('Server listening on port ' + processInfo.port);\n  });\n\n  return app;\n}\n```\n"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a function that sets up an Express server with Socket.IO for real-time communication, including CORS support, route handling, and socket event management for chat room functionality.\n\nFunction Description: The function `setupServer` initializes an Express application with HTTP and WebSocket support. It configures CORS middleware, handles socket connections for chat room operations (joining, messaging, disconnecting), and starts the server on a specified port. The function integrates Express routing and Socket.IO events to manage real-time communication between clients in different rooms.\n\nInput: None (The function uses environment variables for port configuration, with a default fallback to port 5000)\n\nOutput: None (The function starts a server process that listens for incoming HTTP and WebSocket connections, but doesn't return any value)",
    "Canonical_solution": "function setupServer() {\n    const http = require('http');\n    const express = require('express');\n    const socketio = require('socket.io');\n    const cors = require('cors');\n    \n    const app = express();\n    const server = http.createServer(app);\n    const io = socketio(server);\n    \n    app.use(cors());\n    app.use(router);\n    \n    io.on('connect', (socket) => {\n        socket.on('join', ({ name, room }, callback) => {\n            const { error, user } = addUser({ id: socket.id, name, room });\n            if(error) return callback(error);\n            socket.join(user.room);\n            socket.emit('message', { user: 'admin', text: `${user.name}, welcome to room ${user.room}.`});\n            socket.broadcast.to(user.room).emit('message', { user: 'admin', text: `${user.name} has joined!` });\n            io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room) });\n            callback();\n        });\n        \n        socket.on('sendMessage', (message, callback) => {\n            const user = getUser(socket.id);\n            io.to(user.room).emit('message', { user: user.name, text: message });\n            callback();\n        });\n        \n        socket.on('disconnect', () => {\n            const user = removeUser(socket.id);\n            if(user) {\n                io.to(user.room).emit('message', { user: 'Admin', text: `${user.name} has left.` });\n                io.to(user.room).emit('roomData', { room: user.room, users: getUsersInRoom(user.room)});\n            }\n        });\n    });\n    \n    server.listen(process.env.PORT || 5000, () => console.log(`Server has started.`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\nconst cors = require('cors');\n\nconst setupServer = () => {\n  const app = express();\n  const server = http.createServer(app);\n  const io = new Server(server, {\n    cors: {\n      origin: '*',\n      methods: ['GET', 'POST'],\n    },\n  });\n\n  app.use(cors());\n\n  io.on('connection', (socket) => {\n    console.log('A user connected');\n\n    socket.on('joinRoom', (room) => {\n      socket.join(room);\n      console.log(`User joined room: ${room}`);\n      socket.emit('message', { user: 'admin', text: `Welcome to room ${room}` });\n      socket.to(room).emit('message', { user: 'admin', text: `A new user has joined!` });\n    });\n\n    socket.on('sendMessage', (message) => {\n      const room = Object.keys(socket.rooms).find((r) => r !== socket.id);\n      if (room) {\n        io.to(room).emit('message', message);\n      }\n    });\n\n    socket.on('disconnect', () => {\n      console.log('User disconnected');\n      const room = Object.keys(socket.rooms).find((r) => r !== socket.id);\n      if (room) {\n        socket.to(room).emit('message', { user: 'admin', text: `A user has left the room` });\n      }\n    });\n  });\n\n\n  const PORT = process.env.PORT || 5000;\n  server.listen(PORT, () => console.log(`Server has started on port ${PORT}`));\n};\n\nsetupServer();\n\n"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Create a function that initializes and starts an HTTP server with WebSocket support using Express and Socket.IO, implementing a particle simulation system with cluster and client event handling.\n\nFunction Description: The function `startServer` initializes an Express application, sets up static file serving, integrates Socket.IO for real-time communication, and configures a particle simulation system with collision detection and cluster management. It handles particle movement, boundary collisions, and client interactions through defined event handlers.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function starts a server listening on port 3000 but doesn't return any value)",
    "Canonical_solution": "function startServer() {\n    const express = require('express');\n    const app = express();\n    const server = require('http').Server(app);\n    const io = require('socket.io')(server);\n    const swip = require('../../../src/server/index.js');\n\n    app.use(express.static(__dirname + './../static'));\n\n    swip(io, {\n        cluster: {\n            events: {\n                update: (cluster) => {\n                    const blobs = cluster.data.blobs;\n                    const clients = cluster.clients;\n\n                    const updatedBlobs = blobs.map((blob) => {\n                        const boundaryOffset = blob.size;\n                        const client = clients.find((c) => isParticleInClient(blob, c));\n\n                        let nextPosX = blob.x + blob.speedX;\n                        let nextPosY = blob.y + blob.speedY;\n                        let nextSpeedX = blob.speedX;\n                        let nextSpeedY = blob.speedY;\n\n                        if (client) {\n                            if (((blob.speedX < 0) &&\n                                ((nextPosX - boundaryOffset) < client.transform.x)\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.left, nextPosY))) {\n                                nextPosX = client.transform.x + boundaryOffset;\n                                nextSpeedX = blob.speedX * -1;\n                            } else if (((blob.speedX > 0) &&\n                                ((nextPosX + boundaryOffset) > (client.transform.x + client.size.width))\n                                && !isWallOpenAtPosition(client.transform.y, client.openings.right, nextPosY))) {\n                                nextPosX = client.transform.x + (client.size.width - boundaryOffset);\n                                nextSpeedX = blob.speedX * -1;\n                            }\n\n                            if (((blob.speedY < 0) &&\n                                ((nextPosY - boundaryOffset) < client.transform.y\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.top, nextPosX)))) {\n                                nextPosY = client.transform.y + boundaryOffset;\n                                nextSpeedY = blob.speedY * -1;\n                            } else if (((blob.speedY > 0) &&\n                                ((nextPosY + boundaryOffset) > (client.transform.y + client.size.height))\n                                && !isWallOpenAtPosition(client.transform.x, client.openings.bottom, nextPosX))\n                            ) {\n                                nextPosY = client.transform.y + (client.size.height - boundaryOffset);\n                                nextSpeedY = blob.speedY * -1;\n                            }\n                        } else {\n                            const firstClient = clients[0];\n                            nextPosX = firstClient.transform.x + (firstClient.size.width / 2);\n                            nextPosY = firstClient.transform.y + (firstClient.size.height / 2);\n                            nextSpeedX = 0;\n                            nextSpeedY = 0;\n                        }\n\n                        blob.x = nextPosX;\n                        blob.y = nextPosY;\n                        blob.speedX = nextSpeedX;\n                        blob.speedY = nextSpeedY;\n\n                        return blob;\n                    });\n\n                    return {\n                        blobs: { $set: updatedBlobs },\n                    };\n                },\n                merge: (cluster1, cluster2, transform) => ({\n                    blobs: { $set: getNewParticleDist(cluster1, cluster2, transform) },\n                    backgroundColor: { $set: cluster1.data.backgroundColor },\n                }),\n            },\n            init: () => ({ blobs: [], backgroundColor: getRandomColor() }),\n        },\n\n        client: {\n            init: () => ({}),\n            events: {\n                addBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $push: blobs } },\n                        },\n                    };\n                },\n                updateBlobs: ({ cluster, client }, { blobs }) => {\n                    return {\n                        cluster: {\n                            data: { blobs: { $set: blobs } },\n                        },\n                    };\n                },\n            },\n        },\n    });\n\n    server.listen(3000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst http = require('http');\nconst socketio = require('socket.io');\n\nfunction startServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketio(server);\n\n  app.use(express.static(__dirname + '/public'));\n\n  const particles = [];\n  const particleCount = 100;\n\n  for (let i = 0; i < particleCount; i++) {\n    particles.push({\n      x: Math.random() * 500,\n      y: Math.random() * 500,\n      vx: Math.random() * 2 - 1,\n      vy: Math.random() * 2 - 1,\n      radius: 5\n    });\n  }\n\n  io.on('connection', (socket) => {\n    console.log('Client connected');\n\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n  setInterval(() => {\n    for (let i = 0; i < particleCount; i++) {\n      particles[i].x += particles[i].vx;\n      particles[i].y += particles[i].vy;\n\n      if (particles[i].x < 0 || particles[i].x > 500) {\n        particles[i].vx *= -1;\n      }\n      if (particles[i].y < 0 || particles[i].y > 500) {\n        particles[i].vy *= -1;\n      }\n    }\n\n    io.emit('particleData', particles);\n  }, 16);\n\n\n  server.listen(3000, () => {\n    console.log('Server listening on port 3000');\n  });\n}\n\nstartServer();\n\n"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a function that sets up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB, integrates with Next.js for server-side rendering, and sets up basic route handling. It prepares the Next.js application, configures middleware, and starts the server on a specified port.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret for session encryption)\n\nOutput: Returns a Promise that resolves to the configured Express server instance when the Next.js app is prepared and the server is listening on the specified port.",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  return app.prepare().then(async () => {\n    const server = express();\n\n    server.use(express.json());\n\n    const sessionOptions = {\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: mongoSessionStore.create({\n        mongoUrl: MONGO_URL,\n        ttl: 14 * 24 * 60 * 60,\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 14 * 24 * 60 * 60 * 1000,\n        domain: 'localhost',\n      },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => {\n      const url = URL_MAP[req.path];\n      if (url) {\n        app.render(req, res, url);\n      } else {\n        handle(req, res);\n      }\n    });\n\n    server.listen(port, (err) => {\n      if (err) throw err;\n      console.log(`> Ready on ${ROOT_URL}`);\n    });\n\n    return server;\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst connectMongo = require('connect-mongo');\nconst mongoose = require('mongoose');\n\nconst MongoStore = connectMongo(session);\n\nconst setupServer = async () => {\n  const dev = process.env.NODE_ENV !== 'production';\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n  await app.prepare();\n\n  const server = express();\n\n  await mongoose.connect(process.env.MONGO_URL_TEST, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n  });\n\n  server.use(\n    session({\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: new MongoStore({\n        mongooseConnection: mongoose.connection,\n        ttl: 14 * 24 * 60 * 60, // save session 14 days\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 1000 * 60 * 60 * 24 * 14, // 14 days\n        sameSite: 'lax',\n      },\n    })\n  );\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  return new Promise((resolve) => {\n    server.listen(port, () => {\n      resolve(server);\n    });\n  });\n};\n\nmodule.exports = setupServer;\n\n```"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by:\n1. Maintaining a mapping of known URL shortening services\n2. Using service-specific APIs when available\n3. Falling back to generic HTTP HEAD requests to follow redirects\n4. Preventing infinite loops through depth tracking and URL history\n\nAttributes:\nmap: [Object] - A mapping of URL shortening services to their known domains\ntimeout: [Number] - HTTP request timeout in milliseconds (default: 5000)\n\nMethods:\nconstructor() -> [URLExpander] - Initializes the URL expander with default configuration\n\nexpand: [Function](args: Object, callback: Function) -> [void] - Main method to expand a URL\n- args: Object containing:\n  - url: String - The URL to expand\n  - depth: Number - Current recursion depth (optional)\n  - seen: Object - Map of previously seen URLs (optional)\n- callback: Function to receive the result with expanded args object\n\nAPIs: [Object] - Collection of service-specific expansion methods:\n- isgd: [Function](args: Object, callback: Function) -> [void] - Expands is.gd URLs\n- googl: [Function](args: Object, callback: Function) -> [void] - Expands goo.gl URLs\n- budurl: [Function](args: Object, callback: Function) -> [void] - Expands budurl.com URLs\n- snipurl: [Function](args: Object, callback: Function) -> [void] - Expands snipurl.com and related URLs\n- generic: [Function](args: Object, callback: Function) -> [void] - Generic URL expansion using HTTP HEAD requests",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      isgd: ['is.gd'],\n      googl: ['goo.gl'],\n      budurl: ['budurl.com'],\n      snipurl: ['snipurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'tinyurl.com', 'sn.im']\n    };\n    this.timeout = 5000;\n  }\n\n  expand(args, callback) {\n    let { url, depth = 0, seen = {} } = args;\n\n    if (depth > 5 || seen[url]) {\n      return callback(args);\n    }\n    seen[url] = true;\n\n    let service = Object.keys(this.map).find(key => this.map[key].some(domain => url.includes(domain)));\n\n    if (service && this.APIs[service]) {\n      this.APIs[service](args, callback);\n    } else {\n      this.APIs.generic(args, callback);\n    }\n  }\n\n\n  APIs = {\n    isgd: (args, callback) => {\n      const { url } = args;\n      fetch(`https://is.gd/forward.php?format=json&shorturl=${url}`, { redirect: 'manual' })\n        .then(res => res.json())\n        .then(data => {\n          if (data && data.url) {\n            args.url = data.url;\n          }\n          this.expand(args, callback);\n        })\n        .catch(() => this.APIs.generic(args, callback));\n    },\n\n    googl: (args, callback) => this.APIs.generic(args, callback), // Placeholder for future goo.gl API integration\n\n    budurl: (args, callback) => this.APIs.generic(args, callback), // Placeholder for future budurl API integration\n\n    snipurl: (args, callback) => this.APIs.generic(args, callback), // Placeholder for future snipurl API integration\n\n    generic: (args, callback) => {\n      const { url, depth } = args;\n      fetch(url, { method: 'HEAD', redirect: 'manual', timeout: this.timeout })\n        .then(res => {\n          if (res.redirected && res.url) {\n            args.url = res.url;\n            args.depth = depth + 1;\n            this.expand(args, callback);\n          } else {\n            callback(args);\n          }\n        })\n        .catch(() => callback(args));\n    }\n  };\n}\n\n```"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Create a function to set up an Express server with Next.js integration, MongoDB session storage, and basic route handling.\n\nFunction Description: The function `setupServer` initializes and configures an Express server with session management using MongoDB as the session store. It integrates Next.js for server-side rendering and sets up a catch-all route handler. The server listens on a specified port and connects to MongoDB using environment variables for configuration.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Server port (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that:\n- Listens on the specified port\n- Outputs the server URL to console when ready\n- Maintains persistent connections to MongoDB for session storage)",
    "Canonical_solution": "function setupServer() {\n  const express = require('express');\n  const session = require('express-session');\n  const mongoSessionStore = require('connect-mongo');\n  const next = require('next');\n  const mongoose = require('mongoose');\n\n  const dev = process.env.NODE_ENV !== 'production';\n  const MONGO_URL = process.env.MONGO_URL_TEST;\n  const port = process.env.PORT || 8000;\n  const ROOT_URL = `http://localhost:${port}`;\n\n  mongoose.connect(MONGO_URL);\n\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  const server = express();\n\n  const sessionOptions = {\n    name: process.env.SESSION_NAME,\n    secret: process.env.SESSION_SECRET,\n    store: mongoSessionStore.create({\n      mongoUrl: MONGO_URL,\n      ttl: 14 * 24 * 60 * 60,\n    }),\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      httpOnly: true,\n      maxAge: 14 * 24 * 60 * 60 * 1000,\n      domain: 'localhost',\n    },\n  };\n\n  const sessionMiddleware = session(sessionOptions);\n  server.use(sessionMiddleware);\n\n  server.get('*', (req, res) => handle(req, res));\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on ${ROOT_URL}`);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst connectMongo = require('connect-mongo');\nconst mongoose = require('mongoose');\n\nconst MongoStore = connectMongo(session);\n\nconst setupServer = async () => {\n  const dev = process.env.NODE_ENV !== 'production';\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n\n  await app.prepare();\n\n  const server = express();\n\n  server.use(express.json());\n\n  const mongoUrl = process.env.MONGO_URL_TEST;\n\n  await mongoose.connect(mongoUrl, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n    useFindAndModify: false,\n    useCreateIndex: true,\n  });\n\n  server.use(\n    session({\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: new MongoStore({ mongooseConnection: mongoose.connection }),\n      cookie: {\n        maxAge: 1000 * 60 * 60 * 24 * 30, // 30 days\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n      },\n      resave: false,\n      saveUninitialized: false,\n      rolling: true,\n    })\n  );\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  const port = process.env.PORT || 8000;\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n};\n\nmodule.exports = setupServer;\n\n```"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a function that sets up a proxy server using Express and http-proxy-middleware to forward requests to a target API while modifying request and response headers.\n\nFunction Description: The function `createProxyServer` initializes an Express application that acts as a proxy server. It configures middleware to forward all incoming requests to a specified target API (https://api.openai.com in this case), removes certain headers from outgoing requests, and adds CORS headers to responses. The server listens on port 9000 by default.\n\nInput: None (The function takes no parameters as all configurations are hardcoded)\n\nOutput: None (The function doesn't return anything but starts a server process that continues running)",
    "Canonical_solution": "function createProxyServer() {\n    const express = require('express');\n    const { createProxyMiddleware } = require('http-proxy-middleware');\n    const app = express();\n    const port = 9000;\n\n    app.use('/', createProxyMiddleware({\n        target: 'https://api.openai.com',\n        changeOrigin: true,\n        onProxyReq: (proxyReq, req, res) => {\n            proxyReq.removeHeader('x-forwarded-for');\n            proxyReq.removeHeader('x-real-ip');\n        },\n        onProxyRes: function (proxyRes, req, res) {\n            proxyRes.headers['Access-Control-Allow-Origin'] = '*';\n        }\n    }));\n\n    app.listen(port, () => {\n        console.log(`Example app listening at http://localhost:${port}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nconst app = express();\n\nconst proxyOptions = {\n  target: 'https://api.openai.com',\n  changeOrigin: true,\n  onProxyReq: (proxyReq, req) => {\n    proxyReq.removeHeader('origin');\n    proxyReq.removeHeader('referer');\n  },\n  onProxyRes: (proxyRes, req, res) => {\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  },\n};\n\napp.use('/', createProxyMiddleware(proxyOptions));\n\napp.listen(9000);\n\n```\n"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Twitter Search Client class that handles searching tweets, managing search state, and storing results locally.\n\nClass Description: TSClient is a Twitter search client that performs searches, tracks search state (including pagination and since_id), caches results to local files, and provides synchronization capabilities.\n\nAttributes:\n- search: [Object] - Contains search parameters and state including query (q), since_id, result count (rcount), and a unique search id\n- id: [String] - MD5 hash of the search query used as a unique identifier\n- new_since_id: [String] - Tracks the newest tweet ID retrieved during the current sync\n\nMethods:\n- constructor(query, cb) -> [TSClient] - Initializes a new search client with the given query. Creates a unique ID for the search and loads previous state if available. Calls the callback with the initialized client.\n  - query: [String] - The search query string\n  - cb: [Function] - Callback function that receives the initialized TSClient instance\n\n- syncSearch(callback) -> [void] - Initiates a new synchronization of search results, walking through paginated results.\n  - callback: [Function] - Called with the array of results when sync completes\n\n- set(search) -> [void] - Updates the search state and persists it to disk.\n  - search: [Object] - The search state object to save\n\n- _walker(s) -> [void] - Internal recursive method that handles pagination through search results.\n  - s: [Object] - State object containing:\n    - ts: [TSClient] - Reference to the TSClient instance\n    - search: [Object] - Current search parameters\n    - cb: [Function] - Completion callback\n    - page: [Number] - Current page number\n    - results: [Array] - Accumulated results\n    - new_since_id: [String] - Newest tweet ID in current batch (optional)",
    "Canonical_solution": "var request = require('request');\nvar url = require('url');\n\nclass TSClient {\n    constructor(query, cb) {\n        this.search = {};\n        this.search.q = query;\n        this.search.since_id = 0;\n        this.search.rcount = 0;\n        var hash = crypto.createHash('md5');\n        hash.update(query);\n        this.search.id = hash.digest('hex');\n        var self = this;\n        lfs.readObjectFromFile(self.search.id+'.search', function(data) {\n            if(data && data.id) {\n                self.search = data;            \n            } else {\n                lfs.writeObjectToFile(self.search.id+'.search',self.search);\n            }\n            cb(self);\n        });\n    }\n\n    syncSearch(callback) {\n        console.log(\"new sync \"+JSON.stringify(this.search));\n        this._walker({ts:this, search:this.search, cb:callback, page:1, results:[]});\n    }\n\n    set(search) {\n        this.search = search;\n        lfs.writeObjectToFile(search.id+'.search',search);    \n    }\n\n    _walker(s) {\n        var uri = url.parse(\"http://search.twitter.com/search.json\");\n        uri.query = {q:s.search.q, rpp:100, page:s.page, since_id:s.search.since_id};\n        console.log(\"walking page \"+url.format(uri));\n        request.get({uri:url.format(uri)}, function(err, resp, body) {\n            if(err) {\n                console.log(\"request failed: \"+err);\n                s.cb([]);\n                return;\n            }\n            var data = JSON.parse(body);\n            if(data && data.results && data.results.length > 0) {\n                s.results = s.results.concat(data.results);\n                s.page++;\n                console.log(\"page \"+data.page+\" and max \"+data.max_id_str);\n                if(data.page == 1) s.new_since_id = data.max_id_str;\n            } else {\n                s.page=16;\n            }\n            if(s.page <= 15) {\n                this._walker(s);\n            } else {\n                console.log(\"saving \"+s.results.length+\" tweets\");\n                lfs.writeObjectsToFile(s.search.id+'.tweets',s.results);\n                s.search.rcount += s.results.length;\n                if(s.new_since_id) s.search.since_id = s.new_since_id;\n                s.ts.set(s.search);\n                s.cb(s.results);\n            }\n        }.bind(this));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst crypto = require('crypto');\nconst fs = require('fs');\n\nclass TSClient {\n  constructor(query, cb) {\n    this.search = { q: query, since_id: 1, rcount: 100 };\n    this.id = crypto.createHash('md5').update(query).digest('hex');\n    try {\n      const savedState = JSON.parse(fs.readFileSync(`./${this.id}.json`));\n      this.search = { ...this.search, ...savedState };\n    } catch (e) {}\n    cb(this);\n  }\n\n  syncSearch(callback) {\n    this._walker({\n      ts: this,\n      search: this.search,\n      cb: callback,\n      page: 1,\n      results: [],\n    });\n  }\n\n\n  set(search) {\n    this.search = search;\n    fs.writeFileSync(`./${this.id}.json`, JSON.stringify(search));\n  }\n\n  _walker(s) {\n    // Replace this with your actual Twitter API call\n    const mockTwitterApiCall = (search, page) => new Promise(resolve => {\n      const mockResults = Array(search.rcount).fill(null).map((_, i) => ({ id: search.since_id + page * search.rcount + i, text: `Mock tweet ${search.since_id + page * search.rcount + i}` }));\n      if (page > 2) mockResults.length = 0; // Simulate end of results\n      setTimeout(() => resolve({ statuses: mockResults }), 500);\n    });\n\n    mockTwitterApiCall(s.search, s.page).then(data => {\n      if (data.statuses && data.statuses.length > 0) {\n        s.results = s.results.concat(data.statuses);\n        s.new_since_id = data.statuses[data.statuses.length -1].id;\n        s.page++;\n        s.ts.search.since_id = s.new_since_id;\n        s.ts.set(s.ts.search);\n        s.ts._walker(s);\n      } else {\n        s.cb(s.results);\n      }\n    });\n  }\n}\n\n```\n"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a function that sets up and starts an Express server with basic configuration, static file serving, and additional route handlers.\n\nFunction Description: The function `createExpressServer` initializes an Express application, configures it to serve static files from a parent directory, integrates additional route handlers from a separate module, and starts listening on a specified port (either from environment variables or defaulting to 3000).\n\nInput: None (The function takes no parameters but uses environment variables for configuration)\n\nOutput: Returns the HTTP server instance created by `app.listen()`, which is actively listening on the specified port. The function also logs server start information to the console.",
    "Canonical_solution": "function createExpressServer() {\n    const express = require('express');\n    const app = express();\n\n    app.set('port', process.env.PORT || 3000);\n    app.use(express.static('../'));\n\n    require('./src-server/multerImpl')(app);\n\n    return app.listen(app.get('port'), () => {\n        console.log('Express server listening on port ' + app.get('port'));\n        console.log('Visit http://localhost:' + app.get('port') + '/example/ to check out the upload example');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst path = require('path');\nconst additionalRoutes = require('./additional-routes');\n\nfunction createExpressServer() {\n  const app = express();\n  const port = process.env.PORT || 3000;\n\n  app.use(express.static(path.join(__dirname, '..')));\n\n  app.use('/api', additionalRoutes);\n\n  const server = app.listen(port, () => {\n    console.log(`Server listening at http://localhost:${port}`);\n  });\n\n  return server;\n}\n\nmodule.exports = createExpressServer;\n// additional-routes.js\nconst express = require('express');\nconst router = express.Router();\n\nrouter.get('/test', (req, res) => {\n  res.json({ message: 'Test route working' });\n});\n\nmodule.exports = router;\n"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Create a function that uploads a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function uploads a specified file to a server using Node.js's filesystem and HTTP modules. It streams the file content directly to the HTTP request using pipe(), avoiding loading the entire file into memory. The function sets appropriate headers including content-type (multipart/form-data) and content-length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart form data\n\nOutput: None (The function makes an HTTP request but doesn't return any value. The actual upload result would be handled by the server's response, which isn't captured in this function.)",
    "Canonical_solution": "function uploadFile() {\n  const fs = require('fs');\n  const http = require('http');\n  \n  const stat = fs.statSync(FIXTURE);\n  const request = http.request({\n    port: TEST_PORT,\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'content-length': stat.size,\n    },\n  });\n  \n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const stat = fs.statSync(FIXTURE);\n  const headers = {\n    'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n    'Content-Length': stat.size,\n  };\n\n  const options = {\n    port: TEST_PORT,\n    path: '/upload',\n    method: 'POST',\n    headers: headers,\n  };\n\n  const req = http.request(options);\n  fs.createReadStream(FIXTURE).pipe(req);\n}\n\n```"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Implement a function to upload a file to a server using HTTP POST request with streaming capability to handle large files efficiently.\n\nFunction Description: The function should create a readable stream from a specified file and pipe it directly to an HTTP POST request. This approach avoids loading the entire file into memory, making it suitable for large files. The function should set appropriate headers including content type (multipart/form-data) and content length.\n\nInput:\n- FIXTURE: [String] - Path to the file to be uploaded\n- TEST_PORT: [Number] - Port number of the server to upload to\n- BOUNDARY: [String] - Boundary string for multipart/form-data content type\n\nOutput: None (The function streams the file directly to the HTTP request without returning any value)",
    "Canonical_solution": "function uploadFile() {\n  var fs = require('fs'),\n      http = require('http'),\n      stat = fs.statSync(FIXTURE),\n      request = http.request({\n        port: TEST_PORT,\n        path: '/',\n        method: 'POST',\n        headers: {\n          'content-type': 'multipart/form-data; boundary='+BOUNDARY,\n          'content-length': stat.size,\n        },\n      });\n  fs.createReadStream(FIXTURE).pipe(request);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 99,
    "wrong_result": "```javascript\nconst fs = require('fs');\nconst http = require('http');\n\nfunction uploadFile(FIXTURE, TEST_PORT, BOUNDARY) {\n  const stats = fs.statSync(FIXTURE);\n  const fileSizeInBytes = stats.size;\n\n  const options = {\n    hostname: 'localhost',\n    port: TEST_PORT,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': `multipart/form-data; boundary=${BOUNDARY}`,\n      'Content-Length': fileSizeInBytes,\n    },\n  };\n\n  const req = http.request(options);\n\n  const readStream = fs.createReadStream(FIXTURE);\n\n  readStream.pipe(req);\n\n  req.on('error', (error) => {\n    console.error('Error uploading file:', error);\n  });\n\n  req.on('finish', () => {\n    console.log('File uploaded successfully');\n  });\n}\n\n```"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Create a function that makes an HTTP POST request to a specified URL with custom headers and data, then handles the response.\n\nFunction Description: The function `makeHttpRequest` sends an HTTP POST request to a given URL with specified headers and a data payload. It uses the `request` module to perform the HTTP request and includes a callback function to handle the response or errors. The function is designed to be reusable for making HTTP POST requests with minimal configuration.\n\nInput: \n- None (The URL, headers, and data are hardcoded within the function for simplicity. In a real-world scenario, these could be passed as parameters.)\n\nOutput: \n- None (The function logs the response body to the console if the request is successful. In a real-world scenario, the response could be returned or processed further.)\n\nNote: The function assumes the `request` module is available in the environment. If not, it must be installed via npm or another package manager.",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    };\n\n    var dataString = '18233982904';\n\n    var options = {\n        url: 'http://localhost:28139/CurlToNode',\n        method: 'POST',\n        headers: headers,\n        body: dataString\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst request = require('request');\n\nfunction makeHttpRequest() {\n  const url = 'https://jsonplaceholder.typicode.com/posts';\n  const headers = {\n    'Content-Type': 'application/json',\n    'User-Agent': 'MyCustomAgent',\n  };\n  const data = {\n    title: 'foo',\n    body: 'bar',\n    userId: 1,\n  };\n\n  request.post(\n    {\n      url: url,\n      headers: headers,\n      json: data,\n    },\n    (error, response, body) => {\n      if (error) {\n        console.error('Error:', error);\n      } else if (response.statusCode !== 201) {\n        console.error('Status Code:', response.statusCode);\n        console.error('Response Body:', body);\n      } else {\n        console.log('Response Body:', body);\n      }\n    }\n  );\n}\n\nmakeHttpRequest();\n\n```"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to generate PDFs from HTML templates and serve them as streams.\n\nFunction Description: The function `createServer` initializes an HTTP server that listens on port 8080. It serves PDF files generated from an HTML template, replacing placeholders with actual image paths, and streams the PDF output to the client. The server handles incoming requests, checks for favicon requests, and responds with either a 404 error or the generated PDF.\n\nInput: None (The function does not take any input parameters.)\n\nOutput: None (The function does not return any value but starts an HTTP server that listens on port 8080 and logs the server address to the console.)",
    "Canonical_solution": "function createServer() {\n    const fs = require('fs');\n    const http = require('http');\n    const pdf = require('../../');\n    const tmpl = fs.readFileSync(require.resolve('../businesscard/businesscard.html'), 'utf8');\n\n    const server = http.createServer(function (req, res) {\n        if (req.url === '/favicon.ico') return res.end('404');\n        const html = tmpl.replace('{{image}}', `file://${require.resolve('../businesscard/image.png')}`);\n        pdf.create(html, {width: '50mm', height: '90mm'}).toStream((err, stream) => {\n            if (err) return res.end(err.stack);\n            res.setHeader('Content-type', 'application/pdf');\n            stream.pipe(res);\n        });\n    });\n\n    server.listen(8080, function (err) {\n        if (err) throw err;\n        console.log('Listening on http://localhost:%s', server.address().port);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst puppeteer = require('puppeteer');\n\nasync function createServer() {\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/favicon.ico') {\n      res.writeHead(404);\n      res.end();\n      return;\n    }\n\n    try {\n      const browser = await puppeteer.launch();\n      const page = await browser.newPage();\n\n      const templatePath = path.join(__dirname, 'template.html');\n      const htmlTemplate = fs.readFileSync(templatePath, 'utf-8');\n\n      const html = htmlTemplate\n        .replace('{{image1}}', 'image1.jpg')\n        .replace('{{image2}}', 'image2.png');\n\n\n      await page.setContent(html);\n\n      const pdfBuffer = await page.pdf({ format: 'A4' });\n\n      await browser.close();\n\n      res.writeHead(200, {\n        'Content-Type': 'application/pdf',\n        'Content-Disposition': 'inline; filename=generated.pdf',\n        'Content-Length': pdfBuffer.length\n      });\n      res.end(pdfBuffer);\n    } catch (error) {\n      console.error('Error generating PDF:', error);\n      res.writeHead(500);\n      res.end('Error generating PDF');\n    }\n  });\n\n  server.listen(8080, () => {\n    console.log(`Server listening on http://localhost:8080`);\n  });\n}\n\ncreateServer();\n\n```\n"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Create a JavaScript class that implements a server capable of handling HTTP requests and piping data to responses, with support for live reload functionality and error handling.\n\nClass Description: The `Server` class is designed to create an HTTP server that can handle incoming requests, pipe data to responses (particularly for live reload functionality), and manage server lifecycle events. It supports both standalone operation and integration with existing Express-like applications.\n\nAttributes:\n- options: [Object] - Configuration options for the server including livereload file path and port number.\n- clients: [Object] - Storage for connected clients (used for live reload functionality).\n- server: [http.Server] - The underlying HTTP server instance.\n- app: [Object] - Optional Express-like application instance for integration.\n- port: [Number] - The port number the server is listening on.\n\nMethods:\n- constructor(options) -> [Server] - Initializes the server with given options, setting defaults for livereload path and port.\n- configure(app) -> [Server] - Configures the server to work with an existing Express-like application.\n- handler(req, res, next) -> [Server] - Handles incoming HTTP requests, supporting both middleware and direct handling modes.\n- livereload(req, res) -> [void] - Pipes the livereload JavaScript file to the response.\n- listen(port, fn) -> [void] - Starts the server listening on the specified port.\n- close(req, res) -> [void] - Closes the server and optionally ends a response.\n- error(e) -> [void] - Handles and logs server errors.\n\nNote: The class demonstrates inter-process communication through HTTP and file system operations, particularly in the `livereload` method where it pipes file contents directly to HTTP responses.",
    "Canonical_solution": "var fs = require('fs');\nvar http = require('http');\n\nclass Server {\n  constructor(options) {\n    this.options = options || {};\n    this.options.livereload = this.options.livereload || path.join(__dirname, 'public/livereload.js');\n    this.options.port = parseInt(this.options.port || 35729, 10);\n    this.clients = {};\n    this.configure(this.options.app);\n  }\n\n  configure(app) {\n    if(!app) {\n      this.server = http.createServer(this.handler.bind(this));\n      this.server.on('error', this.error.bind(this));\n      return this;\n    }\n\n    var self = this;\n    this.app = app;\n\n    this.app.listen = function(port, done) {\n      done = done || function() {};\n      var srv = self.server = http.createServer(app);\n      srv.on('error', self.error.bind(self));\n      srv.on('close', self.close.bind(self));\n      return srv.listen(port, done);\n    };\n\n    return this;\n  }\n\n  handler(req, res, next) {\n    var middleware = typeof next === 'function';\n    if(middleware) {\n      this.handle(req, res, next);\n      return this;\n    }\n\n    req\n      .on('end', this.handle.bind(this, req, res))\n      .on('data', function(chunk) {\n        req.data = req.data || '';\n        req.data += chunk;\n      });\n\n    return this;\n  }\n\n  livereload(req, res) {\n    fs.createReadStream(this.options.livereload).pipe(res);\n  }\n\n  listen(port, fn) {\n    this.port = port;\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if(res) res.end();\n    if(this.server._handle) this.server.close();\n  }\n\n  error(e) {\n    console.error('Error:', e.message);\n    console.error(e.stack);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nclass Server {\n  constructor(options = {}) {\n    this.options = Object.assign({ livereload: 'livereload.js', port: 0 }, options);\n    this.clients = {};\n    this.server = null;\n    this.app = null;\n    this.port = null;\n  }\n\n  configure(app) {\n    this.app = app;\n    return this;\n  }\n\n  handler(req, res, next) {\n    if (this.app) {\n      this.app(req, res, next);\n    } else if (req.url === `/${this.options.livereload}`) {\n      this.livereload(req, res);\n    } else if (typeof next === 'function') {\n      next();\n    } else {\n      res.writeHead(404);\n      res.end();\n    }\n  }\n\n  livereload(req, res) {\n    const fs = require('fs');\n    fs.createReadStream(require.resolve(this.options.livereload)).pipe(res);\n  }\n\n  listen(port, fn) {\n    const http = require('http');\n    this.port = port;\n    this.server = http.createServer(this.handler.bind(this));\n    this.server.on('error', this.error.bind(this));\n    this.server.listen(port, fn);\n  }\n\n  close(req, res) {\n    if (this.server) {\n      this.server.close();\n    }\n    if (res) {\n      res.end();\n    }\n  }\n\n  error(e) {\n    console.error(e);\n  }\n}\n\n```\n"
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files with specific Content Security Policy (CSP) rules, using pipe to stream file contents to the response.\n\nFunction Description: The function `createServer` creates and returns an HTTP server instance that serves static files from the root directory. It handles incoming requests by resolving the file path, applying CSP headers for security, and piping the file content to the response. If the request URL is '/', it defaults to serving 'index.html'.\n\nInput: None\n\nOutput: Returns an instance of `http.Server` configured to serve static files with CSP headers.",
    "Canonical_solution": "function createServer() {\n  const http = require('http');\n  const send = require('send');\n  const path = require('path');\n  const root = require('rootrequire');\n\n  return http.createServer(function (req, res) {\n    const url = req.url === '/' ? '/index.html' : req.url;\n    const file = path.resolve(root, url.slice(1));\n\n    const cspRules = [\n      `default-src 'self' https://cdnjs.cloudflare.com`,\n      `img-src * data: blob:`,\n      `media-src * data: blob:`,\n      `font-src https://fonts.googleapis.com https://fonts.gstatic.com`,\n      `style-src 'self' 'unsafe-inline' https://fonts.googleapis.com`,\n      `script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com`,\n      `worker-src 'self' blob:`\n    ];\n\n    res.setHeader('content-security-policy', cspRules.join('; '));\n\n    send(req, file).pipe(res);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('node:http');\nconst path = require('node:path');\nconst fs = require('node:fs');\n\nfunction createServer() {\n  return http.createServer((req, res) => {\n    const filePath = path.join(__dirname, req.url === '/' ? 'index.html' : req.url);\n    const extname = path.extname(filePath);\n\n    const csp = {\n      'default-src': \"'self'\",\n      'script-src': \"'self'\",\n      'style-src': \"'self'\",\n      'img-src': \"'self'\",\n      'font-src': \"'self'\",\n      'connect-src': \"'self'\",\n      'object-src': \"'none'\",\n      'base-uri': \"'self'\",\n      'form-action': \"'self'\",\n    };\n\n    res.writeHead(200, {\n      'Content-Security-Policy': Object.entries(csp)\n        .map(([key, value]) => `${key} ${value}`)\n        .join('; '),\n      'Content-Type': {\n        '.html': 'text/html',\n        '.js': 'text/javascript',\n        '.css': 'text/css',\n        '.json': 'application/json',\n        '.png': 'image/png',\n        '.jpg': 'image/jpeg',\n        '.gif': 'image/gif',\n        '.svg': 'image/svg+xml',\n      }[extname] || 'text/plain',\n    });\n\n    const readStream = fs.createReadStream(filePath);\n    readStream.pipe(res);\n\n    readStream.on('error', (err) => {\n      if (err.code === 'ENOENT') {\n        res.writeHead(404);\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(500);\n        res.end('500 Internal Server Error');\n      }\n    });\n  });\n}\n\nmodule.exports = createServer;\n\n```"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files, using Node.js's built-in `http` and `fs` modules. The server should handle different MIME types and pipe file contents to the response stream.\n\nFunction Description: The `createServer` function initializes an HTTP server that listens on port 5000. It serves static files from the local file system, automatically determining the appropriate MIME type based on the file extension. If a requested file doesn't exist, it logs a warning. The function uses streaming to efficiently pipe file contents to the HTTP response.\n\nInput: None (The function takes no parameters)\n\nOutput: None (The function doesn't return anything but creates a running HTTP server)",
    "Canonical_solution": "function createServer() {\n  var http = require('http'), fs = require('fs'), mimeTypes = {\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpg'\n  };\n\n  http.createServer(function (req, res) {\n    var file = (req.url === '/') ? 'index.html' : \".\" + req.url;\n    var ext = require('path').extname(file),\n      type = (mimeTypes[ext] ? mimeTypes[ext] : '');\n\n    fs.exists(file, function (exists) {\n      if (exists) {\n        res.writeHead(200, {'Content-Type': type});\n        fs.createReadStream(file).pipe(res);\n      } else {\n        console.warn(file, ' does not exit');\n      }\n    });\n  }).listen(5000);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst mimeTypes = {\n  '.html': 'text/html',\n  '.js': 'text/javascript',\n  '.css': 'text/css',\n  '.json': 'application/json',\n  '.png': 'image/png',\n  '.jpg': 'image/jpeg',\n  '.gif': 'image/gif',\n  '.svg': 'image/svg+xml',\n  '.wav': 'audio/wav',\n  '.mp4': 'video/mp4',\n  '.woff': 'application/font-woff',\n  '.ttf': 'application/font-ttf',\n  '.eot': 'application/vnd.ms-fontobject',\n  '.otf': 'application/font-otf',\n  '.wasm': 'application/wasm'\n};\n\nconst createServer = () => {\n  http.createServer((req, res) => {\n    const url = new URL(req.url, `http://${req.headers.host}`);\n    const filePath = '.' + (url.pathname === '/' ? '/index.html' : url.pathname);\n    const extname = String(path.extname(filePath)).toLowerCase();\n    const contentType = mimeTypes[extname] || 'application/octet-stream';\n\n    fs.readFile(filePath, (error, content) => {\n      if (error) {\n        if (error.code === 'ENOENT') {\n          console.warn(`File not found: ${filePath}`);\n          res.writeHead(404, { 'Content-Type': 'text/plain' });\n          res.end('404 Not Found');\n        } else {\n          console.error(`Error reading file: ${filePath}`, error);\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('500 Internal Server Error');\n        }\n      } else {\n        res.writeHead(200, { 'Content-Type': contentType });\n        res.end(content, 'utf-8');\n      }\n    });\n  }).listen(5000);\n\n  console.log('Server running at http://localhost:5000/');\n};\n\ncreateServer();\n\n"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve a ReDoc documentation interface, including handling requests for the ReDoc JavaScript file and rendering the documentation page with the provided specification.\n\nFunction Description: The function creates an HTTP server that serves two main routes: (1) '/redoc.standalone.js' which streams the ReDoc JavaScript file to the client, and (2) '/' which renders a complete HTML page with the ReDoc interface hydrated with the provided OpenAPI specification. The server handles other routes with a 404 response.\n\nInput:\n- port: [number] - The port number on which the HTTP server should listen\n- filePath: [string] - The file path to the 'redoc.standalone.js' file to be served\n- specPath: [string] - The file path to the OpenAPI specification file (YAML format)\n\nOutput: None (The function starts an HTTP server that continues running until manually stopped)\n\nNote: The function assumes the availability of certain external dependencies (yaml, fs, http, React, ServerStyleSheet, Redoc) which should be imported/required in the actual implementation. The function also uses async/await for handling asynchronous operations related to the Redoc store creation.",
    "Canonical_solution": "const http = require('http');\nconst fs = require('fs');\n\nfunction createServer(port, filePath, specPath) {\n    const server = http.createServer(async (request, response) => {\n        if (request.url === '/redoc.standalone.js') {\n            fs.createReadStream(filePath, 'utf8').pipe(response);\n        } else if (request.url === '/') {\n            const spec = yaml.load(readFileSync(resolve(__dirname, specPath), 'utf-8'));\n            const store = await createStore(spec, 'path/to/spec.yaml');\n\n            const sheet = new ServerStyleSheet();\n            const html = renderToString(sheet.collectStyles(React.createElement(Redoc, { store })));\n            const css = sheet.getStyleTags();\n\n            const res = `<html>\n            <head>\n                <meta charset=\"utf8\" />\n                <title>ReDoc</title>\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                <style>\n                    body {\n                        padding: 0;\n                        margin: 0;\n                    }\n                </style>\n                <script src=\"redoc.standalone.js\"></script>\n                <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n                ${css}\n            </head>\n            <body>\n            <script>\n                document.addEventListener('DOMContentLoaded', function() {\n                    const state = ${JSON.stringify(await store.toJS())};\n                    Redoc.hydrate(state, document.getElementById('redoc'));\n                });\n                </script>\n                <div id=\"redoc\">${html}</div>\n            </body>\n            </html>`;\n            response.writeHead(200, { 'Content-Length': res.length });\n            response.write(res);\n            response.end();\n        } else {\n            response.writeHead(404);\n            response.write('Not found');\n            response.end();\n        }\n    });\n\n    server.listen(port, () => console.log(`Server started: http://127.0.0.1:${port}`));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst yaml = require('yaml');\nconst fs = require('fs');\nconst http = require('http');\nconst React = require('react');\nconst { ServerStyleSheet } = require('styled-components');\nconst { RedocStandalone, RedocProvider, createStore } = require('redoc');\n\nasync function serveRedoc(port, filePath, specPath) {\n  const spec = yaml.parse(fs.readFileSync(specPath, 'utf8'));\n  const redocStandaloneJS = fs.readFileSync(filePath, 'utf-8');\n\n  const store = await createStore(spec, {}, null, {});\n\n  const server = http.createServer(async (req, res) => {\n    if (req.url === '/redoc.standalone.js') {\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end(redocStandaloneJS);\n    } else if (req.url === '/') {\n      const sheet = new ServerStyleSheet();\n      const html = React.renderToString(\n        sheet.collectStyles(\n          React.createElement(RedocProvider, { store }, React.createElement(RedocStandalone))\n        )\n      );\n      const styleTags = sheet.getStyleTags();\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(`<!DOCTYPE html>\n<html>\n<head>\n  <title>Redoc</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  ${styleTags}\n</head>\n<body>\n  <div id=\"redoc-container\"></div>\n  <script>\n    window.redocOptions = { disableSearch: true };\n  </script>\n  <script src=\"/redoc.standalone.js\"></script>\n</body>\n</html>`);\n    } else {\n      res.writeHead(404);\n      res.end();\n    }\n  });\n\n  server.listen(port);\n}\n\n```"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files and handle dynamic JavaScript file concatenation, with support for piping binary files.\n\nFunction Description: The `createServer` function initializes an HTTP server that serves static files from specified directories, handles dynamic concatenation of JavaScript files, and pipes binary files directly to the response. It supports virtual paths, content type detection, and redirection.\n\nInput: \n- Optional command line argument [string] - The port number to listen on (defaults to 90 if not provided)\n\nOutput: \n- None (directly creates and starts an HTTP server)\n- Console output indicating server startup and loaded files\n\nAttributes: (N/A - This is a function, not a class)\n\nMethods: (N/A - This is a function, not a class)\n\nAdditional Implementation Details:\n1. Reads and caches static files from '../src' and '../dist' directories at startup\n2. Handles binary files separately from text files\n3. Supports special handling for core JavaScript files and plugins\n4. Implements virtual path redirection\n5. Uses file extension to determine content type\n6. Provides fallback behavior for undefined routes\n7. Listens on localhost (127.0.0.1) only\n8. Outputs loaded file list to console at startup",
    "Canonical_solution": "function createServer() {\n    var http = require('http');\n    var fs = require(\"fs\");\n    var url = require(\"url\");\n\n    var BASE_URL=\"http://www.servicestack.net\", \n        VIRTUAL_PATH=\"/jqbuilder\"; \n\n    var getExt = function(path) {\n        return path.substring(path.lastIndexOf('.')+1);\n    };\n    String.prototype.startsWith = function (str){\n        return this.indexOf(str) === 0;\n    };\n\n    var contentTypes = { \"htm\": \"text/html\", \"js\": \"text/javascript\", \"gif\": \"image/gif\" };\n\n    var srcDir = '../src', targetDir = '../dist';\n    var webFiles = fs.readdirSync(targetDir);\n    var staticFiles = {}, binaryFiles = {};\n    fs.readdirSync(srcDir).forEach(function(file) { \n        var filePath = srcDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(targetDir).forEach(function(file) { \n        var filePath = targetDir + '/' + file;\n        staticFiles[\"/\" + file] = fs.readFileSync(filePath).toString('utf-8');\n    });\n    fs.readdirSync(\"./\").forEach(function(file) {\n        var isText = (contentTypes[getExt(file)]||\"\").startsWith(\"text\");\n        if (isText)\n            staticFiles[\"/\" + file] = fs.readFileSync(file).toString('utf-8');\n        else \n            binaryFiles[\"/\" + file] = file;\n    });\n\n    staticFiles[\"/\"] = staticFiles[\"/default.htm\"];\n\n    console.log(\"loaded: \", Object.keys(staticFiles));\n\n    var isCore = { \"/jquip.js\": true, \"/jquip.min.js\": true };\n\n    var port = process.argv[2] || 90;\n\n    http.createServer(function (req, res) {\n        var reqUrl = url.parse(req.url), path = reqUrl.pathname.replace(VIRTUAL_PATH,'');\n        if (reqUrl.pathname == VIRTUAL_PATH){\n            res.writeHead(302,BASE_URL+VIRTUAL_PATH+\"/\");\n            res.end();\n            return;\n        }\n\n        var fileContents = staticFiles[path];\n\n        if (fileContents) {\n            var ext = path == \"/\" ? \"htm\" : getExt(path);\n            var contentType = contentTypes[ext];\n            res.writeHead(200, {'Content-Type': contentType });\n            var isPlugin = ext == \"js\" && path.startsWith(\"/jquip.\") && !isCore[path];\n            if (isPlugin) {\n                var coreJs = path.indexOf(\"min\") != -1 \n                    ? staticFiles[\"/jquip.min.js\"]\n                    : staticFiles[\"/jquip.js\"];\n                fileContents = coreJs + \";\" + fileContents;\n            }\n\n            res.end(fileContents);\n        }\n        else if (binaryFiles[path]) { \n            var filePath = binaryFiles[path]; \n            fs.createReadStream(filePath, {\n              'bufferSize': 4 * 1024\n            }).pipe(res);\n        }\n        else\n        {\n            var isDynamic = path.startsWith(\"/jquip.\");\n            if (isDynamic) {\n                var parts = path.substring(1).split('.');\n                var isMin = parts.indexOf(\"min\") >= 0;\n                var js = isMin ? staticFiles[\"/jquip.min.js\"] : staticFiles[\"/jquip.js\"];\t\t\t\n                parts.forEach(function(part){\n                    if (part == \"jquip\" || part == \"min\" || part == \"js\") return;\n                    var path = \"/jquip.\" + part + (isMin ? \".min.js\" : \".js\");\n                    var jsFile = staticFiles[path];\n                    if (jsFile)\n                        js += \";\" + jsFile;\n                });\n                res.writeHead(200, {'Content-Type': 'text/javascript' });\n                res.end(js);\t\t\n                return;\n            }\n\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            var sb = \"\";\n            for (var i in reqUrl) {\n                if (sb) sb += \"\\n\";\n                sb += i + \": \" + reqUrl[i];\n            }\n            res.end(\"Path not found:\\n\" + sb);\n        }\n    })\n    .listen(port, \"127.0.0.1\");\n    console.log('Server running at http://127.0.0.1:'+port+'/');\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst createServer = (portArg) => {\n  const port = portArg || 90;\n  const cachedFiles = {};\n  const sourceDirs = ['../src', '../dist'];\n\n  function loadFiles(dir) {\n    const files = fs.readdirSync(dir, { withFileTypes: true });\n    files.forEach(file => {\n      const filePath = path.join(dir, file.name);\n      if (file.isDirectory()) {\n        loadFiles(filePath);\n      } else {\n        cachedFiles[filePath.replace(/^\\.\\.\\//, '/')] = fs.readFileSync(filePath);\n      }\n    });\n  }\n\n  sourceDirs.forEach(dir => loadFiles(dir));\n\n  console.log('Loaded files:', Object.keys(cachedFiles).join(', '));\n\n  const server = http.createServer((req, res) => {\n    const url = new URL(req.url, `http://${req.headers.host}`);\n    let filePath = url.pathname;\n\n    if (filePath === '/') {\n      filePath = '/index.html';\n    }\n\n    if (filePath.startsWith('/build/')) {\n      const components = filePath.substring('/build/'.length).split(',');\n      res.setHeader('Content-Type', 'application/javascript');\n      components.forEach(component => {\n        const componentPath = `/src/${component}.js`;\n        if (cachedFiles[componentPath]) {\n          res.write(cachedFiles[componentPath]);\n        }\n      });\n      res.end();\n      return;\n    }\n\n\n    if (cachedFiles[filePath]) {\n      let contentType = 'text/plain';\n      if (filePath.endsWith('.html')) contentType = 'text/html';\n      else if (filePath.endsWith('.js')) contentType = 'application/javascript';\n      else if (filePath.endsWith('.css')) contentType = 'text/css';\n      else if (filePath.endsWith('.png')) contentType = 'image/png';\n      else if (filePath.endsWith('.jpg') || filePath.endsWith('.jpeg')) contentType = 'image/jpeg';\n      else if (filePath.endsWith('.gif')) contentType = 'image/gif';\n\n      res.setHeader('Content-Type', contentType);\n      res.end(cachedFiles[filePath]);\n    } else if (filePath === '/vt') {\n      res.writeHead(302, {\n        'Location': 'https://vt.tiktok.com/ZSJKwJA8p/',\n      });\n      res.end();\n    }\n    else {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('404 Not Found');\n    }\n  });\n\n  server.listen(port, '127.0.0.1', () => {\n    console.log(`Server listening on http://127.0.0.1:${port}`);\n  });\n};\n\n\ncreateServer(process.argv[2]);\n\n```\n"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a function that sets up an HTTP server to serve static files from a specified directory, handling different MIME types and responding with 404 errors for non-existent files.\n\nFunction Description: The function `createFileServer` initializes an HTTP server that serves static files (HTML, images, JavaScript, CSS) from a 'static' directory in the current working directory. It handles proper MIME types for different file extensions and responds with 404 errors when files are not found. The server listens on port 1338 by default.\n\nInput: None (The function takes no parameters; all configuration is internal)\n\nOutput: None (The function doesn't return anything; it creates and starts an HTTP server that continues running)",
    "Canonical_solution": "function createFileServer() {\n    var http = require('http'),\n        url = require('url'),\n        path = require('path'),\n        fs = require('fs'),\n        port = 1338;\n    var mimeTypes = {\n        \"html\": \"text/html\",\n        \"jpeg\": \"image/jpeg\",\n        \"jpg\": \"image/jpeg\",\n        \"png\": \"image/png\",\n        \"js\": \"text/javascript\",\n        \"css\": \"text/css\"};\n\n    http.createServer(function(req, res) {\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(process.cwd(),'static', uri);\n        fs.exists(filename, function(exists) {\n            if(!exists) {\n                console.error(\"not exists: \" + filename);\n                res.writeHead(404, {'Content-Type': 'text/plain'});\n                res.write('404 Not Found\\n');\n                res.end();\n                return;\n            }\n            var mimeType = mimeTypes[path.extname(filename).split(\".\")[1]];\n            res.writeHead(200, {'Content-Type':mimeType});\n\n            var fileStream = fs.createReadStream(filename);\n            fileStream.pipe(res);\n        });\n    }).listen(port);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 100,
    "wrong_result": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst mimeTypes = {\n  '.html': 'text/html',\n  '.js': 'text/javascript',\n  '.css': 'text/css',\n  '.png': 'image/png',\n  '.jpg': 'image/jpeg',\n  '.gif': 'image/gif',\n  '.svg': 'image/svg+xml'\n};\n\nconst createFileServer = () => {\n  const server = http.createServer((req, res) => {\n    const filePath = path.join(__dirname, 'static', req.url === '/' ? 'index.html' : req.url);\n    const extname = String(path.extname(filePath)).toLowerCase();\n    const contentType = mimeTypes[extname] || 'application/octet-stream';\n\n    fs.readFile(filePath, (err, content) => {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          res.writeHead(404, { 'Content-Type': 'text/plain' });\n          res.end('404 Not Found');\n        } else {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('500 Internal Server Error');\n        }\n      } else {\n        res.writeHead(200, { 'Content-Type': contentType });\n        res.end(content, 'utf-8');\n      }\n    });\n  });\n\n  server.listen(1338);\n};\n\ncreateFileServer();\n\n"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a class that handles HTTP requests with authentication and custom headers for a specific API service. The class should support both GET and POST methods, generate required authentication signatures, and handle request errors appropriately.\n\nClass Description: The TaskRequest class is designed to make authenticated HTTP requests to a specific API endpoint. It handles request signing, header generation, and error management. The class maintains authentication-related attributes and provides a method to execute requests.\n\nAttributes:\n- did: [String] - Device identifier used for authentication\n- finger: [String] - Fingerprint information for the request\n- token: [String] - Authentication token for API access\n- oaid: [String] - OAID (Open Anonymous Identification) for tracking\n\nMethods:\n- constructor(did, finger, token, oaid) -> [None] - Initializes the TaskRequest instance with authentication parameters\n- taskRequest(method, url, body) -> [Promise<Object>] - Executes an HTTP request with the specified method to the given URL, optionally with a request body. Returns the response data or throws an error if the request fails. The method handles request signing and header generation internally.\n\nInput:\n- method: [String] - HTTP method to use ('get' or 'post')\n- url: [String] - Target URL for the request\n- body: [String] (optional) - Request body for POST requests (default: empty string)\n\nOutput:\n- [Promise<Object>] - Resolves with the response data if the request succeeds\n- [Error] - Throws an error if the request fails",
    "Canonical_solution": "const axios = require('axios');\n\nclass TaskRequest {\n    constructor(did, finger, token, oaid) {\n        this.did = did;\n        this.finger = finger;\n        this.token = token;\n        this.oaid = oaid;\n    }\n\n    async taskRequest(method, url, body = \"\") {\n        let re = function (e) {\n            function convertObjectToQueryString(obj) {\n                let queryString = \"\";\n                if (obj) {\n                    const keys = Object.keys(obj).sort();\n                    keys.forEach(key => {\n                        const value = obj[key];\n                        if (value !== null && typeof value !== 'object') {\n                            queryString += `&${key}=${value}`;\n                        }\n                    });\n                }\n                return queryString.slice(1);\n            }\n            return convertObjectToQueryString(e)\n        }\n        \n        function v(e) {\n            const crypto = require(\"crypto\")\n            return crypto.createHash(\"md5\").update(e).digest(\"hex\")\n        }\n        \n        const g = {\n            traceid: v((new Date).getTime().toString() + Math.random().toString()),\n            noncestr: Math.random().toString().slice(2, 10),\n            timestamp: Date.now(),\n            platform: \"h5\",\n            did: this.did,\n            version: \"1.0.0\",\n            finger: this.finger,\n            token: this.token,\n            oaid: this.oaid,\n        }\n        \n        const c = \"\\u7c89\\u8c61\\u597d\\u725b\\u903ca8c19d8267527ea4c7d2f011acf7766f\"\n        let s = method === \"get\" ? void 0 : JSON.parse(body)\n        let e = void 0 === s ? {} : s\n        g.sign = v(re(e) + re(g) + c)\n        \n        let headers = {\n            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; MI 8 Lite Build/QKQ1.190910.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/80.0.3987.99 Mobile Safari/537.36 AgentWeb/5.0.0  UCBrowser/11.6.4.950',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n            'origin': 'https://m.fenxianglife.com',\n            'sec-fetch-dest': 'empty',\n            'x-requested-with': 'com.n_add.android',\n            'sec-fetch-site': 'same-site',\n            'sec-fetch-mode': 'cors',\n            'referer': 'https://m.fenxianglife.com/h5-lottery/index.html?hideBack=1&sourceType=lottery_tab&token=030e7e9158af06dea2b3d0175a471ada&AppToken=96e06ae9f3cab6784de443015b8d9ad8&uid=515226607&v=5.4.3&did=njia992631e6-b9b2-4383-b67c-86b5d0fe818a&level=1&platform=android&timestamp=1717426249&channel=xiaomi&traFromId=23192687628924991393323633117947',\n            'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n            \"Content-Type\": \"application/json\"\n        }\n        \n        Object.assign(headers, g)\n        \n        const reqeuestOptions = {\n            url: url,\n            method: method,\n            headers: headers,\n            data: body\n        }\n        \n        try {\n            const response = await axios(reqeuestOptions);\n            return response.data;\n        } catch (error) {\n            console.log('axios error', error);\n            throw error;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass TaskRequest {\n  constructor(did, finger, token, oaid) {\n    this.did = did;\n    this.finger = finger;\n    this.token = token;\n    this.oaid = oaid;\n  }\n\n  async taskRequest(method, url, body = '') {\n    const headers = {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${this.token}`,\n      'X-Device-ID': this.did,\n      'X-Finger-Print': this.finger,\n      'X-OAID': this.oaid,\n    };\n\n    const options = {\n      method: method.toUpperCase(),\n      headers: headers,\n    };\n\n    if (method.toUpperCase() === 'POST' && body) {\n      options.body = JSON.stringify(body);\n    }\n\n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(`HTTP error ${response.status}: ${JSON.stringify(errorData)}`);\n      }\n      return await response.json();\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n\n```"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Create a TCP server in Node.js that serves Flash cross-domain policy files to clients, handling connections, errors, and policy file generation dynamically.\n\nClass Description: The Server class implements a TCP server that listens for Flash policy file requests and responds with an appropriate cross-domain policy XML. It handles server lifecycle events, client connections, and dynamic policy configuration.\n\nAttributes:\n- origins: [Array] - List of allowed domains and ports in \"domain:port\" format\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [net.Server] - The TCP server instance\n- server: [Object] - Optional fallback HTTP server\n- buffer: [Buffer] - Compiled policy file in binary format\n\nMethods:\n- constructor(options, origins) -> [Server] - Initializes the server with configuration options and allowed origins\n- listen(port, server, cb) -> [Server] - Starts listening on specified port, with optional fallback server and callback\n- responder(socket) -> [void] - Responds to client connections with policy file\n- compile() -> [Server] - Generates the policy file XML and converts it to buffer\n- add() -> [Server] - Adds one or more allowed origins to the policy\n- remove(origin) -> [Server] - Removes a specific origin from the policy\n- close() -> [Server] - Closes the server and cleans up resources",
    "Canonical_solution": "var net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => {\n        this.responder.call(this, socket);\n      });\n      this.responder.call(this, socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges. ' +\n          (\n            this.server\n            ? 'The Flash Policy File requests will only be served inline over the supplied HTTP server. Inline serving is slower than a dedicated server instance.'\n            : 'No fallback server supplied, we will be unable to answer Flash Policy File requests.'\n          )\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n      if (this.server && this.server['@'] && this.server.online) {\n        this.server.removeListener('connection', this.server['@']);\n      }\n      delete this.server?.online;\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (\n            data &&\n            data[0] === 60 &&\n            data.toString() === '<policy-file-request/>\\0' &&\n            socket &&\n            (socket.readyState === 'open' || socket.readyState === 'writeOnly')\n          ) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    if (this.port >= 0) {\n      this.socket.listen(this.port, () => {\n        this.socket.online = true;\n        callback?.call(this);\n      });\n    }\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = Buffer.from(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass Server {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.server = options.server;\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    this.port = port || this.port;\n    this.server = server || this.server;\n\n    if (this.server) {\n      this.server.on('connection', (socket) => this.responder(socket));\n    } else {\n      this.socket = net.createServer((socket) => this.responder(socket));\n      this.socket.listen(this.port, cb);\n      this.socket.on('error', (err) => this.log(err));\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.once('data', (data) => {\n      if (data.toString().startsWith('<policy-file-request/>')) {\n        socket.end(this.buffer);\n      } else {\n        socket.end();\n      }\n    });\n    socket.on('error', (err) => this.log(err));\n  }\n\n  compile() {\n    let xml = '<?xml version=\"1.0\"?>\\n<!DOCTYPE cross-domain-policy SYSTEM \"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd\">\\n<cross-domain-policy>\\n';\n    for (const origin of this.origins) {\n      xml += `<allow-access-from domain=\"${origin.split(':')[0]}\" to-ports=\"${origin.split(':')[1] || '80'}\" />\\n`;\n    }\n    xml += '</cross-domain-policy>\\n';\n    this.buffer = Buffer.from(xml, 'utf8');\n    return this;\n  }\n\n  add(...origin) {\n    this.origins = this.origins.concat(origin);\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    this.origins = this.origins.filter((o) => o !== origin);\n    this.compile();\n    return this;\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    }\n    return this;\n  }\n}\n\nmodule.exports = Server;\n\n```"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a TCP server class in JavaScript using Node.js's 'net' module to handle client connections, manage sockets, and provide event-driven communication.\n\nClass Description: The Socket class represents a TCP server that can bind to a specific port/host, manage client connections, handle socket errors, and emit events for various connection states. It extends EventEmitter for event handling capabilities.\n\nAttributes:\n- server: [net.Server] - The underlying TCP server instance\n- socks: [Array] - Array of connected client sockets\n- settings: [Object] - Configuration settings for the server\n- type: [String] - Indicates whether the instance is acting as a server or client\n\nMethods:\n- constructor() -> [void] - Initializes the socket instance with default settings\n- bind(port, host, fn) -> [Socket] - Binds the server to a specified port and host (supports both TCP and Unix sockets)\n- onconnect(sock) -> [void] - Handles new client connections\n- addSocket(sock) -> [void] - Adds a new socket to the connection pool and sets up message parsing\n- removeSocket(sock) -> [void] - Removes a socket from the connection pool\n- handleErrors(sock) -> [void] - Sets up error handling for a socket\n- closeServer(fn) -> [void] - Closes the server and all client connections",
    "Canonical_solution": "var Emitter = require('events').EventEmitter;\nvar net = require('net');\nvar debug = require('debug')('axon:sock');\n\nclass Socket {\n  constructor() {\n    this.server = null;\n    this.socks = [];\n    this.settings = {};\n    this.set('hwm', Infinity);\n    this.set('identity', String(process.pid));\n    this.set('retry timeout', 100);\n    this.set('retry max timeout', 5000);\n  }\n\n  bind(port, host, fn) {\n    var self = this;\n    if ('client' == this.type) throw new Error('cannot bind() after connect()');\n    if ('function' == typeof host) {\n      fn = host;\n      host = undefined;\n    }\n\n    var unixSocket = false;\n\n    if ('string' == typeof port) {\n      port = url.parse(port);\n\n      if ('unix:' == port.protocol) {\n        host = fn;\n        fn = undefined;\n        port = port.pathname;\n        unixSocket = true;\n      } else {\n        host = port.hostname || '0.0.0.0';\n        port = parseInt(port.port, 10);\n      }\n    } else {\n      host = host || '0.0.0.0';\n    }\n\n    this.type = 'server';\n\n    this.server = net.createServer(this.onconnect.bind(this));\n\n    debug('%s bind %s:%s', this.type, host, port);\n    this.server.on('listening', this.emit.bind(this, 'bind'));\n\n    if (unixSocket) {\n      this.server.on('error', function(e) {\n        if (e.code == 'EADDRINUSE') {\n          var clientSocket = new net.Socket();\n\n          clientSocket.on('error', function(e2) {\n            if (e2.code == 'ECONNREFUSED') {\n              fs.unlink(port);\n              self.server.listen(port, host, fn);\n            }\n          });\n\n          clientSocket.connect({path: port}, function() {\n            throw e;\n          });\n        }\n      });\n    }\n\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    var self = this;\n    var addr = sock.remoteAddress + ':' + sock.remotePort;\n    debug('%s accept %s', self.type, addr);\n    this.addSocket(sock);\n    this.handleErrors(sock);\n    this.emit('connect', sock);\n    sock.on('close', function() {\n      debug('%s disconnect %s', self.type, addr);\n      self.emit('disconnect', sock);\n      self.removeSocket(sock);\n    });\n  }\n\n  addSocket(sock) {\n    var parser = new Parser;\n    var i = this.socks.push(sock) - 1;\n    debug('%s add socket %d', this.type, i);\n    sock.pipe(parser);\n    parser.on('data', this.onmessage(sock));\n  }\n\n  removeSocket(sock) {\n    var i = this.socks.indexOf(sock);\n    if (!~i) return;\n    debug('%s remove socket %d', this.type, i);\n    this.socks.splice(i, 1);\n  }\n\n  handleErrors(sock) {\n    var self = this;\n    sock.on('error', function(err) {\n      debug('%s error %s', self.type, err.code || err.message);\n      self.emit('socket error', err);\n      self.removeSocket(sock);\n      if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n      debug('%s ignored %s', self.type, err.code);\n      self.emit('ignored error', err);\n    });\n  }\n\n  closeServer(fn) {\n    debug('%s closing server', this.type);\n    this.server.on('close', this.emit.bind(this, 'close'));\n    this.server.close();\n    fn && fn();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst EventEmitter = require('events');\n\nclass Socket extends EventEmitter {\n  constructor() {\n    super();\n    this.server = null;\n    this.socks = [];\n    this.settings = {\n      timeout: 0,\n      maxConnections: Infinity\n    };\n    this.type = 'server';\n  }\n\n  bind(port, host, fn) {\n    this.server = net.createServer(this.onconnect.bind(this));\n    this.server.maxConnections = this.settings.maxConnections;\n    this.server.listen(port, host, fn);\n    return this;\n  }\n\n  onconnect(sock) {\n    this.addSocket(sock);\n    this.emit('connection', sock);\n  }\n\n  addSocket(sock) {\n    this.socks.push(sock);\n    this.handleErrors(sock);\n\n    let buffer = Buffer.alloc(0);\n    sock.on('data', (data) => {\n      buffer = Buffer.concat([buffer, data]);\n      let i = 0;\n      while ((i = buffer.indexOf('\\n')) >= 0) {\n        const message = buffer.slice(0, i).toString().trim();\n        buffer = buffer.slice(i + 1);\n        this.emit('message', sock, message);\n      }\n    });\n\n    sock.on('close', () => this.removeSocket(sock));\n  }\n\n  removeSocket(sock) {\n    const index = this.socks.indexOf(sock);\n    if (index !== -1) {\n      this.socks.splice(index, 1);\n      this.emit('disconnect', sock);\n    }\n  }\n\n  handleErrors(sock) {\n    sock.on('error', (err) => {\n      this.emit('error', sock, err);\n      this.removeSocket(sock);\n    });\n  }\n\n  closeServer(fn) {\n    this.socks.forEach(sock => sock.destroy());\n    this.server.close(fn);\n  }\n}\n```\n"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a class that provides wallpaper retrieval functionality from different APIs (Unsplash or Bing) based on client availability.\n\nClass Description: The WallpaperService class is designed to fetch random wallpapers from either Unsplash (if an API key is provided) or Bing's wallpaper API (as a fallback). It handles API requests, processes responses, and provides a consistent output format regardless of the source.\n\nAttributes: None (This is a static service class with no instance attributes)\n\nMethods:\ngetWallpaper: static async getWallpaper(unsplashClientId: string) -> Promise<Object> - Fetches a random wallpaper from either Unsplash or Bing. \n  - Input: \n    - unsplashClientId: string - The API client ID for Unsplash (optional, if not provided will use Bing)\n  - Output: \n    - Returns a Promise that resolves to an object with:\n      - type: string - Indicates the source ('unsplash' or 'bing')\n      - data: Array/Object - Contains the wallpaper data in the respective API's format\n    - On error, returns a fallback Bing wallpaper object with a default image",
    "Canonical_solution": "const axios = require('axios');\n\nclass WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    const wallpaperAPI = unsplashClientId\n      ? 'https://api.unsplash.com/photos/random?orientation=landscape&count=1&client_id=' + unsplashClientId\n      : 'https://cn.bing.com/HPImageArchive.aspx?format=js&n=1';\n\n    try {\n      const res = await axios.get(wallpaperAPI);\n      return unsplashClientId\n        ? { type: 'unsplash', data: res.data }\n        : { type: 'bing', data: res.data.images };\n    } catch (error) {\n      return {\n        type: 'bing',\n        data: [{\n          url: '/az/hprichbg/rb/SWFC_ZH-CN9558503653_1920x1080.jpg',\n          copyrightlink: '/search?q=%e4%b8%8a%e6%b5%b7%e4%b8%96%e7%95%8c%e9%87%91%e8%9e%8d%e4%b8%ad%e5%bf%83&form=hpcapt&mkt=zh-cn'\n        }]\n      };\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class WallpaperService {\n  static async getWallpaper(unsplashClientId) {\n    if (unsplashClientId) {\n      try {\n        const response = await fetch(`https://api.unsplash.com/photos/random?client_id=${unsplashClientId}`);\n        if (!response.ok) {\n          throw new Error(`Unsplash API error: ${response.status}`);\n        }\n        const data = await response.json();\n        return { type: 'unsplash', data };\n      } catch (error) {\n        console.error(\"Error fetching from Unsplash, falling back to Bing:\", error);\n        return this.getBingWallpaper();\n      }\n    } else {\n      return this.getBingWallpaper();\n    }\n  }\n\n  static async getBingWallpaper() {\n    try {\n      const response = await fetch(\"https://www.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=en-US\");\n      if (!response.ok) {\n        throw new Error(`Bing API error: ${response.status}`);\n      }\n      const data = await response.json();\n      const imageUrl = `https://www.bing.com${data.images[0].url}`;\n      return {\n        type: 'bing',\n        data: {\n          url: imageUrl,\n          copyright: data.images[0].copyright,\n          copyrightlink: data.images[0].copyrightlink\n        }\n      };\n    } catch (error) {\n      console.error(\"Error fetching from Bing, using default:\", error);\n      return {\n        type: 'bing',\n        data: {\n          url: 'https://www.bing.com/th?id=OHR.YosemiteTree_EN-US9698887984_1920x1080.jpg&rf=LaDigue_1920x1080.jpg&pid=hp',\n          copyright: 'Default Bing Image',\n          copyrightlink: 'https://www.bing.com'\n        }\n      };\n    }\n  }\n}\n\n"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a function that establishes a TCP server which listens for specific termination codes from clients and responds with a predefined byte sequence before shutting down.\n\nFunction Description: The function `makeTerminatingBackend` creates a TCP server that listens for incoming connections. When a client sends data containing specific termination codes (80877103 or 80877104), the server responds with a predefined byte sequence and then closes the connection. The server automatically selects an available port and returns it for external use.\n\nInput: \n- `byte` [String] - The UTF-8 encoded byte sequence to send as a response when a termination code is received.\n\nOutput:\n- `port` [Number] - The port number on which the TCP server is listening. This is dynamically assigned by the system.",
    "Canonical_solution": "function makeTerminatingBackend(byte) {\n  const { createServer } = require('net');\n\n  const server = createServer((socket) => {\n    socket.on('data', (buff) => {\n      const code = buff.readInt32BE(4);\n      if (code === 80877103 || code === 80877104) {\n        const packet = Buffer.from(byte, 'utf-8');\n        socket.write(packet);\n      }\n    });\n    socket.on('close', () => {\n      server.close();\n    });\n  });\n\n  server.listen();\n  const { port } = server.address();\n  return port;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 97,
    "wrong_result": "```python\nimport socket\nimport threading\n\ndef makeTerminatingBackend(byte):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind(('127.0.0.1', 0))\n    s.listen(1)\n    port = s.getsockname()[1]\n\n    def handle_client(conn, addr):\n        while True:\n            data = conn.recv(1024)\n            if not data:\n                break\n            try:\n                received_int = int(data.decode())\n                if received_int == 80877103 or received_int == 80877104:\n                    conn.sendall(byte.encode())\n                    conn.close()\n                    s.close()\n                    return\n            except ValueError:\n                pass\n\n    def accept_connections():\n        while True:\n            try:\n                conn, addr = s.accept()\n                client_thread = threading.Thread(target=handle_client, args=(conn, addr))\n                client_thread.start()\n            except OSError:\n                return\n\n    accept_thread = threading.Thread(target=accept_connections)\n    accept_thread.start()\n    return port\n\n```"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Create a TCP server implementation for handling IMAP (Internet Message Access Protocol) connections with optional TLS/SSL security support.\n\nClass Description: IMAPServer is a class that implements a TCP server for IMAP protocol connections. It supports both plain and TLS/SSL encrypted connections, handles client connections, and manages server lifecycle events.\n\nAttributes:\n- options: [Object] - Configuration options for the server including security settings\n- server: [net.Server] - The underlying TCP server instance\n- connections: [Set] - Active client connections\n- _closeTimeout: [Timeout] - Timer for server shutdown operations\n\nMethods:\n- constructor(options) -> [IMAPServer] - Initializes the server with configuration options and sets up event listeners\n- connect(socket, socketOptions) -> [void] - Creates a new IMAPConnection for a client socket\n- listen(...args) -> [void] - Starts the server listening on specified port/address\n- close(callback) -> [void] - Gracefully shuts down the server\n- _setListeners() -> [void] - Sets up server event listeners\n- _onListening() -> [void] - Handles server 'listening' event\n- _onClose() -> [void] - Handles server 'close' event\n- _onError(err) -> [void] - Handles server 'error' event\n- _handleProxy(socket, callback) -> [void] - Handles proxy protocol if needed\n- _upgrade(socket, callback) -> [void] - Upgrades a connection to TLS/SSL",
    "Canonical_solution": "const net = require('net');\nconst tls = require('tls');\n\nclass IMAPServer {\n    constructor(options) {\n        this.options = options || {};\n\n        if (this.options.secure && !this.options.needsUpgrade) {\n            this.server = net.createServer(this.options, socket => {\n                socket.setKeepAlive(true, 5 * 1000);\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    if (this.options.secured) {\n                        return this.connect(socket, socketOptions);\n                    }\n                    this._upgrade(socket, (err, tlsSocket) => {\n                        if (err) {\n                            return this._onError(err);\n                        }\n                        this.connect(tlsSocket, socketOptions);\n                    });\n                });\n            });\n        } else {\n            this.server = net.createServer(this.options, socket =>\n                this._handleProxy(socket, (err, socketOptions) => {\n                    if (err) {\n                        // ignore, should not happen\n                    }\n                    socket.setKeepAlive(true, 5 * 1000);\n                    this.connect(socket, socketOptions);\n                })\n            );\n        }\n\n        this._setListeners();\n    }\n\n    connect(socket, socketOptions) {\n        let connection = new IMAPConnection(this, socket, socketOptions);\n        this.connections.add(connection);\n        connection.on('error', this._onError.bind(this));\n        connection.init();\n    }\n\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    close(callback) {\n        this.server.close(() => {\n            clearTimeout(this._closeTimeout);\n            callback();\n        });\n    }\n\n    _setListeners() {\n        this.server.on('listening', this._onListening.bind(this));\n        this.server.on('close', this._onClose.bind(this));\n        this.server.on('error', this._onError.bind(this));\n    }\n\n    _onListening() {\n        let address = this.server.address();\n        this.emit('listening');\n    }\n\n    _onClose() {\n        this.emit('close');\n    }\n\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    _handleProxy(socket, callback) {\n        let socketOptions = {\n            id: base32.encode(crypto.randomBytes(10)).toLowerCase()\n        };\n        return setImmediate(() => callback(null, socketOptions));\n    }\n\n    _upgrade(socket, callback) {\n        let socketOptions = {\n            secureContext: this.secureContext.get('*'),\n            isServer: true,\n            server: this.server\n        };\n\n        let tlsSocket = new tls.TLSSocket(socket, socketOptions);\n        tlsSocket.on('secure', () => {\n            return callback(null, tlsSocket);\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\nconst tls = require('tls');\nconst IMAPConnection = require('./imap-connection'); // Assuming IMAPConnection class exists\n\nclass IMAPServer {\n  constructor(options) {\n    this.options = options;\n    this.server = net.createServer(this.options.tls ? this.options.tls : {});\n    this.connections = new Set();\n    this._closeTimeout = null;\n    this._setListeners();\n  }\n\n  connect(socket, socketOptions) {\n    const connection = new IMAPConnection(socket, this.options, socketOptions);\n    this.connections.add(connection);\n    connection.once('close', () => this.connections.delete(connection));\n  }\n\n  listen(...args) {\n    this.server.listen(...args);\n  }\n\n  close(callback) {\n    clearTimeout(this._closeTimeout);\n    this.server.close(() => {\n      if (this.connections.size === 0) {\n        if (callback) callback();\n        return;\n      }\n\n      const timeout = setTimeout(() => {\n        this.connections.forEach(c => c.destroy());\n        if (callback) callback();\n      }, this.options.closeTimeout || 10000);\n\n      this._closeTimeout = timeout;\n\n      this.connections.forEach(c => c.once('close', () => {\n        this.connections.delete(c);\n        if (this.connections.size === 0) {\n          clearTimeout(timeout);\n          if (callback) callback();\n        }\n      }));\n    });\n\n\n    this.server.on('connection', socket => {\n      if (this.server.listening) {\n        socket.destroy();\n      }\n    });\n  }\n\n  _setListeners() {\n    this.server.on('listening', this._onListening.bind(this));\n    this.server.on('close', this._onClose.bind(this));\n    this.server.on('error', this._onError.bind(this));\n    this.server.on('connection', this._handleProxy.bind(this));\n  }\n\n  _onListening() {\n    // Emit listening event or handle as needed\n  }\n\n  _onClose() {\n    // Emit close event or handle as needed\n  }\n\n  _onError(err) {\n    // Emit error event or handle as needed\n    console.error(err); // Example error handling\n  }\n\n  _handleProxy(socket, callback) {\n    if (this.options.proxy) {\n      // Handle proxy protocol (implementation omitted for brevity)\n      this._upgrade(socket, callback);\n    } else {\n      this._upgrade(socket, callback);\n    }\n  }\n\n  _upgrade(socket, callback) {\n    if (this.options.tls) {\n      const socketOptions = {}; // TLS options can be added here\n      const tlsSocket = tls.connect({ ...this.options.tls, socket, ...socketOptions }, () => {\n        this.connect(tlsSocket, socketOptions);\n        if (callback) callback();\n      });\n\n      tlsSocket.on('error', err => {\n        socket.destroy(err);\n      });\n    } else {\n      this.connect(socket);\n      if (callback) callback();\n    }\n  }\n}\n\nmodule.exports = IMAPServer;\n\n```"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Write a function that fetches version information and schema data from a remote API, caches the results locally, and handles errors appropriately.\n\nFunction Description: The function `fetchAndCacheVersions` retrieves version data from a specified API endpoint, then fetches schema data for each non-deprecated version. It caches all retrieved data in JSON files in a local directory. Errors during the process are caught and logged, with the process exiting on failure.\n\nInput: None (The function takes no parameters; all URLs and paths are hardcoded)\n\nOutput: \n- Success: Writes JSON files to the cache directory and logs success messages\n- Failure: Logs error messages and exits the process with status code 1",
    "Canonical_solution": "function fetchAndCacheVersions() {\n    const axios = require('axios');\n    const { writeJsonSync } = require('fs-extra');\n    const path = require('path');\n\n    axios\n        .get('https://exp.host/--/versions')\n        .then(async ({ data }) => {\n            writeJsonSync(path.join(__dirname, '../caches/versions.json'), data);\n\n            for (const version of Object.keys(data.sdkVersions)) {\n                if (data.sdkVersions[version].isDeprecated) {\n                    continue;\n                }\n                const {\n                    data: { data: schema },\n                } = await axios.get(`https://exp.host/--/api/v2/project/configuration/schema/${version}`);\n\n                const filePath = path.join(__dirname, `../caches/schema-${version}.json`);\n                console.log('Writing', filePath);\n                writeJsonSync(filePath, schema);\n            }\n        })\n        .then(() => console.log('Caches updated.'))\n        .catch(error => {\n            console.error(error);\n            console.error('Updating caches failed.');\n            process.exit(1);\n        });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```python\nimport json\nimport os\nimport requests\nimport sys\n\nCACHE_DIR = \"cache\"\nVERSIONS_URL = \"https://example.com/api/versions\"\nSCHEMA_URL = \"https://example.com/api/schema/{}\"\n\ndef fetch_and_cache_versions():\n    try:\n        os.makedirs(CACHE_DIR, exist_ok=True)\n\n        versions_response = requests.get(VERSIONS_URL)\n        versions_response.raise_for_status()\n        versions = versions_response.json()\n\n        with open(os.path.join(CACHE_DIR, \"versions.json\"), \"w\") as f:\n            json.dump(versions, f, indent=2)\n\n        for version in versions:\n            if not version.get(\"deprecated\", False):\n                schema_response = requests.get(SCHEMA_URL.format(version[\"version\"]))\n                schema_response.raise_for_status()\n                schema = schema_response.json()\n\n                with open(os.path.join(CACHE_DIR, f\"schema_{version['version']}.json\"), \"w\") as f:\n                    json.dump(schema, f, indent=2)\n\n        print(\"Successfully fetched and cached versions and schemas.\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n        sys.exit(1)\n    except OSError as e:\n        print(f\"Error writing to cache: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    fetch_and_cache_versions()\n```\n"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a Flash Policy Server class in JavaScript using Node.js's net module to handle cross-domain policy requests for socket connections.\n\nClass Description: The FlashPolicyServer class creates a TCP server that responds to Flash socket policy requests. It manages allowed origins/ports, compiles the XML policy file, and handles server lifecycle events.\n\nAttributes:\n- origins: [Array] - List of allowed domain:port combinations\n- port: [Number] - TCP port to listen on (default: 843)\n- log: [Function] - Logging function (default: console.log)\n- socket: [Object] - TCP server instance\n- buffer: [Buffer] - Compiled policy file in binary format\n- server: [Object] - Optional existing server instance to attach to\n\nMethods:\n- constructor(options, origins) -> [FlashPolicyServer] - Initializes the server with options and allowed origins\n- listen(port, server, cb) -> [FlashPolicyServer] - Starts listening on specified port, optionally attaching to existing server\n- responder(socket) -> [void] - Responds to policy requests on a socket connection\n- compile() -> [FlashPolicyServer] - Generates the XML policy buffer from allowed origins\n- add() -> [FlashPolicyServer] - Adds new allowed origins to the policy\n- remove(origin) -> [FlashPolicyServer] - Removes an origin from the allowed list\n- close() -> [FlashPolicyServer] - Stops the server and cleans up listeners",
    "Canonical_solution": "var net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || ['*:*'];\n    this.port = 843;\n    this.log = console.log;\n\n    Object.keys(options).forEach((key) => {\n      this[key] && (this[key] = options[key]);\n    });\n\n    this.socket = net.createServer((socket) => {\n      socket.on('error', () => this.responder(socket));\n      this.responder(socket);\n    });\n\n    this.socket.on('error', (err) => {\n      if (err.errno == 13) {\n        this.log && this.log(\n          'Unable to listen to port `' + this.port + '` as your Node.js instance does not have root privileges.'\n        );\n        this.emit('connect_failed', err);\n        this.socket.removeAllListeners();\n        delete this.socket;\n      } else {\n        this.log && this.log('FlashPolicyFileServer received an error event:\\n' + (err.message ? err.message : err));\n      }\n    });\n\n    this.socket.on('timeout', () => {});\n    this.socket.on('close', (err) => {\n      err && this.log && this.log('Server closing due to an error: \\n' + (err.message ? err.message : err));\n    });\n\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    let callback;\n    const args = Array.prototype.slice.call(arguments, 0);\n    \n    args.forEach((arg) => {\n      const type = typeof arg;\n      if (type === 'number') this.port = arg;\n      if (type === 'function') callback = arg;\n      if (type === 'object') this.server = arg;\n    });\n\n    if (this.server) {\n      this.server['@'] = (socket) => {\n        socket.once('data', (data) => {\n          if (data && data[0] === 60 && data.toString() === '<policy-file-request/>\\0' &&\n              socket && (socket.readyState === 'open' || socket.readyState === 'writeOnly')) {\n            try {\n              socket.end(this.buffer);\n            } catch (e) {}\n          }\n        });\n      };\n      this.server.on('connection', this.server['@']);\n    }\n\n    this.port >= 0 && this.socket.listen(this.port, () => {\n      this.socket.online = true;\n      if (callback) {\n        callback.call(this);\n        callback = undefined;\n      }\n    });\n\n    return this;\n  }\n\n  responder(socket) {\n    if (socket && socket.readyState == 'open' && socket.end) {\n      try {\n        socket.end(this.buffer);\n      } catch (e) {}\n    }\n  }\n\n  compile() {\n    const xml = [\n      '<?xml version=\"1.0\"?>',\n      '<!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\">',\n      '<cross-domain-policy>'\n    ];\n\n    this.origins.forEach((origin) => {\n      const parts = origin.split(':');\n      xml.push('<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"'+ parts[1] +'\"/>');\n    });\n\n    xml.push('</cross-domain-policy>');\n    this.buffer = new Buffer(xml.join(''), 'utf8');\n    return this;\n  }\n\n  add() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    let i = args.length;\n\n    while (i--) {\n      if (this.origins.indexOf(args[i]) >= 0) {\n        args[i] = null;\n      }\n    }\n\n    Array.prototype.push.apply(\n      this.origins,\n      args.filter((value) => !!value)\n    );\n\n    this.compile();\n    return this;\n  }\n\n  remove(origin) {\n    const position = this.origins.indexOf(origin);\n    if (position > 0) {\n      this.origins.splice(position,1);\n      this.compile();\n    }\n    return this;\n  }\n\n  close() {\n    this.socket.removeAllListeners();\n    this.socket.close();\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 97,
    "wrong_result": "```javascript\nconst net = require('net');\n\nclass FlashPolicyServer {\n  constructor(options, origins) {\n    this.origins = origins || [];\n    this.port = options.port || 843;\n    this.log = options.log || console.log;\n    this.socket = null;\n    this.buffer = null;\n    this.server = options.server;\n    this.compile();\n  }\n\n  listen(port, server, cb) {\n    this.port = port || this.port;\n    this.server = server || this.server;\n\n    const callback = cb || (() => {});\n\n    if (this.server) {\n      this.server.on('connection', this.responder.bind(this));\n      callback(null, this.server);\n    } else {\n      this.socket = net.createServer(this.responder.bind(this));\n      this.socket.listen(this.port, () => {\n        this.log('Flash policy server listening on port ' + this.port);\n        callback(null, this.socket);\n      });\n    }\n    return this;\n  }\n\n  responder(socket) {\n    socket.once('data', data => {\n      if (data.toString().startsWith('<policy-file-request/>')) {\n        socket.end(this.buffer);\n      } else {\n        socket.end();\n      }\n    });\n    socket.on('error', err => this.log('Flash policy server socket error: ' + err));\n  }\n\n  compile() {\n    let xml = '<?xml version=\"1.0\"?>\\n<!DOCTYPE cross-domain-policy SYSTEM \"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd\">\\n<cross-domain-policy>\\n';\n    for (const origin of this.origins) {\n      const parts = origin.split(':');\n      xml += '<allow-access-from domain=\"' + parts[0] + '\" to-ports=\"' + (parts[1] || '80') + '\" />\\n';\n    }\n    xml += '</cross-domain-policy>\\n';\n    this.buffer = Buffer.from(xml, 'utf8');\n    return this;\n  }\n\n  add(origin) {\n    if (typeof origin === 'string') {\n      this.origins.push(origin);\n    } else if (Array.isArray(origin)) {\n      this.origins = this.origins.concat(origin);\n    }\n    return this.compile();\n  }\n\n  remove(origin) {\n    this.origins = this.origins.filter(o => o !== origin);\n    return this.compile();\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    } else if (this.server) {\n      this.server.off('connection', this.responder);\n    }\n    return this;\n  }\n}\n\n```\n"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Create a UDP-based poller class in JavaScript that can send ping messages to a target UDP server and handle pong responses, with timeout functionality.\n\nClass Description: The UdpPoller class is designed to monitor UDP servers by sending periodic ping messages and listening for pong responses. It inherits from a base poller class and implements UDP communication using Node.js's dgram module.\n\nAttributes:\n- udpServer: [Object] - The UDP socket instance created using dgram module\n- target: [Object/String] - The target server address and port (parsed from input URL)\n- timeout: [Number] - The maximum time to wait for a response before timing out\n- callback: [Function] - The callback function to be executed when a response is received or an error occurs\n\nMethods:\n- constructor(target, timeout, callback) -> [void] - Initializes the poller with target, timeout, and callback\n- static get type() -> [String] - Returns the poller type ('udp')\n- static validateTarget(target) -> [Boolean] - Validates if the target URL matches UDP format\n- initialize() -> [void] - Sets up the UDP socket and parses the target address\n- poll() -> [void] - Sends a ping message to the target server and sets up response listener\n- onResponseCallback(message, sender) -> [void] - Handles incoming messages and processes pong responses\n- timeoutReached() -> [void] - Cleans up socket listeners when timeout occurs",
    "Canonical_solution": "var util = require('util');\nvar dgram = require('dgram');\nvar BasePoller = require('../basePoller');\n\nclass UdpPoller {\n  constructor(target, timeout, callback) {\n    UdpPoller.super_.call(this, target, timeout, callback);\n    this.udpServer = null;\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    return reg.test(target);\n  }\n\n  initialize() {\n    this.udpServer = dgram.createSocket('udp4');\n    this.udpServer.bind();\n    this.udpServer.on('error', function() {});\n    \n    var reg = new RegExp('udp:\\/\\/(.*):(\\\\d{1,5})');\n    if(!reg.test(this.target)) {\n      console.log(this.target + ' does not seems to be valid udp url');\n    }\n    var host = reg.exec(this.target);\n    this.target = {\n      'address': host[1],\n      'port': host[2]\n    };\n  }\n\n  poll() {\n    var ping = new Buffer(JSON.stringify({'command': 'ping'}));\n    this.udpServer.send(ping, 0, ping.length, this.target.port, this.target.address);\n    this.udpServer.on(\"message\", this.onResponseCallback.bind(this));\n  }\n\n  onResponseCallback(message, sender) {\n    var cmd;\n    try {\n      cmd = JSON.parse(message);\n    } catch (e) {\n      return this.onErrorCallback({ name: \"Unparsable answer\", message: \"server return answer \" + message.toString()});\n    }\n    if (cmd.command === 'pong') {\n      this.timer.stop();\n      this.callback(null, this.getTime(), cmd);\n    }\n  }\n\n  timeoutReached() {\n    this.udpServer.removeAllListeners();\n  }\n}\n\nutil.inherits(UdpPoller, BasePoller);",
    "Code_level": "Class-level",
    "FSMID_for_test": 98,
    "wrong_result": "```javascript\nconst dgram = require('dgram');\nconst BasePoller = require('./base_poller'); // Assuming base_poller.js exists\n\nclass UdpPoller extends BasePoller {\n  constructor(target, timeout, callback) {\n    super(target, timeout, callback);\n    this.udpServer = dgram.createSocket('udp4');\n  }\n\n  static get type() {\n    return 'udp';\n  }\n\n  static validateTarget(target) {\n    try {\n      const url = new URL(target);\n      return url.protocol === 'udp:';\n    } catch (error) {\n      return false;\n    }\n  }\n\n  initialize() {\n    const url = new URL(this.target);\n    this.target = {\n      address: url.hostname,\n      port: parseInt(url.port, 10),\n    };\n  }\n\n\n  poll() {\n    const message = Buffer.from('ping');\n    this.udpServer.send(message, this.target.port, this.target.address);\n\n    const timeoutId = setTimeout(() => {\n      this.udpServer.removeListener('message', this.onResponseCallback);\n      this.timeoutReached();\n    }, this.timeout);\n\n    this.onResponseCallback = (msg, sender) => {\n      clearTimeout(timeoutId);\n      this.udpServer.removeListener('message', this.onResponseCallback);\n      if (msg.toString() === 'pong') {\n        this.callback(null, { target: this.target });\n      } else {\n        this.callback(new Error('Invalid response received.'));\n      }\n    };\n\n    this.udpServer.on('message', this.onResponseCallback);\n    this.udpServer.on('error', (err) => {\n      clearTimeout(timeoutId);\n      this.udpServer.removeListener('message', this.onResponseCallback);\n      this.callback(err);\n    });\n\n  }\n\n  timeoutReached() {\n    this.callback(new Error('Timeout reached.'));\n  }\n}\n\n\nmodule.exports = UdpPoller;\n\n```"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome DevTools Protocol, handling connection, message exchange, and disconnection events.\n\nClass Description: The Chrome class is an EventEmitter that establishes and manages a WebSocket connection to Chrome's DevTools Protocol. It handles message parsing, error handling, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The WebSocket instance\n- _notifier: [EventEmitter] - External event notifier\n- _callbacks: [Object] - Stores pending command callbacks\n- _nextCommandId: [Number] - Tracks the next command ID\n\nMethods:\n- constructor(options, notifier) -> [void] - Initializes the Chrome instance with connection options and notifier\n- _start() -> [Promise] - Internal method to initiate WebSocket connection\n- _connectToWebSocket() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleConnectionClose() -> [void] - Cleans up when connection closes\n- _handleMessage(message) -> [void] - Processes incoming WebSocket messages\n- send(method, params, sessionId, callback) -> [Promise|void] - Sends a command to Chrome DevTools Protocol\n- _enqueueCommand(method, params, sessionId, callback) -> [void] - Internal method to queue commands\n- close(callback) -> [Promise|void] - Closes the WebSocket connection cleanly",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this.webSocketUrl = undefined;\n        this._ws = null;\n        this._notifier = notifier;\n        this._start();\n    }\n\n    async _start() {\n        try {\n            await this._connectToWebSocket();\n            process.nextTick(() => {\n                this._notifier.emit('connect', this);\n            });\n        } catch (err) {\n            this._notifier.emit('error', err);\n        }\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleConnectionClose() {\n        this._callbacks = {};\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n\n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    close(callback) {\n        const closeWebSocket = (callback) => {\n            if (this._ws.readyState === 3) {\n                callback();\n            } else {\n                this._ws.removeAllListeners('close');\n                this._ws.once('close', () => {\n                    this._ws.removeAllListeners();\n                    this._handleConnectionClose();\n                    callback();\n                });\n                this._ws.close();\n            }\n        };\n        if (typeof callback === 'function') {\n            closeWebSocket(callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                closeWebSocket(fulfill);\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Chrome extends require('events') {\n  constructor(options, notifier) {\n    super();\n    const { host = 'localhost', port = 9222, secure = false } = options;\n    this.host = host;\n    this.port = port;\n    this.secure = secure;\n    this.webSocketUrl = `${secure ? 'wss' : 'ws'}://${host}:${port}/devtools/page/${options.targetId}`;\n    this._ws = null;\n    this._notifier = notifier;\n    this._callbacks = new Map();\n    this._nextCommandId = 1;\n  }\n\n  async _start() {\n    await this._connectToWebSocket();\n  }\n\n  async _connectToWebSocket() {\n    this._ws = new (require('ws'))(this.webSocketUrl);\n    this._ws.on('open', () => this.emit('open'));\n    this._ws.on('close', this._handleConnectionClose.bind(this));\n    this._ws.on('error', (err) => this.emit('error', err));\n    this._ws.on('message', this._handleMessage.bind(this));\n  }\n\n  _handleConnectionClose() {\n    this._ws = null;\n    this.emit('close');\n  }\n\n  _handleMessage(message) {\n    const data = JSON.parse(message);\n    if (data.id) {\n      const callback = this._callbacks.get(data.id);\n      if (callback) {\n        this._callbacks.delete(data.id);\n        if (data.error) {\n          callback.reject(data.error);\n        } else {\n          callback.resolve(data.result);\n        }\n      }\n    } else if (data.method) {\n      this._notifier.emit(data.method, data.params);\n    }\n  }\n\n  send(method, params, sessionId, callback) {\n    return new Promise((resolve, reject) => {\n      const id = this._nextCommandId++;\n      const message = JSON.stringify({ id, method, params, sessionId });\n      this._callbacks.set(id, { resolve, reject });\n      this._ws.send(message);\n      if (callback) {\n        callback();\n      }\n    });\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    this.send(method, params, sessionId, callback);\n  }\n\n  close(callback) {\n    return new Promise((resolve, reject) => {\n      if (this._ws) {\n        this._ws.close();\n        this._ws.once('close', () => {\n          if (callback) callback();\n          resolve();\n        });\n        this._ws.once('error', reject);\n      } else {\n        if (callback) callback();\n        resolve();\n      }\n    });\n  }\n}\n"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Implement a WebSocket-based OrderBook class for managing real-time order book data from a cryptocurrency exchange, with connection management and state handling capabilities.\n\nClass Description: The OrderBook class maintains a real-time order book for a specified trading pair by connecting to a WebSocket feed. It handles connection states, processes incoming messages, and provides event-driven updates. The class inherits from EventEmitter to notify consumers of state changes and order book updates.\n\nAttributes:\n- productID: string - The trading pair identifier (e.g., 'BTC-USD')\n- websocketURI: string - The WebSocket endpoint URL for real-time data\n- restURI: string - The REST API endpoint URL for initial snapshot\n- state: string - Current connection/processing state (from STATES enum)\n- fail_count: number - Count of consecutive connection failures\n- timeProvider: any - Service for timestamp generation\n- socket: WebSocket - The active WebSocket connection instance\n- queue: Array - Buffer for messages received during synchronization\n- book: object - The current order book state with sequence, bids, and asks\n\nMethods:\n- constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) -> OrderBook - Initializes the order book with configuration and starts connection\n- clear_book() -> void - Resets the order book and message queue\n- connect() -> void - Establishes new WebSocket connection with event handlers\n- disconnect() -> void - Closes active WebSocket connection\n- changeState(stateName: string) -> void - Updates state machine and handles transitions (emits statechange event)\n- onOpen() -> void - Handles WebSocket open event (starts synchronization)\n- onClose() -> void - Handles WebSocket close event (updates state)\n- onMessage(datastr: string) -> void - Processes incoming WebSocket messages\n- sync() -> void - Sends subscription message and loads initial snapshot\n- processMessage(message: object, t: Date) -> void - Validates and processes order book updates (emits message-type events)",
    "Canonical_solution": "var WebSocket = require('ws');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nclass OrderBook {\n    constructor(productID: string, websocketURI: string, restURI: string, timeProvider: any) {\n        var self = this;\n        EventEmitter.call(self);\n\n        self.productID = productID || 'BTC-USD';\n        self.websocketURI = websocketURI || 'wss://ws-feed.exchange.coinbase.com';\n        self.restURI = restURI;\n        self.state = self.STATES.closed;\n        self.fail_count = 0;\n        self.timeProvider = timeProvider;\n        self.connect();\n    }\n\n    STATES = {\n        'closed': 'closed',\n        'open': 'open',\n        'syncing': 'syncing',\n        'processing': 'processing',\n        'error': 'error',\n    };\n\n    clear_book() {\n        var self = this;\n        self.queue = [];\n        self.book = {\n            'sequence': -1,\n            'bids': {},\n            'asks': {},\n        };\n    };\n\n    connect() {\n        var self = this;\n        if (self.socket) {\n            self.socket.close();\n        }\n        self.clear_book();\n        self.socket = new WebSocket(self.websocketURI);\n        self.socket.on('message', self.onMessage.bind(self));\n        self.socket.on('open', self.onOpen.bind(self));\n        self.socket.on('close', self.onClose.bind(self));\n    };\n\n    disconnect() {\n        var self = this;\n        if (!self.socket) {\n            throw \"Could not disconnect (not connected)\"\n        }\n        self.socket.close();\n        self.onClose();\n    };\n\n    changeState(stateName) {\n        var self = this;\n        var newState = self.STATES[stateName];\n        if (newState === undefined) {\n            throw \"Unrecognized state: \" + stateName;\n        }\n        var oldState = self.state;\n        self.state = newState;\n\n        if (self.fail_count > 3)\n            throw \"Tried to reconnect 4 times. Giving up.\";\n\n        if (self.state === self.STATES.error || self.state === self.STATES.closed) {\n            self.fail_count += 1;\n            self.socket.close();\n            setTimeout(() => self.connect(), 5000);\n        }\n        else if (self.state === self.STATES.processing) {\n            self.fail_count = 0;\n        }\n\n        self.emit('statechange', { 'old': oldState, 'new': newState });\n    };\n\n    onOpen() {\n        var self = this;\n        self.changeState(self.STATES.open);\n        self.sync();\n    };\n\n    onClose() {\n        var self = this;\n        self.changeState(self.STATES.closed);\n    };\n\n    onMessage(datastr: string) {\n        var self = this;\n        var t = self.timeProvider.utcNow();\n        var data = JSON.parse(datastr);\n        if (self.state !== self.STATES.processing) {\n            self.queue.push(data);\n        } else {\n            self.processMessage(data, t);\n        }\n    };\n\n    sync() {\n        var self = this;\n        self.changeState(self.STATES.syncing);\n        var subscribeMessage = {\n            'type': 'subscribe',\n            'product_id': self.productID,\n        };\n        self.socket.send(JSON.stringify(subscribeMessage));\n        self.loadSnapshot();\n    };\n\n    processMessage(message, t: Date) {\n        var self = this;\n        if (message.sequence <= self.book.sequence) {\n            self.emit('ignored', message);\n            return;\n        }\n        if (message.sequence != self.book.sequence + 1) {\n            self.changeState(self.STATES.error);\n        }\n        self.book.sequence = message.sequence;\n\n        self.emit(message.type, new Models.Timestamped(message, t));\n    };\n}\n\nutil.inherits(OrderBook, EventEmitter);",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class OrderBook extends EventEmitter {\n  static STATES = {\n    CLOSED: 'closed',\n    CONNECTING: 'connecting',\n    SYNCING: 'syncing',\n    PROCESSING: 'processing',\n    FAILED: 'failed',\n  };\n\n  constructor(productID, websocketURI, restURI, timeProvider) {\n    super();\n    this.productID = productID;\n    this.websocketURI = websocketURI;\n    this.restURI = restURI;\n    this.state = OrderBook.STATES.CLOSED;\n    this.fail_count = 0;\n    this.timeProvider = timeProvider;\n    this.socket = null;\n    this.queue = [];\n    this.book = { sequence: -1, bids: [], asks: [] };\n  }\n\n  clear_book() {\n    this.queue = [];\n    this.book = { sequence: -1, bids: [], asks: [] };\n  }\n\n  connect() {\n    if (this.state !== OrderBook.STATES.CLOSED) return;\n    this.changeState(OrderBook.STATES.CONNECTING);\n    this.socket = new WebSocket(this.websocketURI);\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onmessage = (event) => this.onMessage(event.data);\n  }\n\n  disconnect() {\n    if (this.socket) this.socket.close();\n  }\n\n  changeState(stateName) {\n    this.state = stateName;\n    this.emit('statechange', this.state);\n  }\n\n  onOpen() {\n    this.fail_count = 0;\n    this.sync();\n  }\n\n  onClose() {\n    this.socket = null;\n    if (this.state === OrderBook.STATES.CONNECTING) {\n      this.fail_count++;\n      if (this.fail_count < 3) {\n        setTimeout(this.connect.bind(this), 1000);\n        return;\n      }\n      this.changeState(OrderBook.STATES.FAILED);\n    } else {\n      this.changeState(OrderBook.STATES.CLOSED);\n    }\n  }\n\n  onMessage(datastr) {\n    const message = JSON.parse(datastr);\n    if (this.state === OrderBook.STATES.SYNCING) {\n      this.queue.push(message);\n    } else {\n      this.processMessage(message, this.timeProvider());\n    }\n  }\n\n  async sync() {\n    this.changeState(OrderBook.STATES.SYNCING);\n    this.clear_book();\n    this.socket.send(JSON.stringify({ type: 'subscribe', product_ids: [this.productID] }));\n\n    try {\n      const response = await fetch(`${this.restURI}/products/${this.productID}/book?level=3`);\n      const snapshot = await response.json();\n      this.book.sequence = snapshot.sequence;\n      this.book.bids = snapshot.bids;\n      this.book.asks = snapshot.asks;\n\n      while (this.queue.length > 0) {\n        this.processMessage(this.queue.shift(), this.timeProvider());\n      }\n      this.changeState(OrderBook.STATES.PROCESSING);\n    } catch (error) {\n      console.error('Error syncing order book:', error);\n      this.onClose();\n    }\n  }\n\n  processMessage(message, t) {\n    if (message.sequence <= this.book.sequence) return;\n    this.book.sequence = message.sequence;\n    this.emit(message.type, message, t);\n\n    if (message.type === 'open') {\n\n    } else if (message.type === 'done' && message.reason === 'filled') {\n\n    } else if (message.type === 'match') {\n\n    } else if (message.type === 'change') {\n\n    } else if (message.type === 'received') {\n\n    }\n  }\n}\n\n"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a WebSocket-based communication channel class that handles message sending, receiving, and connection management between a client and server.\n\nClass Description: The Channel class manages WebSocket communication by providing methods to send messages, handle incoming messages, and manage connection lifecycle events. It acts as an abstraction layer over raw WebSocket connections.\n\nAttributes:\n- _ws: [WebSocket] - The underlying WebSocket connection instance\n- _handler: [Object|null] - The message handler object that processes incoming messages\n- _messageListener: [Function] - The bound message event listener function\n\nMethods:\n- constructor(ws) -> [void] - Initializes the channel with a WebSocket instance and sets up message listener\n- send(message) -> [void] - Sends a message through the WebSocket if the connection is open\n- close() -> [void] - Closes the WebSocket connection\n- listen(handler) -> [void] - Sets the message handler for incoming messages\n- dispose() -> [void] - Cleans up event listeners\n- _messageReceived(message) -> [void] - Internal method that forwards incoming messages to the handler\n\nTask Description: Create a service class that manages multiple WebSocket connections and sessions for debugging purposes.\n\nClass Description: The NddService class manages multiple debugging sessions through WebSocket connections, handling session creation, connection events, and cleanup.\n\nAttributes:\n- _disconnectPromise: [Promise] - Promise that resolves when the process disconnects\n- _connected: [Set] - Set of currently connected session IDs\n- _frontend: [Object] - Frontend interface for handling session events\n- _pipe: [string] - Path to the named pipe for IPC communication\n\nMethods:\n- constructor(frontend) -> [void] - Initializes the service with frontend interface and sets up IPC server\n- _startSession(info, frontend) -> [Promise<Function>] - Starts a new debugging session and returns a cleanup function\n  - info: [Object] - Session information including inspector URL and ID\n  - frontend: [Object] - Frontend interface for session events\n  - Returns: [Function] - Async cleanup function for the session",
    "Canonical_solution": "const { spawn } = require('child_process');\nconst os = require('os');\nconst path = require('path');\nconst net = require('net');\nconst WebSocket = require('ws');\n\nclass Channel {\n  /**\n   * @param {!WebSocket} ws\n   */\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.on('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  /**\n   * @param {!Object}\n   */\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeListener('message', this._messageListener);\n  }\n\n  /**\n   * @param {string} message\n   */\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler.dispatchMessage(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => process.once('disconnect', () => resolve()));\n    this._connected = new Set();\n    this._frontend = frontend;\n\n    const pipePrefix = process.platform === 'win32' ? '\\\\\\\\.\\\\pipe\\\\' : os.tmpdir();\n    const pipeName = `node-ndb.${process.pid}.sock`;\n    this._pipe = path.join(pipePrefix, pipeName);\n    const server = net.createServer(socket => {\n      socket.on('data', async d => {\n        const runSession = await this._startSession(JSON.parse(d), frontend);\n        socket.write('run');\n        runSession();\n      });\n      socket.on('error', e => {});\n    }).listen(this._pipe);\n    server.unref();\n  }\n\n  async _startSession(info, frontend) {\n    const ws = new WebSocket(info.inspectorUrl);\n    const openPromise = new Promise(resolve => ws.once('open', () => resolve()));\n    const errorPromise = new Promise(resolve => ws.once('error', () => resolve()));\n    const closePromise = new Promise(resolve => ws.once('close', () => resolve()));\n    let state = await Promise.race([openPromise, errorPromise, closePromise, this._disconnectPromise]);\n    if (state === openPromise) {\n      this._connected.add(info.id);\n      const channel = new Channel(ws);\n      state = await Promise.race([frontend.detected(info, rpc.handle(channel)), this._disconnectPromise]);\n      return async() => {\n        if (state !== this._disconnectPromise)\n          state = await Promise.race([closePromise, errorPromise, this._disconnectPromise]);\n        channel.dispose();\n        this._connected.delete(info.id);\n        if (state !== this._disconnectPromise)\n          frontend.disconnected(info.id);\n        else\n          ws.send(CALL_EXIT_MESSAGE, () => ws.close());\n      };\n    } else {\n      return async function() {};\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class Channel {\n  constructor(ws) {\n    this._ws = ws;\n    this._handler = null;\n    this._messageListener = this._messageReceived.bind(this);\n    this._ws.addEventListener('message', this._messageListener);\n  }\n\n  send(message) {\n    if (this._ws.readyState === WebSocket.OPEN) {\n      this._ws.send(message);\n    }\n  }\n\n  close() {\n    this._ws.close();\n  }\n\n  listen(handler) {\n    this._handler = handler;\n  }\n\n  dispose() {\n    this._ws.removeEventListener('message', this._messageListener);\n  }\n\n  _messageReceived(message) {\n    if (this._handler) {\n      this._handler(message);\n    }\n  }\n}\n\nclass NddService {\n  constructor(frontend) {\n    this._disconnectPromise = new Promise(resolve => {\n      process.once('disconnect', resolve);\n    });\n    this._connected = new Set();\n    this._frontend = frontend;\n  }\n\n  async _startSession(info, frontend) {\n    const { id, url } = info;\n    const ws = new WebSocket(url);\n    const channel = new Channel(ws);\n\n    this._connected.add(id);\n    frontend.frontendAttached(id, channel);\n\n    const cleanup = async () => {\n      this._connected.delete(id);\n      channel.dispose();\n      ws.close();\n      frontend.frontendDetached(id);\n    };\n\n    ws.addEventListener('close', cleanup);\n    ws.addEventListener('error', cleanup);\n\n    return cleanup;\n  }\n}\n"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a WebSocket client class for interacting with Chrome's DevTools Protocol, handling connection, message exchange, and event emission.\n\nClass Description: The Chrome class extends EventEmitter to create a WebSocket client that connects to Chrome's DevTools Protocol. It manages WebSocket connections, handles message parsing, and provides methods for sending commands and receiving responses/events.\n\nAttributes:\n- host: [String] - The host address for the WebSocket connection (default: 'localhost')\n- port: [Number] - The port number for the WebSocket connection (default: 9222)\n- secure: [Boolean] - Flag indicating whether to use secure WebSocket (wss)\n- _notifier: [Object] - External notification handler\n- _callbacks: [Object] - Map of pending command callbacks\n- _nextCommandId: [Number] - Counter for generating command IDs\n- webSocketUrl: [String] - The complete WebSocket URL for connection\n- _ws: [WebSocket] - The active WebSocket connection instance\n\nMethods:\n- constructor: [constructor](options: Object, notifier: Object) -> [Chrome] - Initializes the Chrome instance with connection options and notifier\n- _connectToWebSocket: [_connectToWebSocket]() -> [Promise] - Establishes WebSocket connection and sets up event handlers\n- _handleMessage: [_handleMessage](message: Object) -> [void] - Processes incoming WebSocket messages (responses and events)\n- _enqueueCommand: [_enqueueCommand](method: String, params: Object, sessionId: String, callback: Function) -> [void] - Sends a command through WebSocket and tracks its callback\n- send: [send](method: String, ...args: Any) -> [Promise|undefined] - Public method to send commands, supporting both callback and Promise patterns",
    "Canonical_solution": "const EventEmitter = require('events');\nconst WebSocket = require('ws');\n\nclass Chrome extends EventEmitter {\n    constructor(options, notifier) {\n        super();\n        this.host = options.host || 'localhost';\n        this.port = options.port || 9222;\n        this.secure = !!(options.secure);\n        this._notifier = notifier;\n        this._callbacks = {};\n        this._nextCommandId = 1;\n        this.webSocketUrl = undefined;\n        this._start();\n    }\n\n    _connectToWebSocket() {\n        return new Promise((fulfill, reject) => {\n            try {\n                if (this.secure) {\n                    this.webSocketUrl = this.webSocketUrl.replace(/^ws:/i, 'wss:');\n                }\n                this._ws = new WebSocket(this.webSocketUrl, [], {\n                    maxPayload: 256 * 1024 * 1024,\n                    perMessageDeflate: false,\n                    followRedirects: true,\n                });\n\n                this._ws.on('open', () => {\n                    fulfill();\n                });\n                this._ws.on('message', (data) => {\n                    const message = JSON.parse(data);\n                    this._handleMessage(message);\n                });\n                this._ws.on('close', (code) => {\n                    this._handleConnectionClose();\n                    this.emit('disconnect');\n                });\n                this._ws.on('error', (err) => {\n                    reject(err);\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n\n    _handleMessage(message) {\n        if (message.id) {\n            const callback = this._callbacks[message.id];\n            if (!callback) return;\n            \n            if (message.error) {\n                callback(true, message.error);\n            } else {\n                callback(false, message.result || {});\n            }\n            delete this._callbacks[message.id];\n            \n            if (Object.keys(this._callbacks).length === 0) {\n                this.emit('ready');\n            }\n        } else if (message.method) {\n            const {method, params, sessionId} = message;\n            this.emit('event', message);\n            this.emit(method, params, sessionId);\n            this.emit(`${method}.${sessionId}`, params, sessionId);\n        }\n    }\n\n    _enqueueCommand(method, params, sessionId, callback) {\n        const id = this._nextCommandId++;\n        const message = {\n            id,\n            method,\n            sessionId,\n            params: params || {}\n        };\n        this._ws.send(JSON.stringify(message), (err) => {\n            if (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                }\n            } else {\n                this._callbacks[id] = callback;\n            }\n        });\n    }\n\n    send(method, params, sessionId, callback) {\n        const optionals = Array.from(arguments).slice(1);\n        params = optionals.find(x => typeof x === 'object');\n        sessionId = optionals.find(x => typeof x === 'string');\n        callback = optionals.find(x => typeof x === 'function');\n        \n        if (typeof callback === 'function') {\n            this._enqueueCommand(method, params, sessionId, callback);\n            return undefined;\n        } else {\n            return new Promise((fulfill, reject) => {\n                this._enqueueCommand(method, params, sessionId, (error, response) => {\n                    if (error) {\n                        const request = {method, params, sessionId};\n                        reject(error instanceof Error ? error : new ProtocolError(request, response));\n                    } else {\n                        fulfill(response);\n                    }\n                });\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "const EventEmitter = require('events');\n\nclass Chrome extends EventEmitter {\n  constructor(options = {}, notifier) {\n    super();\n    this.host = options.host || 'localhost';\n    this.port = options.port || 9222;\n    this.secure = !!options.secure;\n    this._notifier = notifier;\n    this._callbacks = new Map();\n    this._nextCommandId = 1;\n    this.webSocketUrl = '';\n    this._ws = null;\n  }\n\n  async _connectToWebSocket() {\n    const url = `ws${this.secure ? 's' : ''}://${this.host}:${this.port}/devtools/page/${this.targetId}`;\n    this.webSocketUrl = url;\n    this._ws = new (require('ws'))(url);\n    this._ws.on('open', () => this.emit('connect'));\n    this._ws.on('error', (err) => this.emit('error', err));\n    this._ws.on('close', () => this.emit('disconnect'));\n    this._ws.on('message', (message) => this._handleMessage(JSON.parse(message)));\n  }\n\n  _handleMessage(message) {\n    if (message.method) {\n      this.emit(message.method, message.params);\n    } else if (message.id) {\n      const callback = this._callbacks.get(message.id);\n      if (callback) {\n        this._callbacks.delete(message.id);\n        if (message.error) {\n          callback.reject(message.error);\n        } else {\n          callback.resolve(message.result);\n        }\n      }\n    }\n  }\n\n  _enqueueCommand(method, params, sessionId, callback) {\n    const id = this._nextCommandId++;\n    const message = { id, method, params, sessionId };\n    this._ws.send(JSON.stringify(message));\n    if (callback) {\n      this._callbacks.set(id, { resolve: callback, reject: callback });\n    }\n  }\n\n  send(method, ...args) {\n    const params = args.length > 1 ? args.slice(0, -1) : args[0];\n    const callback = typeof args[args.length - 1] === 'function' ? args[args.length - 1] : undefined;\n    if (callback) {\n      this._enqueueCommand(method, params, this.sessionId, callback);\n    } else {\n      return new Promise((resolve, reject) => {\n        this._enqueueCommand(method, params, this.sessionId, (err, result) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n        });\n      });\n    }\n  }\n}\n"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a WebSocket client class in Node.js that handles WebSocket connections, message transmission, and connection lifecycle events.\n\nClass Description: WebSocketImpl is a WebSocket client implementation that manages WebSocket connections, including establishing connections, handling incoming messages, managing connection states, and sending messages. It wraps the 'ws' library functionality with additional state management and event handling.\n\nAttributes:\n- _globalObject: [Object] - The global context in which the WebSocket operates\n- _ownerDocument: [Object] - The document associated with the WebSocket\n- _urlRecord: [Object|null] - URL information for the WebSocket connection\n- url: [String] - The WebSocket server URL\n- extensions: [String] - Supported WebSocket extensions\n- binaryType: [String] - Type of binary data handling (\"blob\" or \"arraybuffer\")\n- _ws: [Object|null] - The underlying WebSocket instance\n- _readyState: [Number] - Current connection state (0=CONNECTING, 1=OPEN, 2=CLOSING, 3=CLOSED)\n- _requiredToFail: [Boolean] - Flag indicating if the connection should fail\n- bufferedAmount: [Number] - Number of bytes of queued data\n- _sendQueue: [Array] - Queue of messages waiting to be sent\n- _dequeueScheduled: [Boolean] - Flag for send queue scheduling\n\nMethods:\n- constructor(globalObject, args, privateData) -> [void] - Initializes the WebSocket client with configuration and establishes connection\n- _onConnectionEstablished() -> [void] - Handles successful connection establishment\n- _onMessageReceived(data, isBinary) -> [void] - Processes incoming WebSocket messages\n- _onConnectionClosed(code, reason) -> [void] - Handles connection closure\n- close(code, reason) -> [void] - Closes the WebSocket connection with optional code and reason\n- send(data) -> [void] - Queues data for sending through the WebSocket\n- _actuallySend() -> [void] - Internal method that sends queued messages\n- _scheduleSend() -> [void] - Schedules message sending on the next event loop tick",
    "Canonical_solution": "const WebSocket = require(\"ws\");\n\nclass WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = privateData.document;\n    this._urlRecord = null;\n    this.url = \"\";\n    this.extensions = \"\";\n    this.binaryType = \"blob\";\n    this._ws = null;\n    this._readyState = 0; // CONNECTING\n    this._requiredToFail = false;\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n\n    const url = args[0];\n    let protocols = args[1] !== undefined ? args[1] : [];\n\n    this._ws = new WebSocket(this.url, protocols, {\n      headers: {\n        \"user-agent\": globalObject.navigator.userAgent,\n        \"cookie\": this._ownerDocument._cookieJar.getCookieStringSync(nodeParsedURL, { http: true }),\n        \"origin\": globalObject._origin\n      },\n      rejectUnauthorized: globalObject._resourceLoader._strictSSL\n    });\n\n    this._ws.once(\"open\", () => {\n      this._onConnectionEstablished();\n    });\n    this._ws.on(\"message\", this._onMessageReceived.bind(this));\n    this._ws.once(\"close\", (...closeArgs) => {\n      this._onConnectionClosed(...closeArgs);\n    });\n    this._ws.once(\"error\", () => {\n      this._requiredToFail = true;\n    });\n  }\n\n  _onConnectionEstablished() {\n    if (this._ws.extensions !== null) {\n      this.extensions = Object.keys(this._ws.extensions).join(\", \");\n    }\n    // fire open event\n  }\n\n  _onMessageReceived(data, isBinary) {\n    if (this.readyState !== 1) { // OPEN\n      return;\n    }\n    // process message data and fire message event\n  }\n\n  _onConnectionClosed(code, reason) {\n    // fire close event\n  }\n\n  close(code = undefined, reason = undefined) {\n    if (this.readyState === 0) { // CONNECTING\n      this._requiredToFail = true;\n      if (this._ws !== null) {\n        this._ws.terminate();\n      } else {\n        this._readyState = 2; // CLOSING\n      }\n    } else if (this.readyState === 1) { // OPEN\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    if (this.readyState === 0) { // CONNECTING\n      throw new Error(\"Still in CONNECTING state.\");\n    }\n    if (this.readyState !== 1) { // OPEN\n      return;\n    }\n    let length;\n    if (typeof data === \"string\") {\n      length = Buffer.byteLength(data, \"utf8\");\n    } else {\n      length = data.byteLength;\n    }\n    this.bufferedAmount += length;\n    this._sendQueue.push([data, length]);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    for (const [data, length] of this._sendQueue.splice(0)) {\n      this._ws.send(data, { binary: typeof data !== \"string\" }, () => {\n        this.bufferedAmount -= length;\n      });\n    }\n  }\n\n  _scheduleSend() {\n    if (this._dequeueScheduled) {\n      return;\n    }\n    this._dequeueScheduled = true;\n    process.nextTick(() => {\n      this._dequeueScheduled = false;\n      this._actuallySend();\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 91,
    "wrong_result": "class WebSocketImpl {\n  constructor(globalObject, args, privateData) {\n    this._globalObject = globalObject;\n    this._ownerDocument = privateData.ownerDocument;\n    this._urlRecord = privateData.urlRecord;\n\n    this.url = this._urlRecord.urlList[0].toString();\n    this.extensions = '';\n    this.binaryType = 'blob';\n\n    this._ws = null;\n    this._readyState = 0; // CONNECTING\n\n    this._requiredToFail = false;\n\n    this.bufferedAmount = 0;\n    this._sendQueue = [];\n    this._dequeueScheduled = false;\n\n\n    const ws = new this._globalObject.WebSocket(this.url);\n\n    this._ws = ws;\n\n    ws.onopen = () => this._onConnectionEstablished();\n    ws.onmessage = (event) => this._onMessageReceived(event.data, event.binary);\n    ws.onclose = (event) => this._onConnectionClosed(event.code, event.reason);\n    ws.onerror = () => {\n      if (this._readyState === 0) {\n        this._readyState = 3;\n      }\n    };\n\n  }\n\n  _onConnectionEstablished() {\n    this._readyState = 1;\n  }\n\n  _onMessageReceived(data, isBinary) {\n    const messageEvent = new this._globalObject.MessageEvent('message', {\n      data: data,\n      origin: this._urlRecord.urlList[0].origin\n    });\n    this._ownerDocument._dispatch(messageEvent);\n  }\n\n  _onConnectionClosed(code, reason) {\n    this._readyState = 3;\n    const closeEvent = new this._globalObject.CloseEvent('close', {\n      code: code,\n      reason: reason,\n      wasClean: true\n    });\n    this._ownerDocument._dispatch(closeEvent);\n  }\n\n  close(code, reason) {\n    if (this._ws) {\n      this._ws.close(code, reason);\n    }\n  }\n\n  send(data) {\n    this.bufferedAmount += data.length;\n    this._sendQueue.push(data);\n    this._scheduleSend();\n  }\n\n  _actuallySend() {\n    while (this._sendQueue.length) {\n      const data = this._sendQueue.shift();\n      this._ws.send(data);\n      this.bufferedAmount -= data.length;\n    }\n    this._dequeueScheduled = false;\n  }\n\n  _scheduleSend() {\n    if (!this._dequeueScheduled) {\n      this._dequeueScheduled = true;\n      process.nextTick(() => this._actuallySend());\n    }\n  }\n}\n"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a class that handles the downloading and installation of binary packages from a specified URL, including directory management and error handling.\n\nClass Description: The Binary class is responsible for downloading a binary package from a given URL, extracting it to a specified directory, and managing the installation process. It handles directory creation, file extraction, and provides feedback on the installation status.\n\nAttributes:\n- url: [String] - The URL from which the binary package will be downloaded.\n- name: [String] - The name of the binary package (optional, defaults to -1).\n- installDirectory: [String] - The base directory where the binary will be installed (optional, defaults to a 'bin' subdirectory in the current working directory).\n- binaryDirectory: [String] - The full path to the directory where the binary will be extracted (initialized as -1, set during installation).\n- binaryPath: [String] - The full path to the binary file (initialized as -1, not used in current implementation).\n\nMethods:\n- constructor(url, data) -> [None] - Initializes the Binary instance with the download URL and optional configuration data (name and installDirectory).\n- install() -> [Promise] - Handles the complete installation process including directory preparation, downloading, extraction, and cleanup. Returns a Promise that resolves when installation is complete or rejects on error.\n  - Internal method _getInstallDirectory() is used to determine the installation directory path.",
    "Canonical_solution": "const axios = require(\"axios\");\n\nclass Binary {\n    constructor(url, data) {\n        this.url = url;\n        this.name = data.name || -1;\n        this.installDirectory = data.installDirectory || join(__dirname, \"bin\");\n        this.binaryDirectory = -1;\n        this.binaryPath = -1;\n    }\n\n    install() {\n        const dir = this._getInstallDirectory();\n        if (!existsSync(dir)) {\n            mkdirSync(dir, { recursive: true });\n        }\n\n        this.binaryDirectory = join(dir, \"bin\");\n\n        if (existsSync(this.binaryDirectory)) {\n            rimraf.sync(this.binaryDirectory);\n        }\n\n        mkdirSync(this.binaryDirectory, { recursive: true });\n\n        console.log(`Downloading release from ${this.url}`);\n\n        return axios({ url: this.url, responseType: \"stream\" })\n            .then(res => {\n                const writer = tar.x({ strip: 1, C: this.binaryDirectory });\n\n                return new Promise((resolve, reject) => {\n                    res.data.pipe(writer);\n                    let error = null;\n                    writer.on('error', err => {\n                      error = err;\n                      reject(err);\n                    });\n                    writer.on('close', () => {\n                      if (!error) {\n                        resolve(true);\n                      }\n                    });\n                })\n            })\n            .then(() => {\n                console.log(\n                    `${this.name ? this.name : \"Your package\"} has been installed!`\n                );\n            })\n            .catch(e => {\n                error(`Error fetching release: ${e.message}`);\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nclass Binary {\n  constructor(url, data = {}) {\n    this.url = url;\n    this.name = data.name || -1;\n    this.installDirectory = data.installDirectory || 'bin';\n    this.binaryDirectory = -1;\n    this.binaryPath = -1;\n  }\n\n  async install() {\n    const installDir = this._getInstallDirectory();\n    this.binaryDirectory = installDir;\n\n    try {\n      const response = await fetch(this.url);\n      if (!response.ok) {\n        throw new Error(`Failed to download binary: ${response.status} ${response.statusText}`);\n      }\n\n      const blob = await response.blob();\n      const zip = await JSZip.loadAsync(blob);\n\n      await new Promise((resolve, reject) => {\n        zip.folder(Object.keys(zip.files)[0]).forEach((relativePath, file) => {\n          if (!file.dir) {\n            file.async('nodebuffer').then(content => {\n              const filePath = path.join(installDir, relativePath);\n              fs.mkdirSync(path.dirname(filePath), { recursive: true });\n              fs.writeFileSync(filePath, content);\n            }).catch(reject);\n          }\n        });\n        resolve();\n      });\n\n\n    } catch (error) {\n      throw new Error(`Installation failed: ${error.message}`);\n    }\n  }\n\n\n  _getInstallDirectory() {\n    if (this.installDirectory.startsWith('/') || this.installDirectory.startsWith('./') || this.installDirectory.startsWith('../')) {\n      return path.resolve(this.installDirectory);\n    } else {\n      return path.resolve(process.cwd(), this.installDirectory);\n    }\n\n  }\n}\n```"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a function that establishes a WebSocket connection to a server, sends and receives messages in JSON format, and handles connection events including opening, closing, and errors.\n\nFunction Description: The function `testWebSocketConnection` initiates a WebSocket client connection to a specified server URL. It sends initial messages upon successful connection, listens for incoming messages, and handles connection lifecycle events. The function demonstrates a basic WebSocket interaction pattern including sending/receiving JSON data and proper connection cleanup.\n\nInput: \n- wssUrl: [String] - The WebSocket server URL (without protocol) to connect to (e.g., \"example.com:8080\")\n\nOutput: \n- None (void) - The function doesn't return any value but logs connection status and received messages to the console. All operations are performed through side effects (event handlers and WebSocket operations).",
    "Canonical_solution": "function testWebSocketConnection() {\n  var WebSocket = require('ws');\n  var echoWs = new WebSocket('wss://' + wssUrl + '/examples/echo');\n  \n  echoWs.on('open', function open() {\n    console.log('WebSocket connection established');\n    \n    echoWs.send('hello');\n    echoWs.once('message', function(data, flags) {\n      data = JSON.parse(data);\n      console.log('Received:', data);\n      \n      echoWs.send('{\"foo\": \"bar\"}');\n      echoWs.once('message', function(data, flags) {\n        data = JSON.parse(data);\n        console.log('Received:', data);\n        \n        echoWs.close();\n      });\n    });\n  });\n  \n  echoWs.on('close', function() {\n    console.log('WebSocket connection closed');\n  });\n  \n  echoWs.on('error', function(err) {\n    console.error('WebSocket error:', err);\n  });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 91,
    "wrong_result": "function testWebSocketConnection(wssUrl) {\n  const ws = new WebSocket(`wss://${wssUrl}`);\n\n  ws.onopen = () => {\n    console.log(\"WebSocket connection established\");\n    ws.send(JSON.stringify({ type: \"initialMessage\", data: \"Hello from client\" }));\n    setInterval(() => {\n      const message = { type: \"heartbeat\", timestamp: Date.now() };\n      ws.send(JSON.stringify(message));\n    }, 5000);\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const message = JSON.parse(event.data);\n      console.log(\"Received message:\", message);\n      if (message.type === 'close') {\n        ws.close();\n      }\n    } catch (error) {\n      console.error(\"Failed to parse message:\", error);\n    }\n  };\n\n  ws.onclose = (event) => {\n    console.log(\"WebSocket connection closed:\", event.code, event.reason);\n  };\n\n  ws.onerror = (error) => {\n    console.error(\"WebSocket error:\", error);\n    ws.close();\n  };\n}\n\n"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Create a function that sends data to a webhook URL using HTTP POST request with error handling.\n\nFunction Description: The function `sendWebhook` is an asynchronous function that takes data as input and sends it to a predefined webhook URL using an HTTP POST request. It handles potential errors during the request and logs them to the console.\n\nInput: \n- `data` [Object] - The payload/data to be sent to the webhook URL.\n\nOutput: \n- None (The function does not return any value, but it may log errors to the console if the request fails).",
    "Canonical_solution": "const axios = require('axios');\n\nconst sendWebhook = async (data) => {\n    try {\n        await axios.post(process.env.UPDATE_WEBHOOK, data);\n    } catch (err) {\n        console.log(err);\n    }\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function sendWebhook(data) {\n  const webhookUrl = 'YOUR_WEBHOOK_URL'; // Replace with your actual webhook URL\n\n  try {\n    const response = await fetch(webhookUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.text();\n      console.error(`Webhook request failed with status ${response.status}: ${errorData}`);\n      throw new Error(`Webhook request failed with status ${response.status}`);\n    }\n\n    console.log('Webhook data sent successfully');\n\n  } catch (error) {\n    console.error('Error sending webhook data:', error);\n  }\n}\n"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a function that interacts with Microsoft's Speech API to convert SSML (Speech Synthesis Markup Language) text into speech audio using HTTP requests.\n\nFunction Description: The function `speechApi` sends a POST request to Microsoft's Speech API endpoint with SSML text as input and receives audio data in MP3 format as response. It handles the HTTP communication including request configuration, headers, payload, and error handling.\n\nInput: \n- ssml: [String] - The SSML formatted text to be converted to speech\n\nOutput: \n- [Promise] - Resolves with the audio data in arraybuffer format if successful, rejects with error if the request fails",
    "Canonical_solution": "const axios = require(\"axios\");\nconst { v4: uuidv4 } = require(\"uuid\");\n\nfunction speechApi(ssml) {\n    var data = JSON.stringify({\n        ssml,\n        ttsAudioFormat: \"audio-24khz-160kbitrate-mono-mp3\",\n        offsetInPlainText: 0,\n        properties: {\n            SpeakTriggerSource: \"AccTuningPagePlayButton\",\n        },\n    });\n\n    var config = {\n        method: \"post\",\n        url: \"https://southeastasia.api.speech.microsoft.com/accfreetrial/texttospeech/acc/v3.0-beta1/vcg/speak\",\n        responseType: \"arraybuffer\",\n        headers: {\n            authority: \"southeastasia.api.speech.microsoft.com\",\n            accept: \"*/*\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            customvoiceconnectionid: uuidv4(),\n            origin: \"https://speech.microsoft.com\",\n            \"sec-ch-ua\": '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": '\"Windows\"',\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-site\",\n            \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n            \"content-type\": \"application/json\",\n        },\n        data: data,\n    };\n\n    return new Promise((resolve, reject) => {\n        axios(config)\n            .then(function(response) {\n                resolve(response.data);\n            })\n            .catch(function(error) {\n                console.error(error);\n                reject(error);\n            });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function speechApi(ssml) {\n  const apiKey = process.env.SPEECH_API_KEY;\n  const region = process.env.SPEECH_API_REGION;\n\n  if (!apiKey || !region) {\n    throw new Error(\"Environment variables SPEECH_API_KEY and SPEECH_API_REGION are required.\");\n  }\n\n  const url = `https://${region}.tts.speech.microsoft.com/cognitiveservices/v1`;\n  const headers = {\n    'Ocp-Apim-Subscription-Key': apiKey,\n    'Content-Type': 'application/ssml+xml',\n    'X-Microsoft-OutputFormat': 'audio-16khz-32kbitrate-mono-mp3',\n    'User-Agent': 'speech-api-client'\n  };\n\n  const body = `<speak version='1.0' xml:lang='en-US'><voice xml:lang='en-US' xml:gender='Female' name='en-US-JennyNeural'>${ssml}</voice></speak>`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers,\n      body\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Speech API request failed with status ${response.status}: ${errorText}`);\n    }\n\n    const audioData = await response.arrayBuffer();\n    return audioData;\n  } catch (error) {\n    throw error;\n  }\n}\n\n```"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Write a function that retrieves TV channel data from a specified URL, processes the data to extract relevant channel information, and returns it in a structured format.\n\nFunction Description: The function `getChannels` asynchronously fetches TV channel data from a remote API endpoint using HTTP GET request. It processes the response to extract channel details such as language, site ID, and name, then returns them as an array of objects. Error handling is included to log any issues during the request.\n\nInput: None (The function does not take any input parameters; it uses a hardcoded URL for the API endpoint.)\n\nOutput: An array of objects, where each object represents a TV channel with the following properties:\n- `lang`: [String] - The language of the channel (e.g., 'lv').\n- `site_id`: [String] - The unique identifier/slug for the channel.\n- `name`: [String] - The display name of the channel.\n\nIf an error occurs during the HTTP request, the error will be logged to the console, and the function may return an empty array or undefined depending on the error handling flow.",
    "Canonical_solution": "async function getChannels() {\n    const axios = require('axios');\n    const groups = await axios\n        .get('https://www.tv.lv/data/channels/lvall')\n        .then(r => r.data)\n        .catch(console.log);\n\n    let channels = [];\n\n    groups.forEach(group => {\n        group.channels.forEach(item => {\n            channels.push({\n                lang: 'lv',\n                site_id: item.slug,\n                name: item.name\n            });\n        });\n    });\n\n    return channels;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function getChannels() {\n  const url = 'https://tv.lv/api/v3/channels';\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.map(channel => ({\n      lang: channel.lang,\n      site_id: channel.site_id,\n      name: channel.name\n    }));\n  } catch (error) {\n    console.error('Error fetching channel data:', error);\n    return [];\n  }\n}\n```\n"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: \nCreate a WebSocket-based control class for managing connections and communication between a client and a local server, including authorization, message handling, and API invocation.\n\nClass Description: \nThe `CocogoatWebControl` class provides functionality to establish and manage WebSocket connections to a local server, handle authorization, send/receive messages, and invoke API methods through WebSocket communication.\n\nAttributes:\n- port: number - The port number for the local server connection (default: 32333)\n- token: string - The authorization token for authenticated requests\n- hwnd: number - A window handle identifier (default: 0)\n- version: string - Version information (currently unused in the reference code)\n- ev: Mitt - An event emitter for handling WebSocket messages\n- client: FlyType - An HTTP client for initial authorization\n- ws: WebSocket | undefined - The active WebSocket connection instance\n\nMethods:\n- constructor(_port?: number) -> void - Initializes the control instance with optional port specification\n- authorize() -> Promise<boolean> - Establishes WebSocket connection and obtains authorization token\n- wsInvoke(method: string, path: string, querystring?: Record<string, any>) -> Promise<{status: number, body: any}> - Invokes an API method through WebSocket connection",
    "Canonical_solution": "import mitt from 'mitt'\nimport { stringify } from 'qs'\nimport Fly from 'flyio/dist/npm/fly'\nimport type { Fly as FlyType, FlyError } from 'flyio'\n\nexport class CocogoatWebControl {\n    port = 32333\n    token = ''\n    hwnd = 0\n    version = ''\n    ev = mitt()\n    client: FlyType = new Fly()\n    ws: WebSocket | undefined\n\n    constructor(_port = 32333) {\n        this.port = _port\n        this.client.config.baseURL = `http://localhost:${this.port}`\n        this.client.interceptors.request.use((request) => {\n            if (this.token) {\n                request.headers['Authorization'] = `Bearer ${this.token}`\n            }\n            if (request.headers['Content-Type'] === '') {\n                delete request.headers['Content-Type']\n            }\n            return request\n        })\n        this.client.interceptors.response.use(undefined, (e) => {\n            const er = e as unknown as FlyError\n            if (er.status === 410) {\n                console.warn('Control stopped by user')\n                return new Error('ECANCEL')\n            }\n            return e\n        })\n    }\n\n    async authorize() {\n        if (this.ws) {\n            return true\n        }\n        try {\n            const { data } = await this.client.post('/token')\n            this.token = data.token\n            this.hwnd = data.hwnd || 0\n            const ws = new WebSocket(`ws://localhost:${this.port}/ws/${this.token}`)\n            ws.onmessage = (e) => {\n                const data = JSON.parse(e.data)\n                this.ev.emit(data.id || data.action, data.data)\n            }\n            ws.onclose = () => {\n                this.ws = undefined\n            }\n            await new Promise((resolve) => {\n                ws.onopen = resolve\n            })\n            this.ws = ws\n            return true\n        } catch (e) {\n            const er = e as FlyError\n            if (er.status === 401) {\n                return false\n            }\n            throw e\n        }\n    }\n\n    wsInvoke(method: string, path: string, querystring?: Record<string, any>) {\n        if (!this.ws) throw new Error('WebSocket not connected')\n        const url = path + (querystring ? `?${stringify(querystring)}` : '')\n        const id = Math.round(Date.now() * 1000 + Math.random() * 1000).toString(16)\n        const reqjson = {\n            id,\n            action: 'api',\n            data: {\n                url,\n                method,\n            },\n        }\n        const resp = new Promise((resolve) => {\n            this.ev.on(id, resolve)\n        })\n        this.ws.send(JSON.stringify(reqjson))\n        return resp as Promise<{\n            status: number\n            body: any\n        }>\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 89,
    "wrong_result": "```typescript\nimport { Mitt } from 'mitt'\nimport WebSocket from 'ws'\nimport Fly from '@fly/fly'\n\ntype FlyType = Fly\n\nclass CocogoatWebControl {\n  port: number\n  token: string\n  hwnd: number\n  version: string\n  ev: Mitt\n  client: FlyType\n  ws: WebSocket | undefined\n\n  constructor(_port?: number) {\n    this.port = _port || 32333\n    this.token = ''\n    this.hwnd = 0\n    this.version = ''\n    this.ev = new Mitt()\n    this.client = new Fly()\n  }\n\n  async authorize(): Promise<boolean> {\n    try {\n      const res = await this.client.get(`http://127.0.0.1:${this.port}/auth`)\n      if (res.status === 200) {\n        const data = res.data as { token: string; hwnd?: number; version?: string }\n        this.token = data.token\n        this.hwnd = data.hwnd || 0\n        this.version = data.version || ''\n\n        this.ws = new WebSocket(`ws://127.0.0.1:${this.port}/ws`)\n        this.ws.on('open', () => {\n          this.ev.emit('open')\n        })\n        this.ws.on('message', (data) => {\n          this.ev.emit('message', data)\n        })\n        this.ws.on('close', () => {\n          this.ev.emit('close')\n        })\n        this.ws.on('error', (err) => {\n          this.ev.emit('error', err)\n        })\n        return true\n      } else {\n        return false\n      }\n    } catch (err) {\n      return false\n    }\n  }\n\n  async wsInvoke(method: string, path: string, querystring?: Record<string, any>): Promise<{ status: number; body: any }> {\n    return new Promise((resolve, reject) => {\n      if (!this.ws) {\n        reject(new Error('WebSocket not connected'))\n        return\n      }\n\n      const requestId = Math.random().toString(36).substring(2)\n      const message = {\n        id: requestId,\n        method,\n        path,\n        token: this.token,\n        querystring,\n      }\n\n      const listener = (data: any) => {\n        try {\n          const parsedData = JSON.parse(data.toString())\n          if (parsedData.id === requestId) {\n            this.ev.off('message', listener)\n            resolve({ status: parsedData.status, body: parsedData.body })\n          }\n        } catch (e) {\n          // Handle parsing errors if necessary\n        }\n      }\n\n      this.ev.on('message', listener)\n      this.ws.send(JSON.stringify(message))\n    })\n  }\n}\n\n```\n"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Implement a WebSocket client function in JavaScript that establishes a connection to a WebSocket server, handles connection events, sends messages, and manages errors and closures.\n\nFunction Description: The function `connectWebSocket` initializes a WebSocket client connection to a specified server. It sets up event handlers for connection opening, incoming messages, and connection closing. The function also sends an initial message upon successful connection and logs all events to the console.\n\nInput: \n- Optional command line arguments:\n  - `port` (number): The port number to connect to (default: 7000).\n  - `secure` (boolean): Whether to use a secure WebSocket connection (wss) (default: false, uses ws).\n\nOutput: \n- No explicit return value. The function logs connection status, received messages, and closure events to the console.\n- Side effects: Establishes a WebSocket connection and sends/receives messages.",
    "Canonical_solution": "function connectWebSocket() {\n    var WebSocket = require('../lib/faye/websocket'),\n        port = process.argv[2] || 7000,\n        secure = process.argv[3] === 'ssl',\n        scheme = secure ? 'wss' : 'ws',\n        ws = new WebSocket.Client(scheme + '://localhost:' + port + '/');\n\n    console.log('Connecting to ' + ws.url);\n\n    ws.onopen = function(event) {\n        console.log('open');\n        ws.send('Hello, WebSocket!');\n    };\n\n    ws.onmessage = function(event) {\n        console.log('message', event.data);\n    };\n\n    ws.onclose = function(event) {\n        console.log('close', event.code, event.reason);\n    };\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 89,
    "wrong_result": "```javascript\nconst WebSocket = require('ws');\n\nfunction connectWebSocket(port = 7000, secure = false) {\n  const protocol = secure ? 'wss' : 'ws';\n  const ws = new WebSocket(`${protocol}://localhost:${port}`);\n\n  ws.on('open', () => {\n    console.log('WebSocket connection opened');\n    ws.send('Hello from client!');\n  });\n\n  ws.on('message', (data) => {\n    console.log('Received:', data.toString());\n  });\n\n  ws.on('close', (code, reason) => {\n    console.log('WebSocket connection closed', code, reason.toString());\n  });\n\n  ws.on('error', (error) => {\n    console.error('WebSocket error:', error);\n  });\n}\n\nconst args = process.argv.slice(2);\nconst portArg = args.find(arg => arg.startsWith('--port='));\nconst secureArg = args.find(arg => arg.startsWith('--secure='));\n\nconst port = portArg ? parseInt(portArg.split('=')[1], 10) : 7000;\nconst secure = secureArg ? secureArg.split('=')[1] === 'true' : false;\n\n\nconnectWebSocket(port, secure);\n\n```"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Implement a WebSocket server class for peer-to-peer communication that handles connections, messages, and room management.\n\nClass Description: The SnapdropServer class represents a WebSocket server that facilitates peer-to-peer communication. It manages WebSocket connections, handles incoming messages, and maintains rooms for peer grouping. The server also handles connection headers and keeps connections alive.\n\nAttributes:\n- _wss: [WebSocket.Server] - The WebSocket server instance\n- _rooms: [Object] - A dictionary tracking peers grouped by their IP addresses (rooms)\n\nMethods:\n- constructor(port: number) -> void - Initializes the WebSocket server on the specified port and sets up event handlers\n- _onConnection(peer: Peer) -> void - Handles new WebSocket connections, sets up message handlers, and joins the peer to a room\n- _onHeaders(headers: Array, response: Object) -> void - Processes HTTP headers during WebSocket handshake, setting cookies if needed\n- _onMessage(sender: Peer, message: string) -> void - Handles incoming messages from peers, routing them to appropriate recipients\n- _send(peer: Peer, message: Object) -> void - Sends a message to a specific peer over WebSocket connection\n- _joinRoom(peer: Peer) -> void - Adds a peer to their respective room (Not shown in reference but implied)\n- _leaveRoom(peer: Peer) -> void - Removes a peer from their room (Not shown in reference but implied)\n- _keepAlive(peer: Peer) -> void - Maintains connection with periodic pings (Not shown in reference but implied)",
    "Canonical_solution": "const WebSocket = require('ws');\n\nclass SnapdropServer {\n    constructor(port) {\n        this._wss = new WebSocket.Server({ port: port });\n        this._wss.on('connection', (socket, request) => this._onConnection(new Peer(socket, request)));\n        this._wss.on('headers', (headers, response) => this._onHeaders(headers, response));\n\n        this._rooms = {};\n    }\n\n    _onConnection(peer) {\n        this._joinRoom(peer);\n        peer.socket.on('message', message => this._onMessage(peer, message));\n        peer.socket.on('error', console.error);\n        this._keepAlive(peer);\n\n        this._send(peer, {\n            type: 'display-name',\n            message: {\n                displayName: peer.name.displayName,\n                deviceName: peer.name.deviceName\n            }\n        });\n    }\n\n    _onHeaders(headers, response) {\n        if (response.headers.cookie && response.headers.cookie.indexOf('peerid=') > -1) return;\n        response.peerId = Peer.uuid();\n        headers.push('Set-Cookie: peerid=' + response.peerId + \"; SameSite=Strict; Secure\");\n    }\n\n    _onMessage(sender, message) {\n        try {\n            message = JSON.parse(message);\n        } catch (e) {\n            return;\n        }\n\n        switch (message.type) {\n            case 'disconnect':\n                this._leaveRoom(sender);\n                break;\n            case 'pong':\n                sender.lastBeat = Date.now();\n                break;\n        }\n\n        if (message.to && this._rooms[sender.ip]) {\n            const recipientId = message.to;\n            const recipient = this._rooms[sender.ip][recipientId];\n            delete message.to;\n            message.sender = sender.id;\n            this._send(recipient, message);\n            return;\n        }\n    }\n\n    _send(peer, message) {\n        if (!peer) return;\n        if (this._wss.readyState !== this._wss.OPEN) return;\n        message = JSON.stringify(message);\n        peer.socket.send(message, error => '');\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "class SnapdropServer {\n  constructor(port) {\n    this._wss = new require('ws').Server({ port });\n    this._rooms = {};\n\n    this._wss.on('connection', (ws, req) => this._onConnection(ws, req));\n    this._wss.on('headers', (headers, response) => this._onHeaders(headers, response));\n  }\n\n  _onConnection(ws, req) {\n    ws.isAlive = true;\n    ws.on('pong', () => ws.isAlive = true);\n    ws.ip = req.socket.remoteAddress;\n\n    this._joinRoom(ws);\n\n    ws.on('message', message => this._onMessage(ws, message));\n    ws.on('close', () => this._leaveRoom(ws));\n    ws.on('error', () => this._leaveRoom(ws));\n\n    this._keepAlive(ws);\n  }\n\n\n  _onHeaders(headers, response) {\n    // Example: Setting a cookie (Implementation not required for core functionality)\n    // response.setHeader('Set-Cookie', ['snapdrop=1']);\n  }\n\n  _onMessage(sender, message) {\n    try {\n      const parsedMessage = JSON.parse(message);\n      if (parsedMessage.to) {\n        const recipient = this._rooms[sender.ip].find(peer => peer.id === parsedMessage.to);\n        if (recipient) {\n          this._send(recipient, message);\n        }\n      } else {\n        this._rooms[sender.ip].forEach(peer => {\n          if (peer !== sender) {\n            this._send(peer, message);\n          }\n        });\n      }\n    } catch (e) {\n      console.error(\"Failed to parse message:\", e);\n    }\n  }\n\n  _send(peer, message) {\n    if (peer.readyState === peer.OPEN) {\n      try {\n        peer.send(message);\n      } catch (e) {\n        console.error(\"Failed to send message:\", e);\n      }\n    }\n  }\n\n  _joinRoom(peer) {\n    if (!this._rooms[peer.ip]) {\n      this._rooms[peer.ip] = [];\n    }\n    peer.id = this._generatePeerId();\n    this._rooms[peer.ip].push(peer);\n    this._send(peer, JSON.stringify({ type: 'id', id: peer.id }));\n  }\n\n  _leaveRoom(peer) {\n    this._rooms[peer.ip] = this._rooms[peer.ip].filter(p => p !== peer);\n    if (this._rooms[peer.ip].length === 0) {\n      delete this._rooms[peer.ip];\n    }\n  }\n\n  _keepAlive(peer) {\n    const interval = setInterval(() => {\n      if (peer.isAlive === false) {\n        clearInterval(interval);\n        peer.terminate();\n        return;\n      }\n      peer.isAlive = false;\n      peer.ping();\n    }, 30000);\n  }\n\n  _generatePeerId() {\n    return Math.random().toString(36).substring(2, 15);\n  }\n}\n"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Implement a function to fetch and process subscribed TV channels from a streaming service API, including authentication and data extraction.\n\nFunction Description: This asynchronous function retrieves subscribed TV channel information from a streaming service by:\n1. Scraping initial configuration data from a webpage\n2. Authenticating with the service using extracted credentials\n3. Fetching subscribed channel packages\n4. Processing and deduplicating channel information\n5. Returning formatted channel data\n\nInput: \n- lang: [String] (optional, default='id') - Language code for the returned channel data\n\nOutput: \n- Returns: [Array<Object>] - An array of channel objects containing:\n  - lang: [String] - The language code\n  - site_id: [String] - The channel ID\n  - name: [String] - The channel name\n- Throws: [Error] - If any HTTP request fails or data parsing fails",
    "Canonical_solution": "function async channels({ lang = 'id' }) {\n    const axios = require('axios')\n    const cheerio = require('cheerio')\n    const result = await axios\n      .get('https://cubmu.com/live-tv')\n      .then(response => response.data)\n      .catch(console.error)\n\n    const $ = cheerio.load(result)\n\n    const config = JSON.parse($('#__NEXT_DATA__').text()).runtimeConfig || {}\n\n    const options = {\n      headers: {\n        Origin: 'https://cubmu.com',\n        Referer: 'https://cubmu.com/live-tv'\n      }\n    }\n    await axios\n      .post(\n        `https://servicebuss.transvision.co.id/tvs/login/external?email=${config.email}&password=${config.password}&deviceId=${config.deviceId}&deviceType=${config.deviceType}&deviceModel=${config.deviceModel}&deviceToken=&serial=&platformId=${config.platformId}`,\n        options\n      )\n      .then(response => response.data)\n      .catch(console.error)\n    const subscribedChannels = await axios\n      .post(\n        `https://servicebuss.transvision.co.id/tvs/subscribe_product/list?platformId=${config.platformId}`,\n        options\n      )\n      .then(response => response.data)\n      .catch(console.error)\n\n    const channels = []\n    const included = []\n    if (Array.isArray(subscribedChannels.channelPackageList)) {\n      subscribedChannels.channelPackageList.forEach(pkg => {\n        pkg.channelList.forEach(channel => {\n          if (included.indexOf(channel.id) < 0) {\n            included.push(channel.id)\n            channels.push({\n              lang,\n              site_id: channel.id,\n              name: channel.name\n            })\n          }\n        })\n      })\n    }\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function getSubscribedChannels(lang = 'id') {\n  try {\n    const configResponse = await fetch('https://example.com/config.json');\n    if (!configResponse.ok) {\n      throw new Error(`Failed to fetch config: ${configResponse.status}`);\n    }\n    const config = await configResponse.json();\n\n    const authResponse = await fetch(config.authUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        username: config.username,\n        password: config.password,\n      }),\n    });\n    if (!authResponse.ok) {\n      throw new Error(`Failed to authenticate: ${authResponse.status}`);\n    }\n    const authData = await authResponse.json();\n\n    const subscriptionsResponse = await fetch(config.subscriptionsUrl, {\n      headers: {\n        'Authorization': `Bearer ${authData.token}`,\n      },\n    });\n    if (!subscriptionsResponse.ok) {\n      throw new Error(`Failed to fetch subscriptions: ${subscriptionsResponse.status}`);\n    }\n    const subscriptions = await subscriptionsResponse.json();\n\n    const channels = [];\n    const seenChannels = new Set();\n\n    for (const package of subscriptions.packages) {\n      for (const channel of package.channels) {\n        if (!seenChannels.has(channel.site_id)) {\n          channels.push({\n            lang: lang,\n            site_id: channel.site_id,\n            name: channel.name[lang] || channel.name.en,\n          });\n          seenChannels.add(channel.site_id);\n        }\n      }\n    }\n\n    return channels;\n  } catch (error) {\n    console.error('Error fetching channels:', error);\n    throw error;\n  }\n}\n\n```\n"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Create a WebSocket server class that manages WebSocket connections for a webview application, handling connection events and maintaining active connections.\n\nClass Description: The WebviewServer class is responsible for setting up and managing a WebSocket server that facilitates real-time communication between a webview application and a data source. It maintains active connections and provides server information.\n\nAttributes:\n- server: [http.Server] - The underlying HTTP server instance used for WebSocket communication\n- secret: [string] - A secret string used for authentication or security purposes\n- connections: [Set<WebviewConnection>] - A collection of active WebSocket connections\n- config: [Config] - Configuration object containing server settings\n\nMethods:\n- constructor(dataSource: [VisualizationWatchModel], config: [Config]) -> [void] - Initializes the WebSocket server, sets up connection handlers, and stores the configuration\n- get port() -> [number] - Returns the port number on which the server is listening for connections",
    "Canonical_solution": "import { WebSocketStream } from \"@hediet/typed-json-rpc-websocket\";\nimport WebSocket = require(\"ws\");\nimport * as express from \"express\";\nimport * as http from \"http\";\n\nexport class WebviewServer {\n\tprivate readonly server: http.Server;\n\tpublic readonly secret: string;\n\n\tpublic readonly connections = new Set<WebviewConnection>();\n\n\tconstructor(\n\t\tdataSource: VisualizationWatchModel,\n\t\tprivate readonly config: Config\n\t) {\n\t\tconst app = express();\n\t\tthis.server = app.listen();\n\n\t\tconst wss = new WebSocket.Server({ server: this.server });\n\t\twss.on(\"connection\", async ws => {\n\t\t\tconst stream = new WebSocketStream(ws);\n\t\t\tconst c = new WebviewConnection(\n\t\t\t\tdataSource,\n\t\t\t\tstream,\n\t\t\t\tthis,\n\t\t\t\tconfig,\n\t\t\t\tthis.secret\n\t\t\t);\n\t\t\tthis.connections.add(c);\n\t\t\tawait stream.onClosed;\n\t\t\tthis.connections.delete(c);\n\t\t});\n\t}\n\n\tpublic get port(): number {\n\t\tconst httpPort = (this.server.address() as AddressInfo).port;\n\t\treturn httpPort;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "```typescript\nimport * as http from 'http';\nimport * as WebSocket from 'ws';\nimport { VisualizationWatchModel } from './visualizationWatchModel';\nimport { Config } from './config';\nimport { WebviewConnection } from './webviewConnection';\n\nexport class WebviewServer {\n  server: http.Server;\n  secret: string;\n  connections: Set<WebviewConnection>;\n  config: Config;\n\n  constructor(dataSource: VisualizationWatchModel, config: Config) {\n    this.connections = new Set();\n    this.config = config;\n    this.secret = config.secret;\n\n    this.server = http.createServer();\n\n    const wss = new WebSocket.Server({ server: this.server });\n\n    wss.on('connection', (ws: WebSocket) => {\n      const connection = new WebviewConnection(ws, dataSource, this.secret);\n      this.connections.add(connection);\n\n      ws.on('close', () => {\n        this.connections.delete(connection);\n      });\n\n      ws.on('error', (error) => {\n        console.error('WebSocket error:', error);\n        this.connections.delete(connection);\n      });\n    });\n\n    this.server.listen(config.port);\n  }\n\n  get port(): number {\n    const address = this.server.address();\n    if (typeof address === 'string') {\n      throw new Error('Server address is a string, expected an object.');\n    }\n    if (!address) {\n      throw new Error('Server address is undefined.');\n    }\n    return address.port;\n  }\n}\n\n```"
  },
  {
    "Task_id": 267,
    "Instruction": "Task Description: Create a WebSocket server that handles MQTT protocol messages using the Aedes broker, with event listeners for various client interactions and message handling.\n\nFunction Description: The function `createWebSocketServer` initializes and starts a WebSocket server that integrates with the Aedes MQTT broker. It sets up event handlers for client connections, errors, message publishing, subscriptions, and client disconnections. The server listens on a specified port for WebSocket connections and routes MQTT messages through the Aedes broker.\n\nInput: None (The function does not take any input parameters; port and configuration are hardcoded within the function.)\n\nOutput: None (The function does not return any value; it creates and maintains a running WebSocket server with event listeners.)",
    "Canonical_solution": "function createWebSocketServer() {\n    const aedes = require('aedes')();\n    const httpServer = require('http').createServer();\n    const WebSocket = require('ws');\n    const wsPort = 8080;\n\n    const wss = new WebSocket.Server({ server: httpServer });\n    wss.on('connection', function connection(ws) {\n        const duplex = WebSocket.createWebSocketStream(ws);\n        aedes.handle(duplex);\n    });\n\n    httpServer.listen(wsPort, () => {\n        console.log('websocket server listening on port', wsPort);\n    });\n\n    aedes.on('clientError', (client, err) => {\n        console.log('client error', client.id, err.message, err.stack);\n    });\n\n    aedes.on('connectionError', (client, err) => {\n        console.log('client error', client, err.message, err.stack);\n    });\n\n    aedes.on('publish', (packet, client) => {\n        if (packet && packet.payload) {\n            console.log('publish packet:', packet.payload.toString());\n        }\n        if (client) {\n            console.log('message from client', client.id);\n        }\n    });\n\n    aedes.on('subscribe', (subscriptions, client) => {\n        if (client) {\n            console.log('subscribe from client', subscriptions, client.id);\n        }\n    });\n\n    aedes.on('client', (client) => {\n        console.log('new client', client.id);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 90,
    "wrong_result": "const aedes = require('aedes')();\nconst httpServer = require('http').createServer();\nconst ws = require('websocket-stream');\nconst port = 8080; // WebSocket port\n\nws.createServer({ server: httpServer }, aedes.handle);\n\naedes.on('client', function (client) {\n  console.log('Client Connected:', client.id);\n});\n\naedes.on('clientError', function (client, err) {\n  console.error('Client Error:', client.id, err.message);\n});\n\naedes.on('publish', function (packet, client) {\n  if (client) {\n    console.log('Message Published by', client.id, ':', packet.payload.toString());\n  }\n});\n\naedes.on('subscribe', function (subscriptions, client) {\n  if (client) {\n    console.log('Client', client.id, 'subscribed to:', subscriptions.map(s => s.topic));\n  }\n});\n\naedes.on('clientDisconnect', function (client) {\n  console.log('Client Disconnected:', client.id);\n});\n\n\nhttpServer.listen(port, function () {\n  console.log('WebSocket server listening on port', port);\n});\n\n"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a WebSocket server class in Node.js that handles client connections, message processing, and subscription management for real-time communication.\n\nClass Description: The AphlictClientServer class implements a WebSocket server that manages client connections, processes incoming messages (including subscriptions, replays, and pings), and maintains listener lists for different instances. It's built on top of Node.js's HTTP server and ws WebSocket library.\n\nAttributes:\n- _server: [Object] - The underlying HTTP server instance\n- _lists: [Object] - Dictionary storing listener lists for different instances\n- _adminServers: [Array] - Array containing admin server references\n\nMethods:\n- constructor(server) -> [void] - Initializes the server instance and sets up request handling\n- _onrequest(request, response) -> [void] - Handles HTTP requests (returns 501 as this is a WebSocket server)\n- _parseInstanceFromPath(path) -> [String] - Extracts instance name from URL path\n- listen() -> [void] - Starts the WebSocket server and sets up connection handlers\n- getListenerList(instance) -> [Object] - Returns the listener list for a given instance (implied by usage)\n- log(message) -> [void] - Logs messages (implied by usage)\n- trace(message) -> [void] - Logs trace-level messages (implied by usage)\n- getHistory(min_age) -> [Array] - Returns historical messages (implied by usage in replay handler)\n\nThe class handles WebSocket connections with the following behaviors:\n1. Parses instance names from connection URLs\n2. Manages listener subscriptions/unsubscriptions\n3. Handles message replay requests\n4. Processes ping/pong messages\n5. Logs connection/disconnection events\n6. Maintains separate listener lists for different instances",
    "Canonical_solution": "var url = require('url');\nvar util = require('util');\nvar WebSocket = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    server.on('request', this._onrequest.bind(this));\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end('HTTP/501 Use Websockets\\n');\n  }\n\n  _parseInstanceFromPath(path) {\n    if (path.indexOf('~') === -1) {\n      return 'default';\n    }\n\n    var instance = path.split('~')[1];\n    instance = instance.replace(/\\//g, '');\n    if (!instance.length) {\n      return 'default';\n    }\n\n    return instance;\n  }\n\n  listen() {\n    var self = this;\n    var server = this._server.listen.apply(this._server, arguments);\n    var wss = new WebSocket.Server({server: server});\n\n    wss.on('connection', function(ws, request) {\n      if ('upgradeReq' in ws) {\n        request = ws.upgradeReq;\n      }\n\n      var path = url.parse(request.url).pathname;\n      var instance = self._parseInstanceFromPath(path);\n\n      var listener = self.getListenerList(instance).addListener(ws);\n\n      function msg(argv) {\n        return util.format('<%s>', listener.getDescription()) +\n          ' ' +\n          util.format.apply(null, argv);\n      }\n\n      function log() {\n        self.log(msg(arguments));\n      }\n\n      function trace() {\n        self.trace(msg(arguments));\n      }\n\n      trace('Connected from %s.', ws._socket.remoteAddress);\n\n      ws.on('message', function(data) {\n        trace('Received message: %s', data);\n\n        var message;\n        try {\n          message = JSON.parse(data);\n        } catch (err) {\n          log('Message is invalid: %s', err.message);\n          return;\n        }\n\n        switch (message.command) {\n          case 'subscribe':\n            trace(\n              'Subscribed to: %s',\n              JSON.stringify(message.data));\n            listener.subscribe(message.data);\n            break;\n\n          case 'unsubscribe':\n            trace(\n              'Unsubscribed from: %s',\n              JSON.stringify(message.data));\n            listener.unsubscribe(message.data);\n            break;\n\n          case 'replay':\n            var age = message.data.age || 60000;\n            var min_age = (new Date().getTime() - age);\n\n            var old_messages = self.getHistory(min_age);\n            for (var ii = 0; ii < old_messages.length; ii++) {\n              var old_message = old_messages[ii];\n\n              if (!listener.isSubscribedToAny(old_message.subscribers)) {\n                continue;\n              }\n\n              try {\n                listener.writeMessage(old_message);\n              } catch (error) {\n                break;\n              }\n            }\n            break;\n\n          case 'ping':\n            var pong = {\n              type: 'pong'\n            };\n\n            try {\n              listener.writeMessage(pong);\n            } catch (error) {\n              // Ignore any issues here, we'll clean up elsewhere.\n            }\n            break;\n\n          default:\n            log(\n              'Unrecognized command \"%s\".',\n              message.command || '<undefined>');\n        }\n      });\n\n      ws.on('close', function() {\n        self.getListenerList(instance).removeListener(listener);\n        trace('Disconnected.');\n      });\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 90,
    "wrong_result": "const { createServer } = require('http');\nconst { WebSocketServer } = require('ws');\n\nclass AphlictClientServer {\n  constructor(server) {\n    this._server = server;\n    this._lists = {};\n    this._adminServers = [];\n\n    this._server.on('request', this._onrequest.bind(this));\n  }\n\n  _onrequest(request, response) {\n    response.writeHead(501);\n    response.end();\n  }\n\n  _parseInstanceFromPath(path) {\n    return path.substring(1);\n  }\n\n  listen() {\n    const wss = new WebSocketServer({ noServer: true });\n\n    this._server.on('upgrade', (request, socket, head) => {\n      wss.handleUpgrade(request, socket, head, (ws) => {\n        const instance = this._parseInstanceFromPath(request.url);\n\n        if (!this._lists[instance]) {\n          this._lists[instance] = [];\n        }\n\n        const listenerList = this._lists[instance];\n        listenerList.push(ws);\n\n        this.log(`Client connected to instance ${instance}`);\n\n        ws.on('message', (message) => {\n          try {\n            const data = JSON.parse(message);\n            if (data.command === 'subscribe') {\n              // Handle subscription\n            } else if (data.command === 'replay') {\n              // Handle replay\n              const history = this.getHistory(data.age);\n              // ... send history messages\n            } else if (data.command === 'ping') {\n              ws.send(JSON.stringify({ command: 'pong' }));\n            }\n          } catch (e) {\n            this.trace(`Failed to parse message: ${message}`);\n          }\n        });\n\n        ws.on('close', () => {\n          this.log(`Client disconnected from instance ${instance}`);\n          this._lists[instance] = listenerList.filter((client) => client !== ws);\n        });\n\n        ws.on('error', (error) => {\n          this.log(`WebSocket error: ${error}`);\n        });\n      });\n    });\n  }\n\n\n  getListenerList(instance) {\n    return this._lists[instance] || [];\n  }\n\n  log(message) {\n    console.log(message);\n  }\n\n  trace(message) {\n    console.log(message);\n  }\n\n  getHistory(min_age) {\n    return []; // Placeholder implementation\n  }\n}\n\n\nmodule.exports = AphlictClientServer;\n"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Create a class that implements HTTP client functionality using Axios for making HTTP requests with support for GET and POST methods, including proper header and parameter handling.\n\nClass Description: HTTPClient is a class that provides HTTP request capabilities using Axios as the underlying library. It handles request configuration, parameter serialization, content-type detection, and response processing.\n\nAttributes:\n- requestModule: [String] - Specifies the HTTP library being used (default: 'axios')\n\nMethods:\n- httpRequest: [async](options) -> [Object] - Makes an HTTP request based on provided options\n  - options: [Object] - Configuration object containing:\n    - method: [String] - HTTP method (GET/POST)\n    - url: [String] - Request URL\n    - headers: [Object] - Request headers\n    - params: [Object] - Query parameters\n    - body: [Object|String] - Request payload\n- queryStr: [function](options) -> [String] - Converts an object to URL-encoded query string\n  - options: [Object] - Key-value pairs to serialize\n- isJSONString: [function](str) -> [Boolean] - Checks if a string is valid JSON\n  - str: [String] - String to validate\n- isJson: [function](obj) -> [Boolean] - Checks if an object is a plain JSON object\n  - obj: [Any] - Object to validate",
    "Canonical_solution": "```javascript\nconst axios = require('axios');\n\nclass HTTPClient {\n    constructor() {\n        this.requestModule = 'axios';\n    }\n\n    async httpRequest(options) {\n        let t = { ...options };\n        t.headers = t.headers || {};\n        if (t.params) {\n            t.url += '?' + this.queryStr(t.params);\n        }\n        t.method = t.method.toLowerCase();\n        if (t.method === 'get') {\n            delete t.headers['Content-Type'];\n            delete t.headers['Content-Length'];\n            delete t.headers['content-type'];\n            delete t.headers['content-length'];\n            delete t.body;\n        } else if (t.method === 'post') {\n            let ContentType;\n            if (!t.body) {\n                t.body = \"\";\n            } else if (typeof t.body === \"string\") {\n                ContentType = this.isJSONString(t.body) ? 'application/json' : 'application/x-www-form-urlencoded';\n            } else if (this.isJson(t.body)) {\n                t.body = JSON.stringify(t.body);\n                ContentType = 'application/json';\n            }\n            if (!t.headers['Content-Type'] && !t.headers['content-type']) {\n                t.headers['Content-Type'] = ContentType;\n            }\n        }\n        if (this.requestModule === \"axios\" && t.method === \"post\") {\n            t.data = t.body;\n            delete t.body;\n        }\n        let httpResult;\n        if (this.requestModule === \"axios\") {\n            httpResult = await axios(t);\n            httpResult.body = httpResult.data;\n        }\n        return httpResult;\n    }\n\n    queryStr(options) {\n        return Object.entries(options).map(([key, value]) => `${key}=${typeof value === 'object' ? JSON.stringify(value) : value}`).join('&');\n    }\n\n    isJSONString(str) {\n        try {\n            return JSON.parse(str) && typeof JSON.parse(str) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isJson(obj) {\n        var isjson = typeof (obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length;\n        return isjson;\n    }\n}\n```",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class HTTPClient {\n  constructor(requestModule = 'axios') {\n    this.requestModule = requestModule;\n    this.axios = require('axios');\n  }\n\n  async httpRequest(options) {\n    const { method, url, headers = {}, params, body } = options;\n    const config = {\n      method,\n      url,\n      headers,\n      params,\n    };\n\n    if (body) {\n      if (this.isJson(body)) {\n        config.headers['Content-Type'] = 'application/json';\n        config.data = JSON.stringify(body);\n      } else if (typeof body === 'string') {\n        try {\n          JSON.parse(body);\n          config.headers['Content-Type'] = 'application/json';\n          config.data = body;\n        } catch (e) {\n          config.data = body;\n        }\n      } else {\n        config.data = body;\n      }\n    }\n\n    try {\n      const response = await this.axios(config);\n      return {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n        data: response.data,\n      };\n    } catch (error) {\n      if (error.response) {\n        return {\n          status: error.response.status,\n          statusText: error.response.statusText,\n          headers: error.response.headers,\n          data: error.response.data,\n        };\n      } else if (error.request) {\n        throw new Error(`Request failed: ${error.message}`);\n      } else {\n        throw new Error(`Error creating request: ${error.message}`);\n      }\n    }\n  }\n\n\n  queryStr(options) {\n    return Object.keys(options)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(options[key])}`)\n      .join('&');\n  }\n\n  isJSONString(str) {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n\n  isJson(obj) {\n    try {\n      return !!JSON.parse(JSON.stringify(obj));\n    } catch (e) {\n      return false;\n    }\n  }\n}\n"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript to handle real-time bidirectional communication between clients and the server.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io. It sets up event listeners for client connections, messages, and disconnections. The server broadcasts received messages to all connected clients.\n\nInput:\n- `port` (Number): The port number on which the WebSocket server will listen for incoming connections.\n\nOutput:\n- Returns the `socketServer` instance (Object) which can be used to further configure or interact with the WebSocket server.\n\nNote: The function internally uses the `http` module to create an HTTP server and binds socket.io to it for WebSocket communication. The server logs connection, message, and disconnection events to the console.",
    "Canonical_solution": "const http = require(\"http\");\nconst socketIo = require(\"socket.io\");\n\nfunction setupWebSocketServer(port) {\n    const app = express();\n    const webServer = http.createServer(app);\n    const socketServer = socketIo(webServer, {\"log level\": 1});\n\n    socketServer.on(\"connection\", (socket) => {\n        console.log(\"New client connected\");\n\n        socket.on(\"message\", (data) => {\n            console.log(\"Message received: \", data);\n            socketServer.emit(\"message\", data);\n        });\n\n        socket.on(\"disconnect\", () => {\n            console.log(\"Client disconnected\");\n        });\n    });\n\n    webServer.listen(port, () => {\n        console.log(\"WebSocket server listening on port: \" + port);\n    });\n\n    return socketServer;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "```javascript\nconst http = require('http');\nconst io = require('socket.io');\n\nfunction setupWebSocketServer(port) {\n  const server = http.createServer();\n  const socketServer = io(server);\n\n  socketServer.on('connection', (socket) => {\n    console.log('Client connected:', socket.id);\n\n    socket.on('message', (message) => {\n      console.log('Received message:', message);\n      socketServer.emit('message', message);\n    });\n\n    socket.on('disconnect', () => {\n      console.log('Client disconnected:', socket.id);\n    });\n  });\n\n  server.listen(port, () => {\n    console.log(`WebSocket server listening on port ${port}`);\n  });\n\n  return socketServer;\n}\n\n```"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a WebSocket server using socket.io in JavaScript that handles real-time communication between clients and integrates with an Express application and Deployd backend.\n\nFunction Description: The function `setupWebSocketServer` initializes and configures a WebSocket server using socket.io, integrates it with an Express application, and attaches a Deployd backend. It sets up event listeners for server operations and handles custom Express routes.\n\nInput: None (The function uses environment variables for configuration: `process.env.NODE_ENV` for environment setting and `process.env.PORT` for port number)\n\nOutput: None (The function starts a server that listens on the specified port and logs server status to the console)\n\nNote: The function internally uses:\n- Express for HTTP server functionality\n- Socket.io for WebSocket communication\n- Deployd for backend services\n- MongoDB (configured to connect to localhost:27017 with database name 'test-app')",
    "Canonical_solution": "function setupWebSocketServer() {\n    var express = require('express');\n    var app = express();\n    var server = require('http').createServer(app);\n    var io = require('socket.io').listen(server, {'log level': 0});\n\n    require('deployd').attach(server, {\n        socketIo: io,\n        env: process.env.NODE_ENV || 'development',\n        db: {host:'localhost', port:27017, name:'test-app'}\n    });\n    app.use(server.handleRequest);\n\n    app.get('/express-custom-handler', function(req, res) {\n        res.send('Ok');\n    });\n\n    server.listen(process.env.PORT || 2403, function() {\n        console.log({ ENV: process.env.NODE_ENV || 'development', PORT: process.env.PORT || 2403 });\n    });\n    server.on('error', function(err) {\n        console.log(err.stack);\n        process.nextTick(function() {\n            process.exit();\n        });\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 92,
    "wrong_result": "```javascript\nconst express = require('express');\nconst http = require('http');\nconst socketio = require('socket.io');\nconst deployd = require('deployd');\n\nfunction setupWebSocketServer() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = socketio(server);\n  const dpd = deployd({\n    port: process.env.PORT || 3000,\n    env: process.env.NODE_ENV || 'development',\n    db: {\n      host: 'localhost',\n      port: 27017,\n      name: 'test-app'\n    }\n  });\n\n  dpd.listen();\n\n  dpd.on('listening', function() {\n    console.log(\"Deployd is listening on port\", dpd.port);\n  });\n\n  dpd.on('error', function(err) {\n    console.error(err);\n    process.nextTick(function() {\n      process.exit();\n    });\n  });\n\n  io.on('connection', (socket) => {\n    console.log('New client connected');\n\n    socket.on('disconnect', () => {\n      console.log('Client disconnected');\n    });\n  });\n\n\n  server.listen(dpd.port, () => {\n    console.log(`Server listening on port ${dpd.port}`);\n  });\n\n  server.on('error', (err) => {\n    console.error('Server error:', err);\n  });\n}\n\nsetupWebSocketServer();\n\n```"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a function to send telemetry data to a remote endpoint after a software installation, while respecting user preferences for telemetry collection.\n\nFunction Description: The function `installTelemetry` sends a POST request to a specified telemetry endpoint with installation-related data (Node.js version and platform). It checks an environment variable to determine if telemetry collection is enabled before sending any data. The function handles both success and error cases silently.\n\nInput: None (uses environment variable `TUNNELMOLE_TELEMETRY` and Node.js process information)\n\nOutput: None (the function doesn't return any value, it only performs a side effect of sending telemetry data)",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function installTelemetry() {\n  const telemetryEndpoint = `https://service.tunnelmole.com/tunnelmole-log-telemetry`;\n\n  if (process.env.TUNNELMOLE_TELEMETRY === \"0\") {\n    return;\n  }\n\n  axios\n    .post(telemetryEndpoint, {\n      type: \"post-install\",\n      data: {\n        nodeVersion: process.version ? process.version : \"Unknown\",\n        platform: process.platform ? process.platform : \"Unknown\"\n      }\n    }).then(function () {\n      // Ignore the response\n    }).catch(function () {\n      // Ignore the error\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nconst https = require('https');\nconst os = require('os');\n\nasync function installTelemetry() {\n  try {\n    if (process.env.TUNNELMOLE_TELEMETRY !== 'true') {\n      return;\n    }\n\n    const telemetryData = {\n      nodejsVersion: process.version,\n      platform: os.platform(),\n    };\n\n    const data = JSON.stringify(telemetryData);\n\n    const options = {\n      hostname: 'telemetry.example.com',\n      port: 443,\n      path: '/installs',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length,\n      },\n    };\n\n    const req = https.request(options);\n\n    req.on('error', () => {});\n\n    req.write(data);\n    req.end();\n  } catch (e) {}\n}\n\ninstallTelemetry();\n\n```"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a SauceLabs API client class in JavaScript that handles HTTP requests to the SauceLabs REST API, including authentication and basic GET/POST operations.\n\nClass Description: The SauceLabsClient class provides methods to interact with the SauceLabs REST API. It handles authentication and provides simplified methods for making GET and POST requests to the API endpoints.\n\nAttributes:\n- auth: [Object] - An object containing user authentication credentials (username and access token)\n\nMethods:\n- setAuth: [setAuth](saucelabsUsername: String, saucelabsToken: String) -> Void - Sets the authentication credentials for API requests\n- get: [get](path: String, callback: Function) -> Void - Makes a GET request to the specified API path and handles the response through a callback\n- post: [post](path: String, data: Object, callback: Function) -> Void - Makes a POST request to the specified API path with provided data and handles the response through a callback",
    "Canonical_solution": "var request = require('request');\n\nclass SauceLabsClient {\n  constructor() {\n    this.auth = {\n      user: null,\n      password: null\n    };\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth.user = saucelabsUsername;\n    this.auth.password = saucelabsToken;\n  }\n\n  get(path, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + path,\n      auth: this.auth\n    };\n    request.get(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        console.log(params);\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(JSON.parse(body));\n    });\n  }\n\n  post(path, data, callback) {\n    var params = {\n      url: 'https://saucelabs.com/rest/v1/' + this.auth.user + '/' + path,\n      auth: { user: this.auth.user, password: this.auth.password },\n      json: data\n    };\n    request.post(params, function(err, res, body) {\n      if (err) {\n        throw err;\n      }\n      if (res.statusCode != 200) {\n        throw new Error('Non-200 status code: ' + body);\n      }\n      callback(body);\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class SauceLabsClient {\n  constructor() {\n    this.auth = {};\n  }\n\n  setAuth(saucelabsUsername, saucelabsToken) {\n    this.auth = {\n      username: saucelabsUsername,\n      accessKey: saucelabsToken,\n    };\n  }\n\n  get(path, callback) {\n    const url = `https://api.us-west-1.saucelabs.com/v1/${path}`;\n    fetch(url, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Basic ${btoa(`${this.auth.username}:${this.auth.accessKey}`)}`,\n      },\n    })\n    .then(response => response.json())\n    .then(data => callback(null, data))\n    .catch(error => callback(error));\n  }\n\n  post(path, data, callback) {\n    const url = `https://api.us-west-1.saucelabs.com/v1/${path}`;\n    fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Basic ${btoa(`${this.auth.username}:${this.auth.accessKey}`)}`,\n      },\n      body: JSON.stringify(data),\n    })\n    .then(response => response.json())\n    .then(data => callback(null, data))\n    .catch(error => callback(error));\n  }\n}\n"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Create a class that interacts with a bundle size tracking API to get and set file size values for a repository.\n\nClass Description: The BundleSizeAPI class provides methods to retrieve and store file size information from a remote API. It handles authentication, repository name sanitization, and error logging.\n\nAttributes:\n- repo: [String] - The repository name (e.g., \"owner/repo\")\n- token: [String] - Authentication token for API access\n- sha: [String] - Commit SHA associated with the bundle sizes\n- ci: [Any] - CI environment information (usage not shown in reference)\n- url: [String] - Base URL for the bundle size API (\"https://bundlesize-store.now.sh/values\")\n- enabled: [Boolean] - Flag indicating if API operations are enabled (true when repo and token are provided)\n\nMethods:\n- get: [get]() -> [Promise<Object>] - Retrieves file size values from the API. Returns a promise that resolves to an object mapping file paths to their sizes. Automatically sanitizes repository name by replacing dots with underscores.\n- set: [set](values: Object) -> [void] - Posts file size values to the API. Takes an object mapping file paths to sizes. Only operates when repo and token are available. Sanitizes repository name and includes commit SHA in the payload. Errors are logged to console.\n\nNote: Both methods handle errors by logging them to the console and continue execution (errors don't propagate). The class is designed to be fail-safe when API credentials aren't provided.",
    "Canonical_solution": "const axios = require('axios');\n\nclass BundleSizeAPI {\n  constructor(repo, token, sha, ci) {\n    this.repo = repo;\n    this.token = token;\n    this.sha = sha;\n    this.ci = ci;\n    this.url = 'https://bundlesize-store.now.sh/values';\n    this.enabled = (this.repo && this.token) ? true : false;\n  }\n\n  get() {\n    const sanitizedRepo = this.repo.replace(/\\./g, '_');\n    return axios\n      .get(`${this.url}?repo=${sanitizedRepo}&token=${this.token}`)\n      .then(response => {\n        const values = {};\n        if (response && response.data && response.data.length) {\n          response.data.map(file => (values[file.path] = file.size));\n        }\n        return values;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n  }\n\n  set(values) {\n    if (this.repo && this.token) {\n      const sanitizedRepo = this.repo.replace(/\\./g, '_');\n      axios\n        .post(this.url, { repo: sanitizedRepo, token: this.token, sha: this.sha, values })\n        .catch(error => console.log(error));\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 94,
    "wrong_result": "class BundleSizeAPI {\n  constructor({ repo, token, sha, ci }) {\n    this.repo = repo\n    this.token = token\n    this.sha = sha\n    this.ci = ci\n    this.url = 'https://bundlesize-store.now.sh/values'\n    this.enabled = Boolean(repo && token)\n  }\n\n  async get() {\n    if (!this.enabled) return {}\n    const repo = this.repo.replace(/\\./g, '_')\n    try {\n      const res = await fetch(`${this.url}/${repo}`)\n      if (!res.ok) {\n        console.error(`bundlesize API request failed: ${res.status} ${res.statusText}`)\n        return {}\n      }\n      const json = await res.json()\n      return json\n    } catch (err) {\n      console.error('bundlesize API request failed', err)\n      return {}\n    }\n  }\n\n  async set(values) {\n    if (!this.enabled) return\n    const repo = this.repo.replace(/\\./g, '_')\n    try {\n      const res = await fetch(this.url, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n          authorization: `Bearer ${this.token}`,\n        },\n        body: JSON.stringify({ repo, sha: this.sha, values }),\n      })\n      if (!res.ok) {\n        console.error(`bundlesize API request failed: ${res.status} ${res.statusText}`)\n      }\n    } catch (err) {\n      console.error('bundlesize API request failed', err)\n    }\n  }\n}\n\n"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a function that fetches COVID-19 related data from the Israeli government's health dashboard API using HTTP POST request and processes the response.\n\nFunction Description: The function makes a batch request to the Israeli health ministry's API endpoint to retrieve multiple COVID-19 related datasets including updates, patient statistics, test results, and demographic breakdowns. It handles the HTTP communication, error cases, and returns the parsed data or null if the request fails.\n\nInput: None (The function takes no parameters as all request configuration is internally defined)\n\nOutput: \n- On success: Returns parsed data from the API response (type depends on parseData implementation)\n- On failure: Returns null and logs the error",
    "Canonical_solution": "function israelData() {\n    const axios = require('axios');\n    const logger = require('../../../utils/logger');\n    const params = {\n        requests: [\n            { queryName: 'lastUpdate', single: true },\n            { queryName: 'patientsPerDate' },\n            { queryName: 'deadPatientsPerDate' },\n            { queryName: 'recoveredPerDay' },\n            { queryName: 'testResultsPerDate' },\n            { queryName: 'infectedByPeriodAndAgeAndGender' },\n            { queryName: 'deadByPeriodAndAgeAndGender' },\n            { queryName: 'breatheByPeriodAndAgeAndGender' },\n            { queryName: 'severeByPeriodAndAgeAndGender' },\n            { queryName: 'spotlightPublic' },\n            { queryName: 'spotlightLastupdate' }\n        ]\n    };\n    return axios.post('https://datadashboardapi.health.gov.il/api/queries/_batch', params, {\n        headers: { 'Content-Type': 'application/json' }\n    }).then(data => {\n        return parseData(data.data);\n    }).catch(err => {\n        logger.err('Error: Requesting Israel Gov Data failed!', err);\n        return null;\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function fetchCovidData() {\n  const apiUrl = 'https://datadashboardapi.health.gov.il/api/queries/batch';\n  const requestBody = {\n    \"requests\": [\n      {\"id\": \"vaccinated\", \"queryName\": \"vaccinated\"},\n      {\"id\": \"patients\", \"queryName\": \"patients\"},\n      {\"id\": \"tests\", \"queryName\": \"tests\"},\n      {\"id\": \"demographics\", \"queryName\": \"demographics\"}\n    ]\n  };\n\n  try {\n    const response = await fetch(apiUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestBody)\n    });\n\n    if (!response.ok) {\n      console.error(`HTTP error! status: ${response.status}`);\n      return null;\n    }\n\n    const data = await response.json();\n    return parseData(data);\n\n  } catch (error) {\n    console.error('Error fetching or parsing data:', error);\n    return null;\n  }\n}\n\n\nfunction parseData(data) {\n  // Placeholder for data parsing logic.  Replace with actual parsing as needed.\n  // Example:\n  // const vaccinatedData = data.results.find(item => item.id === 'vaccinated').data;\n  // const patientsData = data.results.find(item => item.id === 'patients').data;\n  // ... and so on for other datasets\n\n  return data; // Return the raw data for now\n}\n\n\n// Example usage:\nfetchCovidData()\n  .then(data => {\n    if (data) {\n      console.log('Fetched data:', data);\n      // Process the data\n    }\n  });\n\n```\n"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with optional path extension and error data, then triggers an activity callback based on the request's success or failure.\n\nFunction Description: The function `sendPing` is an asynchronous function that constructs a target URL by combining a base URL and an optional path, then sends an HTTP POST request using Axios. The request includes error data in the payload and a custom user-agent header. Depending on the request's outcome, it triggers a callback function (`triggerActivity`) with a success or failure indicator.\n\nInput:  \n- `url`: [String] - The base URL to which the request will be sent.  \n- `path`: [String] (optional) - An additional path segment to append to the base URL.  \n- `error`: [Any] - Data to be sent as the request payload (typically error information).  \n- `triggerActivity`: [Function] - A callback function to be executed after the request completes, receiving a boolean parameter indicating failure (true) or success (false/undefined).  \n\nOutput:  \n- None (The function's primary effect is the HTTP request and callback execution, not a direct return value).",
    "Canonical_solution": "const axios = require(\"axios\");\n\nasync function sendPing(url, path, error, triggerActivity) {\n    if (url == null) return;\n    if (path) url += \"/\" + path;\n\n    await axios.post(url, error, {headers: {\"user-agent\": \"MySpeed/HealthAgent\"}})\n        .then(() => triggerActivity())\n        .catch(() => triggerActivity(true));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function sendPing(url, path = '', error, triggerActivity) {\n  try {\n    const targetUrl = new URL(path, url).toString();\n    await axios.post(targetUrl, error, {\n      headers: {\n        'User-Agent': 'custom-user-agent',\n      },\n    });\n    triggerActivity();\n  } catch (caughtError) {\n    triggerActivity(true);\n  }\n}\n\n```"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Implement a function to send emails using different email service providers (Mailgun and Sendgrid) through HTTP requests, with error handling and promise-based asynchronous operation.\n\nFunction Description: The function `sendMail` sends an email using a configured transporter (either Mailgun or Sendgrid). It wraps the transporter's send operation in a Promise for better async handling. The transporter is configured to make HTTP requests to the respective email service API.\n\nInput:\n- `to`: [String] - Recipient email address\n- `subject`: [String] - Email subject\n- `text`: [String] - Email body content\n- `options`: [Object] (optional) - Additional email options (defaults to empty object)\n\nOutput:\n- [Promise] - Resolves with email sending success info, or rejects with an error if sending fails.\n\n---\n\nClass Description: (Not applicable, as the reference code is at the function level)",
    "Canonical_solution": "function sendMail(to, subject, text, options = {}) {\n  return new Promise((resolve, reject) => {\n    transporter.sendMail({\n      from: `\"${ config.plugins.email.name || '' }\" <${ config.plugins.email.email || config.plugins.email.username }>`,\n      to,\n      subject,\n      text,\n    }, (error, info) => {\n      if(error) {\n        return reject(error);\n      }\n      return resolve(info);\n    });\n  });\n}\n\n// External libraries and global variables used:\nconst axios = require('axios');\nconst FormData = require('form-data');\nconst config = appRequire('services/config').all();\nlet transporter;\n\n// Mailgun implementation\ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  const form = new FormData();\n  form.append('from', options.from);\n  form.append('to', options.to);\n  form.append('subject', options.subject);\n  form.append('text', options.text);\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: form.getHeaders(),\n    data: form,\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};\n\n// Sendgrid implementation  \ntransporter = {};\ntransporter.sendMail = (options, cb) => {\n  axios({\n    url: uri,\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${ emailConfig.apiKey }`,\n    },\n    data: {\n      personalizations: [{\n        to: [{ email: options.to }]\n      }],\n      from: { email: options.from },\n      subject: options.subject,\n      content: [{\n        type: 'text/plain',\n        value: options.text,\n      }]\n    },\n  }).then(success => {\n    cb(null);\n  }).catch(err => {\n    cb(err);\n  });\n};",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "```javascript\nasync function sendMail(to, subject, text, options = {}) {\n  const transporter = options.transporter || process.env.EMAIL_TRANSPORTER || 'mailgun';\n\n  let mailOptions = {\n    from: process.env.EMAIL_FROM,\n    to,\n    subject,\n    text,\n    ...options,\n  };\n\n\n  if (transporter === 'mailgun') {\n    const mg = require('mailgun-js')({\n      apiKey: process.env.MAILGUN_API_KEY,\n      domain: process.env.MAILGUN_DOMAIN,\n    });\n\n    mailOptions = {\n      ...mailOptions,\n      from: `${mailOptions.from || process.env.EMAIL_FROM_NAME} <${process.env.EMAIL_FROM}>`,\n    };\n\n    return new Promise((resolve, reject) => {\n      mg.messages().send(mailOptions, (error, body) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(body);\n        }\n      });\n    });\n  } else if (transporter === 'sendgrid') {\n    const sgMail = require('@sendgrid/mail');\n    sgMail.setApiKey(process.env.SENDGRID_API_KEY);\n\n    return sgMail\n      .send(mailOptions)\n      .then((response) => {\n        return response[0];\n      })\n      .catch((error) => {\n        throw error;\n      });\n  } else {\n    return Promise.reject(new Error('Invalid email transporter specified.'));\n  }\n}\n\n```\n"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Create an asynchronous function that fetches TV channel data from a specified API endpoint and processes it into a standardized format.\n\nFunction Description: The function makes an HTTP GET request to retrieve TV channel information from a remote API. It processes the response to extract relevant channel details (language, site ID, and name) and returns them in a structured array format. The function includes error handling to log any request failures.\n\nInput: None (The function uses a hardcoded API URL and parameters)\n\nOutput: An array of objects where each object represents a TV channel with the following properties:\n- lang: String - The language code for the channel (hardcoded as 'sq' in this case)\n- site_id: String - The unique identifier for the channel from the API\n- name: String - The display name of the channel",
    "Canonical_solution": "async function channels() {\n    const axios = require('axios')\n    const data = await axios\n        .get('https://www.tvim.tv/script/epg/category_channels?category=all&filter=playable')\n        .then(r => r.data)\n        .catch(console.log)\n\n    let channels = []\n    data.data.forEach(item => {\n        channels.push({\n            lang: 'sq',\n            site_id: item.epg_id,\n            name: item.name\n        })\n    })\n\n    return channels\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 94,
    "wrong_result": "async function fetchAndProcessChannelData() {\n  const apiUrl = 'https://example.com/tv-channels'; // Replace with actual API endpoint\n\n  try {\n    const response = await fetch(apiUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    if (!Array.isArray(data.channels)) {\n      console.error(\"Invalid API response format: 'channels' is not an array.\");\n      return [];\n    }\n\n    return data.channels.map(channel => ({\n      lang: 'sq',\n      site_id: String(channel.id),\n      name: channel.name,\n    }));\n\n  } catch (error) {\n    console.error('Error fetching or processing channel data:', error);\n    return [];\n  }\n}\n"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a function to download a video file from a given URL and save it with a specified description as the filename.\n\nFunction Description: The function `downloadVideo` initiates an asynchronous HTTP GET request to download a video file from the provided URL. It handles the response as a binary blob, creates a downloadable link, and triggers the download automatically. The function includes error handling for empty URLs and checks for successful request completion.\n\nInput:\n- `url` (String): The URL of the video file to be downloaded.\n- `desc` (String): The description to be used as the filename for the downloaded video.\n\nOutput: None (The function triggers a file download but does not return any value.)",
    "Canonical_solution": "function downloadVideo(url, desc) {\n    if (isEmpty(url)) {\n        layer.msg('\u6682\u65e0\u6570\u636e');\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'blob';\n    xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\n    xhr.setRequestHeader(\"Access-Control-Allow-Credentials\", true);\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            let blob = this.response;\n            let u = window.URL.createObjectURL(new Blob([blob]));\n            let a = document.createElement('a');\n            a.download = desc + '.mp4';\n            a.href = u;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function downloadVideo(url, desc) {\n  if (!url) {\n    console.error(\"URL cannot be empty.\");\n    return;\n  }\n\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(`Failed to fetch video: ${response.status} ${response.statusText}`);\n      return;\n    }\n\n    const blob = await response.blob();\n    const link = document.createElement('a');\n    link.href = URL.createObjectURL(blob);\n    link.download = `${desc}.mp4`;\n    link.style.display = 'none';\n    document.body.appendChild(link);\n    link.click();\n    URL.revokeObjectURL(link.href);\n    document.body.removeChild(link);\n  } catch (error) {\n    console.error(`An error occurred: ${error}`);\n  }\n}\n\n```\n"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a cross-platform HTTP client tool that works in Node.js, Surge, and Quantumult X environments, providing consistent methods for making HTTP requests and handling responses across these platforms.\n\nClass Description: The `Tool` class is a utility class designed to abstract HTTP client functionality across different JavaScript environments (Node.js, Surge, and Quantumult X). It provides methods for making HTTP requests (GET/POST), persistent storage, and notifications while automatically detecting the runtime environment.\n\nAttributes:\n- _node: [Object|null] - Contains Node.js specific modules if running in Node.js environment\n- _isSurge: [Boolean] - Indicates if running in Surge environment\n- _isQuanX: [Boolean] - Indicates if running in Quantumult X environment\n- isSurge: [Boolean] - Public alias for _isSurge\n- isQuanX: [Boolean] - Public alias for _isQuanX\n- isResponse: [Boolean] - Indicates if $response is available\n\nMethods:\n- constructor() -> [void] - Initializes the tool and detects the runtime environment\n- notify(title: String, subtitle: String, message: String, option: Object) -> [void] - Sends a notification in the current environment\n- write(value: String, key: String) -> [Boolean] - Writes a value to persistent storage\n- read(key: String) -> [String] - Reads a value from persistent storage\n- get(options: Object|String, callback: Function) -> [void] - Makes a GET HTTP request\n- post(options: Object|String, callback: Function) -> [void] - Makes a POST HTTP request\n- _status(response: Object) -> [Object] - Internal method to normalize response status codes",
    "Canonical_solution": "const request = require('request');\n\nclass Tool {\n    constructor() {\n        this._node = (() => {\n            if (typeof require == \"function\") {\n                const request = require('request')\n                return ({ request })\n            } else {\n                return (null)\n            }\n        })()\n        this._isSurge = typeof $httpClient != \"undefined\"\n        this._isQuanX = typeof $task != \"undefined\"\n        this.isSurge = this._isSurge\n        this.isQuanX = this._isQuanX\n        this.isResponse = typeof $response != \"undefined\"\n    }\n\n    notify(title, subtitle, message, option) {\n        if (this._isQuanX) $notify(title, subtitle, message, option)\n        if (this._isSurge) $notification.post(title, subtitle, message, option[\"open-url\"])\n        if (this._node) console.log(JSON.stringify({ title, subtitle, message }));\n    }\n\n    write(value, key) {\n        if (this._isQuanX) return $prefs.setValueForKey(value, key)\n        if (this._isSurge) return $persistentStore.write(value, key)\n    }\n\n    read(key) {\n        if (this._isQuanX) return $prefs.valueForKey(key)\n        if (this._isSurge) return $persistentStore.read(key)\n    }\n\n    get(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"GET\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.get(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    post(options, callback) {\n        if (this._isQuanX) {\n            if (typeof options == \"string\") options = { url: options }\n            options[\"method\"] = \"POST\"\n            $task.fetch(options).then(response => { callback(null, this._status(response), response.body) }, reason => callback(reason.error, null, null))\n        }\n        if (this._isSurge) $httpClient.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n        if (this._node) this._node.request.post(options, (error, response, body) => { callback(error, this._status(response), body) })\n    }\n\n    _status(response) {\n        if (response) {\n            if (response.status) {\n                response[\"statusCode\"] = response.status\n            } else if (response.statusCode) {\n                response[\"status\"] = response.statusCode\n            }\n        }\n        return response\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class Tool {\n  constructor() {\n    this._node = typeof module !== 'undefined' && !this.isSurge && !this.isQuanX ? module : null;\n    this._isSurge = typeof $httpClient != \"undefined\";\n    this._isQuanX = typeof $task != \"undefined\";\n    this.isSurge = this._isSurge;\n    this.isQuanX = this._isQuanX;\n    this.isResponse = typeof $response != \"undefined\";\n  }\n\n  notify(title, subtitle, message, option) {\n    if (this.isQuanX) $notify(title, subtitle, message, option);\n    if (this.isSurge) $notification.post(title, subtitle, message, option);\n    if (this._node) console.log(title, subtitle, message, option);\n  }\n\n  write(value, key) {\n    if (this.isQuanX) return $prefs.setValueForKey(value, key);\n    if (this.isSurge) return $persistentStore.write(value, key);\n    if (this._node) {\n      try {\n        this._node.require('fs').writeFileSync(`${__dirname}/${key}`, value);\n        return true\n      } catch (error) {\n        console.error(error)\n        return false\n      }\n    }\n    return false;\n  }\n\n  read(key) {\n    if (this.isQuanX) return $prefs.valueForKey(key);\n    if (this.isSurge) return $persistentStore.read(key);\n    if (this._node) {\n      try {\n        return this._node.require('fs').readFileSync(`${__dirname}/${key}`, { encoding: 'utf8' })\n      } catch (error) {\n        console.error(error)\n        return null\n      }\n    }\n    return null;\n  }\n\n  get(options, callback) {\n    if (typeof options == \"string\") options = { url: options };\n    if (this.isQuanX) {\n      $task.fetch(options).then(response => {\n        response.status = response.statusCode;\n        callback(null, response, response.body)\n      }, reason => callback(reason));\n    }\n    if (this.isSurge) $httpClient.get(options, callback);\n    if (this._node) {\n      this._node.require('https').get(options.url, (resp) => {\n        let data = '';\n        resp.on('data', (chunk) => { data += chunk; });\n        resp.on('end', () => {\n          resp.body = data;\n          callback(null, this._status(resp), data)\n        });\n      }).on(\"error\", (err) => { callback(err); });\n    }\n  }\n\n  post(options, callback) {\n    if (typeof options == \"string\") options = { url: options };\n    if (this.isQuanX) {\n      $task.fetch(options).then(response => {\n        response.status = response.statusCode;\n        callback(null, response, response.body)\n      }, reason => callback(reason));\n    }\n    if (this.isSurge) $httpClient.post(options, callback);\n    if (this._node) {\n      const req = this._node.require('https').request(options.url, options, (resp) => {\n        let data = '';\n        resp.on('data', (chunk) => { data += chunk; });\n        resp.on('end', () => {\n          resp.body = data;\n          callback(null, this._status(resp), data)\n        });\n      });\n      req.on(\"error\", (err) => { callback(err); });\n      if (options.body) req.write(options.body);\n      req.end();\n    }\n  }\n\n  _status(response) {\n    response.status = response.statusCode\n    return response\n  }\n}\n"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Implement a class that simulates the behavior of an EventSource object, which is used to receive server-sent events (SSE) over HTTP. The class should handle the connection, reception of events, and error handling.\n\nClass Description: The `EventSource` class is designed to establish a persistent connection to a server using HTTP and receive server-sent events. It manages the connection state, handles incoming events, and dispatches them to appropriate event handlers. The class also supports reconnection in case of errors or connection loss.\n\nAttributes:\n\n- `URL`: [String] - The URL to which the EventSource connects to receive server-sent events.\n- `readyState`: [Number] - Represents the current state of the connection. Possible values are `CONNECTING` (0), `OPEN` (1), and `CLOSED` (2).\n- `_pollTimer`: [Object] - A timer object used to manage the polling interval for reconnection attempts.\n- `_xhr`: [Object] - The XMLHttpRequest object used to make HTTP requests to the server.\n\nMethods:\n\n- `poll()`: [Function] -> [Void] - Initiates a new HTTP request to the server to receive events. Handles the response, processes the events, and manages the connection state.\n- `close()`: [Function]() -> [Void] - Closes the connection to the server, sets the `readyState` to `CLOSED`, and stops any ongoing polling.\n- `dispatchEvent(type, event)`: [Function]([String], [Object]) -> [Void] - Dispatches an event to the registered event handlers based on the event type.\n- `addEventListener(type, handler)`: [Function]([String], [Function]) -> [Void] - Registers an event handler for a specific event type.\n- `removeEventListener()`: [Function]() -> [Void] - Placeholder method for removing event listeners (not implemented in the reference code).\n\nAdditional Classes:\n\n- `MessageEvent`: [Class] - Represents an event received from the server. Contains the event data, origin, and last event ID.\n\nAttributes of `MessageEvent`:\n\n- `data`: [String] - The data payload of the event.\n- `type`: [String] - The type of the event, defaulting to 'message'.\n- `lastEventId`: [String] - The ID of the last received event.\n- `origin`: [String] - The origin URL of the event.\n\nMethods of `MessageEvent`:\n\n- `MessageEvent(data, origin, lastEventId)`: [Constructor]([String], [String], [String]) -> [Object] - Initializes a new `MessageEvent` instance with the provided data, origin, and last event ID.",
    "Canonical_solution": "var EventSource = function (url) {\n  var eventsource = this,\n      interval = 500,\n      lastEventId = null,\n      cache = '';\n\n  if (!url || typeof url != 'string') {\n    throw new SyntaxError('Not enough arguments');\n  }\n\n  this.URL = url;\n  this.readyState = this.CONNECTING;\n  this._pollTimer = null;\n  this._xhr = null;\n\n  function poll() {\n    try {\n      if (eventsource.readyState == eventsource.CLOSED) return;\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', eventsource.URL, true);\n      xhr.setRequestHeader('Accept', 'text/event-stream');\n      xhr.setRequestHeader('Cache-Control', 'no-cache');\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n      if (lastEventId != null) xhr.setRequestHeader('Last-Event-ID', lastEventId);\n      cache = '';\n\n      xhr.timeout = 50000;\n      xhr.onreadystatechange = function () {\n        var status = 0;\n        try {\n          status = xhr.status;\n        } catch (e) {}\n\n        if ((this.readyState == 3 || this.readyState == 4) && status == 200) {\n          if (eventsource.readyState == eventsource.CONNECTING) {\n            eventsource.readyState = eventsource.OPEN;\n            eventsource.dispatchEvent('open', { type: 'open' });\n          }\n\n          var responseText = '';\n          try {\n            responseText = this.responseText || '';\n          } catch (e) {}\n\n          var parts = responseText.substr(cache.length).split(\"\\n\"),\n              eventType = 'message',\n              data = [],\n              i = 0,\n              line = '';\n\n          cache = responseText;\n\n          for (; i < parts.length; i++) {\n            line = parts[i].replace(reTrim, '');\n            if (line.indexOf('event') == 0) {\n              eventType = line.replace(/event:?\\s*/, '');\n            } else if (line.indexOf('data') == 0) {\n              data.push(line.replace(/data:?\\s*/, ''));\n            } else if (line.indexOf('id:') == 0) {\n              lastEventId = line.replace(/id:?\\s*/, '');\n            } else if (line.indexOf('id') == 0) {\n              lastEventId = null;\n            } else if (line == '') {\n              if (data.length) {\n                var event = new MessageEvent(data.join('\\n'), eventsource.url, lastEventId);\n                eventsource.dispatchEvent(eventType, event);\n                data = [];\n                eventType = 'message';\n              }\n            }\n          }\n\n          if (this.readyState == 4) pollAgain(this);\n        } else if (eventsource.readyState !== eventsource.CLOSED) {\n          if (this.readyState == 4) {\n            eventsource.readyState = eventsource.CONNECTING;\n            eventsource.dispatchEvent('error', { type: 'error' });\n            pollAgain(this);\n          } else if (this.readyState == 0) {\n            pollAgain(this);\n          }\n        }\n      };\n\n      xhr.send();\n\n      setTimeout(function () {\n        if (true || xhr.readyState == 3) xhr.abort();\n      }, xhr.timeout);\n\n      eventsource._xhr = xhr;\n\n    } catch (e) {\n      eventsource.dispatchEvent('error', { type: 'error', data: e.message });\n    }\n  };\n\n  poll();\n};\n\nEventSource.prototype = {\n  close: function () {\n    this.readyState = this.CLOSED;\n    clearInterval(this._pollTimer);\n    this._xhr.abort();\n  },\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  dispatchEvent: function (type, event) {\n    var handlers = this['_' + type + 'Handlers'];\n    if (handlers) {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i].call(this, event);\n      }\n    }\n\n    if (this['on' + type]) {\n      this['on' + type].call(this, event);\n    }\n  },\n  addEventListener: function (type, handler) {\n    if (!this['_' + type + 'Handlers']) {\n      this['_' + type + 'Handlers'] = [];\n    }\n    this['_' + type + 'Handlers'].push(handler);\n  },\n  removeEventListener: function () {},\n  onerror: null,\n  onmessage: null,\n  onopen: null,\n  readyState: 0,\n  URL: ''\n};\n\nvar MessageEvent = function (data, origin, lastEventId) {\n  this.data = data;\n  this.origin = origin;\n  this.lastEventId = lastEventId || '';\n};\n\nMessageEvent.prototype = {\n  data: null,\n  type: 'message',\n  lastEventId: '',\n  origin: ''\n};",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "class EventSource {\n  constructor(URL) {\n    this.URL = URL;\n    this.readyState = 0;\n    this._pollTimer = null;\n    this._xhr = null;\n    this.poll();\n  }\n\n  poll() {\n    if (this.readyState === 2) {\n      return;\n    }\n\n    this._xhr = new XMLHttpRequest();\n    this._xhr.open(\"GET\", this.URL);\n    this._xhr.withCredentials = true;\n    this._xhr.onreadystatechange = () => {\n      if (this._xhr.readyState === 3 && this._xhr.status === 200) {\n        if (this.readyState === 0) {\n          this.readyState = 1;\n          this.dispatchEvent(\"open\");\n        }\n\n        let data = \"\";\n        try {\n          data = this._xhr.responseText.substring(this._xhr.previousTextLength);\n        } catch (e) {}\n        this._xhr.previousTextLength = this._xhr.responseText.length;\n\n        const events = data.split(\"\\n\\n\");\n        for (const event of events) {\n          if (!event) continue;\n\n          const fields = event.split(\"\\n\");\n          let eventName = \"message\";\n          let eventData = \"\";\n          let lastEventId = \"\";\n\n          for (const field of fields) {\n            const [key, value] = field.split(\":\").map((s) => s.trim());\n            if (key === \"event\") {\n              eventName = value;\n            } else if (key === \"data\") {\n              eventData += (eventData ? \"\\n\" : \"\") + value;\n            } else if (key === \"id\") {\n              lastEventId = value;\n            }\n          }\n\n          this.dispatchEvent(eventName, new MessageEvent(eventData, this.URL, lastEventId));\n        }\n      } else if (this._xhr.readyState === 4) {\n        if (this.readyState !== 2) {\n          this.readyState = 2;\n          this.dispatchEvent(\"error\");\n        }\n        this._pollTimer = setTimeout(() => this.poll(), 5000);\n        this._xhr = null;\n      }\n    };\n    this._xhr.send();\n  }\n\n  close() {\n    if (this._xhr) {\n      this._xhr.abort();\n      this._xhr = null;\n    }\n    if (this._pollTimer) {\n      clearTimeout(this._pollTimer);\n      this._pollTimer = null;\n    }\n    this.readyState = 2;\n  }\n\n  dispatchEvent(type, event) {\n    const handlers = this[`on${type}`];\n    if (handlers) {\n      handlers(event);\n    }\n  }\n\n  addEventListener(type, handler) {\n    this[`on${type}`] = handler;\n  }\n\n  removeEventListener() {}\n}\n\nclass MessageEvent {\n  constructor(data, origin, lastEventId) {\n    this.data = data;\n    this.type = 'message';\n    this.lastEventId = lastEventId;\n    this.origin = origin;\n  }\n}\n"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Implement a request service class that handles HTTP requests including downloading files and performing various HTTP methods (GET, PUT, POST) with proper headers and data handling.\n\nClass Description: The BasicRequestService class implements IRequestService interface to provide HTTP request functionality. It uses XMLHttpRequest for file downloads and umi-request for standard HTTP methods. The class handles permissions checking before downloads and supports configurable request options.\n\nAttributes:\n- requestMethod: RequestMethod - An instance of umi-request's RequestMethod used for standard HTTP requests\n\nMethods:\n- download(url: string) -> Promise<Blob> - Downloads a file from the specified URL after checking permissions. Returns a Promise that resolves with the downloaded Blob.\n  - url: string - The URL of the file to download\n  - Returns: Promise<Blob> - A promise resolving to the downloaded file as a Blob\n\n- request(url: string, options: TRequestOption) -> Promise<any> - Performs an HTTP request based on the specified options (method, headers, data).\n  - url: string - The target URL for the request\n  - options: TRequestOption - Configuration object containing:\n    - method: string - HTTP method ('get', 'put', or 'post')\n    - headers: object - Optional request headers\n    - data: any - Optional request payload\n    - requestType: string - Optional request type for POST requests\n  - Returns: Promise<any> - A promise resolving to the response data\n  - Throws: Error - When an unsupported request method is specified",
    "Canonical_solution": "import { IPermissionsService } from './../../common/permissions';\nimport { extend, RequestMethod } from 'umi-request';\nimport { IRequestService, IBasicRequestService, TRequestOption } from '@/service/common/request';\nimport Container, { Service } from 'typedi';\n\nclass BasicRequestService implements IRequestService {\n  private requestMethod: RequestMethod;\n  constructor() {\n    this.requestMethod = extend({});\n  }\n\n  async download(url: string) {\n    const permissionsService = Container.get(IPermissionsService);\n    await permissionsService.request({ origins: [`${new URL(url).origin}/*`] });\n    return new Promise<Blob>(resolve => {\n      let oReq = new XMLHttpRequest();\n      oReq.open('GET', url, true);\n      oReq.responseType = 'blob';\n      oReq.onload = function() {\n        let blob = oReq.response;\n        resolve(blob);\n      };\n      oReq.send();\n    });\n  }\n\n  request(url: string, options: TRequestOption) {\n    switch (options.method) {\n      case 'get': {\n        return this.requestMethod.get(url, {\n          headers: options.headers,\n        });\n      }\n      case 'put': {\n        return this.requestMethod.put(url, {\n          headers: options.headers,\n          data: options.data,\n        });\n      }\n      case 'post': {\n        return this.requestMethod.post(url, {\n          headers: options.headers,\n          data: options.data,\n          requestType: options.requestType,\n        });\n      }\n      default: {\n        throw new Error('Unsupported request method');\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 93,
    "wrong_result": "```typescript\nimport { RequestMethod } from 'umi-request';\n\nexport enum ERequestMethod {\n  GET = 'get',\n  PUT = 'put',\n  POST = 'post',\n}\n\ntype TRequestOption = {\n  method: ERequestMethod;\n  headers?: object;\n  data?: any;\n  requestType?: string;\n};\n\nexport interface IRequestService {\n  download(url: string): Promise<Blob>;\n  request(url: string, options: TRequestOption): Promise<any>;\n}\n\nexport class BasicRequestService implements IRequestService {\n  requestMethod: RequestMethod;\n\n  constructor() {\n    this.requestMethod = new RequestMethod();\n  }\n\n  async download(url: string): Promise<Blob> {\n    // Placeholder for permissions check, replace with actual implementation\n    const hasPermission = true; \n    if (!hasPermission) {\n      throw new Error('No permission to download');\n    }\n\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error ${response.status}`);\n    }\n    return await response.blob();\n  }\n\n\n  async request(url: string, options: TRequestOption): Promise<any> {\n    const { method, headers, data, requestType } = options;\n\n    let requestOptions: any = { method, headers };\n\n    if (data) {\n      requestOptions.data = data;\n      if (requestType) {\n        requestOptions.requestType = requestType;\n      }\n    }\n\n    try {\n      const response = await this.requestMethod.run(url, requestOptions);\n      return response;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n\n```\n"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a JavaScript class that handles HTTP requests to fetch data from a URL, with support for different data formats and authentication.\n\nClass Description: The DataManURL class provides methods to interact with remote resources via HTTP, supporting operations like fetching data as a buffer, converting to data URI, creating read streams, and retrieving metadata like content type and size.\n\nAttributes:\n- url: [String] - The URL of the remote resource to access\n- _type: [String] - The content type of the resource (e.g., 'image/png')\n- urlOpts: [Object] - Configuration options for the HTTP request (headers, auth, etc.)\n- _size: [Number] - The size in bytes of the fetched resource (cached after first request)\n\nMethods:\n- constructor(url, type, options) -> [void] - Initializes a new DataManURL instance\n  - url: [String] - The target URL\n  - type: [String] - Expected content type (optional)\n  - options: [Object] - Request options including auth and headers (optional)\n\n- getBuffer(callback) -> [void] - Fetches the resource as a binary buffer\n  - callback: [Function] - Receives (error, buffer) parameters\n\n- getDataUri(callback) -> [void] - Converts the resource to a base64 data URI\n  - callback: [Function] - Receives (error, dataUri) parameters\n\n- createReadStream() -> [Stream] - Creates a readable stream of the resource\n  - Returns: [Stream] - Readable stream of the resource data\n\n- size(callback) -> [void] - Gets the resource size in bytes\n  - callback: [Function] - Receives (error, size) parameters\n\n- type() -> [String] - Gets the content type of the resource\n  - Returns: [String] - The content type (may be null if not fetched yet)",
    "Canonical_solution": "var request = Npm.require(\"request\");\n\nclass DataManURL {\n  constructor(url, type, options) {\n    var self = this;\n    options = options || {};\n\n    self.url = url;\n    self._type = type;\n\n    if (options.auth) {\n      if (options.auth.indexOf(':') < 0)\n        throw new Error('auth option should be of the form \"username:password\"');\n      options.headers = options.headers || {};\n      options.headers['Authorization'] = \"Basic \"+\n        (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n      delete options.auth;\n    }\n\n    self.urlOpts = options;\n  }\n\n  getBuffer(callback) {\n    var self = this;\n\n    request(_.extend({\n      url: self.url,\n      method: \"GET\",\n      encoding: null,\n      jar: false\n    }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n      if (err) {\n        callback(err);\n      } else {\n        self._type = res.headers['content-type'];\n        callback(null, body);\n      }\n    }, function(err) {\n      callback(err);\n    }));\n  }\n\n  getDataUri(callback) {\n    var self = this;\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        if (!self._type) {\n          callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n        } else {\n          var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n          callback(null, dataUri);\n        }\n      }\n    });\n  }\n\n  createReadStream() {\n    var self = this;\n    return request(_.extend({\n      url: self.url,\n      method: \"GET\"\n    }, self.urlOpts));\n  }\n\n  size(callback) {\n    var self = this;\n\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n      return;\n    }\n\n    self.getBuffer(function (error, buffer) {\n      if (error) {\n        callback(error);\n      } else {\n        self._size = buffer.length;\n        callback(null, self._size);\n      }\n    });\n  }\n\n  type() {\n    return this._type;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class DataManURL {\n  constructor(url, type, options) {\n    this.url = url;\n    this._type = type;\n    this.urlOpts = options || {};\n    this._size = null;\n  }\n\n  getBuffer(callback) {\n    const fetch = require('node-fetch');\n    fetch(this.url, this.urlOpts)\n      .then(res => {\n        if (!res.ok) {\n          return callback(new Error(`HTTP error ${res.status}`));\n        }\n        this._type = this._type || res.headers.get('content-type');\n        this._size = this._size || Number(res.headers.get('content-length'));\n        return res.buffer();\n      })\n      .then(buffer => callback(null, buffer))\n      .catch(error => callback(error));\n  }\n\n  getDataUri(callback) {\n    this.getBuffer((err, buffer) => {\n      if (err) return callback(err);\n      const base64 = buffer.toString('base64');\n      const dataUri = `data:${this._type};base64,${base64}`;\n      callback(null, dataUri);\n    });\n  }\n\n  createReadStream() {\n    const fetch = require('node-fetch');\n    return fetch(this.url, this.urlOpts).then(res => {\n      if (!res.ok) {\n        throw new Error(`HTTP error ${res.status}`);\n      }\n      this._type = this._type || res.headers.get('content-type');\n      this._size = this._size || Number(res.headers.get('content-length'));\n      return res.body;\n    });\n  }\n\n\n  size(callback) {\n    if (this._size !== null) {\n      callback(null, this._size);\n      return;\n    }\n    const fetch = require('node-fetch');\n    fetch(this.url, this.urlOpts)\n      .then(res => {\n        if (!res.ok) {\n          throw new Error(`HTTP error ${res.status}`);\n        }\n        this._size = Number(res.headers.get('content-length'));\n        callback(null, this._size);\n      })\n      .catch(error => callback(error));\n  }\n\n  type() {\n    return this._type;\n  }\n}\n"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Implement a function to handle form submission asynchronously using XMLHttpRequest in JavaScript. The function should prevent default form submission, process form data, send it to a server via POST request, and handle the server's response to display a thank-you message upon successful submission.\n\nFunction Description: The function `handleFormSubmit` intercepts form submission events, validates the form data (checking for honeypot fields), disables all buttons during submission, sends the form data to a specified URL via POST request, and processes the server's response to update the UI accordingly.\n\nInput: \n- `event`: [Event Object] - The form submission event that triggers this function. The event object contains the target form element and allows prevention of default submission behavior.\n\nOutput: \n- None (void) - The function does not return any value but performs side effects including:\n  - Preventing default form submission\n  - Disabling form buttons during submission\n  - Sending form data to the server\n  - Updating the UI based on server response (resetting form and showing thank-you message)",
    "Canonical_solution": "function handleFormSubmit(event) {\n    event.preventDefault();\n    var form = event.target;\n    var formData = getFormData(form);\n    var data = formData.data;\n\n    if (formData.honeypot) {\n        return false;\n    }\n\n    disableAllButtons(form);\n    var url = form.action;\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            form.reset();\n            var formElements = form.querySelector(\".form-elements\")\n            if (formElements) {\n                formElements.style.display = \"none\";\n            }\n            var thankYouMessage = form.querySelector(\".thankyou_message\");\n            if (thankYouMessage) {\n                thankYouMessage.style.display = \"block\";\n            }\n        }\n    };\n    var encoded = Object.keys(data).map(function(k) {\n        return encodeURIComponent(k) + \"=\" + encodeURIComponent(data[k]);\n    }).join('&');\n    xhr.send(encoded);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "function handleFormSubmit(event) {\n  event.preventDefault();\n  const form = event.target;\n  if (form.querySelector('[name=\"honeypot\"]').value !== '') {\n    return;\n  }\n  const buttons = form.querySelectorAll('button');\n  buttons.forEach(button => button.disabled = true);\n  const formData = new FormData(form);\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', form.action);\n  xhr.onload = function() {\n    if (xhr.status >= 200 && xhr.status < 300) {\n      form.reset();\n      const thankYouMessage = document.createElement('p');\n      thankYouMessage.textContent = 'Thank you for your submission!';\n      form.parentNode.insertBefore(thankYouMessage, form.nextSibling);\n      form.style.display = 'none';\n    } else {\n      console.error('Submission failed. Status:', xhr.status, xhr.statusText);\n      buttons.forEach(button => button.disabled = false);\n    }\n  };\n  xhr.onerror = function() {\n    console.error('Submission failed due to network error.');\n    buttons.forEach(button => button.disabled = false);\n  };\n  xhr.send(formData);\n}\n"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function that sends a POST request to a specified URL with form-urlencoded data and handles the response asynchronously.\n\nFunction Description: The function `sendPostRequest` constructs and sends an HTTP POST request to a given endpoint. It sets the appropriate content type header for form-urlencoded data, includes credentials if needed, and logs the server's response upon completion. This is useful for submitting form data or making authenticated API requests.\n\nInput: None (The URL and data are hardcoded in this example, but could be parameterized in a real implementation)\n\nOutput: None (The function logs the response to the console, but doesn't return anything)",
    "Canonical_solution": "function sendPostRequest() {\n    const data = 'secret=*%5*!';\n    let xhr = new XMLHttpRequest();\n    xhr.withCredentials = true;\n    xhr.open('POST', 'http://localhost:28139/post');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.onload = function() {\n        console.log(xhr.response);\n    };\n    xhr.send(data);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function sendPostRequest() {\n  const url = 'https://example.com/submit';\n  const data = {\n    name: 'John Doe',\n    email: 'john.doe@example.com'\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      credentials: 'include', // Include cookies for authentication\n      body: new URLSearchParams(data).toString()\n    });\n\n    const responseData = await response.text();\n    console.log('Server response:', responseData);\n\n  } catch (error) {\n    console.error('Error sending POST request:', error);\n  }\n}\n\nsendPostRequest();\n\n```"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a function that handles different types of HTTP requests and script imports, then communicates the results back to a sender.\n\nFunction Description: The function `run_test` processes incoming data to determine which type of request or script import to execute. It supports XMLHttpRequest (XHR), Fetch API, and `importScripts` methods. Based on the input data, it initiates the corresponding operation and sends the result or error message back to the sender via the `postMessage` method.\n\nInput:  \n- `data` [String] - A string indicating the type of operation to perform. Valid values are 'xhr', 'fetch', or 'importScripts'.  \n- `sender` [Object] - An object with a `postMessage` method used to send the response or error message back to the caller.\n\nOutput:  \n- No direct return value. The function communicates results asynchronously via `sender.postMessage()`, sending either the response data (for successful operations) or an error message (for failures).  \n\nThe function handles the following cases:  \n1. If `data` is 'xhr', it performs an XMLHttpRequest GET operation and sends the response text or an error message.  \n2. If `data` is 'fetch', it uses the Fetch API to retrieve data and sends the response text or an error message.  \n3. If `data` is 'importScripts', it imports a script and sends a predefined message from the imported script.  \n4. For any other `data` value, it sends an \"Unexpected message\" response.",
    "Canonical_solution": "function run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'synthesized-response.txt', true);\n    xhr.responseType = 'text';\n    xhr.send();\n    xhr.onload = evt => sender.postMessage(xhr.responseText);\n    xhr.onerror = () => sender.postMessage('XHR failed!');\n  } else if (data === 'fetch') {\n    fetch('synthesized-response.txt')\n        .then(response => response.text())\n        .then(data => sender.postMessage(data))\n        .catch(error => sender.postMessage('Fetch failed!'));\n  } else if (data === 'importScripts') {\n    importScripts('synthesized-response.js');\n    sender.postMessage(message);\n  } else {\n    sender.postMessage('Unexpected message! ' + data);\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nfunction run_test(data, sender) {\n  if (data === 'xhr') {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'https://www.example.com');\n    xhr.onload = () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        sender.postMessage(xhr.responseText);\n      } else {\n        sender.postMessage('XHR failed with status ' + xhr.status);\n      }\n    };\n    xhr.onerror = () => {\n      sender.postMessage('XHR failed');\n    };\n    xhr.send();\n  } else if (data === 'fetch') {\n    fetch('https://www.example.com')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Fetch failed with status ' + response.status);\n        }\n        return response.text();\n      })\n      .then(text => sender.postMessage(text))\n      .catch(error => sender.postMessage(error.message));\n  } else if (data === 'importScripts') {\n    try {\n      importScripts('imported_script.js');\n      sender.postMessage(messageFromImportedScript);\n    } catch (error) {\n      sender.postMessage('importScripts failed: ' + error.message);\n    }\n  } else {\n    sender.postMessage('Unexpected message');\n  }\n}\n\n```\n```javascript\n// imported_script.js\nconst messageFromImportedScript = 'Message from imported script';\n```\n"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a function that asynchronously loads YAML content from a specified URL and processes it using a callback function.\n\nFunction Description: The function `loadYamlUrl` initiates an HTTP GET request to fetch YAML content from a given URL. It handles the response asynchronously, checking for a successful status code (200) before passing the YAML text to a processing function (`yamlToForm`) and logging the response to the console.\n\nInput: \n- `url` [String] - The URL from which to fetch the YAML content.\n\nOutput: \n- None (The function does not return a value directly but processes the YAML content via the `yamlToForm` callback and logs the response to the console.)",
    "Canonical_solution": "function loadYamlUrl(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'text';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            yamlToForm(this.response);\n            console.log(this.response);\n        }\n    };\n    xhr.send();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 93,
    "wrong_result": "```javascript\nasync function loadYamlUrl(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error ${response.status}`);\n    }\n    const yamlText = await response.text();\n    const yaml = jsyaml.load(yamlText);\n    yamlToForm(yaml);\n    console.log(yaml)\n  } catch (error) {\n    console.error(\"Error loading YAML:\", error);\n  }\n}\n\nfunction yamlToForm(yamlData) {\n    // Placeholder for processing the YAML data\n    console.log(\"YAML data processed:\", yamlData);\n}\n\n\n```"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs from multiple services (is.gd, goo.gl, budurl.com, snipurl.com, etc.) by making HTTP requests to their APIs or following HTTP redirects. It handles recursive expansion with depth control and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening services to their domain names\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration\n- expand(args: [Object], callback: [Function]) -> [void] - Recursively expands a shortened URL\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to call with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n      - err: [Error] - Any error that occurred (optional)\n      - headers: [Object] - Response headers (optional)\n      - urlp: [Object] - Parsed URL object (optional)",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        }.bind(this),\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }.bind(this)\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nclass URLExpander {\n  constructor() {\n    this.map = {\n      'is.gd': 'is.gd',\n      'goo.gl': 'goo.gl',\n      'budurl.com': 'budurl.com',\n      'snipurl.com': 'snipurl.com',\n    };\n    this.timeout = 5000;\n    this.APIs = {};\n  }\n\n  expand(args, callback) {\n    let { url, depth = 0, seen = {} } = args;\n\n    if (depth > 10) {\n      return callback({ ...args, err: new Error('Maximum depth exceeded') });\n    }\n\n    if (seen[url]) {\n      return callback({ ...args, err: new Error('Cycle detected') });\n    }\n    seen[url] = true;\n\n    let urlp = new URL(url);\n    let domain = urlp.hostname;\n\n    if (this.APIs[domain]) {\n      this.APIs[domain](url, (err, expandedURL) => {\n        if (err) return callback({ ...args, err });\n        this.expand({ ...args, url: expandedURL, depth: depth + 1, seen }, callback);\n      });\n    } else {\n      const req = new XMLHttpRequest();\n      req.open('GET', url, true);\n      req.timeout = this.timeout;\n      req.ontimeout = () => callback({ ...args, err: new Error('Request timed out') });\n      req.onerror = () => callback({ ...args, err: new Error('Request failed') });\n\n      req.onload = () => {\n        if (req.status >= 200 && req.status < 300) {\n          callback({ ...args, url: req.responseURL, depth: depth + 1, seen, headers: req.getAllResponseHeaders(), urlp });\n        } else if (req.status >= 300 && req.status < 400 && req.responseURL) {\n          this.expand({ ...args, url: req.responseURL, depth: depth + 1, seen }, callback);\n        } else {\n          callback({ ...args, err: new Error(`HTTP error ${req.status}`) });\n        }\n      };\n      req.send();\n    }\n  }\n}\n\n```"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a reusable HTTP server class in JavaScript using the Express framework that can handle various HTTP methods, middleware configuration, and file uploads.\n\nClass Description: The HTTPServer class encapsulates an Express application with configurable routes, middleware, and file upload capabilities. It provides methods to start/stop the server and add route handlers for different HTTP methods.\n\nAttributes:\n- app: [Object] - The Express application instance\n- port: [Number] - The port number the server listens on\n- server: [Object|null] - The HTTP server instance (null before starting)\n\nMethods:\n- constructor(port) -> [HTTPServer] - Initializes the Express app with middleware and file upload handling\n- start() -> [Promise] - Starts the server on the specified port\n- stop() -> [void] - Stops the server if running\n- addRoute(method, path, handler) -> [void] - Adds a route handler for a specific HTTP method\n- get(path, handler) -> [void] - Adds a GET route handler\n- post(path, handler) -> [void] - Adds a POST route handler\n- put(path, handler) -> [void] - Adds a PUT route handler\n- delete(path, handler) -> [void] - Adds a DELETE route handler\n- patch(path, handler) -> [void] - Adds a PATCH route handler\n- options(path, handler) -> [void] - Adds an OPTIONS route handler\n- trace(path, handler) -> [void] - Adds a TRACE route handler\n- head(path, handler) -> [void] - Adds a HEAD route handler",
    "Canonical_solution": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst multer = require(\"multer\");\n\nclass HTTPServer {\n    constructor(port) {\n        this.app = express();\n        this.port = port;\n        this.server = null;\n        \n        // Configure middleware\n        this.app.use(bodyParser.raw({type:\"*/*\"}));\n        this.app.use(cookieParser(undefined,{decode:String}));\n        \n        // File upload handling\n        const fileUploadApp = express();\n        const mp = multer({ storage: multer.memoryStorage() }).any();\n        fileUploadApp.post(\"/file-upload\",function(req,res,next) {\n            mp(req,res,function(err) {\n                req._body = true;\n                next(err);\n            })\n        },bodyParser.json(),function(req,res) {\n            res.json({\n                body: req.body,\n                files: req.files\n            })\n        });\n        this.app.use(fileUploadApp);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            this.server = this.app.listen(this.port, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n\n    addRoute(method, path, handler) {\n        this.app[method.toLowerCase()](path, handler);\n    }\n\n    get(path, handler) {\n        this.addRoute('get', path, handler);\n    }\n\n    post(path, handler) {\n        this.addRoute('post', path, handler);\n    }\n\n    put(path, handler) {\n        this.addRoute('put', path, handler);\n    }\n\n    delete(path, handler) {\n        this.addRoute('delete', path, handler);\n    }\n\n    patch(path, handler) {\n        this.addRoute('patch', path, handler);\n    }\n\n    options(path, handler) {\n        this.addRoute('options', path, handler);\n    }\n\n    trace(path, handler) {\n        this.addRoute('trace', path, handler);\n    }\n\n    head(path, handler) {\n        this.addRoute('head', path, handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst multer = require('multer');\nconst upload = multer();\n\nclass HTTPServer {\n  constructor(port) {\n    this.app = express();\n    this.port = port;\n    this.server = null;\n\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n    this.app.use(upload.any());\n  }\n\n  start() {\n    return new Promise((resolve, reject) => {\n      this.server = this.app.listen(this.port, () => {\n        console.log(`Server listening on port ${this.port}`);\n        resolve();\n      }).on('error', reject);\n    });\n  }\n\n  stop() {\n    if (this.server) {\n      this.server.close();\n      this.server = null;\n    }\n  }\n\n  addRoute(method, path, handler) {\n    this.app[method](path, handler);\n  }\n\n  get(path, handler) {\n    this.addRoute('get', path, handler);\n  }\n\n  post(path, handler) {\n    this.addRoute('post', path, handler);\n  }\n\n  put(path, handler) {\n    this.addRoute('put', path, handler);\n  }\n\n  delete(path, handler) {\n    this.addRoute('delete', path, handler);\n  }\n\n  patch(path, handler) {\n    this.addRoute('patch', path, handler);\n  }\n\n  options(path, handler) {\n    this.addRoute('options', path, handler);\n  }\n  trace(path, handler) {\n    this.addRoute('trace', path, handler)\n  }\n  head(path, handler) {\n    this.addRoute('head', path, handler)\n  }\n}\n"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Implement a Twitter HTTP client class in JavaScript that handles API requests to Twitter, including request construction, execution, and response processing with error handling and clock synchronization.\n\nClass Description: The TwitterHTTPClient class provides methods to interact with Twitter's REST API. It handles HTTP requests (GET/POST), manages authentication, processes responses, and maintains clock synchronization with Twitter's servers.\n\nAttributes:\n- config: [Object] - Configuration object containing API credentials and settings\n- _twitter_time_minus_local_time_ms: [Number] - Time difference between Twitter's server time and local time in milliseconds\n\nMethods:\n- constructor(config) -> [TwitterHTTPClient] - Initializes the client with configuration\n- request(method, path, params, callback) -> [Promise] - Makes HTTP requests to Twitter API\n- _doRestApiRequest(reqOpts, twitOptions, method, callback) -> [void] - Executes the actual HTTP request\n- _updateClockOffsetFromResponse(resp) -> [void] - Updates the clock offset based on Twitter's server time\n\nMethod Details:\n1. request(method, path, params, callback)\n   - Input:\n     - method: [String] - HTTP method ('GET' or 'POST')\n     - path: [String] - API endpoint path\n     - params: [Object] - Request parameters\n     - callback: [Function] - Callback function for handling response\n   - Output: [Promise] - Resolves with response data or rejects with error\n\n2. _doRestApiRequest(reqOpts, twitOptions, method, callback)\n   - Input:\n     - reqOpts: [Object] - Request options including URL and headers\n     - twitOptions: [Object] - Twitter-specific options\n     - method: [String] - HTTP method\n     - callback: [Function] - Callback for handling response\n   - Output: [void] - Calls callback with response data or error\n\n3. _updateClockOffsetFromResponse(resp)\n   - Input:\n     - resp: [Object] - HTTP response object\n   - Output: [void] - Updates internal clock offset value",
    "Canonical_solution": "var request = require('request');\nvar helpers = require('./helpers');\n\nclass TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    var self = this;\n    assert(method == 'GET' || method == 'POST');\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      var _returnErrorToUser = function (err) {\n        if (callback && typeof callback === 'function') {\n          callback(err, null, null);\n        }\n        reject(err);\n      }\n\n      self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n        if (err) {\n          _returnErrorToUser(err);\n          return;\n        }\n\n        var twitOptions = (params && params.twit_options) || {};\n\n        process.nextTick(function () {\n          self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n            self._updateClockOffsetFromResponse(resp);\n\n            if (self.config.trusted_cert_fingerprints) {\n              if (!resp.socket.authorized) {\n                var authErrMsg = resp.socket.authorizationError.toString();\n                var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n              var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n              var trustedFingerprints = self.config.trusted_cert_fingerprints;\n              if (trustedFingerprints.indexOf(fingerprint) === -1) {\n                var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                         trustedFingerprints.join(','), fingerprint);\n                var err = new Error(errMsg);\n                _returnErrorToUser(err);\n                return;\n              }\n            }\n\n            if (callback && typeof callback === 'function') {\n              callback(err, parsedBody, resp);\n            }\n\n            resolve({ data: parsedBody, resp: resp });\n            return;\n          });\n        });\n      });\n    });\n  }\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    var request_method = request[method.toLowerCase()];\n    var req = request_method(reqOpts);\n\n    var body = '';\n    var response = null;\n\n    var onRequestComplete = function () {\n      if (body !== '') {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON');\n          err.statusCode = response ? response.statusCode: null;\n          err.allErrors.concat({error: jsonDecodeError.toString()});\n          callback(err, body, response);\n          return;\n        }\n      }\n\n      if (typeof body === 'object' && (body.error || body.errors)) {\n        var err = helpers.makeTwitError('Twitter API Error');\n        err.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n\n      callback(err, body, response);\n    }\n\n    req.on('response', function (res) {\n      response = res;\n      req.on('data', function (chunk) {\n        body += chunk.toString('utf8');\n      });\n      req.on('end', function () {\n        onRequestComplete();\n      });\n    });\n\n    req.on('error', function (err) {\n      if (twitOptions.retry &&\n          STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n      ) {\n        self.request(method, path, params, callback);\n        return;\n      } else {\n        err.statusCode = null;\n        err.code = null;\n        err.allErrors = [];\n        helpers.attachBodyInfoToError(err, body);\n        callback(err, body, response);\n        return;\n      }\n    });\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    var self = this;\n    if (resp && resp.headers && resp.headers.date &&\n        new Date(resp.headers.date).toString() !== 'Invalid Date'\n    ) {\n      var twitterTimeMs = new Date(resp.headers.date).getTime();\n      self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class TwitterHTTPClient {\n  constructor(config) {\n    this.config = config;\n    this._twitter_time_minus_local_time_ms = 0;\n  }\n\n  request(method, path, params, callback) {\n    return new Promise((resolve, reject) => {\n      method = method.toUpperCase();\n      const url = this.config.api_url + path + '.json';\n\n      const reqOpts = {\n        url: url,\n        method: method,\n        headers: {\n          'Authorization': 'OAuth ' + this._getOAuthHeader(method, url, params),\n          'User-Agent': this.config.user_agent\n        }\n      };\n\n      this._doRestApiRequest(reqOpts, {}, method, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n        if (callback) {\n          callback(err, data);\n        }\n      });\n    });\n  }\n\n\n  _doRestApiRequest(reqOpts, twitOptions, method, callback) {\n    const req = require('https').request(reqOpts, (resp) => {\n      let data = '';\n      resp.setEncoding('utf8');\n      resp.on('data', (chunk) => data += chunk);\n      resp.on('end', () => {\n        this._updateClockOffsetFromResponse(resp);\n        let parsedData;\n        try {\n          parsedData = JSON.parse(data);\n        } catch (e) {\n          return callback(e);\n        }\n        if (parsedData.errors) {\n          return callback(parsedData.errors);\n        }\n        callback(null, parsedData);\n      });\n    });\n\n    req.on('error', (err) => callback(err));\n    if (method === 'POST' && twitOptions.form) {\n      req.write(twitOptions.form);\n    }\n    req.end();\n  }\n\n  _getOAuthHeader(method, url, params) {\n    // Placeholder for OAuth header generation logic\n    // This should be implemented based on your specific OAuth setup\n    return 'OAuth-Generated-Header';\n  }\n\n  _updateClockOffsetFromResponse(resp) {\n    const serverTime = parseInt(resp.headers['date'], 10);\n    if (!isNaN(serverTime)) {\n      this._twitter_time_minus_local_time_ms = serverTime - Date.now();\n    }\n  }\n}\n"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a URL expander class that can recursively resolve shortened URLs from various URL shortening services by making HTTP requests to their respective APIs or following redirects.\n\nClass Description: The URLExpander class provides functionality to expand shortened URLs by detecting the shortening service and using the appropriate API or HTTP HEAD request to follow redirects. It handles recursive expansion with depth limiting and cycle detection.\n\nAttributes:\n- map: [Object] - A mapping of URL shortening service names to their associated domains\n- timeout: [Number] - The timeout duration in milliseconds for HTTP requests\n- APIs: [Object] - Contains methods for handling different URL shortening services\n\nMethods:\n- constructor() -> [void] - Initializes the URL expander with default configuration including known URL shortening services and timeout\n- expand(args: [Object], callback: [Function]) -> [void] - The main method that initiates URL expansion\n  - args: Object containing:\n    - url: [String] - The URL to expand\n    - depth: [Number] - Current recursion depth (optional)\n    - seen: [Object] - Map of already seen URLs to prevent cycles (optional)\n  - callback: Function to be called with the result\n    - Receives modified args object containing:\n      - url: [String] - Final expanded URL\n      - err: [Error] - Any error encountered (optional)\n      - headers: [Object] - Response headers (optional)\n      - depth: [Number] - Final recursion depth\n      - seen: [Object] - Map of seen URLs\n\nThe class includes several internal API methods (isgd, googl, budurl, snipurl, generic) that handle specific URL shortening services or generic URL expansion through HTTP HEAD requests. These methods are not meant to be called directly but are used internally by the expand method.",
    "Canonical_solution": "var urllib = require('url');\nvar request = require('request');\nvar querystring = require('querystring');\n\nclass URLExpander {\n    constructor() {\n        this.map = {\n            isgd: ['is.gd'],\n            googl: ['goo.gl'],\n            budurl: ['budurl.com'],\n            snipurl: ['snipurl.com', 'snurl.com', 'snurl.com', 'cl.lk', 'snipr.com', 'sn.im']\n        };\n        this.timeout = 5000;\n    }\n\n    expand(args, callback) {\n        if(!args || !args.url || typeof(args.url) != 'string') return callback(args);\n\n        if(!args.depth) args.depth = 0;\n        if(!args.seen) args.seen = {};\n\n        if(args.depth > 5) return callback(args);\n\n        if(args.seen[args.url]) return callback(args);\n        args.seen[args.url] = true;\n\n        args.urlp = urllib.parse(args.url);\n        if(!args.urlp) return callback(args);\n\n        if(args.urlp.protocol != 'http:') return callback(args);\n\n        args.depth++;\n\n        try {\n            for (var k in this.map) {\n                if (this.map[k].indexOf(args.urlp.host) > -1) return this.APIs[k](args, callback);\n            }\n            return this.APIs.generic(args, callback);\n        } catch(E) {\n            args.err = E;\n            return callback(args);\n        }\n    }\n\n    APIs = {\n        isgd: function (args, callback) {\n            var url = 'http://is.gd/forward.php?' + querystring.stringify({format: 'json', shorturl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.url) {\n                    args.url = body.url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        googl: function (args, callback) {\n            var url = 'https://www.googleapis.com/urlshortener/v1/url?'+querystring.stringify({shortUrl: args.urlp.href});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.longUrl) {\n                    args.url = body.longUrl;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        budurl: function (args, callback) {\n            var url = 'http://budurl.com/api/v1/budurls/expand?'+querystring.stringify({budurl: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout, json:true}, function(err, res, body){\n                if(body && body.long_url) {\n                    args.url = body.long_url;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        snipurl: function (args, callback) {\n            var url = 'http://snipurl.com/resolveurl?'+querystring.stringify({id: args.urlp.pathname.replace('/', '')});\n            request.get({url:url, timeout:this.timeout}, function(err, res, body){\n                if(body) {\n                    args.url = body;\n                    return this.expand(args, callback);\n                }\n                return this.APIs.generic(args, callback);\n            }.bind(this));\n        },\n\n        generic: function (args, callback) {\n            var headers = (args.urlp.host === \"t.co\")?{}:{'User-Agent': 'AppleWebKit/525.13 (KHTML, like Gecko) Safari/525.13.'};\n            if(args.headers && args.headers['set-cookie']) headers['Cookie'] = args.headers['set-cookie'];\n            request.head({url:args.url, headers:headers, followRedirect:false}, function(err, res){\n                if(err) { args.err = err; return callback(args); }\n                if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                    var newup = urllib.parse(urllib.resolve(args.urlp,urllib.parse(res.headers.location)));\n                    if (!newup || !newup.pathname) return callback(args);\n                    if(newup.pathname.indexOf(\"login\") > 0 && newup.pathname.indexOf(\"login\") < 10) return callback(args);\n                    args.url = urllib.format(newup);\n                    args.headers = res.headers;\n                    return this.expand(args, callback);\n                }\n                args.headers = res.headers;\n                return callback(args);\n            }.bind(this));\n        }\n    };\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 95,
    "wrong_result": "class URLExpander {\n  constructor() {\n    this.map = {\n      bitly: ['bit.ly', 'j.mp', 'bitly.com'],\n      isgd: ['is.gd'],\n      googl: ['goo.gl'],\n      budurl: ['budurl.com'],\n      snipurl: ['snipurl.com'],\n      tinyurl: ['tinyurl.com']\n    };\n    this.timeout = 5000;\n    this.APIs = {\n      isgd: this.isgd.bind(this),\n      googl: this.googl.bind(this),\n      budurl: this.budurl.bind(this),\n      snipurl: this.snipurl.bind(this),\n      generic: this.generic.bind(this)\n    };\n  }\n\n  expand(args, callback) {\n    let { url, depth = 0, seen = {} } = args;\n\n    if (depth > 5) {\n      return callback({ ...args, err: new Error('Too many redirects') });\n    }\n\n    if (seen[url]) {\n      return callback({ ...args, err: new Error('Cycle detected') });\n    }\n    seen[url] = true;\n\n    let method = 'generic';\n    for (const k in this.map) {\n      if (this.map[k].some(domain => url.includes(domain))) {\n        method = k;\n        break;\n      }\n    }\n\n    this.APIs[method](args, callback);\n  }\n\n\n  isgd(args, callback) {\n    const { url } = args;\n    const expandedURL = url.replace(/^https?:\\/\\/is\\.gd\\/([a-zA-Z0-9]+)$/, 'https://is.gd/$1');\n    this.generic({ ...args, url: expandedURL }, callback);\n  }\n\n  googl(args, callback) {\n    const { url } = args;\n    this.generic({ ...args, url: url.replace(/^https?:\\/\\/goo\\.gl\\/([a-zA-Z0-9-_]+)$/, 'https://goo.gl/$1') }, callback);\n  }\n\n  budurl(args, callback) {\n    const { url } = args;\n    this.generic({ ...args, url: url.replace(/^https?:\\/\\/budurl\\.com\\/([a-zA-Z0-9]+)$/, 'https://budurl.com/$1') }, callback);\n  }\n\n  snipurl(args, callback) {\n    const { url } = args;\n    this.generic({ ...args, url: url.replace(/^https?:\\/\\/snipurl\\.com\\/([a-zA-Z0-9]+)$/, 'https://snipurl.com/$1') }, callback);\n  }\n\n  generic(args, callback) {\n    const { url, depth, seen } = args;\n    const options = {\n      method: 'HEAD',\n      timeout: this.timeout,\n      redirect: 'manual'\n    };\n\n    fetch(url, options)\n      .then(res => {\n        if (res.status === 301 || res.status === 302 || res.status === 307 || res.status === 308) {\n          this.expand({ url: res.headers.get('location'), depth: depth + 1, seen }, callback);\n        } else {\n          callback({ ...args, url, headers: Object.fromEntries(res.headers), depth, seen });\n        }\n      })\n      .catch(err => callback({ ...args, err, depth, seen }));\n  }\n}\n\n"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a function that makes an HTTP request to a specified URL with custom headers and handles the response.\n\nFunction Description: The function `makeHttpRequest` performs an HTTP GET request to a specified URL with custom headers and decompresses gzip-encoded responses. It uses the `request` module to send the request and handles the response through a callback function that checks for errors and logs the response body if successful.\n\nInput: None (The URL and headers are hardcoded within the function.)\n\nOutput: None (The function logs the response body to the console if the request is successful.)",
    "Canonical_solution": "function makeHttpRequest() {\n    var request = require('request');\n    \n    var headers = {\n        'Accept-Encoding': 'gzip, deflate, sdch',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Referer': 'http://www.wikipedia.org/',\n        'Cookie': 'GeoIP=US:Albuquerque:35.1241:-106.7675:v4; uls-previous-languages=%5B%22en%22%5D; mediaWiki.user.sessionId=VaHaeVW3m0ymvx9kacwshZIDkv8zgF9y; centralnotice_buckets_by_campaign=%7B%22C14_enUS_dsk_lw_FR%22%3A%7B%22val%22%3A%220%22%2C%22start%22%3A1412172000%2C%22end%22%3A1422576000%7D%2C%22C14_en5C_dec_dsk_FR%22%3A%7B%22val%22%3A3%2C%22start%22%3A1417514400%2C%22end%22%3A1425290400%7D%2C%22C14_en5C_bkup_dsk_FR%22%3A%7B%22val%22%3A1%2C%22start%22%3A1417428000%2C%22end%22%3A1425290400%7D%7D; centralnotice_bannercount_fr12=22; centralnotice_bannercount_fr12-wait=14',\n        'Connection': 'keep-alive'\n    };\n\n    var options = {\n        url: 'http://localhost:28139/',\n        headers: headers,\n        gzip: true\n    };\n\n    function callback(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(body);\n        }\n    }\n\n    request(options, callback);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 95,
    "wrong_result": "```javascript\nconst request = require('request');\nconst zlib = require('zlib');\n\nfunction makeHttpRequest() {\n  const url = 'https://example.com';\n  const headers = {\n    'User-Agent': 'MyCustomUserAgent',\n    'Accept-Encoding': 'gzip'\n  };\n\n  const options = {\n    url: url,\n    headers: headers,\n    encoding: null // Important: Set encoding to null to handle compressed responses\n  };\n\n  request(options, (error, response, body) => {\n    if (error) {\n      console.error('Error:', error);\n      return;\n    }\n\n    if (response.statusCode !== 200) {\n      console.error('Status Code:', response.statusCode);\n      return;\n    }\n\n    const encoding = response.headers['content-encoding'];\n\n    if (encoding && encoding.includes('gzip')) {\n      zlib.gunzip(body, (err, decompressedBody) => {\n        if (err) {\n          console.error('Decompression Error:', err);\n        } else {\n          console.log(decompressedBody.toString());\n        }\n      });\n    } else {\n      console.log(body.toString());\n    }\n  });\n}\n\nmakeHttpRequest();\n```\n"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a function to set up an Express server with session management using MongoDB as the session store, and integrate it with Next.js for server-side rendering.\n\nFunction Description: The function `setupServer` initializes an Express server with session management configured to use MongoDB for session storage. It integrates with Next.js for handling server-side rendering and routes all requests to the Next.js request handler. The server listens on a specified port and logs the root URL when ready.\n\nInput: None (The function uses environment variables for configuration:\n- `process.env.NODE_ENV`: Determines if the environment is production or development\n- `process.env.MONGO_URL_TEST`: MongoDB connection URL\n- `process.env.PORT`: Port number to listen on (defaults to 8000)\n- `process.env.SESSION_NAME`: Name for the session cookie\n- `process.env.SESSION_SECRET`: Secret key for session encryption)\n\nOutput: None (The function starts an Express server that listens on the specified port and handles requests. It logs the root URL to the console when the server is ready.)",
    "Canonical_solution": "function setupServer() {\n    const express = require('express');\n    const session = require('express-session');\n    const mongoSessionStore = require('connect-mongo');\n    const next = require('next');\n    const mongoose = require('mongoose');\n\n    const dev = process.env.NODE_ENV !== 'production';\n    const MONGO_URL = process.env.MONGO_URL_TEST;\n    const port = process.env.PORT || 8000;\n    const ROOT_URL = `http://localhost:${port}`;\n\n    const app = next({ dev });\n    const handle = app.getRequestHandler();\n\n    const server = express();\n\n    const sessionOptions = {\n        name: process.env.SESSION_NAME,\n        secret: process.env.SESSION_SECRET,\n        store: mongoSessionStore.create({\n            mongoUrl: MONGO_URL,\n            ttl: 14 * 24 * 60 * 60,\n        }),\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            httpOnly: true,\n            maxAge: 14 * 24 * 60 * 60 * 1000,\n            domain: 'localhost',\n        },\n    };\n\n    const sessionMiddleware = session(sessionOptions);\n    server.use(sessionMiddleware);\n\n    server.get('*', (req, res) => handle(req, res));\n\n    server.listen(port, (err) => {\n        if (err) throw err;\n        console.log(`> Ready on ${ROOT_URL}`);\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "```javascript\nconst express = require('express');\nconst next = require('next');\nconst session = require('express-session');\nconst connectMongo = require('connect-mongo');\n\nconst MongoStore = connectMongo(session);\n\nconst setupServer = async () => {\n  const dev = process.env.NODE_ENV !== 'production';\n  const app = next({ dev });\n  const handle = app.getRequestHandler();\n  await app.prepare();\n\n  const server = express();\n\n  server.use(\n    session({\n      name: process.env.SESSION_NAME,\n      secret: process.env.SESSION_SECRET,\n      store: new MongoStore({\n        url: process.env.MONGO_URL_TEST,\n        ttl: 14 * 24 * 60 * 60, // save session 14 days\n      }),\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        httpOnly: true,\n        maxAge: 1000 * 60 * 60 * 24 * 14, // 14 days\n        sameSite: 'lax',\n        secure: process.env.NODE_ENV === 'production', // cookie only works in https\n      },\n    })\n  );\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(process.env.PORT || 8000, () => {\n    console.log(`> Ready on http://localhost:${process.env.PORT || 8000}`);\n  });\n};\n\nmodule.exports = setupServer;\n\n```"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a function to set up an Express server that serves static files for a specific route.\n\nFunction Description: The function `setupServer` initializes an Express application, configures a route to serve a static HTML file, and starts the server on port 3000. It is designed to handle GET requests for the '/users' path by sending the corresponding HTML file.\n\nInput: None\n\nOutput: None (The function starts the server and logs a message to the console when the server is running.)",
    "Canonical_solution": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n    const app = express();\n    \n    app.get('/users', function (req, res) {\n        res.sendFile(path.join(__dirname, 'modules/users/views/list.html'));\n    });\n\n    app.listen(3000, function () {\n        console.log('Servidor rodando em localhost:3000');\n    });\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 96,
    "wrong_result": "const express = require('express');\nconst path = require('path');\n\nfunction setupServer() {\n  const app = express();\n  const staticPath = path.join(__dirname, 'public');\n\n  app.use('/users', express.static(staticPath));\n\n  app.listen(3000, () => {\n    console.log('Server running on port 3000');\n  });\n}\n\nsetupServer();\n"
  }
]